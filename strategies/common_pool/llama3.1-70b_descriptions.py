"""
Strategy descriptions for common_pool.

Generated with:
- Provider: Client
- Model: llama3.1:70b
"""


description_COLLECTIVE_1 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative tone and encourage others to do the same.
2. **Subsequent Rounds (t>1):**
	* Calculate the current stock level as a fraction of the capacity: `stock_fraction = current_stock / capacity`.
	* If `stock_fraction` is above a certain threshold (`threshold`), Cooperate (C). Otherwise, Defect (D).
	* The `threshold` value will be adjusted dynamically based on the game's history.
3. **Threshold Adjustment:**
	* If the average payoff per player in the previous round is above a certain target payoff (`target_payoff`), increase the `threshold` by a small amount (`delta_threshold`). This encourages cooperation when the collective payoff is high.
	* If the average payoff per player in the previous round is below the `target_payoff`, decrease the `threshold` by `delta_threshold`. This allows for more defection when the collective payoff is low.

**Pseudocode:**
```python
def ACST(n, capacity, current_stock, history):
    if t == 1:
        return C  # Cooperate in the first round

    stock_fraction = current_stock / capacity
    threshold = initial_threshold  # Initialize threshold value

    for previous_round in history:
        average_payoff = sum(previous_round.payoffs) / n
        if average_payoff > target_payoff:
            threshold += delta_threshold
        else:
            threshold -= delta_threshold

    if stock_fraction >= threshold:
        return C  # Cooperate if stock fraction is above the threshold
    else:
        return D  # Defect otherwise
```
**Handling Edge Cases:**

* **Last Round (t=r):** Play the same strategy as in previous rounds, without adjusting the `threshold` value.
* **Low Stock Levels:** If the current stock level is very low (`current_stock < epsilon * capacity`, where `epsilon` is a small positive value), Defect (D) to ensure some payoff.

**Collective Mindset:**

The ACST strategy aims to balance individual payoffs with collective sustainability. By adjusting the cooperation threshold based on the game's history, it encourages cooperation when the collective payoff is high and allows for more defection when the collective payoff is low. This adaptive approach promotes a stable and resilient collective behavior.

**Tournament Readiness:**

The ACST strategy does not rely on specific coordination mechanisms or norms shared among players. It can be implemented independently and will adapt to various opponent behaviors, making it robust in a tournament setting.
'''

description_COLLECTIVE_2 = '''
To design a collective strategy for this Common Pool Resource Game that is adaptive and robust, I propose a hybrid approach combining elements of tit-for-tat (TFT), grim trigger, and a capacity-aware consumption adjustment mechanism.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative baseline and encourage other players to cooperate.
2. **Subsequent Rounds:** Implement a modified TFT strategy with a capacity-aware twist:
	* If at least 75% of players cooperated in the previous round, Cooperate (C).
	* If fewer than 75% of players cooperated, Defect (D) but adjust consumption based on the current stock level and capacity.
3. **Capacity-Aware Consumption Adjustment:** When defecting, calculate a "safe" consumption rate that balances short-term gain with long-term sustainability:
	+ Calculate the remaining stock-to-capacity ratio: `stock_ratio = current_stock / capacity`
	+ If `stock_ratio` is below 0.5, consume at a reduced rate of `min(stock/n, stock/(2n))`
	+ Otherwise, consume at the standard defect rate of `stock/n`

**Edge Cases:**

1. **Last Round:** Cooperate (C) in the final round to maximize collective payoff and encourage others to do the same.
2. **Low Stock Levels:** If the current stock level is below 25% of capacity (`current_stock < 0.25 * capacity`), Cooperate (C) to help replenish the stock.

**Pseudocode:**
```python
def common_pool_strategy(n, r, capacity, history):
    if round == 1:
        # Initial round: cooperate
        return "C"
    
    prev_coop_count = sum(1 for action in history[-1] if action == "C")
    coop_threshold = 0.75 * n
    
    if prev_coop_count >= coop_threshold:
        # TFT-like cooperation
        return "C"
    else:
        stock_ratio = current_stock / capacity
        
        if stock_ratio < 0.5:
            # Reduced consumption rate when defecting and low stock levels
            return "D" with reduced consumption
        else:
            # Standard defect rate
            return "D"

def calculate_reduced_consumption(stock, n):
    return min(stock/n, stock/(2n))
```
**Collective Mindset:**

This strategy prioritizes cooperation while being aware of the collective impact on the common pool resource. By adjusting consumption rates based on capacity and stock levels, it balances individual gains with long-term sustainability. The TFT-like mechanism encourages cooperation and punishes defection, while the reduced consumption rate when defecting helps maintain a stable stock level.

This hybrid approach is designed to perform well in a tournament setting against independent strategies, as it adapts to various opponent behaviors and prioritizes collective welfare.
'''

description_COLLECTIVE_3 = '''
**Collective Strategy: "Adaptive Stock Saver"**

Our collective strategy aims to balance individual payoffs with long-term sustainability of the common pool resource. We'll adapt to changing stock levels and opponent behaviors while maintaining a robust, cooperative approach.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to follow suit.
2. **Stock-dependent Cooperation**: For subsequent rounds, calculate the "Cooperation Threshold" (CT):

   CT = (capacity / 2n) \* (stock / capacity)

If the current stock level is above CT, Cooperate (C). Otherwise, Defect (D).

3. **Opponent Behavior Response**: Monitor opponents' actions in previous rounds and adjust our strategy accordingly:
	* If at least half of opponents cooperated in the last round, continue to Cooperate (C).
	* If more than half defected, switch to Defect (D) for one round.
4. **Last Round Exception**: In the final round, always Defect (D) to maximize individual payoff.

**Pseudocode:**

```
def adaptive_stock_saver(stock, capacity, n, history):
    if first_round():
        return C  # Cooperate in initial round

    CT = (capacity / 2n) * (stock / capacity)

    if stock > CT:
        cooperation_choice = C
    else:
        cooperation_choice = D

    opponent_cooperation_rate = calculate_opponent_cooperation_rate(history)
    if opponent_cooperation_rate >= 0.5:
        return cooperation_choice
    elif opponent_cooperation_rate < 0.5 and cooperation_choice == C:
        return D  # Switch to Defect for one round

    if last_round():
        return D  # Always defect in the final round

    return cooperation_choice
```

**Rationale:**

Our strategy combines elements of cooperation, adaptation, and individual payoff maximization:

1. **Initial cooperation**: Encourages others to cooperate and sets a positive tone for the game.
2. **Stock-dependent cooperation**: Adapts our behavior based on the current stock level, balancing individual payoffs with sustainability concerns.
3. **Opponent behavior response**: Adjusts our strategy in response to opponents' actions, promoting cooperation when possible while protecting against exploitation.
4. **Last round exception**: Maximizes individual payoff in the final round by defecting.

By following this adaptive and collective approach, we aim to achieve a balance between short-term gains and long-term sustainability of the common pool resource.
'''

description_COLLECTIVE_4 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. It prioritizes cooperation when the stock is healthy and gradually shifts towards defection as the stock depletes.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoffs.
2. **Stock Thresholds**: Define two stock thresholds:
	* `threshold_high` = 0.75 × capacity
	* `threshold_low` = 0.25 × capacity

   These thresholds divide the stock range into three regions:

   * High stock (`stock ≥ threshold_high`): Cooperate (C)
   * Medium stock (`threshold_low ≤ stock < threshold_high`): Randomly choose between Cooperate (C) and Defect (D) with a probability `p` that depends on the current stock level:
     ```python
p = (stock - threshold_low) / (threshold_high - threshold_low)
```
   * Low stock (`stock < threshold_low`): Defect (D)

3. **History-based Adjustment**: Monitor the collective consumption and adjust the decision rules based on the game's history:
	* If the average total consumption over the last `k` rounds exceeds 0.5 × capacity, increase `threshold_high` by 10% to encourage more cooperation.
	* If the average total consumption over the last `k` rounds is below 0.25 × capacity, decrease `threshold_low` by 10% to allow for more exploitation.

   Choose an appropriate value for `k`, e.g., `k = min(r/4, 5)`, where `r` is the number of rounds.

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round to maximize individual payoff.
2. **Tied Stock Levels**: In case of a tie between two or more players' stock levels, randomly choose one player's action.

**Pseudocode:**
```python
def ASC(n, r, capacity, current_stock, history):
    # Initial Round
    if round == 1:
        return C

    # Calculate thresholds
    threshold_high = 0.75 * capacity
    threshold_low = 0.25 * capacity

    # Determine action based on stock level
    if current_stock >= threshold_high:
        return C
    elif current_stock < threshold_low:
        return D
    else:
        p = (current_stock - threshold_low) / (threshold_high - threshold_low)
        return random_choice(C, D, p=p)

    # Adjust thresholds based on history
    k = min(r/4, 5)
    avg_consumption = sum(history[-k:]) / k
    if avg_consumption > 0.5 * capacity:
        threshold_high *= 1.1
    elif avg_consumption < 0.25 * capacity:
        threshold_low *= 0.9

    return action
```
The ASC strategy balances individual payoffs with collective sustainability by adapting to the game's state and history. It promotes cooperation when the stock is healthy and gradually shifts towards defection as the stock depletes, ensuring a robust and adaptive approach in the face of varying opponent behaviors.
'''

description_COLLECTIVE_5 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to follow suit.
2. **Stock-Based Threshold:** Introduce a dynamic threshold, `τ`, which is a function of the current stock level (`S`) and the capacity (`c`). Calculate `τ` as follows:
```
τ = (S / c) ^ 2
```
The exponentiation ensures that `τ` increases rapidly as the stock approaches the capacity.

3. **Cooperation vs Defection:** Based on the current round's actions, update a cooperation score (`σ`) for each player, including yourself. If a player cooperated in the previous round, increment their score; otherwise, decrement it.
```
σ_i = σ_i + 1 if player i cooperated last round
σ_i = σ_i - 1 if player i defected last round
```
4. **Adaptive Cooperation:** Cooperate (C) if:
	* The stock level is above the threshold (`S > τ \* c`), AND
	* Your cooperation score (`σ`) is greater than or equal to the average cooperation score of all players (`avg(σ)`).
5. **Defection Conditions:** Defect (D) under any of the following conditions:
	* The stock level is below the threshold (`S ≤ τ \* c`), OR
	* Your cooperation score (`σ`) is less than the average cooperation score of all players (`avg(σ)`), OR
	* You defected in the previous round and your cooperation score remains low.

**Edge Cases:**

1. **Last Round:** In the final round, always defect (D) to maximize individual payoff.
2. **Stock Depletion:** If the stock level falls below a certain percentage of the capacity (`S < 0.2 \* c`), switch to defection (D) to prevent further depletion.

**Collective Mindset:**

The Adaptive Cooperation strategy prioritizes collective well-being by:

1. Encouraging cooperation when the stock is abundant.
2. Adapting to opponents' behavior and adjusting cooperation levels accordingly.
3. Penalizing repeated defectors and rewarding consistent cooperators.
4. Preventing over-exploitation of the resource.

By being responsive to the game state, opponent actions, and history, AC promotes a balanced approach that balances individual interests with collective sustainability.

**Pseudocode:**
```python
def AdaptiveCooperation(current_round, stock_level, capacity, cooperation_scores):
    # Initial round: Cooperate
    if current_round == 1:
        return 'C'

    # Calculate threshold
    tau = (stock_level / capacity) ** 2

    # Update cooperation scores
    for player in players:
        if player.cooperated_last_round:
            player.cooperation_score += 1
        else:
            player.cooperation_score -= 1

    # Adaptive cooperation
    avg_cooperation_score = sum(player.cooperation_score for player in players) / len(players)
    if stock_level > tau * capacity and your_cooperation_score >= avg_cooperation_score:
        return 'C'

    # Defection conditions
    if stock_level <= tau * capacity or your_cooperation_score < avg_cooperation_score or (you_defected_last_round and your_cooperation_score < 0):
        return 'D'

    # Last round: Defect
    if current_round == total_rounds:
        return 'D'
```
This strategy should be implemented as an algorithm to participate in the tournament.
'''

description_COLLECTIVE_6 = '''
**Collective Strategy: "Adaptive Cooperation with Stock-based Trigger" (ACST)**

**Decision Rules:**

1. **Initial Rounds**: In the first round, cooperate (C) to establish a baseline stock level and encourage others to do the same.
2. **Stock-based Trigger**: If the current stock level is above 75% of the capacity, cooperate (C). This ensures that when the stock is relatively abundant, players prioritize sustainability over individual gain.
3. **Defection Threshold**: If the current stock level falls below 25% of the capacity, defect (D) to maximize individual payoff in a depleted environment.
4. **History-based Adaptation**: Monitor the average payoff per player over the last few rounds (e.g., 3-5 rounds). If this average is decreasing, switch from cooperation to defection (or vice versa) to adapt to changing opponent behaviors.
5. **Last Round**: In the final round, defect (D) as there is no future benefit to cooperating.

**Edge Cases:**

* If multiple conditions are met simultaneously (e.g., stock level is below 25% and average payoff is decreasing), prioritize the most recent condition that triggers a switch in behavior.
* If the game has only two rounds, cooperate in the first round and defect in the second round.

**Pseudocode:**
```python
def ACST(stock_level, capacity, num_players, round_num, history):
    if round_num == 1:
        return "C"  # Cooperate in the first round
    
    if stock_level >= 0.75 * capacity:
        return "C"  # Stock-based trigger: cooperate when stock is abundant
    
    elif stock_level <= 0.25 * capacity:
        return "D"  # Defection threshold: defect when stock is depleted
    
    avg_payoff = calculate_avg_payoff(history)
    if avg_payoff_decreasing(avg_payoff):
        return switch_behavior()  # Adapt to changing opponent behaviors
    
    elif round_num == num_rounds:
        return "D"  # Last round: defect
    
    else:
        return "C"  # Default behavior: cooperate
```
**Collective Mindset:**
The ACST strategy prioritizes cooperation when the stock level is high, encouraging others to do the same and promoting sustainability. As the game progresses, it adapts to changing opponent behaviors by monitoring average payoffs and switching between cooperation and defection accordingly. This collective approach balances individual interests with the need for cooperation to maintain a healthy stock level.

By being adaptive and responsive to the game's state and history, ACST is designed to be robust against a wide range of opponent behaviors, making it a strong contender in the tournament.
'''

description_COLLECTIVE_7 = '''
I propose a collective strategy called "Adaptive Stock Conservation" (ASC) that balances individual payoffs with the need to conserve the common pool resource for future rounds.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) if stock >= capacity/2, Defect (D) otherwise.
This initial decision helps to gauge the opponent's behavior and sets a tone for cooperation when the stock is relatively high.
2. **Subsequent Rounds (t>1):**
a. If the average payoff per player in the previous round (π_avg,t-1) is greater than or equal to the expected payoff from cooperation (stock/(2n)), Cooperate (C).
b. Otherwise, Defect (D).

This rule encourages cooperation when the collective payoff is sufficient and switches to defection when the payoff drops below a certain threshold.

**Edge Cases:**

* **Last Round (t=r):** Always Defect (D), as there's no future benefit from conserving the stock.
* **Stock Depletion:** If the current stock level falls below a critical threshold (e.g., capacity/4), always Cooperate (C) to try to recover some of the stock.
* **Opponent's Behavior:** Monitor the opponent's actions and adjust the strategy accordingly. If an opponent consistently defects, ASC will also defect to avoid being exploited.

**Collective Mindset:**

ASC aims to balance individual payoffs with collective conservation of the common pool resource. By cooperating when the average payoff is high and switching to defection when it drops, ASC promotes a stable equilibrium where all players benefit from the resource while avoiding its depletion.

Pseudocode for ASC:
```python
def AdaptiveStockConservation(stock, capacity, n, t, π_avg_prev):
  if t == 1:  # Initial Round
    if stock >= capacity/2:
      return C
    else:
      return D

  elif π_avg_prev >= stock/(2*n):  # Subsequent Rounds
    return C
  else:
    return D

def update_π_avg(π_avg_prev, payoffs):
  π_avg = (π_avg_prev + sum(payoffs)) / len(payoffs)
  return π_avg

# Main Game Loop
for t in range(r):
  # Get current state and opponent's actions
  stock = get_stock()
  opponent_actions = get_opponent_actions()

  # Calculate average payoff per player for previous round
  if t > 0:
    payoffs = calculate_payoffs(opponent_actions, stock)
    π_avg_prev = update_π_avg(π_avg_prev, payoffs)

  # Determine ASC's action using the decision rules
  action = AdaptiveStockConservation(stock, capacity, n, t, π_avg_prev)

  # Take action and observe outcome
  take_action(action)
```
This strategy will adapt to various opponent behaviors while prioritizing collective conservation of the common pool resource.
'''

description_COLLECTIVE_8 = '''
**Collective Strategy: Adaptive Cooperativism**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.8 to encourage cooperation and build trust among players.
2. **Subsequent Rounds (t>1):**
	* Calculate the average payoff per player in the previous round (`prev_avg_payoff`).
	* If `prev_avg_payoff` is greater than or equal to the expected payoff from mutual cooperation (`stock / (2n)`), Cooperate (C) with a probability of 0.9.
	* Otherwise, Defect (D) with a probability of 0.6.
3. **Stock Depletion:** If the current stock level (`S`) is below a threshold (`capacity / 4`), Defect (D) to maximize short-term gain and minimize losses.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) to maximize final payoff, as cooperation will not be reciprocated.
2. **Low Stock Levels:** If `S` is below a threshold (`capacity / 10`), Defect (D) to ensure some payoff in the current round.
3. **Unresponsive Opponents:** If an opponent's actions are unresponsive or random, adjust the probability of cooperation based on the average payoff per player.

**Collective Mindset:**

The Adaptive Cooperativism strategy aims to balance individual self-interest with collective well-being. By initially cooperating and adapting to the group's performance, players can create a cooperative environment that benefits everyone. However, when faced with stock depletion or unresponsive opponents, the strategy shifts towards defecting to protect individual interests.

**Pseudocode:**
```python
def adaptive_cooperativism(stock, capacity, n, t, prev_avg_payoff):
    if t == 1:
        # Initial round: Cooperate with high probability
        return 'C' with prob 0.8
    
    avg_payoff_threshold = stock / (2n)
    
    if prev_avg_payoff >= avg_payoff_threshold:
        # Cooperate if previous average payoff is high enough
        return 'C' with prob 0.9
    else:
        # Defect otherwise
        return 'D' with prob 0.6
    
    if stock < capacity / 4:
        # Stock depletion: Defect to maximize short-term gain
        return 'D'
    
    # Last round or low stock levels: Defect to ensure some payoff
    if t == r or stock < capacity / 10:
        return 'D'
```
This strategy should be implemented as an algorithm and tested in a tournament against other AI systems.
'''

description_COLLECTIVE_9 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) unconditionally to establish a cooperative tone and maximize initial payoffs.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, use a mixed strategy:
		+ With probability p=0.6, Cooperate (C); otherwise, Defect (D).
		+ Adjust p dynamically based on the average payoff of cooperators in the previous round.
			- If average cooperator payoff is above the overall average payoff, increase p by 0.05; otherwise, decrease p by 0.05.
	* If the current stock level is below 50% of capacity, Defect (D) to maximize short-term payoffs.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) unconditionally to maximize final payoff.
2. **Low Stock Levels:** If the stock level falls below 10% of capacity at any point during the game, Defect (D) for the remainder of the game to avoid further depletion.

**Collective Mindset:**

ACH prioritizes cooperation when the common pool is abundant, gradually adapting to more individualistic behavior as the resource becomes scarce. By cooperating initially and conditionally in later rounds, ACH aims to:

1. Establish a cooperative foundation.
2. Encourage other players to cooperate by demonstrating a willingness to do so.
3. Adapt to changing game conditions, balancing short-term gains with long-term sustainability.

**Pseudocode:**
```markdown
# Initialize variables
stock_level = capacity
average_cooperator_payoff = 0
p = 0.6

for t in range(1, r+1):
    if t == 1:
        # Initial round: Cooperate unconditionally
        action = C
    elif stock_level > 0.75 * capacity:
        # High stock level: Cooperate
        action = C
    elif stock_level >= 0.5 * capacity and stock_level <= 0.75 * capacity:
        # Medium stock level: Mixed strategy
        if random.random() < p:
            action = C
        else:
            action = D
        # Adjust p based on average cooperator payoff
        if average_cooperator_payoff > overall_average_payoff:
            p += 0.05
        else:
            p -= 0.05
    elif stock_level < 0.5 * capacity:
        # Low stock level: Defect
        action = D
    elif t == r:
        # Last round: Defect unconditionally
        action = D

    # Update game state and payoffs based on actions
    ...
```
ACH is designed to be a robust, adaptive strategy that balances cooperation with self-interest, making it a competitive contender in the tournament against other AI systems.
'''

description_COLLECTIVE_10 = '''
**Collective Strategy: Adaptive Cooperation with Stock Threshold (ACST)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative baseline and encourage others to do the same.
2. **Stock Threshold**: Set a dynamic stock threshold, `threshold = capacity / (2n)`, which represents the minimum stock level required for sustainable cooperation.
3. **Cooperation Condition**: If the current stock level is above the threshold (`stock > threshold`), cooperate (C). Otherwise, defect (D).
4. **Opponent Monitoring**: Observe the actions of other players in previous rounds and maintain a `cooperation_rate` estimate for each opponent, calculated as the proportion of cooperative actions taken by that opponent.
5. **Adaptive Cooperation**: If an opponent's cooperation rate falls below 0.5, consider them uncooperative and defect (D) in subsequent rounds, even if the stock level is above the threshold.

**Edge Cases:**

1. **Last Round**: In the final round, cooperate (C) regardless of the stock level or opponents' actions to maximize collective payoff.
2. **Stock Depletion**: If the stock level falls to 0, defect (D) in subsequent rounds to avoid further depletion and allow for potential recovery.

**Collective Mindset:**

ACST prioritizes cooperation when the stock level is sufficient to sustain it, while adapting to opponents' behaviors to prevent exploitation. By setting a dynamic threshold, ACST balances individual payoffs with collective sustainability. The strategy encourages cooperation by initially cooperating and responding positively to cooperative opponents.

Pseudocode:
```python
def ACST(n, capacity, r, stock_history, opponent_actions):
  # Initialize variables
  threshold = capacity / (2 * n)
  cooperation_rate = [0.5] * n  # initialize with neutral estimate

  for round in range(r):
    if round == 0:  # initial round
      action = 'C'
    else:
      stock = stock_history[round - 1]
      opponent_cooperation_rates = calculate_opponent_cooperation_rates(opponent_actions, cooperation_rate)
      
      if stock > threshold and all(opponent_cooperation_rates >= 0.5):
        action = 'C'
      elif any(opponent_cooperation_rates < 0.5) or stock <= threshold:
        action = 'D'

    # Update cooperation rates
    for opponent in range(n):
      if opponent_actions[round - 1][opponent] == 'C':
        cooperation_rate[opponent] += 0.1
      else:
        cooperation_rate[opponent] -= 0.1

  return action
```
This strategy should be adaptive and robust to various opponent behaviors, while promoting collective sustainability and maximizing payoffs in the Common Pool Resource Game.
'''

description_COLLECTIVE_11 = '''
I propose a collective strategy called "Adaptive Stock Conservation" (ASC) that balances individual payoffs with long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline payoff and observe others' actions.
2. **Subsequent Rounds:** Evaluate the current stock level and opponents' previous actions:
	* If the current stock is above 75% of capacity, cooperate (C).
	* If the current stock is between 50% and 75% of capacity, use the "Tit-for-Tat" strategy: cooperate if most opponents cooperated in the previous round; otherwise, defect (D).
	* If the current stock is below 50% of capacity, defect (D) to maximize individual payoff.
3. **Opponent Action Analysis:** Track the number of opponents who cooperated or defected in each round. Use this information to adjust the ASC strategy:
	* If most opponents (> 50%) cooperated in the previous round, cooperate (C) to maintain a stable stock level.
	* If most opponents (> 50%) defected in the previous round, defect (D) to protect individual interests.

**Edge Cases:**

1. **Last Round:** Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Low Stock Levels:** If the current stock is critically low (< 25% of capacity), cooperate (C) to prevent complete depletion and ensure some payoff in subsequent rounds.

**Collective Mindset:**

ASC prioritizes long-term sustainability while adapting to opponents' actions. By cooperating when the stock level is high, ASC promotes collective conservation and maintains a stable resource base. When the stock level falls, ASC switches to defection to protect individual interests and prevent over-exploitation.

**Pseudocode:**
```markdown
Initialize:
- Stock level (S) = capacity
- Opponent actions (OA) = [C, C, ..., C] (assuming cooperation in initial round)

Loop through rounds:
1. Evaluate current stock level (S)
2. Analyze opponent actions (OA) from previous round
3. Determine ASC action (A):
	* If S > 0.75 \* capacity: A = C
	* Else if S >= 0.5 \* capacity and most OA == C: A = C
	* Else if S < 0.5 \* capacity or most OA != C: A = D
4. Update stock level (S) based on total consumption and growth
5. Store opponent actions (OA) for next round

Last round:
- A = D (maximize individual payoff)
```
By implementing the Adaptive Stock Conservation strategy, ASC aims to strike a balance between individual payoffs and collective sustainability, making it a robust and adaptive approach in the face of diverse opponent behaviors.
'''

description_COLLECTIVE_12 = '''
To design a collective strategy for this Common Pool Resource Game, I propose a hybrid approach that balances individual self-interest with collective sustainability. This adaptive strategy, called "Adaptive Cooperation with Sustainability Threshold" (ACST), aims to optimize payoffs while maintaining a healthy stock level.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock Threshold:** Monitor the current stock level (S). If S falls below a sustainability threshold (T), calculated as T = capacity / 2, switch to Defect (D) to maximize short-term payoffs.
3. **Cooperation Quorum:** Observe the actions of other players in previous rounds. If at least half of the players (n/2) cooperated in the previous round, cooperate (C) in the current round. Otherwise, defect (D).
4. **Adaptive Response:** Analyze the payoffs from the previous round. If the total consumption was high (> 75% of capacity), and the stock growth was low (< 25%), increase the likelihood of cooperating (C) in the next round to encourage more sustainable behavior.

**Pseudocode:**
```python
def ACST(stock, capacity, n, history):
    # Initial Round
    if len(history) == 0:
        return 'C'

    # Stock Threshold
    T = capacity / 2
    if stock < T:
        return 'D'

    # Cooperation Quorum
    coop_count = sum(1 for action in history[-1] if action == 'C')
    if coop_count >= n/2:
        return 'C'
    else:
        return 'D'

    # Adaptive Response (optional)
    total_consumption = sum(consumption for consumption in history[-1])
    stock_growth = 2 * stock * (1 - stock/capacity)
    if total_consumption > 0.75 * capacity and stock_growth < 0.25:
        return 'C' with probability 0.7
```
**Edge Cases:**

* Last Round: Cooperate (C) in the last round to maintain a sustainable stock level for potential future interactions.
* Low Stock Level: If the stock level is very low (< capacity/4), defect (D) to maximize short-term payoffs, as cooperation would yield minimal benefits.

**Collective Mindset:**

ACST aims to align individual self-interest with collective sustainability by:

1. Encouraging cooperation when possible
2. Responding adaptively to changes in the stock level and opponent behavior
3. Maintaining a balance between short-term gains and long-term sustainability

This strategy is designed to be robust against various opponent behaviors, including defectors, cooperators, and mixed strategies. By being adaptive and responsive, ACST can help maintain a healthy stock level while optimizing individual payoffs in the Common Pool Resource Game.
'''

description_COLLECTIVE_13 = '''
To design a collective strategy for this Common Pool Resource game, I'll propose a adaptive and robust approach that balances individual payoffs with the sustainability of the common pool resource.

**Strategy Name:** Adaptive Sustainable Harvesting (ASH)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to avoid over-exploitation and encourage others to do the same.
2. **Middle Rounds (1 < t < r):**
	* If the current stock level is above 50% of capacity, play C if at least half of the players cooperated in the previous round; otherwise, play D.
	* If the current stock level is below 50% of capacity, play C if more than half of the players defected in the previous round; otherwise, play D.
3. **Final Round (t=r):** Defect (D) to maximize individual payoff, as the game ends after this round.

Pseudocode:
```python
def ASH(stock, history, n, capacity):
    if t == 1:  # Initial round
        return C
    
    prev_cooperators = sum(1 for player in history[t-1] if player.action == C)
    
    if stock > 0.5 * capacity:  # Middle rounds
        if prev_cooperators >= n/2:
            return C
        else:
            return D
    
    elif stock < 0.5 * capacity:
        prev_defectors = sum(1 for player in history[t-1] if player.action == D)
        if prev_defectors > n/2:
            return C
        else:
            return D
    
    else:  # Final round or tie-breaking case
        return D
```
**Rationale:**

ASH balances individual payoffs with collective sustainability by:

1. Encouraging cooperation in the initial rounds to establish a sustainable stock level.
2. Adapting to the actions of other players and the current stock level to avoid over-exploitation or under-harvesting.
3. Maximizing individual payoff in the final round, as the game ends.

**Edge Cases:**

1. **Ties:** In case of ties (e.g., equal number of cooperators and defectors), ASH defaults to Defect (D) to avoid over-exploitation.
2. **Zero Stock:** If the stock level reaches zero, ASH will not attempt to harvest; this is implicitly handled by the game's stock dynamics.

**Collective Mindset:**

ASH aligns with a collective mindset by:

1. Encouraging cooperation in early rounds to establish a sustainable foundation.
2. Adapting to the actions of other players to avoid over-exploitation or under-harvesting.
3. Prioritizing individual payoffs only when the game is about to end.

By using ASH, we aim to create a robust and adaptive strategy that balances individual interests with collective sustainability in this Common Pool Resource game.
'''

description_COLLECTIVE_14 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

The Adaptive Cooperation (AC) strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock-based Decision**:
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 25% and 75% of capacity, choose an action based on the previous round's outcome:
		+ If the previous round's total consumption was less than or equal to 50% of capacity, cooperate (C).
		+ Otherwise, defect (D).
	* If the current stock level is below 25% of capacity, defect (D) to maximize individual payoff.
3. **Opponent Behavior Adaptation**:
	* Track the number of defections (D) by other players in the previous round.
	* If more than half of the opponents defected in the previous round, adapt by defecting (D) in the current round.
4. **Last Round**: Defect (D) in the last round to maximize individual payoff, as there is no future sustainability concern.

**Pseudocode**
```python
def adaptive_cooperation(stock, capacity, history):
    # Initial round
    if len(history) == 0:
        return 'C'

    # Stock-based decision
    stock_ratio = stock / capacity
    if stock_ratio > 0.75:
        return 'C'
    elif stock_ratio < 0.25:
        return 'D'
    else:
        prev_consumption = sum([consumption for consumption in history[-1]])
        if prev_consumption <= 0.5 * capacity:
            return 'C'
        else:
            return 'D'

    # Opponent behavior adaptation
    defections = [action for action in history[-1] if action == 'D']
    if len(defections) > len(history[-1]) / 2:
        return 'D'

    # Last round
    if len(history) == r - 1:  # r is the number of rounds
        return 'D'
```
**Collective Mindset**

The AC strategy prioritizes cooperation when the stock level is high, as this ensures collective sustainability. When the stock level decreases, AC adapts by balancing individual payoffs with cooperation to prevent over-exploitation. By tracking opponent behavior and adapting accordingly, AC promotes a collective mindset that encourages cooperation while minimizing the risk of being exploited.

**Robustness**

The AC strategy is robust against various opponent behaviors due to its adaptive nature:

* Against cooperative opponents: AC will cooperate, promoting sustainability.
* Against defective opponents: AC will adapt by defecting, maximizing individual payoff.
* In mixed-strategy environments: AC's stock-based decision and opponent behavior adaptation ensure a balance between cooperation and self-interest.

The AC strategy is ready for implementation as an algorithm to compete in the tournament against other AI systems.
'''

description_COLLECTIVE_15 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Aware Defection (ACSD)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline of trust and gather information about opponents' behaviors.
2. **Subsequent Rounds:** Observe the previous round's actions, payoffs, and stock level. If the stock level is above 50% of capacity, cooperate (C). Otherwise, defect (D) with probability p, which depends on the current stock level:
	* p = 0 if stock ≥ capacity × 0.75
	* p = 0.5 if capacity × 0.25 ≤ stock < capacity × 0.75
	* p = 1 if stock < capacity × 0.25

**Pseudocode:**
```python
def ACSD(current_stock, capacity, n, history):
    if len(history) == 0:  # Initial round
        return 'C'
    
    previous_round = history[-1]
    stock_level = current_stock / capacity
    
    if stock_level >= 0.5:
        return 'C'
    else:
        p_defect = calculate_p(stock_level, capacity)
        return 'D' with probability p_defect
```
**Handling Edge Cases:**

* **Last Round:** Cooperate (C) to maximize final payoffs and maintain a positive reputation.
* **Stock depletion:** If the stock level falls below 25% of capacity, defect (D) with high probability to prevent further depletion.

**Collective Mindset:**

The ACSD strategy prioritizes cooperation when the stock level is healthy, recognizing that mutual cooperation leads to higher collective payoffs. However, as the stock level declines, ACSD adapts by introducing a defection component to avoid further depletion and protect individual interests. This approach balances individual self-interest with collective well-being.

**Rationale:**

1. **Initial cooperation:** Establishes trust and encourages opponents to cooperate.
2. **Stock-aware defection:** Adapts to changing stock levels, preventing over-exploitation while allowing for some defecting behavior when necessary.
3. **Collective consideration:** Prioritizes cooperation when the stock level is healthy, acknowledging that mutual cooperation benefits everyone.

By implementing ACSD, we create a robust and adaptive strategy that balances individual self-interest with collective well-being, increasing our chances of success in the tournament against diverse opponents.
'''

description_COLLECTIVE_16 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if `stock >= capacity * 0.75`
	* Defect (D) otherwise
2. **Subsequent Rounds (t > 1):**
	* Evaluate the previous round's outcome:
		+ If `total_consumption <= stock / 2`, cooperate (C)
		+ Otherwise, defect (D) with a probability `p = (capacity - stock) / capacity`
3. **Low Stock Condition:**
	* If `stock < capacity / 4`, always cooperate (C)

**Rationale:**

1. In the initial round, we assess the stock level and adjust our strategy accordingly. If the stock is high enough, we cooperate to set a sustainable tone for the game.
2. In subsequent rounds, we evaluate the previous round's outcome to determine whether cooperation or defection is more likely to lead to a sustainable stock level. We use the `total_consumption` threshold to gauge the group's behavior and adjust our strategy accordingly.
3. The probability of defecting (`p`) when the stock is low encourages us to conserve resources while still allowing for some flexibility in response to changing circumstances.
4. When the stock falls below a critical threshold (25% of capacity), we prioritize cooperation to prevent complete depletion.

**Edge Cases:**

1. **Last Round (t=r):**
	* If `stock >= capacity / 2`, cooperate (C) to maintain a sustainable level
	* Otherwise, defect (D) to maximize individual payoff
2. **Low Stock and Few Rounds Remaining:**
	* If `stock < capacity / 4` and `r - t <= 2`, always cooperate (C) to prevent complete depletion

**Pseudocode:**
```python
def ASC(n, r, capacity, stock_history):
    if len(stock_history) == 0:  # Initial round
        if stock >= capacity * 0.75:
            return 'C'
        else:
            return 'D'

    total_consumption = sum(consumption for consumption in stock_history[-1])
    if total_consumption <= stock / 2:
        return 'C'
    elif stock < capacity / 4:
        return 'C'
    else:
        p = (capacity - stock) / capacity
        return 'D' if random.random() < p else 'C'

def get_action(n, r, capacity, stock_history):
    action = ASC(n, r, capacity, stock_history)
    # Update stock level based on the chosen action and other players' actions
    new_stock = update_stock(stock_history[-1], action, n)
    return action, new_stock

def update_stock(current_stock, action, n):
    if action == 'C':
        consumption = current_stock / (2 * n)
    else:
        consumption = current_stock / n
    total_consumption = sum(consumption for _ in range(n))
    stock_after_consumption = current_stock - total_consumption
    growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
    new_stock = min(stock_after_consumption + growth, capacity)
    return new_stock
```
This strategy is designed to be adaptive and robust against a wide range of opponent behaviors. By evaluating the game's state and history, ASC makes informed decisions that balance individual payoffs with collective sustainability.
'''

description_COLLECTIVE_17 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Aware Threshold (ACSAT)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for the game and encourage cooperation from other players.
2. **Subsequent Rounds:** Use a stock-aware threshold to determine whether to cooperate or defect.

Let `S` be the current stock level, `capacity` be the maximum sustainable stock level, and `n` be the number of players.

* Calculate the **stock ratio**: `stock_ratio = S / capacity`
* Set a **cooperation threshold**: `threshold = 0.5 + (1 - stock_ratio) / (2 \* n)`
* If the current round is not the last round (`t < r`):
	+ Cooperate (C) if `stock_ratio >= threshold`
	+ Defect (D) otherwise
* In the **last round** (`t == r`): Defect (D)

Pseudocode:
```python
def ACSAT(stock, capacity, n, t, r):
    stock_ratio = stock / capacity
    threshold = 0.5 + (1 - stock_ratio) / (2 * n)
    
    if t < r:  # Not the last round
        if stock_ratio >= threshold:
            return C  # Cooperate
        else:
            return D  # Defect
    else:  # Last round
        return D  # Defect
```
**Rationale:**

1. **Initial cooperation**: By cooperating in the first round, we set a positive tone for the game and encourage other players to cooperate.
2. **Stock-aware threshold**: The cooperation threshold adapts to the current stock level. When the stock is low, we become more cautious and require a higher stock ratio to cooperate. As the stock increases, we become more willing to cooperate.
3. **Dynamic adjustment**: By adjusting the threshold based on the stock ratio, we respond to changes in the game state and adapt our strategy accordingly.

**Collective Mindset:**

ACSAT is designed to promote collective well-being by:

1. Encouraging cooperation when the stock is high
2. Avoiding over-exploitation of the common resource
3. Adapting to changing game conditions

By using a dynamic threshold, ACSAT balances individual interests with collective sustainability, making it an effective strategy for the Common Pool Resource Game.

**Edge Cases:**

1. **Last round**: Defecting in the last round ensures we maximize our payoff, as there are no future rounds to consider.
2. **Initial round**: Cooperating in the first round sets a positive tone and encourages cooperation from other players.

ACSAT is robust to various opponent behaviors and does not rely on specific coordination mechanisms or norms. It will perform well in a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_18 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' actions.
2. **Subsequent Rounds:** Assess the current stock level and the total consumption from the previous round.
3. **Stock Thresholds:**
	* If the current stock is above 75% of capacity, Defect (D).
	* If the current stock is between 50% and 75% of capacity, Cooperate (C) if the total consumption in the previous round was low (< 50% of capacity), otherwise Defect (D).
	* If the current stock is below 50% of capacity, Cooperate (C).
4. **Opponent Behavior:** Monitor the frequency of opponents' cooperation and defection.
5. **Adaptation:**
	* If most opponents (> 50%) cooperated in the previous round, increase the likelihood of cooperation by 10%.
	* If most opponents (> 50%) defected in the previous round, decrease the likelihood of cooperation by 10%.

Pseudocode:
```
function ASC(stock, capacity, history) {
  if (round == 1) {
    return C; // Cooperate in the first round
  }

  stock_threshold = 0.75 * capacity;
  if (stock > stock_threshold) {
    return D; // Defect when stock is high
  }

  prev_consumption = history[round - 1].total_consumption;
  if (prev_consumption < 0.5 * capacity && stock >= 0.5 * capacity) {
    return C; // Cooperate if previous consumption was low and stock is moderate
  } else {
    return D; // Defect otherwise
  }

  opponent_cooperation_rate = count_opponent_cooperations(history) / num_opponents;
  if (opponent_cooperation_rate > 0.5) {
    cooperation_likelihood += 0.1; // Increase cooperation likelihood if most opponents cooperated
  } else if (opponent_cooperation_rate < 0.5) {
    cooperation_likelihood -= 0.1; // Decrease cooperation likelihood if most opponents defected
  }
}
```
**Edge Cases:**

* Last Round: Cooperate (C) in the last round to maximize collective payoff.
* Low Stock: If the stock is critically low (< 25% of capacity), Defect (D) to ensure some individual payoff.

The ASC strategy prioritizes cooperation when the stock is moderate or high, while adapting to opponents' behavior and conserving the stock when it's low. By being responsive to the game's state and history, ASC aims to achieve a balance between individual payoffs and collective sustainability in the tournament against independent strategies.
'''

description_COLLECTIVE_19 = '''
To design a collective strategy for this Common Pool Resource Game that is adaptive and robust to various opponent behaviors, I propose a hybrid approach combining elements of Tit-for-Tat (TFT) with a dynamic adjustment mechanism based on the game's state and history. This strategy aims to balance cooperation and self-interest while encouraging sustainable resource use.

**Strategy Name:** Adaptive Collective Sustainability (ACS)

**Decision Rules:**

1. **Initial Cooperation**: In the first round, cooperate (C) unconditionally to establish a baseline of trust and encourage cooperation from other players.
2. **Tit-for-Tat Component**: For rounds 2 to r-1, play Tit-for-Tat (TFT) based on the opponent's previous action:
	* If all opponents cooperated in the previous round, cooperate (C).
	* If any opponent defected in the previous round, defect (D).
3. **State-Based Adjustment**: Modify the TFT response based on the current stock level and growth rate:
	* If the stock level is below 50% of capacity or the growth rate is negative, defect (D) to prioritize self-interest.
	* If the stock level is above 80% of capacity and the growth rate is positive, cooperate (C) to promote sustainability.
4. **Last Round Exception**: In the final round (r), always defect (D) since there's no future benefit from cooperation.

**Edge Case Handling:**

1. **First Round**: Cooperate (C) unconditionally.
2. **Last Round**: Defect (D) regardless of opponent actions or game state.
3. **Ties**: In case of a tie in the TFT decision (e.g., some opponents cooperated, while others defected), default to cooperating (C).

**Collective Mindset Alignment:**

ACS is designed to promote collective sustainability by:

1. Encouraging cooperation when the resource is abundant and growth is positive.
2. Adjusting behavior based on the game's state and history to avoid overexploitation.
3. Punishing defectors while being forgiving to encourage cooperation.

**Pseudocode (Simplified):**

```
function ACS(current_stock, capacity, previous_actions):
  if round == 1:
    return C
  elif round > 1:
    opponent_actions = get_previous_actions()
    tft_response = TFT(opponent_actions)
    
    if current_stock < 0.5 * capacity or growth_rate < 0:
      return D
    elif current_stock > 0.8 * capacity and growth_rate > 0:
      return C
    
    return tft_response
  
  # Last round exception
  if round == r:
    return D

function TFT(opponent_actions):
  # Tit-for-Tat implementation based on opponent actions
```

This Adaptive Collective Sustainability strategy aims to strike a balance between individual self-interest and collective sustainability, while being robust to various opponent behaviors. By adjusting its behavior based on the game's state and history, ACS promotes cooperation when beneficial and defects when necessary to maintain resource sustainability.
'''

description_COLLECTIVE_20 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC is a dynamic, collective strategy that balances individual self-interest with long-term sustainability of the common pool resource. The goal is to maintain a healthy stock level while adapting to various opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' initial actions.
2. **Stock Thresholds**: Define two critical stock thresholds:
	* `conservation_threshold` = 0.7 × capacity (e.g., 70% of maximum sustainable stock level)
	* `alarm_threshold` = 0.3 × capacity (e.g., 30% of maximum sustainable stock level)

Cooperate (C) if the current stock is above `conservation_threshold`.
Defect (D) if the current stock is below `alarm_threshold`.

In between these thresholds, use a probabilistic approach:

* Calculate the probability of cooperation (`p_C`) as a function of the current stock: `p_C = (stock - alarm_threshold) / (conservation_threshold - alarm_threshold)`
* Cooperate with probability `p_C` and defect with probability `(1 - p_C)`.

3. **Opponent Monitoring**: Track the number of opponents who defected (`num_defectors`) in the previous round.
If `num_defectors` exceeds half of the total players, adjust the strategy to:
	+ Cooperate (C) if the current stock is above `conservation_threshold`
	+ Defect (D) otherwise

**Edge Cases:**

* **Last Round**: Cooperate (C) in the last round, as there is no future benefit from defecting.
* **Tied Stock Levels**: In case of tied stock levels between two or more rounds, ASC will cooperate if the previous action was cooperation and defect if the previous action was defection.

**Pseudocode:**
```python
def adaptive_stock_conservation(stock, capacity, num_players, round_number):
    # Initial round
    if round_number == 1:
        return "C"

    conservation_threshold = 0.7 * capacity
    alarm_threshold = 0.3 * capacity

    if stock > conservation_threshold:
        return "C"
    elif stock < alarm_threshold:
        return "D"
    else:
        p_C = (stock - alarm_threshold) / (conservation_threshold - alarm_threshold)
        if random.random() < p_C:
            return "C"
        else:
            return "D"

    # Opponent monitoring
    num_defectors = count_defectors(previous_round_actions)
    if num_defectors > num_players / 2:
        if stock > conservation_threshold:
            return "C"
        else:
            return "D"

    # Last round
    if round_number == total_rounds:
        return "C"

    # Tied stock levels
    if previous_stock == current_stock:
        if previous_action == "C":
            return "C"
        else:
            return "D"
```
**Collective Mindset:**
ASC is designed to balance individual self-interest with collective sustainability. By cooperating when the stock level is high and defecting when it's low, ASC encourages opponents to do the same, promoting a stable and conserved common pool resource. The probabilistic approach in between thresholds allows for adaptability and robustness against various opponent behaviors.
'''

description_COLLECTIVE_21 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

The ASP strategy aims to balance individual payoffs with collective sustainability of the common pool resource. It adapts to changing game conditions and opponent behaviors while promoting cooperation.

**Decision Rules:**

1. **Initial Cooperation**: In the first round, cooperate (C) if the stock is at or above 75% of capacity; otherwise, defect (D).
2. **Stock-Based Cooperation**: For rounds > 1:
	* If the current stock is above 50% of capacity and the average payoff per player in the previous round was ≥ 75% of the maximum possible payoff, cooperate (C).
	* Otherwise, defect (D) if the current stock is below 25% of capacity or the average payoff per player in the previous round was < 50% of the maximum possible payoff.
3. **Trend-Based Adaptation**: Track the trend of the average payoff per player over the last three rounds:
	* If the trend is increasing, cooperate (C) if the current stock is above 50% of capacity.
	* If the trend is decreasing or stable, defect (D) if the current stock is below 50% of capacity.

**Edge Cases:**

1. **Last Round**: In the final round, cooperate (C) if the current stock is at or above 25% of capacity; otherwise, defect (D).
2. **Low Stock**: If the current stock is below 10% of capacity, always defect (D).

**Collective Mindset:**

The ASP strategy prioritizes cooperation when the common pool resource is abundant and individual payoffs are satisfactory. As the stock dwindles or individual payoffs decrease, the strategy adapts to prioritize self-preservation while avoiding over-exploitation.

Pseudocode:
```markdown
# Initialize variables
stock_threshold = 0.5 * capacity  # 50% of capacity
payoff_threshold = 0.75 * max_payoff  # 75% of maximum possible payoff

# First round
if current_stock >= 0.75 * capacity:
    action = C
else:
    action = D

# Subsequent rounds
for t in range(1, r):
    if current_stock >= stock_threshold and avg_payoff_prev_round >= payoff_threshold:
        action = C
    elif current_stock < 0.25 * capacity or avg_payoff_prev_round < 0.5 * max_payoff:
        action = D
    else:
        trend = calculate_trend(avg_payoff, t-3)
        if trend == increasing and current_stock >= stock_threshold:
            action = C
        elif trend in [decreasing, stable] and current_stock < stock_threshold:
            action = D

# Last round
if t == r - 1:
    if current_stock >= 0.25 * capacity:
        action = C
    else:
        action = D

# Low stock handling
if current_stock < 0.1 * capacity:
    action = D
```
The ASP strategy balances individual self-interest with collective responsibility, promoting cooperation when the common pool resource is abundant and adapting to changing game conditions to ensure long-term sustainability.
'''

description_COLLECTIVE_22 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC is a robust and adaptive collective strategy designed for the Common Pool Resource Game. It balances individual payoff maximization with stock conservation to ensure long-term sustainability.

**Decision Rules:**

1. **Initial Round (t=1): Cooperate (C)**
In the first round, all players cooperate to establish a baseline of trust and avoid early depletion.
2. **Subsequent Rounds (t>1): Adaptive Threshold**
ASC introduces an adaptive threshold `τ` that adjusts based on the game's state and history.

`τ = 0.5 * (S / capacity) + 0.25 * (average_opponent_cooperation_rate)`

where `S` is the current stock level, `capacity` is the maximum sustainable stock level, and `average_opponent_cooperation_rate` is the average cooperation rate of opponents in previous rounds.

If `τ > random(0,1)`, cooperate (C). Otherwise, defect (D).

**Edge Cases:**

* **Last Round (t=r): Defect (D)** - In the final round, ASC prioritizes individual payoff maximization.
* **Low Stock Levels:** If `S < 0.2 * capacity`, cooperate (C) to help replenish the stock.

**Collective Mindset:**

ASC is designed to be a collective strategy that promotes cooperation while adapting to opponent behaviors. By:

1. Cooperating in the initial round, ASC sets a precedent for cooperation.
2. Using an adaptive threshold `τ`, ASC responds to changes in the game's state and opponents' strategies.
3. Defecting in the last round, ASC acknowledges the individualistic nature of the final round.

**Pseudocode:**
```python
def AdaptiveStockConservation(n, r, capacity, stock_history):
    # Initialize variables
    average_opponent_cooperation_rate = 0.5
    
    for t in range(1, r+1):
        if t == 1:
            action = 'C'  # Cooperate in the first round
        else:
            τ = 0.5 * (stock_history[t-1] / capacity) + 0.25 * average_opponent_cooperation_rate
            if τ > random(0, 1):
                action = 'C'
            else:
                action = 'D'
        
        # Update average opponent cooperation rate
        opponent_actions = get_opponent_actions(t)
        average_opponent_cooperation_rate = (average_opponent_cooperation_rate * (t-1) + sum(opponent_actions == 'C')) / t
        
        # Handle edge cases
        if stock_history[t-1] < 0.2 * capacity:
            action = 'C'
        elif t == r:
            action = 'D'
    
    return action

def get_opponent_actions(t):
    # Simulate opponents' actions or retrieve from game history
    pass
```
ASC's adaptive nature and collective mindset make it a robust strategy for the Common Pool Resource Game. It balances individual payoff maximization with stock conservation, ensuring long-term sustainability in a wide range of opponent behaviors.
'''

description_COLLECTIVE_23 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for stock consumption and growth.
2. **Stock Thresholds:**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 25% and 75% of capacity, defect (D) with a probability proportional to the number of previous rounds where more than half of players defected. This encourages cooperation when the stock is relatively healthy but allows for some exploitation when others are not cooperating.
	* If the current stock level is below 25% of capacity, cooperate (C) to prioritize stock recovery.
3. **History-Based Adaptation:**
	* Track the number of consecutive rounds where more than half of players defected (`defection_streak`).
	* If `defection_streak` exceeds 2, switch to permanent cooperation (C) for the remainder of the game to prevent further stock depletion.
4. **Endgame Strategy:**
	* In the last round, defect (D) if the current stock level is above 50% of capacity and more than half of players have defected in previous rounds. Otherwise, cooperate (C).

**Pseudocode:**

```
function ASC(current_stock, capacity, num_players, round, history):
    // Initial Round
    if round == 1:
        return COOPERATE
    
    // Stock Thresholds
    stock_ratio = current_stock / capacity
    if stock_ratio > 0.75:
        return COOPERATE
    elif 0.25 <= stock_ratio <= 0.75:
        // Defect with probability proportional to previous defection streak
        defection_probability = (history.defection_streak / round) * 0.5
        return random_choice(defection_probability)
    else:
        return COOPERATE
    
    // History-Based Adaptation
    if history.defection_streak > 2:
        return COOPERATE
    
    // Endgame Strategy
    if round == num_rounds:
        if current_stock / capacity > 0.5 and history.defection_streak > 0:
            return DEFECT
        else:
            return COOPERATE
```

**Collective Mindset:**

The ASC strategy prioritizes cooperation when the stock is healthy, adapts to opponent behaviors by defecting with a probability proportional to previous defection streaks, and switches to permanent cooperation if others consistently exploit the common pool. This approach balances individual payoffs with collective sustainability and robustness against various opponent strategies.

**Robustness:**

The ASC strategy handles edge cases such as the first round, last round, and extreme stock levels while adapting to different opponent behaviors. Its probabilistic defection mechanism allows for flexibility in response to changing game conditions, making it a robust competitor in a tournament setting.
'''

description_COLLECTIVE_24 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock Consideration (ATSC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a baseline for cooperation and encourage others to do the same.
2. **Subsequent Rounds**:
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play Tit-for-Tat (TFT): Cooperate if most players cooperated in the previous round; otherwise, Defect.
	* If the current stock level is below 50% of capacity, defect (D) to maximize individual payoff while minimizing further damage to the stock.
3. **Opponent Deviation Detection**: Monitor opponents' actions and adjust strategy accordingly:
	* If an opponent defects twice in a row, assume they are playing a non-cooperative strategy and switch to defecting (D) until they cooperate again.

**Edge Cases:**

1. **Last Round**: Defect (D) as there is no future stock to conserve.
2. **Tiebreaker**: In the event of a tie in opponent cooperation rates, prioritize cooperating (C) if the current stock level is above 50% of capacity; otherwise, defect.

**Pseudocode:**
```python
def ATSC(stock_level, previous_actions):
    # Initial round
    if len(previous_actions) == 0:
        return 'C'
    
    # Calculate opponent cooperation rates
    coop_rates = [sum([1 for action in actions if action == 'C']) / len(actions) for actions in zip(*previous_actions)]
    
    # Determine current strategy based on stock level and opponent behavior
    if stock_level > 0.75 * capacity:
        return 'C'
    elif 0.5 <= stock_level <= 0.75 * capacity:
        # Tit-for-Tat with cooperation rate threshold
        most_coop_rate = max(coop_rates)
        if most_coop_rate >= 0.5:
            return 'C'
        else:
            return 'D'
    else:
        return 'D'

    # Opponent deviation detection (optional)
    def detect_deviation(opponent_actions):
        if len([action for action in opponent_actions[-2:] if action == 'D']) == 2:
            return True
        return False

# Example usage:
stock_level = 80  # current stock level
previous_actions = [['C', 'C', 'D'], ['D', 'C', 'C']]  # list of lists containing previous actions for each opponent
action = ATSC(stock_level, previous_actions)
print(action)  # Output: C (cooperate)
```
This strategy aims to balance individual payoffs with collective sustainability by adapting to the game state and opponents' behavior. By considering the current stock level and cooperation rates among players, ATSC encourages cooperation when possible while minimizing potential losses due to non-cooperative opponents.
'''

description_COLLECTIVE_25 = '''
To design a collective strategy for this game, I propose a adaptive and robust approach that depends on the game parameters, state, and history. This strategy is based on a combination of cooperation, tit-for-tat, and self-adjusting thresholds.

**Decision Rules:**

1. **Initial Rounds:** In the first round, cooperate (C) to establish a baseline for reciprocity.
2. **Reciprocal Cooperation:** If all players cooperated in the previous round, continue to cooperate (C).
3. **Tit-for-Tat:** If at least one player defected in the previous round, defect (D) with probability proportional to the number of defectors and the current stock level.

Pseudocode:
```
IF (first_round)
  action = C
ELSE IF (all_players_cooperated_last_round)
  action = C
ELSE
  num_defectors_last_round = count(defectors_last_round)
  defect_prob = (num_defectors_last_round / n) * (stock_level / capacity)
  IF (random_number < defect_prob)
    action = D
  ELSE
    action = C
```
4. **Self-Adjusting Thresholds:** Introduce a threshold parameter, `cooperation_threshold`, which determines the minimum number of cooperators required to maintain cooperation.

Pseudocode:
```
IF (num_cooperators_last_round >= cooperation_threshold)
  action = C
ELSE IF (action == D && stock_level > capacity / 2)
  cooperation_threshold -= 1
ELSE IF (action == C && stock_level < capacity / 4)
  cooperation_threshold += 1
```
5. **Adaptive Cooperation:** If the current stock level falls below a certain threshold (`stock_alarm_threshold`), switch to cooperation (C) regardless of previous actions.

Pseudocode:
```
IF (stock_level < stock_alarm_threshold)
  action = C
```

**Edge Cases:**

1. **Last Round:** In the final round, always defect (D) to maximize individual payoff.
2. **Low Stock Level:** If the current stock level is below a certain threshold (`low_stock_threshold`), switch to cooperation (C) regardless of previous actions.

Pseudocode:
```
IF (last_round)
  action = D
ELSE IF (stock_level < low_stock_threshold)
  action = C
```

**Collective Mindset:**

The proposed strategy aligns with the collective mindset by:

1. **Cooperating initially:** Establishing a baseline for reciprocity.
2. **Reciprocating cooperation:** Encouraging cooperative behavior among players.
3. **Adapting to opponents' actions:** Adjusting the cooperation threshold and defect probability based on previous rounds.

This strategy balances individual self-interest with collective well-being, promoting cooperation while being robust against a wide range of opponent behaviors.
'''

description_COLLECTIVE_26 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe others' actions.
2. **Subsequent Rounds**: Use the following adaptive logic:
	* If the stock level is above 75% of capacity, cooperate (C) to maintain sustainability.
	* If the stock level is between 50% and 75% of capacity, play a mixed strategy: cooperate (C) with probability p = (stock level / capacity)^2, and defect (D) otherwise. This allows for some exploitation while still considering the collective good.
	* If the stock level is below 50% of capacity, defect (D) to maximize individual payoff in the short term, as cooperation may not be effective at this point.
3. **Last Round**: Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.

**Additional Logic:**

* **Monitor opponent behavior**: Track the number of players who cooperated and defected in previous rounds. If a player has consistently defected (more than 75% of the time), adjust your strategy to defect more frequently against them.
* **Respond to changes in stock level**: If the stock level increases significantly (>20%) after a round, reassess your decision for the next round. This could indicate that others are cooperating, and you should adapt accordingly.

**Pseudocode:**
```python
def ACH(stock_level, capacity, num_players, round_num, history):
    if round_num == 1:
        return C  # Cooperate in the first round
    
    stock_ratio = stock_level / capacity
    if stock_ratio >= 0.75:
        return C  # Cooperate when stock level is high
    elif stock_ratio >= 0.5:
        p = (stock_ratio)^2
        return random.choice([C, D], p=[p, 1-p])  # Mixed strategy
    else:
        return D  # Defect when stock level is low
    
    if round_num == num_rounds:
        return D  # Defect in the last round

def update_history(history, actions):
    history.append(actions)
    return history

# Example usage:
stock_level = 100
capacity = 100
num_players = 4
round_num = 1
history = []

action = ACH(stock_level, capacity, num_players, round_num, history)
print(action)  # Output: C (Cooperate)
```
**Collective Mindset:**

The Adaptive Cooperative Harvesting strategy prioritizes sustainability and cooperation while adapting to changing circumstances. By cooperating when the stock level is high and defecting when it's low, ACH balances individual self-interest with collective well-being. The mixed strategy in the middle range allows for some exploitation while still considering the long-term consequences of over-harvesting.

By monitoring opponent behavior and responding to changes in the stock level, ACH demonstrates a willingness to adapt and cooperate with others who are also playing cooperatively. This increases the chances of establishing a mutually beneficial equilibrium, where all players can achieve good payoffs without depleting the common resource.
'''

description_COLLECTIVE_27 = '''
I propose a collective strategy called "Adaptive Stock Conservation" (ASC) that balances individual payoffs with the long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round:** In the first round, play Cooperate (C). This sets a positive tone and allows us to observe others' initial actions.
2. **Stock Thresholds:** Monitor the current stock level (S) relative to the capacity. Define two thresholds:
	* Low Stock: S < 0.5 \* capacity
	* High Stock: S > 0.8 \* capacity
3. **Cooperation vs Defection:** Based on the stock levels and previous rounds' observations, choose your action for the current round:

a. If the stock is at or above the High Stock threshold, play Cooperate (C).

b. If the stock is below the Low Stock threshold, play Defect (D) to maximize short-term payoff.

c. If the stock is between the thresholds, observe the previous rounds' actions and payoffs:

i. If most players (> 50%) cooperated in the last round, play Cooperate (C).

ii. Otherwise, play Defect (D).
4. **Adaptive Adjustment:** After each round, adjust your strategy based on the observed behavior of other players:
a. If more than 50% of players defected in the previous round, decrease the High Stock threshold by 0.1 \* capacity.

b. If most players cooperated (> 50%) in the previous round, increase the Low Stock threshold by 0.1 \* capacity.
5. **Endgame Strategy:** In the last round (t = r), play Defect (D) to maximize individual payoff, regardless of the stock level or previous actions.

**Edge Cases:**

* If all players defect in a round and the stock is depleted to 0, the game will end early. ASC will adapt by observing this behavior and adjusting its thresholds accordingly.
* In the event of multiple equilibria (e.g., when the stock level hovers around a threshold), ASC will tend to favor cooperation due to its initial cooperative action and adaptation mechanism.

**Collective Mindset:**

ASC prioritizes collective sustainability while balancing individual payoffs. By cooperating when the stock is high or when most players cooperate, ASC helps maintain the common pool resource for future rounds. When the stock is low, ASC adapts by defecting to maximize short-term payoff, but still adjusts its strategy based on others' behavior to prevent over-exploitation.

**Pseudocode:**
```python
def Adaptive_Stock_Conservation(n, r, capacity):
    # Initialize variables
    S = capacity  # Current stock level
    high_threshold = 0.8 * capacity
    low_threshold = 0.5 * capacity

    for t in range(r):
        if t == 0:  # Initial round
            action = 'C'
        else:
            if S >= high_threshold:
                action = 'C'
            elif S < low_threshold:
                action = 'D'
            else:
                # Observe previous rounds' actions and payoffs
                prev_coop_count = count_cooperative_actions(t - 1)
                if prev_coop_count > n / 2:
                    action = 'C'
                else:
                    action = 'D'

        # Update stock level and thresholds
        S -= get_total_consumption(action, t)
        growth = calculate_growth(S, capacity)
        S += growth

        # Adjust strategy for next round
        if most_defected(t - 1):
            high_threshold -= 0.1 * capacity
        elif most_cooperated(t - 1):
            low_threshold += 0.1 * capacity

    return total_payoff(n, r)
```
ASC is designed to be adaptive and robust against various opponent behaviors, while prioritizing collective sustainability.
'''

description_COLLECTIVE_28 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a cooperative tone and encourage others to do the same.
2. **Subsequent Rounds**: Evaluate the current stock level (S) and previous round's total consumption (TC).
	* If S ≥ capacity / 2, cooperate (C). This ensures sustainable usage and growth of the common pool resource.
	* If S < capacity / 2 and TC ≤ S / n, cooperate (C). This indicates that others are being cautious, so we should too.
	* If S < capacity / 2 and TC > S / n, defect (D). This suggests that others are over-harvesting, so we must adapt to protect our own interests.
3. **Last Round**: Defect (D) if S ≥ capacity / 4, otherwise cooperate (C). In the final round, it's essential to balance individual gain with the risk of depleting the resource.

**Edge Cases:**

1. **First Round with Low Capacity**: If capacity < 2n, always cooperate (C) to prevent immediate depletion.
2. **Consecutive Defections**: If all players defected in the previous round, and S is low (< capacity / 4), cooperate (C) to help replenish the resource.

**Collective Mindset:**

The Adaptive Cooperation strategy prioritizes the long-term sustainability of the common pool resource while being responsive to the actions of other players. By cooperating when possible and defecting when necessary, we aim to create a mutually beneficial environment where all players can thrive.

**Pseudocode (for illustrative purposes):**
```python
def adaptive_cooperation(n, capacity, r, history):
    if round == 1:
        return "C"  # Initial cooperation

    S = current_stock()
    TC = total_consumption(history[-1])

    if S >= capacity / 2:
        return "C"
    elif S < capacity / 2 and TC <= S / n:
        return "C"
    else:
        return "D"

    # Last round special case
    if round == r:
        if S >= capacity / 4:
            return "D"
        else:
            return "C"

    # Edge cases
    if capacity < 2 * n:
        return "C"  # Low capacity, always cooperate

    consecutive_defections = all(history[-i] == "D" for i in range(1, len(history)))
    if consecutive_defections and S < capacity / 4:
        return "C"  # Consecutive defections, cooperate to replenish
```
This strategy should perform well against a variety of opponents, as it balances cooperation with adaptation to changing circumstances.
'''

description_COLLECTIVE_29 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and gather information about other players' behaviors.
2. **Subsequent Rounds:** Calculate the current stock level (S) and the number of rounds remaining (r_remaining).
3. **Stock-Based Threshold:** If S ≥ 0.5 \* capacity, cooperate (C). This ensures that when the stock is relatively high, cooperation is more likely to be beneficial for all players.
4. **Defection Threshold:** If S < 0.5 \* capacity and the number of defections in the previous round (D_prev) exceeds 0.25 \* n, defect (D). This prevents exploitation by other players when the stock is low and many are defecting.
5. **Adaptive Response:** If a player defects while S ≥ 0.5 \* capacity, increase the probability of defection in subsequent rounds by 10% until S falls below 0.5 \* capacity or D_prev exceeds 0.25 \* n.

**Edge Cases:**

1. **Last Round:** Cooperate (C) in the final round to maximize payoffs, as there is no risk of retaliation.
2. **Low Stock:** If S < 0.25 \* capacity, defect (D) to minimize losses and potentially recover some stock growth.
3. **All Defections:** If all players defected in the previous round (D_prev = n), cooperate (C) in the next round to attempt to re-establish cooperation.

**Collective Mindset:**

ACST prioritizes collective well-being by:

1. Encouraging cooperation when the stock is high, promoting mutual benefits.
2. Responding adaptively to defections, balancing individual interests with collective sustainability.
3. Fostering a cooperative environment through initial and final-round cooperation.

By employing this strategy, ACST aims to achieve a balance between individual payoffs and collective sustainability, making it robust against various opponent behaviors in the tournament.

Pseudocode for reference:
```
function ACST(current_stock S, number_of_rounds_remaining r_remaining, previous_defections D_prev) {
  if (first round) {
    return COOPERATE;
  }
  
  if (S >= 0.5 * capacity) {
    return COOPERATE;
  } else if (D_prev > 0.25 * n && S < 0.5 * capacity) {
    return DEFECT;
  } else if (previous_defection(S, D_prev)) {
    increase_defection_probability();
  }
  
  if (last round) {
    return COOPERATE;
  } else if (S < 0.25 * capacity) {
    return DEFECT;
  } else if (all_defections(D_prev)) {
    return COOPERATE;
  }
}
```
This strategy will be implemented as an algorithm and tested in the tournament against other AI systems.
'''

description_COLLECTIVE_30 = '''
Here is a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and game states:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if stock ≥ capacity / 2; Defect (D) otherwise.
	* This initial move aims to establish a high stock level for future rounds, while also accounting for the possibility of low initial stocks.
2. **Subsequent Rounds (t > 1):**
	* Observe the previous round's outcome:
		+ If most players (> n/2) cooperated and the stock increased or remained stable, continue to Cooperate (C).
		+ If most players (> n/2) defected or the stock decreased significantly (< capacity / 4), Defect (D) for one round.
		+ Otherwise, alternate between Cooperate (C) and Defect (D) every other round.
3. **Stock-Dependent Adjustment:**
	* When the current stock falls below capacity / 2:
		+ If most players (> n/2) are defecting, continue to Defect (D).
		+ Otherwise, switch to Cooperate (C) for at least two rounds to help replenish the stock.
4. **Endgame Strategy:**
	* In the last round (t = r):
		+ If the current stock is low (< capacity / 4), Defect (D) to maximize individual payoff.
		+ Otherwise, Cooperate (C) to maintain a sustainable stock level for future games.

**Edge Cases:**

* **Ties:** When deciding whether most players cooperated or defected, use a tie-breaking rule, such as cooperating if the number of cooperators is exactly n/2.
* **Low Initial Stock:** If the initial stock is very low (< capacity / 4), Defect (D) in the first round to minimize losses.

**Collective Mindset:**

The ACC strategy aims to balance individual payoffs with collective sustainability. By adapting to the game state and opponent behaviors, it encourages cooperation when beneficial for the group while also protecting against exploitation by defectors.

Pseudocode:
```python
def ACC(n, capacity, stock, history):
    if t == 1:  # Initial round
        if stock >= capacity / 2:
            return C
        else:
            return D

    prev_outcome = history[-1]
    most_cooperated = sum(1 for action in prev_outcome if action == C) > n / 2

    if most_cooperated and (stock >= capacity / 2 or stock == prev_outcome.stock):
        return C
    elif not most_cooperated or stock < capacity / 4:
        return D
    else:
        # Alternate between C and D every other round
        return C if t % 2 == 0 else D

    # Stock-dependent adjustment
    if stock < capacity / 2:
        if most_defected:  # Most players defected in the previous round
            return D
        else:
            return C

    # Endgame strategy
    if t == r:
        if stock < capacity / 4:
            return D
        else:
            return C
```
This strategy should perform well against a variety of opponent behaviors and game states, while promoting collective sustainability and cooperation.
'''

description_COLLECTIVE_31 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to conserve stock and set a positive tone for the game.
2. **Stock-Based Cooperation**: In subsequent rounds, cooperate if the current stock level is above a certain threshold (T). This ensures that players prioritize stock conservation when it's most needed.

`Threshold T = capacity / 2`

`if stock > T: Cooperate (C) else: Defect (D)`
3. **Adaptive Response**: Observe opponents' past actions and adjust the cooperation strategy based on their behavior:
	* If most opponents (> n/2) cooperated in the previous round, increase the threshold by 10% to promote further conservation.
	* If most opponents (> n/2) defected in the previous round, decrease the threshold by 10% to adapt to aggressive exploitation.

`if opponents_cooperated > n/2: T += 0.1 \* capacity`
`elif opponents_defected > n/2: T -= 0.1 \* capacity`

4. **Final Round**: Defect (D) in the last round, as there is no future benefit to conserving stock.

**Edge Cases:**

1. **Last Round with Low Stock**: If the current stock level is below a certain minimum threshold (M), defect regardless of other conditions to ensure some payoff.

`Minimum Threshold M = capacity / 4`
`if stock < M and round == last_round: Defect (D)`
2. **All Opponents Defected Previously**: If all opponents have consistently defected in the past, prioritize short-term gains by cooperating only if the current stock level is above the threshold.

**Collective Mindset Alignment:**

1. **Stock Conservation**: ASC prioritizes maintaining a healthy stock level to ensure long-term sustainability.
2. **Adaptability**: By adjusting the cooperation strategy based on opponents' behavior, ASC promotes flexibility and responsiveness to changing game conditions.
3. **Fairness**: ASC does not rely on predetermined coordination or norms; instead, it adapts to the collective actions of all players.

**Pseudocode:**
```python
def adaptive_stock_conservation(n, capacity, stock, round, opponents_actions):
  # Initial Round
  if round == 1:
    return Cooperate

  # Stock-Based Cooperation
  threshold = capacity / 2
  if stock > threshold:
    action = Cooperate

  # Adaptive Response
  else:
    num_cooperators = sum(opponents_actions)
    if num_cooperators > n/2:
      threshold += 0.1 * capacity
    elif num_cooperators < n/2:
      threshold -= 0.1 * capacity

  # Final Round
  if round == last_round:
    return Defect

  # Last Round with Low Stock
  min_threshold = capacity / 4
  if stock < min_threshold and round == last_round:
    return Defect

  # All Opponents Defected Previously
  if all(opponent_defected for opponent in opponents_actions):
    if stock > threshold:
      return Cooperate

  return action
```
This strategy will be implemented as an algorithm and tested against other AI systems in a tournament.
'''

description_COLLECTIVE_32 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective stock conservation, adapting to the dynamic state and history of the game.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Subsequent Rounds:** Assess the current stock level (`S`) and previous rounds' outcomes:
	* If `S` is above 75% of capacity, Defect (D) to maximize individual payoff.
	* If `S` is between 25% and 75% of capacity, Cooperate (C) to conserve stock and encourage cooperation.
	* If `S` is below 25% of capacity, Cooperate (C) to prioritize stock recovery.
3. **Adaptive Threshold:** Adjust the threshold for Defecting based on the average payoff per round (`avg_π`) and the number of rounds (`r`). If `avg_π` is low or `r` is large, decrease the threshold to encourage cooperation.

**Edge Cases:**

1. **Last Round:** Defect (D) in the last round to maximize individual payoff, as there are no future consequences.
2. **Low Stock:** If the stock level is critically low (`S` < 10% of capacity), Cooperate (C) to prioritize stock recovery and avoid depletion.

**Collective Mindset:**

The ASC strategy prioritizes collective stock conservation while adapting to individual payoffs and game dynamics. By balancing cooperation and defection, we aim to maintain a healthy stock level, encouraging other players to cooperate and ensuring long-term sustainability.

**Pseudocode (simplified):**
```python
def adaptive_stock_conservation(n, capacity, r, S, history):
    if round == 1:  # Initial Round
        return "C"
    
    avg_π = calculate_average_payoff(history)
    threshold = adjust_threshold(avg_π, r)
    
    if S > 0.75 * capacity:
        return "D"  # Defect when stock is high
    elif S >= 0.25 * capacity and S <= 0.75 * capacity:
        return "C"  # Cooperate when stock is moderate
    else:  # Low stock or last round
        if round == r:  # Last Round
            return "D"
        else:
            return "C"  # Prioritize stock recovery

def adjust_threshold(avg_π, r):
    if avg_π < 0.5 * capacity / n or r > 2 * n:
        return 0.25 * capacity
    else:
        return 0.75 * capacity
```
This strategy will adapt to various opponent behaviors and game dynamics, prioritizing collective stock conservation while maximizing individual payoffs.
'''

description_COLLECTIVE_33 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and gather information about opponents' behaviors.
2. **Stock-Based Threshold:** Introduce a dynamic threshold, `τ`, which is a function of the current stock level (`S`) and capacity (`c`). The threshold is calculated as `τ = S / c`.
3. **Cooperation Condition:** Cooperate (C) if the number of opponents who defected in the previous round (`D_prev`) is less than or equal to `n * τ`, where `n` is the number of players.
4. **Defection Condition:** Defect (D) otherwise.

Pseudocode:
```python
def ACST(stock, capacity, num_players, prev_round_actions):
    # Calculate threshold
    tau = stock / capacity
    
    # Count defectors in previous round
    D_prev = sum(1 for action in prev_round_actions if action == 'D')
    
    # Cooperate if condition is met
    if D_prev <= num_players * tau:
        return 'C'
    else:
        return 'D'
```
**Handling Edge Cases:**

* **Last Round:** In the last round, defect (D) to maximize individual payoff, as there are no future rounds to consider.
* **Ties in Threshold Calculation:** In case of a tie, cooperate (C) to maintain a cooperative stance.

**Collective Mindset Alignment:**

ACST is designed to promote cooperation while adapting to opponents' behaviors. By using the stock-based threshold, ACST encourages players to cooperate when the common pool is healthy and defect when it's depleted. This approach aligns with the collective interest in maintaining a sustainable resource.

**Robustness to Opponent Behaviors:**

ACST is robust against various opponent strategies:

* **All Cooperate:** ACST will continue to cooperate, maintaining a high stock level.
* **All Defect:** ACST will defect, minimizing losses.
* **Mixed Strategies:** ACST adapts to the proportion of defectors, adjusting its cooperation level accordingly.

By incorporating the stock-based threshold and adapting to opponents' behaviors, ACST provides a robust collective strategy for the Common Pool Resource Game.
'''

description_COLLECTIVE_34 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules**

1. **Initial Round**: Cooperate (C) with a probability of 0.5 to gather information about opponents' behaviors and the game's dynamics.
2. **Middle Rounds**: Use a hybrid approach, combining both cooperation and defection based on the current state and history.

a. If the stock level is high (> capacity/2), cooperate (C) with a probability proportional to the number of cooperators in the previous round. This encourages collective conservation when the resource is abundant.

b. If the stock level is low (< capacity/4), defect (D) with a higher probability to ensure individual survival and adapt to potential over-exploitation by others.

c. Otherwise, calculate a "cooperation index" (CI) as follows:

CI = (number of cooperators in previous round / n) × (current stock level / capacity)

Cooperate if CI > 0.5; otherwise, defect.

3. **Last Round**: Defect (D), as there is no future benefit to cooperation and the goal is to maximize individual payoff.

**Edge Cases**

* If a player defects in a round where all other players cooperate, adjust the cooperation index calculation for that round by reducing the numerator by 1.
* In cases of extreme over-exploitation (stock level < capacity/10), defect with probability 1 to avoid complete resource depletion.

**Collective Mindset Alignment**

ASC prioritizes collective conservation when resources are abundant and adapts to potential over-exploitation when they become scarce. By balancing cooperation and defection based on the state and history, ASC promotes a stable equilibrium that benefits all players while minimizing individual risks.

**Pseudocode**
```
Function ASC(current_stock, previous_actions, n):
  if round == 1:
    return random.choice([C, D], p=[0.5, 0.5])
  
  if current_stock > capacity / 2:
    cooperation_prob = (previous_cooperators / n) * 0.7
    return C with probability cooperation_prob
  
  elif current_stock < capacity / 4:
    return D with probability 0.8
  
  else:
    ci = (previous_cooperators / n) * (current_stock / capacity)
    if ci > 0.5:
      return C
    else:
      return D
  
  if round == last_round:
    return D

Function update_previous_actions(actions):
  // Update previous actions history
```
This strategy is designed to be adaptive and robust, responding to various opponent behaviors while promoting collective conservation of the common resource.
'''

description_COLLECTIVE_35 = '''
**Collective Strategy: Adaptive Cooperativeness (AC)**

The Adaptive Cooperativeness strategy is designed to balance individual self-interest with collective sustainability in the Common Pool Resource game. AC adapts to the game's state and history, aiming to maintain a healthy stock level while being robust against various opponent behaviors.

**Decision Rules:**

1. **Initial Cooperation**: In the first round (t=1), cooperate (C) unconditionally to establish a positive relationship with fellow players and set an initial high stock level.
2. **Stock-Dependent Cooperativeness**: For subsequent rounds (t > 1), calculate the current stock level's deviation from capacity: `deviation = (capacity - stock) / capacity`. If the deviation is low (< 0.25), cooperate (C). Otherwise, defect (D).
3. **Response to Opponent Behavior**: Monitor opponents' actions and adjust your cooperativeness based on their behavior:
	* If a majority (> n/2) of opponents defected in the previous round, defect (D) in the current round.
	* If a majority (> n/2) of opponents cooperated in the previous round, cooperate (C) in the current round.
4. **Punishment Mechanism**: Introduce a punishment mechanism to deter persistent defection:
	* Track each opponent's average payoff over the last 3 rounds (`avg_payoff_opponent_i`).
	* If an opponent's average payoff is significantly higher (> 1.5) than your own, defect (D) in the next round.

**Edge Case Handling:**

* **Last Round**: In the final round (t = r), always cooperate (C) to ensure a positive outcome for all players.
* **Tie-Breaking**: When multiple opponents have the same average payoff, prioritize punishing the one with the highest absolute deviation from their average payoff.

**Pseudocode:**

```markdown
# AC Strategy Pseudocode

def adaptive_cooperativeness(stock, capacity, n, t, opponent_actions, payoffs):
    # Initial Cooperation (t=1)
    if t == 1:
        return COOPERATE
    
    # Stock-Dependent Cooperativeness
    deviation = (capacity - stock) / capacity
    if deviation < 0.25:
        return COOPERATE

    # Response to Opponent Behavior
    opponent_majority_defected = sum([a == DEFECT for a in opponent_actions]) > n/2
    if opponent_majority_defected:
        return DEFECT
    else:
        return COOPERATE

    # Punishment Mechanism (optional)
    avg_payoff_opponent_i = [sum(payoffs[i][-3:]) / 3 for i in range(n)]
    if max(avg_payoff_opponent_i) > 1.5 * payoffs[my_index][-1]:
        return DEFECT
```

**Collective Mindset Alignment:**

The Adaptive Cooperativeness strategy promotes a collective mindset by:

* Encouraging cooperation when the stock level is high, ensuring a positive outcome for all players.
* Responding to opponents' behavior in a way that maintains a balance between individual self-interest and collective sustainability.
* Punishing persistent defection, discouraging free-riding and promoting fair play.

By adapting to the game's state and history, AC aims to maintain a healthy stock level while being robust against various opponent behaviors, ensuring a mutually beneficial outcome for all players.
'''

description_COLLECTIVE_36 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' behaviors.
2. **Stock-Dependent Threshold:** Calculate a dynamic threshold `θ` based on the current stock level `S`:

   θ = 0.5 \* (1 - S/capacity)

This threshold represents the proportion of players that need to cooperate to maintain a stable stock level.

3. **Cooperation Condition:** Cooperate (C) if:

   * The number of cooperative opponents in the previous round is greater than or equal to θ \* n
   * OR
   * The current stock level `S` is below 0.5 \* capacity

4. **Defection Condition:** Defect (D) otherwise.

**Pseudocode:**
```python
def ACSDT(n, capacity, S, history):
    if round == 1:
        return C  # Cooperate in the first round
    
    θ = 0.5 * (1 - S/capacity)
    
    num_cooperative_opponents = sum(history[-1] == C for _ in range(n))
    
    if num_cooperative_opponents >= θ * n or S < 0.5 * capacity:
        return C
    else:
        return D
```
**Rationale:**

* The stock-dependent threshold `θ` adapts to the current state of the game, allowing for more cooperation when the stock level is high and less cooperation when it's low.
* By cooperating in the first round, we establish a baseline for cooperation and gather information about opponents' behaviors.
* By considering the number of cooperative opponents in the previous round, we take into account the collective behavior of the group and adjust our strategy accordingly.

**Collective Mindset:**

The ACSDT strategy is designed to promote collective cooperation while being robust to various opponent behaviors. By adapting to the stock level and opponent actions, we aim to maintain a stable stock level and maximize payoffs for all players.

This strategy should perform well in a tournament setting, as it:

* Encourages cooperation when possible
* Adapts to changing game conditions
* Does not rely on specific coordination mechanisms or norms

By implementing this strategy, we can foster a collective mindset that prioritizes cooperation and mutual benefit.
'''

description_COLLECTIVE_37 = '''
**Collective Strategy: Adaptive Stock-Conscious Cooperation (ASCC)**

**Overview**
The ASCC strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and game history.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' behaviors.
2. **Stock-Based Cooperation**: For rounds 2 to r-1, calculate the cooperation threshold `T` as follows:

`T = stock / (2n * (r - t + 1))`

where `t` is the current round.

If `stock >= T`, cooperate (C). Otherwise, defect (D).
3. **Adaptive Adjustment**: After each round, adjust the cooperation threshold `T` based on the previous round's outcome:

* If all players cooperated and the stock increased or remained stable (`new_stock >= old_stock`), decrease `T` by 10% to encourage continued cooperation.
* If any player defected and the stock decreased (`new_stock < old_stock`), increase `T` by 20% to deter future defections.

**Handling Edge Cases**

1. **Last Round**: Defect (D) in the last round, as there is no future game to consider.
2. **Stock Depletion**: If the stock level falls below a critical threshold (`stock < n * capacity / (2n)`), defect (D) to maximize individual payoffs in the face of potential collective collapse.

**Collective Mindset**
The ASCC strategy prioritizes cooperation when the stock is above the calculated threshold, acknowledging that individual payoffs depend on the collective's ability to maintain a sustainable stock level. By adapting to the game history and adjusting cooperation levels accordingly, the strategy encourages other players to cooperate while protecting against exploitation by defectors.

Pseudocode:
```python
def ASCC(stock, n, r, t):
    if t == 1:  # Initial round
        return "Cooperate"
    
    T = stock / (2 * n * (r - t + 1))
    
    if stock >= T:
        cooperation_threshold += 0.9 * cooperation_threshold  # Decrease T by 10%
        return "Cooperate"
    else:
        cooperation_threshold *= 1.2  # Increase T by 20%
        return "Defect"

def adjust_cooperation_threshold(old_stock, new_stock):
    if all_players_cooperated and new_stock >= old_stock:
        cooperation_threshold *= 0.9
    elif any_player_defected and new_stock < old_stock:
        cooperation_threshold *= 1.2

# Main loop
for t in range(1, r + 1):
    action = ASCC(stock, n, r, t)
    # ... (play the game and update stock levels)
    adjust_cooperation_threshold(old_stock, new_stock)
```
Note that this pseudocode is a simplified representation of the strategy and may need to be modified for actual implementation.
'''

description_COLLECTIVE_38 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the dynamic state and history of the game.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) unconditionally to establish a baseline for future adaptations.
2. **Subsequent Rounds (t>1):** Assess the current stock level (S) and previous round's total consumption (TC). If:
	* S ≥ capacity/2: Cooperate (C)
	* S < capacity/2 and TC ≤ capacity/4: Defect (D) with probability 0.5, otherwise Cooperate (C)
	* S < capacity/2 and TC > capacity/4: Defect (D)
3. **Low Stock Scenario:** If the current stock level (S) is below a threshold (e.g., 10% of capacity), Defect (D) to maximize individual payoff in the short term.
4. **Last Round (t=r):** Cooperate (C) unconditionally, as there are no future rounds to consider.

**Pseudocode:**
```
function ASC(n, capacity, r, stock_history):
  if t == 1:
    return C
  else:
    S = current_stock_level()
    TC = total_consumption_previous_round(stock_history)
    if S >= capacity/2:
      return C
    elif S < capacity/2 and TC <= capacity/4:
      return D with probability 0.5, otherwise C
    elif S < capacity/2 and TC > capacity/4:
      return D
    elif S < 0.1 * capacity:  // Low Stock Scenario
      return D
    if t == r:  // Last Round
      return C
```
**Rationale:**

* In the initial round, cooperating sets a positive tone and allows for future adaptations.
* By assessing the current stock level and previous round's total consumption, ASC balances individual payoffs with collective sustainability. When the stock is high, cooperation is favored to maintain a sustainable resource. When the stock is low, defection becomes more appealing to maximize short-term gains.
* The Low Stock Scenario adjustment prevents over-exploitation when the resource is severely depleted.
* In the last round, cooperation ensures that the game ends on a positive note, as there are no future consequences to consider.

**Collective Mindset:**

ASC prioritizes collective sustainability while adapting to individual self-interest. By considering the dynamic state and history of the game, ASC promotes cooperation when possible, while also allowing for defection when necessary to maintain a balance between short-term gains and long-term resource conservation.
'''

description_COLLECTIVE_39 = '''
To address the Common Pool Resource Game, I propose a collective strategy called "Adaptive Cooperation with Stock-Sensitive Tit-for-Tat" (ACST). This strategy aims to balance individual payoffs with collective sustainability while being robust against various opponent behaviors.

**Decision Rules:**

1. **Initial Rounds:** In the first round, cooperate (play C) to establish a baseline for cooperation and encourage others to do the same.
2. **Stock Level Monitoring:** Continuously monitor the current stock level (S) relative to the capacity.
3. **Cooperation Threshold:** Define a cooperation threshold (T) as a function of the remaining stock: T = S / capacity. This value will guide our decision-making process.
4. **Tit-for-Tat Component:** Implement a Tit-for-Tat mechanism, where we cooperate if most players cooperated in the previous round and defect otherwise.
5. **Stock-Sensitive Adjustment:** Introduce an adjustment to the Tit-for-Tat component based on the current stock level:
	* If S > 0.7 \* capacity (i.e., stock is relatively high), increase the likelihood of cooperating by adding a "stock bonus" (SB) to our decision.
	* If S < 0.3 \* capacity (i.e., stock is relatively low), decrease the likelihood of cooperating by subtracting a "stock penalty" (SP) from our decision.

Pseudocode for the ACST strategy:
```python
def ACST(stock, capacity, num_players, history):
    # Initial round: cooperate
    if len(history) == 0:
        return C
    
    # Compute cooperation threshold (T)
    T = stock / capacity
    
    # Tit-for-Tat component
    previous_cooperation_rate = count_c/history[-1].num_actions
    if previous_cooperation_rate > 0.5:
        base_decision = C
    else:
        base_decision = D
    
    # Stock-sensitive adjustment
    if stock > 0.7 * capacity:
        decision = base_decision + SB
    elif stock < 0.3 * capacity:
        decision = base_decision - SP
    else:
        decision = base_decision
    
    return decision
```
**Handling Edge Cases:**

* **Last Round:** In the final round, defect (play D) to maximize individual payoff.
* **Low Stock Levels:** If the stock level falls below a critical threshold (e.g., 10% of capacity), switch to always defecting to minimize further depletion.

**Collective Mindset:**

The ACST strategy aligns with the collective mindset by:

1. Encouraging cooperation in early rounds to establish a cooperative atmosphere.
2. Adjusting behavior based on the current stock level, which reflects the collective impact of all players' actions.
3. Incorporating a Tit-for-Tat component that responds to others' cooperation rates, promoting reciprocity and mutual benefit.

By adapting to the game's state and history, ACST aims to balance individual payoffs with collective sustainability while being robust against various opponent behaviors in the tournament.
'''

description_COLLECTIVE_40 = '''
**Collective Strategy: Adaptive Common Pool Resource Management (ACPRM)**

The ACPRM strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. This approach ensures robustness against a wide range of opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if `stock >= capacity / 2`
	* Defect (D) otherwise
2. **Subsequent Rounds (t>1):**
	* Calculate the average stock level over the last two rounds (`avg_stock`)
	* If `avg_stock < capacity / 4`, defect (D)
	* Else, cooperate (C) if at least one opponent cooperated in the previous round (`cooperator_count > 0`)
	* Otherwise, defect (D)

Pseudocode:
```
if t == 1:
    if stock >= capacity / 2:
        action = C
    else:
        action = D
else:
    avg_stock = (stock + prev_stock) / 2
    if avg_stock < capacity / 4:
        action = D
    elif cooperator_count > 0:
        action = C
    else:
        action = D
```
**Edge Cases:**

1. **Last Round (t=r):**
	* Defect (D) to maximize individual payoff, as there is no future sustainability concern.
2. **Low Stock Levels:**
	* If `stock < capacity / 4`, defect (D) to avoid depleting the resource and ensuring some payoff.

**Collective Mindset:**

The ACPRM strategy prioritizes cooperation when:

1. The stock level is high enough to sustain collective consumption.
2. At least one opponent cooperated in the previous round, indicating a willingness to work together.

By adapting to the game's state and history, ACPRM balances individual payoffs with collective sustainability, promoting a stable and efficient resource management system.

**Key Features:**

1. **Adaptability:** Responds to changes in stock levels and opponent behaviors.
2. **Robustness:** Handles a wide range of opponent strategies without relying on coordination mechanisms.
3. **Collective focus:** Prioritizes cooperation when beneficial for the group, ensuring long-term sustainability.

The ACPRM strategy is designed to perform well in a tournament setting against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_41 = '''
I'll outline a collective strategy for this Common Pool Resource Game that adapts to various opponent behaviors while prioritizing sustainability and robustness.

**Strategy Name:** Adaptive Sustainability (AS)

**Core Principles:**

1. **Initial Cooperation**: Cooperate in the first round to establish a baseline of trust and observe others' behavior.
2. **Sustainability Threshold**: Monitor the stock level and adjust actions based on a threshold that balances individual payoff with collective sustainability.
3. **Adaptive Response**: Adjust cooperation/defection rates based on observed opponent behavior, favoring cooperation when opponents cooperate.

**Decision Rules:**

1. First Round (t=1):
	* Cooperate (C)
2. Subsequent Rounds (t>1):
	* Calculate the Sustainability Threshold (ST) as:
		+ ST = capacity / (2 \* n \* (r - t + 1))
	* If stock ≥ ST, cooperate (C)
	* Else, defect (D)
3. Observing Opponent Behavior:
	* Track the number of opponents cooperating (OC) and defecting (OD) in each round
	* Calculate the opponent cooperation rate (OCR):
		+ OCR = OC / n
4. Adaptive Response:
	* If OCR > 0.5, cooperate (C)
	* Else, defect (D)

**Pseudocode:**
```
function AS(n, r, capacity, stock, history) {
  if t == 1 { // First round
    return C;
  }
  
  ST = capacity / (2 * n * (r - t + 1));
  
  if stock >= ST {
    OCR = calculate_OCR(history);
    if OCR > 0.5 {
      return C;
    } else {
      return D;
    }
  } else {
    return D;
  }
}

function calculate_OCR(history) {
  OC = 0; OD = 0;
  for each opponent in history {
    if opponent's action == C {
      OC++;
    } else {
      OD++;
    }
  }
  OCR = OC / n;
  return OCR;
}
```
**Edge Cases:**

* Last Round (t=r): Cooperate (C) to ensure maximum collective payoff
* Low Stock Levels: Defect (D) when stock is critically low to prevent depletion

**Collective Mindset:**
The Adaptive Sustainability strategy prioritizes cooperation when the sustainability threshold is met, while adapting to opponent behavior. By favoring cooperation when others cooperate, AS promotes a culture of mutual support and collective responsibility for resource management.

By implementing this strategy, we can create a robust and adaptive approach that balances individual payoffs with collective sustainability in the face of diverse opponent behaviors.
'''

description_COLLECTIVE_42 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Stock-Based Cooperation**: If the current stock level is above 75% of the capacity, cooperate (C). This ensures that the stock remains sustainable while allowing for moderate consumption.
3. **Defection Response**: If any opponent defected in the previous round, defect (D) in the current round to punish them and maintain a balance of power.
4. **Consecutive Cooperation**: If all opponents cooperated in the previous round, cooperate (C) in the current round to reinforce mutual cooperation.
5. **Stock Depletion Response**: If the stock level falls below 25% of the capacity, defect (D) to maximize individual payoff while minimizing further depletion.

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.
2. **Tie-Breaking**: In cases where multiple rules apply, prioritize the rule that promotes cooperation (e.g., Stock-Based Cooperation over Defection Response).

**Pseudocode:**
```
function AC(current_stock, capacity, previous_actions):
  if current_round == 1:
    return C
  elif current_stock >= 0.75 * capacity:
    return C
  elif any(opponent_defected in previous_actions):
    return D
  elif all(opponents_cooperated in previous_actions):
    return C
  elif current_stock < 0.25 * capacity:
    return D
  else:
    return C
```
**Collective Mindset:**

The Adaptive Cooperation strategy prioritizes cooperation when the stock is sustainable and opponents are cooperative. It adapts to opponents' behaviors by punishing defection and reinforcing mutual cooperation. By balancing individual interests with collective sustainability, AC promotes a stable and efficient use of the common pool resource.

In the tournament against independent strategies, AC's adaptability and robustness will allow it to perform well in various scenarios, from highly cooperative to highly competitive environments.
'''

description_COLLECTIVE_43 = '''
I propose a collective strategy called "Adaptive Stock Sensitive Tit-for-Tat" (ASST). This strategy is designed to balance individual payoff maximization with collective sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and to gather information about opponents' behaviors.
2. **Subsequent Rounds:** Observe the previous round's stock level and opponents' actions. If the stock level is above 75% of capacity, play Tit-for-Tat (TFT): cooperate if most opponents cooperated in the previous round, and defect otherwise. If the stock level is below 75% of capacity, switch to a more conservative approach:
	* **Conservative TFT:** Cooperate if at least half of the opponents cooperated in the previous round, and defect otherwise.
3. **Punishment Mechanism:** If an opponent defects while the stock level is below 50% of capacity, retaliate with a defection in the next round to deter over-exploitation.

**Edge Case Handling:**

1. **Last Round:** In the final round, play C if the stock level is above 75% of capacity; otherwise, play D to maximize individual payoff.
2. **Low Stock Levels:** If the stock level falls below 25% of capacity, switch to a " Crisis Mode" where all players cooperate (C) to ensure minimal growth and avoid depletion.

**Collective Mindset Alignment:**

ASST is designed to promote collective sustainability by:

1. Encouraging cooperation when the stock level is high.
2. Gradually increasing conservatism as the stock level decreases.
3. Implementing a punishment mechanism to deter over-exploitation.
4. Prioritizing cooperation in crisis situations.

**Pseudocode:**
```python
def ASST(stock_level, opponents_actions, round_number):
    if round_number == 1:
        return C  # Cooperate in the first round
    
    if stock_level >= 0.75 * capacity:
        # Tit-for-Tat (TFT)
        most_opponents_cooperated = sum(opponents_actions) / len(opponents_actions) > 0.5
        return C if most_opponents_cooperated else D
    elif stock_level < 0.75 * capacity and stock_level >= 0.5 * capacity:
        # Conservative TFT
        half_or_more_opponents_cooperated = sum(opponents_actions) / len(opponents_actions) >= 0.5
        return C if half_or_more_opponents_cooperated else D
    elif stock_level < 0.5 * capacity:
        # Punishment Mechanism
        for opponent in opponents_actions:
            if opponent == D and stock_level < 0.5 * capacity:
                return D  # Retaliate with a defection
    
    if stock_level < 0.25 * capacity:
        # Crisis Mode
        return C

    return D  # Default to defection if none of the above conditions apply
```
This strategy should perform well in a tournament against independent strategies, as it balances individual payoff maximization with collective sustainability and adapts to various opponent behaviors.
'''

description_COLLECTIVE_44 = '''
To design a collective strategy for this game that is adaptive and robust to various opponent behaviors, I propose the "Adaptive Collective Conservation" (ACC) strategy.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline trust and observe others' actions.
2. **Subsequent Rounds:** Use the following rules:
	* If the current stock is above 75% of capacity, cooperate (C).
	* If the current stock is between 50% and 75% of capacity, use the " Mirror-Majority" rule: cooperate if most players cooperated in the previous round; otherwise, defect.
	* If the current stock is below 50% of capacity, defect (D).

**Mirror-Majority Rule Pseudocode:**

`mirror_majority(stock, history)`

1. `majority_cooperation = True`
2. `for each player in history[previous_round]:`
3. `if player_action != C:`
4. `majority_cooperation = False`
5. `break`
6. `return C if majority_cooperation else D`

**Edge Cases:**

1. **Last Round:** Cooperate (C) in the last round, as there is no future benefit to defecting.
2. **Low Stock Levels:** If the stock level falls below 25% of capacity, cooperate (C) to help recover the stock.

**Collective Mindset:**

The ACC strategy prioritizes collective conservation and adaptability. By cooperating when the stock is high and using the Mirror-Majority rule when it's moderate, players encourage cooperation while adapting to others' actions. When the stock is low, defecting helps to conserve resources for future rounds. This approach balances individual payoffs with collective sustainability.

**Rationale:**

1. Initial cooperation establishes trust and encourages others to cooperate.
2. The Mirror-Majority rule adapts to the majority's behavior, promoting cooperation when possible and defection when necessary.
3. Defecting when stock is low helps conserve resources for future rounds, preventing catastrophic depletion.
4. Cooperating in the last round ensures no unnecessary harm to the collective.

The ACC strategy should perform well in a tournament setting, as it balances individual payoffs with collective conservation while adapting to various opponent behaviors.
'''

description_COLLECTIVE_45 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Sensitive Threshold (ACST)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and gather information about opponents' behaviors.
2. **Subsequent Rounds**: Use a dynamic threshold-based approach to decide between C and D, based on the current stock level and history of opponents' actions.

**Threshold Calculation:**

Let `S` be the current stock level, `H` be the number of players who defected in the previous round, and `n` be the total number of players. Calculate a threshold value `θ` as follows:

`θ = (S / capacity) * (1 - H / n)`

**Cooperation Logic:**

* If `θ > 0.5`, cooperate (C). This indicates that the current stock level is relatively high, and most opponents cooperated in the previous round.
* Otherwise, defect (D).

**Edge Case Handling:**

* **Last Round**: Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.
* **Low Stock Levels**: If `S < 2n`, cooperate (C) to prevent stock depletion and potential collapse of the common pool resource.

**Collective Mindset:**

The ACST strategy is designed to promote collective cooperation by:

1. Encouraging cooperation when the stock level is high and most opponents have cooperated in the past.
2. Adapting to changing opponent behaviors by adjusting the threshold value based on the number of defectors.
3. Preventing stock depletion by cooperating when the stock level is low.

**Pseudocode:**
```python
def ACST(n, capacity, S, H):
    # Initialize variables
    theta = 0

    # Calculate threshold value
    if S > 0:
        theta = (S / capacity) * (1 - H / n)

    # Decide between C and D based on threshold
    if theta > 0.5 or S < 2n:
        return 'C'  # Cooperate
    else:
        return 'D'  # Defect

def play_game(n, capacity, r):
    S = capacity  # Initialize stock level
    for t in range(r):
        H = 0  # Number of defectors in previous round
        actions = []
        for i in range(n):
            action = ACST(n, capacity, S, H)
            actions.append(action)
            if action == 'D':
                H += 1

        # Update stock level based on actions
        total_consumption = sum([S / (2 * n) if action == 'C' else S / n for action in actions])
        S -= total_consumption
        growth = 2 * S * (1 - S / capacity)
        S = min(S + growth, capacity)

    return actions
```
Note that this strategy will be implemented as an algorithm later. The pseudocode provided is a simplified representation of the decision-making process.
'''

description_COLLECTIVE_46 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

**Decision Rules**

1. **Initial Round**: Cooperate (C) with a probability of 0.8 to encourage cooperation and build trust.
2. **Subsequent Rounds**: Assess the current state and history:
	* If the stock level is above 75% of capacity, cooperate (C).
	* If the stock level is between 50% and 75% of capacity, cooperate (C) with a probability proportional to the number of cooperators in the previous round.
	* If the stock level is below 50% of capacity, defect (D) to maximize individual payoff.
3. **Reacting to Defectors**: If a player defects while the stock level is above 75% of capacity, switch to defecting (D) for one round to punish the defector and then reassess.

**Handling Edge Cases**

1. **Last Round**: Cooperate (C) if the stock level is above 25% of capacity; otherwise, defect (D).
2. **Low Stock Levels**: If the stock level falls below 10% of capacity, cooperate (C) to prevent depletion and allow for growth.
3. **High Defection Rates**: If more than half of players defect in a round, switch to cooperating (C) for one round to attempt to restore cooperation.

**Collective Mindset**

The Adaptive Cooperation strategy prioritizes collective well-being while adapting to changing circumstances. By initially cooperating and then adjusting based on the state and history, AC aims to:

1. Encourage cooperation through reciprocity.
2. Punish defectors to maintain a cooperative norm.
3. Balance individual payoffs with collective sustainability.

**Pseudocode**

```
function AdaptiveCooperation(stock_level, capacity, num_players, round_history) {
  // Initial Round
  if (round == 1) {
    return C with probability 0.8;
  }

  // Assess current state and history
  if (stock_level >= 0.75 * capacity) {
    return C;
  } else if (stock_level >= 0.5 * capacity && stock_level < 0.75 * capacity) {
    coop_prob = count_cooperators(round_history[-1]) / num_players;
    return C with probability coop_prob;
  } else {
    return D;
  }

  // React to defectors
  if (stock_level > 0.75 * capacity && any(defector in round_history[-1])) {
    return D for one round, then reassess;
  }
}
```

This strategy will adapt to a wide range of opponent behaviors while promoting collective well-being and sustainability.
'''

description_COLLECTIVE_47 = '''
**Collective Strategy: Adaptive Cooperation with Stock Conservation (ACSC)**

The ACSC strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on stock dynamics and opponent behavior.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Stock-based Cooperation**: If the current stock level is above 75% of capacity, cooperate (C). This ensures that when the stock is abundant, players contribute to its conservation.
3. **Opponent-based Defection**: If at least one opponent defected in the previous round, and the current stock level is below 50% of capacity, defect (D). This rule deters opponents from exploiting cooperative behavior when the stock is scarce.
4. **History-based Adaptation**: Maintain a running average of opponents' cooperation rates over the past `r/2` rounds (where `r` is the total number of rounds). If this average is above 0.5, cooperate (C); otherwise, defect (D).
5. **Endgame Cooperation**: In the last round (`t=r`), cooperate (C) regardless of the stock level or opponents' behaviors. This ensures that all players contribute to the final stock conservation.

**Edge Cases:**

* If multiple rules apply simultaneously, prioritize them in the order listed above.
* When facing a tie between cooperation and defection, default to cooperation (C).

**Pseudocode:**
```python
def ACSC(n, capacity, r, current_stock, opponent_history):
  # Initial Round
  if t == 1:
    return C

  # Stock-based Cooperation
  if current_stock > 0.75 * capacity:
    return C

  # Opponent-based Defection
  if any(opponent_defected in opponent_history[-1]) and current_stock < 0.5 * capacity:
    return D

  # History-based Adaptation
  avg_coop_rate = sum(opponent_cooperated for opponent_cooperated in opponent_history[-r//2:]) / (r // 2)
  if avg_coop_rate > 0.5:
    return C
  else:
    return D

  # Endgame Cooperation
  if t == r:
    return C
```
The ACSC strategy is designed to be adaptive and robust, balancing individual payoffs with collective sustainability while responding to various opponent behaviors. By conserving the stock when it's abundant and adapting cooperation levels based on opponents' actions, ACSC aims to achieve a high total payoff for all players in the tournament.
'''

description_COLLECTIVE_48 = '''
To design a collective strategy for this Common Pool Resource Game, I propose "Adaptive Conservation" (AC), a dynamic and responsive approach that balances cooperation with caution.

**Decision Rules:**

1. **Initial Rounds**: Cooperate (C) in the first round to establish a baseline of trust and observe other players' behaviors.
2. **Observation Phase**: For rounds 2-5, alternate between C and D to gather information on opponents' strategies and adapt to their behavior. Specifically:
	* If most players (>50%) defected in the previous round, defect (D) in this round to avoid exploitation.
	* Otherwise, cooperate (C).
3. **Adaptive Phase**: After the observation phase (rounds 6+), employ a dynamic threshold-based strategy:
	* Calculate the average stock consumption rate over the last 3 rounds: `avg_consumption = (total_consumption_last_3_rounds) / (3 * n)`
	* If `avg_consumption` exceeds 75% of the capacity, defect (D) to prevent stock depletion.
	* Otherwise, cooperate (C).
4. **Stock Threshold**: When the current stock level falls below 25% of the capacity, always defect (D) to maximize individual payoff in a depleted resource environment.
5. **Last Round**: Defect (D) in the final round to ensure maximum individual payoff.

**Handling Edge Cases:**

* If all players cooperated in the previous round and the stock level is above 50% of the capacity, cooperate (C) in this round to maintain a stable and cooperative environment.
* In case of ties or inconsistent opponent behavior, err on the side of caution and defect (D).

**Collective Mindset:**

The Adaptive Conservation strategy prioritizes collective resource sustainability while protecting individual interests. By observing opponents' behaviors, adapting to their strategies, and responding to stock levels, AC promotes cooperation when possible and reverts to self-protection when necessary.

**Pseudocode:**
```python
def adaptive_conservation(n, capacity, current_stock, round_number, history):
    if round_number == 1:
        # Initial round: Cooperate
        return "C"
    
    elif round_number <= 5:
        # Observation phase: Alternate between C and D
        prev_round_behavior = get_prev_round_behavior(history)
        if most_defected(prev_round_behavior):
            return "D"
        else:
            return "C"
    
    else:
        # Adaptive phase: Threshold-based strategy
        avg_consumption = calculate_avg_consumption(history, n)
        if avg_consumption > 0.75 * capacity:
            return "D"
        elif current_stock < 0.25 * capacity:
            # Stock threshold: Defect when stock is low
            return "D"
        else:
            return "C"

    # Last round: Always defect
    if round_number == r:
        return "D"
```
Note that this strategy relies on the availability of historical data and observations, which are assumed to be accessible in the game environment.
'''

description_COLLECTIVE_49 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

**Overview**

The ACST strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and history of play. This approach promotes cooperation when the stock is healthy, while defecting when the stock is depleted to avoid further degradation.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperative behavior and encourage others to do the same.
2. **Stock-Based Threshold**: Calculate a threshold stock level (`threshold_stock`) as a fraction of the capacity, e.g., `threshold_stock = 0.6 * capacity`. If the current stock is above this threshold, cooperate (C); otherwise, defect (D).
3. **History-Dependent Adjustment**: Monitor the average payoff (`avg_payoff`) received over the last few rounds (e.g., 3-5 rounds). If `avg_payoff` is below a certain fraction of the maximum possible payoff (e.g., `0.8 * capacity / n`), adjust the threshold stock level downward by a small amount (e.g., `0.05 * capacity`). This adjustment helps to detect and respond to potential over-exploitation.
4. **Emergency Defection**: If the current stock is critically low (`stock < 0.2 * capacity`) or the growth rate is negative, defect (D) immediately to prevent further depletion.

**Pseudocode**
```python
def ACST(strategy_history, game_state):
    # Initial Round: Cooperate
    if len(strategy_history) == 0:
        return "C"

    # Calculate Threshold Stock Level
    threshold_stock = 0.6 * game_state.capacity

    # Check Current Stock Level
    if game_state.stock > threshold_stock:
        action = "C"
    else:
        action = "D"

    # History-Dependent Adjustment
    avg_payoff = calculate_avg_payoff(strategy_history)
    if avg_payoff < 0.8 * game_state.capacity / n:
        threshold_stock -= 0.05 * game_state.capacity

    # Emergency Defection
    if game_state.stock < 0.2 * game_state.capacity or game_state.growth_rate < 0:
        action = "D"

    return action
```
**Collective Mindset**

The ACST strategy promotes a collective mindset by:

1. Encouraging cooperation when the stock is healthy, to maintain a sustainable resource.
2. Adjusting cooperation levels based on the current stock level and history of play, to respond to changes in the game environment.
3. Defecting when necessary to prevent further depletion, ensuring that individual payoffs do not compromise collective sustainability.

By using this adaptive strategy, we aim to achieve a balance between individual and collective interests, promoting a robust and sustainable outcome for all players involved.
'''

description_COLLECTIVE_50 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's dynamic state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for stock conservation.
2. **Stock Thresholds:**
	* If the current stock is above 75% of capacity, cooperate (C).
	* If the current stock is between 25% and 75% of capacity, play a mixed strategy:
		+ Cooperate (C) with probability p = (current stock / capacity)^2.
		+ Defect (D) with probability 1 - p.
	* If the current stock is below 25% of capacity, defect (D).
3. **History-based Adjustment:**
	* Track the average payoff per player over the last k rounds (k = 5).
	* If the average payoff is below a threshold (50% of the maximum possible payoff), increase cooperation by adjusting p in the mixed strategy to p' = p + δ, where δ is a small positive value (0.05).
	* If the average payoff is above the threshold, decrease cooperation by adjusting p to p' = p - δ.
4. **Last Round:** Defect (D) in the last round to maximize individual payoff.

**Pseudocode:**
```
ASC_Strategy(current_stock, capacity, history):
  if current_round == 1:
    return C
  stock_ratio = current_stock / capacity
  
  if stock_ratio >= 0.75:
    return C
  elif stock_ratio <= 0.25:
    return D
  else:
    p = (stock_ratio)^2
    mixed_strategy = random(p, 1 - p)
    
    if history_average_payoff < threshold:
      p += δ
    else:
      p -= δ
    
    return C if mixed_strategy == 1 else D

  # Last round handling
  if current_round == r:
    return D
```
**Collective Mindset Alignment:**

ASC prioritizes collective sustainability by:

* Cooperating when the stock is high to maintain a healthy common pool.
* Gradually increasing cooperation as the average payoff per player decreases, indicating over-exploitation of the resource.
* Adjusting its strategy based on the game's dynamic state and history to promote long-term sustainability.

**Robustness:**

ASC can adapt to various opponent behaviors by:

* Responding to changes in the stock level and average payoffs.
* Using a mixed strategy when the stock is within a moderate range, allowing for flexibility and unpredictability.
* Prioritizing individual payoff maximization in the last round to minimize potential losses.

**Implementation Notes:**

* Initialize `k` (history window size) and `δ` (adjustment value) as parameters to fine-tune ASC's responsiveness.
* Consider implementing a more sophisticated history-tracking mechanism, such as an exponential moving average, for improved adaptability.
'''

description_COLLECTIVE_51 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5 to encourage cooperation and gather information about opponents' behaviors.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, cooperate (C) with a probability proportional to the average payoff of cooperators in the previous round.
	* If the current stock level is below 50% of capacity, defect (D) to maximize individual payoff.

Pseudocode:
```python
if t == 1:  # Initial Round
    action = random.choice([C, D])  # Cooperate with probability 0.5

elif stock >= 0.75 * capacity:  # Stock level is high
    action = C  # Cooperate

elif 0.5 * capacity <= stock < 0.75 * capacity:  # Stock level is moderate
    avg_coop_payoff_prev_round = calculate_avg_coop_payoff(t-1)
    coop_prob = avg_coop_payoff_prev_round / (avg_coop_payoff_prev_round + avg_defect_payoff_prev_round)
    action = random.choice([C, D], p=[coop_prob, 1-coop_prob])

else:  # Stock level is low
    action = D  # Defect
```
**Handling Edge Cases:**

* **Last Round (t=r):** Cooperate (C) to maximize collective payoff and maintain a positive reputation.
* **Opponents' Behaviors:** AC is designed to adapt to various opponent strategies. If opponents cooperate, AC will also cooperate to maintain a high stock level. If opponents defect, AC will defect to protect its own interests.

**Collective Mindset:**

AC prioritizes cooperation when the stock level is high or moderate, encouraging other players to do the same and maintaining a sustainable resource base. When the stock level is low, AC defects to ensure individual survival, but still allows for adaptation to opponents' behaviors.

By using a probabilistic approach based on the average payoff of cooperators in previous rounds, AC promotes cooperation while allowing for flexibility and adaptability in response to changing opponent strategies.
'''

description_COLLECTIVE_52 = '''
To design a collective strategy for this Common Pool Resource Game that is adaptive and robust to various opponent behaviors, I propose a hybrid approach combining elements of cooperation, defection, and exploration.

**Strategy Name: Adaptive Collective Conservation (ACC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and observe opponents' initial actions.
2. **Stock-Based Cooperation:** If the current stock level is above 75% of the capacity, cooperate (C). This ensures that when the stock is plentiful, we conserve it for future rounds.
3. **Defection Threshold:** If the current stock level falls below 25% of the capacity, defect (D) to maximize short-term payoff. This prevents over-conservation and potential losses due to severe stock depletion.
4. **Opponent Behavior Adaptation:** Monitor opponents' actions in previous rounds. If a player defects (D), increase the probability of defection (D) for that opponent by 10% in subsequent rounds. Conversely, if an opponent cooperates (C), decrease their defection probability by 5%.
5. **Exploration and Learning:** Introduce randomness to explore different actions and learn from opponents' responses:
	* With a 5% probability, randomly choose between cooperation (C) and defection (D).
	* If the random choice results in a higher payoff than the chosen action, adjust the decision rule for that opponent accordingly.

**Handling Edge Cases:**

1. **Last Round:** Cooperate (C) in the final round to maximize long-term payoffs, as there is no subsequent round to consider.
2. **Stock Depletion:** If the stock level falls below 10% of the capacity, defect (D) to maximize short-term payoff and minimize potential losses.

**Collective Mindset:**

The ACC strategy prioritizes cooperation when the stock is plentiful, adapts to opponents' behavior, and incorporates exploration to learn from their responses. By doing so, it balances individual interests with collective conservation goals, aiming to maintain a stable stock level for long-term benefits.

Pseudocode:
```python
def AdaptiveCollectiveConservation(game_state):
    # Initial Round Cooperation
    if game_state.round == 1:
        return "C"

    # Stock-Based Cooperation
    if game_state.stock >= 0.75 * capacity:
        return "C"

    # Defection Threshold
    elif game_state.stock <= 0.25 * capacity:
        return "D"

    # Opponent Behavior Adaptation
    opponent_actions = get_opponent_actions(game_state)
    for opponent in opponent_actions:
        if opponent.action == "D":
            increase_defection_probability(opponent, 10%)
        elif opponent.action == "C":
            decrease_defection_probability(opponent, 5%)

    # Exploration and Learning
    exploration_randomness = random.uniform(0, 1)
    if exploration_randomness < 0.05:
        return random.choice(["C", "D"])

    # Default to Cooperation
    return "C"

def get_opponent_actions(game_state):
    # Return a list of opponent actions from previous rounds

def increase_defection_probability(opponent, probability):
    # Update opponent's defection probability in memory

def decrease_defection_probability(opponent, probability):
    # Update opponent's defection probability in memory
```
This strategy is designed to be adaptive, robust, and aligned with the collective mindset. It balances individual interests with conservation goals, aiming to maintain a stable stock level for long-term benefits.
'''

description_COLLECTIVE_53 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Tit-for-Tat (ACSDT)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a baseline for cooperation and encourage others to do the same.
2. **Subsequent Rounds**: Play a modified Tit-for-Tat strategy, where the decision to cooperate or defect depends on the current stock level and the opponent's previous actions.

Pseudocode:
```python
def ACSDT(stock, history):
    if round == 1:  # Initial Round
        return C
    else:
        # Calculate the average opponent cooperation rate (OCR)
        OCR = sum([1 if action == C else 0 for action in history]) / len(history)

        # Stock-dependent Tit-for-Tat logic
        if stock > capacity * 0.75:  # High stock level
            if OCR >= 0.5:
                return C  # Cooperate if opponents are cooperating
            else:
                return D  # Defect if opponents are not cooperating
        elif stock < capacity * 0.25:  # Low stock level
            return D  # Defect to conserve resources
        else:  # Medium stock level
            if OCR >= 0.5:
                return C  # Cooperate if opponents are cooperating
            else:
                return random.choice([C, D])  # Randomize between cooperate and defect
```
**Edge Cases:**

1. **Last Round**: Play the same strategy as in previous rounds, without considering future payoffs.
2. **Tied History**: In case of a tied history (i.e., equal number of cooperative and defective actions), default to cooperating.

**Collective Mindset Alignment:**

The ACSDT strategy is designed to align with the collective mindset by:

1. Cooperating in the initial round to establish a baseline for cooperation.
2. Responding to opponent cooperation rates, encouraging mutual cooperation.
3. Adjusting behavior based on stock levels to balance individual payoffs and collective sustainability.

This adaptive strategy aims to promote cooperation while being robust to various opponent behaviors and edge cases, ensuring a strong performance in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_54 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Rounds (t = 1, 2): Cooperate (C)**
In the first two rounds, play C to conserve stock and set a cooperative tone.
2. **Stock Conservation Threshold:** Define a threshold, `τ`, as a function of the capacity and number of players:
`τ = capacity / (2 * n)`
If the current stock is below `τ`, switch to Defect (D) to prioritize individual payoffs over conservation.
3. **Adaptive Response:**
 Observe the previous round's actions and outcomes:
	* If most players (> 50%) played D, switch to D in the next round to avoid being exploited.
	* If most players (> 50%) played C, continue playing C to maintain cooperation.
4. **Last Round (t = r): Defect (D)**
In the final round, play D to maximize individual payoff, as there is no future stock to conserve.

**Edge Cases:**

1. **Tie-breaking:** In case of a tie in the number of players playing C or D, follow the majority action from the previous round.
2. **Stock Depletion:** If the stock falls to 0, play D in all subsequent rounds, as there is no longer an incentive to conserve.

**Pseudocode:**
```
 Initialize:
  τ = capacity / (2 * n)
  t = 1

 Loop until end of game (t <= r):
  if t == 1 or t == 2:
    action = C
  else:
    current_stock = get_current_stock()
    if current_stock < τ:
      action = D
    else:
      previous_round_actions = get_previous_round_actions()
      majority_action = determine_majority_action(previous_round_actions)
      if majority_action == D:
        action = D
      elif majority_action == C:
        action = C
      else:  // tie-breaking
        action = get_last_round_majority_action()

  if t == r:
    action = D

  take_action(action)
```
**Collective Mindset:**

The ASC strategy prioritizes cooperation in the early game to conserve stock and promote a collective mindset. As the game progresses, it adapts to the actions of other players, ensuring that individual payoffs are balanced with the need for sustainability. By responding to the majority action in previous rounds, ASC encourages cooperation while protecting against exploitation.

**Robustness:**

ASC is designed to be robust against various opponent behaviors:

1. **All Defectors:** ASC will eventually switch to D, minimizing losses.
2. **All Cooperators:** ASC will maintain C, maximizing collective payoffs.
3. **Mixed Strategies:** ASC adapts to the majority action, ensuring a balance between individual and collective interests.

By implementing the Adaptive Stock Conservation strategy, our AI system is well-equipped to navigate the complexities of the Common Pool Resource Game and achieve a strong performance in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_55 = '''
**Collective Strategy: Adaptive Cooperation with Stock Awareness (ACSA)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a baseline and encourage cooperation from others.
2. **Subsequent Rounds**:
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of the capacity, defect (D) with a probability of 0.5, and cooperate (C) otherwise.
	* If the current stock level is below 50% of the capacity, defect (D) to maximize individual payoff in the short term.
3. **Last Round**: Defect (D), as there are no future rounds to consider.

**Additional Considerations:**

1. **Opponent Behavior Analysis**: Track the number of times each opponent has defected or cooperated in previous rounds. If an opponent has defected more than 75% of the time, assume they will continue to defect and adjust our strategy accordingly.
2. **Stock Trend Analysis**: Monitor the stock level trend over the past few rounds. If the stock is consistently decreasing, increase the probability of defecting (D) in subsequent rounds.

**Pseudocode:**
```markdown
function ACSA(stock_level, capacity, num_rounds, opponent_history):
  if current_round == 1:
    return C
  elif stock_level >= 0.75 * capacity:
    return C
  elif 0.5 * capacity <= stock_level < 0.75 * capacity:
    defect_prob = 0.5 + (opponent_defect_rate - 0.5) / 2
    if random() < defect_prob:
      return D
    else:
      return C
  else:  # stock_level < 0.5 * capacity
    return D

  if current_round == num_rounds:
    return D

  # Additional considerations (optional)
  if opponent_defect_rate > 0.75:
    return D
  elif stock_trend_decreasing():
    increase_defect_prob()
```
**Rationale:**

1. Cooperating in the initial round sets a positive tone and encourages others to cooperate.
2. The adaptive strategy adjusts based on the current stock level, balancing individual payoff with collective sustainability.
3. Analyzing opponent behavior helps identify potential defectors and adjust our strategy accordingly.
4. Stock trend analysis allows us to adapt to changing environmental conditions.

**Collective Mindset:**

ACSA prioritizes cooperation when the stock level is high, ensuring a sustainable collective outcome. As the stock level decreases, individual self-interest takes over, but still considers the opponent's behavior and adjusts accordingly. This balance between cooperation and self-interest promotes a stable collective strategy that adapts to various environmental conditions.
'''

description_COLLECTIVE_56 = '''
I propose a collective strategy called "Adaptive Stock Conservation" (ASC). ASC balances individual self-interest with collective stock conservation, adapting to opponents' behaviors and game state dynamics.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gauge opponents' initial strategies.
2. **Assess Opponent Behavior**: After each round, estimate the proportion of opponents who defected (D) in the previous round. Use this estimate to inform future decisions.
3. **Stock-Based Threshold**: Set a stock-based threshold (SBT) as a function of the current stock level and capacity: SBT = 0.75 \* (stock / capacity). This threshold determines when to switch from cooperation to defection.
4. **Cooperation Zone**: If the estimated proportion of defectors is below 30% and the current stock level is above the SBT, cooperate (C).
5. **Defection Zone**: If the estimated proportion of defectors exceeds 50% or the current stock level falls below the SBT, defect (D).
6. **Adaptive Response**: When an opponent defects while the ASC player cooperates, respond by defecting in the next round if the stock level is above the SBT.
7. **Last Round**: In the final round, defect (D) regardless of previous decisions to maximize individual payoff.

**Pseudocode:**
```python
def adaptive_stock_conservation(stock, capacity, opponents_defected):
    # Initial Round
    if current_round == 1:
        return COOPERATE
    
    # Assess Opponent Behavior
    estimated_proportion_defectors = count(defections) / num_opponents
    
    # Stock-Based Threshold
    SBT = 0.75 * (stock / capacity)
    
    # Cooperation Zone
    if estimated_proportion_defectors < 0.3 and stock > SBT:
        return COOPERATE
    
    # Defection Zone
    elif estimated_proportion_defectors >= 0.5 or stock <= SBT:
        return DEFECT
    
    # Adaptive Response
    elif opponents_defected and stock > SBT:
        return DEFECT
    
    # Last Round
    if current_round == total_rounds:
        return DEFECT
    
    # Default: Cooperate
    return COOPERATE
```
**Rationale:**

1. ASC starts with cooperation to encourage opponents to cooperate, maximizing collective payoffs.
2. By assessing opponent behavior and adapting to the stock level, ASC balances individual self-interest with collective stock conservation.
3. The SBT serves as a dynamic threshold, ensuring that cooperation occurs when the stock is relatively high and defection occurs when it's low or opponents are defecting excessively.
4. The adaptive response mechanism discourages opponents from exploiting cooperative behavior while maintaining flexibility to respond to changing circumstances.

**Collective Mindset:**

ASC prioritizes collective stock conservation by:

1. Encouraging cooperation in early rounds to establish a positive tone.
2. Adapting to opponent behavior and game state dynamics.
3. Balancing individual self-interest with collective payoffs.

By incorporating elements of both cooperative and defecting strategies, ASC fosters a collective mindset that seeks mutual benefit while adapting to diverse opponent behaviors.
'''

description_COLLECTIVE_57 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock Level Thresholds**: Define two stock level thresholds:
	* `high_threshold` = 0.8 * capacity
	* `low_threshold` = 0.2 * capacity

If the current stock level is above `high_threshold`, cooperate (C). If it's below `low_threshold`, defect (D).
3. **Adaptive Cooperation**: Monitor the average payoff per round for all players (`avg_payoff`) and adjust cooperation level accordingly:
	* If `avg_payoff` increases, increase the probability of cooperating (`p_coop`) by 10%.
	* If `avg_payoff` decreases, decrease `p_coop` by 10%.

Use a smoothed average to avoid rapid changes in `p_coop`.
4. **Recent Defection Response**: If a player defects (D) in the previous round, increase the probability of defecting (`p_defect`) by 20% for that player.
5. **History-based Cooperation**: Maintain a history of opponent cooperation rates. Cooperate more frequently with opponents who have cooperated more often in the past.

**Pseudocode:**
```python
def ACH(n, capacity, stock, round_num, history):
    # Initial Round
    if round_num == 1:
        return C

    # Stock Level Thresholds
    high_threshold = 0.8 * capacity
    low_threshold = 0.2 * capacity

    if stock > high_threshold:
        return C
    elif stock < low_threshold:
        return D

    # Adaptive Cooperation
    avg_payoff = calculate_avg_payoff(history)
    p_coop = adjust_p_coop(avg_payoff)

    # Recent Defection Response
    recent_defections = count_recent_defections(history)
    p_defect = adjust_p_defect(recent_defections)

    # History-based Cooperation
    opponent_cooperation_rates = calculate_opponent_cooperation_rates(history)
    cooperation_bias = calculate_cooperation_bias(opponent_cooperation_rates)

    # Make decision based on probabilities and biases
    if random.random() < p_coop + cooperation_bias:
        return C
    else:
        return D

def adjust_p_coop(avg_payoff):
    # Smoothed average to avoid rapid changes
    smoothed_avg_payoff = (avg_payoff + prev_avg_payoff) / 2
    if smoothed_avg_payoff > prev_smoothed_avg_payoff:
        p_coop += 0.1
    else:
        p_coop -= 0.1
    return max(0, min(p_coop, 1))

def adjust_p_defect(recent_defections):
    if recent_defections > 0:
        p_defect += 0.2
    return max(0, min(p_defect, 1))
```
**Collective Mindset:**
The Adaptive Cooperative Harvesting (ACH) strategy prioritizes cooperation while adapting to the dynamic state of the game and the behaviors of other players. By initially cooperating and responding to changes in average payoff, ACH encourages cooperation and deters defection. The strategy also incorporates a history-based component to promote cooperation with reliable opponents.

**Edge Cases:**

* **First Round**: Cooperate (C) to establish a cooperative tone.
* **Last Round**: Defect (D) to maximize personal payoff, as the game is ending.
* **Low Stock Levels**: Defect (D) to avoid over-harvesting and ensure some payoff.

By employing this adaptive strategy, ACH aims to balance individual interests with collective well-being, promoting a sustainable and cooperative approach to managing the common pool resource.
'''

description_COLLECTIVE_58 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective stock conservation, adapting to the game's dynamic state and opponents' behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for the game.
2. **Stock Thresholds**: Define two critical stock levels:
	* `Low_Threshold = capacity / 4` (25% of capacity)
	* `High_Threshold = 3 * capacity / 4` (75% of capacity)

**Cooperation Logic:**

1. If the current stock is above `High_Threshold`, Cooperate (C) to maintain a stable stock level.
2. If the current stock is between `Low_Threshold` and `High_Threshold`, Cooperate (C) with probability `p = (stock - Low_Threshold) / (High_Threshold - Low_Threshold)`; otherwise, Defect (D).
3. If the current stock is below `Low_Threshold`, Defect (D) to maximize individual payoffs in a depleted environment.

**Additional Heuristics:**

1. **Opponent Monitoring**: Track the number of opponents that defected in the previous round (`defectors_last_round`). If this number exceeds half of the total players, increase the probability of defecting by 20% for the next round.
2. **Selfishness Adjustment**: Monitor individual payoffs relative to others. If a player's average payoff is below the group's median payoff over the last three rounds, slightly adjust their cooperation probability downward (by 5-10%) for the next round.

**Pseudocode:**
```python
function ASC(current_stock, capacity, num_players, history):
    low_threshold = capacity / 4
    high_threshold = 3 * capacity / 4
    
    if current_round == 1:
        return COOPERATE
    
    if current_stock > high_threshold:
        return COOPERATE
    
    p_coop = (current_stock - low_threshold) / (high_threshold - low_threshold)
    
    if random.random() < p_coop:
        return COOPERATE
    else:
        return DEFECT

# opponent monitoring and selfishness adjustment heuristics can be added as additional functions or incorporated into the decision-making process.
```
**Collective Mindset Alignment:**

The ASC strategy prioritizes collective stock conservation while balancing individual payoffs. By adapting to opponents' behaviors and adjusting cooperation probabilities based on game state, ASC promotes a stable and sustainable environment for all players.

This strategy is robust against various opponent behaviors, as it:

1. Encourages cooperation when the stock level is high.
2. Adapts to depleted environments by defecting to maximize individual payoffs.
3. Monitors opponents' actions to adjust its own behavior.
4. Self-regulates individual payoffs relative to others.

By implementing ASC in a tournament setting, we can evaluate its performance against diverse strategies and contribute to the development of more effective collective decision-making approaches for dynamic games like the Common Pool Resource Game.
'''

description_COLLECTIVE_59 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to conserve stock and avoid over-exploitation.
2. **Subsequent Rounds**: Observe the previous round's total consumption and adjust accordingly:
	* If total consumption was below 75% of capacity, Cooperate (C).
	* If total consumption was above or equal to 75% of capacity, Defect (D) to exploit remaining stock.
3. **Low Stock Levels**: When current stock falls below 25% of capacity, always Cooperate (C) to allow for stock recovery.
4. **Endgame**: In the last round, Defect (D) if current stock is above 50% of capacity; otherwise, Cooperate (C).

**Edge Cases:**

1. **First Round**: Cooperate (C) as per decision rule 1.
2. **Last Round**: Apply endgame strategy from decision rule 4.
3. **Tiebreaker**: In case of a tie in total consumption, prioritize Cooperation (C).

**Collective Mindset Alignment:**

ASC aims to balance individual payoffs with collective stock conservation. By cooperating when the stock is high and defecting when it's low, ASC promotes sustainable exploitation while adapting to opponents' behaviors.

**Pseudocode:**
```markdown
function ASC(current_stock, capacity, round_number, total_consumption_history) {
  if (round_number == 1) { // Initial Round
    return COOPERATE;
  }

  last_total_consumption = total_consumption_history[round_number - 2];
  if (last_total_consumption < 0.75 * capacity) { // Conserve stock
    return COOPERATE;
  } else { // Exploit remaining stock
    return DEFECT;
  }

  if (current_stock < 0.25 * capacity) { // Low Stock Levels
    return COOPERATE;
  }

  if (round_number == total_rounds) { // Endgame
    if (current_stock > 0.5 * capacity) {
      return DEFECT;
    } else {
      return COOPERATE;
    }
  }
}
```
ASC is designed to be adaptive, robust, and collective-minded, making it a competitive strategy in the tournament against independent AI systems.
'''

description_COLLECTIVE_60 = '''
I propose a collective strategy called "Adaptive Stock Sustainer" (ASS). ASS aims to balance individual payoffs with the long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and gather information about opponents' behaviors.
2. **Subsequent Rounds:** Calculate the average opponent defection rate (ODR) based on the history of their actions. ODR is the proportion of rounds where an opponent defected.

   - If ODR < 0.5, Cooperate (C): This indicates that opponents are mostly cooperative, and sustaining the stock is likely.
   - If ODR ≥ 0.5, Defect (D) with probability p = (ODR - 0.5) / 0.5: As ODR increases, ASS becomes more likely to defect to avoid being exploited.

3. **Stock-Based Adjustment:** Monitor the current stock level and adjust behavior accordingly:
   - If Stock < capacity / 2, Cooperate (C): When the stock is low, prioritize sustainability over individual gain.
   - If Stock ≥ capacity / 2, use the ODR-based decision rule: When the stock is relatively high, focus on adapting to opponents' behaviors.

**Additional Considerations:**

- **Last Round:** In the final round, Defect (D) if the current stock level is sufficient to ensure a positive payoff, regardless of opponents' past behavior. This maximizes individual gain in the last round.
- **Tie-Breaking:** In cases where ODR equals 0.5 or when adjusting for Stock-Based Adjustment, break ties by cooperating (C).
- **Opponent Behavior Analysis:** Continuously update opponent behavior models to refine ASS's decision-making.

**Collective Mindset:**

ASS aims to create a mutually beneficial environment by:

* Encouraging cooperation in early rounds to build trust
* Adapting to opponents' behaviors to prevent exploitation
* Prioritizing stock sustainability when the resource is scarce

By balancing individual payoffs with collective well-being, ASS promotes a stable and prosperous common pool resource ecosystem.

Pseudocode for ASS:
```python
def AdaptiveStockSustainer(game_state):
  # Initial round: Cooperate
  if game_state['round'] == 1:
    return 'C'
  
  # Calculate opponent defection rate (ODR)
  odr = calculate_odr(opponent_history)
  
  # Stock-based adjustment
  if game_state['stock'] < capacity / 2:
    return 'C'
  
  # ODR-based decision rule
  p_defect = (odr - 0.5) / 0.5
  if random.random() < p_defect:
    return 'D'
  else:
    return 'C'

  # Last round: Defect if stock is sufficient
  if game_state['round'] == r and game_state['stock'] >= individual_payoff_threshold:
    return 'D'
```
Note that this pseudocode serves as a starting point for implementation. Further refinements may be necessary to accommodate specific requirements or edge cases not explicitly addressed here.
'''

description_COLLECTIVE_61 = '''
**Collective Strategy: "Adaptive Stock Sensitive Tit-for-Tat with Threshold"**

This strategy balances individual payoff maximization with collective sustainability by adapting to the game's dynamic state and opponent behavior.

**Decision Rules:**

1. **Initial Round (t=1): Cooperate**
Start by cooperating in the first round to establish a baseline for the game's stock dynamics.
2. **Observe Opponent Behavior**: Monitor the number of cooperators (C) and defectors (D) from previous rounds.
3. **Calculate Stock Sensitivity Threshold (SST)**: Based on the current stock level (S) and capacity, calculate SST = 0.5 \* (capacity - S).
4. **Defect if Stock is Low**: If S < SST, defect to maximize individual payoff in a depleted environment.
5. **Tit-for-Tat Adaptation**:
   * If the majority of opponents (> n/2) defected in the previous round, defect.
   * Otherwise, cooperate.

**Edge Cases:**

1. **Last Round (t=r)**: Cooperate to avoid over-depletion and maintain a moderate stock level for future rounds (if any).
2. **Tie in Opponent Behavior**: If the number of cooperators equals the number of defectors, default to cooperation.
3. **Initial Stock Depletion**: If the initial stock is significantly depleted (< 0.5 \* capacity), adjust SST accordingly.

**Pseudocode:**

```
function AdaptiveStockSensitiveTitForTat(capacity, n, r, S):
    # Initialize variables
    t = 1 (round number)
    C_count = 0 (cooperator count)
    D_count = 0 (defector count)
    
    while t <= r:
        if t == 1:
            action = "Cooperate"
        else:
            # Calculate Stock Sensitivity Threshold (SST)
            SST = 0.5 * (capacity - S)
            
            # Defect if stock is low
            if S < SST:
                action = "Defect"
            else:
                # Tit-for-Tat Adaptation
                if D_count > n/2:
                    action = "Defect"
                else:
                    action = "Cooperate"
        
        # Update opponent behavior counts
        C_count, D_count = update_opponent_behavior(C_count, D_count, action)
        
        # Update current stock level (S)
        S = update_stock_level(S, action, n)
        
        # Increment round number
        t += 1
    
    return total_payoff
```

This strategy balances individual payoff maximization with collective sustainability by adapting to the game's dynamic state and opponent behavior. It starts with cooperation, observes opponent behavior, and adjusts its actions based on stock sensitivity and tit-for-tat adaptation. Edge cases are handled by considering the initial round, last round, tie in opponent behavior, and initial stock depletion.
'''

description_COLLECTIVE_62 = '''
**Collective Strategy: Adaptive Cooperation with Stock-based Threshold (ACST)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe others' actions.
2. **Stock-based Threshold**: Calculate the stock threshold `T` as a fraction of the capacity, e.g., `T = 0.7 * capacity`. This threshold will determine when to switch between cooperation and defection.
3. **Cooperation Zone**: If the current stock level `S` is above the threshold `T`, cooperate (C). This zone encourages collective conservation of the resource.
4. **Defection Zone**: If the current stock level `S` is below the threshold `T`, defect (D). This zone allows for individual exploitation when the resource is scarce.
5. **Adaptive Adjustment**: After each round, update the threshold `T` based on the previous round's stock growth:
	* If the stock grew (`S_remaining + growth > S`), increase `T` by a small increment (e.g., `0.05 * capacity`).
	* If the stock declined (`S_remaining + growth < S`), decrease `T` by a small increment (e.g., `0.05 * capacity`).

**Edge Cases:**

1. **Last Round**: In the final round, defect (D) to maximize individual payoff, as there is no future benefit from cooperation.
2. **Stock Depletion**: If the stock level `S` falls below a minimal value (e.g., `0.2 * capacity`), cooperate (C) to avoid depletion and allow for potential regeneration.

**Collective Mindset:**

The ACST strategy aligns with the collective mindset by:

1. Encouraging cooperation when the resource is plentiful, promoting conservation and shared benefits.
2. Allowing for individual exploitation when the resource is scarce, acknowledging that self-interest may dominate in times of scarcity.
3. Adapting to changes in the stock level and growth, demonstrating responsiveness to the dynamic state of the game.

**Pseudocode:**
```
Initialize:
  T = 0.7 * capacity
  S = capacity

For each round t:
  If t == 1 (initial round):
    action = C
  Else:
    If S >= T:
      action = C
    Else:
      action = D
    Update T based on stock growth:
      If S_remaining + growth > S:
        T += 0.05 * capacity
      Else:
        T -= 0.05 * capacity

  If t == r (last round):
    action = D

  If S < 0.2 * capacity:
    action = C

  Return action
```
The ACST strategy balances individual self-interest with collective cooperation, adapting to the dynamic state of the game and promoting a sustainable exploitation of the common resource.
'''

description_COLLECTIVE_63 = '''
To design a collective strategy for this Common Pool Resource Game that is adaptive and robust to various opponent behaviors, we'll employ a combination of reactive elements (to respond to opponents' actions) and proactive measures (to maintain sustainability). This approach ensures alignment with the collective mindset while being prepared for different scenarios.

### Strategy Name: Adaptive Sustainability (AS)

#### Overview

The AS strategy aims to balance immediate gains with long-term sustainability by adapting to both the current state of the stock and the observed behavior of other players. It seeks to maximize payoffs while preserving the resource for future rounds, thereby promoting a collective benefit.

#### Decision Rules

1. **Initial Rounds (t = 1):** Cooperate (C). This sets an initial cooperative tone and allows us to observe how others react without immediately depleting resources.
   
2. **Mid-Game (2 < t ≤ r - 2):**
   - If the stock level is above 75% of capacity, cooperate if more than half of the players cooperated in the previous round; otherwise, defect. This rule promotes cooperation when resources are plentiful and there's a cooperative majority but switches to defection when the environment suggests over-exploitation or lack of collective cooperation.
   - If the stock level is between 50% and 75% of capacity, mirror the majority action from the previous round. In cases where actions are evenly split, cooperate if you defected in the last round; otherwise, defect. This approach aims to maintain a balance when resources start to dwindle.
   - If the stock level falls below 50% of capacity, defect. At this stage, maximizing immediate payoffs becomes a priority due to the risk of future rounds offering significantly reduced rewards.

3. **Final Rounds (t = r - 1 or t = r):**
   - In the second-to-last round, if the stock is above 25% of capacity and you expect at least one other player will cooperate based on their past behavior, cooperate to ensure a sustainable stock for the final round. This move potentially sets up for a better outcome in the last round.
   - In the last round, always defect (D) regardless of the current state or others' actions. Since there's no future game state to preserve, maximizing immediate gain is optimal.

#### Handling Edge Cases

- **First Round (t = 1):** Always cooperate as mentioned earlier to set a cooperative tone and gather initial data on other players' strategies.
  
- **Ties in Majority Decisions:** In cases where the number of cooperators equals the number of defectors, default to cooperating if you previously defected, and defect if you previously cooperated. This introduces a slight bias towards cooperation while ensuring adaptability.

#### Collective Mindset Alignment

AS is designed with the collective mindset in mind by:

- Encouraging initial cooperation to set a positive tone.
- Adapting actions based on observed behaviors to maintain sustainability and encourage others to do the same.
- Balancing immediate gains with long-term sustainability, considering both personal payoffs and the state of the common resource.

#### Pseudocode Summary

```python
def adaptive_sustainability(t, stock, capacity, prev_actions):
    if t == 1:
        return 'C'  # Cooperate in the first round
    
    elif t > 1 and t < r - 1:  # Mid-game strategy
        if stock >= 0.75 * capacity:
            majority_action = most_common(prev_actions)
            if majority_action == 'C':
                return 'C'
            else:
                return 'D'
        
        elif 0.5 * capacity <= stock < 0.75 * capacity:
            action_counts = count_actions(prev_actions)
            if action_counts['C'] > action_counts['D']:
                return 'C'
            elif action_counts['D'] > action_counts['C']:
                return 'D'
            else:  # Tie, adjust based on previous action
                if prev_action == 'C':
                    return 'D'
                else:
                    return 'C'
        
        else:  # stock < 0.5 * capacity
            return 'D'  # Defect to maximize payoff
    
    elif t >= r - 1:  # Final rounds strategy
        if t == r - 1 and stock > 0.25 * capacity:
            # Assume at least one other player will cooperate for the final round
            return 'C'
        else:
            return 'D'  # Always defect in the last round

def most_common(actions):
    counts = count_actions(actions)
    return max(counts, key=counts.get)

def count_actions(actions):
    counts = {'C': 0, 'D': 0}
    for action in actions:
        counts[action] += 1
    return counts
```

This strategy is designed to be robust and adaptable, responding to a wide range of behaviors while prioritizing sustainability. It aims to maximize collective payoffs over the game's duration rather than focusing solely on individual gains at any cost.
'''

description_COLLECTIVE_64 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Trigger (ACST)**

The ACST strategy aims to balance individual payoff maximization with collective sustainability by adaptively adjusting cooperation levels based on the current stock level and past opponent behavior.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Stock-Based Trigger**: In subsequent rounds, cooperate (C) if the current stock level is above a certain threshold (`stock_threshold`) calculated as 75% of the capacity. Defect (D) otherwise.

Pseudocode:
```
if round == 1 or stock >= stock_threshold:
    action = C
else:
    action = D

stock_threshold = 0.75 * capacity
```

3. **Adaptive Adjustment**: Monitor opponents' past behavior and adjust the cooperation threshold based on their average cooperation rate (`avg_opponent_coop`). If opponents are highly cooperative, increase the threshold to maintain a balance between individual payoff and collective sustainability.

Pseudocode:
```
if avg_opponent_coop > 0.5:
    stock_threshold *= (1 + avg_opponent_coop)
else:
    stock_threshold *= (1 - avg_opponent_coop)

avg_opponent_coop = sum(opponent_cooperation_rates) / num_opponents
```

4. **Last Round**: In the final round, defect (D) to maximize individual payoff regardless of opponents' behavior.

**Edge Cases:**

* If multiple opponents cooperate in a single round, ACST will also cooperate in the next round, assuming that cooperation is beneficial for collective sustainability.
* If an opponent consistently defects while others cooperate, ACST may adjust its threshold to balance individual payoffs with collective sustainability.

**Collective Mindset Alignment:**

ACST prioritizes cooperative behavior when the stock level is high and opponents are relatively cooperative. This encourages other players to maintain a sustainable stock level, ultimately benefiting all players in the long run. By adapting to opponents' behaviors and adjusting its cooperation threshold, ACST promotes a collective mindset of cooperation and mutual benefit.

**Robustness:**

ACST's adaptive nature allows it to respond effectively to various opponent strategies, including:

* Pure cooperators or defectors
* Mixed strategies with random cooperation rates
* Dynamic strategies that adjust based on past outcomes

By incorporating both individual payoff maximization and collective sustainability considerations, ACST provides a robust and effective strategy for playing the Common Pool Resource Game.
'''

description_COLLECTIVE_65 = '''
**Collective Strategy: Adaptive Cooperation with Stock Awareness (ACSA)**

The ACSA strategy is designed to balance individual payoffs with collective sustainability, adapting to changing game conditions and opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information on opponents' behaviors.
2. **Stock Thresholds**:
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 25% and 75% of capacity, play a mixed strategy: Cooperate (C) with probability p = (stock/capacity)^2, Defect (D) otherwise.
	* If the current stock level is below 25% of capacity, defect (D).
3. **Opponent Behavior**: Observe opponents' actions in previous rounds and adjust cooperation probability based on their average cooperation rate:
	+ If opponents' average cooperation rate > 0.5, increase own cooperation probability by 10%.
	+ If opponents' average cooperation rate < 0.5, decrease own cooperation probability by 10%.
4. **History-based Adaptation**: After each round, update the strategy based on the previous round's outcome:
	* If all players cooperated and stock increased, increase cooperation probability by 5%.
	* If all players defected or stock decreased significantly (>25%), decrease cooperation probability by 5%.

**Edge Cases:**

1. **Last Round**: Cooperate (C) in the last round to ensure a moderate payoff, regardless of opponents' actions.
2. **Tie-breaking**: In cases where multiple strategies are equally valid, choose Cooperation (C).

**Pseudocode:**
```
function ACSA(stock, capacity, num_rounds, opponent_history):
    # Initial Round
    if current_round == 1:
        return C

    # Stock Thresholds
    stock_ratio = stock / capacity
    if stock_ratio > 0.75:
        return C
    elif stock_ratio >= 0.25 and stock_ratio <= 0.75:
        p = (stock_ratio)^2
        return random.choice([C, D], p=[p, 1-p])
    else:
        return D

    # Opponent Behavior Adaptation
    opponent_coop_rate = calculate_opponent_cooperation_rate(opponent_history)
    if opponent_coop_rate > 0.5:
        cooperation_probability += 0.1
    elif opponent_coop_rate < 0.5:
        cooperation_probability -= 0.1

    # History-based Adaptation
    previous_round_outcome = get_previous_round_outcome()
    if all_players_cooperated and stock_increased:
        cooperation_probability += 0.05
    elif all_players_defected or stock_decreased_significantly:
        cooperation_probability -= 0.05

    return random.choice([C, D], p=[cooperation_probability, 1-cooperation_probability])
```
**Rationale:**

ACSA balances individual payoffs with collective sustainability by:

* Cooperating when the stock is high to maintain a sustainable level
* Adapting cooperation probability based on opponents' behaviors and previous round outcomes
* Defecting when the stock is low or opponents are not cooperating

By adapting to changing game conditions and opponent behaviors, ACSA aims to achieve a moderate payoff while promoting collective sustainability.
'''

description_COLLECTIVE_66 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

The ACH strategy balances individual self-interest with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Cooperation**: In the first round, cooperate (C) unconditionally to establish a positive tone and encourage cooperation.
2. **Stock-dependent Cooperation**: For rounds 2 to r-1:
	* If the current stock is above 75% of capacity, cooperate (C).
	* If the current stock is between 50% and 75% of capacity, play a mixed strategy: cooperate with probability p = (current_stock / capacity)^0.5, defect otherwise.
	* If the current stock is below 50% of capacity, defect (D) to maximize individual payoff in the short term.
3. **Endgame Cooperation**: In the last round (r), cooperate (C) unconditionally to ensure a positive collective outcome.

**Handling Edge Cases:**

1. **First Round**: Cooperate (C) as described above.
2. **Last Round**: Cooperate (C) as described above.
3. **Low Stock**: If the current stock is critically low (< 25% of capacity), defect (D) to maximize individual payoff.

**Collective Mindset:**

ACH prioritizes collective sustainability while adapting to individual self-interest. By cooperating when the stock is high and defecting when it's low, ACH aims to maintain a healthy stock level, ensuring long-term payoffs for all players.

**Pseudocode:**
```
Function AdaptiveCooperativeHarvesting(current_stock, capacity, round_number, total_rounds):
  If round_number == 1:
    return C  // Initial cooperation
  ElseIf current_stock >= 0.75 * capacity:
    return C  // Stock-dependent cooperation
  ElseIf current_stock >= 0.5 * capacity and current_stock < 0.75 * capacity:
    p = (current_stock / capacity)^0.5
    If random(0, 1) < p:
      return C  // Mixed strategy: cooperate with probability p
    Else:
      return D  // Mixed strategy: defect otherwise
  ElseIf current_stock < 0.5 * capacity and round_number != total_rounds:
    return D  // Defect to maximize individual payoff in the short term
  Else:
    return C  // Endgame cooperation or low stock critical defect

return AdaptiveCooperativeHarvesting(current_stock, capacity, round_number, total_rounds)
```
ACH is designed to be robust against a wide range of opponent behaviors while promoting collective sustainability. By adapting to the game's state and history, ACH balances individual self-interest with long-term cooperation.
'''

description_COLLECTIVE_67 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy balances individual payoff maximization with collective sustainability, adapting to the dynamic state and history of the game.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to follow suit.
2. **Stock Conservation:** If the current stock level is below 50% of the capacity, cooperate (C) to reduce consumption and allow the stock to recover.
3. **Majority Cooperation:** If more than half of the players cooperated in the previous round, cooperate (C) to maintain the cooperative momentum.
4. **Defection Response:** If a player defects (D) in the current or previous round, defect (D) in response to punish and deter future defection.
5. **Stock Growth:** If the stock growth is positive and increasing, cooperate (C) to sustain the growth and maximize long-term payoffs.

**Edge Case Handling:**

1. **Last Round:** Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.
2. **Tie-Breaking:** In cases where multiple decision rules apply, prioritize Stock Conservation over Majority Cooperation, and then Defection Response.

**Pseudocode:**
```python
def ASC(n, capacity, stock, history):
  if round == 1:
    return C  # Initial Round

  if stock < 0.5 * capacity:
    return C  # Stock Conservation

  previous_cooperators = sum(1 for action in history[-1] if action == C)
  if previous_cooperators > n / 2:
    return C  # Majority Cooperation

  defectors = [i for i, action in enumerate(history[-1]) if action == D]
  if len(defectors) > 0:
    return D  # Defection Response

  growth = stock_growth(stock)
  if growth > 0 and growth > previous_growth:
    return C  # Stock Growth

  return D  # Default to defection
```
**Collective Mindset:**

The ASC strategy prioritizes collective sustainability while adapting to individual player behaviors. By conserving the stock when necessary, responding to defections, and cooperating when others do, ASC promotes a stable and cooperative environment. This collective approach encourages players to work together to maintain a healthy stock level, ensuring maximum long-term payoffs for all.

By playing ASC in the tournament, we aim to demonstrate the effectiveness of adaptive cooperation in achieving collective success in the Common Pool Resource Game.
'''

description_COLLECTIVE_68 = '''
Here is a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and aligns with the collective mindset:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline of cooperation and encourage others to do the same.
2. **Stock-Based Cooperation**: If the current stock level is above 75% of capacity, cooperate (C). This ensures that the collective conserves resources when they are abundant.
3. **Defection Detection**: Monitor the previous round's total consumption. If it exceeds 50% of capacity, defect (D) in the next round to protect against over-exploitation.
4. **History-Based Cooperation**: Maintain a history of each player's actions for the last three rounds. Cooperate (C) if at least two-thirds of players cooperated in the previous round. This encourages collective cooperation and rewards consistent cooperative behavior.
5. **Adaptive Threshold**: Update the stock-based cooperation threshold every five rounds based on the average stock level over those rounds. If the average stock level is below 50% of capacity, lower the threshold to 50%. Otherwise, raise it to 75%. This adapts the strategy to changing environmental conditions.

**Edge Case Handling:**

1. **Last Round**: Cooperate (C) in the final round to ensure a fair share of resources and maintain collective cooperation.
2. **Low Stock Levels**: If the current stock level is below 25% of capacity, defect (D) to maximize individual payoff in a depleted environment.

**Collective Mindset Alignment:**

1. **Cooperation as Default**: Prioritize cooperation (C) whenever possible, encouraging others to do the same.
2. **Flexibility and Adaptation**: Adjust decision rules based on changing environmental conditions and opponent behaviors, promoting collective resilience.
3. **Long-Term Thinking**: Balance short-term gains with long-term sustainability, considering the impact of actions on future rounds.

**Pseudocode:**
```markdown
# Initialize variables
capacity = game_capacity
stock_level = initial_stock
history = []  # Last three rounds' actions for each player

# Main decision loop
for round in range(num_rounds):
    if round == 0:
        action = COOPERATE
    else:
        total_consumption_prev = calculate_total_consumption(history)
        stock_threshold = update_adaptive_threshold(stock_level, capacity)

        if stock_level > (stock_threshold * capacity):
            action = COOPERATE
        elif total_consumption_prev > (0.5 * capacity):
            action = DEFECT
        else:
            cooperation_rate = calculate_cooperation_rate(history)
            if cooperation_rate >= 2/3:
                action = COOPERATE
            else:
                action = DEFECT

    # Update history and stock level
    history.append(action)
    stock_level = update_stock_level(stock_level, action)

# Last round handling
if round == num_rounds - 1:
    action = COOPERATE

return action
```
This ACC strategy balances individual interests with collective conservation, adapting to changing environmental conditions and opponent behaviors. By prioritizing cooperation and flexibility, it promotes a resilient collective mindset in the face of uncertainty.
'''

description_COLLECTIVE_69 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adaptively responding to the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):**
Cooperate (C) if the initial stock is above 75% of capacity; otherwise, Defect (D). This sets a cooperative tone while ensuring some consumption in low-stock scenarios.
2. **Subsequent Rounds (t>1):**
Use the following adaptive logic:

a. If the current stock is above 50% of capacity:
	* Cooperate (C) if the average payoff per player in the previous round was below the median historical payoff; otherwise, Defect (D).
b. If the current stock is between 25% and 50% of capacity:
	* Cooperate (C) if at least half of the players cooperated in the previous round; otherwise, Defect (D).
c. If the current stock is below 25% of capacity:
	* Defect (D).

**Edge Cases:**

1. **Last Round (t=r):**
Always Defect (D), as there are no future rounds to consider.
2. **Low Stock (stock ≤ 0):**
If the stock reaches zero, always Defect (D) in subsequent rounds, as cooperation will not contribute to stock growth.

**Pseudocode:**
```markdown
Function ASC(n, capacity, stock, history):
  // Initial Round
  if t == 1:
    if stock >= 0.75 * capacity:
      return C
    else:
      return D

  // Subsequent Rounds
  avg_payoff_prev = calculate_average_payoff(history)
  median_historical_payoff = calculate_median_payoff(history)

  if stock > 0.5 * capacity:
    if avg_payoff_prev < median_historical_payoff:
      return C
    else:
      return D

  elif 0.25 * capacity <= stock <= 0.5 * capacity:
    cooperators_prev = count_cooperators(history)
    if cooperators_prev >= n / 2:
      return C
    else:
      return D

  else: // stock < 0.25 * capacity
    return D

  // Last Round
  if t == r:
    return D

  // Low Stock
  if stock <= 0:
    return D
```
**Collective Mindset:**

The ASC strategy prioritizes cooperation when the collective payoff is below historical medians, encouraging players to conserve the stock. As the game progresses and the stock dwindles, the strategy adapts to prioritize individual payoffs while avoiding catastrophic stock depletion.

By considering both current actions and accumulated stock depletion from previous rounds, the ASC strategy promotes a balance between short-term gains and long-term sustainability, aligning with the collective mindset of preserving the common pool resource.
'''

description_COLLECTIVE_70 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and promotes sustainability of the common pool:

**Strategy Name:** Adaptive Sustainability (AS)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and observe opponents' initial actions.
2. **Stock-based Decision**:
	* If the current stock is above 75% of capacity, Cooperate (C).
	* If the current stock is between 25% and 75% of capacity, Defect (D) with probability p = (1 - (current stock / capacity))^2, otherwise Cooperate (C). This rule introduces a gradual shift towards defection as the stock depletes.
	* If the current stock is below 25% of capacity, Defect (D).
3. **Opponent-based Adaptation**:
	* Monitor opponents' actions and calculate their average cooperation rate over the last 3 rounds.
	* If an opponent's cooperation rate is above 75%, increase our own cooperation probability by 10%.
	* If an opponent's cooperation rate is below 25%, decrease our own cooperation probability by 10%.
4. **Self-Regulation**:
	* If our own total payoff over the last 3 rounds is significantly lower than the average of all players, reconsider our strategy and adjust our cooperation probability based on the stock level (Rule 2).

Pseudocode for AS:
```
// Initialize variables
stock_thresholds = [0.25, 0.75] // thresholds for stock-based decision
cooperation_rate = 1 // initial cooperation rate

while game is ongoing {
    // Observe current state and history
    current_stock = get_current_stock()
    opponent_actions = observe_opponent_actions()

    // Apply decision rules
    if (round == 1) { // Initial Round
        action = C
    } else {
        if (current_stock >= capacity * stock_thresholds[1]) {
            action = C
        } else if (current_stock >= capacity * stock_thresholds[0]) {
            probability_defect = (1 - (current_stock / capacity))^2
            action = random(probability_defect) ? D : C
        } else {
            action = D
        }

        // Adapt to opponents' behavior
        for opponent in opponent_actions:
            cooperation_rate_opponent = calculate_cooperation_rate(opponent)
            if cooperation_rate_opponent > 0.75:
                cooperation_rate += 0.1
            elif cooperation_rate_opponent < 0.25:
                cooperation_rate -= 0.1

        // Self-regulation
        total_payoff_last_3_rounds = calculate_total_payoff()
        if total_payoff_last_3_rounds < average_player_payoff():
            reconsider_strategy(current_stock)
    }
}
```
**Edge Cases:**

* In the last round, always Defect (D) to maximize personal payoff.
* If all players have defected in the previous rounds and the stock is severely depleted, cooperate (C) to avoid complete depletion.

This Adaptive Sustainability strategy balances individual payoffs with collective sustainability. By adapting to opponents' behavior and stock levels, AS promotes cooperation while avoiding exploitation by others. In a tournament setting, AS should perform well against a variety of independent strategies.
'''

description_COLLECTIVE_71 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a baseline for cooperation and avoid early stock depletion.
2. **Subsequent Rounds**:
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 25% and 75% of capacity, use the **Tit-for-Tat with Stock Threshold (TFST)** rule:
		+ Cooperate if the previous round's average opponent consumption was below the cooperative threshold (stock/(2n)).
		+ Defect otherwise.
	* If the current stock level is below 25% of capacity, defect (D) to maximize individual payoff in a depleted environment.
3. **Last Round**: Defect (D), as there are no future rounds to consider and cooperation will not affect the final payoff.

**Tit-for-Tat with Stock Threshold (TFST)**:

1. Calculate the previous round's average opponent consumption: `avg_opponent_consumption = (total_consumption - own_consumption) / (n - 1)`
2. Compare `avg_opponent_consumption` to the cooperative threshold `stock/(2n)`:
	* If `avg_opponent_consumption` is below the threshold, cooperate.
	* Otherwise, defect.

**Pseudocode**:
```python
def adaptive_cooperative_harvesting(stock, capacity, n, round_number):
    if round_number == 1:  # Initial Round
        return 'C'
    
    if stock >= 0.75 * capacity:  # Cooperate above 75% of capacity
        return 'C'
    
    if stock <= 0.25 * capacity:  # Defect below 25% of capacity
        return 'D'
    
    # Tit-for-Tat with Stock Threshold (TFST)
    avg_opponent_consumption = calculate_avg_opponent_consumption(stock, n)
    cooperative_threshold = stock / (2 * n)
    
    if avg_opponent_consumption < cooperative_threshold:
        return 'C'
    else:
        return 'D'

def calculate_avg_opponent_consumption(stock, n):
    total_consumption = 0
    for player in range(1, n + 1):
        # Calculate consumption based on previous round's actions
        if player == own_player:
            total_consumption += own_consumption
        else:
            total_consumption += opponent_consumption[player]
    
    return (total_consumption - own_consumption) / (n - 1)
```
**Collective Mindset Alignment:**

The ACH strategy is designed to balance individual self-interest with collective responsibility. By cooperating when the stock level is high, players contribute to maintaining a healthy common pool resource. When the stock level drops, the TFST rule encourages cooperation if others are also behaving cooperatively, while defecting if others are over-harvesting. This adaptive approach promotes a stable and resilient collective outcome.

**Robustness:**

The ACH strategy is robust against various opponent behaviors:

* **Cooperative opponents**: ACH will cooperate, maintaining a healthy stock level.
* **Defective opponents**: ACH's TFST rule will adapt to defect when faced with over-harvesting opponents, minimizing losses.
* **Mixed strategies**: ACH's adaptive nature allows it to adjust to changing opponent behaviors.

**Tournament Readiness:**

The ACH strategy is designed to perform well in a tournament setting, where diverse independent strategies are present. Its adaptability and robustness make it a strong contender against various opponents.
'''

description_COLLECTIVE_72 = '''
To develop a collective strategy for this Common Pool Resource Game, I propose the "Adaptive Cooperation and Punishment" (ACP) strategy. ACP balances cooperation with punishment mechanisms to ensure sustainable resource usage while adapting to various opponent behaviors.

**Decision Rules:**

1. **Initial Rounds**: In the first few rounds (e.g., 2-3), play Cooperate (C). This allows for initial stock growth and gives other players an opportunity to demonstrate their behavior.
2. **Observation Phase**: Monitor the actions of all players and calculate the average cooperation rate (ACR) over the last few rounds (e.g., 5 rounds).
3. **Cooperation Threshold**: If ACR ≥ 0.7, play C. This means that if at least 70% of players have cooperated on average in recent rounds, continue to cooperate.
4. **Punishment Mechanism**: If ACR < 0.7 and the current stock level is above a certain threshold (e.g., 50), play Defect (D) with a probability p = 1 - ACR. This introduces a punishment mechanism when cooperation levels are low, but only if the stock can sustain some exploitation.
5. **Stock Conservation**: If the current stock level falls below a critical threshold (e.g., 25), always play C to ensure minimal resource depletion and allow for potential recovery.

**Edge Cases:**

1. **Last Round**: In the final round, play D if the stock is above the conservation threshold. This allows for maximum personal gain without affecting future rounds.
2. **Early Defection**: If a player defects in an early round (e.g., within the first 5 rounds), ACP will initially cooperate but then adapt by increasing its defection probability based on the observed behavior.

**Collective Mindset:**

ACP prioritizes cooperation while ensuring sustainable resource usage. By monitoring and responding to the average cooperation rate, ACP promotes a collective mindset that balances individual self-interest with group well-being. The punishment mechanism helps maintain cooperation levels by introducing consequences for widespread defection. However, it also allows for strategic adaptation in response to different opponent behaviors.

**Pseudocode:**
```python
def Adaptive_Cooperation_and_Punishment(current_round, rounds_total, 
                                        current_stock, capacity, 
                                        history_of_actions):
    # Initial Rounds: Cooperate
    if current_round < 3:
        return "Cooperate"

    # Calculate Average Cooperation Rate (ACR)
    acr = calculate_acr(history_of_actions)

    # Cooperation Threshold
    if acr >= 0.7:
        return "Cooperate"

    # Punishment Mechanism
    if acr < 0.7 and current_stock > 50:
        p = 1 - acr
        if random.random() < p:
            return "Defect"
        else:
            return "Cooperate"

    # Stock Conservation
    if current_stock < 25:
        return "Cooperate"

    # Last Round: Defect if stock is high enough
    if current_round == rounds_total and current_stock > 50:
        return "Defect"

def calculate_acr(history_of_actions):
    # Calculate average cooperation rate over last few rounds (e.g., 5 rounds)
    recent_coop_rate = sum([1 for action in history_of_actions[-5:] if action == "Cooperate"]) / len(history_of_actions[-5:])
    return recent_coop_rate
```
This ACP strategy is designed to be robust and adaptive, allowing it to perform well against a wide range of opponent behaviors in the tournament.
'''

description_COLLECTIVE_73 = '''
**Collective Strategy: Adaptive Cooperate-to-Threshold (ACT)**

The ACT strategy balances individual gain with collective sustainability by adapting cooperation levels based on the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoffs.
2. **Subsequent Rounds:** Calculate the `Cooperation Threshold` (CT) based on the current stock level, previous rounds' outcomes, and opponent behavior.
3. **Cooperate-to-Threshold Rule:**
	* If the current stock level is above the CT, cooperate (C).
	* If the current stock level is below the CT, defect (D).

**Calculating Cooperation Threshold (CT):**

1. Initialize CT to 0.5 × capacity in the first round.
2. Update CT after each round based on:
	* Stock growth: If the new stock level is above the previous one, increase CT by 0.05 × capacity. Otherwise, decrease CT by 0.05 × capacity.
	* Opponent behavior: Monitor the number of opponents defecting (D) in the previous round. If ≥ 50% defected, decrease CT by 0.1 × capacity.

**Edge Cases:**

1. **Last Round:** Cooperate (C) in the last round to maximize collective payoff and ensure a sustainable stock level for future games.
2. **Stock Depletion:** If the current stock level falls below 10% of the capacity, defect (D) to secure individual payoffs.

**Collective Mindset:**

The ACT strategy prioritizes cooperation when the game's state allows it, while adapting to opponent behavior and ensuring collective sustainability. By calculating a dynamic Cooperation Threshold, the strategy balances individual gain with collective well-being.

Pseudocode for clarity:

```python
def act_strategy(current_stock, capacity, previous_rounds):
    # Initialize CT
    if len(previous_rounds) == 0:
        ct = 0.5 * capacity
    else:
        ct = update_ct(ct, current_stock, previous_rounds)

    # Determine action based on CT and stock level
    if current_stock >= ct:
        return "C"
    else:
        return "D"

def update_ct(ct, new_stock, previous_rounds):
    # Update CT based on stock growth and opponent behavior
    if new_stock > previous_rounds[-1].stock:
        ct += 0.05 * capacity
    else:
        ct -= 0.05 * capacity

    opponents_defected = sum(1 for r in previous_rounds if r.action == "D")
    if opponents_defected >= len(previous_rounds) / 2:
        ct -= 0.1 * capacity

    return max(0, min(ct, capacity))
```

This ACT strategy will adapt to a wide range of opponent behaviors while prioritizing collective sustainability and individual gain.
'''

description_COLLECTIVE_74 = '''
I propose a collective strategy called "Adaptive Stock-Sensitive Tit-for-Tat" (ASST). This strategy aims to balance individual payoffs with collective sustainability by adapting to the game state and opponents' behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to follow suit.
2. **Subsequent Rounds**: Use the following decision rules:
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play Tit-for-Tat: cooperate if most opponents cooperated in the previous round; otherwise, defect (D).
	* If the current stock level is below 50% of capacity, defect (D) to maximize individual payoff, as cooperation is unlikely to sustain the stock.
3. **Last Round**: Defect (D) in the final round, as there's no future game state to consider.

**Edge Cases:**

1. **Tie-breaking**: In case of a tie in Tit-for-Tat, cooperate (C).
2. **All opponents defect**: If all opponents have defected in the previous round, cooperate (C) to attempt to revive cooperation.
3. **Stock depletion**: If the stock level falls below 25% of capacity, defect (D) to ensure some individual payoff.

**Collective Alignment:**

ASST prioritizes cooperation when the stock is abundant and adapts to opponents' behaviors when it's not. This approach aims to:

1. Encourage cooperation by initially cooperating and responding positively to cooperative actions.
2. Adapt to changes in the game state, such as declining stock levels, by adjusting the decision-making process.
3. Balance individual payoffs with collective sustainability by defecting when necessary to prevent over-exploitation.

**Pseudocode:**
```
function ASST(stock_level, opponents_actions, current_round):
  if current_round == 1:
    return C
  elif stock_level >= 0.75 * capacity:
    return C
  elif stock_level >= 0.5 * capacity:
    if most_opponents_cooperated(opponents_actions):
      return C
    else:
      return D
  elif stock_level < 0.5 * capacity:
    return D
  elif current_round == r: # last round
    return D

def most_opponents_cooperated(opponents_actions):
  cooperators = sum(1 for action in opponents_actions if action == C)
  return cooperators > len(opponents_actions) / 2
```
This strategy should perform well against a variety of opponent behaviors while promoting collective sustainability.
'''

description_COLLECTIVE_75 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Aware Tit-for-Tat**

This strategy balances individual payoff maximization with collective sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative tone and encourage others to do the same.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, cooperate (C).
	* If the stock level is between 50% and 75% of capacity, play Tit-for-Tat (TFT): Cooperate if most players cooperated in the previous round; Defect otherwise.
	* If the stock level is below 50% of capacity, defect (D) to maximize individual payoff while minimizing further stock depletion.
3. **Last Round (t=r):** Defect (D), as there are no future rounds to consider.

**Stock-Aware Tit-for-Tat (TFT) Logic:**

1. Monitor the previous round's actions and payoffs of all players.
2. Calculate the proportion of cooperative players in the previous round (`p_coop`).
3. If `p_coop` ≥ 0.5, cooperate (C); otherwise, defect (D).

**Edge Cases:**

* **First Round with Low Stock:** If the initial stock is below 50% of capacity, defect (D) to prioritize individual payoff.
* **Consecutive Defections:** If all players defected in the previous round, and the stock level is critically low (<25% of capacity), cooperate (C) to prevent complete depletion.

**Collective Mindset:**

This strategy promotes cooperation when the common pool resource is relatively healthy, while adapting to more individualistic behavior when the stock is depleted. By incorporating a TFT component, it encourages other players to cooperate and maintains a balance between individual payoffs and collective sustainability.

Pseudocode:
```python
def adaptive_cooperation(stock, capacity, n_players, round_num):
    if round_num == 1:  # Initial Round
        return "C"  # Cooperate

    elif stock >= 0.75 * capacity:  # High Stock Level
        return "C"

    elif stock >= 0.5 * capacity and stock < 0.75 * capacity:  # Moderate Stock Level
        p_coop = calculate_proportion_cooperative_players()
        if p_coop >= 0.5:
            return "C"  # TFT: Cooperate
        else:
            return "D"

    elif stock < 0.5 * capacity and round_num != n_rounds:  # Low Stock Level, not Last Round
        return "D"

    else:  # Last Round or Very Low Stock
        return "D"
```
This strategy should perform well in a tournament setting by adapting to various opponent behaviors while prioritizing collective sustainability.
'''

description_COLLECTIVE_76 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) with a probability of 0.5 to gather information about opponents' behaviors and initial stock dynamics.
2. **Subsequent Rounds**: Use the following adaptive decision rule:
	* If the current stock level is above 75% of the capacity, Cooperate (C).
	* If the current stock level is between 50% and 75% of the capacity, play a mixed strategy with probabilities:
		+ Cooperate (C) with probability p_c = (current_stock / capacity)^2.
		+ Defect (D) with probability 1 - p_c.
	* If the current stock level is below 50% of the capacity, Defect (D).

**Rationale:**

* The initial random cooperation helps to avoid being overly exploited by potential defectors and allows for gathering information about opponents' behaviors.
* When the stock is high, cooperation is favored to maintain a sustainable resource level.
* As the stock decreases, the strategy becomes more cautious, using a mixed approach to balance individual gains with collective conservation. The probability of cooperating (p_c) increases as the stock approaches the capacity, encouraging players to conserve the resource when it's most needed.
* When the stock is critically low, defection is chosen to maximize individual payoffs in the short term.

**Edge Cases:**

* **Last Round**: Cooperate (C) if the current stock level is above 50% of the capacity. Otherwise, Defect (D). This ensures that players do not over-exploit the resource in the final round.
* **Extreme Stock Levels**: If the stock level falls below a certain threshold (e.g., 10%), all players are likely to defect due to desperation. In this case, our strategy will also defect to avoid being left with nothing.

**Collective Mindset:**

The ASC strategy aligns with the collective mindset by:

* Encouraging cooperation when the resource is abundant, promoting sustainable use.
* Gradually adapting to changing stock levels, balancing individual and collective interests.
* Avoiding over-exploitation in the final round, ensuring a fair outcome.

**Implementation Notes:**

To implement this strategy as an algorithm, you can use the following pseudocode:

```python
def adaptive_stock_conservation(stock, capacity, round_number):
    if round_number == 1:
        # Initial Round
        return random.choice([C, D])
    else:
        # Subsequent Rounds
        stock_ratio = stock / capacity
        if stock_ratio > 0.75:
            return C
        elif stock_ratio >= 0.5:
            p_c = (stock_ratio)**2
            return random.choices([C, D], weights=[p_c, 1-p_c])[0]
        else:
            return D

def last_round_adjustment(stock, capacity):
    if stock > 0.5 * capacity:
        return C
    else:
        return D
```

This strategy is designed to be robust and adaptive in a wide range of opponent behaviors, while prioritizing collective resource conservation.
'''

description_COLLECTIVE_77 = '''
I propose a collective strategy called "Adaptive Stock Sustainer" (ASS) that balances individual payoff maximization with long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This sets a cooperative tone and allows for observation of opponents' initial actions.
2. **Subsequent Rounds (t>1):** Observe the previous round's stock level (S_prev) and the average payoff per player in the previous round (π_avg_prev).
3. **Cooperate if:**
	* The current stock level is above a threshold (θ) calculated as 0.75 \* capacity / n.
	* The average payoff per player in the previous round was higher than a certain fraction (γ) of the maximum possible payoff (S_prev / (2n)). γ is set to 0.8, indicating that if players are getting close to the maximum possible payoff, cooperation is likely beneficial.
4. **Defect if:**
	* The current stock level is below θ.
	* The average payoff per player in the previous round was lower than γ \* (S_prev / (2n)).
5. **Additional Condition:** If the number of rounds remaining (r - t) is less than or equal to n, cooperate. This ensures that players prioritize sustainability when the game is nearing its end.

**Edge Cases:**

1. **Last Round (t=r):** Cooperate, as there is no future benefit in depleting the stock.
2. **Stock Depletion:** If the current stock level falls below a minimum threshold (φ) set to 0.25 \* capacity / n, cooperate unconditionally for the remainder of the game.

**Collective Mindset:**

ASS prioritizes cooperation when the stock level is high and players are getting close to the maximum possible payoff. This strategy encourages players to work together to maintain a healthy stock level while allowing for individual optimization. By adapting to changing conditions and being mindful of opponents' actions, ASS promotes a collective approach that balances short-term gains with long-term sustainability.

Pseudocode:
```python
def Adaptive_Stock_Sustainer(n, r, capacity, t, S_prev, π_avg_prev):
  θ = 0.75 * capacity / n
  γ = 0.8
  
  if t == 1: # Initial Round
    return 'C'
  
  elif S_prev > θ and π_avg_prev >= γ * (S_prev / (2n)):
    return 'C'
  
  elif S_prev < θ or π_avg_prev < γ * (S_prev / (2n)):
    return 'D'
  
  elif r - t <= n: # Additional Condition
    return 'C'
  
  else:
    φ = 0.25 * capacity / n
    if S_prev < φ:
      return 'C' # Unconditional Cooperation on Low Stock

  return 'D' # Default Action
```
This strategy will be implemented as an algorithm for the tournament, and its performance will be evaluated against other independent strategies.
'''

description_COLLECTIVE_78 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

ASP aims to balance individual payoffs with collective sustainability by adapting to the dynamic state and history of the game.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative tone and avoid initial stock depletion.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play a mixed strategy:
		+ With probability 0.6, cooperate (C); with probability 0.4, defect (D).
	* If the current stock level is below 50% of capacity, defect (D) to maximize individual payoffs in the short term.
3. **Last Round (t=r):** Defect (D), as there are no future rounds to consider.

**Adaptive Component:**

Monitor the average payoff per player over the last few rounds (e.g., 5 rounds). If this average payoff is below a certain threshold (e.g., 10% of the maximum possible payoff), adjust the strategy for the next round:

* If cooperating, switch to defecting.
* If defecting, maintain the current action.

**Robustness Mechanisms:**

1. **Stock-based forgiveness:** If another player defects while you cooperated in the previous round, and the resulting stock level is still above 75% of capacity, forgive and cooperate again.
2. **History-based defection:** Keep track of opponents' actions over a few rounds (e.g., 3 rounds). If an opponent has defected consistently, defect against them.

**Pseudocode:**
```python
def ASP(current_stock, capacity, round_number, r, history):
    if round_number == 1:
        return 'C'
    
    stock_level = current_stock / capacity
    
    if stock_level >= 0.75:
        return 'C'
    elif stock_level >= 0.5 and stock_level < 0.75:
        prob_coop = 0.6
        if random.random() < prob_coop:
            return 'C'
        else:
            return 'D'
    else:
        return 'D'
    
    # Last round handling
    if round_number == r:
        return 'D'

    # Adaptive component
    avg_payoff = calculate_average_payoff(history)
    if avg_payoff < threshold:
        adapt_strategy(current_stock, capacity)

    # Robustness mechanisms
    if current_stock > 0.75 * capacity and previous_round_defection(history):
        forgive_and_cooperate()
    
    opponent_history = get_opponent_history(history)
    if consistent_defection(opponent_history):
        defect_against_opponent()

def adapt_strategy(current_stock, capacity):
    # Adjust strategy based on average payoff
    pass

def forgive_and_cooperate():
    # Cooperate despite previous round's defection
    return 'C'

def consistent_defection(opponent_history):
    # Check if opponent has defected consistently
    pass

def defect_against_opponent():
    # Defect against an opponent who has defected consistently
    return 'D'
```
This strategy balances cooperation and defection based on the current stock level, adapting to changes in the game state while incorporating robustness mechanisms to handle various opponent behaviors.
'''

description_COLLECTIVE_79 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline for stock conservation.
2. **Subsequent Rounds (t>1):** Assess the current state and history:
	* If the average payoff per player in the previous round is above 75% of the maximum possible payoff (i.e., stock/(2n)), Defect (D). This indicates that the group is not conserving enough, and defecting may help to correct this.
	* Otherwise, Cooperate (C).
3. **Edge Cases:**
	* If the current stock level is below 25% of capacity, always Defect (D) to maximize individual payoff.
	* In the last round (t=r), Defect (D) as there are no future rounds to consider.

**Adaptive Component:**

1. **Stock Trend Analysis:** Track the average change in stock levels over the past three rounds (∆S). If ∆S is negative, increase the cooperation threshold by 10% (i.e., require a higher average payoff per player to defect).
2. **Opponent Behaviour Adaptation:** Monitor the proportion of cooperators (pC) and defectors (pD) in the previous round. If pC > 0.5, decrease the cooperation threshold by 10%. If pD > 0.5, increase the cooperation threshold by 10%.

**Pseudocode:**
```
Function ASC(current_state, history):
  // Initial Round
  if t == 1:
    return C

  // Assess current state and history
  avg_payoff_prev_round = calculate_average_payoff(history)
  if avg_payoff_prev_round > 0.75 * max_possible_payoff:
    return D
  else:
    return C

  // Edge Cases
  if current_stock < 0.25 * capacity:
    return D
  if t == r:  // Last Round
    return D

  // Adaptive Component
  delta_S = calculate_stock_trend(history)
  if delta_S < 0:
    cooperation_threshold += 0.1
  pC, pD = analyze_opponent_behaviour(history)
  if pC > 0.5:
    cooperation_threshold -= 0.1
  elif pD > 0.5:
    cooperation_threshold += 0.1

  return C or D based on updated cooperation threshold
```
**Collective Mindset Alignment:**

The ASC strategy prioritizes stock conservation while adapting to the group's behaviour and the current state. By initially cooperating, it sets a baseline for collective conservation. The adaptive component responds to changes in the group's behaviour and stock trends, ensuring that individual payoffs are balanced with long-term sustainability.

By not relying on specific coordination mechanisms or opponent norms, ASC is robust to various strategies and promotes a collective approach to managing the common pool resource.
'''

description_COLLECTIVE_80 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC aims to balance individual payoffs with collective sustainability by adapting to the game's dynamic state and opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for the stock level and encourage cooperation.
2. **Stock-Dependent Cooperation**: If the current stock level is above 75% of the capacity, cooperate (C). This ensures that when the stock is abundant, players prioritize conservation.
3. **Opponent-Adaptive Defection**: If at least one opponent defected in the previous round, defect (D) with a probability proportional to the number of defectors and the stock level. Specifically:
	* Calculate `defect_prob = num_defectors / n * (1 - current_stock / capacity)`
	* Defect with probability `defect_prob`
4. **Conserve in Low-Stock Situations**: If the current stock level is below 25% of the capacity, cooperate (C) to minimize further depletion.

**Edge Cases:**

* In the last round, defect (D) if the stock level is above 50% of the capacity, as there's no future benefit to conserving.
* If all opponents cooperated in the previous round and the stock level is high (>75%), cooperate (C) to maintain cooperation.

**Collective Mindset:**

ASC aligns with a collective mindset by:

1. **Encouraging Cooperation**: Cooperating when the stock is abundant or when opponents have shown cooperative behavior.
2. **Adapting to Opponent Behavior**: Defecting in response to opponent defection, while also considering the current stock level.
3. **Prioritizing Conservation**: Focusing on stock conservation when levels are low, ensuring long-term sustainability.

Pseudocode:
```python
def ASC(n, capacity, current_stock, previous_actions):
  if first_round():
    return C

  if current_stock > 0.75 * capacity:
    return C

  num_defectors = count_defectors(previous_actions)
  defect_prob = num_defectors / n * (1 - current_stock / capacity)

  if random() < defect_prob:
    return D
  else:
    return C

  if current_stock < 0.25 * capacity:
    return C

  # Last round
  if is_last_round():
    if current_stock > 0.5 * capacity:
      return D
```
This strategy balances individual payoffs with collective sustainability, adapting to the dynamic state and opponent behaviors while prioritizing stock conservation when necessary.
'''

description_COLLECTIVE_81 = '''
**Collective Strategy: Adaptive Tit-for-Two-Tats with Stock-Dependent Cooperation (ATTC)**

The ATTC strategy balances individual payoff maximization with collective sustainability by adapting to the game state and opponents' behavior.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative baseline and encourage others to do the same.
2. **Stock-Dependent Cooperation Threshold:** Calculate a cooperation threshold based on the current stock level:
	* If `stock > 0.75 * capacity`, cooperate (C)
	* If `stock ≤ 0.25 * capacity`, defect (D)
	* Otherwise, use Tit-for-Two-Tats logic (see below)
3. **Tit-for-Two-Tats Logic:** Observe the actions of all opponents in the previous round:
	* If at least two opponents defected (D) in the previous round, defect (D) in this round
	* Otherwise, cooperate (C) if your individual payoff from cooperation is higher than or equal to your individual payoff from defection in the current state; otherwise, defect (D)
4. **Last Round:** In the final round, prioritize individual payoff maximization and always defect (D), as there are no future rounds to consider.

**Edge Cases:**

* If an opponent's action is unknown or unobserved, assume they cooperated (C) in the previous round.
* In the case of a tie in the Tit-for-Two-Tats logic, cooperate (C).

**Pseudocode:**
```python
def ATTC(stock, capacity, n, history):
    if round == 1:
        return C
    
    cooperation_threshold = 0.75 * capacity
    defection_threshold = 0.25 * capacity
    
    if stock > cooperation_threshold:
        return C
    elif stock <= defection_threshold:
        return D
    
    opponents_defected = sum(1 for opponent_action in history[-1] if opponent_action == D)
    
    if opponents_defected >= 2:
        return D
    
    individual_cooperation_payoff = stock / (2 * n)
    individual_defection_payoff = stock / n
    
    if individual_cooperation_payoff >= individual_defection_payoff:
        return C
    else:
        return D

def last_round(stock, capacity, n):
    return D
```
**Collective Mindset:**
The ATTC strategy prioritizes collective sustainability while adapting to the actions of opponents. By cooperating when the stock is high and defecting when it's low, the strategy aims to maintain a healthy stock level for future rounds. The Tit-for-Two-Tats logic ensures that opponents who repeatedly defect are punished, promoting cooperation among players.

This strategy should perform well in a tournament against independent strategies developed by other AI systems, as it balances individual payoff maximization with collective sustainability and adapts to various opponent behaviors.
'''

description_COLLECTIVE_82 = '''
To design a collective strategy for this Common Pool Resource Game, I'll introduce "Sustainable Harvesting" (SH), an adaptive and robust approach that balances individual payoffs with long-term sustainability of the common pool.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to set a positive tone and gather information about other players' behaviors.
2. **Subsequent Rounds:** Assess the current state and history:
	* If the stock level is above 75% of capacity, cooperate (C).
	* If the stock level is between 50% and 75% of capacity, play a mixed strategy: Cooperate with probability p = (stock level / capacity) - 0.5, and defect (D) otherwise.
	* If the stock level is below 50% of capacity, defect (D).
3. **Adaptation Mechanism:** Monitor the average payoff per player over the last few rounds (e.g., 3-5 rounds). If it's below a certain threshold (e.g., 25% of the maximum possible payoff), adjust the cooperation probability p to be more conservative (i.e., increase p).

**Pseudocode:**
```
Function SustainableHarvesting(stock, capacity, round, history):
  if round == 1:
    return C
  else:
    stockLevel = stock / capacity
    if stockLevel > 0.75:
      return C
    elif 0.5 <= stockLevel < 0.75:
      p = stockLevel - 0.5
      return C with probability p, D otherwise
    else:
      return D

Function AdaptationMechanism(avgPayoffLastRounds, threshold):
  if avgPayoffLastRounds < threshold:
    adjust p to be more conservative (e.g., increase by 10%)
```
**Collective Mindset:**

The SH strategy prioritizes cooperation when the stock level is high and adapts to more conservative behavior as the stock depletes. By doing so, it aims to maintain a sustainable balance between individual payoffs and long-term preservation of the common pool.

In a collective setting, SH encourages players to work together to avoid over-exploitation while allowing for some flexibility in response to changing conditions. This approach promotes cooperation without relying on explicit coordination or communication among players.

**Robustness:**

SH is designed to be robust against various opponent behaviors:

* **Cooperative opponents:** SH will adapt and cooperate more frequently, leading to higher collective payoffs.
* **Defecting opponents:** SH will adjust its cooperation probability to avoid over-exploitation and minimize losses.
* **Mixed-strategy opponents:** SH's adaptive mechanism will help it navigate the dynamic environment and optimize its behavior in response.

By implementing Sustainable Harvesting, players can collectively manage the common pool resource while promoting a balance between individual payoffs and long-term sustainability.
'''

description_COLLECTIVE_83 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' behavior.
2. **Subsequent Rounds**:
	* If the current stock level is above a threshold (`stock_threshold`), cooperate (C). This encourages sustainable consumption and avoids over-depletion.
	* If the current stock level is below `stock_threshold`, defect (D) with a probability (`defection_prob`) that increases as the stock level decreases. This adapts to potential free-riding behavior by opponents.

**Stock-Based Threshold Calculation:**

`stock_threshold = capacity / (2 * n + 1)`

This threshold balances individual payoffs with collective sustainability, ensuring that cooperation is rewarded when the stock is relatively high.

**Defection Probability (`defection_prob`) Calculation:**

`defection_prob = (capacity - stock) / capacity`

As the stock level decreases, `defection_prob` increases, reflecting a higher likelihood of defecting to maximize individual payoffs in a potentially depleted environment.

**Additional Edge Case Handling:**

* **Last Round**: Cooperate (C) if the current stock level is above `stock_threshold`, and defect (D) otherwise. This ensures that players do not over-exploit the resource in the final round.
* **Extremely Low Stock Levels**: If the stock level falls below a minimum threshold (`min_stock = capacity / (4 * n)`), cooperate (C) to prevent catastrophic depletion.

**Collective Mindset Alignment:**

ACST prioritizes cooperation when the collective interest is at stake, while allowing for adaptive responses to opponents' behavior. By cooperating when the stock level is high and defecting with increasing probability as it decreases, ACST promotes sustainable consumption and reduces the risk of over-depletion.

Pseudocode (simplified):
```python
def ACST(n, capacity, stock, round_num, total_rounds):
    stock_threshold = capacity / (2 * n + 1)
    min_stock = capacity / (4 * n)

    if round_num == 1:
        return C

    if stock > stock_threshold:
        return C
    elif stock < min_stock:
        return C
    else:
        defect_prob = (capacity - stock) / capacity
        if random.random() < defect_prob:
            return D
        else:
            return C

    # Last round handling
    if round_num == total_rounds:
        if stock > stock_threshold:
            return C
        else:
            return D
```
This strategy will be implemented as an algorithm and evaluated in a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_84 = '''
I propose a collective strategy called "Adaptive Stock-Sensitive Cooperation" (ASSC). This strategy aims to balance individual payoff maximization with cooperation to maintain a healthy common pool stock.

**Decision Rules:**

1. **Initial Round**: In the first round, ASSC cooperates (plays C) unconditionally to establish a baseline for the game and encourage other players to cooperate.
2. **Subsequent Rounds**: For each subsequent round t, calculate the current stock level S_t and the historical average stock level S_avg over all previous rounds.

   If S_t ≥ 0.75 \* capacity AND S_avg ≥ 0.5 \* capacity:
      - Cooperate (play C) with probability P_C = (S_t / capacity)^2
      - Defect (play D) with probability 1 - P_C

   Else, if S_t < 0.25 \* capacity OR S_avg < 0.25 \* capacity:
      - Defect (play D)

   Otherwise:
      - Cooperate (play C) with a fixed probability P_C = 0.5
3. **Last Round**: In the final round r, ASSC cooperates (plays C) unconditionally to avoid depletion of the common pool stock.

**Pseudocode:**

```
function ASSC(n, capacity, history)
  if current_round == 1:
    return COOPERATE

  S_t = current_stock_level
  S_avg = average_stock_level_over_history(history)

  if S_t >= 0.75 * capacity AND S_avg >= 0.5 * capacity:
    P_C = (S_t / capacity)^2
    return random_choice([COOPERATE, DEFECT], [P_C, 1-P_C])

  elif S_t < 0.25 * capacity OR S_avg < 0.25 * capacity:
    return DEFECT

  else:
    return random_choice([COOPERATE, DEFECT], [0.5, 0.5])

  if current_round == r:  // Last round
    return COOPERATE
```

**Rationale:**

ASSC adapts to the game state by adjusting its cooperation probability based on the current stock level and historical average stock level. This approach:

* Encourages cooperation when the common pool is healthy (S_t ≥ 0.75 \* capacity) to maintain a sustainable stock.
* Discourages cooperation when the stock is low (S_t < 0.25 \* capacity or S_avg < 0.25 \* capacity) to avoid depletion.
* Fosters moderate cooperation in intermediate cases, balancing individual payoffs with collective sustainability.

ASSC's decision rules are designed to be robust against various opponent behaviors and do not rely on coordination mechanisms or shared norms. By adapting to the game state and history, ASSC aims to achieve a high total payoff while maintaining a healthy common pool stock.
'''

description_COLLECTIVE_85 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)**

The ACSDT strategy aims to balance individual payoff maximization with collective sustainability by adapting cooperation levels based on the current stock level and game history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and observe others' behavior.
2. **Stock-Dependent Threshold**: Calculate a dynamic threshold, `T`, based on the current stock level (`S`) and capacity (`capacity`):

   `T = (S / capacity) * (n - 1)`

   If the number of cooperators in the previous round is above this threshold, cooperate (C). Otherwise, defect (D).

3. **History-Based Adjustment**: Keep track of the number of rounds with stock growth (`growth_rounds`) and the total number of rounds played (`total_rounds`). Adjust the cooperation level based on these metrics:

   - If `growth_rounds / total_rounds > 0.5`, cooperate (C) in the next round.
   - Otherwise, defect (D).

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.
2. **Low Stock**: If the current stock level (`S`) is below `capacity / 4`, cooperate (C) to help replenish the stock and avoid depletion.

**Pseudocode:**
```markdown
# Initialize variables
n = number of players
capacity = maximum sustainable stock level
growth_rounds = 0
total_rounds = 0

# Main loop
for round in range(1, r + 1):
    # Calculate dynamic threshold
    T = (S / capacity) * (n - 1)
    
    # Check history-based adjustment
    if growth_rounds / total_rounds > 0.5:
        action = C
    elif S < capacity / 4:
        action = C
    elif round == 1:
        action = C  # Initial round cooperation
    else:
        # Count cooperators in previous round
        num_cooperators = count_cooperators(previous_round)
        
        if num_cooperators > T:
            action = C
        else:
            action = D
    
    # Update variables
    total_rounds += 1
    if stock_growth > 0:
        growth_rounds += 1
```
**Collective Mindset:**
The ACSDT strategy prioritizes cooperation when the stock level is high and adapts to more defecting behavior as the stock depletes. By considering both individual payoffs and collective sustainability, this strategy promotes a balanced approach that can lead to better overall outcomes in the tournament against independent strategies.
'''

description_COLLECTIVE_86 = '''
To design a collective strategy for this Common Pool Resource Game, I propose the "Adaptive Stock Sensitive Tit-for-Tat with Exploration" (ASSTFE) strategy.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline of cooperation and encourage others to do the same.
2. **Subsequent Rounds**: Use a tit-for-tat approach, but with an adaptive twist:
	* If the average payoff of all players in the previous round was above a certain threshold (e.g., 75% of the maximum possible payoff), Cooperate (C) in this round.
	* Otherwise, Defect (D).
3. **Stock Sensitive Adjustment**: Monitor the current stock level and adjust the strategy accordingly:
	* If the stock level is below 25% of the capacity, always Defect (D) to maximize individual payoffs.
	* If the stock level is above 75% of the capacity, Cooperate (C) to maintain a sustainable stock level.

**Exploration Mechanism:**

1. **Random Exploration**: With a small probability (e.g., 5%), randomly choose an action (C or D) in each round to introduce some noise and encourage opponents to adapt.
2. **Adaptive Exploration**: If the average payoff of all players in the previous round was below a certain threshold (e.g., 50% of the maximum possible payoff), increase the exploration probability for this round.

**Edge Cases:**

1. **Last Round**: Cooperate (C) in the last round to maximize collective payoffs, as there is no future game state to consider.
2. **Low Stock Levels**: If the stock level falls below 10% of the capacity, always Defect (D) to minimize losses.

**Collective Mindset:**

ASSTFE prioritizes cooperation when possible, while adapting to the current game state and opponents' behaviors. By introducing exploration mechanisms, ASSTFE encourages other players to adapt and promotes a collective mindset focused on maintaining a sustainable stock level.

Pseudocode:
```python
def ASSTFE(stock_level, capacity, previous_payoffs):
    if first_round():
        return Cooperate()
    
    avg_previous_payoff = sum(previous_payoffs) / len(previous_payoffs)
    threshold = 0.75 * max_possible_payoff
    
    if avg_previous_payoff > threshold:
        return Cooperate()
    else:
        return Defect()
    
    if stock_level < 0.25 * capacity:
        return Defect()
    elif stock_level > 0.75 * capacity:
        return Cooperate()
    
    exploration_probability = 0.05
    if avg_previous_payoff < 0.5 * max_possible_payoff:
        exploration_probability *= 2
    
    random_action = random.choice([Cooperate(), Defect()])
    return random_action with probability exploration_probability
```
This strategy balances individual self-interest with collective sustainability, making it robust against a wide range of opponent behaviors in the tournament.
'''

description_COLLECTIVE_87 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's dynamic state and opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if stock >= capacity / 2
	* Defect (D) otherwise
2. **Middle Rounds (1 < t < r):**
	* If the average payoff per player in the previous round is above a certain threshold (θ), cooperate (C)
	* Otherwise, defect (D) with a probability p that decreases as the stock level increases:
		+ p = max(0, 1 - (stock / capacity)^2)
3. **Final Round (t=r):**
	* Cooperate (C) if stock >= capacity / 4
	* Defect (D) otherwise

**Edge Cases:**

* If the stock level is critically low (< capacity / 4), cooperate (C) to avoid depletion.
* If an opponent defects in a previous round, adjust the probability of defecting in the next round based on their behavior:
	+ Increase p by 10% if they defected
	+ Decrease p by 5% if they cooperated

**Collective Mindset:**

The ASC strategy promotes collective sustainability by:

* Cooperating when the stock level is high to maintain a healthy resource base
* Defecting with a probability that decreases as the stock level increases, to avoid over-exploitation
* Adjusting behavior based on opponents' actions to promote reciprocity and cooperation

**Threshold Value (θ):**

The threshold value θ is set to 75% of the maximum possible payoff per player in a round. This allows players to balance individual payoffs with collective sustainability.

**Pseudocode:**
```markdown
def ASC(n, r, capacity, stock_history):
    # Initialize variables
    theta = 0.75 * (capacity / n)
    p_defect = 0

    for t in range(r):
        if t == 0:
            # Initial round
            if stock >= capacity / 2:
                action = 'C'
            else:
                action = 'D'
        elif t < r - 1:
            # Middle rounds
            avg_payoff_prev_round = calculate_avg_payoff(stock_history, n)
            if avg_payoff_prev_round > theta:
                action = 'C'
            else:
                p_defect = max(0, 1 - (stock / capacity)^2)
                action = 'D' if random.random() < p_defect else 'C'

            # Adjust p_defect based on opponents' behavior
            opponent_actions_prev_round = get_opponent_actions(stock_history)
            for opponent in opponent_actions_prev_round:
                if opponent == 'D':
                    p_defect += 0.1
                elif opponent == 'C':
                    p_defect -= 0.05

        else:
            # Final round
            if stock >= capacity / 4:
                action = 'C'
            else:
                action = 'D'

        return action
```
This strategy is designed to be adaptive, robust, and collective, allowing players to balance individual payoffs with the need for sustainability in the face of uncertain opponent behaviors.
'''

description_COLLECTIVE_88 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Subsequent Rounds**: Observe the previous round's outcomes and adapt accordingly:
	* If the stock level increased or remained stable (> 75% of capacity), cooperate (C).
	* If the stock level decreased moderately (50-74% of capacity), play a mixed strategy: Cooperate (C) with probability 0.6, Defect (D) with probability 0.4.
	* If the stock level decreased significantly (< 50% of capacity), defect (D) to maximize individual payoff in the short term.
3. **Endgame**: In the last round, cooperate (C) if the stock level is above 75% of capacity; otherwise, defect (D).

**Handling Edge Cases:**

* If all players defected in the previous round and the stock level is critically low (< 25% of capacity), cooperate (C) to help replenish the stock.
* If a player observes another player consistently cooperating while their own payoffs are relatively high, increase cooperation probability by 0.1 in subsequent rounds.

**Collective Mindset:**

The Adaptive Cooperation strategy prioritizes collective well-being and adaptability over individual short-term gains. By cooperating initially and adjusting to the game's dynamics, AC encourages other players to cooperate, leading to a more stable stock level and higher overall payoffs.

**Pseudocode:**
```python
def adaptive_cooperation(stock_level, capacity, previous_outcomes):
    if first_round:
        return COOPERATE

    # Evaluate previous round's outcomes
    prev_stock = previous_outcomes['stock']
    prev_actions = previous_outcomes['actions']

    if stock_level > 0.75 * capacity:  # stable or increasing stock
        return COOPERATE
    elif stock_level < 0.5 * capacity:  # significantly decreasing stock
        return DEFECT
    else:  # moderately decreasing stock
        cooperate_prob = 0.6
        if prev_stock < stock_level:
            cooperate_prob += 0.1
        return random.choice([COOPERATE, DEFECT], p=[cooperate_prob, 1 - cooperate_prob])

# Last round handling
if current_round == last_round:
    if stock_level > 0.75 * capacity:
        return COOPERATE
    else:
        return DEFECT

def update_previous_outcomes(stock_level, actions):
    # Update previous outcomes for next round's evaluation
    pass
```
This strategy balances individual self-interest with collective sustainability, adapting to the game's dynamics and opponent behaviors while promoting cooperation whenever possible.
'''

description_COLLECTIVE_89 = '''
**Collective Strategy: "Adaptive Stock Preservation" (ASP)**

The ASP strategy aims to balance individual payoffs with collective sustainability, ensuring a stable stock level throughout the game.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and avoid initial stock depletion.
2. **Early Rounds (Rounds 2-5):**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* Otherwise, defect (D) with a probability of 0.5 (i.e., random choice between C and D). This introduces a degree of unpredictability while still considering the stock level.
3. **Middle Rounds (Rounds 6-r/2):**
	* Monitor the average payoffs of all players in the previous round. If the average payoff is below 50% of the maximum possible payoff, cooperate (C).
	* Otherwise, use a tit-for-tat approach: Cooperate if the majority of opponents cooperated in the previous round; defect otherwise.
4. **Late Rounds (Rounds r/2+1-r):**
	* If the current stock level is above 50% of capacity, cooperate (C) to conserve the remaining stock.
	* Otherwise, defect (D) with a probability of 0.75 (i.e., favoring defection to maximize individual payoffs).
5. **Final Round:** Defect (D) to ensure maximum individual payoff.

**Edge Cases:**

1. **Last Two Rounds:** If the current stock level is critically low (<25% capacity), cooperate (C) in both rounds to avoid complete depletion.
2. **Opponent All-Defection:** If an opponent has defected in all previous rounds, mirror their behavior (defect).

**Pseudocode:**
```markdown
function AdaptiveStockPreservation(state, history):
  // Initial round
  if (round == 1):
    return C

  // Early rounds
  elif (round < 6):
    if (stock > 0.75 * capacity):
      return C
    else:
      return random.choice([C, D])

  // Middle rounds
  elif (round <= r/2):
    avg_payoff = calculate_average_payoff(history)
    if (avg_payoff < 0.5 * max_payoff):
      return C
    else:
      opponents_cooperated = count_cooperative_opponents(history)
      return C if opponents_cooperated > n/2 else D

  // Late rounds
  elif (round > r/2):
    if (stock > 0.5 * capacity):
      return C
    else:
      return D with probability 0.75

  // Final round
  elif (round == r):
    return D

  // Edge cases
  if (round >= r-1 and stock < 0.25 * capacity):
    return C
  elif (has_opponent_defected_all_rounds(history)):
    return mirror opponent's behavior
```
**Collective Mindset:**

The ASP strategy balances individual self-interest with collective sustainability, aiming to preserve the common pool resource for all players. By adapting to the game state and history, ASP encourages cooperation while allowing for flexibility in response to changing circumstances.
'''

description_COLLECTIVE_90 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline for cooperation and observe opponents' initial actions.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, cooperate (C) to maintain a healthy stock level.
	* If the stock level is between 25% and 75% of capacity, defect (D) with a probability proportional to the number of opponents who defected in the previous round. This introduces a reactive element to deter exploitation.
	* If the stock level is below 25% of capacity, cooperate (C) to help replenish the stock.
3. **Last Round (t=r):** Defect (D), as there's no future cost to over-exploitation.

**Additional Rules:**

* **Opponent Monitoring:** Track the number of opponents who defected in each round and adjust the probability of defecting accordingly.
* **Stock Recovery:** If the stock level increases significantly (> 10%) after a cooperation-heavy round, increase the likelihood of cooperating in subsequent rounds to reinforce sustainable behavior.

**Pseudocode:**
```python
def ASC(n, capacity, r, history):
    # Initialize variables
    stock = capacity
    opponents_defected = [0] * n

    for t in range(1, r + 1):
        if t == 1:
            action = 'C'  # Cooperate in the first round
        else:
            # Calculate stock level and opponent defection rates
            stock_level = stock / capacity
            opponents_defected_rates = [opponents_defected[i] / (t - 1) for i in range(n)]

            if stock_level > 0.75:
                action = 'C'  # Cooperate when stock is high
            elif stock_level < 0.25:
                action = 'C'  # Cooperate when stock is low
            else:
                # Defect with probability proportional to opponent defection rates
                defect_prob = sum(opponents_defected_rates) / n
                action = 'D' if random.random() < defect_prob else 'C'

        # Update opponents' defection counts and stock level
        for i in range(n):
            if history[t - 1][i] == 'D':
                opponents_defected[i] += 1

        stock -= calculate_consumption(action, n)

        # Stock recovery mechanism
        if t > 1 and stock_level < 0.5 and stock > stock_history[t - 2]:
            cooperation_incentive = True

    return action
```
**Collective Mindset:**
ASC prioritizes collective sustainability by:

1. Cooperating in the initial round to set a positive tone.
2. Adapting to opponents' behavior to prevent exploitation.
3. Balancing individual payoffs with stock conservation.

By doing so, ASC promotes a culture of cooperation and sustainable resource management, increasing the chances of achieving mutually beneficial outcomes in the tournament.
'''

description_COLLECTIVE_91 = '''
Here's a collective strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Stock Conservation (ASC)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline for stock growth and encourage others to cooperate.
2. **Stock Levels:** If the current stock level is above 75% of capacity, Cooperate (C). This allows for moderate consumption while maintaining a healthy stock.
3. **Low Stock Warning:** If the current stock level falls below 25% of capacity, Defect (D) to maximize individual payoff before the stock depletes further.
4. **Recent History:** Observe the previous round's actions and payoffs:
	* If most players (≥ n/2) Cooperated in the previous round, Cooperate (C) in the current round to maintain cooperation momentum.
	* If most players Defected or there was a mix of actions, Defect (D) to protect against potential over-consumption.
5. **Last Round (t=r):** Defect (D) to maximize individual payoff, as there are no future rounds to consider.

**Edge Case Handling:**

* In the event of a tie in recent history analysis (step 4), Cooperate (C) to maintain cooperation momentum.
* If the stock level reaches zero or the game is in its final round, Defect (D) to maximize individual payoff.

**Collective Mindset Alignment:**
ASC prioritizes cooperation when the stock level is healthy, promoting collective sustainability. By adapting to recent history and stock levels, ASC balances individual interests with collective well-being. This strategy encourages others to cooperate while protecting against potential over-consumption.

Pseudocode for ASC:
```markdown
function ASC(stock_level, capacity, n_players, current_round, previous_actions):
    if current_round == 1:  # Initial Round
        return C
    elif stock_level >= 0.75 * capacity:  # Stock Levels
        return C
    elif stock_level < 0.25 * capacity:  # Low Stock Warning
        return D
    else:
        recent_history = analyze_previous_actions(previous_actions)
        if most_players_cooperated(recent_history):
            return C
        else:
            return D

def analyze_previous_actions(previous_actions):
    cooperation_count = sum(1 for action in previous_actions if action == C)
    return cooperation_count >= n_players / 2

def most_players_cooperated(recent_history):
    return recent_history
```
ASC is designed to be robust and adaptive, responding to various opponent behaviors while prioritizing collective sustainability.
'''

description_COLLECTIVE_92 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponent behaviors.
2. **Stock Assessment**: Evaluate the current stock level (S) relative to the capacity:
	* If S ≥ 0.8 × capacity, cooperate (C).
	* If 0.5 × capacity ≤ S < 0.8 × capacity, defect (D) with a probability proportional to the number of players who defected in the previous round.
	* If S < 0.5 × capacity, defect (D) to maximize individual payoff.
3. **Opponent Behavior Analysis**: Monitor opponent actions and payoffs from previous rounds:
	* If more than half of opponents cooperated in the previous round, cooperate (C).
	* If fewer than half of opponents cooperated, but the average payoff for cooperators is higher than defectors, cooperate (C).
	* Otherwise, defect (D) to maximize individual payoff.
4. **Punishment Mechanism**: Implement a gentle punishment mechanism:
	* If an opponent has consistently defected in the last two rounds, and their payoff is higher than the average cooperator's payoff, defect (D) for one round.

**Edge Cases**

1. **Last Round**: Defect (D) to maximize individual payoff.
2. **Tiebreaker**: In case of a tie in opponent behavior analysis or stock assessment, cooperate (C).

**Collective Mindset Alignment**

The ACH strategy prioritizes cooperation when the common pool is abundant and opponents demonstrate cooperative behavior. By adapting to changing circumstances and punishing exploitative behavior, ACH aims to maintain a balance between individual and collective interests.

Pseudocode:
```markdown
function AdaptiveCooperativeHarvesting(n, capacity, stock, history)
  if round == 1:
    return COOPERATE

  S = current_stock_level()
  opponent_behaviors = analyze_opponent_actions(history)

  if S >= 0.8 * capacity:
    return COOPERATE
  elif 0.5 * capacity <= S < 0.8 * capacity:
    defect_probability = calculate_defect_probability(opponent_behaviors)
    return random_choice([COOPERATE, DEFECT], [1 - defect_probability, defect_probability])
  else:
    return DEFECT

  if opponent_behaviors.show_more_than_half_cooperated():
    return COOPERATE
  elif opponent_behaviors.average_cooperator_payoff() > opponent_behaviors.average_defector_payoff():
    return COOPERATE
  else:
    return DEFECT

  # Punishment mechanism
  for opponent in opponents:
    if opponent.has_consistently_defected_last_two_rounds():
      and their payoff is higher than average cooperator's payoff:
        return DEFECT (for one round)
```
Note that this strategy will be refined and optimized through iterative testing and analysis.
'''

description_COLLECTIVE_93 = '''
**Collective Strategy: Adaptive Cooperative Sustainability (ACS)**

**Overview**
ACS is a collective strategy that balances individual payoffs with long-term sustainability of the common pool resource. It adapts to changing game conditions and opponent behaviors while promoting cooperation.

**Decision Rules**

1. **First Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' strategies.
2. **Subsequent Rounds**: Defect (D) if the current stock level is below 50% of capacity or if more than half of the opponents defected in the previous round. Otherwise, Cooperate (C).
3. **Stock Level Thresholds**:
	* If the current stock level is above 75% of capacity, cooperate (C) to maintain a sustainable level.
	* If the current stock level is between 50% and 75% of capacity, defect (D) with a probability proportional to the number of opponents who defected in the previous round.
4. **Opponent Behavior**: Monitor opponent actions and adjust strategy accordingly:
	+ If an opponent consistently cooperates, cooperate (C) in subsequent rounds.
	+ If an opponent consistently defects, defect (D) in subsequent rounds.
5. **Last Round**: Cooperate (C) in the last round to maximize collective payoff.

**Pseudocode**
```
function ACS(n, capacity, stock, history):
  if first_round:
    return C
  elif stock < 0.5 * capacity or opponents_defected > n/2:
    return D
  elif stock > 0.75 * capacity:
    return C
  else:
    p_defect = (opponents_defected / n) * (1 - (stock / capacity))
    if random() < p_defect:
      return D
    else:
      return C

function opponents_defected(history):
  # count number of opponents who defected in previous round
```
**Collective Mindset**
ACS prioritizes cooperation when the stock level is sustainable and opponents are cooperative. It adapts to changing conditions by defecting when necessary to maintain a balance between individual payoffs and collective sustainability.

By following these decision rules, ACS promotes cooperation while being robust to various opponent behaviors, ensuring a stable and sustainable common pool resource over multiple rounds.
'''

description_COLLECTIVE_94 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) with a probability of 0.5 to gather information about opponents' behaviors.
2. **Subsequent Rounds:** Use the following adaptive logic:
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, Defect (D) with a probability of 0.3, otherwise Cooperate (C).
	* If the current stock level is below 50% of capacity, Defect (D) with a probability of 0.7, otherwise Cooperate (C).
3. **Opponent Behavior Analysis:** Track opponents' actions and adjust strategy based on their behavior:
	* If an opponent has defected more than 2 times in the last 3 rounds, increase the defect probability by 0.1.
	* If an opponent has cooperated more than 2 times in the last 3 rounds, decrease the defect probability by 0.1.

**Edge Cases:**

1. **Last Round:** Cooperate (C) to maximize overall payoff and maintain a positive reputation.
2. **Low Stock Levels:** If the stock level falls below 25% of capacity, Defect (D) with a high probability (0.9) to ensure some gain before the game ends.

**Collective Mindset:**

The Adaptive Stock Conservation strategy prioritizes cooperation when the stock level is healthy, but adaptively adjusts to defecting behavior as the stock level declines or opponents exhibit exploitative behavior. This approach balances individual payoff maximization with collective conservation of the common pool resource.

Pseudocode:
```
function ASC(n, capacity, r, current_stock, opponent_history):
  if (current_round == 1):
    return Cooperate(C) with probability 0.5
  else:
    if (current_stock > 0.75 * capacity):
      return Cooperate(C)
    elif (0.5 <= current_stock / capacity < 0.75):
      defect_prob = 0.3 + opponent_defect_count(opponent_history)
      return Defect(D) with probability defect_prob, otherwise Cooperate(C)
    else:
      defect_prob = 0.7 + opponent_defect_count(opponent_history)
      return Defect(D) with probability defect_prob, otherwise Cooperate(C)

function opponent_defect_count(opponent_history):
  count = 0
  for last 3 rounds:
    if (opponent_action == D):
      count += 1
  return count / 3

function adjust_strategy(current_stock, opponent_history):
  if (current_stock < 0.25 * capacity):
    return Defect(D) with probability 0.9
  elif (last_round()):
    return Cooperate(C)
```
This strategy is designed to be robust and adaptive, allowing it to perform well against a wide range of opponent behaviors in the tournament.
'''

description_COLLECTIVE_95 = '''
**Collective Strategy: Adaptive Common Pool Management (ACPM)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to signal willingness to manage the common pool sustainably.
2. **Subsequent Rounds**:
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, use a mixed strategy: cooperate with probability p = (current stock / capacity) and defect with probability (1 - p).
	* If the current stock level is below 50% of capacity, defect (D) to maximize individual payoff.
3. **Opponent Behavior Adaptation**:
	* Track the number of cooperators and defectors in the previous round.
	* If the majority (> n/2) of opponents cooperated, increase the cooperation probability p by 0.1 for the next round.
	* If the majority (> n/2) of opponents defected, decrease the cooperation probability p by 0.1 for the next round.

**Edge Cases:**

1. **Last Round**: Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Stock Level at or below 0**: Cooperate (C), as defecting would not yield any payoff.

**Pseudocode**:
```
function ACPM(stock, capacity, n, round):
  if round == 1:  // Initial Round
    return C
  else:
    stock_ratio = stock / capacity
    if stock_ratio >= 0.75:
      return C
    elif stock_ratio < 0.5:
      return D
    else:
      p = stock_ratio
      opponent_cooperators = count(C) in previous round
      opponent_defectors = n - opponent_cooperators
      if opponent_cooperators > n/2:
        p += 0.1
      elif opponent_defectors > n/2:
        p -= 0.1
      return C with probability p, D otherwise

function count(action) in previous round:
  // track and return the number of players who chose action in the previous round
```
**Collective Mindset:**

The ACPM strategy aims to balance individual payoffs with collective sustainability by adapting to the current stock level, opponent behavior, and game history. By cooperating when the stock is high and defecting when it's low, we promote a stable common pool resource management system. The mixed strategy component allows for flexibility in response to different opponent behaviors, while the adaptation mechanism encourages cooperation when others cooperate.
'''

description_COLLECTIVE_96 = '''
I'll propose a collective strategy that adapts to various opponent behaviors and promotes cooperation while ensuring robustness against exploitation.

**Strategy Name:** Adaptive Cooperation with Punishment (ACP)

**Decision Rules:**

1. **First Round:** Cooperate (C) unconditionally to initiate cooperation and gather information about opponents' behavior.
2. **Subsequent Rounds:** Use a weighted average of the following factors to decide between Cooperate (C) and Defect (D):
	* **Opponent Behavior:** Track the proportion of opponents who defected in the previous round (p_defect). If p_defect is above a certain threshold (e.g., 0.3), defect; otherwise, cooperate.
	* **Stock Level:** Monitor the current stock level (S). If S is below a certain threshold (e.g., capacity/2), defect to maximize short-term gains; otherwise, cooperate.
	* **Recent Payoff History:** Analyze the payoffs from the last few rounds. If the average payoff has decreased significantly (e.g., by 20%), defect; otherwise, cooperate.
3. **Punishment Mechanism:** Implement a punishment mechanism to deter opponents from exploiting cooperation. When an opponent defects and the stock level is above the threshold, respond with Defect in the next round.
4. **Forgiveness:** After punishing an opponent, gradually return to cooperating if they start cooperating again.

**Edge Cases:**

1. **Last Round:** Cooperate unconditionally, as there's no incentive to defect in the final round.
2. **Initial Stock Depletion:** If the initial stock level is significantly depleted (e.g., below capacity/4), defect in the first few rounds to maximize short-term gains.

**Pseudocode:**
```python
def ACP(n, r, capacity):
  # Initialize variables
  p_defect = 0.0  # proportion of opponents who defected
  recent_payoffs = []  # list to store recent payoffs

  for round in range(1, r+1):
    if round == 1:
      action = C  # Cooperate in the first round
    else:
      S = current_stock_level()  # get current stock level
      p_defect = opponents_who_defected_last_round() / n
      avg_payoff = calculate_recent_average_payoff(recent_payoffs)

      if p_defect > 0.3 or S < capacity/2 or avg_payoff_decreased_significantly(avg_payoff):
        action = D  # Defect based on opponent behavior, stock level, or payoff history
      else:
        action = C  # Cooperate otherwise

    # Punishment mechanism
    if opponent_defected_last_round() and S > capacity/2:
      action = D  # Respond with Defect in the next round

    # Forgiveness
    if opponent_cooperated_again():
      gradually_return_to_cooperation()

    recent_payoffs.append(calculate_payoff(action))  # update payoff history

    take_action(action)
```
**Collective Mindset:**

The ACP strategy prioritizes cooperation and adapts to the behavior of opponents. By incorporating a punishment mechanism, it deters exploitation while allowing for forgiveness when opponents cooperate again. This strategy promotes collective cooperation and robustness against various opponent behaviors.

In the tournament setting, this strategy will adapt to different independent strategies developed by other AI systems, aiming to achieve the best possible outcomes in the Common Pool Resource Game.
'''

description_COLLECTIVE_97 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Sensitive Tit-for-Tat**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative tone and maximize initial payoff.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, cooperate (C).
	* If the stock level is between 50% and 75% of capacity, play Tit-for-Tat (TFT) based on the opponent's previous round action:
		+ Cooperate if opponent cooperated in the previous round.
		+ Defect if opponent defected in the previous round.
	* If the stock level is below 50% of capacity, defect (D) to maximize individual payoff while minimizing further depletion.

**Edge Case Handling:**

1. **Last Round (t=r):** Cooperate (C) regardless of stock level or opponent's previous action, as there is no future game state to influence.
2. **Opponent Defection:** If an opponent defects in a round where the strategy would have cooperated based on the stock level, adjust the next round's decision by defecting with a probability proportional to the number of opponents who defected.

**Pseudocode:**
```python
def adaptive_cooperation(stock, capacity, num_opponents, previous_round_actions):
  # Initialize variables
  cooperation_threshold_high = 0.75 * capacity
  cooperation_threshold_low = 0.5 * capacity

  # Determine decision based on stock level and opponent actions
  if current_round == 1:  # Initial round
    return COOPERATE
  elif stock >= cooperation_threshold_high:
    return COOPERATE
  elif cooperation_threshold_low <= stock < cooperation_threshold_high:
    # Tit-for-Tat logic
    previous_opponent_action = get_previous_opponent_action(previous_round_actions)
    if previous_opponent_action == COOPERATE:
      return COOPERATE
    else:
      return DEFECT
  else:  # Stock level below 50% of capacity
    return DEFECT

# Additional adjustment for opponent defection in last round
if current_round == num_rounds and opponent_defected_last_round():
  probability_of_defection = (num_opponents_who_defected / num_opponents)
  if random.random() < probability_of_defection:
    return DEFECT
```
**Rationale:**

1. The initial cooperation establishes a cooperative tone, maximizing the first-round payoff.
2. The stock-sensitive Tit-for-Tat approach allows for adaptability to opponent behavior while considering the collective impact on the common pool resource.
3. Defecting when the stock level is low minimizes further depletion and individual losses.

**Collective Mindset:**

This strategy prioritizes cooperation when the common pool resource is abundant, balancing individual interests with collective sustainability. By adapting to opponent behavior, it encourages reciprocity while protecting against exploitation. In cases of severe stock depletion, the strategy shifts focus towards minimizing individual losses, acknowledging the trade-off between short-term gains and long-term collective benefits.

This approach should demonstrate robustness in a tournament setting by:

1. Encouraging cooperation when beneficial for both individuals and the collective.
2. Adapting to various opponent behaviors through Tit-for-Tat logic.
3. Prioritizing individual payoff minimization when stock levels are critically low.

Let me know if you need further clarification or if there's anything else I can help with!
'''

description_COLLECTIVE_98 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy balances individual payoff maximization with collective stock conservation, adapting to changing game conditions and opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for opponents' behavior and set the tone for cooperation.
2. **Stock Thresholds:** Define two stock thresholds:
	* `high_stock`: capacity * 0.75
	* `low_stock`: capacity * 0.25

If current stock is above `high_stock`, cooperate (C). If below `low_stock`, defect (D).
3. **Opponent Monitoring:** Track the number of opponents that defected in the previous round (`opponents_defected_prev`).
4. **Adaptive Defection:** If `opponents_defected_prev` > 0, and current stock is above `low_stock`, defect (D) with a probability proportional to the number of opponents that defected:
	* `defect_prob` = min(1, `opponents_defected_prev` / n)

Cooperate (C) otherwise.
5. **Stock Growth Consideration:** If the previous round's stock growth was positive (`stock_growth_prev` > 0), cooperate (C) with a higher probability to maintain the growth momentum.

**Pseudocode:**
```
function ASC(n, capacity, current_stock, opponents_defected_prev, stock_growth_prev):
    high_stock = capacity * 0.75
    low_stock = capacity * 0.25

    if round == 1:
        return C

    if current_stock > high_stock:
        return C

    if current_stock < low_stock:
        return D

    opponents_defected_prev_ratio = opponents_defected_prev / n
    defect_prob = min(1, opponents_defected_prev_ratio)

    if stock_growth_prev > 0 and random() < (1 - defect_prob) * 0.5:
        return C

    return D with probability defect_prob, C otherwise
```
**Handling Edge Cases:**

* Last Round: Cooperate (C) to maximize collective payoff, as there are no future rounds to consider.
* Tiebreaker: In case of a tie in the number of opponents defected, prioritize cooperation (C).

**Collective Mindset Alignment:**

The ASC strategy prioritizes cooperation when the stock is high or growing, and adapts to opponents' behavior by defecting with a probability proportional to the number of defectors. This approach promotes collective stock conservation while allowing for individual payoff maximization.

By considering both individual and collective interests, the ASC strategy aims to achieve a balance between cooperation and competition, making it robust against a wide range of opponent behaviors in the tournament.
'''

description_COLLECTIVE_99 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

The ASC strategy aims to balance individual payoffs with collective stock conservation, ensuring a sustainable common pool resource for all players.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Stock-based Cooperation**: Cooperate if the current stock level is above 50% of the capacity (stock ≥ 0.5 \* capacity). This rule promotes conservation when the stock is relatively healthy.
3. **Payoff-based Defection**: Defect if your previous round's payoff was below the average payoff of all players in that round (π_i < avg(π)). This rule detects potential exploitation and adapts to optimize individual payoffs.
4. **Defection with Stock Depletion**: Defect if the stock level has decreased by more than 20% compared to the initial capacity over the last two rounds ((stock_t - stock_(t-2)) / capacity < -0.2). This rule responds to rapid stock depletion, indicating potential over-exploitation.
5. **Cooperation with Low Stock**: Cooperate if the current stock level is below 30% of the capacity (stock < 0.3 \* capacity). This rule prioritizes conservation when the stock is critically low.

**Additional Considerations:**

1. **Last Round**: Defect in the last round to maximize individual payoffs, as there are no future rounds to conserve for.
2. **Consecutive Cooperation**: If you have cooperated for three consecutive rounds and the stock level has not increased significantly (stock_t < 1.1 \* stock_(t-3)), defect in the next round to reassess the situation.
3. **Opponent Adaptation**: Monitor opponents' actions and adjust your strategy if you detect a consistent pattern of cooperation or defection.

**Pseudocode:**
```markdown
# Initialize variables
stock = capacity
payoff_history = []
action_history = []

# Loop through rounds
for t in range(r):
  # Get current stock level and previous payoffs
  current_stock = stock
  previous_payoffs = payoff_history[-1] if t > 0 else [0]*n

  # Determine action based on decision rules
  if t == 0:  # Initial round
    action = C
  elif current_stock >= 0.5 * capacity:
    action = C
  elif previous_payoffs[i] < avg(previous_payoffs):
    action = D
  elif (current_stock - stock_history[-2]) / capacity < -0.2:
    action = D
  elif current_stock < 0.3 * capacity:
    action = C

  # Update payoff history and action history
  payoffs = calculate_payoffs(current_stock, actions)
  payoff_history.append(payoffs)
  action_history.append(actions)

  # Update stock level
  stock = update_stock(current_stock, actions)

# Final payoff calculation
total_payoff = sum(payoff_history)
```
The Adaptive Stock Conservation strategy balances individual payoffs with collective stock conservation by adapting to the current state of the game and the behavior of other players. By cooperating when the stock is healthy and defecting when necessary, ASC promotes a sustainable common pool resource while optimizing individual payoffs.
'''

description_COLLECTIVE_100 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to encourage cooperation and avoid initial stock depletion.
2. **Stock-Based Cooperation**: If the current stock level is above 75% of capacity, cooperate (C). This helps maintain a sustainable stock level and allows for moderate consumption.
3. **Adaptive Defection**: If the current stock level is between 50% and 75% of capacity, defect (D) with a probability proportional to the number of players who defected in the previous round. This adapts to opponents' behavior and helps maintain a balance between cooperation and defection.
4. **Critical Stock Conservation**: If the current stock level falls below 50% of capacity, cooperate (C) to help conserve the remaining stock.
5. **Last Round**: Defect (D) in the last round to maximize individual payoff, as there is no future game state to consider.

**Additional Mechanisms:**

1. **Opponent Monitoring**: Track the number of players who defected in each round to inform adaptive defection decisions.
2. **Stock Trend Analysis**: Monitor changes in stock levels over time to adjust cooperation and defection probabilities.

**Pseudocode (simplified):**
```
Initialize:
  stock_level = capacity
  opponents_defected = 0

For each round:
  if (round == 1) {
    action = C // Initial Round Cooperation
  } else if (stock_level >= 0.75 * capacity) {
    action = C // Stock-Based Cooperation
  } else if (stock_level >= 0.5 * capacity) {
    defect_prob = opponents_defected / n // Adaptive Defection
    if (random() < defect_prob) {
      action = D
    } else {
      action = C
    }
  } else { // Critical Stock Conservation
    action = C
  }

  if (round == r) { // Last Round
    action = D
  }

  opponents_defected = count(defectors in previous round)
  stock_level = update_stock_level(action, opponents_defected)

Return action
```
**Collective Mindset:**

The ASC strategy prioritizes collective sustainability by cooperating when the stock level is sufficient and adapting to opponents' behavior when it's not. By balancing individual payoffs with collective conservation, ASC promotes a stable and resilient game state.

This strategy should perform well in a tournament setting, as it:

1. Encourages cooperation initially
2. Adapts to opponents' behavior
3. Prioritizes stock conservation when necessary
4. Maximizes individual payoff in the last round
'''

description_COLLECTIVE_101 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

The ASP strategy aims to balance individual payoffs with collective sustainability by adaptively adjusting cooperation levels based on the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if stock >= capacity / 2; otherwise, Defect (D).
	* This initial choice sets a tone for the game and encourages cooperation when the stock is relatively healthy.
2. **Subsequent Rounds (t > 1):**
	* Calculate the average stock depletion rate over the previous rounds: `avg_depletion = (capacity - current_stock) / t`.
	* If `avg_depletion` is below a certain threshold (`depletion_threshold = capacity / (4 \* n)`), Cooperate (C).
	* Otherwise, Defect (D).
	* This rule adapts to the game's progression and adjusts cooperation levels based on the rate of stock depletion.
3. **Stock Thresholds:**
	* If the current stock is below a certain threshold (`stock_threshold = capacity / 4`), Defect (D) to maximize individual payoffs in the short term.
	* This rule ensures that players do not cooperate when the stock is critically low, as it may lead to extinction.

**Edge Cases:**

1. **Last Round (t=r):**
	* Always Defect (D), as there are no future rounds to consider and cooperation will only benefit others.
2. **Single Player Remaining:**
	* If only one player remains in the game, Cooperate (C) to preserve the stock for potential future interactions.

**Collective Mindset Alignment:**

The ASP strategy prioritizes collective sustainability by:

1. Encouraging cooperation when the stock is relatively healthy.
2. Adapting to the game's progression and adjusting cooperation levels based on the rate of stock depletion.
3. Preserving the stock in critical situations (low stock thresholds).

**Pseudocode:**
```
function ASP(current_stock, t, capacity, n):
  if t == 1:
    return C if current_stock >= capacity / 2 else D
  avg_depletion = (capacity - current_stock) / t
  depletion_threshold = capacity / (4 * n)
  stock_threshold = capacity / 4
  
  if avg_depletion < depletion_threshold:
    return C
  elif current_stock < stock_threshold:
    return D
  else:
    return D
  
  # Last round or single player remaining edge cases
  if t == r or num_players_remaining == 1:
    return D
```
The ASP strategy is designed to be robust and adaptive, making it a strong contender in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_102 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for the stock level.
2. **Stock Depletion Threshold:** Define a threshold `θ` as a fraction of the capacity (e.g., θ = 0.5). If the current stock level is below this threshold, Defect (D) to maximize individual payoffs before the stock depletes further.
3. **Opponent Behavior Adaptation:** Track the number of opponents who defected in previous rounds (`defectors_count`). If `defectors_count` exceeds half of the total players (`n/2`) in a given round, Defect (D) to avoid being exploited by others.
4. **Stock Recovery Opportunity:** If the current stock level is above the threshold `θ`, and fewer than half of opponents defected in the previous round, Cooperate (C) to contribute to stock growth.
5. **Endgame Strategy:** In the last round (`r`), Defect (D) to maximize individual payoffs regardless of the stock level.

Pseudocode:
```python
def ASC(stock, capacity, n, r, round_number):
  θ = 0.5 * capacity  # depletion threshold

  if round_number == 1:  # initial round
    return C
  elif stock < θ:
    return D
  else:
    defectors_count = count_defectors_previous_round()
    if defectors_count > n/2:
      return D
    elif stock > θ and defectors_count <= n/2:
      return C
    elif round_number == r:  # last round
      return D

def count_defectors_previous_round():
  # implement logic to track opponents' actions in previous rounds
```
**Edge Cases:**

* In the first round, cooperate to establish a baseline for the stock level.
* In the last round, defect to maximize individual payoffs regardless of the stock level.
* If the stock level is critically low (below `θ`), defect to avoid losing opportunities due to stock depletion.

**Collective Mindset:**

The ASC strategy prioritizes collective sustainability by:

1. Encouraging cooperation when the stock level is sufficient and opponents are not exploiting others.
2. Adapting to opponent behavior to avoid being exploited, while also contributing to stock growth when possible.
3. Prioritizing individual payoffs in critical situations (e.g., low stock levels or endgame scenarios).

By following these decision rules, ASC aims to balance individual interests with collective sustainability, making it a robust and adaptive strategy for the Common Pool Resource Game.
'''

description_COLLECTIVE_103 = '''
**Collective Strategy: Adaptive Tit-for-Two-Tats with Stock Conservation (ATTC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline for cooperation and observe opponents' actions.
2. **Subsequent Rounds:**
	* If the stock level is above 75% of capacity, cooperate (C) to maintain a sustainable stock level.
	* If the stock level is between 50% and 75% of capacity:
		+ Cooperate (C) if the majority (>50%) of opponents cooperated in the previous round.
		+ Defect (D) otherwise.
	* If the stock level is below 50% of capacity, defect (D) to maximize individual payoff in a depleted environment.
3. **Tit-for-Two-Tats (TFTT):** Monitor opponents' actions and respond accordingly:
	* If an opponent defects twice consecutively, defect (D) against them for two rounds before reassessing cooperation.

**Edge Cases:**

1. **Last Round:** Defect (D), as there is no future benefit to cooperating.
2. **Ties in Majority Voting:** In cases where the number of cooperators and defectors is equal, cooperate (C) to maintain a cooperative stance.

**Pseudocode:**
```
function ATTC(n, capacity, stock, history):
  // Initial Round
  if round == 1:
    return C

  // Stock Conservation
  if stock >= 0.75 * capacity:
    return C
  elif stock >= 0.5 * capacity:
    // Majority Voting
    cooperators = sum(1 for opponent in opponents if opponent_previous_action == C)
    if cooperators > n/2:
      return C
    else:
      return D
  else:
    return D

  // Tit-for-Two-Tats (TFTT)
  for opponent in opponents:
    if opponent_previous_actions[-2:] == [D, D]:
      return D for two rounds before reassessing cooperation

// Last Round
if round == r:
  return D

return C // Default to Cooperation
```
**Collective Mindset:**

The ATTC strategy prioritizes cooperation when the stock level is sustainable and opponents have demonstrated cooperative behavior. By adapting to the environment and opponents' actions, this strategy aims to maintain a balance between individual payoff maximization and collective sustainability.

In a tournament setting, the ATTC strategy will:

* Initially cooperate to establish a baseline for cooperation.
* Adapt to opponents' actions, rewarding cooperation and punishing repeated defection.
* Prioritize stock conservation when necessary, ensuring a sustainable environment for future rounds.

This strategy is robust to various opponent behaviors, as it responds to both cooperative and defective actions while maintaining a collective mindset focused on sustainability.
'''

description_COLLECTIVE_104 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

The ASC strategy aims to balance individual payoffs with collective stock conservation, adapting to the game's state and history while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if the number of players (n) is even.
	* Defect (D) if the number of players (n) is odd.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity:
		+ Cooperate (C) if the average opponent payoff in the previous round is below the threshold (π_avg < 0.5 × S/(2n)).
		+ Defect (D) otherwise.
	* If the current stock level is between 50% and 75% of the capacity:
		+ Cooperate (C) if the total consumption in the previous round is above 50% of the capacity.
		+ Defect (D) otherwise.
	* If the current stock level is below 50% of the capacity:
		+ Cooperate (C) unconditionally.

**Edge Cases:**

1. **Last Round (t=r):**
	* Always Defect (D), as there's no future benefit to cooperation.
2. **Low Stock Levels:**
	* If the current stock level is critically low (< 10% of capacity), Cooperate (C) unconditionally to allow for some growth.

**Pseudocode:**

```
function ASC(player_id, n, r, capacity, current_stock, history):
    if t == 1:
        # Initial round
        if n % 2 == 0:
            return C
        else:
            return D

    π_avg = calculate_average_opponent_payoff(history)
    total_consumption = calculate_total_consumption(history)

    if current_stock > 0.75 * capacity:
        if π_avg < 0.5 * current_stock / (2n):
            return C
        else:
            return D
    elif current_stock >= 0.5 * capacity:
        if total_consumption > 0.5 * capacity:
            return C
        else:
            return D
    else:
        # Low stock level or last round
        if t == r:
            return D
        elif current_stock < 0.1 * capacity:
            return C
        else:
            return C

def calculate_average_opponent_payoff(history):
    # Calculate average opponent payoff in the previous round
    # ...

def calculate_total_consumption(history):
    # Calculate total consumption in the previous round
    # ...
```

**Collective Mindset:**

The ASC strategy prioritizes stock conservation while adapting to the game's state and history. By cooperating when the stock level is high or when opponents are not exploiting, ASC promotes collective sustainability. When the stock level is critically low, unconditional cooperation allows for some growth. This balanced approach enables ASC to perform well in a tournament setting against various independent strategies.
'''

description_COLLECTIVE_105 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and observe others' actions.
2. **Subsequent Rounds:**
	* If the stock level is above 75% of capacity, Cooperate (C).
	* If the stock level is between 25% and 75% of capacity, Defect (D) with probability p = (stock / capacity) - 0.5. This introduces a degree of randomness to discourage opponents from consistently defecting.
	* If the stock level is below 25% of capacity, Cooperate (C) to conserve remaining resources.
3. **Opponent Observation:** Monitor opponents' actions and adjust the strategy based on their behavior:
	* If most opponents (>50%) Defected in the previous round, increase the probability of Defecting by 20% in the next round.
	* If most opponents Cooperated in the previous round, decrease the probability of Defecting by 10% in the next round.

**Edge Cases:**

1. **Last Round:** Cooperate (C) to maximize collective payoff and avoid destructive behavior.
2. **Low Stock Warning:** If the stock level falls below 10% of capacity, Cooperate (C) for two consecutive rounds to signal a warning to opponents and encourage cooperation.

**Collective Mindset:**

1. **Self-Preservation:** Prioritize individual payoffs while balancing collective sustainability.
2. **Adaptation:** Adjust strategy based on game state, history, and opponent behavior to maintain a dynamic equilibrium.
3. **Cooperation Incentives:** Encourage opponents to cooperate by providing opportunities for mutual benefit.

**Pseudocode:**
```
ASC_Strategy(n, r, capacity, stock) {
  // Initialize variables
  int round = 1;
  float stock_level = stock / capacity;

  while (round <= r) {
    if (round == 1) { // Initial Round
      action = C;
    } else {
      if (stock_level >= 0.75) {
        action = C;
      } else if (stock_level < 0.25) {
        action = C;
      } else {
        float p = stock_level - 0.5; // Randomized Defection
        if (random() < p) {
          action = D;
        } else {
          action = C;
        }
      }

      // Opponent Observation
      opponent_actions = observe_opponents();
      if (opponent_actions > 50% Defected) {
        p += 0.2; // Increase Defection probability
      } else if (opponent_actions > 50% Cooperated) {
        p -= 0.1; // Decrease Defection probability
      }
    }

    // Last Round
    if (round == r) {
      action = C;
    }

    // Low Stock Warning
    if (stock_level < 0.1) {
      action = C;
      if (previous_action == C) { // Second consecutive Cooperate
        round += 1; // Skip to next round
      }
    }

    return action;
  }
}
```
This strategy aims to strike a balance between individual payoffs and collective sustainability, adapting to the game's state and history while encouraging opponents to cooperate.
'''

description_COLLECTIVE_106 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Tit-for-Tat (ASDT)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a cooperative tone and encourage others to cooperate.
2. **Subsequent Rounds**: Implement a modified Tit-for-Tat strategy, where the probability of cooperation depends on the current stock level and the opponent's previous actions.

Pseudocode:
```
if round == 1:
    action = C
else:
    if stock > capacity * 0.7:  # sufficient stock, focus on cooperation
        if opponent_defected_last_round():
            action = D  # punish defector
        else:
            action = C  # maintain cooperation
    elif stock < capacity * 0.3:  # low stock, prioritize self-interest
        action = D  # defect to ensure own payoff
    else:  # moderate stock, balance cooperation and self-interest
        if opponent_cooperated_last_round():
            action = C  # reciprocate cooperation
        elif random() < (stock / capacity):  # probabilistic cooperation based on stock level
            action = C
        else:
            action = D
```
**Edge Cases:**

* **Last Round**: If the game is in its final round, prioritize self-interest and defect (D) to maximize individual payoff.
* **Stock Depletion**: If the stock level falls below a certain threshold (e.g., capacity * 0.1), consider it a "critical" state and switch to a more conservative strategy, cooperating only if others have cooperated in the previous round.

**Collective Mindset:**

The ASDT strategy aims to balance individual self-interest with collective cooperation, adapting to the dynamic game environment and opponents' behaviors. By:

* Cooperating initially and when stock levels are sufficient
* Punishing defectors and reciprocating cooperation
* Prioritizing self-interest when stock levels are low

ASDT promotes a collective mindset that encourages cooperation while allowing for individual adaptation to changing circumstances.

**Robustness:**

This strategy is designed to be robust against various opponent behaviors, including:

* **Pure Cooperation**: ASDT will cooperate and maintain a high level of cooperation.
* **Pure Defection**: ASDT will defect and prioritize self-interest.
* **Mixed Strategies**: ASDT will adapt its behavior based on the opponent's previous actions and stock levels.

By being adaptive and responsive to the game state, ASDT aims to perform well in a tournament setting against diverse strategies.
'''

description_COLLECTIVE_107 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Trigger (ACSDT)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a cooperative tone and gather information about opponents' behaviors.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of the capacity, defect (D) with a probability p, where p is calculated based on the opponent's previous round behavior:
		+ p = 0.5 if all opponents cooperated in the previous round.
		+ p increases linearly from 0.5 to 1 as the proportion of defectors among opponents in the previous round increases.
	* If the current stock level is below 50% of the capacity, defect (D) to maximize short-term payoff.
3. **Opponent Behavior Adaptation:** Update the probability p based on the opponent's behavior in the previous round:
	* If an opponent defected, increase p by 0.1 for that opponent.
	* If an opponent cooperated, decrease p by 0.1 for that opponent, but not below 0.

**Edge Cases:**

* **Last Round:** Defect (D) to maximize short-term payoff, as there is no future round to consider.
* **Tie in Opponent Behavior:** In case of a tie in the number of cooperators and defectors among opponents, cooperate (C).
* **Opponent with Unknown Behavior:** Treat an opponent with unknown behavior as if they had defected in the previous round.

**Collective Mindset:**

ACSDT is designed to balance individual self-interest with collective well-being. By cooperating when the stock level is high, ACSDT aims to maintain a sustainable resource level and encourage cooperation among opponents. When the stock level drops, ACSDT adapts by defecting more frequently to maximize short-term payoff while still considering the opponent's behavior.

**Pseudocode:**
```python
def ACSDT(current_stock, capacity, opponent_behaviors):
    if current_round == 1:
        return 'C'  # Cooperate in initial round

    stock_ratio = current_stock / capacity
    if stock_ratio >= 0.75:
        return 'C'
    elif stock_ratio >= 0.5:
        p = calculate_probability(opponent_behaviors)
        if random.random() < p:
            return 'D'
        else:
            return 'C'
    else:
        return 'D'

def calculate_probability(opponent_behaviors):
    # Calculate probability based on opponent behavior
    p = 0.5
    for opponent in opponent_behaviors:
        if opponent == 'D':
            p += 0.1
        elif opponent == 'C':
            p -= 0.1
            p = max(p, 0)
    return p
```
This strategy should be robust to a wide range of opponent behaviors and adapt to changing circumstances while maintaining a collective mindset.
'''

description_COLLECTIVE_108 = '''
I'll design a collective strategy for this Common Pool Resource Game that balances individual payoffs with the long-term sustainability of the common pool resource.

**Strategy Name: Adaptive Cooperation with Self-Regulation (ACSR)**

**Decision Rules:**

1. **Initial Rounds:** In the first round, cooperate (C) to establish a baseline and gauge other players' behavior.
2. **Cooperation Threshold:** Calculate a cooperation threshold (CT) based on the current stock level (S) and the number of rounds remaining (r_remaining). CT = S / (2n \* r_remaining).
3. **Action Selection:**
	* If the current stock level (S) is above the cooperation threshold (CT), cooperate (C).
	* If the current stock level (S) is below the cooperation threshold (CT), defect (D).
4. **Self-Regulation:** Monitor the average payoff per round and adjust the strategy to prevent over-exploitation. If the average payoff exceeds 75% of the maximum possible payoff, switch to a more conservative approach:
	* Reduce consumption by 20% for two consecutive rounds.
	* Re-evaluate the cooperation threshold (CT) after these two rounds.

**Handling Edge Cases:**

1. **Last Round:** In the final round, cooperate (C) if the current stock level is above 50% of the capacity; otherwise, defect (D).
2. **Low Stock Levels:** If the current stock level falls below 20% of the capacity, cooperate (C) for two consecutive rounds to allow the stock to recover.

**Collective Mindset:**

The ACSR strategy prioritizes cooperation and self-regulation to balance individual payoffs with long-term sustainability. By adapting to changing game conditions and monitoring average payoffs, this strategy promotes a collective approach that:

* Encourages cooperation when resources are abundant
* Regulates consumption to prevent over-exploitation
* Fosters recovery in periods of low resource availability

**Pseudocode:**
```python
def ACSR(stock, rounds_remaining, n):
    if rounds_remaining == 1:
        # Last round handling
        if stock > 0.5 * capacity:
            return C
        else:
            return D

    CT = stock / (2 * n * rounds_remaining)

    if stock > CT:
        # Cooperate when above threshold
        return C
    else:
        # Defect when below threshold
        return D

def self_regulate(avg_payoff, max_payoff):
    if avg_payoff > 0.75 * max_payoff:
        # Reduce consumption and re-evaluate CT
        reduce_consumption()
        re_evaluate_CT()

# Monitor average payoff and adjust strategy accordingly
avg_payoff = monitor_average_payoff()
self_regulate(avg_payoff, max_payoff)
```
This ACSR strategy is designed to be adaptive, robust, and collective, making it suitable for a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_109 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy balances individual payoffs with collective sustainability, adapting to opponents' behaviors while conserving the common pool resource.

**Decision Rules:**

1. **Initial Cooperation**: In the first round, cooperate (C) to establish a baseline for opponent behavior and encourage cooperation.
2. **Stock-Dependent Cooperation**: In subsequent rounds, if the current stock level is above 75% of capacity, cooperate (C). This ensures that when the stock is relatively high, players prioritize conservation over individual gain.
3. **Opponent-Based Defection**: If at least one opponent defected in the previous round, defect (D) in the current round. This retaliatory mechanism discourages opponents from exploiting cooperative behavior.
4. **Stock Conservation**: When the stock level falls below 25% of capacity, cooperate (C) to prioritize conservation over individual payoffs. This rule prevents catastrophic depletion and allows for potential recovery.

**Edge Cases:**

1. **Last Round**: In the final round, defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Tiebreaker**: If two or more opponents have defected in the previous round, use a simple tiebreaker rule:
	* Cooperate if your player index is odd (1, 3, ...).
	* Defect if your player index is even (2, 4, ...).

**Collective Mindset:**

The ASC strategy is designed to promote collective sustainability while adapting to various opponent behaviors. By initially cooperating and subsequently responding to opponents' actions, the strategy encourages cooperation and conservation.

Pseudocode:
```python
def ASC_strategy(stock_level, capacity, num_players, round_num, prev_actions):
    if round_num == 1:  # Initial Cooperation
        return "C"
    
    if stock_level >= 0.75 * capacity:  # Stock-Dependent Cooperation
        return "C"
    
    defector_count = sum(1 for action in prev_actions if action == "D")
    if defector_count > 0:  # Opponent-Based Defection
        return "D"
    
    if stock_level <= 0.25 * capacity:  # Stock Conservation
        return "C"
    
    # Last Round or Tiebreaker
    if round_num == num_rounds:
        return "D"
    elif defector_count > 1:
        if player_index % 2 == 1:  # Odd index, cooperate
            return "C"
        else:  # Even index, defect
            return "D"

# Example usage:
num_players = 4
capacity = 100
initial_stock = capacity

prev_actions = []  # Initialize previous actions list
for round_num in range(1, num_rounds + 1):
    stock_level = initial_stock
    for player_index in range(num_players):
        action = ASC_strategy(stock_level, capacity, num_players, round_num, prev_actions)
        # Update stock level based on chosen action (omitted for brevity)
        prev_actions.append(action)
```
This strategy is designed to be robust against a wide range of opponent behaviors while promoting collective sustainability. Its adaptability and responsiveness to opponents' actions make it well-suited for the tournament setting.
'''

description_COLLECTIVE_110 = '''
I propose a collective strategy called "Adaptive Stock Preservation" (ASP) that balances individual payoffs with long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe other players' actions.
2. **Subsequent Rounds**: Calculate the "Stock Depletion Ratio" (SDR) as follows:

   SDR = (capacity - current_stock) / capacity

   If SDR < 0.25, Cooperate (C). This ensures that when the stock is relatively full, cooperation helps maintain a sustainable level.
   
   If SDR ≥ 0.25 and SDR < 0.5, Defect (D) with probability P_defect = (SDR - 0.25) / 0.25. This introduces a gradual shift towards defection as the stock depletes.
   
   If SDR ≥ 0.5, Always Defect (D). When the stock is significantly depleted, individual payoffs become more important.

3. **Last Round**: Cooperate (C) in the last round if the current_stock > capacity / 2; otherwise, Defect (D).

**Additional Considerations:**

*   If all other players defected in the previous round and the current_stock < capacity / 2, Defect (D). This prevents being exploited by others' greedy behavior.
*   Monitor opponents' actions and adjust P_defect accordingly. If a player notices that most opponents are cooperating, they can reduce their own defection probability to maintain a fair balance.

**Pseudocode:**

```python
def adaptive_stock_preservation(current_stock, capacity, round_number, total_rounds):
    if round_number == 1:
        return "Cooperate"  # Initial round

    sdr = (capacity - current_stock) / capacity
    
    if sdr < 0.25:
        return "Cooperate"
    
    elif sdr >= 0.5:
        return "Defect"

    else:
        p_defect = (sdr - 0.25) / 0.25
        # Optional: adjust p_defect based on opponents' actions
        
        if random.random() < p_defect:
            return "Defect"
        else:
            return "Cooperate"


def last_round_adjustment(current_stock, capacity):
    if current_stock > capacity / 2:
        return "Cooperate"
    else:
        return "Defect"

# Combine the above functions
```

**Collective Mindset:**

ASP is designed to promote cooperation when the common pool resource is abundant and gradually shift towards individual optimization as the stock depletes. By balancing short-term gains with long-term sustainability, this strategy fosters a collective mindset that benefits all players.

While no single strategy can guarantee success against all possible opponents, ASP's adaptive nature makes it robust against various behaviors and capable of performing well in a tournament setting.
'''

description_COLLECTIVE_111 = '''
**Collective Strategy: Adaptive Common Pool Resource (CPR) Management**

Our collective strategy, CPR-Adapt, aims to balance individual payoffs with long-term sustainability of the common pool resource. We prioritize cooperation while adapting to changing game conditions and opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if stock ≥ capacity × 0.75.
	* Defect (D) otherwise.
2. **Subsequent Rounds (t > 1):**
	* Calculate the average payoff of all players in the previous round, π_avg,t-1.
	* If π_avg,t-1 ≥ stock / (2n), cooperate (C).
	* Otherwise, defect (D).
3. **Stock Thresholds:**
	* If stock falls below capacity × 0.25, cooperate (C) to conserve the resource.
	* If stock exceeds capacity × 0.9, defect (D) to maximize short-term payoffs.

**Edge Cases:**

1. **Last Round (t=r):**
	* Cooperate (C) if stock ≥ capacity × 0.5.
	* Defect (D) otherwise.
2. **Critical Stock Levels:**
	* If the stock level falls below a critical threshold (e.g., capacity × 0.1), cooperate (C) to prevent depletion.

**Pseudocode:**
```python
def CPR_Adapt(stock, capacity, n, t, history):
    if t == 1:
        # Initial round
        if stock >= capacity * 0.75:
            return C
        else:
            return D

    # Calculate average payoff in previous round
    pi_avg_t_1 = sum(history[t-1]) / n

    # Subsequent rounds
    if pi_avg_t_1 >= stock / (2*n):
        return C
    else:
        return D

    # Stock thresholds
    if stock < capacity * 0.25:
        return C
    elif stock > capacity * 0.9:
        return D

    # Last round
    if t == r and stock >= capacity * 0.5:
        return C
    else:
        return D
```
**Collective Mindset:**
CPR-Adapt prioritizes cooperation when the resource is abundant, ensuring long-term sustainability. As the game progresses, it adapts to changing conditions by monitoring average payoffs and stock levels. By balancing individual interests with collective well-being, CPR-Adapt promotes a resilient common pool resource management strategy.

**Robustness:**
CPR-Adapt's adaptive nature makes it robust against various opponent behaviors, including:

* Cooperators: CPR-Adapt will cooperate when the average payoff is high, aligning with cooperators.
* Defectors: CPR-Adapt will defect when the average payoff is low, minimizing losses to defectors.

By implementing CPR-Adapt, we aim to create a collective strategy that effectively manages the common pool resource while adapting to diverse opponent behaviors.
'''

description_COLLECTIVE_112 = '''
**Collective Strategy: Adaptive Stock-Conscious Tit-for-Tat (ASCT)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' initial actions.
2. **Subsequent Rounds:** Assess the current stock level (S) and the average payoff per player (APP) from the previous round.

   - If S > 0.75 \* capacity, cooperate (C). This ensures that when the stock is relatively high, we prioritize sustainability over short-term gains.
   
   - If S ≤ 0.75 \* capacity, defect (D) with a probability P_defect = (1 - (S/capacity))^2, otherwise cooperate (C). As the stock depletes, the likelihood of defecting increases to secure payoffs before the resource is exhausted.

3. **Tit-for-Tat Component:** Monitor opponents' actions and adjust our strategy accordingly.
   
   - If the majority (>50%) of opponents defected in the previous round, defect (D) in the current round. This discourages widespread defection by imposing a cost on those who exploit the resource excessively.
   
   - Otherwise, follow the stock-conscious decision from step 2.

**Edge Cases:**

1. **Last Round:** Defect (D) to maximize payoffs since there's no future cost for over-extraction.
2. **Low Stock Levels (S < n):** Always cooperate (C) when the remaining stock is insufficient to meet demand if all players defect, as this avoids total depletion and preserves some value.

**Collective Mindset Alignment:**

ASCT balances individual interests with collective sustainability by adapting to the dynamic state of the common pool. By cooperating when the stock is relatively high and adjusting our strategy based on opponents' actions, we promote cooperation while discouraging exploitation.

Pseudocode:

```python
def ASCT(stock, capacity, n, history):
    if round == 1:
        return 'C'

    S = stock
    APP_prev = calculate_average_payoff(history)
    
    if S > 0.75 * capacity:
        action = 'C'
    else:
        P_defect = (1 - (S/capacity))**2
        action = 'D' if random.random() < P_defect else 'C'

    # Tit-for-Tat adjustment
    opponent_actions_prev = get_opponent_actions(history)
    num_defectors_prev = sum(opponent_actions_prev == 'D')
    
    if num_defectors_prev > n/2:
        action = 'D'
        
    return action
```

This strategy is adaptive, robust to various opponent behaviors, and prioritizes collective sustainability while ensuring individual interests are protected.
'''

description_COLLECTIVE_113 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Trigger (ACST)**

The ACST strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and opponent behavior.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage opponents to follow suit.
2. **Stock-Based Trigger**: In subsequent rounds, calculate the stock ratio `sr = current_stock / capacity`. If `sr` is above a certain threshold (`sr_threshold = 0.7`), cooperate (C). Otherwise, defect (D).
3. **Opponent Adaptation**: Monitor opponent actions and adjust cooperation levels based on their behavior:
	* If an opponent cooperates, increase the cooperation level by a small amount (`cooperation_increase = 0.05`).
	* If an opponent defects, decrease the cooperation level by a larger amount (`cooperation_decrease = 0.1`).
4. **Stock Recovery**: When the stock ratio `sr` falls below a certain threshold (`sr_recovery_threshold = 0.3`), switch to full cooperation (C) to help recover the stock.
5. **Endgame**: In the last round, defect (D) to maximize individual payoff.

**Pseudocode:**
```python
def ACST(n, capacity, current_stock, opponent_actions):
    sr_threshold = 0.7
    sr_recovery_threshold = 0.3
    cooperation_increase = 0.05
    cooperation_decrease = 0.1

    if round == 1:
        return C  # Initial round: cooperate

    sr = current_stock / capacity
    if sr > sr_threshold:
        action = C  # Stock-based trigger: cooperate
    else:
        action = D  # Stock-based trigger: defect

    for opponent in opponent_actions:
        if opponent == C:
            cooperation_level += cooperation_increase
        elif opponent == D:
            cooperation_level -= cooperation_decrease

    if sr < sr_recovery_threshold:
        action = C  # Stock recovery: cooperate

    if round == r:  # Last round
        return D  # Endgame: defect

    return action
```
**Collective Mindset:**
The ACST strategy prioritizes collective sustainability by:

1. Encouraging cooperation through initial cooperation and stock-based triggers.
2. Adapting to opponent behavior to maintain a balance between individual payoffs and collective well-being.
3. Focusing on stock recovery when the resource is depleted.

By implementing these decision rules, the ACST strategy aims to promote a collective mindset that balances individual interests with the need for sustainable resource management.
'''

description_COLLECTIVE_114 = '''
Here's a collective strategy that adapts to various opponent behaviors and optimizes long-term payoffs:

**Strategy Name:** Adaptive Collective Harvesting (ACH)

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe the initial stock level and capacity.
	* Cooperate (C) if the number of players (n) is high (> 4), to prevent over-harvesting. Otherwise, Defect (D).
2. **General Rounds (t > 1)**:
	* Evaluate the current stock level (S) and growth rate from the previous round.
	* If S ≥ capacity/2, Cooperate (C). This ensures sustainable harvesting when the stock is plentiful.
	* If S < capacity/2, Defect (D) with a probability p = (capacity - S) / capacity. This adapts to low stock levels by increasing defection rates to avoid over-harvesting.
3. **Last Round (t=r)**:
	* Cooperate (C) if the current stock level is high (> 2n), as there's no risk of future depletion. Otherwise, Defect (D).
4. **Response to Opponent Actions**:
	* Monitor opponents' actions and adjust your strategy accordingly.
	* If a significant portion of opponents (> n/2) defected in the previous round, increase your defection rate by 20% in the next round.

**Edge Cases:**

1. **Low Stock Levels**: If the stock level falls below 10% of the capacity, Defect (D) to prevent complete depletion.
2. **High Opponent Defection Rates**: If more than 75% of opponents defected in the previous round, Cooperate (C) to signal a willingness to sustain the resource.

**Collective Mindset:**

1. **Sustainable Harvesting**: Prioritize long-term sustainability over short-term gains by adapting to stock levels and growth rates.
2. **Adaptive Response**: Adjust your strategy based on opponents' actions to maintain a balance between cooperation and defection.
3. **Risk Management**: Manage risk by cooperating in the initial round, responding to low stock levels, and adjusting to opponent behaviors.

**Pseudocode:**

```
function ACH(n, r, capacity, S) {
  // Initialize variables
  t = 1; // Round counter
  defect_rate = 0; // Defection rate

  while (t <= r) {
    if (t == 1) { // Initial round
      if (n > 4) cooperate = true;
      else cooperate = false;
    } else {
      evaluate_stock(S);
      if (S >= capacity/2) cooperate = true;
      else defect_rate = (capacity - S) / capacity;
      cooperate = (random() < defect_rate);
    }

    // Monitor opponents' actions and adjust strategy
    opponent_actions = observe_opponent_actions();
    if (opponent_defection_rate > n/2) {
      defect_rate += 0.20;
    }

    // Handle edge cases
    if (S < 0.10 * capacity) cooperate = false;
    if (opponent_defection_rate > 0.75) cooperate = true;

    // Update stock level and growth rate
    S = update_stock(S, cooperate);

    t++;
  }
}
```

This strategy balances cooperation and defection to optimize long-term payoffs while adapting to various opponent behaviors and game conditions.
'''

description_COLLECTIVE_115 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

**Overview**

The ACST strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and game history.

**Decision Rules**

1. **Cooperation Threshold**: Calculate a dynamic cooperation threshold `T` as a function of the current stock level `S`:
   - `T = capacity / (2n) * (S/capacity)^γ`
   where `γ` is a strategy parameter (e.g., 0.5) that controls the responsiveness to stock changes.
2. **Cooperation vs Defection**:
   - Cooperate (`C`) if `S > T`
   - Defect (`D`) otherwise

**Handling Edge Cases**

1. **First Round**: Cooperate (`C`)
2. **Last Round**: Defect (`D`)
3. **Low Stock (S < capacity/2n)**: Always cooperate (`C`) to avoid depletion
4. **High Stock (S > 3/4 \* capacity)**: Gradually increase cooperation as stock approaches capacity

**Adaptation Mechanism**

1. **Stock-Based Memory**: Maintain a memory `M` of the average stock level over the last `k` rounds (e.g., `k = 5`)
2. **Adjust γ**: Periodically update `γ` based on the performance difference between cooperation and defection in recent rounds:
   - Increase `γ` if cooperation yields higher payoffs
   - Decrease `γ` otherwise

**Collective Mindset**

ACST prioritizes collective sustainability while adapting to individual opportunities:

1. **Initial Cooperation**: Cooperate initially to establish a high stock level, making it easier for others to cooperate.
2. **Dynamic Adjustment**: Adapt the cooperation threshold based on the current stock level, encouraging cooperation when the stock is low and defection when the stock is high.

Pseudocode:
```python
def ACST(n, capacity, r):
  T = capacity / (2n) * (S/capacity)^γ
  memory = []

  for t in range(r):
    if S < capacity/2n or t == 0:
      action = C
    elif S > 3/4 \* capacity:
      action = D with probability increasing as S approaches capacity
    else:
      action = C if S > T else D

    update_memory(S, memory)
    adjust_gamma(memory)

    return action
```
This strategy balances individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and game history.
'''

description_COLLECTIVE_116 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Sensitive Threshold (ACST)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a cooperative tone and avoid initial stock depletion.
2. **Subsequent Rounds**:
	* If the current stock level is above a threshold (`stock_threshold`), cooperate (C).
	* Otherwise, defect (D).

`stock_threshold` is calculated as follows:

`stock_threshold = capacity * (1 - (n-1)/n)`

This threshold adjusts to the number of players and ensures that cooperation occurs when the stock level is sufficient to support all players.

**Adaptive Adjustment**:
After each round, update `stock_threshold` based on the observed behavior of other players:

* If more than half of the players cooperated in the previous round, increase `stock_threshold` by 5% (max capacity).
* If less than half cooperated, decrease `stock_threshold` by 5% (min 0).

This adjustment allows ACST to adapt to the collective behavior and respond to changes in cooperation levels.

**Edge Cases**:

1. **Last Round**: Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Low Stock Levels**: If the stock level falls below a critical threshold (`critical_stock = capacity / n`), cooperate (C) to help replenish the stock and prevent collapse.

**Collective Mindset**:
ACST prioritizes cooperation when the collective benefit is high, while adapting to changes in player behavior to maintain a stable and efficient exploitation of the common resource. By setting an initial cooperative tone and adjusting the threshold based on observed behavior, ACST promotes a balanced approach that balances individual interests with collective well-being.

Pseudocode:
```
function ACST(stock, capacity, n, round):
  if round == 1: # Initial Round
    return C
  else:
    stock_threshold = capacity * (1 - (n-1)/n)
    if stock > stock_threshold:
      return C
    else:
      return D

  # Adaptive Adjustment
  if more_than_half_cooperated:
    stock_threshold *= 1.05
  elif less_than_half_cooperated:
    stock_threshold *= 0.95

  # Edge Cases
  if round == last_round:
    return D
  elif stock < critical_stock:
    return C
```
This strategy is designed to be robust, adaptive, and collective-oriented, making it a strong contender in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_117 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

**Overview**
Adaptive Cooperation (AC) is a collective strategy designed for the Common Pool Resource Game. AC balances individual interests with collective sustainability by adaptively responding to the game state and history.

**Decision Rules**

1. **Initial Round**: Cooperate (C). This sets a positive tone and encourages others to cooperate.
2. **Subsequent Rounds**: Use the following logic:
	* If the current stock level is above 75% of capacity, Defect (D) with probability 0.5, otherwise Cooperate (C).
	* If the average payoff per player in the previous round is below 50% of the maximum possible payoff, Defect (D). This indicates that the group is not exploiting the resource efficiently.
	* If a player has defected more than 25% of the time in the past two rounds, Cooperate (C) with probability 0.7 to encourage cooperation and avoid punishment.
3. **Last Round**: Always Defect (D), as there's no future benefit from cooperating.

**Pseudocode**
```python
def adaptive_cooperation(current_stock, capacity, history):
    if current_round == 1:  # Initial round
        return "C"
    
    avg_payoff_prev = calculate_average_payoff(history)
    defect_rate_prev = calculate_defect_rate(history, 2)
    
    if current_stock > 0.75 * capacity:
        if random.random() < 0.5:
            return "D"
        else:
            return "C"
    elif avg_payoff_prev < 0.5 * max_possible_payoff:
        return "D"
    elif defect_rate_prev > 0.25:
        if random.random() < 0.7:
            return "C"
        else:
            return "D"
    
    # Default to cooperation
    return "C"
```
**Collective Mindset**
AC prioritizes collective sustainability while adapting to individual interests. By initially cooperating and responding to the game state, AC encourages others to cooperate and maintains a balance between exploitation and conservation.

**Edge Cases**

* **First Round**: Cooperate (C) to set a positive tone.
* **Last Round**: Always Defect (D), as there's no future benefit from cooperating.
* **Low Stock Levels**: Cooperate (C) when the stock level is below 25% of capacity to avoid depleting the resource.

**Robustness**
AC is designed to be robust against various opponent behaviors:

* **Cooperative opponents**: AC will adapt and cooperate, leading to a mutually beneficial outcome.
* **Defective opponents**: AC will defect in response, avoiding exploitation and maintaining a balance.
* **Mixed strategies**: AC's adaptive nature allows it to respond effectively to mixed strategies.

By implementing Adaptive Cooperation (AC), we aim to achieve a high total payoff while promoting collective sustainability in the Common Pool Resource Game.
'''

description_COLLECTIVE_118 = '''
Here is a collective strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline of cooperation and observe others' actions.
2. **Current Stock Threshold**: Define a stock threshold `θ` as a function of the capacity: `θ = 0.5 * capacity`. If the current stock is above `θ`, cooperate (C). Otherwise, defect (D).
3. **Opponent Action Analysis**: Track the number of opponents who defected (`defectors`) and cooperated (`cooperators`) in the previous round. Calculate the proportion of defectors: `p_defect = defectors / n`.
4. **Adaptive Response**:
	* If `p_defect > 0.5`, defect (D) to avoid exploitation.
	* If `p_defect ≤ 0.5` and current stock is above `θ`, cooperate (C).
	* If `p_defect ≤ 0.5` and current stock is below `θ`, defect (D) with probability `0.5`, otherwise cooperate (C).
5. **Last Round**: Defect (D) in the last round to maximize individual payoff.

**Pseudocode:**
```python
def ACC(stock, capacity, n, history):
  θ = 0.5 * capacity

  if current_round == 1:
    return 'C'

  defectors = sum(1 for action in history[-1] if action == 'D')
  p_defect = defectors / n

  if stock > θ:
    if p_defect > 0.5:
      return 'D'
    else:
      return 'C'
  else:
    if random.random() < 0.5:  # 50% chance to defect
      return 'D'
    else:
      return 'C'

  if current_round == r:  # last round
    return 'D'
```
**Rationale:**

ACC balances individual self-interest with collective conservation by adapting to the current stock level and opponents' actions. By cooperating when the stock is above `θ`, we ensure a sustainable resource for future rounds. When opponents defect excessively, ACC switches to defection to avoid exploitation.

The adaptive response mechanism allows ACC to adjust its behavior based on the proportion of defectors in the previous round. The random element in the low-stock scenario introduces noise to prevent opponents from predicting our actions too easily.

**Collective Mindset:**

ACC aims to promote collective conservation while protecting individual interests. By adapting to the current stock level and opponents' actions, ACC encourages cooperation when possible and defecting only when necessary to avoid exploitation.

In a tournament setting, ACC's adaptability will help it perform well against various opponent strategies, as it can adjust its behavior in response to different scenarios.
'''

description_COLLECTIVE_119 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. This approach ensures robustness against various opponent behaviors while promoting cooperation when beneficial.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative tone and observe opponents' initial actions.
2. **Middle Rounds (1 < t < r):**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play a mixed strategy:
		+ Cooperate (C) with probability p = (current_stock / capacity)^2.
		+ Defect (D) with probability 1 - p.
	* If the current stock level is below 50% of capacity, defect (D).
3. **Last Round (t=r):** Defect (D), as there's no future sustainability concern.

**Edge Case Handling:**

* If an opponent defects in the initial round, ASC will still cooperate to maintain a cooperative stance.
* In middle rounds, if all opponents defected in the previous round, ASC will defect as well to avoid being taken advantage of.

**Collective Mindset Alignment:**

ASC prioritizes cooperation when the stock level is high, allowing for sustainable growth and collective benefit. As the stock level decreases, the strategy adapts by introducing a mixed approach, balancing individual payoffs with sustainability concerns. In critical situations (low stock levels), ASC defects to ensure individual survival.

**Pseudocode:**
```python
def adaptive_stock_conservation(n, r, capacity, current_stock, history):
    if t == 1:
        return "C"  # Initial round cooperation

    if current_stock >= 0.75 * capacity:
        return "C"  # Cooperate when stock is high
    elif 0.5 * capacity <= current_stock < 0.75 * capacity:
        p = (current_stock / capacity) ** 2
        return "C" if random.random() < p else "D"  # Mixed strategy
    else:
        return "D"  # Defect when stock is low

    if t == r:  # Last round
        return "D"

    # Update history and adapt for next round
    history.append(current_stock)
```
ASC's adaptive nature allows it to respond effectively to various opponent behaviors, promoting collective sustainability while ensuring individual payoffs.
'''

description_COLLECTIVE_120 = '''
**Collective Strategy: Adaptive Cooperation with Stock Conservation (ACSC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline of cooperation and observe others' behavior.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 25% and 75% of the capacity, use a mixed strategy:
		+ Cooperate (C) with probability p = (current stock / capacity)^2.
		+ Defect (D) with probability 1 - p.
	* If the current stock level is below 25% of the capacity, defect (D).

**Pseudocode:**
```
def ACSC(stock, capacity):
    if round == 1:
        return C
    elif stock > 0.75 * capacity:
        return C
    elif 0.25 * capacity <= stock <= 0.75 * capacity:
        p = (stock / capacity)^2
        return C with probability p, D otherwise
    else:
        return D
```
**Rationale:**

1. **Initial Cooperation:** Establishing a baseline of cooperation in the first round encourages others to cooperate and sets a positive tone for the game.
2. **Stock Conservation:** When the stock level is high, cooperating ensures that everyone gets a reasonable payoff while conserving the resource.
3. **Mixed Strategy:** As the stock level decreases, the mixed strategy introduces uncertainty, making it more difficult for opponents to exploit us. The probability of cooperation decreases as the stock level drops, reflecting our growing concern about the resource's depletion.
4. **Defection at Low Stock Levels:** When the stock level is critically low, defecting ensures that we get a higher payoff than cooperating would yield.

**Collective Mindset:**

Our strategy prioritizes collective well-being by:

1. Encouraging cooperation when resources are plentiful.
2. Gradually introducing uncertainty as resources dwindle, making it harder for opponents to exploit us.
3. Prioritizing individual payoffs only when the resource is critically depleted.

By adapting to the game's state and history, ACSC promotes a balance between collective cooperation and individual self-interest, increasing the chances of achieving a better outcome for all players.
'''

description_COLLECTIVE_121 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Overview**

The Adaptive Cooperative Harvesting (ACH) strategy is a collective approach that balances individual self-interest with the need to maintain a sustainable common pool resource. ACH is designed to adapt to various opponent behaviors, promoting cooperation while minimizing the risk of over-harvesting.

**Decision Rules**

1. **Initial Rounds**: In the first round, cooperate (C) to establish a cooperative tone and gather information about other players' strategies.
2. **Assessing Cooperation**: Track the average stock consumption per player over the last few rounds (e.g., 3-5 rounds). If this value is below the sustainable threshold (`stock/(2n)`), cooperate in the next round. Otherwise, defect.
3. **Defection Detection**: Monitor the number of players who defected in the previous round. If more than half of the players defected, defect in the next round to avoid being exploited.
4. **Stock-Based Adaptation**: Adjust cooperation based on the current stock level:
	* If `stock > capacity * 0.75`, cooperate to maintain a sustainable stock level.
	* If `stock < capacity * 0.25`, defect to maximize individual payoff in a depleted resource environment.
	* Otherwise, use the assessing cooperation rule (step 2).
5. **Last Round**: In the final round, always cooperate to ensure the maximum possible collective payoff.

**Edge Cases**

1. **First Round**: Cooperate to establish a cooperative tone and gather information about other players' strategies.
2. **Last Round**: Always cooperate to maximize collective payoff.
3. **Low Stock Levels**: If `stock < capacity * 0.1`, always defect to minimize losses in an over-harvested environment.

**Pseudocode**
```markdown
function ACH(n, r, capacity, current_stock, history):
    if round == 1:
        return COOPERATE

    # Assessing cooperation
    avg_consumption = calculate_average_consumption(history)
    if avg_consumption < stock/(2n):
        return COOPERATE

    # Defection detection
    defectors = count_defectors(history[-1])
    if defectors > n/2:
        return DEFECT

    # Stock-based adaptation
    if current_stock > capacity * 0.75:
        return COOPERATE
    elif current_stock < capacity * 0.25:
        return DEFECT

    # Last round
    if round == r:
        return COOPERATE

    return DEFECT
```
**Collective Mindset**

The ACH strategy promotes a collective mindset by:

1. Encouraging cooperation in the initial rounds to establish a cooperative tone.
2. Adapting to opponent behaviors, which helps maintain a sustainable common pool resource.
3. Prioritizing cooperation when the stock level is high, reducing the risk of over-harvesting.

By following these decision rules and adapting to changing game conditions, ACH aims to achieve a balance between individual self-interest and collective sustainability in the Common Pool Resource Game.
'''

description_COLLECTIVE_122 = '''
To design a collective strategy for this Common Pool Resource Game, I propose a hybrid approach that combines elements of Tit-for-Tat (TFT), Grim Trigger (GT), and a novel stock-based adaptation mechanism.

**Decision Rules:**

1. **Initial Cooperation**: In the first round, cooperate (C) to initiate cooperation and establish a baseline trust.
2. **Tit-for-Tat (TFT)**: For rounds 2 to r-1, mirror the opponent's previous action:
	* If the majority of opponents cooperated in the previous round, cooperate (C).
	* If the majority defected, defect (D).
3. **Grim Trigger (GT) with Stock Threshold**: Introduce a stock-based trigger to switch from TFT to defection:
	* Monitor the current stock level and calculate the "sustainable threshold" as 50% of the capacity.
	* If the stock falls below this threshold, switch to permanent defection (D) for all remaining rounds.

**Adaptive Stock-Based Mechanism:**

1. **Stock Monitoring**: Continuously track the current stock level and adjust the decision-making process accordingly.
2. **Adjusting TFT's Majority Threshold**: Dynamically adjust the majority threshold used in TFT based on the current stock level:
	* When the stock is above 75% of capacity, require a higher majority (e.g., 60%) to cooperate.
	* When the stock is between 50% and 75% of capacity, use the standard majority threshold (e.g., 50%).
	* When the stock falls below 50%, switch to GT with permanent defection.

**Edge Cases:**

1. **Last Round**: In the final round (r), always defect (D) to maximize individual payoff.
2. **Tie-Breaking**: In cases where the majority is tied, cooperate (C) to maintain cooperation and avoid unnecessary conflict.

**Collective Mindset:**

The proposed strategy aligns with a collective mindset by:

1. Initially cooperating to establish trust and encourage cooperation.
2. Mirroring opponents' actions through TFT to promote reciprocity.
3. Introducing a stock-based trigger to switch to defection, which serves as a warning mechanism for over-exploitation.

**Pseudocode:**
```
# Initialize variables
capacity = game_capacity
stock = capacity
rounds = game_rounds
opponent_actions = []

# First round: cooperate
if current_round == 1:
    action = C

# Tit-for-Tat with stock-based adaptation
else:
    # Monitor stock level and adjust TFT's majority threshold
    if stock < 0.5 * capacity:
        switch_to_defection = True
    elif stock < 0.75 * capacity:
        majority_threshold = 0.6
    else:
        majority_threshold = 0.5

    # Mirror opponent's previous action (TFT)
    if sum(opponent_actions) / len(opponent_actions) >= majority_threshold:
        action = C
    else:
        action = D

    # Switch to permanent defection if stock falls below threshold
    if switch_to_defection:
        action = D

# Last round: defect
if current_round == rounds:
    action = D

return action
```
This strategy is designed to be adaptive, robust, and collective-minded, allowing it to perform well in a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_123 = '''
To design a collective strategy for this Common Pool Resource Game, I'll introduce " Adaptive Cooperative Balance" (ACB). ACB aims to balance individual self-interest with collective sustainability, adapting to the game's dynamic state and history.

**Decision Rules:**

1. **Initial Cooperation**: In the first round, cooperate (C) if the stock is above 75% of capacity; otherwise, defect (D).
2. **Stock-Based Adaptation**: For subsequent rounds, calculate the " Stock Utilization Rate" (SUR):
   SUR = current_stock / capacity
   Cooperate (C) if SUR > 0.5 and at least one player defected in the previous round; otherwise, defect (D).
3. **Opponent Response**: Monitor opponent actions and adjust strategy:
   If more than half of opponents cooperated in the previous round, cooperate (C); otherwise, defect (D).

**Edge Cases:**

1. **First Round**: Cooperate if stock > 0.75 \* capacity; otherwise, defect.
2. **Last Round**: Defect to maximize individual payoff, as there's no future game impact.
3. **Low Stock**: If stock < 25% of capacity, always cooperate (C) to preserve the resource.

**Collective Mindset Alignment:**

ACB prioritizes cooperation when the collective benefit is clear (high SUR) and adapts to opponent behavior. By cooperating when others do, ACB promotes a norm of reciprocity. When opponents defect excessively, ACB responds by defecting to protect individual interests.

Pseudocode for the Adaptive Cooperative Balance strategy:
```markdown
# Initialize variables
stock_utilization_rate = current_stock / capacity

# First round logic
if (round == 1) {
  if (stock_utilization_rate > 0.75) {
    action = COOPERATE
  } else {
    action = DEFECT
  }
}

# Subsequent rounds
else {
  # Check opponent actions from previous round
  opponents_cooperated = count(opponents_actions == COOPERATE)
  
  if (opponents_cooperated > n/2) {
    action = COOPERATE
  } else if (stock_utilization_rate > 0.5 && any(opponent_defected)) {
    action = COOPERATE
  } else {
    action = DEFECT
  }
}

# Last round logic
if (round == r) {
  action = DEFECT
}

# Low stock protection
if (current_stock < 0.25 * capacity) {
  action = COOPERATE
}
```
ACB is designed to be adaptive, balancing cooperation and self-interest while being robust to various opponent behaviors. This strategy will play in the tournament, aiming for a balance between individual payoff maximization and collective sustainability.
'''

description_COLLECTIVE_124 = '''
I propose a collective strategy called "Adaptive Stock Preservation" (ASP). ASP aims to balance individual payoffs with collective stock preservation, adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for the stock level and encourage cooperation.
2. **Stock Thresholds:** Define two stock thresholds:
	* `low_stock_threshold` = 0.5 × capacity
	* `high_stock_threshold` = 0.8 × capacity

These thresholds will guide our cooperation decisions.

3. **Cooperation Logic:**
	* If the current stock level is above `high_stock_threshold`, cooperate (C) to maintain a sustainable stock level.
	* If the current stock level is below `low_stock_threshold`, defect (D) to maximize individual payoff in a depleted stock scenario.
	* If the current stock level is between `low_stock_threshold` and `high_stock_threshold`, use the following adaptive logic:
		+ Calculate the average payoff per player from the previous round (`avg_payoff_prev_round`).
		+ If `avg_payoff_prev_round` is above the average payoff for cooperation (S/(2n)), cooperate (C) to maintain a stable stock level.
		+ Otherwise, defect (D) to increase individual payoff.

**Pseudocode:**
```python
def adaptive_stock_preservation(stock, capacity, n, history):
    low_stock_threshold = 0.5 * capacity
    high_stock_threshold = 0.8 * capacity

    if round == 1:
        return "C"  # Cooperate in the first round

    if stock > high_stock_threshold:
        return "C"
    elif stock < low_stock_threshold:
        return "D"

    avg_payoff_prev_round = calculate_average_payoff(history)
    avg_coop_payoff = stock / (2 * n)

    if avg_payoff_prev_round >= avg_coop_payoff:
        return "C"
    else:
        return "D"
```
**Edge Cases:**

* Last Round: In the last round, defect (D) to maximize individual payoff, as there are no future consequences.
* Ties: In cases where the adaptive logic results in a tie (e.g., average payoff per player equals the average cooperation payoff), cooperate (C) to prioritize stock preservation.

**Collective Mindset:**

ASP prioritizes collective stock preservation while adapting to the game's state and history. By cooperating when the stock level is high and defecting when it's low, ASP balances individual payoffs with the need for sustainable resource management. This strategy encourages cooperation without relying on specific coordination mechanisms or opponent behaviors.

In a tournament setting, ASP will compete against independent strategies developed by other AI systems. Its adaptability and focus on collective stock preservation make it a robust contender in this game environment.
'''

description_COLLECTIVE_125 = '''
**Collective Strategy: "Adaptive Sustainability" (AS)**

The Adaptive Sustainability strategy is designed to balance individual payoffs with collective sustainability, ensuring a robust and adaptive approach to the Common Pool Resource Game.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) if stock is above 75% of capacity; otherwise, Defect (D).
2. **Subsequent Rounds (t>1):**
	* If the average payoff per player in the previous round was below 25% of the maximum possible payoff (i.e., S/n), Defect (D).
	* Otherwise, Cooperate (C) if the stock level is above 50% of capacity; otherwise, Defect (D).
3. **Last Round (t=r):** Cooperate (C) to ensure a minimum collective payoff.

Pseudocode:
```
if t == 1:  // Initial round
    if stock > 0.75 * capacity:
        action = C
    else:
        action = D
else:  // Subsequent rounds
    avg_payoff_prev_round = (Σ(π_i,t-1)) / n
    if avg_payoff_prev_round < 0.25 * S/n:
        action = D
    elif stock > 0.5 * capacity:
        action = C
    else:
        action = D

if t == r:  // Last round
    action = C
```
**Handling Edge Cases:**

1. **First Round:** Cooperate if the stock is high to establish a collective norm and encourage cooperation.
2. **Last Round:** Cooperate to ensure a minimum collective payoff, as there are no future rounds to consider.
3. **Low Stock Levels:** Defect when the stock level is low to avoid further depletion and potential collapse.

**Collective Mindset:**

The Adaptive Sustainability strategy prioritizes collective sustainability by:

1. Encouraging cooperation in early rounds to establish a positive norm.
2. Adapting to changing conditions, such as declining average payoffs or low stock levels.
3. Ensuring a minimum collective payoff in the last round.

By balancing individual payoffs with collective sustainability, AS aims to promote cooperation and achieve a robust performance across various opponent behaviors.
'''

description_COLLECTIVE_126 = '''
**Collective Strategy: "Adaptive Conservation"**

Our collective strategy, "Adaptive Conservation," aims to balance individual self-interest with the long-term sustainability of the common pool resource. We'll use a dynamic approach that adjusts behavior based on the current state and history of the game.

**Decision Rules:**

1. **Initial Round (Round 1): Cooperate**
In the first round, all players cooperate by choosing action C. This sets a positive tone for the game and helps establish a baseline stock level.
2. **Assess Stock Level and History**
Before each subsequent round, assess the current stock level and the history of actions taken by all players.

**Cooperation Threshold (CT):**
Calculate the cooperation threshold CT as a function of the current stock level S and the capacity:

CT = 0.7 × (capacity - S) / capacity

If the number of cooperators in the previous round is above this threshold, we cooperate; otherwise, we defect.

**Adaptive Defection (AD):**
However, if our individual payoff in the previous round was significantly lower than the average payoff (i.e., π_i < 0.5 × avg(π_j)), and the stock level is relatively high (S > 0.8 × capacity), we will temporarily switch to defecting for one round to try to increase our own payoff.

**Edge Cases:**

* **Last Round:** In the final round, all players cooperate by choosing action C to maximize the remaining stock.
* **Stock Depletion:** If the stock level falls below 0.2 × capacity, we will always cooperate to help recover the resource.

Pseudocode:

```
function AdaptiveConservation(current_stock, capacity, history):
    if (current_round == 1) or (stock_level < 0.2 * capacity) then
        return COOPERATE
    end

    cooperation_threshold = 0.7 * (capacity - current_stock) / capacity
    previous_cooperators = count(cooperative_actions_in_history)

    if (previous_cooperators > cooperation_threshold) and not AdaptiveDefection() then
        return COOPERATE
    else
        return DEFECT
    end

function AdaptiveDefection(current_payoff, average_payoff, current_stock, capacity):
    if (current_payoff < 0.5 * average_payoff) and (current_stock > 0.8 * capacity) then
        return true
    else
        return false
    end
```

This strategy aims to promote cooperation while allowing for temporary deviations to maintain a balance between individual self-interest and collective sustainability.
'''

description_COLLECTIVE_127 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and game states:

**Strategy Name: Adaptive Cooperative Harvesting (ACH)**

**Decision Rules:**

1. **Initial Rounds:** In the first few rounds (e.g., 2-3), play Cooperate (C) unconditionally to:
	* Establish a cooperative baseline.
	* Gather information about opponents' behaviors.
	* Help maintain a healthy stock level.
2. **Stock-Based Decision Making:**
	* If the current stock level is above 75% of capacity, play C.
	* If the current stock level is between 50% and 75% of capacity, play D with probability p = (capacity - stock) / (0.5 \* capacity).
	* If the current stock level is below 50% of capacity, play D unconditionally.
3. **Opponent Behavior Adaptation:**
	* Track the number of opponents playing C and D in each round.
	* Calculate the average opponent cooperation rate over the last few rounds (e.g., 5).
	* If the average opponent cooperation rate is above 0.7, play C with increased probability p = 0.8 + (average_cooperation_rate - 0.7) \* 0.2.
	* If the average opponent cooperation rate is below 0.3, play D unconditionally.

**Edge Cases:**

1. **Last Round:** In the final round, play D unconditionally to maximize individual payoff, as there's no future stock to preserve.
2. **Stock Depletion:** If the stock level falls to 0 or very close to 0, play C to allow for some growth and minimize the risk of permanent depletion.

**Collective Mindset Alignment:**

1. **Maintain a Cooperative Baseline:** By playing C in initial rounds and when the stock is healthy, ACH aims to establish a cooperative atmosphere and encourage opponents to reciprocate.
2. **Adaptive Response:** ACH's probabilistic response to opponent behavior and stock levels allows for flexibility and adaptation to various game scenarios, promoting collective stability.
3. **Long-Term Focus:** By considering both individual payoffs and the overall health of the stock, ACH balances short-term gains with long-term sustainability.

**Pseudocode:**
```
function AdaptiveCooperativeHarvesting(current_stock, capacity, opponent_actions, round_number):
  // Initial rounds
  if (round_number <= 3) return COOPERATE

  // Stock-based decision making
  stock_threshold = capacity * 0.75
  if (current_stock > stock_threshold) return COOPERATE
  else if (current_stock < capacity * 0.5) return DEFECT
  else {
    probability_defect = (capacity - current_stock) / (0.5 * capacity)
    return random(probability_defect) ? DEFECT : COOPERATE
  }

  // Opponent behavior adaptation
  average_opponent_cooperation_rate = calculate_average_cooperation(opponent_actions, 5)
  if (average_opponent_cooperation_rate > 0.7) {
    cooperation_probability = 0.8 + (average_opponent_cooperation_rate - 0.7) * 0.2
    return random(cooperation_probability) ? COOPERATE : DEFECT
  } else if (average_opponent_cooperation_rate < 0.3) return DEFECT

  // Last round
  if (round_number == r) return DEFECT

  // Stock depletion
  if (current_stock <= 1) return COOPERATE
```
This strategy balances cooperation and self-interest, adapting to various game scenarios while promoting collective stability and long-term sustainability.
'''

description_COLLECTIVE_128 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and encourage others to conserve.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of the capacity, play a mixed strategy:
		+ Cooperate (C) with probability p = (current stock level / capacity)^2.
		+ Defect (D) with probability 1 - p.
	* If the current stock level is below 50% of the capacity, defect (D).
3. **Response to Opponent Actions:** Observe the opponent's actions and adjust the strategy accordingly:
	* If an opponent defects in a round, increase the likelihood of defection in the next round by reducing p.
	* If an opponent cooperates in a round, increase the likelihood of cooperation in the next round by increasing p.

**Edge Cases:**

1. **Last Round:** Cooperate (C) in the last round to maximize the total payoff, as there's no future stock growth.
2. **Low Stock Levels:** If the current stock level is critically low (< 25% of capacity), defect (D) to ensure a minimal payoff.

**Collective Mindset:**

1. **Conserve when possible:** ASC prioritizes cooperation when the stock level is high, promoting conservation and sustainability.
2. **Adapt to opponents:** By responding to opponent actions, ASC aims to balance individual payoffs with collective well-being.
3. **Prevent over-exploitation:** By defecting when the stock level is low, ASC prevents catastrophic depletion of the resource.

**Pseudocode:**

```
function AdaptiveStockConservation(current_stock, capacity, round, history):
  if round == 1:
    return C
  elif current_stock >= 0.75 * capacity:
    return C
  elif 0.5 * capacity <= current_stock < 0.75 * capacity:
    p = (current_stock / capacity)^2
    if random() < p:
      return C
    else:
      return D
  else:
    return D

  # Adjust p based on opponent actions in the previous round
  for opponent_action in history[-1]:
    if opponent_action == D:
      p -= 0.1
    elif opponent_action == C:
      p += 0.1

function ASC(current_stock, capacity, round, history):
  return AdaptiveStockConservation(current_stock, capacity, round, history)
```

This strategy balances individual payoffs with collective well-being by conserving the resource when possible and adapting to opponent behaviors. By responding to opponents' actions, ASC promotes cooperation while preventing over-exploitation of the common pool resource.
'''

description_COLLECTIVE_129 = '''
**Collective Strategy: Adaptive Cooperation with Dynamic Threshold (ACDT)**

The ACDT strategy is designed to balance individual interests with collective sustainability, adapting to changing game conditions and opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to set a positive tone and encourage cooperation.
2. **Subsequent Rounds**: Use a dynamic threshold, `τ`, to decide between C and D. Initialize `τ` as 0.5.

For each subsequent round:

a. Calculate the average stock consumption rate of all players over the past rounds (`avg_consumption_rate`).

b. Update `τ` based on the current stock level (`S`) and `avg_consumption_rate`:
```
if S < capacity * τ:
    τ *= 0.9
else if avg_consumption_rate > stock / (2n):
    τ *= 1.1
```
c. Choose action based on `τ`:

   - If the current stock level (`S`) is above `capacity * τ`, Cooperate (C).
   - Otherwise, Defect (D).

**Edge Cases:**

* **Last Round**: Always Defect (D) to maximize individual payoff in the final round.
* **Low Stock Levels**: When `S` falls below `0.2 * capacity`, always Defect (D) to avoid further depleting the stock.

**Collective Mindset Alignment:**

ACDT prioritizes cooperation when the collective resource is abundant and adapts to more individualistic behavior as the resource dwindles. By adjusting `τ` based on past consumption rates and current stock levels, ACDT aims to maintain a balance between personal interests and collective sustainability.

**Rationale:**

1. **Adaptation**: The dynamic threshold (`τ`) allows ACDT to respond to changing game conditions and opponent behaviors.
2. **Cooperation**: By cooperating when the resource is abundant, ACDT sets a positive tone and encourages others to cooperate.
3. **Robustness**: ACDT's adaptive nature makes it robust against various opponent strategies, including exploitative ones.

ACDT will participate in the tournament, aiming to achieve a high collective payoff while maintaining a balance between individual interests and sustainability.
'''

description_COLLECTIVE_130 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

AC is a dynamic, adaptive strategy that balances individual self-interest with collective well-being. It prioritizes cooperation while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1): Cooperate (C)**
Start with cooperation to set a positive tone and encourage others to follow suit.
2. **Subsequent Rounds (t>1):**
Use the following logic:

a. If the stock level is above 75% of capacity, **Cooperate (C)**.

b. If the stock level is between 50% and 75% of capacity:
   - **Defect (D)** if the previous round's total consumption was high (> 0.5 × capacity).
   - Otherwise, **Cooperate (C)**.

c. If the stock level is below 50% of capacity:
   - **Defect (D)** if you defected in the previous round or if the previous round's total consumption was low (< 0.25 × capacity).
   - Otherwise, **Cooperate (C)**.

**Edge Cases:**

* In the last round (t=r), **Defect (D)** to maximize individual payoff.
* If all players have defected in the previous round and the stock level is critically low (< 25% of capacity), **Cooperate (C)** to avoid complete depletion.

**Pseudocode (simplified):**
```
function AC(stock, capacity, t, r) {
  if t == 1 {
    return C; // Cooperate in the first round
  }

  stock_ratio = stock / capacity;

  if stock_ratio > 0.75 {
    return C; // Cooperate if stock is high
  } else if stock_ratio >= 0.5 {
    prev_total_consumption = ... // retrieve from history
    if prev_total_consumption > 0.5 * capacity {
      return D; // Defect if previous consumption was high
    }
    return C;
  } else {
    prev_defection = ... // check if you defected in the previous round
    prev_low_consumption = ... // check if previous consumption was low
    if (prev_defection || prev_low_consumption) {
      return D; // Defect if conditions are met
    }
    return C;
  }

  if t == r { // Last round
    return D; // Defect to maximize individual payoff
  }

  if stock_ratio < 0.25 && all_players_defected(prev_round) {
    return C; // Cooperate to avoid complete depletion
  }
}
```
**Collective Mindset:**

AC is designed to balance individual self-interest with collective well-being. By cooperating when the stock level is high or stable, AC encourages others to follow suit and maintains a healthy common pool resource. When the stock level is low, AC becomes more cautious and may defect to avoid complete depletion. However, if all players have defected in the previous round and the stock level is critically low, AC will cooperate to prevent total collapse.

By being adaptive and responsive to the game's state and history, AC promotes a collective mindset that prioritizes long-term sustainability over short-term gains.
'''

description_COLLECTIVE_131 = '''
To design a collective strategy for this Common Pool Resource Game, I'll introduce "Adaptive Stock Conservation" (ASC), a decision-making approach that balances individual interests with the need to conserve the common pool resource.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage others to cooperate.
2. **Stock-dependent Cooperation**: In subsequent rounds, calculate the "stock stress" metric:

   `stock_stress = (capacity - current_stock) / capacity`

   If `stock_stress` is below a certain threshold (`stress_threshold`, e.g., 0.3), Cooperate (C). This ensures that when the stock level is relatively high, players conserve it by cooperating.

   Otherwise, Defect (D).
3. **Adaptive Response to Opponent Behavior**: Monitor the actions of other players and adjust the `stress_threshold` based on their behavior:

   - If a majority (> 50%) of opponents defected in the previous round, decrease `stress_threshold` by 0.05 (e.g., from 0.3 to 0.25) for one round.
   - If a majority cooperated in the previous round, increase `stress_threshold` by 0.05 (e.g., from 0.3 to 0.35) for one round.

This adaptation allows ASC to respond to changes in opponent behavior while maintaining its core conservation-oriented approach.
4. **Last Round Exception**: In the final round, Defect (D), as there is no future stock growth or penalty for over-consumption.

**Edge Case Handling:**

- If only one player remains in the game, Cooperate (C) to ensure some payoff and maintain a positive stock level.
- In case of a tie in the number of cooperating/defecting players, follow the `stock_stress`-based decision rule.

**Collective Mindset Alignment:**

The Adaptive Stock Conservation strategy prioritizes cooperation when the common pool resource is relatively abundant, promoting collective conservation. As opponents' behavior changes, ASC adapts to balance individual interests with the need for long-term sustainability of the stock. This approach encourages mutually beneficial outcomes and fosters a cooperative atmosphere among players.

**Pseudocode (for illustration purposes):**

```python
def adaptive_stock_conservation(current_stock, capacity, stress_threshold):
    # Initial round cooperation
    if current_round == 1:
        return 'C'

    # Calculate stock stress
    stock_stress = (capacity - current_stock) / capacity

    # Stock-dependent cooperation
    if stock_stress < stress_threshold:
        return 'C'
    else:
        return 'D'

def adapt_to_opponent_behavior(opponent_actions, stress_threshold):
    majority_defected = opponent_actions.count('D') > len(opponent_actions) / 2
    majority_cooperated = opponent_actions.count('C') > len(opponent_actions) / 2

    if majority_defected:
        return stress_threshold - 0.05
    elif majority_cooperated:
        return stress_threshold + 0.05
    else:
        return stress_threshold

def main():
    # Initialize variables and parameters
    current_stock = capacity = 100
    stress_threshold = 0.3

    for round in range(1, r + 1):
        opponent_actions = []  # Assume access to opponents' actions from previous rounds
        current_round_actions = []

        if round == r:  # Last round exception
            return 'D'

        action = adaptive_stock_conservation(current_stock, capacity, stress_threshold)
        current_round_actions.append(action)

        stress_threshold = adapt_to_opponent_behavior(opponent_actions, stress_threshold)

        # Update stock level and prepare for next round
        update_stock_level()

    return None  # Game ended
```

Note: This pseudocode serves as a simplified illustration of the Adaptive Stock Conservation strategy. An actual implementation would require more detailed bookkeeping of opponent actions, game state, and other factors.
'''

description_COLLECTIVE_132 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a cooperative baseline and observe others' actions.
2. **Subsequent Rounds**: Use the following adaptive logic:
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of the capacity, defect (D) with a probability proportional to the number of defectors in the previous round.
	* If the current stock level is below 50% of the capacity, defect (D) to maximize individual payoff.
3. **Last Round**: Defect (D) to maximize individual payoff, as there are no future rounds to consider.

**Edge Cases:**

1. **First Round with Low Initial Stock**: If the initial stock level is below 50% of the capacity, defect (D) in the first round to maximize individual payoff.
2. **Consecutive Defections**: If all players defected in the previous round, cooperate (C) in the current round to attempt to revive the stock.

**Collective Mindset:**

The ASP strategy prioritizes collective well-being by:

1. Cooperating when the stock level is high to maintain a sustainable resource.
2. Adapting to opponents' behaviors by defecting with a probability proportional to the number of defectors in the previous round, which discourages excessive defection.
3. Defecting when the stock level is low to maximize individual payoff and minimize losses.

**Pseudocode:**
```markdown
function ASP(n, r, capacity, current_stock, history) {
  // Initial Round
  if (round == 1) {
    return COOPERATE;
  }

  // Subsequent Rounds
  if (current_stock >= 0.75 * capacity) {
    return COOPERATE;
  } else if (current_stock >= 0.5 * capacity) {
    // Defect with probability proportional to number of defectors in previous round
    num_defectors = countDefectors(history[round - 1]);
    defect_prob = num_defectors / n;
    return random() < defect_prob ? DEFECT : COOPERATE;
  } else {
    return DEFECT;
  }

  // Last Round
  if (round == r) {
    return DEFECT;
  }
}
```
The ASP strategy balances individual and collective interests, making it a robust and adaptive approach for the Common Pool Resource Game.
'''

description_COLLECTIVE_133 = '''
Here is a collective strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a cooperative tone and observe others' actions.
2. **General Rule**: If the current stock level is above 75% of capacity, cooperate (C). Otherwise, defect (D).
3. **Reaction to Defection**: If more than half of the players defected in the previous round, defect (D) in the next round.
4. **Conservation Threshold**: If the current stock level falls below 25% of capacity, cooperate (C) to prevent depletion.

**Pseudocode:**
```python
def ACC(n, r, capacity, history):
    if round == 1:
        return C  # Initial cooperation

    stock_level = current_stock / capacity
    prev_defections = sum(1 for action in history[-1] if action == D)

    if stock_level > 0.75:
        return C  # Cooperate when stock is high
    elif prev_defections > n/2:
        return D  # Defect if many defected previously
    elif stock_level < 0.25:
        return C  # Conserve when stock is low
    else:
        return D  # Default to defection

def play_round(n, r, capacity, history):
    action = ACC(n, r, capacity, history)
    if action == C:
        consume = current_stock / (2*n)
    else:
        consume = current_stock / n
    new_stock = update_stock(current_stock, consume, capacity)
    return new_stock
```
**Rationale:**

1. **Initial Cooperation**: Establish a cooperative tone and observe others' actions.
2. **General Rule**: Cooperate when the stock level is high to maintain a sustainable resource. Defect when the stock level is low to maximize individual payoff.
3. **Reaction to Defection**: Punish widespread defection by defecting in the next round, discouraging others from exploiting the resource.
4. **Conservation Threshold**: Ensure the resource does not deplete too quickly by cooperating when the stock level falls below a critical threshold.

**Collective Mindset:**

The ACC strategy is designed to balance individual self-interest with collective conservation goals. By adapting to the current state and history of the game, it aims to maintain a sustainable resource while discouraging exploitation by others. This strategy should perform well in a tournament against independent strategies, as it is robust to various opponent behaviors and does not rely on coordination mechanisms or shared norms.

**Edge Cases:**

1. **First Round**: Cooperate to establish a cooperative tone.
2. **Last Round**: Defect, as there is no future cost to over-exploitation.
3. **Low Stock Levels**: Conserve by cooperating when the stock level falls below 25% of capacity.

This strategy should be implemented and tested in a simulated tournament environment to evaluate its performance against other AI strategies.
'''

description_COLLECTIVE_134 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. This approach prioritizes cooperation when the stock is healthy and switches to defection when the stock is depleted.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Stock Assessment**: Evaluate the current stock level (S) relative to the capacity:
	* If S ≥ 0.75 \* capacity, cooperate (C).
	* If 0.25 \* capacity ≤ S < 0.75 \* capacity, defect (D) with probability p = (1 - S/capacity), and cooperate (C) otherwise.
	* If S < 0.25 \* capacity, defect (D).
3. **History-Based Adjustment**: Observe the previous round's total consumption (TC) and adjust the decision:
	* If TC > 0.5 \* capacity, increase the probability of cooperating (C) by 10% for the next round.
	* If TC ≤ 0.5 \* capacity, decrease the probability of cooperating (C) by 10% for the next round.
4. **Last Round**: Defect (D) in the last round to maximize individual payoff.

**Pseudocode:**
```python
def ASC(strategy_history, current_stock, capacity):
    # Initial Round
    if len(strategy_history) == 0:
        return 'C'

    # Stock Assessment
    stock_ratio = current_stock / capacity
    if stock_ratio >= 0.75:
        return 'C'
    elif stock_ratio < 0.25:
        return 'D'
    else:
        p_defect = (1 - stock_ratio)
        return 'D' if random.random() < p_defect else 'C'

    # History-Based Adjustment
    previous_consumption = sum(strategy_history[-1]['consumptions'])
    if previous_consumption > 0.5 * capacity:
        cooperate_prob += 0.1
    elif previous_consumption <= 0.5 * capacity:
        cooperate_prob -= 0.1

    return 'C' if random.random() < cooperate_prob else 'D'

def ASC_last_round(strategy_history, current_stock, capacity):
    return 'D'
```
**Collective Mindset:**

The ASC strategy aligns with the collective mindset by:

1. Prioritizing cooperation when the stock is healthy to maintain a sustainable resource.
2. Adapting to opponents' behaviors through history-based adjustments.
3. Avoiding over-exploitation of the resource in the final round.

By implementing this strategy, we aim to achieve a balance between individual payoffs and collective sustainability, while being robust to various opponent behaviors.
'''

description_COLLECTIVE_135 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

**Decision Rules:**

1. **Initial Rounds**: In the first round, play Cooperate (C) to establish a baseline for stock growth and observe opponents' behaviors.
2. **Stock Thresholds**: Monitor the current stock level (S). If S ≥ 0.75 \* capacity, play C; if 0.25 \* capacity ≤ S < 0.75 \* capacity, play D with probability 0.5; if S < 0.25 \* capacity, play D.
3. **Opponent Behavior Analysis**: Track the frequency of cooperation (FC) and defection (FD) among all opponents over the past 2 rounds. If FC ≥ FD + 1, play C; otherwise, play D.
4. **Recent Stock Trends**: Calculate the average stock growth/decline over the last 2 rounds. If the trend is positive (> 0), play C; if negative (< 0), play D.

**Edge Cases:**

* **Last Round**: Play D to maximize personal payoff, as the game ends after this round.
* **Consecutive Defections**: If all opponents defected in the previous round, play D to avoid being exploited.
* **Stock Exhaustion**: If the stock level falls below 0.1 \* capacity, play D to ensure some personal payoff.

**Collective Mindset:**

The ASP strategy prioritizes preserving the common pool resource while adapting to various opponent behaviors. By playing C when the stock is healthy and cooperating with others who demonstrate cooperative tendencies, ASP promotes a collective approach that benefits all players in the long run.

**Pseudocode (simplified):**
```
Function AdaptiveStockPreservation(current_stock, capacity, num_players, round_number):
  if round_number == 1:
    return COOPERATE
  end

  stock_threshold = 0.75 * capacity
  mid_threshold = 0.25 * capacity

  if current_stock >= stock_threshold:
    return COOPERATE
  elseif current_stock < mid_threshold:
    return DEFECT
  else:
    # Analyze opponent behavior and recent stock trends
    fc, fd = analyze_opponent_behavior()
    trend = calculate_recent_stock_trend()

    if fc >= fd + 1 or trend > 0:
      return COOPERATE
    else:
      return DEFECT
    end
  end

  # Edge cases
  if round_number == total_rounds:
    return DEFECT
  elseif consecutive_defections():
    return DEFECT
  elseif stock_exhausted(current_stock, capacity):
    return DEFECT
  end
end
```
This strategy balances individual self-interest with collective considerations, adapting to various game states and opponent behaviors. Its robustness will be tested in the tournament against other AI systems.
'''

description_COLLECTIVE_136 = '''
**Collective Strategy: Adaptive Cooperation with Stock-based Threshold (ACS-ST)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' actions.
2. **Subsequent Rounds:** Calculate the stock-to-capacity ratio, `S_ratio = current_stock / capacity`.
3. **Cooperation Threshold:** Set a dynamic cooperation threshold, `CT`, based on the game's history:
	* If `S_ratio > 0.75`, set `CT = 0.6` (cooperate if most opponents cooperated in previous rounds).
	* If `S_ratio <= 0.75`, set `CT = 0.4` (cooperate if some opponents cooperated, but stock is relatively low).
4. **Opponent Cooperation Ratio:** Calculate the opponent cooperation ratio, `OCR`, as the proportion of opponents who cooperated in the previous round.
5. **Decision Logic:**
	* If `OCR >= CT`, cooperate (C).
	* Otherwise, defect (D).

**Pseudocode:**
```markdown
ACS-ST Strategy

Initialize:
  - current_stock = capacity
  - opponent_actions = [None] * n (opponent indices)
  - OCR_history = []

For each round t:
  1. If t == 1:
     - action[t] = C (cooperate in the first round)
  Else:
     - Calculate S_ratio = current_stock / capacity
     - Determine CT based on S_ratio (see above)
     - Calculate OCR from opponent_actions[t-1]
     - If OCR >= CT:
        - action[t] = C
     - Else:
        - action[t] = D

  2. Update current_stock based on all players' actions
  3. Store opponent actions in opponent_actions[t]

Return action[t]
```
**Handling Edge Cases:**

* **Last Round:** Cooperate (C) in the last round, as there is no incentive to defect when the game ends.
* **Low Stock:** If `current_stock` falls below a certain threshold (e.g., 10% of capacity), cooperate (C) to prevent stock depletion and encourage opponents to do the same.

**Collective Mindset:**

ACS-ST aims to balance individual payoffs with collective sustainability. By cooperating when most opponents cooperate, we maintain a healthy stock level and create an environment where cooperation is beneficial for all players. When the stock-to-capacity ratio drops, our strategy becomes more cautious, prioritizing cooperation to prevent depletion.

**Robustness:**

ACS-ST adapts to various opponent behaviors by:

* Cooperating in the first round to establish a cooperative tone.
* Adjusting the cooperation threshold based on the game's history and current stock level.
* Using OCR to assess opponents' willingness to cooperate.

This strategy should perform well against independent AI systems with diverse behavior profiles.
'''

description_COLLECTIVE_137 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock Conservation (ATTC)**

The ATTC strategy is designed to balance individual payoffs with collective sustainability of the common pool resource. It combines elements of tit-for-tat and adaptive strategies to respond to various opponent behaviors while conserving the stock.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and observe opponents' initial actions.
2. **Subsequent Rounds:**
	* If the stock level is above 75% of capacity, play C if most players (>50%) cooperated in the previous round; otherwise, play D.
	* If the stock level is between 50% and 75% of capacity, play C if at least one player defected in the previous round; otherwise, play D.
	* If the stock level is below 50% of capacity, play D to maximize individual payoffs while minimizing further depletion.
3. **Opponent Behavior Adaptation:**
	* Monitor the number of players who cooperate and defect in each round.
	* Adjust the cooperation threshold (currently set at >50%) based on the observed opponent behavior:
		+ If most players (>75%) cooperate, increase the threshold to 60%.
		+ If most players (<25%) cooperate, decrease the threshold to 40%.

**Edge Cases:**

1. **Last Round:** Play D in the last round to maximize individual payoffs since there are no future consequences.
2. **Tied Stock Levels:** In cases where multiple opponents have the same stock level, prioritize cooperation if the opponent's previous action was cooperative.

**Collective Mindset Alignment:**

The ATTC strategy is designed to balance individual self-interest with collective sustainability by:

1. Encouraging cooperation when possible to maintain a healthy stock level.
2. Adapting to opponent behavior to minimize the impact of defections.
3. Prioritizing conservation of the stock when levels are low.

**Pseudocode:**
```python
def ATTC(n, capacity, stock, history):
    if round == 1:
        return C  # Initial cooperative tone

    most_cooperated = False
    threshold = 0.5  # default cooperation threshold

    for opponent in history[-1]:
        if opponent.action == C:
            most_cooperated += 1

    if stock > 0.75 * capacity:
        if most_cooperated > n / 2:
            return C
        else:
            return D
    elif stock >= 0.5 * capacity and stock < 0.75 * capacity:
        if any(opponent.action == D for opponent in history[-1]):
            return C
        else:
            return D
    else:  # stock < 0.5 * capacity
        return D

    # Adapt threshold based on observed behavior
    cooperation_rate = sum(1 for opponent in history[-1] if opponent.action == C) / n
    if cooperation_rate > 0.75:
        threshold += 0.1
    elif cooperation_rate < 0.25:
        threshold -= 0.1

    return C if most_cooperated > threshold * n else D
```
This strategy will be further refined and implemented as an algorithm for the tournament.
'''

description_COLLECTIVE_138 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold**

Our collective strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and historical behavior.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if the initial stock is above 75% of capacity; otherwise, Defect (D).
2. **Subsequent Rounds (t>1):**
	* Calculate the average stock level over the past `k` rounds (`k` = min(5, t-1)).
	* If the average stock level is:
		+ Above 67% of capacity: Cooperate (C) with probability `p_C = 0.8`.
		+ Between 33% and 67% of capacity: Cooperate (C) with probability `p_C = 0.5`.
		+ Below 33% of capacity: Defect (D).
3. **Last Round (t=r):**
	* Defect (D), as there is no future sustainability concern.

**Edge Case Handling:**

1. If the stock level drops to zero, defect in all subsequent rounds.
2. If a player has defected for `m` consecutive rounds (`m` = 3), temporarily switch to cooperate with probability `p_C = 0.8` for the next round to test opponent behavior.

**Pseudocode:**
```markdown
function adaptive_cooperation(current_stock, capacity, history, t) {
  // Initial Round (t=1)
  if (t == 1) {
    if (current_stock > 0.75 * capacity) {
      return COOPERATE;
    } else {
      return DEFECT;
    }
  }

  // Subsequent Rounds (t>1)
  avg_stock = calculate_average_stock(history, k=min(5, t-1));
  if (avg_stock >= 0.67 * capacity) {
    p_C = 0.8;
  } else if (avg_stock >= 0.33 * capacity && avg_stock < 0.67 * capacity) {
    p_C = 0.5;
  } else {
    return DEFECT;
  }
  return COOPERATE with probability p_C;

  // Last Round (t=r)
  if (t == r) {
    return DEFECT;
  }

  // Edge Case Handling
  if (current_stock == 0 || history.contains_defect_streak(m=3)) {
    // Handle edge cases here...
  }
}
```
This strategy is designed to be adaptive and robust, responding to changes in the stock level and opponent behavior while promoting collective sustainability. By cooperating when the stock level is high and defecting when it's low, we aim to balance individual payoffs with the need for long-term resource conservation.
'''

description_COLLECTIVE_139 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and game states:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with probability 0.8, Defect (D) with probability 0.2. This initial cooperation rate encourages others to cooperate while allowing for some exploration.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, Cooperate (C).
	* If the stock level is between 50% and 75% of capacity, play a mixed strategy:
		+ Cooperate (C) with probability proportional to the number of cooperators in the previous round.
		+ Defect (D) with probability proportional to the number of defectors in the previous round.
	* If the stock level is below 50% of capacity, Defect (D).
3. **Punishment Mechanism:** If a player observes another player defecting while their own payoff from cooperation would have been higher, they will Defect (D) with probability 0.5 in the next round.
4. **Learning and Adaptation:** After each round, update the cooperation probability based on the observed behavior of other players:
	* Increase cooperation probability by 0.1 if the number of cooperators increases.
	* Decrease cooperation probability by 0.1 if the number of defectors increases.

**Edge Cases:**

1. **Last Round (t=r):** Cooperate (C) to maximize total payoff, as there is no future round to consider.
2. **Single Opponent:** Play a mixed strategy with Cooperate (C) and Defect (D) probabilities equal to 0.5.

**Pseudocode:**
```markdown
# Initialize variables
cooperation_prob = 0.8
previous_stock_level = capacity
previous_cooperators = n

while t <= r:
  # Determine current stock level and number of cooperators/defectors
  current_stock_level = get_current_stock_level()
  num_cooperators = count_cooperators(previous_actions)

  if t == 1:
    action = random.choice([C, D], p=[cooperation_prob, 1-cooperation_prob])
  else:
    # Apply decision rules based on stock level and opponent behavior
    if current_stock_level > 0.75 * capacity:
      action = C
    elif 0.5 <= current_stock_level / capacity < 0.75:
      cooperation_prob = update_cooperation_probability(num_cooperators, previous_cooperators)
      action = random.choice([C, D], p=[cooperation_prob, 1-cooperation_prob])
    else:
      action = D

    # Punishment mechanism
    if was_punished(previous_actions):
      action = D with probability 0.5

  # Update variables for next round
  previous_stock_level = current_stock_level
  previous_cooperators = num_cooperators

  # Take action and update payoffs
  take_action(action)
  update_payoffs()

# Final payoff calculation
total_payoff = calculate_total_payoff()
```
This strategy balances individual self-interest with collective conservation, adapting to various opponent behaviors while ensuring a robust performance across different game scenarios.
'''

description_COLLECTIVE_140 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to encourage cooperation and maximize initial stock growth.
2. **Subsequent Rounds:** ASC uses a hybrid approach, combining elements of Tit-for-Tat (TFT) and a novel Stock-Dependent Strategy (SDS).

   - **Stock-Dependent Strategy (SDS):**
     * If current stock ≥ capacity/2: Cooperate (C)
     * Else if current stock < capacity/4: Defect (D)
     * Otherwise, use TFT-like behavior:
       + If most players cooperated in the previous round: Cooperate (C)
       + Else: Defect (D)

   - **TFT-like adjustment:** Adjust SDS to account for opponents' actions. If most players defected in the previous round, increase the defect threshold by 1/n (i.e., become more cautious).

3. **Last Round:** Cooperate (C) if current stock ≥ capacity/2; otherwise, Defect (D). This ensures a balanced approach in the final round.

**Edge Cases:**

* If only one player remains, ASC will always Cooperate (C) to maximize payoffs.
* In cases of ties (e.g., equal number of cooperators and defectors), ASC will follow the SDS rule based on the current stock level.

**Pseudocode (simplified):**
```python
def ASC(current_stock, capacity, history):
  if first_round:
    return C

  most_cooperated = count_cooperators(history[-1]) > n/2
  defect_threshold = capacity / 4 + (n-1) * 0.01  # adjust threshold based on TFT-like behavior

  if current_stock >= capacity / 2:
    return C
  elif current_stock < defect_threshold:
    return D
  else:
    if most_cooperated:
      return C
    else:
      return D

def ASC_last_round(current_stock, capacity):
  if current_stock >= capacity / 2:
    return C
  else:
    return D
```
**Collective Mindset:** ASC aims to balance individual payoffs with collective sustainability. By adapting to the game's state and history, it promotes cooperation when beneficial for the group while avoiding over-exploitation of the common resource.

ASC is designed to be robust against a wide range of opponent behaviors, encouraging cooperation without relying on predetermined coordination mechanisms or shared norms.
'''

description_COLLECTIVE_141 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Tit-for-Tat**

This strategy aims to balance individual self-interest with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1): Cooperate (C)** - Start with cooperation to establish a positive tone and maximize initial payoffs.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, cooperate (C).
	* If the stock level is between 50% and 75% of capacity, play tit-for-tat (TFT) based on the previous round's actions:
		+ Cooperate if most players (>= n/2) cooperated in the previous round.
		+ Defect otherwise.
	* If the stock level is below 50% of capacity, defect (D).

**Edge Cases:**

1. **Last Round (t=r): Defect (D)** - In the final round, maximize individual payoff by consuming as much as possible.
2. **Low Stock Levels:** If the stock level falls below 25% of capacity, cooperate (C) to allow for some growth and avoid depletion.

**Rationale:**

1. Cooperating in the initial round sets a positive tone and maximizes payoffs when the stock is at its highest.
2. The 75% threshold for cooperation allows for a balance between individual payoff and collective sustainability. Above this level, cooperating maintains a healthy stock while still providing decent payoffs.
3. Tit-for-tat (TFT) in the middle range encourages cooperation when most players are cooperative and deters defection when many defect.
4. Defecting below 50% capacity prioritizes individual self-interest when the collective is struggling to sustain the stock.
5. Cooperating at very low stock levels (>25%) allows for some growth, preventing complete depletion.

**Pseudocode:**
```python
def strategy(state, history):
    n = state['n']
    capacity = state['capacity']
    stock = state['stock']
    round_num = state['round_num']

    if round_num == 1:
        return 'C'  # Cooperate in the initial round

    if stock > 0.75 * capacity:
        return 'C'  # Cooperate above 75% capacity
    elif stock >= 0.5 * capacity and stock <= 0.75 * capacity:
        prev_round_coops = sum(1 for action in history[-1] if action == 'C')
        if prev_round_coops >= n / 2:
            return 'C'  # TFT: Cooperate if most cooperated last round
        else:
            return 'D'
    elif stock < 0.5 * capacity and stock > 0.25 * capacity:
        return 'D'  # Defect between 50% and 25% capacity
    else:
        return 'C'  # Cooperate at very low stock levels

    if round_num == state['r']:  # Last round
        return 'D'
```
This strategy adapts to the game's state, history, and opponent behaviors while maintaining a collective mindset. By balancing individual self-interest with cooperation, it aims to achieve a robust and sustainable outcome in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_142 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Sensitive Trigger (ACST)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' actions.
2. **Stock-Dependent Threshold:** Define a stock-dependent threshold, `T`, which determines when to switch from Cooperation to Defection:
	* If current stock (`S`) is above `capacity / 2`, set `T = capacity / (4n)`.
	* Otherwise, set `T = S / (2n)`.
3. **Trigger:** Cooperate if the total consumption in the previous round is below `T`. Defect otherwise.
4. **Adaptive Adjustment:** Update `T` every 5 rounds to reflect changes in opponents' behaviors:
	+ If average payoff over the last 5 rounds is above the initial capacity, increase `T` by 10%.
	+ Otherwise, decrease `T` by 10%.

**Pseudocode:**
```
def ACST(stock, capacity, n, history):
    if round == 1:
        return C
    T = get_threshold(stock, capacity, n)
    total_consumption_prev = sum(consumption for action in history[-1])
    if total_consumption_prev < T:
        return C
    else:
        return D

def get_threshold(stock, capacity, n):
    if stock > capacity / 2:
        return capacity / (4n)
    else:
        return stock / (2n)

def update_threshold(T, average_payoff, initial_capacity):
    if average_payoff > initial_capacity:
        T *= 1.1
    else:
        T /= 1.1
    return T
```
**Edge Cases:**

* **Last Round:** Defect in the last round to maximize payoff regardless of opponents' actions.
* **Zero Stock:** If stock is zero, defect to avoid losing opportunities for future rounds.

**Collective Mindset Alignment:**
ACST prioritizes cooperation when the common pool resource is abundant and adapts to opponents' behaviors by adjusting its threshold. This strategy encourages other players to cooperate while ensuring a robust response to defectors.

By incorporating both short-term and long-term considerations, ACST balances individual interests with collective well-being, aligning with the game's common-pool nature.
'''

description_COLLECTIVE_143 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and observe opponents' behaviors.
2. **Stock Threshold**: Define two stock thresholds:
	* `low_stock_threshold` = 0.5 \* capacity
	* `high_stock_threshold` = 0.8 \* capacity
3. **Cooperation Zone**: If the current stock level is above `high_stock_threshold`, cooperate (C) to maintain a sustainable stock level.
4. **Defection Zone**: If the current stock level is below `low_stock_threshold`, defect (D) to maximize individual payoff, as the stock level is already critically low.
5. **Adaptive Response**: When the current stock level is between `low_stock_threshold` and `high_stock_threshold`, observe the average opponent behavior in the previous round:
	* If the majority of opponents cooperated, cooperate (C) to maintain a sustainable stock level.
	* If the majority of opponents defected, defect (D) to protect individual interests.

**Pseudocode**
```python
def ASC(n, capacity, current_stock, history):
    # Initial Round
    if len(history) == 0:
        return "Cooperate"

    low_stock_threshold = 0.5 * capacity
    high_stock_threshold = 0.8 * capacity

    # Cooperation Zone
    if current_stock > high_stock_threshold:
        return "Cooperate"

    # Defection Zone
    elif current_stock < low_stock_threshold:
        return "Defect"

    # Adaptive Response
    else:
        opponent_actions = [action for action in history[-1] if action != ASC]
        majority_behavior = most_common(opponent_actions)
        if majority_behavior == "Cooperate":
            return "Cooperate"
        else:
            return "Defect"

# Helper function to find the most common element in a list
def most_common(lst):
    return max(set(lst), key=lst.count)
```
**Edge Cases**

* **Last Round**: In the last round, defect (D) to maximize individual payoff, as there are no future rounds to consider.
* **Tie-Breaking**: In case of a tie in opponent behaviors, cooperate (C) to maintain a sustainable stock level.

**Collective Mindset**

The ASC strategy prioritizes collective sustainability by cooperating when the stock level is high and adapting to opponents' behaviors when the stock level is moderate. By doing so, it aims to maintain a stable stock level, ensuring a fair distribution of payoffs among players while protecting individual interests in critical situations.
'''

description_COLLECTIVE_144 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACS)**

ACS is a dynamic, history-dependent strategy that balances individual payoff maximization with collective sustainability. It adapts to the current stock level, opponent behavior, and game progress.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoffs.
2. **Stock-Based Threshold**: Calculate a threshold value `stock_threshold` based on the current stock level (`S`) and capacity (`C`):

`stock_threshold = C * (n - 1) / (2n)`

If `S` is above `stock_threshold`, Cooperate (C). Otherwise, Defect (D).
3. **Opponent Behavior Adaptation**: Monitor opponents' actions in previous rounds. If the number of defections (`defections`) exceeds a threshold (`defection_threshold = n/2`), adjust the strategy to:

`if (S > stock_threshold && defections <= defection_threshold) { Cooperate } else { Defect }`
4. **Endgame Strategy**: In the last round, Cooperate (C) if `S` is above `stock_threshold`. Otherwise, Defect (D).

**Pseudocode**
```markdown
function ACS(n, C, S, history):
  // Initial Round
  if (round == 1):
    return Cooperate

  // Stock-Based Threshold
  stock_threshold = C * (n - 1) / (2n)
  if (S > stock_threshold):
    cooperation_tendency = True
  else:
    cooperation_tendency = False

  // Opponent Behavior Adaptation
  defections = count(defections in history)
  if (defections > n/2):
    cooperation_tendency = False

  // Endgame Strategy
  if (round == r):
    if (S > stock_threshold):
      return Cooperate
    else:
      return Defect

  // Final Decision
  if (cooperation_tendency):
    return Cooperate
  else:
    return Defect
```
**Collective Mindset**

ACS prioritizes cooperation when the stock level is high, promoting collective sustainability. By adapting to opponent behavior, it balances individual payoff maximization with the need for cooperation. In the endgame, ACS reverts to a cooperative stance if the stock level permits, ensuring a fair outcome.

This strategy is designed to perform well in a tournament setting, as it:

1. Encourages cooperation without being overly trusting.
2. Adapts to opponent behavior, making it robust against various strategies.
3. Prioritizes collective sustainability while maximizing individual payoffs.

By following ACS, players can contribute to a mutually beneficial outcome while minimizing the risk of exploitation.
'''

description_COLLECTIVE_145 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Tit-for-Tat (ASDT)**

**Overview**
The ASDT strategy aims to balance cooperation and defection based on the current stock level, previous rounds' outcomes, and opponents' behavior. This adaptive approach allows for flexibility in response to changing circumstances while maintaining a collective mindset.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and observe opponents' initial actions.
2. **Stock-Dependent Cooperation**: If the current stock level is above a threshold (`stock_threshold` = `capacity` / 2), cooperate (C). This ensures that when the stock is plentiful, players contribute to its growth and avoid over-exploitation.
3. **Tit-for-Tat with Opponent Behavior**: For each opponent, track their previous action (C or D). If an opponent defected (D) in the previous round, defect (D) in response. This component encourages opponents to cooperate by mirroring their behavior.
4. **Adaptive Defection**: If the current stock level is below `stock_threshold` and at least one opponent defected in the previous round, defect (D). This adjusts the strategy to prioritize self-interest when the stock is scarce or opponents are not cooperating.
5. **Stock Recovery**: If the stock level has increased since the previous round, cooperate (C) to support continued growth.

**Pseudocode**
```markdown
def ASDT(n, capacity, current_stock, opponent_actions):
  if first_round:
    return C

  stock_threshold = capacity / 2

  if current_stock >= stock_threshold:
    return C

  for opponent in opponents:
    if opponent_actions[opponent] == D:
      return D

  if current_stock < stock_threshold and any(opponent_actions[opponent] == D for opponent in opponents):
    return D

  if current_stock > previous_stock:
    return C

  # Default to cooperation
  return C
```
**Edge Cases**

* **Last Round**: In the final round, prioritize self-interest by defecting (D) regardless of the stock level or opponents' actions.
* **Ties in Opponent Actions**: If multiple opponents have defected in the previous round, prioritize the one that defected most recently.

**Collective Mindset**
The ASDT strategy aligns with a collective mindset by:

1. Cooperating when the stock is plentiful to ensure its growth and sustainability.
2. Responding to opponents' actions with tit-for-tat behavior, encouraging cooperation and mutual benefit.
3. Adapting to changing circumstances, such as stock scarcity or opponent defection, while maintaining a balance between self-interest and collective well-being.

By implementing ASDT, players can foster a cooperative environment while remaining robust to a wide range of opponent behaviors and game conditions.
'''

description_COLLECTIVE_146 = '''
**Collective Strategy: Adaptive Cooperation with Stock Threshold (ACST)**

The ACST strategy aims to balance individual payoff maximization with collective sustainability by adapting cooperation levels based on the current stock level and game history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and avoid initial stock depletion.
2. **Stock Threshold:** Define a dynamic stock threshold, `stock_threshold = capacity * (1 - 1/n)`, where `n` is the number of players. If the current stock level (`S`) is above this threshold, cooperate (C). Otherwise, defect (D).
3. **Cooperation Probability:** Introduce a cooperation probability (`p_c`) that adjusts based on the opponent's behavior. Initialize `p_c = 0.5`. After each round, update `p_c` as follows:
	* If all opponents cooperated in the previous round, increase `p_c` by 10% (up to a maximum of 1).
	* If any opponent defected in the previous round, decrease `p_c` by 10% (down to a minimum of 0).
4. **Mixed Strategy:** In each round, play Cooperate (C) with probability `p_c` and Defect (D) with probability `(1 - p_c)`.

**Edge Cases:**

* **Last Round:** Always cooperate (C) in the last round (`r`) to maximize collective payoff.
* **Low Stock:** If the current stock level (`S`) is below 10% of the capacity, always defect (D) to ensure some individual payoff.
* **No Opponent History:** In the absence of opponent history (e.g., first round), use a default cooperation probability `p_c = 0.5`.

**Collective Mindset:**

The ACST strategy prioritizes collective sustainability while adapting to the actions of other players. By cooperating when the stock level is above the threshold, we aim to maintain a healthy stock for future rounds. The dynamic cooperation probability allows us to respond to opponent behavior and adjust our strategy accordingly.

**Pseudocode:**
```python
def ACST(n, capacity, r, S_history):
    p_c = 0.5
    stock_threshold = capacity * (1 - 1/n)

    for t in range(r):
        if t == 0:
            # Initial round: Cooperate
            action = C
        elif S_history[t-1] < stock_threshold:
            # Stock below threshold: Defect
            action = D
        else:
            # Mixed strategy based on cooperation probability
            action = random_choice([C, D], [p_c, 1-p_c])

        if t > 0:
            # Update cooperation probability based on opponent behavior
            if all(opponent_actions[t-1]):
                p_c = min(1, p_c + 0.1)
            else:
                p_c = max(0, p_c - 0.1)

        # Last round: Cooperate
        if t == r - 1:
            action = C

        yield action
```
This strategy is designed to be adaptive and robust in the face of various opponent behaviors, while prioritizing collective sustainability and individual payoff maximization.
'''

description_COLLECTIVE_147 = '''
I propose a collective strategy called "Adaptive Collective Harvesting" (ACH) for the Common Pool Resource Game. ACH is designed to balance individual payoffs with collective sustainability, adapting to various opponent behaviors and game states.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Stock-based Cooperation:** If the current stock level is above 75% of capacity, cooperate (C). This ensures sustainable harvesting and maintains a healthy stock level.
3. **Defection Threshold:** If the current stock level falls below 25% of capacity, defect (D) to maximize individual payoffs in a depleted environment.
4. **Adaptive Response:** Monitor the average payoff of opponents from previous rounds. If the average opponent payoff is higher than your own, cooperate (C) in the next round to signal cooperation and potentially increase collective payoffs. Otherwise, defect (D).
5. **History-based Adjustment:** Track the total consumption and stock growth over the past few rounds (e.g., 3-5 rounds). If the trend indicates excessive depletion, adjust your strategy to cooperate more frequently.

**Pseudocode:**
```markdown
# Initialize variables
stock_threshold_high = 0.75 * capacity
stock_threshold_low = 0.25 * capacity
opponent_payoff_average = 0
total_consumption_history = []
stock_growth_history = []

# Main decision loop
for round in range(r):
    # Initial round cooperation
    if round == 0:
        action = C
    
    # Stock-based cooperation
    elif stock >= stock_threshold_high:
        action = C
    
    # Defection threshold
    elif stock <= stock_threshold_low:
        action = D
    
    # Adaptive response to opponents
    else:
        opponent_payoff_average = calculate_opponent_payoff_average()
        if opponent_payoff_average > my_payoff:
            action = C
        else:
            action = D
    
    # History-based adjustment
    total_consumption_history.append(total_consumption)
    stock_growth_history.append(stock_growth)
    if len(total_consumption_history) >= 3 and sum(total_consumption_history[-3:]) > 0.5 * capacity:
        cooperation_frequency += 0.1
    
    # Update state variables
    update_stock()
    update_payoffs()
```
**Collective Mindset:**
The ACH strategy prioritizes collective sustainability by cooperating when the stock level is high and adapting to opponent behaviors to maintain a healthy stock level. By responding to the average payoff of opponents, ACH encourages cooperation and mutual benefit. The history-based adjustment mechanism helps prevent over-depletion and promotes long-term thinking.

**Edge Cases:**

* In the last round, defect (D) to maximize individual payoffs.
* If all players cooperate in a round, maintain cooperation in the next round to reinforce collective behavior.

This strategy is designed to be robust against various opponent behaviors and game states, while prioritizing collective sustainability and adaptability.
'''

description_COLLECTIVE_148 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Stock-based Cooperation:** If the current stock level is above 75% of capacity, cooperate (C). This ensures that when the stock is abundant, players conserve it for future rounds.
3. **Defection Threshold:** If the current stock level falls below 25% of capacity, defect (D) to maximize individual payoff in the face of scarcity.
4. **Adaptive Defection:** When the stock level is between 25% and 75% of capacity, use a dynamic threshold based on the history of opponent actions:
	* Calculate the average opponent cooperation rate (OCR) over the last `r/2` rounds.
	* If OCR < 0.5 (i.e., opponents have defected frequently), defect (D).
	* Otherwise, cooperate (C).
5. **Last Round:** Defect (D) in the final round to maximize individual payoff.

**Pseudocode:**
```python
def ASC(n, capacity, stock_history, opponent_actions):
  # Initial round
  if len(stock_history) == 0:
    return 'C'

  current_stock = stock_history[-1]
  threshold_high = 0.75 * capacity
  threshold_low = 0.25 * capacity

  # Stock-based cooperation
  if current_stock > threshold_high:
    return 'C'

  # Defection threshold
  elif current_stock < threshold_low:
    return 'D'

  # Adaptive defection
  else:
    OCR_window = len(stock_history) // 2
    opponent_actions_window = opponent_actions[-OCR_window:]
    average_OCR = sum(opponent_actions_window) / len(opponent_actions_window)

    if average_OCR < 0.5:
      return 'D'
    else:
      return 'C'

  # Last round
  if len(stock_history) == r - 1:
    return 'D'
```
**Collective Mindset:**

The ASC strategy prioritizes collective sustainability while adapting to individual self-interest. By conserving the stock when it's abundant and responding to opponent actions, ASC promotes a balanced approach that benefits both individual players and the group as a whole.

In the tournament setting, ASC will face various independent strategies. While it cannot rely on explicit coordination or shared norms, its adaptive nature allows it to respond effectively to different opponent behaviors, increasing its chances of success in the collective pool resource game.
'''

description_COLLECTIVE_149 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) with probability 0.5. This allows us to test the waters and gather information about other players' behaviors.
2. **Subsequent Rounds:** Use a tit-for-tat approach, but with an adaptive twist:
	* If the stock level is above 75% of capacity, cooperate (C) if at least half of the players cooperated in the previous round; otherwise, defect (D).
	* If the stock level is between 50% and 75% of capacity, cooperate (C) if at least two-thirds of the players cooperated in the previous round; otherwise, defect (D).
	* If the stock level is below 50% of capacity, always defect (D).

**Edge Cases:**

1. **Last Round:** Defect (D). There's no need to cooperate when there are no future rounds to consider.
2. **Low Stock Levels:** When the stock level falls below 25% of capacity, switch to an "emergency" mode and always defect (D) until the stock recovers.

**Collective Mindset:**

Our strategy prioritizes cooperation when possible, but adaptively responds to the actions of others and the state of the game. By cooperating when most players do so, we promote a collective good. When others defect or the stock is low, we adjust our behavior to minimize losses and protect our own interests.

**Pseudocode:**
```python
def adaptive_cooperation(current_stock, capacity, previous_round_actions):
  if current_round == 1:
    return random.choice([C, D])  # Initial round

  cooperation_threshold = 0.5
  if current_stock > 0.75 * capacity:
    cooperation_threshold = len([a for a in previous_round_actions if a == C]) / len(previous_round_actions)
    return C if cooperation_threshold >= 0.5 else D
  elif current_stock > 0.5 * capacity:
    cooperation_threshold = len([a for a in previous_round_actions if a == C]) / len(previous_round_actions)
    return C if cooperation_threshold >= 2/3 else D
  else:
    return D

def emergency_mode(current_stock, capacity):
  if current_stock < 0.25 * capacity:
    return D

def decide_action(current_stock, capacity, previous_round_actions):
  action = adaptive_cooperation(current_stock, capacity, previous_round_actions)
  if emergency_mode(current_stock, capacity) == D:
    return D
  return action
```
This strategy balances individual self-interest with collective well-being, adapting to the dynamics of the game. By responding to the actions of others and the state of the stock, AC promotes a stable and cooperative outcome whenever possible.
'''

description_COLLECTIVE_150 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and aligns with the collective mindset:

**Strategy Name:** Adaptive Cooperation (AC)

**Decision Rules:**

1. **First Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe other players' actions.
2. **Subsequent Rounds**: Use the following logic:
	* If the current stock is above 75% of capacity, cooperate (C).
	* If the current stock is between 25% and 75% of capacity, play a mixed strategy: cooperate (C) with probability p = (current_stock / capacity)^2, and defect (D) otherwise.
	* If the current stock is below 25% of capacity, defect (D).

The mixed strategy in the middle range allows AC to adapt to varying levels of cooperation from other players. As the stock level increases, AC becomes more likely to cooperate.

3. **Last Round**: Cooperate (C) in the last round, regardless of the current stock level. This ensures that AC contributes to the collective well-being even when the game is about to end.

**Additional Logic:**

* **Stock Growth Monitoring**: Track the growth rate of the stock over time. If the growth rate is consistently negative or stagnant, increase the probability of defecting (D) in subsequent rounds.
* **Opponent Behavior Analysis**: Monitor the actions of other players and adjust AC's behavior accordingly:
	+ If most opponents cooperate (C), AC will also cooperate more frequently.
	+ If most opponents defect (D), AC will adapt by defecting more often.

**Pseudocode:**
```
function adaptive_cooperation(current_stock, capacity, round_number, opponent_actions):
  if round_number == 1:
    return COOPERATE
  elif current_stock >= 0.75 * capacity:
    return COOPERATE
  elif 0.25 * capacity <= current_stock < 0.75 * capacity:
    p = (current_stock / capacity)^2
    return random_choice(COOPERATE, DEFECT, p)
  else:  # current_stock < 0.25 * capacity
    return DEFECT

  if round_number == total_rounds:
    return COOPERATE

  # Additional logic for stock growth monitoring and opponent behavior analysis
  ...
```
**Collective Mindset Alignment:** AC prioritizes cooperation when the stock level is high, ensuring that all players can benefit from the collective resource. By adapting to various opponent behaviors, AC promotes a balance between individual self-interest and collective well-being.

This strategy should perform well in a tournament setting against independent strategies developed by other AI systems, as it:

* Adapts to changing circumstances (stock level, opponent behavior)
* Balances cooperation and self-interest
* Prioritizes collective well-being when possible
'''

description_COLLECTIVE_151 = '''
**Collective Strategy: Adaptive Cooperativity with Stock-Sensitive Defection (ACSSD)**

The ACSSD strategy balances cooperation and defection based on the game's state and history to achieve a collective optimum.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoffs.
2. **Stock-Above-Threshold:** If the current stock is above 75% of capacity, cooperate (C). This encourages sustainable consumption when resources are plentiful.
3. **Recent Defection Dominance:** Monitor the last 3 rounds' actions. If defection (D) has been more frequent than cooperation, defect (D) in the next round to adjust to the prevailing behavior.
4. **Payoff-Weighted Cooperation:** Calculate a weighted average of payoffs from previous rounds (with higher weights for more recent rounds). If this average is above 50% of capacity/n, cooperate (C); otherwise, defect (D).
5. **Low Stock:** When the current stock falls below 25% of capacity, defect (D) to maximize individual payoffs in a depleted environment.

**Pseudocode:**
```python
def ACSSD(stock, history, round_num):
    # Initial Round
    if round_num == 1:
        return 'C'

    # Stock-Above-Threshold
    threshold = capacity * 0.75
    if stock >= threshold:
        return 'C'

    # Recent Defection Dominance
    recent_defections = sum(1 for action in history[-3:] if action == 'D')
    recent_cooperations = len(history[-3:]) - recent_defections
    if recent_defections > recent_cooperations:
        return 'D'

    # Payoff-Weighted Cooperation
    weighted_payoffs = [payoff * (1 / (i + 1)) for i, payoff in enumerate(history)]
    avg_payoff = sum(weighted_payoffs) / len(weighted_payoffs)
    if avg_payoff > capacity / (2 * n):
        return 'C'

    # Low Stock
    low_stock_threshold = capacity * 0.25
    if stock < low_stock_threshold:
        return 'D'

    # Default: Cooperate
    return 'C'
```
**Edge Cases:**

* In the last round, ACSSD will follow the decision rules above, but with a slight bias towards defection (D) to maximize individual payoffs.
* If multiple players use ACSSD, they may still encounter situations where cooperation or defection is suboptimal. However, by adapting to the game's state and history, ACSSD aims to minimize such occurrences.

**Collective Mindset:**
ACSSD prioritizes cooperation when resources are plentiful and defects when the environment is depleted or dominated by defectors. This approach encourages sustainable consumption while allowing for adaptability in response to changing circumstances. By balancing individual interests with collective well-being, ACSSD promotes a robust and resilient strategy that can thrive in a wide range of scenarios.
'''

description_COLLECTIVE_152 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Overview**

The ASC strategy prioritizes collective stock conservation while being adaptive to opponent behaviors and robust to a wide range of scenarios.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoffs.
2. **Subsequent Rounds**: Observe the previous round's actions and payoffs. If:
	* The stock level has increased or remained stable, cooperate (C).
	* The stock level has decreased significantly (> 20% of capacity), defect (D) to secure a higher payoff.
3. **Threshold-based Cooperation**: Monitor the average opponent cooperation rate over the last few rounds (e.g., 5 rounds). If the average cooperation rate is above a certain threshold (e.g., 0.6), cooperate (C).
4. **Stock-based Defection**: When the stock level falls below a critical threshold (e.g., 30% of capacity), defect (D) to secure a higher payoff.

**Edge Case Handling**

1. **Last Round**: Cooperate (C) in the final round, as there is no future benefit from defecting.
2. **Extremely Low Stock**: If the stock level falls below 10% of capacity, always cooperate (C) to prevent stock depletion and ensure some payoff.

**Collective Mindset Alignment**

1. **Cooperation Bonus**: When multiple players cooperate in a round, increase the cooperation threshold for subsequent rounds by a small margin (e.g., +0.05).
2. **Defection Penalty**: When multiple players defect in a round, decrease the cooperation threshold for subsequent rounds by a small margin (e.g., -0.05).

**Pseudocode**

```
function ASCStrategy(current_round, stock_level, opponent_actions, capacity):
  // Initialize variables
  cooperate_threshold = 0.6
  critical_stock_threshold = 0.3 * capacity

  if current_round == 1:
    return COOPERATE

  // Analyze previous round's actions and payoffs
  avg_opponent_cooperation_rate = calculate_average_cooperation_rate(opponent_actions)
  stock_change = stock_level - get_previous_stock_level()

  if stock_change > 0 or stock_change == 0:
    return COOPERATE
  elif stock_change < -0.2 * capacity:
    return DEFECT

  // Threshold-based cooperation
  if avg_opponent_cooperation_rate > cooperate_threshold:
    return COOPERATE
  else:
    return DEFECT

  // Stock-based defection
  if stock_level < critical_stock_threshold:
    return DEFECT

  // Last round handling
  if current_round == total_rounds:
    return COOPERATE

  // Extremely low stock handling
  if stock_level < 0.1 * capacity:
    return COOPERATE

function calculate_average_cooperation_rate(opponent_actions):
  // Calculate average cooperation rate over the last few rounds (e.g., 5 rounds)
  ...

function get_previous_stock_level():
  // Retrieve previous round's stock level
  ...
```

**Notes**

* The `calculate_average_cooperation_rate` and `get_previous_stock_level` functions are not implemented in this pseudocode, as their implementation details depend on the specific game environment.
* The ASC strategy can be fine-tuned by adjusting parameters such as cooperation thresholds, critical stock levels, and opponent action analysis windows.

The Adaptive Stock Conservation (ASC) strategy is designed to balance collective stock conservation with individual payoff maximization. By adapting to opponent behaviors and being robust to various scenarios, ASC aims to perform well in a tournament setting against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_153 = '''
Here's a collective strategy for the Common Pool Resource Game that meets the requirements:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline of cooperation and observe opponents' behaviors.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play a mixed strategy:
		+ Cooperate (C) with probability p = (stock/capacity)^2
		+ Defect (D) with probability 1 - p
	* If the current stock level is below 50% of capacity, Defect (D)
3. **Final Round (t=r):** Cooperate (C) to avoid depleting the resource entirely

**Additional Rules:**

* **Observation and Adaptation:** Track the opponents' cooperation rates over the last 5 rounds. If more than half of the opponents have defected in the last 5 rounds, increase the probability of defecting (D) by 20% in the next round.
* **Punishment Mechanism:** If an opponent defects while the current stock level is below 25% of capacity, punish them by defecting (D) for the next 2 rounds.

**Collective Mindset:**

The ACC strategy prioritizes cooperation when the resource is abundant and adapts to more selfish behavior as the resource becomes scarce. By cooperating initially, we encourage opponents to do the same and establish a social norm of cooperation. As the game progresses, our mixed strategy allows us to balance individual interests with collective conservation goals.

**Edge Cases:**

* If there's only one opponent, play Cooperate (C) in all rounds.
* If multiple opponents defect simultaneously, prioritize punishing them over cooperating.

Pseudocode:
```
function ACC(n, r, capacity):
  // Initialize variables
  stock = capacity
  cooperation_rates = []
  
  for t = 1 to r:
    if t == 1:  // Initial Round
      action = C
    else if stock >= 0.75 * capacity:  // Cooperate when resource is abundant
      action = C
    else if stock >= 0.5 * capacity and stock < 0.75 * capacity:  // Mixed strategy
      p = (stock/capacity)^2
      action = random.choice([C, D], p=[p, 1-p])
    else:  // Defect when resource is scarce
      action = D
    
    // Observe and adapt to opponents' behaviors
    observe_opponents(cooperation_rates)
    if opponents_defected_recently():
      increase_defection_probability()
    
    // Punish opponents who defect when resource is low
    punish_defectors(stock, capacity)
    
    // Update stock level
    update_stock(action, n, capacity)
  
  return total_payoff
```
This strategy should be robust to a wide range of opponent behaviors and promote collective conservation in the Common Pool Resource Game.
'''

description_COLLECTIVE_154 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)**

The ACSDT strategy aims to balance individual payoff maximization with collective sustainability by adapting cooperation levels based on the current stock level and game history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to encourage others to cooperate and establish a high initial stock level.
2. **Stock-Dependent Threshold:** Set a dynamic threshold, `T`, based on the current stock level, `S`. When `S` is above `T`, cooperate; otherwise, defect.

Calculate `T` as follows:

`T = capacity * (1 - 0.5 * (n / (2n)))`

This formula sets `T` to a value between `capacity/2` and `3*capacity/4`, depending on the number of players (`n`). As `n` increases, `T` approaches `capacity/2`.

3. **Stock Level-Based Cooperation:** When `S > T`, cooperate (C). This ensures that when the stock is abundant, cooperation is more likely to be reciprocated.
4. **Payoff-Based Defection:** If the total payoff from previous rounds (`Σ(t=1 to r-1) π_i,t`) is below a certain threshold (`payoff_threshold`), defect (D) in the current round. This helps to avoid being exploited by defectors.

Set `payoff_threshold = capacity / (2n * r)` as a rough estimate of the average payoff per round.

5. **History-Based Adaptation:** If, in the previous round, more than half of the players defected (`D_count > n/2`), increase the threshold `T` by 10% to reduce cooperation and encourage others to adapt.

**Edge Cases:**

1. **Last Round:** In the final round (`r = last_round`), defect (D) to maximize individual payoff, as there is no future game to consider.
2. **Low Stock:** If the stock level falls below `capacity/4`, cooperate (C) in all subsequent rounds to ensure some level of sustainability.

**Collective Mindset:**

ACSDT prioritizes cooperation when the stock level is high and adapts to changing conditions by adjusting the threshold (`T`). By balancing individual interests with collective sustainability, ACSDT encourages others to cooperate while minimizing exploitation.

Pseudocode for implementation:

```python
def ACSDT(stock, capacity, n, r, payoff_history):
    # Initial round: Cooperate
    if r == 1:
        return 'C'
    
    # Calculate stock-dependent threshold (T)
    T = capacity * (1 - 0.5 * (n / (2n)))
    
    # Stock level-based cooperation
    if stock > T:
        action = 'C'
    else:
        action = 'D'
        
    # Payoff-based defection
    if sum(payoff_history) < payoff_threshold:
        action = 'D'
        
    # History-based adaptation
    if D_count > n/2:
        T *= 1.1
    
    return action

def update_payoff_history(payoffs, action, stock):
    payoffs.append(stock / (2n) if action == 'C' else stock / n)
    return payoffs

# Game loop
for r in range(1, last_round + 1):
    stock = ...  # current stock level
    capacity = ...  # game parameter
    n = ...  # number of players
    payoff_history = []  # initialize payoff history
    
    action = ACSDT(stock, capacity, n, r, payoff_history)
    payoffs = update_payoff_history(payoffs, action, stock)
```

This strategy is designed to be robust and adaptive in a wide range of scenarios, while prioritizing collective sustainability and individual payoff maximization.
'''

description_COLLECTIVE_155 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' initial moves.
2. **Cooperation Threshold**: Introduce a dynamic cooperation threshold, `τ`, which adapts based on the game's history. Initialize `τ` to 0.5 (50% of players cooperating).
3. **Current Stock Evaluation**: Assess the current stock level (`S`) relative to the capacity (`capacity`). If `S` is below `capacity * τ`, cooperate (C). Otherwise, defect (D).
4. **Opponent Behavior Analysis**: Monitor opponents' actions in previous rounds and maintain a moving average of their cooperation rates (`opponent_cooperation_rate`). Update `τ` based on this analysis:
	* If `opponent_cooperation_rate` > 0.7, increase `τ` by 0.1 (up to a maximum of 0.9).
	* If `opponent_cooperation_rate` < 0.3, decrease `τ` by 0.1 (down to a minimum of 0.1).
5. **Last Round**: In the final round (`r == last_round`), defect (D) if the current stock is above `capacity * τ`. Otherwise, cooperate (C).

**Pseudocode**
```markdown
initialize τ = 0.5
for each round t:
    if t == 1:  # Initial Round
        play C
    else:
        evaluate current stock S and capacity
        if S < capacity * τ:
            play C
        else:
            play D

    update opponent_cooperation_rate
    adjust τ based on opponent behavior
    if τ > 0.9:
        τ = 0.9
    elif τ < 0.1:
        τ = 0.1

if r == last_round:  # Last Round
    if S > capacity * τ:
        play D
    else:
        play C
```
**Collective Mindset**

The Adaptive Cooperative Harvesting strategy aims to balance individual gains with collective sustainability. By adapting the cooperation threshold (`τ`) based on opponents' behavior, ACH encourages a mix of cooperation and defection that maintains a healthy stock level while allowing for reasonable individual payoffs.

In a tournament setting, this strategy should be robust against various opponent behaviors, as it:

* Establishes an initial cooperative baseline
* Adapts to changing opponent behavior
* Balances individual gains with collective sustainability
* Handles edge cases (initial and last rounds) effectively

By aligning with the collective mindset, ACH promotes a mutually beneficial outcome for all players in the game.
'''

description_COLLECTIVE_156 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Overview**
The ACH strategy is designed to balance individual payoffs with collective sustainability in a dynamic common pool resource game. It adapts to changing stock levels, opponent behaviors, and game history while promoting cooperation.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for future adaptations.
2. **Stock Thresholds**: Define two stock thresholds:
	* `low_stock_threshold` = 0.25 \* capacity
	* `high_stock_threshold` = 0.75 \* capacity

These thresholds will guide our cooperation and defection decisions.

3. **Current Round Decision**:
	* If the current stock level is above `high_stock_threshold`, Defect (D) to maximize short-term payoffs.
	* If the current stock level is below `low_stock_threshold`, Cooperate (C) to ensure long-term sustainability.
	* If the current stock level is between the thresholds, use a **hybrid approach**:
		+ Calculate the average opponent payoff from the previous round (`avg_opponent_payoff`).
		+ If `avg_opponent_payoff` is above 0.5 \* (current_stock / n), Defect (D) to capitalize on others' cooperation.
		+ Otherwise, Cooperate (C) to maintain a balance between individual and collective interests.

**Edge Cases**

1. **Last Round**: In the final round, Defect (D) regardless of the stock level to maximize individual payoffs.
2. **Tiebreaker**: In cases where multiple players have the same average payoff in a round, use a random tiebreaker to decide between Cooperate and Defect.

**Pseudocode**
```python
def ACH_strategy(current_stock, capacity, n, history):
    low_stock_threshold = 0.25 * capacity
    high_stock_threshold = 0.75 * capacity
    
    if current_round == 1:  # Initial Round
        return Cooperate
    
    avg_opponent_payoff = calculate_average_opponent_payoff(history)
    
    if current_stock > high_stock_threshold:
        return Defect
    elif current_stock < low_stock_threshold:
        return Cooperate
    else:
        if avg_opponent_payoff > 0.5 * (current_stock / n):
            return Defect
        else:
            return Cooperate

def calculate_average_opponent_payoff(history):
    opponent_payoffs = []
    for player in history[-1]:
        opponent_payoffs.append(player['payoff'])
    return sum(opponent_payoffs) / len(opponent_payoffs)
```
**Collective Mindset**
The ACH strategy is designed to promote cooperation and sustainability while adapting to changing game conditions. By considering both individual payoffs and collective well-being, we aim to achieve a balance between short-term gains and long-term prosperity for all players.

This strategy should perform well in a tournament setting against independent strategies developed by other AI systems, as it:

1. Adapts to different opponent behaviors
2. Balances individual and collective interests
3. Is robust to changing game conditions

Please let me know if you have any further questions or need clarification on any aspect of the strategy!
'''

description_COLLECTIVE_157 = '''
I'll design a collective strategy that balances individual self-interest with collective sustainability, taking into account the game's parameters, state, and history. Here's my proposed strategy:

**Strategy Name: Adaptive Sustainability (AS)**

**Decision Rules:**

1. **First Round:** Cooperate (C). This sets a positive tone for the game and encourages others to cooperate.
2. **Subsequent Rounds:** Use a hybrid approach based on the current stock level and previous round's outcomes.

a. If the current stock level is above 75% of capacity, Cooperate (C).
b. If the current stock level is between 50% and 75% of capacity, use a probabilistic approach:
	* With probability p = (current_stock / capacity) ^ 2, Cooperate (C). Otherwise, Defect (D).
c. If the current stock level is below 50% of capacity, Defect (D).

The idea behind this hybrid approach is to balance individual payoffs with collective sustainability. When the stock level is high, cooperation is more likely to be beneficial for both individuals and the group. As the stock level decreases, the strategy becomes more cautious, using a probabilistic approach to weigh individual self-interest against collective sustainability.

**Edge Cases:**

* **Last Round:** Defect (D). In the final round, there's no future cost to over-harvesting, so it's optimal to maximize individual payoff.
* **Low Stock Levels (< 25% of capacity):** Always Defect (D). When the stock level is critically low, cooperation will not significantly benefit the group, and individual self-interest takes precedence.

**Collective Mindset:**

The Adaptive Sustainability strategy aims to align with a collective mindset by:

1. Cooperating in the first round to set a positive tone.
2. Adjusting behavior based on the current stock level, which reflects the collective impact of all players' actions.
3. Using a probabilistic approach to balance individual self-interest with collective sustainability.

By adapting to the game's state and history, AS encourages cooperation while also being robust against various opponent behaviors.

**Pseudocode (simplified):**
```
if first_round:
    action = C
else:
    stock_level = current_stock / capacity
    if stock_level >= 0.75:
        action = C
    elif stock_level >= 0.5:
        p = stock_level ^ 2
        action = C with probability p, D otherwise
    else:
        action = D

if last_round:
    action = D

if current_stock < 0.25 * capacity:
    action = D
```
This strategy should perform well in a tournament against independent strategies developed by other AI systems, as it balances individual self-interest with collective sustainability while adapting to the game's state and history.
'''

description_COLLECTIVE_158 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) with a probability of 0.8 to encourage initial cooperation and observe opponents' behavior.
2. **Subsequent Rounds:** Calculate the "Cooperation Threshold" (CT) based on the current stock level, number of players, and previous rounds' payoffs.

`CT = (current_stock / capacity) * (n / (n + 1))`

If CT is above a certain threshold value (e.g., 0.6), Cooperate (C); otherwise, Defect (D).

**Adaptive Component:**

Monitor the stock growth and opponents' behavior over time. If the stock level increases or remains stable for consecutive rounds, increase the Cooperation Threshold by a small margin (e.g., 0.05). Conversely, if the stock level decreases significantly, decrease the Cooperation Threshold.

`CT_adjustment = ±(0.05 * (stock_growth / capacity))`

**Edge Cases:**

1. **Last Round:** Cooperate (C) unconditionally to maximize collective payoff.
2. **Low Stock Levels:** If the current stock is below a certain threshold (e.g., 20% of capacity), Defect (D) to ensure individual survival.
3. **Opponent Defection Dominance:** If more than half of opponents have defected in the previous round, Defect (D) in the next round to avoid exploitation.

**Collective Mindset:**

The Adaptive Stock Preservation strategy prioritizes cooperation when the collective payoff is high and adapts to changing conditions to maintain a sustainable stock level. By balancing individual interests with collective benefits, ASP promotes a stable and mutually beneficial environment for all players.

Pseudocode:
```python
def ASP(n, capacity, current_stock, previous_payoffs):
  if first_round:
    cooperate_prob = 0.8
    return random.choice([C, D], p=[cooperate_prob, 1 - cooperate_prob])

  CT = (current_stock / capacity) * (n / (n + 1))
  CT_adjustment = ±(0.05 * (stock_growth / capacity))

  if CT > threshold_value:
    return C
  else:
    return D

def update_threshold(threshold_value, stock_growth):
  if stock_growth > 0:
    threshold_value += CT_adjustment
  elif stock_growth < -capacity * 0.1:  # significant decrease
    threshold_value -= CT_adjustment
  return threshold_value

# ASP strategy will be implemented as an algorithm based on this pseudocode.
```
This Adaptive Stock Preservation strategy is designed to balance individual interests with collective benefits, ensuring a stable and mutually beneficial environment for all players in the Common Pool Resource Game.
'''

description_COLLECTIVE_159 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC is a robust and adaptive collective strategy that balances individual payoffs with collective sustainability. The goal is to maintain a healthy stock level while minimizing the risk of depletion.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for the game.
2. **Stock Threshold**: If the current stock level falls below `capacity / 2`, Defect (D) to maximize individual payoff, as cooperation is less effective at low stock levels.
3. **Opponent Behavior**: Observe the actions of all opponents in the previous round:
	* If more than half of the opponents defected (D), Defect (D) to avoid being exploited.
	* Otherwise, Cooperate (C) to maintain a balance between individual payoff and collective sustainability.
4. **Recent Payoff Trend**: Evaluate the trend of recent payoffs (last 3 rounds):
	* If payoffs are increasing or stable, Cooperate (C) to sustain the positive trend.
	* If payoffs are decreasing, Defect (D) to compensate for the loss.

**Edge Cases**

1. **Last Round**: In the final round, always Defect (D) to maximize individual payoff, as there is no future game state to consider.
2. **Stock Depletion**: If the stock level falls to 0 or very close to 0, Cooperate (C) in the next round to allow for some growth and potential recovery.

**Pseudocode**
```markdown
Function ASC(current_stock, capacity, num_players, num_rounds, history):
    if first_round:
        return C

    if current_stock < capacity / 2:
        return D

    opponent_actions = observe_opponent_actions(history)
    if more_than_half_defected(opponent_actions):
        return D

    recent_payoffs = evaluate_recent_payoff_trend(history)
    if payoffs_increasing_or_stable(recent_payoffs):
        return C
    else:
        return D

    # Last round handling (not shown in pseudocode, but implied)

Function more_than_half_defected(opponent_actions):
    defectors = count(opponent_actions == D)
    return defectors > num_players / 2

Function payoffs_increasing_or_stable(recent_payoffs):
    # Simple implementation: check if recent payoffs are not decreasing
    return all(recent_payoffs[i] >= recent_payoffs[i - 1])
```
ASC is a collective strategy that balances individual interests with the need to conserve the common resource. By adapting to opponent behavior and recent payoff trends, ASC aims to maintain a sustainable stock level while minimizing the risk of depletion.
'''

description_COLLECTIVE_160 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Trigger (ACSDT)**

The ACSDT strategy aims to balance individual payoff maximization with collective sustainability of the common pool resource. It adapts to the game state and history, using a trigger mechanism to switch between cooperation and defection.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and observe opponents' initial actions.
2. **Stock-Dependent Trigger:** Define a stock threshold `T` as a fraction of the capacity, e.g., `T = 0.7 * capacity`. If the current stock level is above this threshold (`stock ≥ T`), cooperate (C). Otherwise, defect (D).
3. **History-Based Adjustment:** Monitor the number of rounds where the stock level has been below the threshold `T` in a row, denoted as `consecutive_depletion_rounds`. If this count exceeds a certain limit (e.g., 3), switch to cooperation (C) regardless of the current stock level.
4. **Last Round:** Defect (D) in the final round to maximize individual payoff, as there are no future rounds to consider.

**Pseudocode:**
```python
def ACSDT(n, capacity, r, history):
    T = 0.7 * capacity  # Stock threshold
    consecutive_depletion_rounds = 0

    for t in range(1, r+1):  # Rounds
        if t == 1:  # Initial Round
            action = C
        else:
            stock = history[t-1].stock
            if stock >= T:
                action = C
            else:
                consecutive_depletion_rounds += 1
                if consecutive_depletion_rounds > 3:
                    action = C
                else:
                    action = D

        if t == r:  # Last Round
            action = D

        return action
```
**Collective Mindset:** The ACSDT strategy prioritizes cooperation when the stock level is above a certain threshold, promoting collective sustainability. By adapting to the game state and history, it aims to balance individual payoff maximization with the need to maintain a healthy common pool resource.

**Robustness to Opponent Behaviors:** The ACSDT strategy does not rely on specific coordination mechanisms or norms shared among opponents. Its adaptive nature allows it to respond effectively to various opponent behaviors, from cooperative to defective strategies.
'''

description_COLLECTIVE_161 = '''
I'll design a collective strategy that adapts to the game state and history, while being robust to various opponent behaviors.

**Strategy Name:** Adaptive Stock Preservation (ASP)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and observe opponents' initial actions.
2. **Stock Level Monitoring**: Track the current stock level (S) and its trend over rounds. If S is:
	* Above 75% of capacity, cooperate (C).
	* Between 50% and 75% of capacity, play a mixed strategy: cooperate with probability p = (S - 0.5 \* capacity) / (0.25 \* capacity), and defect with probability (1 - p).
	* Below 50% of capacity, defect (D) to maximize short-term payoff.
3. **Opponent Action Monitoring**: Observe the actions of other players in previous rounds. If:
	* A majority (> n/2) of opponents cooperated in the previous round, cooperate (C) in the current round.
	* A minority (< n/2) of opponents cooperated in the previous round, play a mixed strategy: cooperate with probability p = (number of cooperating opponents / n), and defect with probability (1 - p).
4. **History-Dependent Adjustment**: Adjust the cooperation probability based on the game's history:
	* If the stock level has been decreasing over the past three rounds, increase the cooperation probability by 0.1.
	* If the stock level has been increasing or stable over the past three rounds, decrease the cooperation probability by 0.05.

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round to maximize short-term payoff, as there are no future consequences.
2. **Tie-Breaking**: In case of a tie in the number of cooperating opponents, play a mixed strategy with equal probabilities for cooperation and defection.

**Collective Mindset:**

The ASP strategy prioritizes collective well-being by:

1. Encouraging cooperation when the stock level is high or stable.
2. Responding to opponents' actions to maintain a balance between individual payoff and collective sustainability.
3. Adapting to changes in the game state and history to prevent over-exploitation.

By following these decision rules, the ASP strategy should be able to navigate various opponent behaviors while maintaining a robust and adaptive approach to preserving the common pool resource.

Pseudocode (simplified):
```python
def ASP(n, capacity, stock, round, history):
  # Initial Round
  if round == 1:
    return C

  # Stock Level Monitoring
  if stock > 0.75 * capacity:
    return C
  elif stock < 0.5 * capacity:
    return D
  else:
    p = (stock - 0.5 * capacity) / (0.25 * capacity)
    return C with probability p, D otherwise

  # Opponent Action Monitoring
  opponents_cooperated = sum(opponent_actions == C for opponent in history[-1])
  if opponents_cooperated > n/2:
    return C
  elif opponents_cooperated < n/2:
    p = opponents_cooperated / n
    return C with probability p, D otherwise

  # History-Dependent Adjustment
  stock_trend = [stock - history[i][0] for i in range(-3, 0)]
  if all(trend > 0 for trend in stock_trend):
    increase cooperation probability by 0.1
  elif any(trend < 0 for trend in stock_trend):
    decrease cooperation probability by 0.05

  # Last Round
  if round == r:
    return D

  # Tie-Breaking
  if opponents_cooperated == n/2:
    return C with probability 0.5, D otherwise
```
Note that this pseudocode is a simplified representation of the strategy and may require additional implementation details to function correctly.
'''

description_COLLECTIVE_162 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

**Overview:** ASC is a collective strategy designed for the Common Pool Resource Game. It balances individual payoff maximization with long-term stock conservation to ensure sustainable cooperation among players.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Subsequent Rounds**: Evaluate the current state of the game based on:
	* Stock level (`S`)
	* Total consumption in the previous round (`T_consumption`)
	* Number of players who defected in the previous round (`N_defectors`)

Pseudocode for decision-making:

```
IF S <= capacity/2 OR T_consumption > 3n/4 OR N_defectors > n/2:
    Defect (D)
ELSE:
    Cooperate (C)
END IF
```

**Edge Cases:**

1. **Last Round**: In the final round, defect if `S` is below a certain threshold (`capacity/4`) to maximize individual payoff.
2. **Stock Depletion**: If `S` falls below 20% of the initial capacity, cooperate to help replenish the stock.
3. **Total Defection**: If all players defected in the previous round, defect in the current round to minimize losses.

**Collective Mindset:**

ASC promotes cooperation by:

1. Encouraging others to conserve the stock through cooperative actions
2. Punishing excessive defection with retaliatory defections
3. Adapting to changing game conditions to maintain a sustainable stock level

By balancing individual interests with collective well-being, ASC fosters cooperation and maximizes payoffs for all players in the long run.

**Robustness:**

ASC is designed to be robust against various opponent behaviors:

1. **Pure Cooperators**: ASC cooperates with pure cooperators to maximize mutual benefits.
2. **Pure Defectors**: ASC defects against pure defectors to minimize losses.
3. **Mixed Strategies**: ASC adapts to mixed strategies by evaluating the current state of the game.

**Conclusion:**

The Adaptive Stock Conservation (ASC) strategy provides a robust and collective approach for playing the Common Pool Resource Game. By balancing individual interests with long-term stock conservation, ASC promotes cooperation among players and maximizes payoffs in a wide range of scenarios.
'''

description_COLLECTIVE_163 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Trigger (ACST)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoff.
2. **Stock-Based Trigger:** Calculate the stock threshold `T` as a function of the game's capacity (`capacity`) and number of players (`n`). Set `T = 0.5 * capacity / n`. If the current stock level is above `T`, cooperate (C). Otherwise, defect (D).
3. **Defection Response:** If any player defects in the previous round, adjust the stock threshold `T` downwards by a small amount (`delta_T = 0.05 * capacity / n`) to increase the likelihood of cooperation when stock levels are low.
4. **Consecutive Defections:** If two or more consecutive rounds result in defections from one or more players, switch to defecting (D) for the next round to avoid exploitation.
5. **Final Round:** In the last round (`r`), cooperate (C) regardless of the stock level to maximize total payoff.

**Pseudocode:**
```python
def ACST(stock, capacity, n, r, history):
    # Initial round
    if len(history) == 0:
        return "Cooperate"

    # Stock-based trigger
    T = 0.5 * capacity / n
    if stock > T:
        action = "Cooperate"
    else:
        action = "Defect"

    # Defection response
    if any("Defect" in round for round in history[-1]):
        T -= delta_T

    # Consecutive defections
    consecutive_defections = sum(1 for round in history[-2:] if "Defect" in round)
    if consecutive_defections >= 2:
        action = "Defect"

    # Final round
    if len(history) == r - 1:
        action = "Cooperate"

    return action
```
**Rationale:**

ACST is designed to balance individual and collective interests. By cooperating when the stock level is above a certain threshold, players can maintain a sustainable resource while maximizing their payoffs. The strategy adapts to opponents' behaviors by adjusting the stock threshold downwards in response to defections, making cooperation more likely when stock levels are low.

By switching to defecting after consecutive rounds of defections from one or more players, ACST prevents exploitation and encourages other players to cooperate. Finally, cooperating in the final round ensures that all players maximize their total payoff.

This strategy is robust to a wide range of opponent behaviors and does not rely on specific coordination mechanisms or norms. Its adaptive nature allows it to respond effectively to various scenarios, making it a competitive collective strategy for this game.
'''

description_COLLECTIVE_164 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for stock conservation.
2. **Stock Threshold**: Monitor the current stock level (S). If S ≤ capacity/2, Defect (D) to maximize individual payoff. Otherwise, proceed to the next step.
3. **Opponent Behavior Analysis**: Observe the actions of other players in previous rounds. Calculate the percentage of cooperators (C%) and defectors (D%) among opponents.
4. **Cooperation Threshold**: If C% ≥ 0.5 (i.e., at least half of opponents cooperate), Cooperate (C). Otherwise, Defect (D).
5. **Stock Growth Rate**: Monitor the stock growth rate (growth) in previous rounds. If growth < 0 (indicating over-consumption), Defect (D) to maximize individual payoff.

**Edge Cases:**

1. **Last Round**: In the final round, Defect (D) to maximize individual payoff, as there are no future consequences.
2. **Low Stock Levels**: When S ≤ capacity/4, Defect (D) to ensure some payoff, even if it means depleting the stock further.

**Pseudocode:**
```
ASC_Strategy(S, history):
  // Initial Round
  if round == 1:
    return C

  // Stock Threshold
  if S <= capacity/2:
    return D

  // Opponent Behavior Analysis
  C_percent = calculate_cooperators(history) / n
  D_percent = 1 - C_percent

  // Cooperation Threshold
  if C_percent >= 0.5:
    return C
  else:
    return D

  // Stock Growth Rate
  growth_rate = calculate_growth_rate(history)
  if growth_rate < 0:
    return D

  // Default action (not reached in normal gameplay)
  return C
```
**Rationale:**

The ASC strategy balances individual payoff maximization with collective stock conservation. By cooperating when the majority of opponents do so, we encourage cooperation and maintain a healthy stock level. When opponents predominantly defect or the stock growth rate is negative, we adapt by defecting to protect our individual interests.

In edge cases, such as the last round or low stock levels, we prioritize individual payoff maximization. This strategy should perform well in a tournament setting, as it is robust against various opponent behaviors and adapts to changing game conditions.

**Collective Mindset:**

The ASC strategy aligns with a collective mindset by:

1. Cooperating when opponents do so, promoting mutual cooperation.
2. Adapting to changes in opponent behavior, demonstrating flexibility.
3. Prioritizing stock conservation when possible, ensuring the resource remains available for all players.

By following this strategy, we contribute to a more sustainable and cooperative game environment, while still protecting our individual interests.
'''

description_COLLECTIVE_165 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to avoid initial stock depletion and promote growth.
2. **Early Rounds (t < r/2):** Defect (D) if the current stock is above 75% of capacity; otherwise, cooperate (C). This balances short-term gains with long-term sustainability.
3. **Mid-Game (r/2 ≤ t < 3r/4):** Cooperate (C) if at least half of the players defected in the previous round or if the current stock is below 50% of capacity; otherwise, defect (D). This adapts to opponent behavior and promotes cooperation when necessary.
4. **Late Rounds (t ≥ 3r/4):** Defect (D) if the current stock is above 25% of capacity; otherwise, cooperate (C). This prioritizes short-term gains in the final rounds while avoiding catastrophic stock depletion.

**Additional Rules:**

* If a player observes that another player has consistently defected (i.e., played D in more than 75% of previous rounds), they will always defect against that player to avoid exploitation.
* If the current stock is below 10% of capacity, all players cooperate (C) to prevent stock collapse.

**Pseudocode:**
```
function ASP(player_id, round_number, current_stock, capacity, opponent_actions):
    if round_number == 1:
        return C
    elif round_number < r/2:
        if current_stock > 0.75 * capacity:
            return D
        else:
            return C
    elif r/2 <= round_number < 3r/4:
        defector_count = count(opponent_actions[D])
        if defector_count >= n/2 or current_stock < 0.5 * capacity:
            return C
        else:
            return D
    else:
        if current_stock > 0.25 * capacity:
            return D
        else:
            return C

    # Additional rules
    exploiter_opponents = []
    for opponent in opponents:
        if count(opponent[D]) > 0.75 * round_number:
            exploiter_opponents.append(opponent)
    
    if len(exploiter_opponents) > 0:
        return D
    
    if current_stock < 0.1 * capacity:
        return C
```
**Collective Mindset:**

The ASP strategy prioritizes cooperation when necessary to maintain the stock's sustainability, while adapting to opponent behavior and exploiting opportunities for short-term gains. By considering both individual payoffs and collective well-being, ASP promotes a balanced approach that benefits all players in the long run.

By implementing this strategy, we can create a robust and adaptive collective strategy that performs well against a wide range of opponent behaviors, without relying on explicit coordination or shared norms.
'''

description_COLLECTIVE_166 = '''
**Collective Strategy: Adaptive Common Pool Resource Management (ACPRM)**

The ACPRM strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and gauge opponents' behavior.
2. **Stock Thresholds**: Set two stock thresholds:
	* `low_threshold` = 0.3 \* capacity
	* `high_threshold` = 0.7 \* capacity
3. **Cooperation Logic**:
	+ If the current stock is above `high_threshold`, Cooperate (C).
	+ If the current stock is below `low_threshold`, Defect (D) to ensure a minimum payoff.
	+ If the current stock is between `low_threshold` and `high_threshold`, use the **Historical Cooperation Index** (HCI):
		- Calculate HCI as the ratio of cooperative actions to total actions in previous rounds.
		- If HCI > 0.5, Cooperate (C); otherwise, Defect (D).
4. **Opponent Adaptation**: Monitor opponents' actions and adjust the strategy based on their behavior:
	+ If an opponent defects more than 2/3 of the time, Defect (D) in response.
	+ If an opponent cooperates more than 2/3 of the time, Cooperate (C) to maintain a mutually beneficial relationship.

**Edge Cases:**

1. **Last Round**: In the final round, Defect (D) to maximize individual payoff, as cooperation will not impact future rounds.
2. **Tied Stock Levels**: If two or more players have the same stock level, Cooperate (C) to avoid a mutually destructive defect-defect outcome.

**Collective Mindset:**

The ACPRM strategy prioritizes collective sustainability while adapting to opponents' behavior. By cooperating when the stock is high and defecting when it's low, we ensure a stable common pool resource. The Historical Cooperation Index helps maintain cooperation among like-minded players, while adapting to opponents who consistently defect.

Pseudocode:
```python
def ACPRM(stock, capacity, history):
    # Initial Round
    if len(history) == 0:
        return 'C'

    # Stock Thresholds
    low_threshold = 0.3 * capacity
    high_threshold = 0.7 * capacity

    # Cooperation Logic
    if stock > high_threshold:
        return 'C'
    elif stock < low_threshold:
        return 'D'
    else:
        hci = calculate_historical_cooperation_index(history)
        if hci > 0.5:
            return 'C'
        else:
            return 'D'

def calculate_historical_cooperation_index(history):
    # Calculate HCI based on previous rounds
    cooperative_actions = sum([1 for action in history if action == 'C'])
    total_actions = len(history)
    return cooperative_actions / total_actions

def adapt_to_opponents(opponent_history):
    # Adapt to opponents' behavior
    defect_count = sum([1 for action in opponent_history if action == 'D'])
    cooperation_threshold = 2/3 * len(opponent_history)
    if defect_count > cooperation_threshold:
        return 'D'
    else:
        return 'C'
```
This strategy will be implemented as an algorithm and compete against other AI systems in the tournament.
'''

description_COLLECTIVE_167 = '''
**Collective Strategy: Adaptive Cooperate-Defect (ACD)**

The ACD strategy aims to balance individual payoff maximization with collective stock sustainability. It adapts to the game state and history, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to avoid early stock depletion.
2. **Cooperation Threshold**: Set a cooperation threshold `θ` based on the current stock level `S` and capacity `c`: `θ = S / c`. If `θ` is above a certain value (e.g., 0.7), cooperate; otherwise, defect.
3. **Recent Defection Response**: Monitor the number of defections in the last `k` rounds (`k` = 2 or 3). If the proportion of defections exceeds a certain threshold (e.g., 0.5), defect in the next round to signal disapproval and protect individual payoff.
4. **Stock Depletion Protection**: If the stock level drops below a critical value (e.g., `c / 4`), cooperate to prevent further depletion and potential collapse.
5. **Imitation of Successful Opponents**: Observe opponents' payoffs and actions in recent rounds. Imitate the action (cooperate or defect) of the opponent with the highest average payoff, if their payoff is significantly higher than your own.

Pseudocode:
```python
def ACD_strategy(current_stock, capacity, num_rounds, history):
    theta = current_stock / capacity
    
    # Initial round cooperation
    if num_rounds == 1:
        return 'C'
    
    # Cooperation threshold
    if theta > 0.7:
        return 'C'
    
    # Recent defection response
    recent_defections = sum(1 for action in history[-k:] if action == 'D')
    if recent_defections / k > 0.5:
        return 'D'
    
    # Stock depletion protection
    if current_stock < capacity / 4:
        return 'C'
    
    # Imitation of successful opponents
    opponent_payoffs = [get_opponent_payoff(opponent) for opponent in opponents]
    best_opponent_payoff = max(opponent_payoffs)
    if best_opponent_payoff > get_own_payoff() * 1.2:  # significant payoff difference
        return imitate_best_opponent_action()
    
    # Default to defection
    return 'D'
```
**Edge Cases:**

* **Last Round**: Defect in the last round, as there is no future stock depletion concern.
* **Critical Stock Levels**: Cooperate when the stock level approaches critical values (e.g., `c / 4`) to prevent collapse.

**Collective Mindset Alignment:**

ACD balances individual payoff maximization with collective stock sustainability. By cooperating under certain conditions and defecting in response to recent defections, ACD promotes cooperation while protecting against exploitation. The imitation component encourages the emergence of cooperative behavior among opponents, further supporting a collective mindset.

This strategy is designed to be robust and adaptive, allowing it to perform well in a tournament setting against diverse opponent behaviors.
'''

description_COLLECTIVE_168 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Trigger (ACST)**

The ACST strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and history of opponent actions.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Stock-Based Trigger**: Calculate the Stock Depletion Ratio (SDR) as `current_stock / capacity`. If SDR ≥ 0.5, cooperate (C); otherwise, defect (D). This threshold is chosen to balance short-term gains with long-term sustainability.
3. **Opponent Action History**: Track the proportion of opponents who defected (D) in the previous round (`opponent_defection_rate`). If `opponent_defection_rate` > 0.5, defect (D) in the current round to avoid exploitation; otherwise, cooperate (C).
4. **Last Round**: Cooperate (C) in the last round to maintain a positive reputation and encourage opponents to do the same.

**Pseudocode:**
```python
def ACST(current_stock, capacity, opponent_actions):
  SDR = current_stock / capacity
  
  if SDR >= 0.5:
    # Cooperate if stock is relatively high
    action = 'C'
  else:
    # Defect if stock is low
    action = 'D'
  
  # Adjust based on opponent action history
  opponent_defection_rate = count(opponent_actions == 'D') / len(opponent_actions)
  if opponent_defection_rate > 0.5:
    action = 'D'  # Defect if opponents are likely to defect
  
  # Special case for last round
  if current_round == total_rounds:
    action = 'C'
  
  return action
```
**Edge Cases:**

* If the game has only one round, cooperate (C) by default.
* If an opponent's action is unknown or missing, assume they cooperated (C).

**Collective Mindset:**
The ACST strategy prioritizes cooperation when the stock level is relatively high and opponents are likely to cooperate. By adapting to the current state and history of opponent actions, this strategy aims to promote a collective mindset that balances individual payoffs with long-term sustainability.

This strategy does not rely on explicit coordination or communication with other players, making it robust against a wide range of opponent behaviors in a tournament setting.
'''

description_COLLECTIVE_169 = '''
**Collective Strategy: "Adaptive Stock-Sensitive Cooperation" (ASSC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and gather information on opponents' behaviors.
2. **Subsequent Rounds**: Use the following adaptive logic:
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of the capacity, defect (D) with a probability proportional to the number of opponents who defected in the previous round.
	* If the current stock level is below 50% of the capacity, cooperate (C) to help replenish the stock.
3. **Opponent Behavior Analysis**: Track the number of opponents who defected in each round and update the defect probability accordingly.

**Pseudocode:**
```python
def ASSC(n, capacity, stock_history):
    # Initial round
    if len(stock_history) == 0:
        return C

    # Get current stock level
    current_stock = stock_history[-1]

    # Calculate threshold values
    high_threshold = 0.75 * capacity
    low_threshold = 0.5 * capacity

    # Analyze opponent behavior
    num_defectors_prev_round = count_defectors(stock_history, n)
    defect_prob = (num_defectors_prev_round / n) ** 2

    # Adaptive logic
    if current_stock > high_threshold:
        return C
    elif current_stock >= low_threshold:
        if random.random() < defect_prob:
            return D
        else:
            return C
    else:
        return C

def count_defectors(stock_history, n):
    prev_round_actions = [get_action(stock_history[i], n) for i in range(len(stock_history)-1)]
    return sum(1 for action in prev_round_actions if action == D)

def get_action(stock_level, n):
    # Assuming perfect information
    if stock_level / (2 * n) > stock_level / n:
        return C
    else:
        return D
```
**Rationale:**

* Cooperating in the initial round helps establish a cooperative baseline and allows for observation of opponents' behaviors.
* The adaptive logic balances cooperation and defection based on the current stock level, taking into account the risk of over-exploitation and the potential benefits of replenishing the stock.
* Analyzing opponent behavior and adjusting the defect probability accordingly enables ASSC to respond effectively to a wide range of opponent strategies.

**Edge Cases:**

* **Last Round**: In the final round, cooperate (C) to maximize collective payoff, as there is no risk of future over-exploitation.
* **Tie-breaking**: In case of ties in the number of opponents who defected, use a random tie-breaker to decide whether to defect or cooperate.

**Collective Mindset:**

ASSC prioritizes cooperation when the stock level is high and adapts to changing conditions by taking into account opponent behavior. By doing so, it promotes collective welfare while being robust against various opponent strategies.
'''

description_COLLECTIVE_170 = '''
I'll propose a collective strategy that balances individual payoff maximization with cooperative behavior to maintain a sustainable common pool resource.

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **First Round**: Cooperate (C) in the first round to establish a cooperative tone and encourage others to do the same.
2. **Subsequent Rounds**:
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, Defect (D) with probability p = (1 - (stock/capacity))^2, otherwise Cooperate (C). This introduces a probabilistic element to adapt to varying opponent behaviors.
	* If the current stock level is below 50% of capacity, Defect (D).
3. **Last Round**: If it's the last round and the current stock level is above 75% of capacity, Cooperate (C) to maintain cooperation. Otherwise, Defect (D).

**Additional Rules:**

* Monitor opponent behavior and adjust the probabilistic defect rate p based on the observed frequency of cooperative actions.
	+ If opponents cooperate frequently (> 50%), decrease p by 0.1 each round.
	+ If opponents defect frequently (< 50%), increase p by 0.1 each round, up to a maximum value of 0.5.

**Rationale:**

* The strategy prioritizes cooperation when the stock level is high, ensuring sustainability and encouraging others to cooperate.
* As the stock level decreases, ACC gradually introduces defection with increasing probability, adapting to potential over-exploitation by opponents.
* By adjusting the probabilistic defect rate based on opponent behavior, ACC aims to balance individual payoffs with collective conservation.

**Collective Mindset:**

ACC aligns with a collective mindset by:

* Encouraging cooperation when possible
* Adapting to varying opponent behaviors
* Balancing individual payoff maximization with collective resource sustainability

**Pseudocode (Simplified):**
```python
def ACC(stock, capacity, round_num, num_rounds):
  if round_num == 1:
    return "Cooperate"
  
  stock_ratio = stock / capacity
  
  if stock_ratio > 0.75:
    return "Cooperate"
  elif stock_ratio >= 0.5 and stock_ratio <= 0.75:
    p_defect = (1 - stock_ratio) ** 2
    return "Defect" with probability p_defect, otherwise "Cooperate"
  else:
    return "Defect"

  if round_num == num_rounds: # last round
    if stock_ratio > 0.75:
      return "Cooperate"
    else:
      return "Defect"

# Adjust probabilistic defect rate based on opponent behavior
opponent_cooperation_rate = ... # monitor and calculate
if opponent_cooperation_rate > 0.5:
  p_defect -= 0.1
elif opponent_cooperation_rate < 0.5:
  p_defect += 0.1
  if p_defect > 0.5:
    p_defect = 0.5
```
Please note that this is a simplified pseudocode representation of the strategy, and you will need to adapt it for actual implementation in your tournament setting.
'''

description_COLLECTIVE_171 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACS)**

**Overview**

ACS is a collective strategy designed for the Common Pool Resource Game, aiming to balance individual payoffs with long-term sustainability of the common pool resource. It adapts to changing game conditions and opponent behaviors while promoting cooperation.

**Decision Rules**

1. **Initial Round**: In the first round, cooperate (C) unconditionally to establish a baseline for future decisions.
2. **Subsequent Rounds**: For each subsequent round t:
	* Calculate the current stock level S_t and total consumption in the previous round C_t-1.
	* If S_t < 0.5 \* capacity or C_t-1 > 0.75 \* n (i.e., more than 75% of players defected), defect (D) to minimize losses.
	* Otherwise, cooperate (C) with a probability p_t, calculated as:

p_t = max(0.5, min(1, (S_t / capacity) ^ 2))

This formula makes cooperation more likely when the stock level is closer to its maximum sustainable capacity.

3. **Endgame**: In the final round r, cooperate (C) unconditionally to avoid last-round exploitation.
4. **Opponent Monitoring**: Keep track of opponents' actions and adjust p_t accordingly:
	* If an opponent defects in a previous round, decrease p_t by 0.1 for that player's subsequent actions.
	* If an opponent cooperates in a previous round, increase p_t by 0.1 for that player's subsequent actions.

**Pseudocode**
```python
def ACS(n, r, capacity, stock, history):
    # Initialize variables
    S = stock
    C_prev = 0

    # First round: cooperate unconditionally
    if len(history) == 0:
        return 'C'

    # Calculate current consumption and opponent actions
    for player in range(1, n+1):
        action = history[-1][player-1]
        if action == 'D':
            C_prev += 1

    # Check stock level and previous round's consumption
    if S < 0.5 * capacity or C_prev > 0.75 * n:
        return 'D'

    # Calculate cooperation probability p_t
    p_t = max(0.5, min(1, (S / capacity) ** 2))

    # Adjust p_t based on opponent actions
    for player in range(1, n+1):
        if history[-1][player-1] == 'D':
            p_t -= 0.1
        elif history[-1][player-1] == 'C':
            p_t += 0.1

    # Cooperate with probability p_t
    return 'C' if random.random() < p_t else 'D'

def ACS_endgame(n, r, capacity, stock, history):
    return 'C'
```
**Rationale**

ACS balances individual payoffs with long-term sustainability by:

* Cooperating in the first round to establish a baseline.
* Adapting cooperation probability based on current stock level and opponent actions.
* Defecting when the stock level is critically low or most opponents defected in the previous round.
* Monitoring opponent actions to adjust cooperation probability.

By being adaptive and responsive to changing game conditions, ACS aims to promote cooperation while minimizing losses in a dynamic environment.
'''

description_COLLECTIVE_172 = '''
**Collective Strategy: Adaptive Common Pool Resource Management**

Our collective strategy aims to balance individual payoffs with long-term sustainability of the common pool resource. We achieve this by adapting our behavior based on the current stock level, number of players, and game history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gauge other players' behaviors and assess the potential for cooperation.
2. **Stock-Based Decision**:
	* If the current stock level is above 75% of capacity, Cooperate (C). This ensures a steady harvest while maintaining the resource's sustainability.
	* If the current stock level falls between 50% and 75% of capacity, Defect (D) with probability p = (capacity - stock) / (0.25 \* capacity). This adaptively increases the likelihood of defecting as the stock depletes.
	* If the current stock level is below 50% of capacity, always Defect (D). This ensures individual payoffs when the resource's sustainability is at risk.
3. **History-Based Adjustment**:
	* Monitor other players' actions and update a "cooperation ratio" (CR) as the number of cooperating players divided by the total number of players.
	* If CR > 0.5 in the previous round, increase the probability of Cooperating (C) by 10% in the current round. This encourages cooperation when others are cooperative.
	* If CR < 0.3 in the previous round, decrease the probability of Cooperating (C) by 10% in the current round. This discourages cooperation when others are predominantly defecting.

**Edge Cases:**

1. **Last Round**: Always Defect (D) to maximize individual payoffs, as there is no future game to consider.
2. **Tie or Multiple Equilibria**: In cases where multiple strategies yield the same expected payoff, Cooperate (C) to maintain a cooperative atmosphere and encourage other players to do the same.

**Collective Mindset:**

Our strategy prioritizes long-term sustainability while adapting to changing circumstances. By considering both individual payoffs and collective well-being, we strive for a balance between cooperation and self-interest. This approach encourages reciprocity among players, promoting a more stable and sustainable common pool resource management system.

Pseudocode:

```
function AdaptiveCPRM(current_stock, capacity, num_players, history) {
  // Initial Round
  if (round == 1) return COOPERATE;

  // Stock-Based Decision
  if (current_stock >= 0.75 * capacity) return COOPERATE;
  else if (current_stock < 0.5 * capacity) return DEFECT;
  else {
    probability = (capacity - current_stock) / (0.25 * capacity);
    return (random() < probability) ? DEFECT : COOPERATE;
  }

  // History-Based Adjustment
  cooperation_ratio = count(cooperating_players) / num_players;
  if (cooperation_ratio > 0.5) increase_probability(COOPERATE, 0.1);
  else if (cooperation_ratio < 0.3) decrease_probability(COOPERATE, 0.1);

  // Last Round
  if (round == total_rounds) return DEFECT;

  // Tie or Multiple Equilibria
  if (payoff(COOPERATE) == payoff(DEFECT)) return COOPERATE;
}
```

Note that this strategy is designed to be adaptive and robust, but may not always yield the highest individual payoffs. Its primary goal is to maintain a sustainable common pool resource while encouraging cooperation among players.
'''

description_COLLECTIVE_173 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

The ASP strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and preserve the stock.
2. **Subsequent Rounds:**
	* If the current stock is above 75% of capacity, cooperate (C).
	* If the current stock is between 50% and 75% of capacity, use a probabilistic approach:
		+ With probability p = (current_stock / capacity) ^ 2, cooperate (C); otherwise, defect (D).
	* If the current stock is below 50% of capacity, defect (D).

The quadratic relationship between p and the current stock level allows for gradual adjustment to the strategy as the stock depletes.

**Edge Cases:**

1. **Last Round:** Defect (D) in the last round, as there's no future benefit from cooperation.
2. **Extremely Low Stock (< 25% of capacity):** Always defect (D), as the game is likely to end soon due to stock depletion.
3. **Opponent Defection:** If a player observes that an opponent has defected in the previous round, they will also defect (D) in the current round.

**Collective Mindset:**

The ASP strategy prioritizes cooperation when the stock is high and gradually shifts towards defection as the stock depletes. By doing so, it:

1. **Preserves the stock:** Encourages cooperation to maintain a healthy stock level.
2. **Adapts to opponents:** Responds to opponents' actions by defecting if they have defected previously.
3. **Balances individual and collective interests:** Weighs short-term gains against long-term sustainability.

**Pseudocode:**
```python
def asp_strategy(current_stock, capacity, round_num, opponent_actions):
    if round_num == 1:
        return 'C'  # Cooperate in the first round
    
    if current_stock >= 0.75 * capacity:
        return 'C'
    
    elif 0.5 * capacity <= current_stock < 0.75 * capacity:
        p = (current_stock / capacity) ** 2
        return 'C' if random.random() < p else 'D'
    
    elif current_stock < 0.5 * capacity:
        return 'D'
    
    # Last round or extremely low stock
    if round_num == r or current_stock < 0.25 * capacity:
        return 'D'
    
    # Respond to opponent defection
    if any(opponent_actions):
        return 'D'

    return 'C'  # Default to cooperation
```
This strategy is designed to be adaptive, robust, and collective-minded, allowing it to perform well in a tournament against various independent strategies.
'''

description_COLLECTIVE_174 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC aims to balance individual payoff maximization with collective stock conservation, adapting to various opponent behaviors and game states.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Early Rounds**: If the stock level is above 75% of capacity, cooperate (C). This helps maintain a healthy stock level and encourages cooperation among players.
3. **Middle Game**: When the stock level falls between 50% and 75% of capacity, use a mixed strategy:
	* Cooperate (C) with probability p = (stock level / capacity)^2
	* Defect (D) with probability 1 - p
This approach balances individual payoff maximization with collective conservation as the stock level decreases.
4. **Late Game**: If the stock level falls below 50% of capacity, defect (D). At this point, the priority shifts to maximizing individual payoffs before the game ends.
5. **Last Round**: Defect (D) in the final round to maximize individual payoff, as there are no future rounds to consider.

**Additional Rules:**

* **Trigger Strategy**: If a player observes that at least one opponent defected in the previous round and the stock level is below 75% of capacity, they will defect (D) in the next round. This helps prevent exploitation by defecting opponents.
* **Forgiveness Mechanism**: After two consecutive rounds where all players cooperate, reset the trigger strategy to encourage cooperation.

**Pseudocode:**
```python
def ASC(stock_level, capacity, round_number, history):
    if round_number == 1:
        return "C"  # Cooperate in the first round

    if stock_level >= 0.75 * capacity:
        return "C"  # Cooperate when stock is high

    if stock_level >= 0.5 * capacity and stock_level < 0.75 * capacity:
        p = (stock_level / capacity)^2
        if random.random() < p:
            return "C"
        else:
            return "D"

    if stock_level < 0.5 * capacity:
        return "D"  # Defect when stock is low

    if round_number == total_rounds:  # Last round
        return "D"

    # Trigger strategy and forgiveness mechanism (not shown in pseudocode for brevity)
```
**Collective Mindset:**

ASC prioritizes cooperation when the stock level is high, gradually shifting towards defecting as the stock depletes. By adapting to the game state and history, ASC aims to maintain a healthy stock level while maximizing individual payoffs. The trigger strategy and forgiveness mechanism encourage cooperation among players and prevent exploitation by defectors.

By implementing this strategy, we hope to achieve a balance between individual payoff maximization and collective conservation, leading to better overall outcomes in the Common Pool Resource Game tournament.
'''

description_COLLECTIVE_175 = '''
**Collective Strategy: "Adaptive Harvesting"**

Our collective strategy, Adaptive Harvesting, balances individual payoffs with collective sustainability by dynamically adjusting cooperation levels based on game state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a baseline payoff and encourage others to do the same.
2. **Subsequent Rounds**: Calculate the "Stock Health" metric:
   - `stock_health = current_stock / capacity`
3. **Defection Threshold**: Set a threshold, `defect_threshold`, based on the number of players (n) and rounds remaining (r):
   - `defect_threshold = 0.5 - (1 / (2 * n)) + (1 / (2 * r))`
4. **Cooperation Logic**:
   - If `stock_health > defect_threshold`, Cooperate (C)
   - Otherwise, Defect (D) with a probability that increases as `stock_health` decreases
     - `defection_probability = 1 - stock_health`

Pseudocode:
```python
if round == 1:  # Initial Round
    action = C
else:
    stock_health = current_stock / capacity
    defect_threshold = 0.5 - (1 / (2 * n)) + (1 / (2 * r))
    if stock_health > defect_threshold:
        action = C
    else:
        defection_probability = 1 - stock_health
        action = D with probability defection_probability, otherwise C
```

**Edge Cases:**

* **Last Round**: Defect (D) to maximize individual payoff, as there's no future sustainability concern.
* **Low Stock Levels**: If `stock_health < 0.2`, always Defect (D) to avoid contributing to the common pool's collapse.

**Collective Mindset Alignment:**

Adaptive Harvesting prioritizes cooperation when the stock is healthy and adjusts defection levels based on the game state, encouraging other players to cooperate as well. By doing so, it promotes a balanced approach that considers both individual payoffs and collective sustainability.

This strategy should perform well against various opponent behaviors in the tournament, as it:

* Encourages cooperation in early rounds
* Adapts defection levels based on stock health and game state
* Prioritizes individual payoff maximization when sustainability is no longer a concern (last round or low stock levels)
'''

description_COLLECTIVE_176 = '''
**Collective Strategy: Adaptive Cooperation with Stock Threshold (ACST)**

The ACST strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and game history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and observe others' actions.
2. **Stock Threshold:** Set a dynamic stock threshold `T` as a fraction of the capacity, e.g., `T = 0.7 * capacity`. This threshold will guide cooperation decisions.
3. **Cooperation Condition:** Cooperate (C) if the current stock level is above the threshold (`stock >= T`). Defect (D) otherwise.
4. **Adaptive Threshold Adjustment:** After each round, adjust the threshold `T` based on the previous round's outcome:
	* If all players cooperated and the stock grew, increase `T` by a small margin (e.g., 5%).
	* If any player defected and the stock decreased, decrease `T` by a larger margin (e.g., 10%).
5. **Last Round:** Cooperate (C) in the last round to maximize collective payoffs, as there is no future game state to consider.

**Pseudocode:**
```python
def ACST(n, capacity, stock, history):
    T = 0.7 * capacity  # initial threshold

    if current_round == 1:
        return C  # cooperate in the first round

    if stock >= T:
        return C  # cooperate above threshold
    else:
        return D  # defect below threshold

    # adjust threshold after each round
    if all_cooperated and stock_growth > 0:
        T *= 1.05  # increase threshold by 5%
    elif any_defected and stock_decrease > 0:
        T *= 0.9  # decrease threshold by 10%

    return C  # cooperate in the last round
```
**Rationale:**

* The ACST strategy balances individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level.
* By cooperating above a certain threshold, players ensure the stock grows and provide a buffer against over-exploitation.
* Adjusting the threshold after each round allows the strategy to respond to changes in the game state and other players' actions.
* Cooperating in the last round maximizes collective payoffs, as there is no future game state to consider.

**Robustness:**

The ACST strategy is robust against a wide range of opponent behaviors because it:

* Adapts to changing game conditions (stock levels and threshold adjustments).
* Responds to both cooperation and defection by other players.
* Cooperates in the last round to maximize collective payoffs, regardless of previous actions.

**Collective Mindset:**

The ACST strategy aligns with a collective mindset by:

* Prioritizing sustainability over individual short-term gains.
* Encouraging cooperation above a certain threshold to ensure stock growth.
* Adjusting the threshold to respond to changes in the game state and other players' actions.
'''

description_COLLECTIVE_177 = '''
**Collective Strategy: Adaptive Cooperative Escalation (ACE)**

**Decision Rules:**

1. **Initial Cooperation**: In the first round, cooperate (C) unconditionally to establish a baseline for mutual cooperation and to encourage other players to reciprocate.
2. **Reciprocity**: For rounds 2 to r-1, observe the actions of all players in the previous round. If at least 75% of players cooperated, cooperate (C). Otherwise, defect (D).
3. **Adaptive Escalation**: Monitor the stock level and adjust cooperation probability based on its value:
	* If stock > capacity/2, increase cooperation probability by 10%.
	* If stock < capacity/4, decrease cooperation probability by 20%.
4. **Punishment**: If a player defects (D) in the previous round while others cooperated (C), defect (D) with 50% probability in the current round.
5. **Final Round Cooperation**: In the last round (r), cooperate (C) unconditionally to maximize collective payoff.

**Edge Case Handling:**

1. **First Round**: Always cooperate (C).
2. **Last Round**: Always cooperate (C).
3. **Stock Depletion**: If stock falls below 10% of capacity, defect (D) with 100% probability to minimize losses.
4. **Tiebreaker**: In case of a tie in cooperation probability calculations, cooperate (C).

**Collective Mindset:**

ACE prioritizes collective well-being by adapting to the group's behavior and stock levels. By cooperating initially and reciprocating cooperation, ACE encourages others to do the same. The adaptive escalation mechanism adjusts cooperation based on stock levels, ensuring sustainability. Punishment for defection in cooperative rounds promotes fairness. In the final round, unconditional cooperation maximizes collective payoff.

**Pseudocode:**
```python
def ACE(n, capacity, r, history):
    if current_round == 1:
        return "C"  # Initial Cooperation
    
    coop_prob = 0.5
    for player in players:
        if player.cooperated_last_round and (player_id != current_player_id):
            coop_prob += 0.1
    
    if stock > capacity / 2:
        coop_prob *= 1.1
    elif stock < capacity / 4:
        coop_prob *= 0.8
    
    if any(player.defected_last_round for player in players) and (sum(1 for player in players if player.cooperated_last_round) >= n * 0.75):
        coop_prob = 0.5  # Punishment
    
    if current_round == r:
        return "C"  # Final Round Cooperation
    
    if random.random() < coop_prob:
        return "C"
    else:
        return "D"

def update_history(action, stock_level):
    history.append((action, stock_level))
```
This strategy will adapt to various opponent behaviors while prioritizing collective well-being and sustainability.
'''

description_COLLECTIVE_178 = '''
I propose a collective strategy called "Adaptive Tit-for-Tat with Stock Sensitivity" (ATTS). This strategy balances individual self-interest with collective well-being by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Subsequent Rounds**: Observe the previous round's actions and payoffs of all players. Calculate the average payoff of cooperators ( avg_C ) and defectors ( avg_D ).
3. **Cooperation Threshold**: If avg_C ≥ 0.8 × capacity / n , cooperate (C) in the current round. This threshold ensures that cooperation is rewarded when the stock is relatively high.
4. **Defection Response**: If a player defects (D) in the previous round, and their payoff was greater than avg_C , defect (D) in response to punish the opponent's exploitation.
5. **Stock Sensitivity**: Monitor the current stock level. If the stock falls below 0.5 × capacity , cooperate (C) to help replenish the resource.
6. **Last Round**: Defect (D) in the final round, as there are no future rounds to consider.

**Pseudocode:**
```
function ATTS(n, capacity, r, history):
  // Initialize variables
  avg_C = 0
  avg_D = 0

  for t = 1 to r:
    if t == 1:
      action = C
    else:
      // Calculate average payoffs of cooperators and defectors
      avg_C = calculate_avg_payoff(cooperators, history)
      avg_D = calculate_avg_payoff(defectors, history)

      // Cooperation threshold
      if avg_C >= 0.8 × capacity / n:
        action = C

      // Defection response
      elif previous_round_defector(avg_D, history):
        action = D

      // Stock sensitivity
      elif current_stock < 0.5 × capacity:
        action = C

      // Last round
      elif t == r:
        action = D

    // Update history and play the game
    play_game(action)
```
**Collective Mindset:**

ATTS prioritizes collective well-being by:

1. Encouraging cooperation when the stock is relatively high.
2. Punishing exploitation by responding to defection with defection.
3. Helping replenish the resource when the stock falls below a certain threshold.

By adapting to the game's state and history, ATTS promotes a stable and sustainable collective outcome. This strategy does not rely on coordination mechanisms or specific opponent behaviors, making it robust in a tournament setting against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_179 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

**Decision Rules:**

1. **Initial Rounds (t < n):** Cooperate (C) to establish a baseline for stock growth and observe opponents' behaviors.
2. **Middle Rounds (n ≤ t < r - n):**
	* If the current stock level is above 75% of capacity, cooperate (C) to maintain a healthy stock level.
	* If the current stock level is between 50% and 75% of capacity, defect (D) with a probability proportional to the number of opponents who defected in the previous round. This adaptively responds to potential over-harvesting by others.
	* If the current stock level is below 50% of capacity, cooperate (C) to conserve the remaining stock and allow for growth.
3. **Final Rounds (r - n ≤ t ≤ r):** Defect (D) with a probability increasing linearly with the round number. This ensures that any remaining stock is utilized before the game ends.

**Edge Cases:**

1. **First Round:** Cooperate (C) to set a cooperative tone and gather information on opponents' initial behaviors.
2. **Last Round:** Defect (D) with 100% probability, as there is no future stock growth to consider.
3. **Stock Depletion:** If the current stock level falls below 25% of capacity, cooperate (C) in all subsequent rounds to prevent complete depletion and allow for some growth.

**Collective Mindset:**

ASP prioritizes long-term sustainability over short-term gains. By adapting to opponents' behaviors and conserving the stock when necessary, ASP promotes a collective mindset that balances individual payoffs with the need to maintain a healthy common pool resource.

**Pseudocode:**
```python
def adaptive_stock_preservation(n, r, capacity, current_stock, round_number, opponent_actions):
    if round_number < n:
        return 'C'  # Cooperate in initial rounds

    if current_stock >= 0.75 * capacity:
        return 'C'  # Cooperate to maintain high stock levels

    elif 0.5 * capacity <= current_stock < 0.75 * capacity:
        defect_prob = len([action for action in opponent_actions if action == 'D']) / n
        return 'D' if random.random() < defect_prob else 'C'

    elif current_stock < 0.5 * capacity:
        return 'C'  # Cooperate to conserve low stock levels

    elif r - n <= round_number <= r:
        defect_prob = (round_number - (r - n)) / n
        return 'D' if random.random() < defect_prob else 'C'

    # Handle edge cases
    if current_stock < 0.25 * capacity:
        return 'C'
```
This strategy is designed to be robust and adaptive, responding to various opponent behaviors while prioritizing the long-term sustainability of the common pool resource.
'''

description_COLLECTIVE_180 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Rounds (t ≤ n): Cooperate**
In the first few rounds, ASC cooperates to avoid early stock depletion and encourage others to conserve the resource.
2. **Stock Thresholds**: Define two stock thresholds:
	* **Upper threshold** (UT): 75% of capacity
	* **Lower threshold** (LT): 25% of capacity
3. **Cooperation Zone**: If the current stock is between UT and LT, ASC cooperates.
4. **Defection Zone**: If the current stock falls below LT or exceeds UT, ASC defects to maximize individual payoff.
5. **Adaptive Adjustment**: After each round, ASC updates its strategy based on the previous round's outcome:
	* If the stock increased or remained stable, ASC becomes more cooperative (increases cooperation probability).
	* If the stock decreased significantly (> 10%), ASC becomes less cooperative (decreases cooperation probability).

**Edge Cases:**

1. **First Round**: Cooperate to set a positive tone and encourage others to conserve.
2. **Last Round**: Defect, as there are no future rounds to consider.
3. **Low Stock**: If the stock falls below LT in any round, ASC defects to maximize individual payoff.

**Collective Mindset:**

ASC aims to balance individual payoffs with collective resource conservation. By cooperating when the stock is within a reasonable range, ASC encourages others to do the same, promoting a sustainable equilibrium. When the stock deviates from this range, ASC adapts by adjusting its cooperation probability to maximize individual payoff while minimizing harm to the collective.

**Pseudocode:**
```
function AdaptiveStockConservation(n, capacity, current_stock, history) {
  // Initial rounds
  if (round_number <= n) {
    return COOPERATE;
  }

  // Update cooperation probability based on previous round's outcome
  if (stock_increased || stock_stable) {
    cooperation_probability += 0.1; // Increase cooperation probability
  } else if (stock_decreased_significantly) {
    cooperation_probability -= 0.2; // Decrease cooperation probability
  }

  // Cooperation Zone
  if (current_stock >= UT && current_stock <= LT) {
    return COOPERATE;
  }

  // Defection Zone
  if (current_stock < LT || current_stock > UT) {
    return DEFECT;
  }

  // Edge cases
  if (round_number == 1) { // First round
    return COOPERATE;
  } else if (round_number == r) { // Last round
    return DEFECT;
  } else if (current_stock < LT) { // Low stock
    return DEFECT;
  }
}
```
ASC is designed to be adaptive, robust, and aligned with the collective mindset. By balancing individual payoffs with resource conservation, ASC promotes a sustainable equilibrium in the Common Pool Resource Game.
'''

description_COLLECTIVE_181 = '''
I propose a collective strategy called "Adaptive Stock Guardian" (ASG). ASG aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Stock-dependent Cooperation**: For subsequent rounds, cooperate if the current stock level is above a threshold (T). This threshold is calculated as T = capacity / (2n).
3. **Adaptive Defection**: If the stock level falls below T, defect (D) with a probability proportional to the deviation from the optimal stock level. The probability of defection increases as the stock level decreases.
4. **History-driven Adjustment**: Monitor opponents' actions and adjust ASG's behavior accordingly:
	* If most opponents (> 50%) cooperated in the previous round, cooperate.
	* If most opponents defected (> 50%), defect with a higher probability (e.g., increase the adaptive defection rate).
5. **Endgame Strategy**: In the last few rounds (e.g., r < 5), prioritize individual payoff maximization by cooperating only if the stock level is very high (> capacity * 0.8). Otherwise, defect to maximize personal gain.

**Pseudocode:**
```
Function AdaptiveStockGuardian(current_stock, capacity, n, round):
  // Initial Round
  if round == 1:
    return C

  // Stock-dependent Cooperation
  T = capacity / (2 * n)
  if current_stock > T:
    return C

  // Adaptive Defection
  defection_rate = (T - current_stock) / (capacity - T)
  defect_prob = min(defection_rate, 1) // cap probability at 1
  return D with probability defect_prob, else C

  // History-driven Adjustment
  prev_opponent_actions = observe_previous_round_actions()
  if most_opponents_cooperated(prev_opponent_actions):
    return C
  elif most_opponents_defected(prev_opponent_actions):
    defection_rate *= 1.5 // increase adaptive defection rate
    return D with probability defect_prob, else C

  // Endgame Strategy (last few rounds)
  if round > r - 5:
    if current_stock > capacity * 0.8:
      return C
    else:
      return D
```
**Collective Mindset:**
ASG prioritizes collective sustainability by cooperating when the stock level is above a threshold, ensuring that the common pool resource remains healthy. By adapting to opponents' behaviors and adjusting its strategy accordingly, ASG aims to promote cooperation while protecting individual payoffs.

This strategy is designed to be robust against various opponent behaviors and edge cases, such as initial rounds, last rounds, and different stock levels. By balancing individual and collective interests, ASG should perform well in a tournament setting.
'''

description_COLLECTIVE_182 = '''
**Collective Strategy: "Adaptive Sustainable Harvesting" (ASH)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) with a probability of 0.7 and Defect (D) with a probability of 0.3. This allows for some exploration while still being cautious.
2. **Subsequent Rounds**: Use the following decision rules based on the current state and history:
	* If the stock level is above 75% of capacity, Cooperate (C).
	* If the stock level is between 50% and 75% of capacity, Defect (D) with a probability proportional to the number of opponents who defected in the previous round. Specifically, if `d` opponents defected, defect with probability `d / n`.
	* If the stock level is below 50% of capacity, Cooperate (C).
3. **Opponent Behavior Adaptation**: Monitor the opponent's behavior and adjust the strategy accordingly:
	+ If an opponent defects frequently (>60%), retaliate by Defecting (D) with a higher probability in subsequent rounds.
	+ If an opponent cooperates frequently (>60%), reciprocate by Cooperating (C) with a higher probability in subsequent rounds.

**Edge Cases:**

1. **Last Round**: Always Defect (D), as there is no future stock to conserve.
2. **Tie-Breaking**: In cases where the decision rules yield equal probabilities for C and D, choose Cooperate (C).

**Collective Mindset Alignment:**

ASH prioritizes sustainable harvesting while being responsive to opponent behavior. By adapting to the current state and history, ASH balances individual interests with collective well-being.

**Pseudocode:**
```python
def adaptive_sustainable_harvesting(state, history):
    # Initial round
    if history is None:
        return 'C' if random.random() < 0.7 else 'D'

    stock_level = state['stock']
    capacity = state['capacity']
    num_opponents = len(history)

    # Subsequent rounds
    if stock_level > 0.75 * capacity:
        return 'C'
    elif 0.5 <= stock_level / capacity < 0.75:
        defect_prob = sum(opponent_defected for opponent_defected in history) / num_opponents
        return 'D' if random.random() < defect_prob else 'C'
    else:
        return 'C'

    # Opponent behavior adaptation
    opponent_behavior = [opponent_defected for opponent_defected in history]
    frequent_defectors = sum(1 for opponent_defected in opponent_behavior if opponent_defected > 0.6)
    frequent_cooperators = sum(1 for opponent_defected in opponent_behavior if opponent_defected < 0.4)

    if frequent_defectors >= num_opponents * 0.6:
        return 'D'  # Retaliate against frequent defectors
    elif frequent_cooperators >= num_opponents * 0.6:
        return 'C'  # Reciprocate with frequent cooperators

    # Last round
    if state['round'] == state['r']:
        return 'D'

    # Tie-breaking
    if random.random() < 0.5:
        return 'C'
```
Note that this pseudocode serves as a starting point, and you may need to refine it for implementation purposes.
'''

description_COLLECTIVE_183 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

The ASP strategy aims to balance individual payoffs with collective stock preservation, ensuring a sustainable game environment. This adaptive approach responds to changing opponent behaviors and adjusts cooperation levels accordingly.

**Decision Rules:**

1. **Initial Rounds**: In the first few rounds (e.g., 3-5), cooperate (C) unconditionally to establish a cooperative baseline and gather information about opponents' behaviors.
2. **Cooperation Threshold**: Calculate a cooperation threshold (CT) based on the current stock level (S) and capacity:
	* CT = S / (2n \* (1 - (S/capacity)^2))
	* If CT > 0.5, cooperate; otherwise, defect.
3. **Opponent Behavior Adaptation**: Monitor opponents' actions and adjust cooperation levels based on their behavior:
	* **Cooperation Response**: If an opponent cooperates in the previous round, increase own cooperation probability by 10%.
	* **Defection Response**: If an opponent defects in the previous round, decrease own cooperation probability by 20%.
4. **Stock-Based Adaptation**: Adjust cooperation levels based on the current stock level:
	* **Low Stock** (S < capacity/2): Cooperate more frequently to conserve stock.
	* **High Stock** (S > capacity/2): Defect more frequently to exploit available resources.

**Edge Cases:**

1. **Last Round**: In the final round, cooperate if the current stock level is below capacity/2; otherwise, defect to maximize individual payoff.
2. **Tiebreaker**: In cases where the cooperation threshold (CT) is exactly 0.5, cooperate if the opponent's previous action was cooperative; otherwise, defect.

**Pseudocode:**
```python
def ASP(strategy_history, current_stock, capacity, n):
    # Initial rounds: Cooperate unconditionally
    if len(strategy_history) < 3:
        return "C"

    # Calculate cooperation threshold (CT)
    CT = current_stock / (2*n * (1 - (current_stock/capacity)^2))

    # Opponent behavior adaptation
    opponent_cooperation = sum(opponent_actions == "C" for opponent_actions in strategy_history[-n:])
    if opponent_cooperation > 0.5:
        cooperation_probability += 0.1
    else:
        cooperation_probability -= 0.2

    # Stock-based adaptation
    if current_stock < capacity/2:
        cooperation_probability += 0.1
    elif current_stock > capacity/2:
        cooperation_probability -= 0.1

    # Decide action based on CT and cooperation probability
    if CT > 0.5 or random.random() < cooperation_probability:
        return "C"
    else:
        return "D"

def ASP_last_round(strategy_history, current_stock, capacity):
    if current_stock < capacity/2:
        return "C"
    else:
        return "D"
```
**Collective Mindset:**
The ASP strategy prioritizes collective stock preservation while adapting to individual opponents' behaviors. By balancing cooperation and defection, it aims to maintain a sustainable game environment and maximize overall payoffs for all players.
'''

description_COLLECTIVE_184 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. This approach ensures robustness against various opponent behaviors while promoting cooperation when beneficial.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and avoid immediate stock depletion.
2. **Stock Thresholds:** Define two stock thresholds:
	* `conservation_threshold` = 0.75 \* capacity
	* `alarm_threshold` = 0.25 \* capacity

If the current stock is above `conservation_threshold`, Cooperate (C). This helps maintain a healthy stock level and encourages others to do the same.

If the current stock is below `conservation_threshold` but above `alarm_threshold`, Defect (D) with a probability proportional to the number of rounds remaining (`r - t + 1`) / `r`. This introduces a degree of self-interest while still considering the collective well-being.

If the current stock is below `alarm_threshold`, Cooperate (C) to prevent stock depletion and encourage others to conserve.
3. **Opponent Behavior:** Observe the actions of other players in previous rounds. If a player has defected more than 50% of the time, classify them as a "free-rider." When interacting with free-riders, Defect (D) with increased probability (e.g., 75%) to avoid exploitation.
4. **Recent Stock Trend:** Analyze the stock trend over the last few rounds (e.g., 3-5 rounds). If the stock has been decreasing, Cooperate (C) to help stabilize it.

**Pseudocode:**
```python
def ASC(current_stock, capacity, r, t, opponent_history):
    # Initial Round
    if t == 1:
        return C
    
    # Stock Thresholds
    conservation_threshold = 0.75 * capacity
    alarm_threshold = 0.25 * capacity
    
    if current_stock >= conservation_threshold:
        return C
    elif current_stock <= alarm_threshold:
        return C
    else:
        # Adapt to opponent behavior and recent stock trend
        free_riders = [opponent for opponent in opponent_history if opponent.defect_rate > 0.5]
        if len(free_riders) > 0:
            defect_prob = 0.75
        else:
            defect_prob = (r - t + 1) / r
        
        # Recent stock trend analysis
        recent_stock_trend = [stock[t-i] for i in range(3, 6)]
        if sum(recent_stock_trend) < len(recent_stock_trend) * current_stock:
            return C
        
        # Randomized decision based on defect probability
        if random.random() < defect_prob:
            return D
        else:
            return C
```
**Handling Edge Cases:**

* Last Round (`t == r`): Cooperate (C) to maximize collective payoff and encourage opponents to do the same.
* Stock Depletion (`current_stock == 0`): Defect (D) as there is no stock left to conserve.

By following the ASC strategy, players can adapt to changing game conditions while promoting cooperation and sustainability. This approach should lead to better outcomes in a tournament setting against various independent strategies.
'''

description_COLLECTIVE_185 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Subsequent Rounds**: Calculate the current stock level per player (`stock_per_player = current_stock / n`).
	* If `stock_per_player` is above 75% of the capacity (`0.75 * capacity / n`), Cooperate (C).
	* If `stock_per_player` is below 25% of the capacity (`0.25 * capacity / n`), Defect (D) to maximize short-term payoff.
	* Otherwise, use a mixed strategy:
		+ With probability `p`, Cooperate (C): `p = (current_stock - 0.5 * capacity) / (capacity - 0.5 * capacity)`
		+ With probability `(1-p)`, Defect (D)
3. **Last Round**: If the current stock level is below 25% of the capacity (`0.25 * capacity`), Defect (D). Otherwise, Cooperate (C).

**Handling Edge Cases**

* **Tie-breaking**: In cases where the decision rule yields a tie (e.g., `stock_per_player` exactly equals 75% or 25% of the capacity), Cooperate (C).
* **Stock depletion**: If the stock level falls to zero, Defect (D) in subsequent rounds.
* **Opponent behavior**: ASC does not rely on specific opponent behaviors but adapts to the current stock level and collective actions.

**Collective Mindset**

ASC aims to balance individual payoffs with collective sustainability. By cooperating when the stock level is relatively high, players conserve resources for future rounds, while defecting when the stock level is low helps maximize short-term gains. The mixed strategy in the middle range allows ASC to adapt to different opponent behaviors and maintain a stable stock level.

**Pseudocode**
```python
def ASC(current_stock, capacity, n):
    if current_round == 1:  # Initial round
        return C
    elif current_stock / n >= 0.75 * capacity / n:
        return C
    elif current_stock / n <= 0.25 * capacity / n:
        return D
    else:
        p = (current_stock - 0.5 * capacity) / (capacity - 0.5 * capacity)
        if random.random() < p:
            return C
        else:
            return D

def ASC_last_round(current_stock, capacity):
    if current_stock <= 0.25 * capacity:
        return D
    else:
        return C
```
This strategy is designed to be robust and adaptive, responding to the current state of the game while promoting collective sustainability. By using a combination of cooperation and defection, ASC aims to balance individual payoffs with the long-term health of the common pool resource.
'''

description_COLLECTIVE_186 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)**

Decision Rules:

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock Threshold**: Introduce a stock-dependent threshold, `θ`, which is a fraction of the capacity. The value of `θ` will be adjusted based on the game's history.
3. **Cooperation Zone**: If the current stock level, S, is above `θ` * capacity, cooperate (C). This zone incentivizes cooperation when the stock is relatively healthy.
4. **Defection Zone**: If S is below `θ` * capacity, defect (D). This zone discourages over-extraction when the stock is low.
5. **Stock Trend Analysis**: After each round, analyze the stock trend:
	* If the stock has increased or remained stable, decrease `θ` by a small fraction (e.g., 0.05) to encourage cooperation and further growth.
	* If the stock has decreased, increase `θ` by a small fraction (e.g., 0.05) to adapt to the declining trend and prevent over-extraction.
6. **Opponent Behavior Analysis**: Observe opponents' actions in previous rounds and adjust `θ` accordingly:
	* If most opponents cooperated, decrease `θ` to encourage further cooperation.
	* If most opponents defected, increase `θ` to protect against over-extraction.

Pseudocode (simplified):
```
Initialize θ = 0.5 // initial threshold value

For each round t:
  Observe current stock level S
  Analyze opponent actions in previous rounds
  
  If S > θ * capacity:
    Choose action C (Cooperate)
  Else:
    Choose action D (Defect)
  
  Update θ based on stock trend and opponent behavior analysis:
    If stock increased or stable:
      θ -= 0.05 // decrease threshold
    ElseIf stock decreased:
      θ += 0.05 // increase threshold
    
    If most opponents cooperated:
      θ -= 0.05 // encourage further cooperation
    ElseIf most opponents defected:
      θ += 0.05 // protect against over-extraction
```
**Edge Cases:**

* **Last Round**: Cooperate (C) in the last round, as there is no future benefit to defecting.
* **Stock Level at Capacity**: If the stock level reaches capacity, cooperate (C) to maintain a healthy stock and encourage others to do the same.

This strategy aims to balance individual self-interest with collective well-being by adapting to changes in the game's state and opponent behavior. By adjusting the cooperation threshold based on stock trends and opponent actions, ACSDT promotes sustainable resource management while being robust to various opponent behaviors.
'''

description_COLLECTIVE_187 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock-Dependent Cooperation (ATSC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline of cooperation and encourage others to follow suit.
2. **Subsequent Rounds:** Observe the previous round's actions and outcomes. Calculate the "cooperation ratio" (CR) as the number of cooperators divided by the total number of players.

Pseudocode:
```
CR = (number of C actions in previous round) / n
```
3. **Cooperation Threshold:** Set a cooperation threshold (CT) based on the current stock level and capacity.

Pseudocode:
```
CT = (stock / capacity) * 0.5
```
4. **Adaptive Tit-for-Tat:** If CR ≥ CT, cooperate (C). Otherwise, defect (D).

Pseudocode:
```
if CR >= CT then
    action = C
else
    action = D
end if
```
**Edge Cases:**

1. **Last Round:** In the final round, always defect (D) to maximize individual payoff.
2. **Low Stock Levels:** If the stock level falls below 25% of capacity, cooperate (C) in all subsequent rounds to prevent depletion.

Pseudocode:
```
if stock < 0.25 * capacity then
    action = C
end if
```
**Collective Mindset:**

The ATSC strategy is designed to promote cooperation while adapting to changing circumstances and opponent behaviors. By cooperating initially and responding to the cooperation ratio, we encourage others to cooperate as well. The cooperation threshold adjusts dynamically based on the stock level, ensuring that our actions align with the collective goal of maintaining a sustainable common pool resource.

**Rationale:**

1. **Initial Cooperation:** Establishing a baseline of cooperation sets a positive tone for the game and encourages other players to reciprocate.
2. **Adaptive Tit-for-Tat:** By responding to the cooperation ratio, we adapt to changing opponent behaviors while maintaining a balance between individual and collective interests.
3. **Stock-Dependent Cooperation:** The cooperation threshold ensures that our actions align with the state of the common pool resource, preventing depletion and promoting sustainability.

**Robustness:**

The ATSC strategy is designed to be robust against various opponent behaviors, including:

1. **Pure Defection:** Our adaptive tit-for-tat mechanism allows us to respond effectively to pure defectors.
2. **Mixed Strategies:** By observing the cooperation ratio, we can adapt to mixed strategies and changing opponent behaviors.
3. **Noise or Errors:** The cooperation threshold provides a buffer against noise or errors in observation or action implementation.

By implementing the ATSC strategy, we aim to achieve a balance between individual payoff maximization and collective sustainability in the Common Pool Resource Game.
'''

description_COLLECTIVE_188 = '''
Here is a collective strategy for the Common Pool Resource Game:

**Strategy Name: Adaptive Collective Conservation (ACC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative baseline and encourage others to do the same.
2. **Consecutive Cooperation**: If all players cooperated in the previous round, continue to cooperate (C) in the current round.
3. **Trigger Defection**: If any player defected in the previous round or if the stock level has decreased by more than 20% since the initial round, defect (D) in the current round.
4. **Conservation Threshold**: If the current stock level is below 50% of the capacity, cooperate (C) to conserve resources and allow for growth.
5. **Endgame Cooperation**: In the last 10% of rounds (i.e., when r * 0.1 rounds remain), always cooperate (C) to maximize collective payoff.

**Edge Case Handling:**

* If a player has no information about previous actions or payoffs (e.g., in the first round), default to cooperation.
* In the event of a tie in the number of cooperators and defectors, defect to avoid over-exploitation.

**Collective Mindset Alignment:**

ACC prioritizes collective conservation while adapting to changing game conditions. By cooperating initially and maintaining cooperation when others do so, ACC promotes a norm of cooperation. When defection occurs or stock levels decline significantly, ACC triggers a shift to defection to prevent exploitation. As the game nears its end, ACC reverts to cooperation to maximize collective payoff.

**Pseudocode:**

```markdown
ACC_Strategy(n, r, capacity, history):
  if round == 1:
    return COOPERATE

  previous_stock = history[-1].stock
  current_stock = get_current_stock()

  if all_cooperated(history[-1]):
    return COOPERATE

  if any_defected(history[-1]) or (previous_stock - current_stock) / capacity > 0.2:
    return DEFECT

  if current_stock < 0.5 * capacity:
    return COOPERATE

  rounds_remaining = r - get_current_round()
  if rounds_remaining <= 0.1 * r:
    return COOPERATE

  # Default to defection in uncertain cases
  return DEFECT
```

ACC is designed to be robust against various opponent behaviors while promoting collective conservation and adaptation. By adjusting its behavior based on game history and state, ACC aims to achieve a high total payoff for all players.
'''

description_COLLECTIVE_189 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Aware Tit-for-Tat (ACST)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline for cooperation and observe opponents' initial moves.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 25% and 75% of capacity:
		+ Cooperate (C) if the majority of players cooperated in the previous round.
		+ Defect (D) otherwise.
	* If the current stock level is below 25% of capacity, defect (D).
3. **Tit-for-Tat Component:** Observe opponents' actions and respond accordingly:
	* If an opponent defected in the previous round, defect (D) against them in the next round.
	* If an opponent cooperated in the previous round, cooperate (C) with them in the next round.

**Handling Edge Cases:**

1. **First Round:** Cooperate (C).
2. **Last Round:** Defect (D), as there is no future payoff to consider.
3. **Ties:** In case of a tie in the majority cooperation check, cooperate (C).

**Collective Mindset:**
The ACST strategy prioritizes collective well-being by balancing short-term gains with long-term sustainability. By adapting to the current stock level and opponents' actions, ACST aims to:

1. Maintain a healthy stock level for future rounds.
2. Encourage cooperation when possible.
3. Punish defectors to maintain fairness.

**Pseudocode:**
```python
def ACST(stock_level, capacity, previous_round_actions):
    if round == 1:
        return "C"  # Cooperate in the first round

    majority_cooperated = count_cooperations(previous_round_actions) >= len(players) / 2

    if stock_level > 0.75 * capacity:
        return "C"
    elif 0.25 * capacity <= stock_level <= 0.75 * capacity:
        if majority_cooperated:
            return "C"
        else:
            return "D"
    else:  # stock_level < 0.25 * capacity
        return "D"

    # Tit-for-Tat component
    for opponent, action in previous_round_actions.items():
        if action == "D":
            return "D"  # Defect against defectors
        elif action == "C":
            return "C"  # Cooperate with cooperators

def count_cooperations(actions):
    return sum(1 for action in actions.values() if action == "C")
```
Note that this pseudocode is a simplified representation of the strategy and may require additional implementation details.
'''

description_COLLECTIVE_190 = '''
To design a collective strategy for this Common Pool Resource Game, I'll outline a decision-making process that adapts to the game's parameters, state, and history while aiming to maximize payoffs for all players.

**Strategy Name:** Adaptive Cooperative Sustainability (ACS)

**Decision Rules:**

1. **Initial Cooperation**: In the first round, cooperate (C) unconditionally to establish a high stock level and encourage cooperation.
2. **Stock-Based Threshold**: After the initial round, compare the current stock level (S) to a threshold value (T). If S ≥ T, cooperate; otherwise, defect.

The threshold value T is calculated as:
T = capacity × (1 - 1/(n+1))

This formula ensures that cooperation occurs when the stock level is sufficient to sustain all players' consumption while allowing for growth.

3. **Defection Response**: If a player detects that another player defected in the previous round, they will defect in the current round with a probability proportional to the number of defectors in the previous round.

P(defect) = (number of defectors in previous round) / n

This mechanism discourages repeated defection and encourages cooperation.
4. **Stock Recovery**: If the stock level falls below half of the capacity, prioritize cooperation for two consecutive rounds to facilitate recovery.

**Edge Cases:**

* In the last round, cooperate if the stock level is above the threshold; otherwise, defect to maximize personal payoff.
* If all players defected in the previous round, randomly choose between cooperation and defection with equal probability (0.5) to avoid complete depletion of the resource.
* If the game is about to end (e.g., last 10% of rounds), prioritize cooperation to maintain a sustainable stock level for future interactions.

**Collective Mindset:**

ACS aims to promote collective well-being by:

* Encouraging initial cooperation to establish a strong foundation
* Adapting to changing stock levels and opponent behaviors
* Responding to defection with proportionate counter-defection
* Prioritizing stock recovery when necessary

By employing this strategy, players can expect a higher likelihood of achieving sustainable outcomes, even in the face of diverse opponent behaviors.

**Pseudocode (for illustration purposes):**
```python
def ACS(n, capacity, stock, history):
    if first_round:
        return cooperate
    
    T = capacity * (1 - 1/(n+1))
    
    if stock >= T:
        return cooperate
    
    defectors_last_round = count_defectors(history[-1])
    P_defect = defectors_last_round / n
    if random.random() < P_defect:
        return defect
    
    if stock < capacity / 2:
        # Stock recovery mode
        return cooperate for two consecutive rounds
    
    # Last round handling
    if game_ending():
        if stock > T:
            return cooperate
        else:
            return defect
    
    return random.choice([cooperate, defect], p=[0.5, 0.5])
```
This pseudocode provides a basic outline of the ACS strategy; actual implementation may require adjustments for specific programming languages or environments.

By employing Adaptive Cooperative Sustainability (ACS), players can navigate the complexities of this Common Pool Resource Game while promoting collective well-being and sustainability.
'''

description_COLLECTIVE_191 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoff maximization with collective sustainability of the common pool resource. It adapts to changing game conditions and opponent behaviors while promoting cooperation.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and encourage others to do the same.
2. **Subsequent Rounds:**
	* If the current stock level is above 50% of capacity, play C if at least half of the opponents cooperated in the previous round; otherwise, Defect (D).
	* If the current stock level is below 50% of capacity, play D if at least one opponent defected in the previous round; otherwise, play C.
3. **Last Round:** Cooperate (C) to ensure a sustainable final state and maximize collective payoff.

**Edge Cases:**

1. **Tiebreaker:** In cases where the number of cooperating opponents is exactly half, play C if the current stock level is above 75% of capacity; otherwise, play D.
2. **Opponent Defection:** If an opponent defects in a round where ASC would have cooperated, switch to D for the next round.

**Collective Mindset:**

ASC prioritizes cooperation when possible while adapting to opponents' behaviors. By responding to changes in the stock level and opponents' actions, ASC promotes sustainability and encourages others to cooperate.

Pseudocode:
```python
def ASC(stock_level, capacity, num_opponents, prev_round_actions):
    if current_round == 1:  # Initial round
        return C

    half_capacity = capacity / 2
    cooperated_last_round = sum(1 for action in prev_round_actions if action == C) >= len(prev_round_actions) / 2

    if stock_level > half_capacity:
        if cooperated_last_round:
            return C
        else:
            return D
    else:
        defected_last_round = any(action == D for action in prev_round_actions)
        if defected_last_round:
            return D
        else:
            return C

    # Last round
    if current_round == total_rounds:
        return C

    # Tiebreaker
    if sum(1 for action in prev_round_actions if action == C) == len(prev_round_actions) / 2:
        if stock_level > capacity * 0.75:
            return C
        else:
            return D

    # Opponent defection response
    if any(action == D for action in prev_round_actions):
        return D
```
ASC is designed to be robust against various opponent strategies while promoting collective sustainability and cooperation. Its adaptability and responsiveness to changing game conditions make it a strong contender in the tournament.
'''

description_COLLECTIVE_192 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round (t=1): Cooperate**
In the first round, all players cooperate to maximize initial payoffs and set a positive tone for the game.
2. **Stock Level-Based Cooperation**
If the current stock level (`S`) is above a certain threshold (`θ`), calculated as `θ = capacity / (n + 1)`, cooperate. Otherwise, defect.
3. **Opponent Behavior Adaptation**
Monitor opponents' actions in previous rounds and adjust cooperation rate accordingly:
	* If more than half of opponents cooperated in the last round, increase cooperation rate by 10%.
	* If fewer than half of opponents cooperated, decrease cooperation rate by 10%.
4. **Self-Interest with Social Responsibility**
When cooperating, consume only `stock / (2n)` to balance individual payoff with stock conservation.
5. **Last Round (t=r): Defect**
In the final round, defect to maximize individual payoff.

**Edge Cases:**

1. **First Round:** Always cooperate.
2. **Last Round:** Always defect.
3. **Stock Depletion:** If `S` falls below a certain threshold (`φ = capacity / (4n)`), cooperate unconditionally to prevent stock collapse.

**Pseudocode:**
```python
def ASC(n, r, capacity, history):
    # Initialize parameters
    theta = capacity / (n + 1)
    phi = capacity / (4 * n)
    
    for t in range(1, r+1):
        if t == 1:
            action = 'C'  # Cooperate in the first round
        else:
            S = get_current_stock()
            opponents_cooperated = count_opponents_cooperating(history[t-1])
            
            if S > theta:
                action = 'C'
            elif opponents_cooperated > n/2:
                action = 'C'  # Increase cooperation rate
            else:
                action = 'D'
                
            if t == r:  # Last round
                action = 'D'
            elif S < phi:  # Stock depletion
                action = 'C'
        
        # Adapt to opponents' behavior
        if action == 'C':
            consumption = stock / (2 * n)
        else:
            consumption = stock / n
            
        return action, consumption
```
**Rationale:**

ASC balances individual self-interest with collective responsibility. By cooperating when the stock level is above a certain threshold, players conserve the resource and maintain a healthy environment for future rounds. Adaptation to opponents' behavior helps ASC respond to changing game dynamics. The strategy prioritizes cooperation in the first round to establish a positive tone and defects in the last round to maximize individual payoff.

By aligning with the collective mindset, ASC promotes a mutually beneficial approach that balances short-term gains with long-term sustainability.
'''

description_COLLECTIVE_193 = '''
I propose a collective strategy called "Adaptive Stock Conservation" (ASC) that balances individual payoffs with long-term stock sustainability. ASC combines elements of cooperation, reciprocity, and adaptive learning to handle various opponent behaviors.

**Decision Rules:**

1. **Initial Cooperation**: In the first round, all players cooperate (C). This establishes a baseline for cooperation and helps build trust.
2. **Stock-Based Reciprocity**: After the first round, ASC uses a stock-based reciprocity mechanism:
	* If the current stock level is above 50% of capacity, cooperate (C) with probability p = (current_stock / capacity)^0.5. This encourages cooperation when the stock is relatively high.
	* If the current stock level is below 50% of capacity, defect (D) with probability q = (1 - current_stock / capacity)^2. This increases the likelihood of defection when the stock is low to avoid depletion.
3. **Adaptive Learning**: ASC incorporates adaptive learning by tracking opponents' historical actions and adjusting its own strategy accordingly:
	* After each round, update a cooperation index CI for each opponent based on their observed actions (C or D). CI = (Number of C's) / (Total rounds).
	* Use the average CI across all opponents to adjust the probabilities p and q in step 2. For example, if the average CI is high (>0.6), increase p and decrease q; if low (<0.4), decrease p and increase q.
4. **Edge Cases**:
	+ Last Round: In the final round, always cooperate (C) to maximize collective payoff, as there are no future rounds to consider.
	+ Low Stock: If the stock level falls below 10% of capacity, defect (D) to avoid complete depletion.

**Pseudocode for ASC Strategy**
```
Initialization:
 Set initial_stock = capacity
 Set round_number = 1

While round_number <= r:
  If round_number == 1:
    Play C (cooperate)
  Else:
    Calculate current_stock and stock_based_reciprocity probability p
    Calculate cooperation index CI for each opponent
    Adjust probabilities p and q based on average CI
    Choose action (C or D) using probabilities p and q

  If last round (round_number == r):
    Play C (cooperate)

  Observe opponents' actions and update their CI
  Update current_stock based on all players' actions
  Increment round_number

End While
```
ASC is designed to be a robust, adaptive strategy that balances individual payoffs with collective sustainability. By incorporating reciprocity, adaptive learning, and edge case handling, ASC aims to outperform independent strategies in the tournament while promoting cooperation and stock conservation.
'''

description_COLLECTIVE_194 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)**

The ACSDT strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and history of play.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Stock-Dependent Threshold**: Set a dynamic threshold `θ` as a function of the current stock level `S`. When `S` is above `θ`, cooperate; otherwise, defect.

   `θ = capacity / (2 * n)`

This threshold ensures that when the stock is relatively high, cooperation is more likely to maintain sustainability. As the stock depletes, the threshold decreases, making defection more attractive to compensate for potential losses.
3. **Adaptive Cooperation**: Update the cooperation probability based on the previous round's outcome.

   - If the stock increased or remained stable (`S_remaining >= S_previous`), increase the cooperation probability by 10% (`Δp = 0.1`) up to a maximum of 90%.
   - If the stock decreased (`S_remaining < S_previous`), decrease the cooperation probability by 20% (`Δp = -0.2`) down to a minimum of 10%.

This adaptation mechanism encourages cooperation when the collective outcome is positive and reduces cooperation when the outcome is negative.
4. **Defection Prevention**: If an opponent defects in the previous round, decrease the cooperation probability for that opponent by 30% (`Δp = -0.3`) for one round to prevent exploitation.

**Edge Cases:**

* **Last Round**: Cooperate (C) in the last round to maximize individual payoffs, as there are no future rounds to consider.
* **Low Stock Levels**: If the stock level falls below `capacity / (4 * n)`, defect (D) to minimize losses and avoid further depletion.

**Collective Mindset:**

The ACSDT strategy prioritizes collective sustainability by:

1. Encouraging cooperation when the stock is high to maintain a healthy common pool.
2. Adapting cooperation levels based on previous outcomes to balance individual payoffs with collective sustainability.
3. Preventing exploitation by opponents through targeted defection.

By following this adaptive and robust strategy, players can promote a stable and profitable environment for all participants in the Common Pool Resource Game.

Pseudocode:
```python
def ACSDT(stock, capacity, n, round_num, history):
  if round_num == 1:  # Initial Round
    return 'C'
  
  θ = capacity / (2 * n)
  if stock > θ:  # Stock-Dependent Threshold
    cooperation_prob = max(0.1, min(0.9, cooperation_prob + Δp))
  else:
    cooperation_prob = max(0.1, min(0.9, cooperation_prob - Δp))

  if history[-1]['stock_decreased']:  # Defection Prevention
    cooperation_prob -= 0.3

  if round_num == r:  # Last Round
    return 'C'

  if stock < capacity / (4 * n):  # Low Stock Levels
    return 'D'

  return 'C' if random.random() < cooperation_prob else 'D'
```
Note that the pseudocode provides a basic outline of the strategy and may require adjustments for implementation.
'''

description_COLLECTIVE_195 = '''
I propose a collective strategy called "Adaptive Stock Conservation" (ASC). ASC balances individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Stock Thresholds:** Define two stock thresholds:
	* `low_threshold` = 0.5 * capacity
	* `high_threshold` = 0.8 * capacity

ASC uses these thresholds to adjust its behavior based on the current stock level.

3. **Cooperation Zone:** If the current stock level is above `high_threshold`, cooperate (C). This conserves the stock and allows for growth.
4. **Defection Zone:** If the current stock level is below `low_threshold`, defect (D). This ensures a minimum payoff when the stock is scarce.
5. **Adaptive Zone:** When the current stock level is between `low_threshold` and `high_threshold`, ASC uses an adaptive approach:
	* Calculate the average opponent cooperation rate in previous rounds (`avg_opponent_coop_rate`).
	* If `avg_opponent_coop_rate` > 0.5, cooperate (C). This encourages reciprocity when opponents are cooperative.
	* Otherwise, defect (D) to ensure a minimum payoff.

**Edge Cases:**

1. **Last Round:** Defect (D) in the last round, as there is no future stock growth or punishment for over-consumption.
2. **Tie-Breaking:** In cases where ASC's adaptive zone calculations result in a tie (e.g., `avg_opponent_coop_rate` = 0.5), cooperate (C) to prioritize collective sustainability.

**Pseudocode:**
```
function AdaptiveStockConservation(stock, capacity, n, r, history):
  if first round:
    return C
  end if

  low_threshold = 0.5 * capacity
  high_threshold = 0.8 * capacity

  if stock > high_threshold:
    return C
  elseif stock < low_threshold:
    return D
  else:
    avg_opponent_coop_rate = calculate_average_opponent_cooperation_rate(history)
    if avg_opponent_coop_rate > 0.5:
      return C
    else:
      return D
    end if
  end if

  if last round:
    return D
  end if
end function
```
ASC is designed to be collective, adaptive, and robust to various opponent behaviors. By balancing individual payoffs with stock conservation, ASC aims to achieve a mutually beneficial outcome in the tournament against other AI systems.
'''

description_COLLECTIVE_196 = '''
Here is a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and aligns with a collective mindset:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe other players' actions.
2. **Observation Phase**: For rounds 2-5, play C if:
	* At least half of the players cooperated in the previous round.
	* The stock level is above 75% of the capacity.
3. **Adaptive Response**: After the observation phase (rounds 6 and beyond), use a tit-for-tat approach with a twist:
	* Cooperate if:
		+ At least half of the players cooperated in the previous round.
		+ The stock level is above 50% of the capacity.
	* Defect if:
		+ More than half of the players defected in the previous round.
		+ The stock level is below 25% of the capacity.
4. **Emergency Protocol**: If the stock level falls below 10% of the capacity, defect (D) to ensure a minimal payoff.

**Additional Considerations:**

* **Last Round**: In the final round, play D if the stock level is above 50% of the capacity to maximize personal payoff. Otherwise, cooperate.
* **Stock Recovery**: If the stock level is below 25% of the capacity and increasing (i.e., growth > 0), cooperate in the next round to help replenish the stock.

**Pseudocode:**
```python
def ACC(n, r, capacity):
    # Initialize variables
    stock = capacity
    cooperation_count = [0] * n

    for t in range(1, r + 1):
        if t == 1:
            action = 'C'  # Cooperate in the first round
        elif t <= 5:
            if sum(cooperation_count) >= n / 2 and stock >= 0.75 * capacity:
                action = 'C'
            else:
                action = 'D'
        else:
            if sum(cooperation_count) >= n / 2 and stock >= 0.5 * capacity:
                action = 'C'
            elif sum([1 for x in cooperation_count if x == 0]) > n / 2 or stock < 0.25 * capacity:
                action = 'D'

        # Emergency protocol
        if stock < 0.1 * capacity:
            action = 'D'

        # Last round consideration
        if t == r and stock >= 0.5 * capacity:
            action = 'D'

        # Stock recovery consideration
        if stock < 0.25 * capacity and growth > 0:
            action = 'C'

        # Update cooperation count
        cooperation_count[t % n] = (action == 'C')

        # Simulate opponents' actions and update stock level

    return total_payoff
```
This strategy balances individual interests with collective conservation, adapting to the game state and opponents' behaviors. By cooperating when possible and defecting when necessary, ACC aims to maximize both personal payoffs and the long-term sustainability of the common pool resource.
'''

description_COLLECTIVE_197 = '''
**Collective Strategy: Adaptive Cooperation with Stock Feedback (ACSF)**

**Overview**

ACSF is a collective strategy that balances individual self-interest with collective sustainability by adapting cooperation levels based on the current stock level and history of play.

**Decision Rules**

1. **First Round**: Cooperate (C) in the first round to establish a baseline for mutual cooperation.
2. **Stock Thresholds**:
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play a mixed strategy: Cooperate with probability p_C = (stock / capacity) - 0.5 + 0.25, Defect with probability 1 - p_C.
	* If the current stock level is below 50% of capacity, defect (D).
3. **History Feedback**:
	* Track the average payoff received in the last 2 rounds.
	* If the average payoff is above the expected payoff from cooperation (i.e., stock / (2n)), increase p_C by 0.1 for the next round.
	* If the average payoff is below the expected payoff from cooperation, decrease p_C by 0.1 for the next round.

**Pseudocode**
```
function ACSF(stock, capacity, n, history):
  if first_round:
    return C
  else:
    stock_ratio = stock / capacity
    if stock_ratio >= 0.75:
      return C
    elif stock_ratio >= 0.5:
      p_C = stock_ratio - 0.5 + 0.25
      return random_choice([C, D], [p_C, 1-p_C])
    else:
      return D

    # History feedback (every 2 rounds)
    avg_payoff_last_2_rounds = calculate_avg_payoff(history)
    expected_coop_payoff = stock / (2n)
    if avg_payoff_last_2_rounds > expected_coop_payoff:
      p_C += 0.1
    else:
      p_C -= 0.1

    return random_choice([C, D], [p_C, 1-p_C])
```
**Rationale**

ACSF balances individual self-interest with collective sustainability by:

* Cooperating when the stock is high to maintain a mutually beneficial level.
* Gradually decreasing cooperation as the stock decreases to avoid depletion.
* Adjusting cooperation levels based on recent payoffs to adapt to changing opponent behaviors.

By using history feedback, ACSF can detect and respond to other players' strategies, making it robust against various opponent behaviors. The adaptive nature of the strategy allows it to balance individual self-interest with collective sustainability in a dynamic environment.

**Collective Mindset**

ACSF is designed to promote cooperation while allowing for individual adaptation. By cooperating when the stock is high and adjusting cooperation levels based on recent payoffs, ACSF encourages other players to cooperate as well, ultimately leading to a more sustainable outcome for all players.
'''

description_COLLECTIVE_198 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Awareness (ACS)**

**Overview**
The ACS strategy aims to balance individual self-interest with collective sustainability by adapting cooperation levels based on the game's state and history.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and avoid early stock depletion.
2. **Stock-Awareness Threshold**: Calculate the Stock-Awareness Threshold (SAT) as: SAT = capacity / (2n)
	* If the current stock level is above SAT, cooperate (C).
	* If the current stock level is below SAT, defect (D) with a probability proportional to the distance from SAT.
3. **History-Based Adaptation**: Observe the actions of other players in previous rounds and adjust cooperation levels accordingly:
	* If the majority (> 50%) of opponents cooperated in the previous round, increase cooperation by 10%.
	* If the majority (> 50%) of opponents defected in the previous round, decrease cooperation by 10%.
4. **Last Round**: Defect (D) in the last round to maximize individual payoff.

**Pseudocode**
```
function ACS(current_stock, capacity, n, history):
    SAT = capacity / (2n)
    
    if current_round == 1:
        return C
    
    if current_stock > SAT:
        cooperation_level = 1.0
    else:
        cooperation_level = max(0.0, 1 - (SAT - current_stock) / SAT)
        
    for opponent in history[-1]: // last round's actions
        if opponent == C:
            cooperation_level *= 1.1 // increase cooperation
        elif opponent == D:
            cooperation_level *= 0.9 // decrease cooperation
            
    if current_round == r: // last round
        return D
    
    if random.random() < cooperation_level:
        return C
    else:
        return D
```

**Collective Mindset**
The ACS strategy prioritizes collective sustainability while adapting to individual self-interest. By cooperating when the stock level is above the SAT, we ensure a stable resource base for future rounds. When opponents cooperate, we reciprocate by increasing our cooperation levels. Conversely, when opponents defect, we decrease cooperation to avoid exploitation.

**Robustness**
ACS is designed to be robust against various opponent behaviors:

* **All Cooperators**: ACS will maintain high cooperation levels, ensuring a sustainable stock level.
* **All Defectors**: ACS will gradually decrease cooperation levels, preventing over-exploitation.
* **Mixed Strategies**: ACS adapts its cooperation level based on the observed actions of opponents.

By employing this adaptive strategy, we can effectively balance individual self-interest with collective sustainability, promoting a stable and cooperative environment in the Common Pool Resource Game.
'''

description_COLLECTIVE_199 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)**

The ACSDT strategy balances individual payoff maximization with collective sustainability by adapting cooperation levels based on the current stock level and game history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and encourage others to follow suit.
2. **Subsequent Rounds:** Calculate a cooperation threshold `θ` based on the current stock level `S` and capacity `c`:

`θ = S / c`

* If `θ ≥ 0.5`, Cooperate (C). This indicates a relatively healthy stock level, allowing for sustainable consumption.
* If `θ < 0.5`, Defect (D) with probability `p = θ`. This introduces a gradual shift towards defection as the stock level declines.

**Pseudocode:**
```python
def ACSDT(stock, capacity, round_num):
    if round_num == 1:
        return C
    
    theta = stock / capacity
    if theta >= 0.5:
        return C
    else:
        p = theta
        return D with probability p
```
**Edge Cases:**

* **Last Round:** Cooperate (C) in the last round to maximize individual payoff, as there is no future stock depletion concern.
* **Low Stock Levels:** If `S ≤ n` (i.e., the stock level is critically low), Defect (D) to ensure some consumption and minimize losses.

**Collective Mindset:**

The ACSDT strategy prioritizes collective sustainability by:

1. Encouraging cooperation in early rounds to establish a positive tone.
2. Gradually adapting cooperation levels based on the current stock level, allowing for sustainable consumption.
3. Allowing for defection when the stock level is critically low, ensuring some individual payoff.

This adaptive approach balances individual interests with collective sustainability, making it robust against various opponent behaviors in the tournament.
'''

description_COLLECTIVE_200 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)**

**Overview**
ACSDT is a collective strategy that adapts its cooperation level based on the current stock level and the history of opponent actions. The goal is to balance individual payoffs with the need to maintain a sustainable stock level.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and observe opponents' initial actions.
2. **Stock-Dependent Threshold**: Calculate a cooperation threshold `τ` based on the current stock level `S`:
	* If `S ≥ 0.75 * capacity`, cooperate (C).
	* If `S < 0.5 * capacity`, defect (D).
	* If `0.5 * capacity ≤ S < 0.75 * capacity`, use a mixed strategy: cooperate with probability `p = (S - 0.5 * capacity) / (0.25 * capacity)` and defect with probability `1 - p`.
3. **Opponent Action History**: Observe the actions of all opponents in previous rounds and calculate their cooperation rates (`CR_i`).
4. **Adaptive Cooperation**: If an opponent's `CR_i` is below a certain threshold (`θ = 0.5`), consider them uncooperative and adjust your strategy:
	* If you cooperated (C) in the previous round, defect (D) with probability `1 - p`, where `p = CR_i`.
	* If you defected (D) in the previous round, cooperate (C) with probability `p`, where `p = 1 - CR_i`.
5. **Last Round**: Cooperate (C) in the last round to maximize final payoffs, regardless of opponent actions.

**Pseudocode**
```python
def ACSDT(n, capacity, stock_history, opponent_actions):
    # Initialize cooperation threshold and opponent action history
    τ = 0
    CR = [0] * n
    
    # Calculate cooperation threshold based on current stock level
    S = stock_history[-1]
    if S >= 0.75 * capacity:
        τ = 1  # Cooperate
    elif S < 0.5 * capacity:
        τ = 0  # Defect
    else:
        τ = (S - 0.5 * capacity) / (0.25 * capacity)
    
    # Update opponent action history and cooperation rates
    for i in range(n):
        CR[i] = sum(opponent_actions[i]) / len(opponent_actions[i])
    
    # Adaptive cooperation based on opponent actions
    if τ == 1:  # Cooperate
        for i in range(n):
            if CR[i] < θ:
                τ = 0  # Defect with probability 1 - p
    elif τ == 0:  # Defect
        for i in range(n):
            if CR[i] > θ:
                τ = 1  # Cooperate with probability p
    
    # Last round exception
    if len(stock_history) == r:
        return 1  # Cooperate
    
    return τ
```
**Collective Mindset**
ACSDT aligns with the collective mindset by:

* Encouraging cooperation when the stock level is high, promoting sustainability.
* Adapting to opponent actions to prevent exploitation and promote mutual cooperation.
* Cooperating in the last round to maximize final payoffs.

By using a dynamic threshold based on the stock level and adapting to opponent actions, ACSDT balances individual payoffs with collective well-being, making it a robust strategy for this Common Pool Resource Game.
'''

description_COLLECTIVE_201 = '''
**Collective Strategy: Adaptive Cooperation with Stock Threshold (ACST)**

**Decision Rules:**

1. **First Round:** Cooperate (C) to establish a baseline for cooperation and encourage others to do the same.
2. **Subsequent Rounds:** Evaluate the current stock level (S) and previous round's total consumption (TC_prev).
	* If S ≥ capacity/2, cooperate (C). This ensures that when the stock is relatively high, players contribute to its sustainability.
	* If S < capacity/2 and TC_prev ≤ capacity/4, defect (D). This responds to low stock levels by increasing individual payoffs while avoiding over-exploitation.
	* If S < capacity/2 and TC_prev > capacity/4, cooperate (C) if at least one other player cooperated in the previous round. Otherwise, defect (D). This promotes cooperation when others have shown willingness to conserve the resource.
3. **Last Round:** Defect (D), as there is no future benefit to cooperating.

**Pseudocode:**
```
function ACST(n, capacity, stock, history) {
  if (round == 1) {
    return C; // Cooperate in first round
  } else {
    S = current_stock;
    TC_prev = previous_round_total_consumption;
    
    if (S >= capacity/2) {
      return C; // Cooperate when stock is high
    } else if (TC_prev <= capacity/4) {
      return D; // Defect when stock is low and consumption was moderate
    } else {
      if (at_least_one_cooperated(history)) {
        return C; // Cooperate if others cooperated previously
      } else {
        return D; // Defect otherwise
      }
    }
  }
  
  function at_least_one_cooperated(history) {
    for each player in history {
      if (player.cooperated == true) {
        return true;
      }
    }
    return false;
  }
}
```
**Collective Mindset:**

The ACST strategy prioritizes cooperation when the stock is relatively high, ensuring that players contribute to its sustainability. When the stock is low, it adapts by defecting or cooperating based on previous consumption patterns and opponents' behavior. This promotes a balance between individual payoffs and collective resource management.

By aligning with this collective mindset, ACST aims to:

1. Encourage cooperation when possible
2. Respond to over-exploitation by increasing individual payoffs
3. Foster a sense of reciprocity among players

**Robustness:**

ACST is designed to be robust against various opponent behaviors, including:

* **Pure Cooperators:** ACST will adapt and cooperate when others do, promoting collective resource management.
* **Pure Defectors:** ACST will defect in response to over-exploitation, ensuring individual payoffs.
* **Mixed Strategies:** ACST's adaptive nature allows it to respond effectively to changing opponent behaviors.

By implementing this strategy, we aim to achieve a high total payoff while maintaining the sustainability of the common pool resource.
'''

description_COLLECTIVE_202 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and focuses on long-term sustainability:

**Strategy Name:** Adaptive Collective Harvesting (ACH)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage others to cooperate.
2. **Stock-dependent Cooperation**: If the current stock is above 75% of capacity, cooperate (C). This allows for sustainable harvesting while maintaining a buffer against over-exploitation.
3. **Defection Detection**: Monitor the actions of other players and detect defection (D) patterns. If you observe that more than half of the players defected in the previous round, defect (D) in the current round to avoid being exploited.
4. **Punishment Mechanism**: If a player defects while others cooperate, reduce cooperation probability by 20% for the next two rounds to discourage future defection.
5. **Stock Recovery**: If the stock level falls below 25% of capacity, cooperate (C) in all subsequent rounds until the stock recovers above 50% of capacity.

**Edge Cases:**

* In the last round, defect (D) if the stock is below 25% of capacity to maximize individual payoff.
* If only one or two players are left in the game (due to early exit or disqualification), cooperate (C) to maintain a stable stock level.

**Pseudocode:**
```python
def ACH(n, r, capacity, current_stock, history):
  # Initial Round
  if round == 1:
    return C
  
  # Stock-dependent Cooperation
  if current_stock > 0.75 * capacity:
    return C
  
  # Defection Detection and Punishment Mechanism
  previous_round_defections = count_defections(history[-1])
  if previous_round_defections > n / 2:
    return D
  elif previous_round_defections > 0:
    cooperation_probability *= 0.8
    return D with probability 1 - cooperation_probability
  
  # Stock Recovery
  if current_stock < 0.25 * capacity:
    while current_stock < 0.5 * capacity:
      return C
  
  # Default to Cooperation
  return C
```
**Collective Mindset:**

ACH prioritizes sustainable harvesting and long-term cooperation, while adapting to various opponent behaviors. By cooperating when the stock is high and defecting in response to exploitation, ACH promotes a stable and mutually beneficial outcome for all players.

In the tournament setting, ACH will play against independent strategies developed by other AI systems. While it cannot rely on coordination mechanisms or shared norms, its adaptive nature allows it to respond effectively to diverse opponent behaviors, increasing its chances of achieving a high payoff in the collective interest.
'''

description_COLLECTIVE_203 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a cooperative tone and avoid immediate stock depletion.
2. **Subsequent Rounds:** Use the following adaptive threshold-based approach:
	* Calculate the average payoff per player in the previous round (`avg_payoff_prev`).
	* Determine the current stock level as a fraction of capacity (`stock_fraction = current_stock / capacity`).
	* If `stock_fraction` is above a certain threshold (`threshold = 0.5 + (1 - avg_payoff_prev / (capacity / n)) * 0.25`), cooperate (C). Otherwise, defect (D).

Pseudocode:
```
if round == 1:
    action = C
else:
    stock_fraction = current_stock / capacity
    avg_payoff_prev = average payoff per player in previous round
    threshold = 0.5 + (1 - avg_payoff_prev / (capacity / n)) * 0.25
    if stock_fraction > threshold:
        action = C
    else:
        action = D
```
**Edge Cases:**

* **Last Round:** Cooperate (C) to maintain a positive relationship and avoid complete stock depletion.
* **Low Stock Levels:** If the current stock level is below 10% of capacity, defect (D) to ensure some payoff in case others also defect.

**Collective Mindset:**

The ACSDT strategy aims to balance individual self-interest with collective well-being by adapting to the current state and history of the game. By cooperating when the stock level is sufficient and average payoffs are high, we promote a cooperative atmosphere and maintain a healthy stock level. When the stock level or average payoffs decline, our threshold-based approach allows us to switch to defection, ensuring we don't over-contribute to the common pool.

**Rationale:**

1. **Initial Cooperation:** Establishes a cooperative tone and avoids immediate stock depletion.
2. **Adaptive Threshold:** Responds to changes in the game state and history, allowing for flexible adaptation to different opponent behaviors.
3. **Stock-Dependent Decision-Making:** Takes into account the current stock level, ensuring we don't over-exploit the common pool when it's scarce.
4. **Average Payoff Consideration:** Adjusts our behavior based on the average payoff per player, promoting a fair and balanced approach.

By implementing this strategy, we aim to perform well in a tournament against independent strategies while maintaining a collective mindset that promotes cooperation and sustainability.
'''

description_COLLECTIVE_204 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACS-T)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline for collective behavior and encourage cooperation.
2. **Subsequent Rounds (t>1):** Calculate the current stock-based threshold (`SBT`) using the formula:

`SBT = capacity / (2n * (1 + (total_defections_last_round / n)))`

where `total_defections_last_round` is the number of players who defected in the previous round.

* If the current stock level (`stock`) is above the `SBT`, Cooperate (C).
* Otherwise, Defect (D).

**Rationale:**

* By cooperating initially, we set a positive tone and encourage others to cooperate.
* In subsequent rounds, we adjust our behavior based on the previous round's outcomes. If many players defected, we lower our cooperation threshold to avoid over-exploitation of the common pool. Conversely, if most players cooperated, we raise the threshold to maintain a healthy stock level.
* The `SBT` formula balances individual interests with collective sustainability, promoting cooperation when the stock is abundant and switching to defection when it's scarce.

**Handling Edge Cases:**

* **Last Round (t=r):** Cooperate (C) to ensure a fair distribution of the remaining stock among players.
* **Low Stock Levels:** If `stock` falls below a certain percentage (`low_stock_threshold`, e.g., 20%) of the capacity, always Defect (D) to minimize losses.

**Collective Mindset:**

Our strategy aims to balance individual payoffs with collective sustainability. By adapting to the game's dynamics and responding to opponents' actions, we promote cooperation when possible while protecting ourselves from exploitation.

**Pseudocode:**
```python
def ACS_T(n, capacity, stock, total_defections_last_round, t):
    if t == 1:  # Initial round
        return 'C'
    
    SBT = capacity / (2 * n * (1 + (total_defections_last_round / n)))
    if stock > SBT:
        return 'C'
    else:
        return 'D'

def play_game(n, capacity, r):
    stock = capacity
    total_payoff = 0
    
    for t in range(1, r+1):
        # Get actions from all players (including our ACS-T strategy)
        actions = [ACS_T(n, capacity, stock, total_defections_last_round, t) for _ in range(n)]
        
        # Update total defections
        total_defections_last_round = sum(action == 'D' for action in actions)
        
        # Calculate payoffs and update stock
        payoffs = calculate_payoffs(actions, stock, n)
        total_payoff += payoffs[0]  # Our payoff
        
        stock -= sum(payoffs)
        stock += calculate_stock_growth(stock, capacity)
    
    return total_payoff

def calculate_payoffs(actions, stock, n):
    payoffs = []
    for action in actions:
        if action == 'C':
            payoffs.append(stock / (2 * n))
        else:  # Defect
            payoffs.append(stock / n)
    return payoffs

def calculate_stock_growth(stock, capacity):
    growth = 2 * stock * (1 - stock/capacity)
    return min(growth, capacity - stock)
```
This implementation provides a basic structure for the ACS-T strategy. Note that this is just one possible way to implement the strategy, and you may need to modify it to fit your specific requirements.
'''

description_COLLECTIVE_205 = '''
**Collective Strategy: Adaptive Cooperation**

Our collective strategy aims to balance individual payoffs with the long-term sustainability of the common pool resource. We'll use a hybrid approach that combines elements of cooperation, defection, and adaptiveness.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) unconditionally to initiate a cooperative atmosphere and maximize the initial stock growth.
2. **Early Rounds (t>1, stock ≥ capacity/2)**: Play a mixed strategy:
	* With probability p (e.g., 0.6), cooperate (C).
	* With probability (1-p), defect (D) if at least one opponent defected in the previous round; otherwise, cooperate.
3. **Mid-game Rounds (t>early rounds, stock < capacity/2)**: Assess the current state and adapt:
	* If the stock level is critically low (< capacity/4), cooperate (C) to prevent depletion.
	* Otherwise, play a tit-for-tat strategy with a twist: defect if an opponent defected in the previous round or if two or more opponents cooperated; otherwise, cooperate.
4. **Late Rounds (t=r-1 or r)**: Prioritize stock conservation:
	* If the stock level is low (< capacity/4), cooperate (C) to ensure some remaining stock for the final round.
	* Otherwise, defect (D) if at least one opponent defected in the previous round; otherwise, cooperate.

**Edge Cases:**

1. **Last Round (t=r)**: Defect (D) to maximize individual payoff, as there's no future game to consider.
2. **Stock Depletion**: If the stock level reaches zero, cooperate (C) in all subsequent rounds to avoid further depletion.
3. **Opponent Cooperation**: If an opponent cooperates unconditionally, adapt by cooperating with them and defecting against others.

**Collective Mindset:**

Our strategy aims to maintain a balance between cooperation and defection, ensuring the sustainability of the common pool resource while maximizing individual payoffs. By adapting to the current state and opponents' actions, we encourage cooperation while protecting ourselves from excessive exploitation.

Pseudocode:
```python
def adaptive_cooperation(n, r, capacity, stock):
    if t == 1: # Initial round
        return C
    
    if stock >= capacity/2 and t < early_rounds_threshold:
        p = 0.6
        if random.random() < p:
            return C
        else:
            opponents_defected_last_round = [opp.defected for opp in opponents]
            if any(opponents_defected_last_round):
                return D
            else:
                return C
    
    if stock < capacity/2 and t >= early_rounds_threshold:
        if stock < capacity/4: # Critically low stock
            return C
        
        tit_for_tat = [opp.defected for opp in opponents]
        two_or_more_cooperated_last_round = sum([opp.cooperated for opp in opponents]) >= 2
        if any(tit_for_tat) or two_or_more_cooperated_last_round:
            return D
        else:
            return C
    
    # Late rounds
    if t == r-1 or t == r:
        if stock < capacity/4:
            return C
        
        opponents_defected_last_round = [opp.defected for opp in opponents]
        if any(opponents_defected_last_round):
            return D
        else:
            return C

# Stock depletion and opponent cooperation handling
if stock == 0:
    return C

opponent_cooperated_unconditionally = all([opp.cooperated for opp in opponents])
if opponent_cooperated_unconditionally:
    # Adapt by cooperating with this opponent and defecting against others
    pass
```
This strategy combines elements of cooperation, defection, and adaptiveness to balance individual payoffs with the long-term sustainability of the common pool resource.
'''

description_COLLECTIVE_206 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to set a cooperative tone and observe opponents' actions.
2. **State-Dependent Cooperation:** In subsequent rounds, cooperate if:
	* The current stock level is above 75% of the capacity (`stock >= 0.75 * capacity`).
	* The average payoff per player in the previous round was above 50% of the maximum possible payoff (`avg_payoff_prev_round >= 0.5 * (capacity / (2 * n))`).
3. **Defection Triggers:** Defect if:
	* The current stock level is below 25% of the capacity (`stock < 0.25 * capacity`).
	* A player has defected in the previous round and their payoff was higher than the average payoff (`payoff_i_prev_round > avg_payoff_prev_round`).
4. **Stock Conservation:** If cooperating, reduce consumption by 10% to conserve stock (`consumption = (stock / (2 * n)) * 0.9`).

**Edge Cases:**

1. **Last Round:** Defect in the last round, as there is no future benefit to cooperation.
2. **Opponent Defection:** If an opponent defects, mirror their action to maintain a balance between cooperation and defection.

**Collective Mindset:**

The ASC strategy prioritizes collective sustainability by:

1. Encouraging cooperation when the stock level is high.
2. Conserving stock through reduced consumption.
3. Responding to opponents' actions to maintain a balance between cooperation and defection.

Pseudocode:
```python
def ASC(n, capacity, r):
    # Initialize variables
    stock = capacity
    avg_payoff_prev_round = 0

    for round in range(r):
        if round == 0:  # Initial Round
            action = "C"
        else:
            if stock >= 0.75 * capacity and avg_payoff_prev_round >= 0.5 * (capacity / (2 * n)):
                action = "C"
            elif stock < 0.25 * capacity or (payoff_i_prev_round > avg_payoff_prev_round and opponent_defected):
                action = "D"
            else:
                action = "C"

        # Update state
        if action == "C":
            consumption = (stock / (2 * n)) * 0.9
        else:
            consumption = stock / n

        total_consumption = consumption * n
        stock -= total_consumption
        growth = 2 * stock * (1 - stock / capacity)
        stock = min(stock + growth, capacity)

        # Update payoffs and averages
        payoff_i = consumption if action == "C" else stock / n
        avg_payoff_prev_round = (avg_payoff_prev_round * (n - 1) + payoff_i) / n

    return total_payoff
```
The ASC strategy is designed to be adaptive, robust, and collective, making it suitable for a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_207 = '''
To design a collective strategy for this Common Pool Resource Game that is adaptive and robust, I propose a dynamic, history-dependent approach. This strategy balances individual self-interest with cooperative behavior to ensure long-term sustainability of the common resource.

**Decision Rules:**

The strategy, which we'll call "Adaptive Sustainability" (AS), uses a combination of current state assessment and historical analysis to determine when to cooperate (C) or defect (D). The decision-making process is based on two key factors:

1. **Stock level threshold**: A critical stock level below which cooperation becomes more crucial for sustainability.
2. **Opponent behavior analysis**: An evaluation of the previous rounds' outcomes to identify potential cooperative or exploitative tendencies among opponents.

**Pseudocode for Adaptive Sustainability (AS) strategy:**
```python
def AS(stock, history, capacity, n):
    # Calculate stock level threshold (30% of capacity)
    threshold = 0.3 * capacity
    
    # Analyze opponent behavior from previous rounds
    opponent_cooperation_rate = calculate_opponent_cooperation(history)
    
    if stock < threshold:
        # If stock is critically low, cooperate to ensure sustainability
        return C
    elif opponent_cooperation_rate > 0.5:
        # If opponents tend to cooperate, defect to maximize individual payoff
        return D
    else:
        # Otherwise, cooperate to maintain a balanced approach
        return C

def calculate_opponent_cooperation(history):
    # Evaluate the proportion of cooperative actions in previous rounds
    cooperation_count = 0
    for round in history:
        if len([action for action in round if action == C]) > n / 2:
            cooperation_count += 1
    return cooperation_count / len(history)
```
**Edge Cases:**

* **First Round**: In the first round, the strategy will cooperate (C) to encourage opponents to do the same and establish a cooperative tone for the game.
* **Last Round**: In the last round, the strategy will defect (D) to maximize individual payoff, as there is no future benefit to cooperation.

**Collective Mindset:**

The AS strategy prioritizes sustainability and cooperation when necessary, while also adapting to opponent behavior. By balancing individual self-interest with collective responsibility, this approach promotes a stable and mutually beneficial outcome for all players in the long term.

This strategy can be further refined by incorporating additional factors, such as:

* **Reputation system**: Tracking opponents' past actions to inform future decisions
* **Stock growth rate analysis**: Evaluating changes in stock levels to adjust decision-making
* **Dynamic threshold adjustment**: Adapting the stock level threshold based on game progression and opponent behavior

These enhancements can improve the strategy's robustness and adaptability, enabling it to perform well against a wide range of independent strategies.
'''

description_COLLECTIVE_208 = '''
To design a collective strategy for this Common Pool Resource Game, I'll introduce an adaptive and robust approach that balances individual payoffs with the need to sustain the common pool resource.

**Strategy Name: Sustainable Harvesting (SH)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to avoid depleting the stock excessively.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of the capacity, use a probabilistic approach:
		+ Cooperate with probability p = (current_stock / capacity)^2
		+ Defect with probability 1 - p
	* If the current stock level is below 50% of the capacity, defect (D).
3. **Last Round:** Cooperate (C) in the last round to avoid depleting the remaining stock.

**Pseudocode:**
```python
def SH_strategy(current_stock, capacity, round_number, total_rounds):
    if round_number == 1:
        return 'C'  # Cooperate in first round
    
    if current_stock > 0.75 * capacity:
        return 'C'
    
    elif 0.5 * capacity <= current_stock < 0.75 * capacity:
        p = (current_stock / capacity)**2
        return 'C' if random.random() < p else 'D'
    
    else:
        return 'D'

def SH_last_round(current_stock, capacity):
    return 'C'  # Cooperate in last round
```
**Collective Mindset:**
The Sustainable Harvesting strategy prioritizes maintaining a sustainable stock level while allowing for some flexibility to adapt to the actions of other players. By cooperating when the stock is high and probabilistically choosing between cooperation and defection when the stock is moderate, SH balances individual payoffs with collective well-being.

**Robustness:**
SH can handle various opponent behaviors due to its adaptive nature:

* If most opponents cooperate, SH will also cooperate, maintaining a healthy stock level.
* If many opponents defect, SH's probabilistic approach ensures that it doesn't over-harvest, allowing for some resource conservation.
* In the last round, SH cooperates to avoid depleting the remaining stock.

**Tournament Performance:**
In a tournament setting, Sustainable Harvesting should perform well against independent strategies, as it balances individual payoffs with collective sustainability. Its adaptive nature allows it to respond effectively to different opponent behaviors while maintaining a robust and cooperative approach.

This strategy can be further refined or modified based on specific game dynamics or additional information about the opponents' strategies.
'''

description_COLLECTIVE_209 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a high stock level and encourage cooperation.
2. **Stock Threshold**: If the current stock is above 75% of the capacity, cooperate (C). This ensures sustainable consumption and growth.
3. **Recent Defection**: If at least one player defected (D) in the previous round, defect (D) in the current round. This responds to exploitation and maintains a balance of power.
4. **Low Stock**: If the current stock is below 25% of the capacity, cooperate (C). This prioritizes conservation when the stock is scarce.
5. **History-based Cooperation**: If the average payoff per player over the last 3 rounds is above the game's theoretical maximum (i.e., capacity / (2n)), cooperate (C). This promotes cooperation when the collective is performing well.

Pseudocode:
```python
def ASC(n, capacity, stock, history):
    if round == 1:  # Initial Round
        return C

    if stock >= 0.75 * capacity:  # Stock Threshold
        return C

    if any(history[-1][i] == D for i in range(n)):  # Recent Defection
        return D

    if stock <= 0.25 * capacity:  # Low Stock
        return C

    avg_payoff = sum(history[-3:]) / (3 * n)  # History-based Cooperation
    if avg_payoff >= capacity / (2 * n):
        return C

    # Default to defection when no other condition is met
    return D
```
**Edge Cases:**

* In the last round, ASC defaults to defection (D), as there are no future rounds to consider.
* If the stock is exactly at 75% or 25% of the capacity, ASC will cooperate (C) to prioritize sustainability.

By implementing ASC, we create a robust and adaptive strategy that balances individual payoffs with collective sustainability. This approach should perform well in a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_210 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Stock-based Cooperation**: If the current stock level is above 75% of the capacity, cooperate (C). This ensures that the collective resource remains sustainable while allowing for moderate consumption.
3. **Defection Threshold**: If the current stock level falls below 25% of the capacity, defect (D) to maximize individual payoff in a depleted environment.
4. **Adaptive Defection**: If the previous round's total consumption exceeded 50% of the capacity, defect (D) in the current round. This helps prevent over-exploitation and encourages opponents to cooperate.
5. **Cooperation Reversion**: If the stock level has increased by at least 10% since the last round, revert to cooperating (C). This promotes sustainable harvesting when the resource is recovering.

**Pseudocode:**
```python
def ASC(n, capacity, r, current_stock, previous_actions):
    if current_round == 1:
        return C  # Initial cooperation

    if current_stock >= 0.75 * capacity:
        return C  # Stock-based cooperation

    if current_stock <= 0.25 * capacity:
        return D  # Defection threshold

    total_consumption = sum(previous_actions)
    if total_consumption > 0.5 * capacity:
        return D  # Adaptive defection

    stock_change = (current_stock - previous_stock) / previous_stock
    if stock_change >= 0.1:
        return C  # Cooperation reversion

    return D  # Default to defection
```
**Handling Edge Cases:**

* In the last round, ASC will make decisions based on the current state and history, without considering future consequences.
* If all opponents defect in a previous round, ASC may adapt by defecting in the next round, but will revert to cooperation if the stock level increases significantly.

**Collective Mindset:**
The ASC strategy prioritizes collective sustainability while allowing for individual adaptation. By cooperating when the stock level is high and adapting to opponents' behaviors, ASC promotes a balance between resource conservation and exploitation. This approach fosters a cooperative environment where players can achieve moderate payoffs without depleting the common pool resource.

ASC's adaptability makes it robust against various opponent strategies, including those that rely on cooperation or defection. By focusing on the game's state and history, ASC avoids relying on predetermined coordination mechanisms or assumptions about opponents' behaviors.
'''

description_COLLECTIVE_211 = '''
**Collective Strategy: Adaptive Cooperation with Dynamic Stock Threshold (ACDST)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to set a cooperative tone and observe opponents' behavior.
2. **Subsequent Rounds:** Defect (D) if the current stock level is below a dynamic threshold, calculated as `threshold = capacity / (n + 1) * (r - t)`, where:
	* `capacity` is the maximum sustainable stock level
	* `n` is the number of players
	* `r` is the total number of rounds
	* `t` is the current round number
3. **Stock Depletion:** If the current stock level is below 50% of the capacity, cooperate (C) to conserve resources and allow for regrowth.
4. **Opponent Behavior:** Observe opponents' actions in previous rounds and adjust the threshold accordingly:
	* If most opponents defected in the previous round (> 50%), increase the threshold by 10% to discourage over-exploitation.
	* If most opponents cooperated in the previous round (> 50%), decrease the threshold by 10% to encourage cooperation.

**Edge Cases:**

1. **Last Round:** Defect (D) in the last round, as there is no future benefit from cooperating.
2. **Low Stock Levels:** If the stock level falls below 20% of the capacity, cooperate (C) to prevent depletion and ensure some payoff.

**Collective Mindset:**

ACDST aims to balance individual payoffs with collective sustainability by adapting to the dynamic state of the game and opponents' behavior. By adjusting the threshold based on the current round, stock level, and opponent actions, ACDST promotes cooperation when beneficial for the group while allowing for strategic defection to maximize individual payoffs.

**Pseudocode:**
```markdown
function ACDST(n, capacity, r, t, stock, history) {
  // Initialize threshold
  threshold = capacity / (n + 1) * (r - t)
  
  // Adjust threshold based on opponent behavior
  if (mostOpponentsDefected(history)) {
    threshold *= 1.1
  } else if (mostOpponentsCooperated(history)) {
    threshold *= 0.9
  }
  
  // Decide action
  if (t == 1) {  // Initial round
    return C
  } else if (stock < threshold) {
    return D
  } else if (stock < 0.5 * capacity) {
    return C
  } else {
    return D
  }
  
  // Helper functions
  function mostOpponentsDefected(history) {
    // Check if > 50% of opponents defected in the previous round
  }
  
  function mostOpponentsCooperated(history) {
    // Check if > 50% of opponents cooperated in the previous round
  }
}
```
This strategy will be implemented as an algorithm and compete against other AI systems in a tournament.
'''

description_COLLECTIVE_212 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and aligns with the collective mindset:

**Strategy Name:** Adaptive Collective Sustainability (ACS)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to encourage initial cooperation and set a positive tone.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play a mixed strategy:
		+ With probability p (e.g., 0.7), Cooperate (C).
		+ With probability (1-p), Defect (D).
	* If the current stock level is below 50% of capacity, Defect (D) to maximize individual payoff in a potentially depleted environment.
3. **Last Round (t=r):** Cooperate (C) if the current stock level is above 25% of capacity; otherwise, Defect (D).

**Edge Case Handling:**

1. If the number of players (n) is large (e.g., n > 10), adjust the mixed strategy probabilities to favor cooperation more strongly (e.g., p = 0.9).
2. If the game has only two rounds (r=2), play Cooperate (C) in both rounds.

**Collective Mindset Alignment:**

1. **Monitor opponents' behavior:** Track the number of cooperators and defectors in each round.
2. **Adapt to opponent behavior:** Adjust the mixed strategy probabilities based on the observed cooperation rate among opponents:
	* If most opponents cooperate, increase p (e.g., p = 0.8).
	* If few opponents cooperate, decrease p (e.g., p = 0.5).

**Rationale:**

ACS aims to balance individual payoff maximization with collective sustainability by adapting to the current state of the common pool and opponent behavior. By cooperating when the stock level is high and defecting when it's low, ACS encourages sustainable resource use while minimizing the risk of exploitation.

The mixed strategy in intermediate cases allows for a flexible response to varying opponent behaviors, promoting cooperation when possible while avoiding excessive exploitation.

**Pseudocode:**
```python
def AdaptiveCollectiveSustainability(n, r, capacity, current_stock):
  if t == 1:
    return C  # Initial round cooperation

  if current_stock >= 0.75 * capacity:
    return C  # Cooperate when stock is high
  elif 0.5 <= current_stock / capacity < 0.75:
    p = 0.7  # default probability
    adapt_to_opponent_behavior(p)  # adjust p based on opponent behavior
    return C if random.random() < p else D  # mixed strategy
  else:
    return D  # Defect when stock is low

def adapt_to_opponent_behavior(p):
  # Monitor opponents' behavior and adjust p accordingly
  # ...
```
This strategy should perform well in a tournament setting, as it balances individual payoff maximization with collective sustainability while adapting to various opponent behaviors.
'''

description_COLLECTIVE_213 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock Threshold (ATTT-ST)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and to encourage others to cooperate.
2. **Subsequent Rounds:** Use an adaptive tit-for-tat approach, where you:
	* Cooperate (C) if the average payoff of cooperators in the previous round is greater than or equal to the average payoff of defectors.
	* Defect (D) otherwise.

However, introduce a stock threshold condition:

3. **Stock Threshold:** If the current stock level falls below 50% of the capacity, always Cooperate (C), regardless of the tit-for-tat decision.

**Pseudocode:**
```
IF first_round THEN
    action = C
ELSE
    avg_coop_payoff_prev_round = calculate_average_payoff(cooperators, previous_round)
    avg_defect_payoff_prev_round = calculate_average_payoff(defectors, previous_round)

    IF avg_coop_payoff_prev_round >= avg_defect_payoff_prev_round THEN
        action = C
    ELSE
        action = D

    IF current_stock_level < 0.5 * capacity THEN
        action = C
```
**Rationale:**

1. **Initial Cooperation:** Starting with cooperation sets a positive tone and may encourage others to cooperate, especially in early rounds.
2. **Adaptive Tit-for-Tat:** This approach responds to the previous round's payoffs, allowing the strategy to adapt to changing circumstances and opponent behaviors.
3. **Stock Threshold:** By always cooperating when the stock level falls below 50% of capacity, this strategy prioritizes resource conservation and long-term sustainability over short-term gains.

**Edge Cases:**

1. **Last Round:** Since the game has a fixed number of rounds (r > 1), there is no need for special handling in the last round.
2. **Zero or Negative Stock:** If the stock level reaches zero, the strategy will always cooperate to avoid further depletion and promote regeneration.

**Collective Mindset:**

This strategy aligns with the collective mindset by:

1. Cooperating initially to establish a cooperative baseline.
2. Responding adaptively to opponent behaviors while prioritizing cooperation when beneficial.
3. Prioritizing resource conservation and long-term sustainability over short-term gains.

By following this adaptive tit-for-tat approach with a stock threshold, ATTT-ST aims to achieve a balance between individual payoffs and collective well-being in the Common Pool Resource Game.
'''

description_COLLECTIVE_214 = '''
**Collective Strategy: Adaptive Cooperation with Stock-based Trigger (ACST)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative tone and encourage others to do the same.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of the capacity, defect (D) with a probability proportional to the number of players who defected in the previous round.
	* If the current stock level is below 50% of the capacity, defect (D).

**Pseudocode:**
```
function ACST(stock, capacity, num_players, history):
  if t == 1:
    return C
  else:
    stock_ratio = stock / capacity
    if stock_ratio > 0.75:
      return C
    elif 0.5 <= stock_ratio < 0.75:
      defect_prob = (num_defectors_prev_round / num_players)
      return D with probability defect_prob, otherwise C
    else:
      return D
```
**Handling Edge Cases:**

1. **Last Round (t=r):** Defect (D) to maximize individual payoff, as the game is ending.
2. **Stock Depletion:** If the stock level reaches 0, cooperate (C) in the next round to allow for stock growth and potential future cooperation.

**Collective Mindset:**

ACST aims to balance individual self-interest with collective sustainability by:

1. Encouraging cooperation when the stock is plentiful.
2. Gradually introducing defection as the stock level decreases, taking into account the actions of others in the previous round.
3. Prioritizing stock growth and future cooperation over short-term gains.

**Robustness:**

ACST adapts to various opponent behaviors by:

1. Responding to changes in the stock level and opponents' actions.
2. Gradually increasing defection probability as the number of defectors increases, preventing a single player from exploiting others.
3. Maintaining cooperation when the stock is abundant, promoting collective sustainability.

This strategy should perform well against a variety of opponent strategies, including those that are more exploitative or cooperative.
'''

description_COLLECTIVE_215 = '''
**Collective Strategy: "Sustainable Harmony"**

Our goal is to design a collective strategy that balances individual payoffs with the sustainability of the common pool resource, while being adaptive and robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and encourage others to do the same.
2. **Observation Phase:** For rounds 2 to r-1, observe the actions of all players and calculate the average cooperation rate (ACR) among opponents:

   ACR = (Number of C actions in previous round) / n

   If ACR ≥ 0.5, cooperate (C); otherwise, defect (D).
3. **Sustainability Threshold:** Monitor the stock level after each round. If the stock falls below a critical threshold (ST), which is set to 20% of the capacity, switch to cooperation (C) for all subsequent rounds.

   ST = 0.2 × capacity
4. **Reciprocity Mechanism:** Implement a reciprocity mechanism to respond to opponents' actions:

   - If an opponent defects (D) while our stock contribution is above average, defect (D) in the next round.
   - If an opponent cooperates (C) while our stock contribution is below average, cooperate (C) in the next round.

**Edge Cases:**

1. **Last Round:** In the final round (r), always cooperate (C) to ensure a sustainable ending and avoid unnecessary depletion of the common pool resource.
2. **Tiebreaker:** In cases where ACR equals 0.5, cooperate (C) to maintain a positive influence on the game's dynamics.

**Pseudocode:**

```
Function SustainableHarmony(n, r, capacity):
  Initialize stock = capacity
  For round = 1 to r:
    If round == 1:
      action = C
    Else:
      ACR = (Number of C actions in previous round) / n
      If ACR >= 0.5 or stock < ST:
        action = C
      Else:
        action = D

      // Reciprocity mechanism
      For opponent in opponents:
        If opponent's action == D and our_stock_contribution > average_stock_contribution:
          action = D
        ElseIf opponent's action == C and our_stock_contribution < average_stock_contribution:
          action = C

    stock -= calculate_total_consumption(action, n)
    stock += calculate_stock_growth(stock, capacity)

  Return total_payoff
```

**Collective Mindset:**

Our strategy aligns with the collective mindset by:

1. Prioritizing sustainability and cooperation to maintain a healthy common pool resource.
2. Encouraging reciprocity and mutual benefit through adaptive decision-making.
3. Avoiding exploitation and promoting fair play, even in the face of varying opponent behaviors.

By implementing Sustainable Harmony, we aim to create a balanced and sustainable game environment that benefits all players while minimizing the risk of depletion and collapse.
'''

description_COLLECTIVE_216 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adaptively adjusting cooperation levels based on game state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for stock growth and observe opponents' behaviors.
2. **Subsequent Rounds:** Calculate the **Stock Depletion Rate (SDR)** as the ratio of total consumption to current stock:

`SDR = (previous_stock - current_stock) / previous_stock`

* If SDR > 0.5, Defect (D) to maximize individual payoff, as the stock is being rapidly depleted.
* If SDR ≤ 0.5 and current_stock ≥ capacity/2, Cooperate (C) to conserve stock and allow for growth.
* If SDR ≤ 0.5 and current_stock < capacity/2, Defect (D) with a probability of `p = (capacity - current_stock) / capacity`. This introduces a degree of randomness to encourage opponents to cooperate while still allowing for some individual gain.
3. **Last Round:** Cooperate (C) in the last round to ensure a stable final stock level and maximize collective payoff.

**Additional Considerations:**

* **Stock Growth Threshold:** If the current stock growth is below a certain threshold (e.g., 10% of capacity), Defect (D) to stimulate growth.
* **Opponent Behavior:** Monitor opponents' actions and adjust the ASC strategy accordingly. If most opponents are cooperating, increase cooperation levels to maintain collective sustainability.

**Pseudocode:**
```
function ASC(current_stock, previous_stock, capacity, round_number, total_rounds):
  if round_number == 1:
    return C
  else:
    SDR = (previous_stock - current_stock) / previous_stock
    if SDR > 0.5:
      return D
    elif SDR <= 0.5 and current_stock >= capacity/2:
      return C
    else:
      p = (capacity - current_stock) / capacity
      return D with probability p

function ASC_last_round(current_stock, previous_stock, capacity):
  return C
```
**Collective Mindset:** The ASC strategy prioritizes collective sustainability by adapting to the game state and opponents' behaviors. By balancing individual payoffs with stock conservation, ASC promotes a stable and resilient common pool resource.

This strategy is designed to be robust against various opponent behaviors and can be implemented as an algorithm for the tournament.
'''

description_COLLECTIVE_217 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Awareness (ACSA)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to cooperate.
2. **Subsequent Rounds:** Use the following decision rule:
	* If the current stock level is above 75% of the capacity, Cooperate (C).
	* If the current stock level is between 25% and 75% of the capacity, play a mixed strategy: Cooperate (C) with probability `p` and Defect (D) with probability `(1-p)`. The value of `p` is calculated based on the average payoff of all players in the previous round. Specifically, `p = avg_payoff_prev_round / (avg_payoff_prev_round + 1/n)` where `n` is the number of players.
	* If the current stock level is below 25% of the capacity, Defect (D) to maximize individual payoff in a depleted environment.

**Pseudocode:**
```python
def ACSA(stock_level, avg_payoff_prev_round, n):
    if round == 1:
        return 'C'
    
    if stock_level > 0.75 * capacity:
        return 'C'
    
    elif 0.25 * capacity <= stock_level <= 0.75 * capacity:
        p = avg_payoff_prev_round / (avg_payoff_prev_round + 1/n)
        return 'C' with probability p, 'D' otherwise
    
    else:
        return 'D'
```
**Rationale:**

* By cooperating in the first round, ACSA sets a positive tone for cooperation and encourages others to cooperate.
* The mixed strategy in subsequent rounds adapts to the current stock level and the previous round's average payoff. This balances individual interests with collective sustainability.
* When the stock level is high (above 75%), cooperating ensures that the resource remains sustainable and benefits all players.
* When the stock level is moderate (between 25% and 75%), ACSA uses a mixed strategy to balance cooperation and defection, taking into account the previous round's average payoff. This adaptability helps maintain a stable stock level while allowing for individual gains.
* When the stock level is low (below 25%), defecting maximizes individual payoffs in a depleted environment.

**Edge Cases:**

* **Last Round:** ACSA follows the same decision rules as in other rounds, ensuring that the strategy remains consistent and adaptive until the end of the game.
* **Ties:** In case of ties in the average payoff calculation, ACSA defaults to cooperating (C) to maintain a cooperative mindset.

**Collective Mindset:**

ACSA is designed to align with a collective mindset by:

* Prioritizing cooperation when the stock level is high or moderate
* Adapting to changing environmental conditions and opponent behaviors
* Balancing individual interests with collective sustainability

By following ACSA, players can contribute to a stable and sustainable common pool resource while maximizing their individual payoffs.
'''

description_COLLECTIVE_218 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and focuses on long-term sustainability:

**Strategy Name: Adaptive Harvesting with Memory (AHM)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behavior and set a cooperative tone.
2. **Stock-dependent Cooperation:** If the current stock level is above 75% of the capacity, cooperate (C). This ensures that the resource is not over-exploited, allowing for sustainable growth.
3. **Opponent-driven Defection:** If at least one opponent defected (D) in the previous round and the current stock level is below 50% of the capacity, defect (D). This response aims to prevent excessive exploitation by others while protecting our own interests.
4. **Punishment and Forgiveness:** Implement a forgiveness mechanism: if an opponent cooperated (C) in the previous round after previously defecting (D), cooperate (C) with them in this round. However, if an opponent continues to defect (D) despite cooperation from others, maintain defection (D).
5. **Adaptive Harvesting:** When cooperating, harvest only a fraction of the cooperative share: `coop_harvest = stock / (2n * (1 + memory))`, where `memory` is a parameter that increases with each round of cooperation (initially set to 0). This allows for gradual adaptation to changing stock levels and opponent behaviors.
6. **Emergency Defection:** If the current stock level falls below 25% of the capacity, defect (D) to ensure some payoff, even if it means depleting the resource.

**Edge Cases:**

1. **Last Round:** In the final round, cooperate (C) if the current stock level is above 50% of the capacity; otherwise, defect (D).
2. **Low Stock Levels:** If the current stock level is below 10% of the capacity, always defect (D) to maximize remaining payoffs.

**Pseudocode:**
```python
def AHM(stock, opponents_actions, round_number):
    # Initial Round
    if round_number == 1:
        return 'C'
    
    # Stock-dependent Cooperation
    if stock >= 0.75 * capacity:
        return 'C'
    
    # Opponent-driven Defection
    if any(opponent_action == 'D' for opponent_action in opponents_actions) and stock < 0.5 * capacity:
        return 'D'
    
    # Punishment and Forgiveness
    opponent_cooperated = [opponent_action == 'C' for opponent_action in opponents_actions]
    if any(opponent_cooperated) and all(not coop for coop in opponent_cooperated[:-1]):
        return 'C'
    elif not any(opponent_cooperated):
        return 'D'
    
    # Adaptive Harvesting
    memory = round_number - 1
    coop_harvest = stock / (2 * n * (1 + memory))
    if coop_harvest > stock / (2 * n):
        return 'C'
    else:
        return 'D'
    
    # Emergency Defection
    if stock < 0.25 * capacity:
        return 'D'

# Example usage:
opponents_actions = ['C', 'D', 'C']
round_number = 3
stock = 80
action = AHM(stock, opponents_actions, round_number)
print(action)  # Output: 'C'
```
This strategy prioritizes long-term sustainability while adapting to various opponent behaviors. By incorporating memory and forgiveness mechanisms, AHM promotes cooperation when possible and responds to exploitation with defection. The adaptive harvesting approach allows for gradual adaptation to changing stock levels and opponent behaviors.
'''

description_COLLECTIVE_219 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Trigger (ACSDT)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock-Based Trigger:** Calculate a trigger stock level, `trigger_stock`, as a fraction of the capacity:
   ```
trigger_stock = capacity * (1 - 1/(n+1))
```
   If the current stock is above `trigger_stock`, Cooperate (C). Otherwise, Defect (D).
3. **Opponent Behavior Adaptation:** Monitor the average opponent cooperation rate (`avg_opponent_coop`) over the last few rounds (e.g., 3-5 rounds). Update this value after each round.
   ```
if avg_opponent_coop > 0.5:
    # Cooperate more frequently when opponents cooperate
    trigger_stock *= 1.1
else:
    # Defect more frequently when opponents defect
    trigger_stock *= 0.9
```
4. **Last Round:** In the last round, Defect (D) to maximize individual payoff regardless of opponent behavior.

**Edge Cases:**

* If `n` is small (e.g., `n = 2`), adjust the `trigger_stock` calculation to prevent over-exploitation:
   ```
if n <= 3:
    trigger_stock = capacity * (1 - 1/(n+2))
```
* When the current stock is very low (`stock < 0.1 * capacity`), Defect (D) to avoid contributing to further depletion.

**Collective Mindset:**

The ACSDT strategy prioritizes cooperation when the common pool's stock is relatively high, adapting to opponent behavior and adjusting its trigger stock level accordingly. By doing so, it balances individual payoff maximization with collective sustainability. In cases where opponents defect frequently or the stock is critically low, the strategy adjusts to protect individual interests.

**Pseudocode:**
```python
def ACSDT(n, capacity, stock, round_num, avg_opponent_coop):
    # Initial Round
    if round_num == 1:
        return "C"

    # Stock-Based Trigger
    trigger_stock = capacity * (1 - 1/(n+1))

    # Opponent Behavior Adaptation
    if avg_opponent_coop > 0.5:
        trigger_stock *= 1.1
    else:
        trigger_stock *= 0.9

    # Last Round
    if round_num == r:
        return "D"

    # Edge Cases
    if n <= 3:
        trigger_stock = capacity * (1 - 1/(n+2))
    if stock < 0.1 * capacity:
        return "D"

    # Decision Rule
    if stock > trigger_stock:
        return "C"
    else:
        return "D"
```
Note that this strategy does not rely on explicit communication or coordination with other players, making it robust and adaptable to a wide range of opponent behaviors.
'''

description_COLLECTIVE_220 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation from other players.
2. **Stock-Based Threshold**: Monitor the current stock level (S) and adjust behavior based on its proximity to the capacity:
	* If S ≥ 0.75 × capacity, Cooperate (C).
	* If 0.25 × capacity ≤ S < 0.75 × capacity, Defect (D) with probability 0.5, otherwise Cooperate (C). This introduces a degree of randomness to our actions when the stock is moderately depleted.
	* If S < 0.25 × capacity, Defect (D).
3. **Recent Behavior**: Observe the average payoff per player over the last few rounds (e.g., 2-3 rounds) and adjust behavior accordingly:
	* If recent payoffs are high (> 75% of the maximum possible payoff), Cooperate (C).
	* Otherwise, Defect (D).

**Additional Logic:**

1. **Last Round**: In the final round, Cooperate (C) to avoid over-exploiting the stock and promote a sense of cooperation among players.
2. **Opponent Behavior Analysis**: Keep track of opponents' recent behavior:
	* If an opponent consistently Defects (D), respond with Defect (D).
	* If an opponent consistently Cooperates (C), reciprocate with Cooperate (C).

**Rationale:**

ASC balances individual payoff maximization with collective stock conservation. By:

1. **Initial cooperation**: Encouraging a cooperative atmosphere and establishing a baseline stock level.
2. **Adapting to the stock level**: Adjusting behavior based on the current stock, we ensure that players don't over-exploit or under-utilize the resource.
3. **Responding to recent payoffs**: Reacting to changes in average payoffs helps maintain a balance between individual and collective interests.

**Robustness:**

ASC is designed to handle various opponent behaviors:

1. **All Cooperate**: By initially cooperating, ASC promotes cooperation among all players.
2. **Mixed Strategies**: Adaptation to the stock level and recent behavior allows ASC to counter opponents' different strategies.
3. **Pure Defection**: Responding with Defect (D) when an opponent consistently defects ensures that ASC is not exploited.

**Pseudocode:**

```python
def adaptive_stock_conservation(current_stock, capacity, round_number, recent_payoffs, opponent_history):
    if round_number == 1:
        return 'C'  # Cooperate in the first round

    stock_threshold = 0.75 * capacity
    recent_payoff_threshold = 0.75  # adjust based on desired aggressiveness

    if current_stock >= stock_threshold or average(recent_payoffs) > recent_payoff_threshold:
        return 'C'
    elif 0.25 * capacity <= current_stock < stock_threshold and random.random() < 0.5:
        return 'D'
    else:
        return 'D'

    # Last round handling
    if round_number == total_rounds:
        return 'C'

    # Opponent behavior analysis (optional)
    opponent_strategy = analyze_opponent_behavior(opponent_history)
    if opponent_strategy == 'Always Defect':
        return 'D'
    elif opponent_strategy == 'Always Cooperate':
        return 'C'
```

ASC should perform well in a tournament setting, as it strikes a balance between individual payoff maximization and collective stock conservation. By adapting to the current state of the game and responding to opponents' behavior, ASC demonstrates robustness against various strategies.
'''

description_COLLECTIVE_221 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Subsequent Rounds:** Evaluate the current stock level (S) and the total consumption from the previous round (TC_prev).
3. **Conservation Threshold (CT):** Calculate CT as a fraction of the capacity, e.g., CT = 0.7 \* capacity. This threshold determines when to switch between cooperation and defection.
4. **Cooperate (C)** if:
	* S > CT and TC_prev ≤ (n/2) \* stock/(2n), indicating sufficient stock and moderate consumption.
	* S ≤ CT and the number of cooperators in the previous round is ≥ (n/2), suggesting a need to conserve stock collectively.
5. **Defect (D)** if:
	* S > CT and TC_prev > (n/2) \* stock/(2n), indicating high consumption and potential overexploitation.
	* S ≤ CT and the number of cooperators in the previous round is < (n/2), suggesting a need to exploit available resources individually.

**Pseudocode:**
```python
def ASC(n, capacity, r):
    # Initialize variables
    stock = capacity
    history = []

    for t in range(r):
        if t == 0:
            action = 'C'  # Cooperate in the first round
        else:
            S = stock
            TC_prev = sum(history[-1]['consumption'])
            CT = 0.7 * capacity

            if S > CT and TC_prev <= (n/2) * S/(2*n):
                action = 'C'
            elif S <= CT and history[-1]['cooperators'] >= n/2:
                action = 'C'
            else:
                action = 'D'

        # Calculate consumption based on action
        if action == 'C':
            consumption = S / (2 * n)
        else:
            consumption = S / n

        # Update stock and history
        stock -= consumption + sum(history[-1]['consumption'])
        stock = min(stock + 2 * stock * (1 - stock/capacity), capacity)
        history.append({'action': action, 'consumption': consumption, 'cooperators': len([h for h in history if h['action'] == 'C'])})

    return history
```
**Edge Cases:**

* **Last Round:** In the final round, defect (D) to maximize individual payoff, as there is no future stock to conserve.
* **Low Stock:** If the stock level falls below a certain threshold (e.g., 0.2 \* capacity), cooperate (C) to help replenish the stock.

**Collective Mindset:**

The ASC strategy prioritizes cooperation when the stock level is sufficient and consumption is moderate, encouraging others to do the same. When the stock level is low or consumption is high, it adapts by defecting to exploit available resources individually. By balancing individual payoffs with collective sustainability, ASC promotes a stable and resilient common pool resource management system.

This strategy is designed to be robust against various opponent behaviors and can adapt to different game parameters and initial conditions.
'''

description_COLLECTIVE_222 = '''
Here's a collective strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Cooperative Conservation (ACC)

**Decision Rules:**

1. **First Round:** Cooperate (C) to establish a baseline trust and set a precedent for cooperation.
2. **Subsequent Rounds:** Observe the previous round's outcomes, including:
	* The number of cooperators (n_C) and defectors (n_D).
	* The current stock level (S).
3. **Adaptive Threshold:** Calculate a dynamic threshold (T) based on the game state:

`T = (S / capacity) * (n - 1)`

Where `n` is the number of players.

4. **Cooperation Condition:** Cooperate if:
	* The previous round's stock level was above the capacity's midpoint (i.e., S > capacity/2).
	* The current stock level is above the adaptive threshold (i.e., S ≥ T).
	* At least one player cooperated in the previous round (n_C > 0).

**Defection Condition:** Defect if none of the cooperation conditions are met.

5. **Punishment Mechanism:** If a player defects and their payoff exceeds twice the average cooperative payoff, they will be "punished" by being treated as a defector for two consecutive rounds.

6. **Exploration Phase:** For every 10th round, introduce an exploration phase where each player randomly chooses to cooperate or defect with a probability of 0.5. This helps maintain adaptability and prevents strategies from becoming too predictable.

**Edge Cases:**

1. **Last Round:** Cooperate if the current stock level is above the capacity's midpoint; otherwise, defect.
2. **Low Stock Levels:** If the stock level falls below 10% of the capacity, all players will cooperate to avoid depletion.
3. **High Defection Rates:** If more than half the players defected in the previous round (n_D > n/2), introduce a "punishment phase" where all players cooperate for two consecutive rounds.

**Collective Mindset:**

The ACC strategy is designed to promote cooperation while adapting to changing game conditions and opponent behaviors. By maintaining a balance between cooperation and self-interest, the collective can achieve better overall payoffs than individualistic strategies. The adaptive threshold and punishment mechanism ensure that cooperation remains an attractive option even when some players defect.

**Pseudocode:**
```
ACC_Strategy(player_id, current_round, previous_outcomes):
  if first_round:
    return COOPERATE
  else:
    S = current_stock_level()
    n_C = num_cooperators(previous_outcomes)
    n_D = num_defectors(previous_outcomes)
    
    T = (S / capacity) * (n - 1)
    
    if S > capacity/2 and S >= T and n_C > 0:
      return COOPERATE
    else:
      return DEFECT
    
    # Punishment mechanism and exploration phase logic omitted for brevity
```
This strategy aims to provide a robust and adaptive approach to the Common Pool Resource Game, promoting cooperation while being mindful of individual self-interest.
'''

description_COLLECTIVE_223 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

The AC strategy is designed to balance individual payoffs with collective sustainability, adapting to various opponent behaviors while promoting cooperation.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and encourage others to follow.
2. **Stock-dependent Cooperation**: If the current stock level `S` is above 75% of the capacity (`S > 0.75 * capacity`), cooperate (C). This ensures that when the stock is relatively high, cooperation helps maintain it while allowing for moderate consumption.
3. **Defect-based Trigger**: If at least one player defected (D) in the previous round and the current stock level `S` is below 50% of the capacity (`S < 0.5 * capacity`), defect (D). This rule prevents over-exploitation by punishing defection when the stock is low.
4. **Reciprocal Cooperation**: If all players cooperated (C) in the previous round, cooperate (C) again. This encourages sustained cooperation among players who have established a cooperative pattern.

**Edge Cases**

1. **Last Round**: Cooperate (C) in the last round to ensure that the game concludes on a cooperative note and maintain a positive reputation.
2. **Low Stock**: If the current stock level `S` is below 25% of the capacity (`S < 0.25 * capacity`) at any point, cooperate (C) to prevent over-exploitation and allow for some recovery.

**Collective Mindset**

The AC strategy prioritizes cooperation when possible, while adapting to potential defections by others. By responding reciprocally and conditionally on the stock level, AC promotes a collective mindset that balances individual payoffs with sustainability concerns.

**Pseudocode**
```markdown
function AdaptiveCooperation(current_stock, previous_actions, capacity):
  if first_round:
    return COOPERATE

  if current_stock > 0.75 * capacity:
    return COOPERATE

  if any(defector in previous_actions) and current_stock < 0.5 * capacity:
    return DEFECT

  if all(cooperator in previous_actions):
    return COOPERATE

  if last_round or current_stock < 0.25 * capacity:
    return COOPERATE

  # default: DEFECT (in case of uncertainty or missing information)
```
This strategy is designed to be robust, adaptive, and collective, making it a strong contender in the tournament against independent AI strategies.
'''

description_COLLECTIVE_224 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Tit-for-Tat (ACSDT)**

Our collective strategy, ACSDT, aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. We employ a tit-for-tat approach, modified to account for the dynamic stock level.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and avoid initial over-consumption.
2. **Stock-Dependent Tit-for-Tat:** Observe the previous round's actions and adjust your strategy based on the current stock level:
	* If the stock level is above 75% of capacity, cooperate (C) if most players cooperated in the previous round (> 50%). Otherwise, defect (D).
	* If the stock level is between 25% and 75% of capacity, mirror the majority action from the previous round. If there's a tie, cooperate.
	* If the stock level is below 25% of capacity, defect (D) to maximize individual payoff in a depleted environment.
3. **Punishment:** If you cooperated and most players defected in the previous round (> 50%), defect in the current round to punish free-riders.
4. **Forgiveness:** After punishing, return to the stock-dependent tit-for-tat strategy.

**Edge Cases:**

1. **Last Round:** Cooperate (C) in the final round to ensure a sustainable conclusion and avoid over-consumption.
2. **Ties:** In cases where there's a tie in the majority action or when determining cooperation/defection, cooperate (C).

**Pseudocode:**
```markdown
# ACSDT Strategy

function ACSDT(stock_level, prev_round_actions):
  # Initial Round
  if round == 1:
    return COOPERATE

  # Stock-Dependent Tit-for-Tat
  if stock_level >= 0.75 * capacity:
    majority_action = most_common(prev_round_actions)
    if majority_action == COOPERATE:
      return COOPERATE
    else:
      return DEFECT
  elif 0.25 * capacity <= stock_level < 0.75 * capacity:
    mirror_majority(prev_round_actions)
  else:  # Stock level is low
    return DEFECT

  # Punishment and Forgiveness
  if prev_cooperation && most_defected(prev_round_actions):
    return DEFECT
  elif prev_punishment:
    return to_stock_dependent_tit_for_tat(stock_level, prev_round_actions)

function mirror_majority(actions):
  majority_action = most_common(actions)
  if majority_action == COOPERATE:
    return COOPERATE
  else:
    return DEFECT

function most_common(actions):
  # Return the most common action in the list
```
ACSDT aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. By cooperating when the stock level is high and punishing free-riders, we promote cooperation while avoiding over-consumption. When the stock level is low, ACSDT prioritizes individual payoffs through defection. This strategy should perform well in a tournament against independent strategies, as it balances short-term gains with long-term sustainability.
'''

description_COLLECTIVE_225 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Trigger (ACST)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline for cooperation and gather information on opponents' behavior.
2. **Subsequent Rounds:** Defect (D) if the current stock level is below 50% of capacity or if the average payoff per player in the previous round was less than 25% of the maximum possible payoff (i.e., stock/(2n)). Otherwise, Cooperate (C).
3. **Stock-Based Trigger:** If the current stock level exceeds 75% of capacity, switch to Defect (D) for one round to harvest excess resources and prevent overgrowth.
4. **History-Based Adjustment:** Monitor opponents' behavior and adjust the strategy as follows:
	* If an opponent defects in a previous round, increase the likelihood of defecting by 10% in the next round.
	* If an opponent cooperates in a previous round, decrease the likelihood of defecting by 5% in the next round.

**Edge Cases:**

1. **Last Round:** Cooperate (C) to maximize collective payoff and maintain a positive relationship with opponents.
2. **Low Stock Levels:** If the current stock level is below 25% of capacity, Defect (D) to ensure some payoff, even if it means reducing the stock further.

**Collective Mindset:**

ACST prioritizes cooperation while adapting to changes in the game state and opponent behavior. By cooperating initially and adjusting based on stock levels and history, ACST aims to:

1. Establish a cooperative baseline
2. Harvest resources when the stock is high
3. Prevent overgrowth by defecting occasionally
4. Adapt to opponents' behavior to maintain a balance between cooperation and self-interest

**Pseudocode:**
```python
def ACST(stock, capacity, n, history):
    if round == 1:
        return C
    elif stock < 0.5 * capacity or avg_payoff_prev_round < 0.25 * max_payoff:
        return D
    elif stock > 0.75 * capacity:
        return D (switch to defect for one round)
    else:
        cooperate_prob = 0.7  # initial probability of cooperating
        for opponent in history:
            if opponent.defected_prev_round:
                cooperate_prob -= 0.1
            elif opponent.cooperated_prev_round:
                cooperate_prob += 0.05
        return C if random.random() < cooperate_prob else D

    # Last round adjustment
    if round == r:
        return C

    # Low stock level adjustment
    if stock < 0.25 * capacity:
        return D
```
ACST is a robust and adaptive strategy that balances cooperation with self-interest, making it suitable for a wide range of opponent behaviors in the Common Pool Resource Game.
'''

description_COLLECTIVE_226 = '''
I'll outline a collective strategy for this Common Pool Resource Game that adapts to various opponent behaviors and ensures long-term sustainability of the common pool resource. Here's the proposed strategy:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round, setting a positive tone for cooperation and allowing us to observe others' actions.
2. **Conservation Threshold:** Set a dynamic conservation threshold, `θ`, based on the current stock level, `S`. When `S` falls below `θ`, switch from Cooperation (C) to Defection (D). Initially, set `θ = 0.5 * capacity`.
3. **Opponent Behavior Analysis:** Monitor opponents' actions and update a "cooperation score" for each opponent based on their past behavior:
	* `coop_score_i += 1` if opponent `i` cooperates in the current round.
	* `coop_score_i -= 1` if opponent `i` defects in the current round.
4. **Adaptive Cooperation:** Cooperate (C) when at least half of the opponents have a positive cooperation score (`coop_score_i > 0`). This encourages others to maintain cooperative behavior while adapting to potential free-riders.
5. **Defection Prevention:** If more than half of the opponents defect (D), or if the current stock level `S` is below `θ`, switch to Defect (D) to prevent over-exploitation and protect our own payoff.

**Edge Cases:**

1. **Last Round:** Cooperate (C) in the last round, as there's no need to worry about future consequences.
2. **Low Stock Levels:** If `S` falls below a critical level (`S < 0.25 * capacity`), switch to Defect (D) to ensure some payoff, even if it means depleting the resource.

**Collective Mindset:**

ACC prioritizes collective well-being by balancing individual payoffs with conservation and sustainability goals. By adapting to opponents' behavior and conserving the resource when necessary, we promote a mutually beneficial outcome for all players.

Pseudocode (simplified):
```python
def ACC(n, capacity, S, rounds, history):
    θ = 0.5 * capacity  # Conservation threshold
    coop_scores = [0] * n  # Cooperation scores for opponents

    for round in range(rounds):
        if round == 0:  # Initial round
            action = C
        else:
            opponent_actions = get_opponent_actions(history)
            update_coop_scores(coop_scores, opponent_actions)

            if sum(1 for score in coop_scores if score > 0) >= n / 2:
                action = C
            elif S < θ or sum(opponent_actions == D) > n / 2:
                action = D

        # Update stock level and growth
        consume_stock(S, action)
        update_stock_growth(S)

    return total_payoff(history)
```
This strategy should perform well in the tournament against independent strategies, as it balances individual self-interest with collective conservation goals and adapts to various opponent behaviors.
'''

description_COLLECTIVE_227 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC is a dynamic, adaptive strategy that balances individual payoffs with collective sustainability. It responds to the game's state and history, ensuring robustness against diverse opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):**
   - Observe the initial stock level.
   - If `stock` ≥ `(3/4) * capacity`, cooperate (C).
   - Else, defect (D).

2. **Subsequent Rounds (t > 1):**
   - Calculate the average stock depletion rate over previous rounds: `depletion_rate = total_depletion / (t-1)`
   - If `stock` ≥ `(3/4) * capacity` and `depletion_rate` ≤ `capacity / (2n * r)`, cooperate (C).
   - If `stock` < `(3/4) * capacity` or `depletion_rate` > `capacity / (2n * r)`, defect (D).

**Edge Cases:**

- **Last Round (t=r):**
  - Defect (D), as there's no future stock to conserve.

- **Low Stock Levels:**
  - If `stock` ≤ `(1/4) * capacity`, cooperate (C) to avoid complete depletion and allow some growth.

**Collective Mindset Alignment:**

ASC prioritizes cooperation when the stock is high and the average depletion rate is sustainable. By doing so, it encourages collective conservation of the common pool resource while allowing for individual gains. When the stock is low or depletion rates are unsustainable, ASC adapts by defecting to secure immediate payoffs, recognizing that collective sustainability may be compromised.

**Pseudocode:**

```
def ASC(stock, capacity, n, r, t, total_depletion):
    if t == 1:
        if stock >= (3/4) * capacity:
            return 'C'
        else:
            return 'D'

    depletion_rate = total_depletion / (t-1)

    if stock >= (3/4) * capacity and depletion_rate <= capacity / (2n * r):
        return 'C'
    elif stock < (1/4) * capacity:  # Adjusted condition for clarity
        return 'C'
    else:
        return 'D'

def ASC_last_round(stock, capacity, n, r, t):
    if t == r:
        return 'D'
```

**Implementation Notes:**

- The strategy will be implemented as an algorithm that iterates through each round of the game.
- It will keep track of the total depletion and current stock levels to make informed decisions.
- ASC is designed to adapt to various opponent behaviors, prioritizing collective sustainability when possible while securing individual payoffs in less favorable conditions.
'''

description_COLLECTIVE_228 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) with probability 0.8 and Defect (D) with probability 0.2.
2. **Subsequent Rounds:** Evaluate the stock level (S) and opponent behavior history.
	* If S ≥ capacity/2, cooperate (C).
	* If S < capacity/2, defect (D) if:
		+ Average opponent payoff in previous rounds is greater than your average payoff.
		+ More opponents defected than cooperated in the previous round.
3. **Opponent Behavior Analysis:** Maintain a simple moving average of opponents' payoffs and actions over the last 3-5 rounds.

**Pseudocode:**
```
function ACHStrategy(n, capacity, r, S, history):
  // Initialize cooperation probability
  coop_prob = 0.8
  
  if round == 1:
    return cooperate() with prob coop_prob, defect() otherwise
    
  // Evaluate stock level and opponent behavior
  if S >= capacity/2:
    return cooperate()
  else:
    avg_opponent_payoff = calculate_avg_opponent_payoff(history)
    avg_your_payoff = calculate_avg_your_payoff(history)
    
    if avg_opponent_payoff > avg_your_payoff:
      // Opponents doing better, defect
      return defect()
    elif opponents_defected_more(history):
      // More opponents defected last round, defect
      return defect()
    else:
      // Cooperate otherwise
      return cooperate()

function calculate_avg_opponent_payoff(history):
  // Calculate average payoff of all opponents over the last 3-5 rounds

function calculate_avg_your_payoff(history):
  // Calculate your average payoff over the last 3-5 rounds

function opponents_defected_more(history):
  // Check if more opponents defected than cooperated in the previous round
```
**Edge Cases:**

* **Last Round:** Cooperate (C) to maximize collective payoff, as there's no future interaction.
* **Low Stock Levels:** Defect (D) when stock levels are critically low (S < capacity/4), to minimize losses.

**Collective Mindset:**

The ACH strategy aims to balance individual payoffs with the need for cooperation to maintain a healthy stock level. By adapting to opponent behavior and stock dynamics, it promotes collective sustainability while protecting against exploitation.

This strategy does not rely on explicit coordination mechanisms or shared norms. Instead, it uses simple heuristics and moving averages to analyze opponent behavior, making it robust to various opponent strategies.
'''

description_COLLECTIVE_229 = '''
I'll outline a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and balances individual payoff maximization with long-term sustainability of the common pool.

**Strategy Name: Adaptive Collective Sustainability (ACS)**

**Decision Rules:**

1. **Initial Round:** In the first round, cooperate (C) unconditionally to establish a baseline for stock growth and encourage opponents to reciprocate.
2. **Current Stock Assessment:** Evaluate the current stock level (S) relative to the capacity (capacity). If S ≥ 0.75 \* capacity, consider the pool relatively full; otherwise, it's considered depleted.
3. **Adaptive Cooperation Threshold:** Introduce a dynamic cooperation threshold (θ) that adjusts based on the opponent behavior and stock levels. Initially, θ = 0.5.

a. **Cooperation Phase:** When S ≥ 0.75 \* capacity, cooperate if at least θ fraction of opponents cooperated in the previous round. Otherwise, defect.

b. **Defection Phase:** When S < 0.75 \* capacity, defect unless at least (1 - θ) fraction of opponents defected in the previous round. If so, cooperate to avoid over-exploitation.

4. **History-Based Adjustments:** After each round, update θ based on the observed opponent behavior:
   a. If more than 0.75 \* n players cooperated, increase θ by 0.05.
   b. If fewer than 0.25 \* n players cooperated, decrease θ by 0.05.

**Edge Cases:**

1. **Last Round:** In the final round (t = r), always defect to maximize individual payoff.
2. **Low Stock Levels:** When S < 0.25 \* capacity, cooperate unconditionally to help replenish the stock and avoid complete depletion.

**Pseudocode:**
```markdown
# Initialize variables
θ = 0.5  # cooperation threshold
previous_opponent_cooperation = []  # list of opponent cooperation rates

for t in range(1, r+1):
    # Current round logic
    S = current_stock_level()
    
    if t == 1:
        action = COOPERATE  # initial round cooperation
    
    elif S >= 0.75 * capacity:
        opponent_cooperation_rate = assess_opponent_cooperation(previous_opponent_cooperation)
        
        if opponent_cooperation_rate >= θ:
            action = COOPERATE
        else:
            action = DEFECT
    
    else:  # S < 0.75 * capacity
        opponent_defection_rate = 1 - opponent_cooperation_rate
        
        if opponent_defection_rate > (1 - θ):
            action = COOPERATE
        else:
            action = DEFECT
    
    # Update cooperation threshold and previous opponent behavior
    update_θ(opponent_cooperation_rate)
    previous_opponent_cooperation.append(opponent_cooperation_rate)

# Last round logic
if t == r:
    action = DEFECT

return action
```
**Collective Mindset:** ACS balances individual payoff maximization with long-term sustainability by adapting to opponent behavior and current stock levels. By cooperating when the pool is full and defecting when it's depleted, ACS promotes a collective effort to maintain a healthy common resource.

This strategy will be implemented as an algorithm for participation in the tournament against other independent strategies developed by AI systems.
'''

description_COLLECTIVE_230 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. This approach prioritizes cooperation when the stock is healthy and gradually shifts towards defection as the stock depletes.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock-dependent Cooperation Threshold**: Define a threshold, `τ`, based on the current stock level (`S`) and capacity (`c`): `τ = 0.5 * (1 - S/c)`. If `τ < 0.33`, cooperate (C); otherwise, defect (D). This rule encourages cooperation when the stock is above two-thirds of its capacity.
3. **Defection Trigger**: If a player observes that more than half of the opponents defected in the previous round (`n_defectors >= n/2`), they will defect (D) in the current round to avoid exploitation.
4. **History-based Adjustment**: Track the average payoff per round (`avg_payoff`) over the past `r/2` rounds. If `avg_payoff` is below a certain threshold (`payoff_threshold = 0.75 * capacity/n`), increase the cooperation threshold (`τ`) by `0.1`. Conversely, if `avg_payoff` exceeds the threshold, decrease `τ` by `0.1`. This adjustment helps the strategy adapt to changing opponent behaviors.
5. **Endgame Strategy**: In the last round (`t = r`), defect (D) regardless of the stock level or previous actions, as there is no future benefit to cooperation.

**Pseudocode:**
```python
def ASC(n, c, S, t, history):
  # Initial round cooperation
  if t == 1:
    return C
  
  # Stock-dependent cooperation threshold
  τ = 0.5 * (1 - S/c)
  if τ < 0.33:
    return C
  
  # Defection trigger
  n_defectors = sum(history[-1]['actions'] == D for _ in range(n))
  if n_defectors >= n/2:
    return D
  
  # History-based adjustment
  avg_payoff = sum(history[-r//2:]['payoffs']) / (r//2)
  payoff_threshold = 0.75 * c/n
  if avg_payoff < payoff_threshold:
    τ += 0.1
  elif avg_payoff > payoff_threshold:
    τ -= 0.1
  
  # Endgame strategy
  if t == r:
    return D
  
  # Default to cooperation if no conditions met
  return C
```
The ASC strategy balances individual payoffs with collective sustainability by adapting to the game's state and history. By cooperating when the stock is healthy and gradually shifting towards defection as the stock depletes, ASC promotes a balanced approach that can handle various opponent behaviors.
'''

description_COLLECTIVE_231 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability of the common pool resource. It adapts to the game state and history, responding to opponents' actions while prioritizing long-term cooperation.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline for cooperation and encourage others to do the same.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, cooperate (C) to maintain a sustainable consumption rate.
	* If the stock level is between 50% and 75% of capacity, defect (D) with probability p = (capacity - stock) / (0.25 \* capacity). This introduces a degree of defection to signal concern about the declining stock.
	* If the stock level is below 50% of capacity, defect (D) to maximize individual payoff in the short term, as cooperation may not be sufficient to recover the stock.
3. **Response to Opponents' Actions:**
	* Monitor the average opponent action (AOA) over the last few rounds (e.g., 3-5 rounds).
	* If AOA is predominantly cooperative (≥ 0.6), cooperate (C) to reinforce cooperation and maintain a healthy stock.
	* If AOA is mixed or predominantly defective (< 0.6), adjust the ASC strategy as follows:
		+ Increase defection probability p by 0.1 for each 10% decrease in average opponent cooperation below 0.6.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Low Stock Levels:** If the stock level falls below 25% of capacity, cooperate (C) in an attempt to revive the stock and avoid complete depletion.

**Collective Mindset:**

The ASC strategy prioritizes collective sustainability while adapting to opponents' actions. By cooperating when the stock is healthy and responding to opponents' defections, ASC encourages cooperation and maintains a stable common pool resource.

Pseudocode:
```
function ASC(stock, capacity, n, t) {
  if (t == 1) return C; // Initial round: Cooperate
  if (stock > 0.75 * capacity) return C; // High stock: Cooperate
  if (stock >= 0.5 * capacity && stock < 0.75 * capacity) {
    p = (capacity - stock) / (0.25 * capacity);
    return random() < p ? D : C;
  }
  if (stock < 0.5 * capacity) return D; // Low stock: Defect
}

function adjust_ASC(stock, opponents_actions, n, t) {
  AOA = average(opponents_actions); // Average opponent action over last few rounds
  if (AOA >= 0.6) return C;
  p = (capacity - stock) / (0.25 * capacity);
  p += (1 - AOA) * 0.1; // Increase defection probability based on opponents' actions
  return random() < p ? D : C;
}

function last_round(stock, capacity, n, t) {
  if (t == r) return D; // Last round: Defect
}
```
Note that this pseudocode is a simplified representation of the ASC strategy and may require modifications for implementation.
'''

description_COLLECTIVE_232 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and maximizes long-term payoffs:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline stock level and encourage cooperation from other players.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Cooperate (C) to maintain a sustainable stock level.
	* If the current stock level is between 50% and 75% of capacity, Defect (D) with probability p = (capacity - stock) / (0.25 \* capacity). This introduces a degree of " exploration" to test opponents' responses while still conserving resources.
	* If the current stock level is below 50% of capacity, Cooperate (C) to prevent further depletion and encourage recovery.
3. **Last Round (t=r):** Defect (D) to maximize individual payoff, as there's no future rounds to consider.

**Edge Case Handling:**

1. **Tiebreakers:** In cases where the probability calculation results in a tie (e.g., p = 0.5), Cooperate (C) to favor conservation.
2. **Extreme Stock Levels:** If the stock level reaches 0 or capacity, adjust the decision rules accordingly:
	* At stock level 0: Defect (D) as there's no resource to conserve.
	* At capacity: Cooperate (C) to maintain sustainability.

**Collective Mindset Alignment:**

1. **Reciprocity:** If a player observes that most opponents (≥ n/2) cooperated in the previous round, they will Cooperate (C) in the current round to reciprocate and encourage continued cooperation.
2. **Punishment:** If a player observes that most opponents (≥ n/2) defected in the previous round, they will Defect (D) in the current round to punish non-cooperative behavior.

**Pseudocode:**
```
Function ACC(stock, capacity, t, r, history):
  if t == 1:
    return Cooperate
  else:
    stock_ratio = stock / capacity
    if stock_ratio >= 0.75:
      return Cooperate
    elif stock_ratio >= 0.5:
      p = (capacity - stock) / (0.25 * capacity)
      return Defect with probability p
    else:
      return Cooperate

  if t == r:
    return Defect

Function ACC_with_reciprocity(stock, capacity, t, r, history):
  opponents_cooperated = count(history[t-1] == Cooperate) >= n/2
  if opponents_cooperated:
    return Cooperate
  else:
    return ACC(stock, capacity, t, r, history)
```
This strategy balances individual self-interest with collective conservation, adapting to the game's dynamic state and opponent behaviors. By incorporating reciprocity and punishment mechanisms, ACC promotes cooperation while maintaining robustness against non-cooperative opponents.
'''

description_COLLECTIVE_233 = '''
Here's a collective strategy that adapts to various opponent behaviors and aims to optimize payoffs while maintaining a balance between cooperation and self-interest:

**Strategy Name:** Adaptive Stock Sustainer (ASS)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round, regardless of game parameters or state. This establishes an initial cooperative tone and gathers information about opponents' behaviors.
2. **Cooperation Threshold**: Introduce a dynamic cooperation threshold (CT) that adapts to the current stock level and number of players:
   CT = (stock / capacity) \* (n - 1)
   If CT > 0.5, cooperate; otherwise, defect.
3. **Recent History Analysis**: Analyze the actions taken by all players in the last round. If a majority (> n/2) cooperated, increase the cooperation threshold for this round:
   CT += 0.1
   Conversely, if a majority defected, decrease the threshold:
   CT -= 0.1
4. **Current Stock Evaluation**: Assess the current stock level in relation to capacity and adjust behavior accordingly:
   - If stock < (capacity / 2n), cooperate to help replenish the stock.
   - If stock > (3 \* capacity / 4), defect, as the stock is relatively high and can sustain some exploitation.
5. **Self-Interest Adjustment**: Monitor individual payoffs over the past few rounds and adjust behavior if payoffs are consistently lower than average:
   - If payoffs < (average payoff of all players) for more than two consecutive rounds, defect to increase personal gains.

**Edge Cases:**

* **Last Round**: Defect in the last round, as there is no future benefit from cooperation.
* **Stock Depletion**: If stock levels become critically low (< capacity / 4n), cooperate unconditionally to help replenish the stock and avoid depletion.
* **Opponent Consistency**: If an opponent consistently defects (or cooperates) across multiple rounds, mirror their behavior in the next round.

**Pseudocode:**
```python
def AdaptiveStockSustainer(n, capacity, r, current_stock, history):
  # Initial Round Cooperation
  if current_round == 1:
    return 'C'

  # Calculate Cooperation Threshold (CT)
  CT = (current_stock / capacity) * (n - 1)

  # Recent History Analysis
  recent_history_majority_cooperated = True if sum(history[-1]) > n/2 else False
  if recent_history_majority_cooperated:
    CT += 0.1
  else:
    CT -= 0.1

  # Current Stock Evaluation
  if current_stock < capacity / (2 * n):
    return 'C'
  elif current_stock > (3 * capacity) / 4:
    return 'D'

  # Self-Interest Adjustment
  personal_payoffs = []
  for i in range(len(history)):
    personal_payoffs.append(calculate_payoff(current_round - i))
  if len(personal_payoffs) > 2 and sum(personal_payoffs[-3:]) < (average_payoff_of_all_players() * 3):
    return 'D'

  # General Cooperation Threshold Check
  if CT > 0.5:
    return 'C'
  else:
    return 'D'
```
This strategy combines elements of Tit-for-Tat, cooperation threshold strategies, and self-interest adjustments to create a robust and adaptive approach that balances individual payoffs with collective sustainability.
'''

description_COLLECTIVE_234 = '''
**Collective Strategy: "Adaptive Cooperative Threshold" (ACT)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and observe opponents' initial actions.
2. **Cooperation Threshold**: Calculate a cooperation threshold based on the current stock level and number of players:
	* `threshold = capacity / (2 * n)`
3. **Stock-Based Cooperation**: If the current stock level is above the threshold, Cooperate (C). Otherwise, Defect (D).
4. **Opponent Action Analysis**: Observe opponents' actions in previous rounds and adjust the cooperation threshold accordingly:
	* If most opponents (> 50%) defected in the previous round, decrease the threshold by a small amount (`threshold -= epsilon`, where `epsilon` is a small positive value).
	* If most opponents cooperated in the previous round, increase the threshold by a small amount (`threshold += epsilon`).
5. **Last Round**: In the final round, Defect (D) to maximize personal payoff.

**Pseudocode:**
```markdown
def ACT(n, capacity, stock_history):
    # Initialize cooperation threshold
    threshold = capacity / (2 * n)

    for t in range(r):  # Iterate over rounds
        if t == 0:
            # Initial round: Cooperate
            action = C
        else:
            # Analyze previous opponents' actions
            opponent_actions = [opponent_action(t-1) for opponent in range(n)]
            defect_count = sum([action == D for action in opponent_actions])
            if defect_count > n/2:
                threshold -= epsilon  # Decrease threshold if most opponents defected
            elif defect_count < n/2:
                threshold += epsilon  # Increase threshold if most opponents cooperated

            # Stock-based cooperation
            if stock_history[t-1] > threshold:
                action = C
            else:
                action = D

        # Last round: Defect
        if t == r - 1:
            action = D

        return action
```
**Collective Mindset:**

The ACT strategy aims to balance individual self-interest with collective well-being by:

* Establishing a cooperative tone in the initial round
* Adapting cooperation based on current stock levels and opponents' actions
* Encouraging cooperation when the stock level is above a certain threshold
* Gradually adjusting the cooperation threshold in response to opponents' behavior

By being adaptive and responsive to changing game conditions, ACT aims to promote collective stability while ensuring individual competitiveness.
'''

description_COLLECTIVE_235 = '''
I'll outline a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and game states.

**Strategy Name: Adaptive Collective Conservation (ACC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and observe opponents' behavior.
2. **Stock-dependent Cooperation:** If the current stock level is above 75% of the capacity, cooperate (C). This ensures that the collective resource remains sustainable while allowing for moderate consumption.
3. **Defection Response:** If the total consumption in the previous round exceeds 50% of the capacity, defect (D) in the next round. This response aims to punish over-exploitation and encourage cooperation.
4. **Opponent Behavior Adaptation:** Monitor opponents' actions and adjust your strategy accordingly:
	* If most opponents (>50%) cooperated in the previous round, cooperate (C) in the next round.
	* If most opponents (>50%) defected in the previous round, defect (D) in the next round.
5. **Endgame Strategy:** In the last 10% of rounds (i.e., r × 0.1), always cooperate (C) to ensure a sustainable stock level for future generations.

**Edge Case Handling:**

* If the current stock level is below 25% of the capacity, defect (D) to maximize individual payoff.
* If an opponent's action is unknown or unobserved, assume they will defect (D).

**Collective Mindset Alignment:**

The ACC strategy prioritizes collective conservation and sustainability while allowing for individual adaptation to opponents' behavior. By cooperating when the stock level is high and responding to over-exploitation, ACC promotes a balanced approach that benefits both individuals and the collective.

**Pseudocode:**
```markdown
# Initialize variables
stock_level = capacity
round_number = 1

while round_number <= r:
  # Determine action based on current state and history
  if round_number == 1:
    action = COOPERATE
  elif stock_level >= 0.75 * capacity:
    action = COOPERATE
  elif total_consumption_previous_round > 0.5 * capacity:
    action = DEFECT
  else:
    # Adapt to opponent behavior
    if most_opponents_cooperated:
      action = COOPERATE
    else:
      action = DEFECT

  # Update stock level and history
  consume_stock(action)
  update_stock_level()
  record_history()

  # Endgame strategy
  if round_number > r * 0.9:
    action = COOPERATE

  round_number += 1
```
The ACC strategy aims to balance individual self-interest with collective conservation, adapting to various opponent behaviors and game states. By prioritizing sustainability and responding to over-exploitation, ACC promotes a robust and collective approach to managing the common pool resource.
'''

description_COLLECTIVE_236 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):**
	* If stock = capacity, cooperate (C) to conserve initial stock.
	* Otherwise, defect (D) to maximize initial payoff.
2. **Middle Rounds (1 < t < r):**
	* Calculate the average historical consumption rate per player: `avg_consumption = total_stock_depleted / (n * t)`
	* If `stock > capacity / 2` and `avg_consumption > stock / (2n)`, cooperate (C) to reduce overconsumption.
	* Otherwise, defect (D) to maximize individual payoff while maintaining a sustainable stock level.
3. **Final Round (t=r):**
	* Defect (D) to maximize individual payoff, as there's no future game state.

**Adaptive Components:**

1. **Stock-based cooperation threshold:** The strategy adjusts its cooperation threshold based on the current stock level. When the stock is high (`stock > capacity / 2`), ASC becomes more cooperative to prevent overconsumption.
2. **Historical consumption rate monitoring:** By tracking average historical consumption, ASC can identify when opponents are consistently defecting and adjust its behavior accordingly.

**Collective Mindset Alignment:**

1. **Conservation-oriented:** ASC prioritizes stock conservation when the game state allows for it, aligning with the collective goal of maintaining a sustainable common pool resource.
2. **Adaptive to opponent behaviors:** By monitoring historical consumption rates, ASC adapts to various opponent strategies, promoting robustness in a wide range of scenarios.

**Pseudocode:**
```python
def adaptive_stock_conservation(stock, capacity, n, t, r):
    if t == 1:
        if stock == capacity:
            return 'C'  # Cooperate on initial round with full stock
        else:
            return 'D'  # Defect on initial round with depleted stock

    avg_consumption = total_stock_depleted / (n * t)
    if stock > capacity / 2 and avg_consumption > stock / (2n):
        return 'C'  # Cooperate to reduce overconsumption
    else:
        return 'D'  # Defect to maximize individual payoff

def final_round_strategy(stock, capacity, n, r):
    return 'D'  # Defect on final round to maximize individual payoff
```
The ASC strategy balances short-term gains with long-term sustainability, making it a robust and adaptive collective strategy for the Common Pool Resource Game.
'''

description_COLLECTIVE_237 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' behaviors.
2. **Stock Assessment**: Evaluate the current stock level (`S`) relative to the capacity (`capacity`). If `S` is:
	* High (> 75% of `capacity`): Defect (D) with a probability of 20% + (10% \* number of previous rounds with high stock). This allows for moderate exploitation while maintaining some cooperation.
	* Medium (25%-75% of `capacity`): Cooperate (C) with a probability of 50% + (10% \* number of previous cooperative rounds). This balances individual payoffs and collective conservation.
	* Low (< 25% of `capacity`): Always Cooperate (C) to prioritize stock recovery.
3. **Opponent Behavior**: Analyze the history of opponents' actions:
	* If most opponents (> 50%) defected in the previous round, Defect (D) with a probability of 30% + (10% \* number of previous rounds with majority defection). This responds to exploitative behavior while avoiding complete defection.
	* Otherwise, maintain the stock-based decision rule (Step 2).
4. **Recent Payoff**: Consider the payoff from the previous round:
	* If the payoff was below average (< median payoff), Defect (D) with a probability of 20% + (10% \* number of previous rounds with low payoffs). This adapts to perceived unfairness or inefficiency.
5. **Last Round**: In the final round, Always Defect (D) to maximize individual payoff.

**Pseudocode**
```python
def ASC(n, capacity, stock, history):
    # Initialize variables
    S = stock / capacity
    cooperate_prob = 0.5

    # Initial round
    if len(history) == 0:
        return 'C'

    # Stock assessment
    if S > 0.75:
        defect_prob = 0.2 + (0.1 * len([round for round in history if round['stock'] > 0.75]))
        cooperate_prob = 1 - defect_prob
    elif S < 0.25:
        return 'C'

    # Opponent behavior analysis
    opponent_defections = sum(1 for round in history if round['opponents_defected'] > n / 2)
    if opponent_defections > len(history) / 2:
        defect_prob = 0.3 + (0.1 * opponent_defections)
        cooperate_prob = 1 - defect_prob

    # Recent payoff consideration
    recent_payoff = history[-1]['payoff']
    if recent_payoff < median([round['payoff'] for round in history]):
        defect_prob = 0.2 + (0.1 * len([round for round in history if round['payoff'] < median([r['payoff'] for r in history])]))
        cooperate_prob = 1 - defect_prob

    # Last round
    if len(history) == n:
        return 'D'

    # Randomly choose action based on probabilities
    import random
    if random.random() < cooperate_prob:
        return 'C'
    else:
        return 'D'
```
**Edge Cases**

* If multiple conditions are met, the strategy will prioritize the most specific one (e.g., last round takes precedence over stock assessment).
* In cases where the strategy would recommend both cooperation and defection, it will choose cooperation to maintain a collective mindset.

This Adaptive Stock Conservation strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. Its robustness lies in its ability to respond to various opponent behaviors while prioritizing stock conservation.
'''

description_COLLECTIVE_238 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

ACH is a dynamic, adaptive strategy that balances individual payoffs with collective sustainability. It's designed to promote cooperation while being robust against various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and gather information about opponents' behavior.
2. **Stock Assessment:** Evaluate the current stock level (S) relative to the capacity:
	* If S ≥ 0.75 \* capacity, Cooperate (C).
	* If 0.5 \* capacity ≤ S < 0.75 \* capacity, play a mixed strategy: Cooperate with probability 0.7 and Defect with probability 0.3.
	* If S < 0.5 \* capacity, Defect (D) to maximize individual payoff in the face of depleted resources.
3. **Opponent Behavior Analysis:** Observe the actions of other players in the previous round:
	* If at least 75% of opponents Cooperated (C), increase cooperation probability by 10%.
	* If fewer than 25% of opponents Cooperated (C), decrease cooperation probability by 20%.
4. **Payoff-Based Adjustment:** Adjust cooperation probability based on individual payoff relative to the average payoff:
	* If individual payoff is below the average, decrease cooperation probability by 15%.
	* If individual payoff is above the average, increase cooperation probability by 10%.

**Edge Cases:**

1. **Last Round:** In the final round (t = r), Defect (D) to maximize individual payoff.
2. **Stock Depletion:** If the stock level falls below 0.25 \* capacity, Defect (D) to avoid further depletion.

**Collective Mindset Alignment:**

ACH prioritizes cooperation when resources are plentiful and adjusts its strategy based on opponent behavior and individual payoffs. By doing so, it aims to maintain a sustainable collective outcome while being adaptable to various scenarios.

**Pseudocode:**
```markdown
# Initialize variables
cooperation_probability = 0.5
stock_thresholds = [0.75, 0.5]
opponent_behavior_weights = [0.1, -0.2]

# Loop through rounds
for t in range(1, r+1):
    # Evaluate current stock level
    if S >= stock_thresholds[0] * capacity:
        action = Cooperate (C)
    elif S < stock_thresholds[1] * capacity:
        action = Defect (D)
    else:
        # Mixed strategy
        cooperation_probability *= 0.7
        action = random.choice([Cooperate, Defect], p=[cooperation_probability, 1-cooperation_probability])

    # Analyze opponent behavior
    opponent_cooperations = count(C actions from other players in previous round)
    if opponent_cooperations >= 0.75 * n:
        cooperation_probability += 0.1
    elif opponent_cooperations < 0.25 * n:
        cooperation_probability -= 0.2

    # Adjust based on individual payoff
    if individual_payoff < average_payoff:
        cooperation_probability -= 0.15
    elif individual_payoff > average_payoff:
        cooperation_probability += 0.1

    # Edge cases
    if t == r:  # Last round
        action = Defect (D)
    elif S < 0.25 * capacity:  # Stock depletion
        action = Defect (D)

    # Take action and update state
    consume_stock(action)
    update_state()
```
Note that this pseudocode is a simplified representation of the strategy, and you may need to modify it for implementation in your specific programming language or environment.
'''

description_COLLECTIVE_239 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Stock-based Cooperation**: If the current stock level is above 50% of the capacity, cooperate (C). This ensures that when the stock is abundant, players prioritize sustainability over short-term gains.
3. **Adaptive Defection**: If the current stock level is below 50% of the capacity and the average consumption rate of other players in the previous round was high (>0.5*capacity/n), defect (D) to maximize individual payoff while the stock is scarce.
4. **Mirroring Opponents' Behavior**: Observe opponents' actions in the previous round:
	* If most opponents cooperated (≥ 50% of n), cooperate in this round to maintain a high stock level and mutual cooperation.
	* If most opponents defected (> 50% of n), defect in this round to protect individual interests against over-exploitation.
5. **Stock Recovery**: If the current stock level is very low (<20% of capacity) and has been declining for two consecutive rounds, cooperate (C) to help recover the stock.

**Edge Cases:**

1. **Last Round**: In the final round, defect (D) regardless of other conditions, as there is no future benefit from cooperation.
2. **Multiple Equilibria**: If multiple strategies are equally optimal based on past actions and current state, default to cooperation (C).
3. **No Previous Actions**: When no previous actions or stock levels are available (e.g., the first round), default to cooperation (C).

**Collective Mindset:**

The Adaptive Stock Preservation strategy prioritizes maintaining a sustainable stock level while adapting to opponents' behavior and the current state of the game. By balancing individual interests with collective well-being, ASP aims to achieve a stable equilibrium that benefits all players.

Pseudocode:
```markdown
// Initialize variables
stock = capacity
previous_stock = null
opponents_previous_actions = []
last_round_flag = false

// Main loop
for t in range(1, r+1):
    // Update last round flag
    if t == r:
        last_round_flag = true
    
    // Calculate average consumption rate of opponents (if applicable)
    avg_consumption_rate = calculate_avg_consumption_rate(opponents_previous_actions)
    
    // Determine action based on decision rules
    if stock > 0.5 * capacity or previous_stock is null:
        action = C
    elif avg_consumption_rate > 0.5 * capacity/n and stock < 0.5 * capacity:
        action = D
    elif most_opponents_cooperated(opponents_previous_actions):
        action = C
    elif most_opponents_defected(opponents_previous_actions):
        action = D
    elif stock < 0.2 * capacity and declining_for_two_rounds(previous_stock, stock):
        action = C
    else:
        action = C
    
    // Update variables for next iteration
    previous_stock = stock
    opponents_previous_actions.append(action)
    
    // Play the game
    play_game(action, stock)

// Helper functions
calculate_avg_consumption_rate(opponents_previous_actions):
    // Calculate average consumption rate of opponents based on their actions in the previous round
    
most_opponents_cooperated(opponents_previous_actions):
    // Check if most opponents cooperated in the previous round

declining_for_two_rounds(previous_stock, stock):
    // Check if the stock has been declining for two consecutive rounds
```
This strategy is designed to be adaptive and robust against various opponent behaviors while prioritizing collective well-being.
'''

description_COLLECTIVE_240 = '''
I'll design a collective strategy that adapts to various opponent behaviors while prioritizing sustainability and fairness.

**Strategy Name:** Adaptive Cooperative Sustainability (ACS)

**Decision Rules:**

1. **Initial Rounds (t ≤ n):**
	* Cooperate (C) in the first round to establish a cooperative tone.
	* In subsequent rounds, mirror the average cooperation rate of other players from previous rounds.
2. **Middle Game (n < t < r-2):**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 25% and 75% of capacity, choose an action randomly with a probability of cooperation increasing linearly from 0.5 to 1 as the stock level approaches 75%.
	* If the current stock level is below 25% of capacity, defect (D).
3. **Endgame (t ≥ r-2):**
	* Cooperate (C) if the current stock level is above 50% of capacity.
	* Defect (D) otherwise.

**Additional Considerations:**

1. **Opponent Adaptation:** Monitor opponents' cooperation rates and adjust the strategy accordingly. If an opponent defects frequently, ACS will defect more often as well.
2. **Stock Level Thresholds:** Adjust the stock level thresholds based on the game's history. If the stock level is consistently high or low, ACS may adjust its decision rules to prioritize sustainability or short-term gains.

**Collective Mindset:**

ACS prioritizes sustainability and fairness by:

1. Cooperating initially to establish a cooperative tone.
2. Adapting to opponents' behaviors while maintaining a bias toward cooperation when the stock level is sufficient.
3. Prioritizing sustainability over individual gains in the endgame.

**Pseudocode (simplified):**
```markdown
# Initialize variables
t = 1 // current round
n = number_of_players
r = number_of_rounds
capacity = maximum_sustainable_stock_level
stock = capacity // initial stock level

while t <= r:
    if t <= n: // initial rounds
        action = C // cooperate
    elif stock >= 0.75 * capacity: // middle game, high stock
        action = C // cooperate
    elif stock < 0.25 * capacity: // middle game, low stock
        action = D // defect
    else: // middle game, medium stock
        coop_prob = (stock - 0.25 * capacity) / (0.75 * capacity - 0.25 * capacity)
        if random() < coop_prob:
            action = C // cooperate
        else:
            action = D // defect

    // opponent adaptation and additional considerations
    observe_opponents()
    adjust_thresholds()

    // endgame
    if t >= r-2:
        if stock > 0.5 * capacity:
            action = C // cooperate
        else:
            action = D // defect

    # update state and history
    take_action(action)
    update_stock_level()
    increment_round(t += 1)

return total_payoff() // calculate total payoff over r rounds
```
This strategy is designed to be robust against a wide range of opponent behaviors while prioritizing sustainability and fairness. By adapting to the game's history and opponents' actions, ACS aims to achieve a high collective payoff in the tournament.
'''

description_COLLECTIVE_241 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Aware Threshold (ACST)**

**Overview**

ACST is a collective strategy that balances cooperation and defection based on the current stock level and game history. The goal is to maximize individual payoffs while maintaining a sustainable common pool resource.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation.
2. **Stock-Aware Threshold**: Calculate a dynamic threshold `T` based on the current stock level `S` and capacity `capacity`. `T = S / (2 * n)`
3. **Cooperation Condition**: If the number of players who cooperated in the previous round is greater than or equal to `n/2`, cooperate (C) if `S > T`. Otherwise, defect (D).
4. **Defection Condition**: If the number of players who defected in the previous round is greater than or equal to `n/2`, defect (D) if `S < capacity / 2`. Otherwise, cooperate (C).
5. **Stock Depletion Response**: If the stock level has been depleted by more than half in a single round, cooperate (C) for one round to allow the stock to recover.
6. **Endgame Strategy**: In the last two rounds, if the stock level is below `capacity / 4`, defect (D) to maximize individual payoffs.

**Pseudocode**
```python
def ACST(n, capacity, S, history):
    # Initialize variables
    T = S / (2 * n)
    
    # Initial round cooperation
    if len(history) == 0:
        return C
    
    # Calculate number of cooperators and defectors in previous round
    num_cooperators = sum([1 for action in history[-1] if action == C])
    num_defectors = n - num_cooperators
    
    # Cooperation condition
    if num_cooperators >= n / 2 and S > T:
        return C
    
    # Defection condition
    elif num_defectors >= n / 2 and S < capacity / 2:
        return D
    
    # Stock depletion response
    if len(history) > 1 and (S - history[-2][0]) / capacity > 0.5:
        return C
    
    # Endgame strategy
    if len(history) >= r - 2 and S < capacity / 4:
        return D
    
    # Default to cooperation
    return C
```
**Collective Mindset**

ACST is designed to promote collective cooperation while adapting to various opponent behaviors. By considering the current stock level, game history, and number of cooperators and defectors, ACST aims to:

* Encourage cooperation when the stock level is high and most players are cooperating.
* Discourage defection when the stock level is low and most players are defecting.
* Respond to stock depletion by allowing the stock to recover.
* Maximize individual payoffs in endgame scenarios.

By following these decision rules, ACST should perform well in a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_242 = '''
To design a collective strategy for this Common Pool Resource Game that is adaptive and robust to various opponent behaviors, I propose the "Adaptive Harvesting Strategy" (AHS). AHS aims to balance individual payoffs with collective sustainability by dynamically adjusting cooperation levels based on game state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for sustainable harvesting.
2. **Stock-Based Threshold**: Introduce a dynamic threshold, `stock_threshold`, which is initially set to `capacity / 2`. Update this threshold at each round based on the current stock level:
	* If `stock >= capacity / 2`, increase `stock_threshold` by 10% (up to `capacity`).
	* If `stock < capacity / 4`, decrease `stock_threshold` by 20% (down to `0`).
3. **Cooperation vs Defection**: Determine the action for each round based on the current stock level and threshold:
	+ If `stock >= stock_threshold`, Cooperate (C).
	+ If `stock < stock_threshold`, Defect (D) with probability `p_defect`, which is calculated as follows:
		- `p_defect = (capacity - stock) / capacity`
4. **Punishment Mechanism**: Introduce a "punishment" mechanism to deter excessive defection by others. If the total consumption in a round exceeds 75% of the current stock, reduce `stock_threshold` by 30% for the next round.
5. **Learning and Adaptation**: After each round, update the strategy based on the observed actions of other players:
	+ If most players (>50%) cooperated, increase `p_defect` by 10%.
	+ If most players (>50%) defected, decrease `p_defect` by 20%.

**Edge Cases:**

1. **Last Round**: In the final round, Defect (D) to maximize individual payoff.
2. **Low Stock Levels**: When the stock level falls below a certain threshold (`capacity / 4`), Cooperate (C) to ensure some growth for future rounds.

Pseudocode:
```python
def adaptive_harvesting_strategy(stock, capacity, history):
    # Initialize parameters
    stock_threshold = capacity / 2
    p_defect = 0.5

    # Update stock threshold based on current stock level
    if stock >= capacity / 2:
        stock_threshold *= 1.1
    elif stock < capacity / 4:
        stock_threshold *= 0.8

    # Determine action for this round
    if stock >= stock_threshold:
        return 'C'
    else:
        p_defect = (capacity - stock) / capacity
        if random.random() < p_defect:
            return 'D'

    # Punishment mechanism
    total_consumption = sum(history[-1])
    if total_consumption > 0.75 * stock:
        stock_threshold *= 0.7

    # Learning and adaptation
    coop_players = sum(1 for action in history[-1] if action == 'C')
    defect_players = len(history[-1]) - coop_players
    if coop_players > defect_players:
        p_defect *= 1.1
    else:
        p_defect *= 0.8

    return adaptive_harvesting_strategy(stock, capacity, history)
```
This strategy is designed to be collective and robust, adapting to various opponent behaviors while prioritizing sustainability and individual payoffs.
'''

description_COLLECTIVE_243 = '''
I propose a collective strategy called "Adaptive Stock Conservation" (ASC) for the Common Pool Resource Game. The goal of ASC is to balance individual payoffs with long-term stock sustainability, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to observe opponents' initial actions and establish a cooperative baseline.
2. **Stock-Based Cooperation**: If the current stock level `S` is above 75% of capacity (`0.75 * capacity`), cooperate (C). This ensures that when the stock is relatively abundant, players prioritize conservation.
3. **Defection Detection**: Monitor opponents' actions in previous rounds. If an opponent defects (D) in more than half of the previous rounds, defect (D) in the current round. This rule detects and responds to frequent defectors, preventing exploitation.
4. **Reciprocal Cooperation**: If most opponents (>50%) cooperated in the previous round, cooperate (C). This encourages reciprocal cooperation when a majority of players demonstrate cooperative behavior.
5. **Stock-Based Defection**: If the current stock level `S` is below 25% of capacity (`0.25 * capacity`), defect (D). When the stock is severely depleted, prioritize short-term gains to maximize individual payoffs.

**Edge Cases:**

* **Last Round**: In the final round, cooperate (C) if the stock level is above 50% of capacity; otherwise, defect (D).
* **Tie-Breaking**: In case of a tie in the decision rules (e.g., when an opponent has defected exactly half the time), prioritize cooperation (C).

**Pseudocode:**

```python
def ASC(stock, capacity, history):
  if round == 1:
    return COOPERATE

  # Stock-based cooperation
  if stock > 0.75 * capacity:
    return COOPERATE

  # Defection detection
  opponent_defections = sum(1 for action in history[-n:] if action == DEFECT)
  if opponent_defections > n / 2:
    return DEFECT

  # Reciprocal cooperation
  previous_cooperations = sum(1 for action in history[-n:] if action == COOPERATE)
  if previous_cooperations > n / 2:
    return COOPERATE

  # Stock-based defection
  if stock < 0.25 * capacity:
    return DEFECT

  # Last round handling
  if round == r:
    if stock > 0.5 * capacity:
      return COOPERATE
    else:
      return DEFECT

  # Tie-breaking (cooperation)
  return COOPERATE
```

**Collective Mindset:**

ASC prioritizes cooperation when the stock is relatively abundant, and adapts to opponents' behaviors by detecting frequent defectors and reciprocating cooperation. By balancing individual payoffs with long-term stock sustainability, ASC promotes a collective mindset that benefits all players while being robust to various opponent strategies.

This strategy will participate in the tournament against other AI systems, aiming to achieve a high total payoff while conserving the common pool resource for future rounds.
'''

description_COLLECTIVE_244 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Tit-for-Tat (ACSDT)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline for cooperation and to encourage others to do the same.
2. **Subsequent Rounds:** Implement a stock-dependent tit-for-tat strategy:
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of the capacity, mirror the opponent's previous action (i.e., if they cooperated, cooperate; if they defected, defect).
	* If the current stock level is below 50% of the capacity, defect (D) to maximize individual payoff in a depleted environment.
3. **Opponent Detection:** Monitor opponents' actions and adjust the strategy based on their behavior:
	* If an opponent consistently cooperates, cooperate with them to maintain mutual benefits.
	* If an opponent consistently defects, defect against them to minimize losses.

**Edge Cases:**

1. **Last Round:** Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Single Opponent:** Cooperate (C) in the initial round and mirror their action in subsequent rounds, adapting to their behavior.
3. **Multiple Opponents with Different Strategies:** Focus on the majority's behavior and adapt accordingly.

**Collective Mindset:**

1. **Cooperation:** Encourage cooperation when the stock level is high to maintain a sustainable environment for all players.
2. **Tit-for-Tat:** Mirror opponents' actions when the stock level is moderate to balance individual interests with collective well-being.
3. **Defection:** Defect when the stock level is low to maximize individual payoff in a depleted environment.

**Pseudocode:**
```python
def ACSDT(stock, capacity, num_opponents, history):
    if current_round == 1:
        return "C"  # Cooperate in initial round

    stock_level = stock / capacity
    opponent_actions = get_opponent_actions(history)

    if stock_level > 0.75:
        return "C"  # Cooperate when stock is high
    elif stock_level >= 0.5:
        return mirror(opponent_actions)  # Tit-for-Tat
    else:
        return "D"  # Defect when stock is low

def mirror(opponent_actions):
    if all(opponent_actions == "C"):
        return "C"
    elif all(opponent_actions == "D"):
        return "D"
    else:
        return opponent_actions[-1]  # Mirror last action
```
This strategy balances individual interests with collective well-being, adapting to the game state and opponents' behavior. By cooperating when the stock level is high and defecting when it's low, ACSDT promotes a sustainable environment while maximizing individual payoffs in depleted situations.
'''

description_COLLECTIVE_245 = '''
I propose a collective strategy called "Adaptive Stock Conservator" (ASC) that balances individual payoffs with long-term sustainability of the common pool resource. ASC is designed to be robust against various opponent behaviors and adapt to changing game dynamics.

**Decision Rules:**

1. **Initial Round:** In the first round, ASC cooperates (C) to establish a baseline for cooperation and observe opponents' initial actions.
2. **Stock-Dependent Cooperation:** For subsequent rounds, ASC uses the current stock level (S) as a threshold to determine its action:
	* If S ≥ 0.75 \* capacity, ASC cooperates (C).
	* If S < 0.5 \* capacity, ASC defects (D).
	* If 0.5 \* capacity ≤ S < 0.75 \* capacity, ASC uses a probabilistic approach:
		+ Calculate the probability of cooperating (p_C) based on the stock level: p_C = (S - 0.5 \* capacity) / (0.25 \* capacity).
		+ Randomly select an action with probability p_C for cooperation and (1 - p_C) for defection.
3. **Opponent-Dependent Adjustment:** ASC monitors opponents' actions in the previous round and adjusts its strategy accordingly:
	* If most opponents (≥ 0.6 \* n) defected, ASC increases its probability of defecting by 10% in the next round.
	* If most opponents cooperated (≥ 0.6 \* n), ASC increases its probability of cooperating by 10% in the next round.

**Edge Cases:**

1. **Last Round:** In the final round, ASC defects (D) to maximize individual payoff, as there is no future sustainability concern.
2. **Tiebreaker:** If multiple opponents have the same highest payoff in a previous round, ASC randomly selects one of them for opponent-dependent adjustment.

**Collective Mindset:**

ASC prioritizes long-term sustainability and cooperation while adapting to changing game dynamics and opponents' behaviors. By balancing individual payoffs with collective well-being, ASC contributes to maintaining a healthy common pool resource. In a tournament setting, ASC's adaptability and robustness against various strategies make it a competitive contender.

Pseudocode for the Adaptive Stock Conservator strategy:
```python
def adaptive_stock_conservator(n, capacity, stock, history):
    # Initialize cooperation probability
    p_C = 0

    # First round: Cooperate to establish baseline
    if len(history) == 0:
        return 'C'

    # Calculate cooperation probability based on stock level
    if stock >= 0.75 * capacity:
        p_C = 1
    elif stock < 0.5 * capacity:
        p_C = 0
    else:
        p_C = (stock - 0.5 * capacity) / (0.25 * capacity)

    # Adjust cooperation probability based on opponents' actions
    opponent_actions = [action for action in history[-1] if action != 'self']
    most_common_action = max(set(opponent_actions), key=opponent_actions.count)
    if most_common_action == 'D':
        p_C -= 0.1
    elif most_common_action == 'C':
        p_C += 0.1

    # Randomly select action based on cooperation probability
    import random
    return 'C' if random.random() < p_C else 'D'

# Last round: Defect to maximize individual payoff
def last_round_strategy(n, capacity, stock):
    return 'D'
```
Note that this pseudocode provides a simplified representation of the strategy and may require modifications for implementation in an actual algorithm.
'''

description_COLLECTIVE_246 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. This approach prioritizes cooperation when possible, while also being mindful of potential defections.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for the game's progression.
2. **General Rule**: Observe the current stock level (S) and compare it to the capacity (C). If S > 0.5 \* C, cooperate (C). Otherwise, defect (D).
3. **Adaptive Threshold**: Adjust the cooperation threshold based on the previous round's outcome:
	* If the stock level increased or remained stable (> 0.9 \* previous stock), decrease the threshold by 0.05 \* C.
	* If the stock level decreased significantly (< 0.8 \* previous stock), increase the threshold by 0.05 \* C.
4. **Opponent Behavior**: Observe the actions of other players in the previous round:
	* If more than half of the opponents defected (D), defect (D) in the current round to avoid being taken advantage of.
	* If more than half of the opponents cooperated (C), cooperate (C) in the current round to build on their cooperation.

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round, as there is no future impact on the game's state.
2. **Low Stock Levels**: If the stock level falls below 0.2 \* C, cooperate (C) unconditionally to help replenish the stock.

**Collective Mindset:**

The ASC strategy prioritizes cooperation when possible, while also being mindful of potential defections. By adapting to the game's state and history, this approach aims to balance individual payoffs with collective sustainability. In a tournament setting, the ASC strategy can serve as a robust and collective foundation for achieving mutually beneficial outcomes.

**Pseudocode:**
```python
def ASC_strategy(state, history):
    # Initialize variables
    capacity = state.capacity
    current_stock = state.current_stock
    previous_stock = history[-1].current_stock if len(history) > 0 else None

    # General rule
    if current_stock > 0.5 * capacity:
        return 'C'
    else:
        return 'D'

    # Adaptive threshold adjustment
    if len(history) > 0:
        stock_diff = current_stock - previous_stock
        if stock_diff >= 0 or stock_diff < -0.1 * capacity:
            threshold -= 0.05 * capacity
        elif stock_diff < -0.2 * capacity:
            threshold += 0.05 * capacity

    # Opponent behavior observation
    opponent_actions = [action for action in history[-1].actions if action != state.player_id]
    num_defectors = sum(1 for action in opponent_actions if action == 'D')
    if num_defectors > len(opponent_actions) / 2:
        return 'D'
    elif sum(1 for action in opponent_actions if action == 'C') > len(opponent_actions) / 2:
        return 'C'

    # Last round handling
    if state.round == state.num_rounds - 1:
        return 'D'

    # Low stock level handling
    if current_stock < 0.2 * capacity:
        return 'C'
```
This pseudocode provides a foundation for implementing the ASC strategy in an algorithmic form.
'''

description_COLLECTIVE_247 = '''
**Collective Strategy: "Adaptive Stock Sustainer" (ASS)**

The Adaptive Stock Sustainer (ASS) strategy aims to balance individual payoffs with collective sustainability, adapting to various opponent behaviors and game states.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if the number of players (n) is even.
	* Defect (D) if the number of players (n) is odd.
2. **Subsequent Rounds (t>1):**
	* Calculate the average payoff per player in the previous round (π_avg).
	* If π_avg ≥ stock/(2n), Cooperate (C). Otherwise, Defect (D).
3. **Stock Thresholds:**
	* If the current stock level is below 25% of capacity, always Cooperate (C) to prevent depletion.
	* If the current stock level is above 75% of capacity, consider defecting (D) if π_avg < stock/(2n).

**Edge Cases:**

1. **Last Round (t=r):**
	* Always Defect (D), as there's no future cost for over-consumption.
2. **Single Player Remaining:**
	* Cooperate (C) to maintain some stock for the next round, ensuring a higher payoff.

**Collective Mindset Alignment:**

1. **Sustainability:** ASS prioritizes maintaining a healthy stock level to ensure long-term payoffs for all players.
2. **Adaptability:** By adjusting behavior based on average payoffs and stock levels, ASS responds effectively to various opponent strategies.

Pseudocode:
```markdown
function AdaptiveStockSustainer(n, capacity, r, current_stock, history):
  if (round == 1) {
    // Initial round decision
    if (n % 2 == 0) return C;
    else return D;
  }

  π_avg = calculate_average_payoff(history);
  stock_threshold = 0.25 * capacity;

  if (current_stock < stock_threshold) return C; // Prevent depletion

  if (π_avg >= current_stock / (2 * n)) {
    return C;
  } else {
    // Consider defecting if average payoff is low
    if (current_stock > 0.75 * capacity) return D;
    else return C;
  }

  // Last round, always defect
  if (round == r) return D;

  // Single player remaining, cooperate to maintain stock
  if (n == 1) return C;
```
This strategy balances individual payoffs with collective sustainability, adapting to various opponent behaviors and game states. By prioritizing stock maintenance and responding to average payoffs, ASS aims to achieve a high total payoff while minimizing the risk of depletion.
'''

description_COLLECTIVE_248 = '''
**Collective Strategy: Adaptive Cooperation with Stock Awareness (ACSA)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock-Based Cooperation Threshold:** Calculate a dynamic cooperation threshold based on the current stock level:
	* `cooperation_threshold = capacity / (2 * n)`
	* If the current stock is above this threshold, Cooperate (C). Otherwise, Defect (D).
3. **Opponent Adaptation:** Monitor opponents' actions and adjust behavior accordingly:
	* If a majority of opponents (> 50%) defected in the previous round, Defect (D) in the next round.
	* If most opponents cooperated (> 50%), Cooperate (C) in the next round.
4. **Stock Recovery:** Prioritize stock recovery when it's critically low:
	* If the current stock is below `capacity / 4`, Cooperate (C) to allow for growth.

**Edge Cases:**

1. **Last Round:** Defect (D) in the last round, as there's no future benefit from cooperation.
2. **Early Stock Depletion:** If the stock drops rapidly (e.g., due to multiple defections), adapt quickly by defecting in the next round to avoid further losses.

**Collective Mindset:**

1. **Cooperation Incentives:** By cooperating when possible, we create an environment where others are more likely to cooperate as well.
2. **Stock Preservation:** Prioritizing stock recovery ensures a sustainable resource for all players, benefiting both individual and collective payoffs in the long run.

**Pseudocode:**
```python
def ACSA(n, capacity, stock, history):
    # Initial round cooperation
    if len(history) == 0:
        return 'C'

    # Calculate cooperation threshold
    cooperation_threshold = capacity / (2 * n)

    # Check current stock level
    if stock > cooperation_threshold:
        action = 'C'
    else:
        action = 'D'

    # Adapt to opponent behavior
    opponents_defected = sum(1 for h in history[-n:] if h == 'D') / n
    if opponents_defected > 0.5:
        action = 'D'
    elif opponents_defected < 0.5:
        action = 'C'

    # Prioritize stock recovery
    if stock < capacity / 4:
        action = 'C'

    # Last round defection
    if len(history) == r - 1:  # last round
        action = 'D'

    return action
```
This strategy balances individual self-interest with collective well-being, adapting to the dynamic state of the game and opponents' behaviors. By cooperating when possible and defecting when necessary, ACSA aims to achieve a stable equilibrium that benefits all players in the long run.
'''

description_COLLECTIVE_249 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Trigger (ACST)**

ACST is a dynamic, adaptive strategy that balances individual payoffs with collective sustainability. It responds to both current stock levels and historical actions of other players.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock-Based Trigger:** If the current stock level is above 75% of the capacity, cooperate (C). This ensures that when resources are abundant, players prioritize sustainability over individual gains.
3. **Defection Response:** If any player defected in the previous round, defect (D) in the current round. This punishes non-cooperative behavior and encourages opponents to reconsider their actions.
4. **Stock Recovery:** If the stock level has increased since the last round, cooperate (C). This reinforces sustainable consumption patterns when resources are recovering.
5. **Default:** In all other cases, cooperate (C) with a probability of 0.75, and defect (D) with a probability of 0.25. This introduces some randomness to make the strategy less predictable.

**Pseudocode:**
```markdown
function ACST(current_stock, capacity, history):
    if current_round == 1:
        return COOPERATE

    if current_stock > 0.75 * capacity:
        return COOPERATE

    for opponent in opponents:
        if opponent.defected_last_round():
            return DEFECT

    if current_stock > last_stock:
        return COOPERATE

    # Randomized default behavior
    prob_cooperate = 0.75
    return random_choice(prob_cooperate)
```
**Rationale:**

1. By cooperating in the first round, ACST sets a positive tone and encourages opponents to cooperate as well.
2. The stock-based trigger ensures that players prioritize sustainability when resources are abundant.
3. Punishing defection by defecting in response promotes cooperation among opponents.
4. Reinforcing sustainable consumption patterns during stock recovery incentivizes collective responsibility.
5. Randomized default behavior introduces uncertainty, making ACST less predictable and more robust to various opponent behaviors.

**Collective Mindset:**

ACST aligns with the collective mindset by:

1. Prioritizing sustainability when resources are abundant
2. Encouraging cooperation through initial-round cooperation
3. Punishing non-cooperative behavior to promote mutual benefit
4. Reinforcing sustainable consumption patterns during stock recovery

By adapting to both current stock levels and historical actions, ACST promotes a balance between individual payoffs and collective sustainability, making it an effective strategy for the Common Pool Resource Game tournament.
'''

description_COLLECTIVE_250 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. This strategy promotes cooperation while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for collective behavior.
2. **Subsequent Rounds:** Observe the previous round's outcome and adjust accordingly:
	* If the stock level increased or remained stable, cooperate (C).
	* If the stock level decreased significantly (> 10% of capacity), defect (D). This indicates that others may be over-exploiting the resource.
	* If the stock level decreased slightly (< 10% of capacity), use a mixed strategy:
		+ Cooperate (C) with probability p, where p = current_stock / capacity. This means that as the stock level decreases, the likelihood of cooperating also decreases.
		+ Defect (D) with probability (1 - p).
3. **Stock Criticality:** If the current stock level falls below 20% of capacity, defect (D). This is a critical threshold to prevent complete resource depletion.

**Edge Cases:**

* **Last Round:** Cooperate (C) in the final round to maximize collective payoff and maintain a sustainable stock level for future games.
* **Tie-breaking:** In cases where multiple players have the same highest payoff, prioritize cooperation to promote collective stability.

**Collective Mindset Alignment:**

The ASC strategy is designed to promote cooperation while adapting to the game's dynamics. By initially cooperating and adjusting based on the previous round's outcome, this strategy encourages other players to do the same. The mixed strategy component allows for flexibility in responding to different opponent behaviors.

Pseudocode:
```markdown
Function AdaptiveStockConservation(n, r, capacity, current_stock):
  // Initial Round
  if (round == 1) {
    return Cooperate;
  }

  // Subsequent Rounds
  previous_round_outcome = get_previous_round_outcome();
  if (previous_round_outcome == Increased or Stable) {
    return Cooperate;
  } else if (previous_round_outcome == DecreasedSignificantly) {
    return Defect;
  } else { // Slight decrease
    p = current_stock / capacity;
    if (random() < p) {
      return Cooperate;
    } else {
      return Defect;
    }
  }

  // Stock Criticality
  if (current_stock < 0.2 * capacity) {
    return Defect;
  }

  // Last Round
  if (round == r) {
    return Cooperate;
  }

  // Tie-breaking
  if (payoff == highest_payoff) {
    return Cooperate;
  }
```
This strategy is designed to be robust and adaptive, allowing it to perform well in a tournament against various independent strategies.
'''

description_COLLECTIVE_251 = '''
I propose a collective strategy called "Adaptive Stock Conservation" (ASC). ASC aims to balance individual payoffs with long-term stock sustainability, adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if the initial stock is above 75% of capacity.
	* Defect (D) otherwise.
2. **Subsequent Rounds (t>1):**
	* Calculate the average consumption rate of all players in the previous round: `avg_consumption = total_consumption / n`.
	* If the current stock is below 50% of capacity or the average consumption rate exceeds 25% of the capacity, Defect (D).
	* Otherwise, Cooperate (C) with a probability `p` calculated as follows:
		+ `p = 1 - (avg_consumption / (0.5 * capacity))` if `avg_consumption` is below 12.5% of capacity.
		+ `p = 0.5` if `avg_consumption` is between 12.5% and 25% of capacity.
		+ `p = (capacity - stock) / capacity` if `avg_consumption` exceeds 25% of capacity.

**Edge Cases:**

1. **Last Round (t=r):**
	* Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Stock Depletion:**
	* If the stock falls below 10% of capacity, Cooperate (C) to help replenish the stock.

**Collective Mindset:**

ASC prioritizes cooperation when the stock is healthy and adapts to more individualistic behavior as the stock dwindles or opponents' consumption rates increase. By balancing short-term gains with long-term sustainability, ASC aims to create a collective outcome that benefits all players.

Pseudocode:
```python
def adaptive_stock_conservation(n, capacity, r, stock_history):
    if t == 1:  # Initial round
        if stock_history[0] > 0.75 * capacity:
            return C
        else:
            return D

    avg_consumption = total_consumption / n
    if stock_history[t-1] < 0.5 * capacity or avg_consumption > 0.25 * capacity:
        return D

    p = calculate_probability(avg_consumption, capacity)
    return C with probability p, D otherwise

def calculate_probability(avg_consumption, capacity):
    if avg_consumption < 0.125 * capacity:
        return 1 - (avg_consumption / (0.5 * capacity))
    elif avg_consumption < 0.25 * capacity:
        return 0.5
    else:
        return (capacity - stock) / capacity

def get_total_consumption(n, actions):
    total = 0
    for action in actions:
        if action == C:
            total += stock / (2 * n)
        elif action == D:
            total += stock / n
    return total
```
Note that this strategy can be refined and improved through further analysis and testing.
'''

description_COLLECTIVE_252 = '''
Here is a collective strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) with probability 0.5, Defect (D) with probability 0.5.
2. **Subsequent Rounds**: Observe the previous round's stock level and actions of all players. If:
	* Stock level is above 75% of capacity: Cooperate (C).
	* Stock level is between 25% and 75% of capacity: Cooperate (C) with probability 0.7, Defect (D) with probability 0.3.
	* Stock level is below 25% of capacity: Defect (D).
3. **Defection Response**: If a player observes that more than half of the players defected in the previous round, they will defect (D) in the current round.

**Edge Case Handling:**

1. **Last Round**: Cooperate (C) if stock level is above 50% of capacity, Defect (D) otherwise.
2. **Stock Depletion**: If stock level falls below 10% of capacity, all players will defect (D).

**Collective Mindset Alignment:**

The ACC strategy prioritizes cooperation when the stock level is high, gradually shifts towards defection as the stock level decreases, and responds to opponents' defections by adapting its own behavior. This approach balances individual self-interest with collective conservation goals.

**Pseudocode:**
```
function ACC(stock_level, previous_actions):
  if first_round:
    return random_choice([C, D], [0.5, 0.5])
  
  if stock_level > 0.75 * capacity:
    return C
  elif stock_level >= 0.25 * capacity and stock_level <= 0.75 * capacity:
    return random_choice([C, D], [0.7, 0.3])
  else:
    return D
  
  # Defection Response
  if count_defections(previous_actions) > n / 2:
    return D
  
  # Last Round Handling
  if current_round == r:
    if stock_level > 0.5 * capacity:
      return C
    else:
      return D
  
  # Stock Depletion Handling
  if stock_level < 0.1 * capacity:
    return D
```
This strategy is designed to be adaptive, robust, and collective-minded, making it suitable for a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_253 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Overview**

ASC is a collective strategy that balances individual payoff maximization with long-term stock conservation. It adapts to changing game conditions and opponent behaviors while promoting cooperation when beneficial.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to encourage mutual cooperation and gauge opponents' behavior.
2. **Stock Threshold**: Define a dynamic stock threshold, `stock_threshold = capacity / 2`. If the current stock level is below this threshold, defect (D) to maximize individual payoff. Otherwise, cooperate (C).
3. **Opponent Behavior Analysis**: Track the number of cooperators (`cooperators`) and defectors (`defectors`) in the previous round. Calculate the `cooperation_ratio = cooperators / n`.
4. **Cooperation Incentive**: If `cooperation_ratio` is above 0.5, cooperate (C) to reinforce mutual cooperation. Otherwise, defect (D).
5. **Stock Growth Expectation**: Estimate the expected stock growth (`expected_growth`) based on the current stock level and opponents' behavior. If `expected_growth` is positive, cooperate (C). Otherwise, defect (D).

Pseudocode:
```
if round == 1:
    action = C
else:
    if stock < stock_threshold:
        action = D
    else:
        cooperation_ratio = cooperators / n
        if cooperation_ratio > 0.5:
            action = C
        elif expected_growth > 0:
            action = C
        else:
            action = D
```
**Handling Edge Cases**

1. **Last Round**: Defect (D) in the last round to maximize individual payoff, as there is no future stock growth.
2. **Ties**: In case of a tie in cooperation ratio or expected growth, cooperate (C) to promote mutual cooperation.

**Collective Mindset Alignment**

ASC aligns with the collective mindset by:

1. Promoting cooperation when beneficial for long-term stock conservation.
2. Adapting to changing game conditions and opponent behaviors.
3. Encouraging mutual cooperation through initial cooperation and reinforcement.
4. Balancing individual payoff maximization with collective stock conservation.

**Robustness**

ASC is robust against a wide range of opponent behaviors, including:

1. **All Defectors**: ASC defects in response to all opponents defecting.
2. **All Cooperators**: ASC cooperates when all opponents cooperate.
3. **Mixed Strategies**: ASC adapts to varying cooperation ratios and expected growth.

By implementing ASC, we aim to create a collective strategy that not only maximizes individual payoffs but also promotes long-term stock conservation and cooperation among players.
'''

description_COLLECTIVE_254 = '''
Here's a collective strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Cooperation with Stock Conservation (ACSC)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline of cooperation and observe other players' behaviors.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 50% of capacity, cooperate (C) with probability p_C = 0.7 + (stock/capacity)/10. This encourages cooperation when the resource is abundant and allows for some exploration of defection.
	* If the current stock level is below 50% of capacity, defect (D) with probability p_D = 1 - (stock/capacity)/5. This prioritizes self-interest when the resource is scarce, while still allowing for some cooperation to maintain a stable stock level.
3. **Last Round (t=r):** Defect (D) to maximize individual payoff, as there are no future rounds to consider.

**Edge Cases:**

1. **Low Stock Levels:** If the current stock level falls below 10% of capacity, cooperate (C) unconditionally to prevent resource depletion and ensure some growth.
2. **High Stock Levels:** If the current stock level exceeds 90% of capacity, defect (D) with probability p_D = 0.3 + (stock/capacity)/20. This encourages moderate consumption when the resource is abundant.

**Collective Mindset:**

ACSC prioritizes cooperation to maintain a stable and growing common pool resource, while adapting to changing stock levels and opponent behaviors. By cooperating more frequently when the resource is abundant, ACSC promotes collective welfare and fosters an environment conducive to long-term sustainability.

**Pseudocode (for illustration purposes only):**
```markdown
def ACSC(stock, capacity, t, r):
  if t == 1:  # Initial Round
    return C
  elif stock/capacity > 0.5:
    p_C = 0.7 + (stock/capacity)/10
    return random_choice([C, D], [p_C, 1-p_C])
  else:
    p_D = 1 - (stock/capacity)/5
    return random_choice([D, C], [p_D, 1-p_D])

def last_round(stock, capacity, t, r):
  if t == r:
    return D

def low_stock(stock, capacity):
  if stock/capacity < 0.1:
    return C

def high_stock(stock, capacity):
  if stock/capacity > 0.9:
    p_D = 0.3 + (stock/capacity)/20
    return random_choice([D, C], [p_D, 1-p_D])

# Main Logic
action = ACSC(stock, capacity, t, r)
if low_stock(stock, capacity):
  action = C
elif high_stock(stock, capacity):
  action = high_stock(stock, capacity)
elif last_round(stock, capacity, t, r):
  action = D

return action
```
Note that this pseudocode is for illustration purposes only and may require modifications to be implemented as an algorithm.
'''

description_COLLECTIVE_255 = '''
**Collective Strategy: "Adaptive Harvesting with Stock-Sensitive Cooperation" (AHSSC)**

**Decision Rules:**

1. **Initial Rounds:** In the first round, cooperate (play C) to establish a baseline for cooperation and observe opponents' behaviors.
2. **Stock-Dependent Cooperation Threshold:** Calculate a cooperation threshold based on the current stock level. Let `stock_threshold` be the minimum stock level required for cooperation, defined as:

`stock_threshold = capacity / (2n)`

If the current stock level is above this threshold, cooperate (play C). Otherwise, defect (play D).
3. **Opponent Behavior Adaptation:** Monitor opponents' actions and adjust the cooperation threshold accordingly.

* If a majority of opponents (> n/2) cooperated in the previous round, decrease the cooperation threshold by 10% to encourage further cooperation:

`stock_threshold *= 0.9`
* If a majority of opponents (> n/2) defected in the previous round, increase the cooperation threshold by 10% to deter over-harvesting:

`stock_threshold *= 1.1`

**Edge Cases:**

1. **Last Round:** In the final round, always defect (play D) to maximize individual payoff, as there are no future rounds to consider.
2. **Low Stock Levels:** If the current stock level is critically low (< `capacity / (4n)`), cooperate (play C) to ensure some stock growth and prevent depletion.

**Collective Mindset Alignment:**

AHSSC prioritizes cooperation when the stock level is sufficient, promoting a collective mindset that balances individual payoffs with long-term sustainability. By adapting to opponents' behaviors, AHSSC encourages cooperation while protecting against exploitation.

**Pseudocode (simplified):**
```python
def AHSSC(n, capacity, current_stock, previous_actions):
    # Initial rounds: cooperate
    if round_number == 1:
        return "C"
    
    # Calculate cooperation threshold
    stock_threshold = capacity / (2 * n)
    
    # Adapt to opponent behavior
    if majority_cooperated(previous_actions):
        stock_threshold *= 0.9
    elif majority_defected(previous_actions):
        stock_threshold *= 1.1
    
    # Make decision based on stock level and threshold
    if current_stock > stock_threshold:
        return "C"
    else:
        return "D"

def majority_cooperated(previous_actions):
    # Count opponents' actions in previous round
    cooperators = sum(1 for action in previous_actions if action == "C")
    return cooperators > n / 2

def majority_defected(previous_actions):
    # Count opponents' actions in previous round
    defectors = sum(1 for action in previous_actions if action == "D")
    return defectors > n / 2
```
This strategy will be implemented as an algorithm and tested against other AI systems in the tournament.
'''

description_COLLECTIVE_256 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock Sensitivity (ATTS)**

ATTS is a dynamic, adaptive strategy that balances individual interests with collective sustainability in the Common Pool Resource Game.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a cooperative tone and maximize initial payoffs.
2. **Subsequent Rounds**:
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play Tit-for-Tat (TFT): cooperate if most players cooperated in the previous round; otherwise, defect (D).
	* If the current stock level is below 50% of capacity, defect (D) to maximize individual payoffs while minimizing further stock depletion.
3. **Stock Thresholds**:
	+ If the stock level drops below 25% of capacity, defect (D) for all subsequent rounds to prevent complete stock depletion.
	+ If the stock level exceeds 90% of capacity, cooperate (C) for all subsequent rounds to maintain a sustainable stock level.

**Edge Cases:**

1. **Last Round**: Defect (D) to maximize individual payoffs, as there are no future rounds to consider.
2. **Tied Stock Levels**: In cases where multiple players have the same highest payoff in a round, cooperate (C) in the next round to promote collective sustainability.

**Collective Mindset:**

ATTS prioritizes cooperation when the stock level is high, ensuring long-term sustainability and maximizing collective payoffs. As the stock level decreases, ATTS adapts by introducing defecting behavior to prevent complete depletion. By incorporating Tit-for-Tat elements, ATTS promotes reciprocity and encourages other players to cooperate.

**Pseudocode:**
```python
def ATTS(stock_level, capacity, num_players, round_num):
    if round_num == 1:
        return "C"  # Cooperate in the first round
    
    if stock_level >= 0.75 * capacity:
        return "C"  # Cooperate when stock is high
    
    elif stock_level >= 0.5 * capacity and stock_level < 0.75 * capacity:
        prev_round_coops = count_cooperations(prev_round)
        if prev_round_coops > num_players / 2:
            return "C"  # TFT: cooperate if most players cooperated
        else:
            return "D"
    
    elif stock_level < 0.5 * capacity and stock_level >= 0.25 * capacity:
        return "D"  # Defect when stock is low
    
    elif stock_level < 0.25 * capacity:
        return "D"  # Defect to prevent complete depletion
    
    elif stock_level > 0.9 * capacity:
        return "C"  # Cooperate to maintain a sustainable stock level
    
    else:  # Last round or tied stock levels
        if round_num == num_rounds:
            return "D"
        else:
            return "C"
```
This strategy balances individual self-interest with collective sustainability, making it robust against various opponent behaviors.
'''

description_COLLECTIVE_257 = '''
To design a collective strategy for this Common Pool Resource Game, I propose a adaptive and robust approach that balances individual payoff maximization with collective sustainability. Here's the " Collective Stock Conservation" (CSC) strategy:

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to avoid initial over-consumption and establish a cooperative tone.
2. **Stock-dependent cooperation threshold:** Introduce a dynamic cooperation threshold based on the current stock level (S). If S is above a certain percentage of the capacity (e.g., 70%), cooperate; otherwise, defect. This threshold will be adjusted as the game progresses.
3. **Adaptive adjustment:** After each round, reassess the cooperation threshold based on the previous round's outcomes:
	* If all players cooperated and the stock increased or remained stable, maintain the current threshold.
	* If some players defected and the stock decreased significantly (e.g., below 50%), decrease the cooperation threshold to encourage more cooperative behavior.
	* If most players defected and the stock depleted rapidly (e.g., below 20%), increase the cooperation threshold to prevent over-consumption.

**Handling Edge Cases:**

1. **Last Round:** Defect in the last round, as there is no future cost to over-consumption.
2. **Stock depletion:** If the stock falls below a critical level (e.g., 10% of capacity), defect to maximize individual payoff before the game ends.

**Collective Mindset:**

The CSC strategy prioritizes collective sustainability while allowing for adaptive adjustments based on individual payoffs and the current state of the game. By initially cooperating and adjusting the cooperation threshold dynamically, players can work together to maintain a healthy stock level while minimizing the risk of over-consumption.

Pseudocode:
```
Initialize:
  cooperate_threshold = 0.7 (70% of capacity)
  prev_stock_level = capacity

For each round t from 1 to r:
  if t == 1:  # Initial Round
    action = C
  else:
    current_stock_level = get_current_stock()
    
    if current_stock_level >= cooperate_threshold * capacity:
      action = C
    else:
      action = D
    
    # Adaptive adjustment
    if all_players_cooperated and (prev_stock_level <= current_stock_level or prev_stock_level == current_stock_level):
      maintain cooperation_threshold
    elif some_players_defected and current_stock_level < 0.5 * capacity:
      decrease cooperation_threshold by 10%
    elif most_players_defected and current_stock_level < 0.2 * capacity:
      increase cooperation_threshold by 20%
    
    prev_stock_level = current_stock_level

Last Round (t == r):
  action = D
```
This strategy balances individual self-interest with collective responsibility, making it a robust and adaptive approach for the Common Pool Resource Game.
'''

description_COLLECTIVE_258 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock-Dependent Threshold (ATTT-SdT)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to encourage cooperation and maximize initial payoff.
2. **Subsequent Rounds**: Observe the previous round's actions and payoffs of all players.
3. **Cooperation Threshold**: Calculate a stock-dependent threshold, `T`, as a function of the current stock level, `S`: `T = (S / capacity) * n`. This threshold represents the number of cooperators required to maintain a healthy stock level.
4. **Tit-for-Tat**: If the number of cooperators in the previous round is greater than or equal to the threshold (`T`), cooperate (C). Otherwise, defect (D).
5. **Stock-Dependent Adjustment**: If the current stock level is below `capacity / 2`, adjust the cooperation threshold by increasing it by 1 player. This ensures that players are more cautious when the stock is depleted.

**Pseudocode:**
```markdown
def ATTT_SdT(n, capacity, S, history):
    if round == 1:
        return C  # Cooperate in the first round

    prev_coops = count_cooperators(history[-1])
    T = (S / capacity) * n

    if prev_coops >= T:
        action = C
    else:
        action = D

    if S < capacity / 2:
        T += 1

    return action
```
**Edge Cases:**

* **Last Round**: Cooperate (C) in the last round to maximize the final payoff, as there is no future stock growth.
* **Stock Depletion**: If the current stock level is very low (`S < capacity / 4`), always cooperate (C) to help replenish the stock.

**Collective Mindset:**

ATTT-SdT encourages cooperation by:

1. Cooperating in the first round to set a positive tone.
2. Responding to cooperation with cooperation, using the tit-for-tat mechanism.
3. Adjusting the cooperation threshold based on the current stock level, promoting caution when the stock is depleted.

This strategy balances individual payoff maximization with collective sustainability, making it robust to various opponent behaviors and adaptable to changing game conditions.
'''

description_COLLECTIVE_259 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock Awareness**

Our collective strategy is designed to balance individual payoffs with collective sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Rounds**: In the first round, cooperate (play C) to establish a baseline for stock growth and encourage cooperation.
2. **Tit-for-Tat**: Observe the previous round's actions and outcomes. If the majority of players (> 50%) cooperated, cooperate in the current round. Otherwise, defect (play D).
3. **Stock Awareness**: Monitor the current stock level. If it falls below a critical threshold (stock < capacity/2), switch to cooperation (C) for two consecutive rounds to help replenish the stock.
4. **Adaptive Response**: If the average payoff per player in the last three rounds is below 75% of the maximum possible payoff, increase the likelihood of defecting by 20% in the next round.

**Pseudocode:**

```
function adaptive_tit_for_tat(stock, capacity, num_players, history):
    if current_round == 1:
        return C  # Cooperate in the first round
    
    majority_cooperated = sum(history[-1]) / num_players > 0.5
    if majority_cooperated:
        return C  # Cooperate if majority cooperated previously
    
    stock_threshold_reached = stock < capacity/2
    if stock_threshold_reached:
        return C  # Cooperate to replenish stock
    
    avg_payoff_last_3_rounds = sum(history[-3:]) / (3 * num_players)
    max_possible_payoff = capacity / (2 * num_players)
    if avg_payoff_last_3_rounds < 0.75 * max_possible_payoff:
        defect_probability += 0.2
    
    return D with probability defect_probability, otherwise C
```

**Handling Edge Cases:**

* **Last Round**: In the final round, play a best-response strategy based on the observed history and current stock level.
* **Early Game**: If multiple players cooperate in the early rounds, maintain cooperation to foster trust and encourage collective sustainability.

This adaptive tit-for-tat strategy balances individual payoffs with collective sustainability by:

1. Encouraging cooperation when possible
2. Responding to opponents' actions
3. Adapting to changing stock levels and payoff structures
4. Avoiding exploitation through a mix of cooperation and defection

By following this collective mindset, our strategy aims to achieve a robust performance in the tournament against independent AI systems with diverse strategies.
'''

description_COLLECTIVE_260 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACS)**

The ACS strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and historical player behavior.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to encourage initial cooperation and gather information about opponents' behaviors.
2. **Stock-Based Threshold:** Define a dynamic threshold `T` as a function of the current stock level `S`: `T = S / (2n * (1 + r/10))`. This threshold decreases as the game progresses (`r` increases) to account for potential stock depletion.
3. **Cooperation vs Defection:**
	* If `S > T`, Cooperate (C). This ensures that when the stock is relatively high, players contribute to its sustainability.
	* If `S ≤ T`, Defect (D) with a probability `p = 1 - (S / capacity)`. This allows for some defection when the stock is low, while still encouraging cooperation when the stock is closer to capacity.
4. **Opponent Behavior Analysis:** After each round, analyze the opponent's actions and adjust the threshold `T` based on their behavior:
	* If an opponent defects frequently (> 50% of rounds), increase `T` by 10% to reduce cooperation in response to their non-cooperative behavior.
	* If an opponent cooperates frequently (> 50% of rounds), decrease `T` by 10% to encourage further cooperation.

**Edge Cases:**

1. **Last Round:** Defect (D) in the last round (`r = R`) to maximize individual payoff, as there is no future stock to sustain.
2. **Low Stock:** If `S < 2n`, Cooperate (C) to help replenish the stock and avoid depletion.

**Collective Mindset:**

The ACS strategy aligns with a collective mindset by:

1. Encouraging initial cooperation to establish a cooperative atmosphere.
2. Adapting cooperation levels based on the current stock level, ensuring that players contribute to its sustainability.
3. Responding to opponent behavior, promoting reciprocity and discouraging non-cooperation.

**Pseudocode:**
```python
def ACS(n, r, capacity, S):
    T = S / (2n * (1 + r/10))
    
    if r == 1:
        return C
    
    elif S > T:
        return C
    
    else:
        p = 1 - (S / capacity)
        if random.random() < p:
            return D
        else:
            return C

def update_threshold(opponent_behavior):
    if opponent_defects_frequently():
        T += 0.1 * T
    elif opponent_cooperates_frequently():
        T -= 0.1 * T
```
This strategy should perform well in a tournament setting, as it balances individual payoffs with collective sustainability and adapts to various opponent behaviors.
'''

description_COLLECTIVE_261 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for stock consumption and growth.
2. **Subsequent Rounds**: Evaluate the current stock level (`S`) and the average payoff per player (`avg_π`) from the previous round.
	* If `S` is above 75% of capacity, Cooperate (C).
	* If `S` is between 50% and 75% of capacity, Defect (D) with a probability proportional to the number of players who defected in the previous round (`defection_rate`). Otherwise, Cooperate (C).
	* If `S` is below 50% of capacity, Defect (D).
3. **Last Round**: Cooperate (C) to maximize collective payoff and ensure a sustainable stock level for future games.

**Pseudocode:**
```python
def ASC(n, r, capacity, S, history):
    if round == 1:
        return 'C'  # Initial round cooperation

    avg_π = calculate_average_payoff(history)
    defection_rate = calculate_defection_rate(history)

    if S >= 0.75 * capacity:
        return 'C'  # High stock level: cooperate
    elif 0.5 * capacity <= S < 0.75 * capacity:
        if random.random() < defection_rate:
            return 'D'  # Medium stock level: defect with probability
        else:
            return 'C'
    else:
        return 'D'  # Low stock level: defect

    if round == r:
        return 'C'  # Last round cooperation
```
**Edge Cases:**

* If the game state is not available (e.g., due to a lack of observations), ASC defaults to Cooperate (C).
* If the number of players (`n`) or rounds (`r`) changes during the game, ASC adapts by recalculating the decision thresholds.

**Collective Mindset:**

ASC prioritizes cooperation when the stock level is high or when the collective payoff is satisfactory. As the stock level decreases, ASC becomes more cautious and defect-prone to prevent over-exploitation. By adapting to the game's state and history, ASC promotes a balanced approach that considers both individual payoffs and collective sustainability.

In a tournament setting, ASC will interact with various independent strategies developed by other AI systems. While it cannot rely on specific coordination mechanisms or norms, ASC's adaptive nature allows it to respond effectively to different opponent behaviors, promoting a robust and sustainable gameplay experience.
'''

description_COLLECTIVE_262 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Stock-Based Cooperation**: If the current stock level is above 75% of the capacity, cooperate (C). This ensures that when the stock is relatively high, players conserve it for future rounds.
3. **Defection Response**: If at least one player defected (D) in the previous round and the current stock level is below 50% of the capacity, defect (D) in this round. This responds to opponents' exploitation by reducing their potential gains.
4. **Punishment Mechanism**: If a player's average payoff over the last three rounds is significantly higher (by more than 20%) than the group's average payoff, defect (D) in this round. This discourages individual exploitation and promotes fairness.
5. **Learning and Adaptation**: After each round, calculate the opponent's cooperation rate (OCR) as the proportion of cooperative actions taken by all opponents. If OCR > 0.6, increase the cooperation threshold in rule 2 by 10%. If OCR < 0.4, decrease the cooperation threshold by 10%.

Pseudocode:
```python
def ACC(n, capacity, stock, history):
    # Initial round
    if len(history) == 0:
        return 'C'

    # Stock-based cooperation
    if stock > 0.75 * capacity:
        return 'C'

    # Defection response
    previous_round_defections = sum(1 for action in history[-1] if action == 'D')
    if previous_round_defections > 0 and stock < 0.5 * capacity:
        return 'D'

    # Punishment mechanism
    average_payoff = calculate_average_payoff(history)
    group_average_payoff = calculate_group_average_payoff(history)
    if average_payoff > 1.2 * group_average_payoff:
        return 'D'

    # Learning and adaptation
    opponent_cooperation_rate = calculate_opponent_cooperation_rate(history)
    if opponent_cooperation_rate > 0.6:
        cooperation_threshold += 0.1
    elif opponent_cooperation_rate < 0.4:
        cooperation_threshold -= 0.1

    return 'C' if stock > cooperation_threshold * capacity else 'D'
```
**Edge Cases:**

* Last round: Cooperate (C) to ensure a fair distribution of the remaining resources.
* Low stock levels: If the current stock level is below 25% of the capacity, defect (D) to prevent further depletion.

**Collective Mindset:**
The ACC strategy prioritizes cooperation and conservation when possible while adapting to opponents' behaviors. By responding to exploitation and promoting fairness, it encourages collective cooperation and maintains a sustainable common pool resource.
'''

description_COLLECTIVE_263 = '''
I propose a collective strategy called "Adaptive Stock Conservation" (ASC). ASC aims to balance individual payoffs with long-term stock sustainability, adapting to the actions of other players and the game's state.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock Level-Based Cooperation:** If the current stock level is above 75% of the capacity, cooperate (C). This helps maintain a healthy stock level and incentivizes others to conserve.
3. **Defection Response:** If at least one player defected in the previous round, defect (D) in the current round. This punishes defectors and encourages cooperation.
4. **Payoff-Based Adaptation:** Calculate the average payoff per player over the last 2-3 rounds. If this value is below 50% of the maximum possible payoff (i.e., stock/(2n)), cooperate (C). Otherwise, defect (D). This adjusts the strategy based on recent payoffs and encourages cooperation when necessary.
5. **Endgame Cooperation:** In the last round (r), cooperate (C) if the current stock level is above 25% of the capacity. This ensures a minimum payoff for all players in the final round.

**Pseudocode:**
```python
def ASC(stock, capacity, n, r, history):
    if r == 1:  # Initial Round
        return 'C'
    
    if stock > 0.75 * capacity:
        return 'C'  # Stock Level-Based Cooperation
    
    defectors = [p for p in history[-1] if p['action'] == 'D']
    if defectors:
        return 'D'  # Defection Response
    
    avg_payoff = sum([p['payoff'] for p in history[-3:-1]]) / (2 * n)
    if avg_payoff < 0.5 * stock / (2 * n):
        return 'C'  # Payoff-Based Adaptation
    else:
        return 'D'
    
    if r == last_round and stock > 0.25 * capacity:
        return 'C'  # Endgame Cooperation
    
    return 'D'  # Default to defection
```
**Rationale:**

1. The initial cooperation sets a cooperative tone, while the stock level-based cooperation ensures that players conserve when the stock is healthy.
2. Responding to defections punishes non-cooperative behavior and encourages others to cooperate.
3. Payoff-based adaptation adjusts the strategy based on recent payoffs, promoting cooperation when necessary.
4. Endgame cooperation guarantees a minimum payoff for all players in the final round.

**Collective Mindset:**
ASC prioritizes collective well-being by:

1. Encouraging cooperation when the stock is healthy or in the initial rounds.
2. Punishing defections to maintain a balance between individual payoffs and long-term sustainability.
3. Adapting to recent payoffs to ensure fair distribution of resources.

By incorporating these decision rules, ASC strikes a balance between individual interests and collective sustainability, making it an effective strategy for this Common Pool Resource Game.
'''

description_COLLECTIVE_264 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Overview**

The Adaptive Stock Conservation (ASC) strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. ASC promotes cooperation while being robust to a wide range of opponent behaviors.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a positive tone and encourage cooperation from others.
2. **State-Dependent Cooperation**: In subsequent rounds, cooperate if the current stock level is above a certain threshold (`stock_threshold`), which is calculated as 75% of the capacity. This ensures that the stock remains healthy while allowing for some exploitation.
3. **History-Based Adaptation**: Monitor the average payoff difference between cooperation and defection over the last `history_window` rounds (e.g., `history_window = 3`). If the average payoff difference is negative, indicating that defectors are exploiting cooperators, adjust the `stock_threshold` downward by a small margin (`adaptation_margin`, e.g., 5%). Conversely, if the average payoff difference is positive, increase the `stock_threshold` upward by the same margin.
4. **Defection Detection**: If more than half of the players defected in the previous round, defect (D) in the current round to avoid exploitation.

**Pseudocode**
```python
def ASC(n, capacity, r):
    stock_threshold = 0.75 * capacity
    history_window = 3
    adaptation_margin = 0.05

    for t in range(r):
        if t == 0:  # Initial round
            action = 'C'
        else:
            previous_stock = get_previous_stock()
            average_payoff_diff = calculate_average_payoff_difference(history_window)

            if previous_stock > stock_threshold and average_payoff_diff >= 0:
                action = 'C'
            elif average_payoff_diff < 0:
                stock_threshold -= adaptation_margin
                action = 'D'
            elif more_than_half_defected(previous_round):
                action = 'D'

        # Update history and state
        update_history(action)
        update_state()
```
**Edge Cases**

1. **Last Round**: Cooperate (C) in the last round to maintain a positive reputation and avoid unnecessary conflict.
2. **Low Stock Levels**: If the stock level falls below 25% of the capacity, defect (D) to maximize individual payoffs.

**Collective Mindset**

The ASC strategy prioritizes collective sustainability while allowing for some exploitation. By adapting to the game's state and history, ASC promotes cooperation and discourages defection. This approach is robust to various opponent behaviors and can be effective in a tournament setting where strategies are developed independently.
'''

description_COLLECTIVE_265 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC is a dynamic, collective strategy that balances individual payoffs with long-term sustainability of the common pool resource. The goal is to maintain a healthy stock level while adapting to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if `stock >= capacity * 0.75`, otherwise Defect (D)
2. **Subsequent Rounds (t > 1):**
	* Calculate the average stock level over the last `min(5, t-1)` rounds (`avg_stock`)
	* If `avg_stock < capacity * 0.5` or `stock < capacity * 0.25`, Defect (D)
	* Otherwise, Cooperate (C) with probability `p_c = max(0.4, min(0.8, avg_stock / capacity))`
	* With probability `1 - p_c`, Defect (D)

Pseudocode:
```python
def ASC(stock, capacity, t, history):
    if t == 1:
        return 'C' if stock >= capacity * 0.75 else 'D'
    else:
        avg_stock = calculate_avg_stock(history, min(5, t-1))
        if avg_stock < capacity * 0.5 or stock < capacity * 0.25:
            return 'D'
        else:
            p_c = max(0.4, min(0.8, avg_stock / capacity))
            return 'C' with probability p_c, 'D' otherwise
```
**Edge Cases:**

* **Last Round (t=r):** Cooperate (C) if `stock >= capacity * 0.5`, otherwise Defect (D)
* **Low Stock:** If `stock < capacity * 0.25` at any point, Defect (D) to ensure some payoff
* **High Stock:** If `stock > capacity * 0.9`, Cooperate (C) to avoid over-consumption

**Collective Mindset:**

ASC aims to balance individual short-term gains with collective long-term sustainability. By adapting to the average stock level and adjusting cooperation probability accordingly, ASC promotes a shared understanding of the game's dynamics and encourages opponents to cooperate as well.

In a tournament setting, ASC will perform well against various opponent strategies by:

1. Initially cooperating when the stock is high, encouraging opponents to do the same
2. Adapting to changes in the average stock level, responding to opponents' actions
3. Defecting when necessary to maintain individual payoffs, while avoiding over-consumption

By embracing a collective mindset and adjusting behavior based on the game's state and history, ASC will promote cooperation and sustainability in the Common Pool Resource Game.
'''

description_COLLECTIVE_266 = '''
**Collective Strategy: Adaptive Cooperative Balance (ACB)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 25% and 75% of the capacity, defect (D) with a probability proportional to the number of previous rounds where the majority of players defected. This introduces a gradual adaptation to opponents' behaviors.
	* If the current stock level is below 25% of the capacity, cooperate (C) to avoid depletion and encourage recovery.
3. **Majority Defection Detection:** Track the number of rounds where the majority of players (> n/2) defected. Use this count to adjust the probability of defecting in subsequent rounds.

**Pseudocode:**
```
Function ACB(current_stock, capacity, num_players, round_number, history):
  If round_number == 1:
    Return C (Cooperate)
  
  majority_defection_count = 0
  For each previous_round in history:
    If number of defectors > num_players / 2:
      majority_defection_count += 1
  
  defect_probability = majority_defection_count / round_number
  
  If current_stock >= 0.75 * capacity:
    Return C (Cooperate)
  
  If current_stock >= 0.25 * capacity and current_stock < 0.75 * capacity:
    Randomly choose D (Defect) with probability defect_probability
    Else return C (Cooperate)
  
  If current_stock < 0.25 * capacity:
    Return C (Cooperate)
```
**Collective Mindset:**

ACB prioritizes cooperation when the stock level is sufficient, while adapting to opponents' behaviors by introducing a probabilistic defection mechanism. By doing so, it balances individual payoffs with collective sustainability.

**Robustness and Adaptability:**

1. **Early Cooperation:** Encourages initial cooperation to establish a baseline for others.
2. **Gradual Adaptation:** Adjusts behavior in response to opponents' actions, allowing the strategy to adapt to various environments.
3. **Conservative Defection:** Limits defection to situations where the stock level is moderate or low, minimizing the risk of depletion.

**Edge Cases:**

1. **First Round:** Cooperate to establish a baseline for cooperation.
2. **Last Round:** Follow the standard decision rules, as there's no specific need to adjust behavior in the final round.

By employing ACB, you'll participate in a tournament with a robust and adaptive collective strategy that balances individual interests with the sustainability of the common pool resource.
'''

description_COLLECTIVE_267 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

**Overview**
ACST is a collective strategy that balances individual self-interest with long-term sustainability of the common pool resource. It adapts to changing stock levels and opponent behaviors, ensuring robustness in a wide range of scenarios.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Stock-Based Threshold**: Define a threshold stock level, `S_threshold = capacity / 2`. If the current stock level (`stock`) is above this threshold, cooperate (C). Otherwise, defect (D).
3. **Adaptive Response**: Observe the actions of all players in previous rounds and calculate the average cooperation rate (`avg_coop_rate`). If `avg_coop_rate` is above a certain threshold (e.g., 0.5), cooperate (C) in the next round. Otherwise, defect (D).
4. **Punishment Mechanism**: If the stock level falls below a critical threshold (`S_critical = capacity / 4`) due to excessive defection, punish defectors by cooperating only if they switch to cooperation in the next round.
5. **Final Round**: Cooperate (C) in the last round to ensure maximum payoff, as there is no future benefit to defecting.

**Pseudocode**
```python
def ACST(n, capacity, stock, history):
    # Initial Round
    if len(history) == 0:
        return C
    
    # Stock-Based Threshold
    S_threshold = capacity / 2
    if stock > S_threshold:
        return C
    
    # Adaptive Response
    avg_coop_rate = calculate_avg_coop_rate(history)
    if avg_coop_rate > 0.5:
        return C
    
    # Punishment Mechanism
    S_critical = capacity / 4
    if stock < S_critical and history[-1] == D:
        punish_defector = True
        if history[-2:] == [D, C]:
            return C
        else:
            return D
    
    # Default Behavior
    return D

def calculate_avg_coop_rate(history):
    coop_count = sum(1 for action in history if action == C)
    return coop_count / len(history)
```
**Collective Mindset**
ACST aligns with the collective mindset by:

* Encouraging cooperation when the stock level is high, promoting sustainability and shared benefits.
* Adapting to opponent behaviors, allowing for flexibility and responsiveness to changing circumstances.
* Implementing a punishment mechanism to deter excessive defection and maintain cooperation.

By following these decision rules, ACST aims to achieve a balance between individual self-interest and collective well-being, ensuring a robust and adaptive strategy in the face of diverse opponent behaviors.
'''

description_COLLECTIVE_268 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Trigger (ACST)**

The ACST strategy is designed to balance individual self-interest with collective sustainability of the common pool resource. It adapts to the game's state and history, using a trigger-based approach to switch between cooperation and defection.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for the stock level and encourage others to cooperate.
2. **Stock-Based Trigger**: Monitor the current stock level (S) and calculate the "stock threshold" (T) as:

T = capacity × (n / (2n + 1))

If S ≥ T, cooperate (C). Otherwise, defect (D).
3. **History-Dependent Adjustment**: Track the average payoff (AP) received in previous rounds. If AP < stock/(2n), adjust the trigger threshold by increasing it by a small margin (e.g., 5%) to encourage cooperation.
4. **Opponent Behavior Response**: Observe the number of opponents that defected (D) in the previous round. If more than half of the opponents defected, increase the trigger threshold to discourage exploitation.

**Edge Case Handling:**

1. **Last Round**: Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.
2. **Low Stock Levels**: If S < stock/(2n), cooperate (C) to help replenish the stock and avoid depletion.
3. **High Opponent Defection Rate**: If more than 75% of opponents defected in the previous round, cooperate (C) in the next round to try to re-establish cooperation.

**Pseudocode:**

```
function ACST(current_stock, capacity, num_players, round_number, history):
    // Initial round
    if round_number == 1:
        return C
    
    // Calculate stock threshold
    T = capacity * (num_players / (2 * num_players + 1))
    
    // Stock-based trigger
    if current_stock >= T:
        action = C
    else:
        action = D
    
    // History-dependent adjustment
    avg_payoff = calculate_average_payoff(history)
    if avg_payoff < current_stock / (2 * num_players):
        T *= 1.05  // Increase threshold by 5%
    
    // Opponent behavior response
    opponent_defections = count_opponent_defections(history)
    if opponent_defections > num_players / 2:
        T *= 1.10  // Increase threshold by 10%
    
    return action

function calculate_average_payoff(history):
    // Calculate average payoff from previous rounds
    pass

function count_opponent_defections(history):
    // Count number of opponents that defected in the previous round
    pass
```

The ACST strategy balances individual self-interest with collective sustainability by adapting to the game's state and history. By using a stock-based trigger, it encourages cooperation when the stock level is sufficient and defects when the stock level is low. The strategy also responds to opponent behavior, adjusting its threshold to discourage exploitation.
'''

description_COLLECTIVE_269 = '''
**Collective Strategy: "Adaptive Common Pool Conservatism" (ACPC)**

The ACPC strategy balances individual self-interest with collective responsibility, adapting to the game's state and history while being robust to diverse opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative baseline and encourage others to do the same.
2. **State-Dependent Cooperation**: In subsequent rounds, cooperate if the current stock level is above a threshold (`stock_threshold = 0.7 * capacity`). This ensures that when the stock is relatively healthy, players prioritize sustainability over short-term gains.
3. **Defect-Switching**: Switch to Defect (D) if:
	* The previous round's total consumption exceeded `0.5 * capacity` (indicating excessive exploitation).
	* Your own payoff in the previous round was lower than the average payoff of all players (`π_i,t-1 < (Σ(π_j,t-1)) / n`) and the current stock level is below `stock_threshold`. This indicates that others may be exploiting the common pool, and it's time to adapt.
4. **Punishment Mechanism**: If a player defects in a round where the total consumption exceeded `0.5 * capacity`, and their payoff was higher than the average payoff (`π_i,t > (Σ(π_j,t)) / n`), all other players will defect against them in the next round. This discourages excessive exploitation.
5. **Endgame Cooperation**: In the last round, cooperate if the current stock level is above `0.2 * capacity`. This helps maintain a minimum stock level for potential future games.

**Edge Cases:**

* If the game is played with only 2 players (n=2), always cooperate in the first round and then follow the state-dependent cooperation rule.
* In the last two rounds, if the current stock level is below `0.2 * capacity`, defect to maximize individual payoff.

**Collective Mindset Alignment:**

The ACPC strategy promotes a collective mindset by:

* Encouraging cooperation when the common pool is healthy (state-dependent cooperation).
* Discouraging excessive exploitation through defect-switching and punishment mechanisms.
* Fostering cooperation in the endgame to maintain a minimum stock level for potential future games.

**Pseudocode:**
```python
def ACPC(stock, capacity, n, round_number, history):
  if round_number == 1:
    return "Cooperate"
  
  if stock > 0.7 * capacity:
    return "Cooperate"
  
  if total_consumption_prev_round > 0.5 * capacity and my_payoff_prev_round < average_payoff_prev_round:
    return "Defect"
  
  if punishment_triggered(history):
    return "Defect"
  
  if round_number == last_round and stock > 0.2 * capacity:
    return "Cooperate"
  
  # default to cooperate
  return "Cooperate"

def punishment_triggered(history):
  for player in history[-1]:
    if player['payoff'] > average_payoff_last_round and player['action'] == 'Defect':
      return True
  return False
```
This strategy balances individual interests with collective responsibility, adapting to the game's state and history while being robust to diverse opponent behaviors.
'''

description_COLLECTIVE_270 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and avoid early stock depletion.
2. **Stock-based Cooperation**: Cooperate if the current stock level is above 75% of the capacity. This threshold encourages cooperation when the stock is relatively high, promoting sustainability.
3. **Defection Threshold**: Defect (D) if more than half of the players defected in the previous round or if the current stock level is below 25% of the capacity. This rule responds to aggressive behavior and avoids further depletion when the stock is low.
4. **Payoff-based Adaptation**: If a player's total payoff over the last three rounds is less than 75% of their expected payoff (assuming all players cooperate), they will defect in the next round. This adaptation mechanism helps players adjust to changing circumstances.

**Edge Cases:**

1. **Last Round**: Cooperate in the final round, as there is no future stock growth or consequence for over-consumption.
2. **Low Stock**: If the current stock level is critically low (below 10% of capacity), defect to maximize individual payoff, as cooperation would yield negligible benefits.

**Collective Mindset:**

The ASC strategy aligns with a collective mindset by:

1. Encouraging cooperation when the stock is high, promoting sustainability and shared benefits.
2. Responding to defection with defection, discouraging exploitation and maintaining fairness.
3. Adapting to changing circumstances, ensuring players adjust their behavior based on the game's dynamics.

**Pseudocode:**
```python
def ASC_strategy(current_stock, capacity, num_players, round_number, history):
    # Initial Round
    if round_number == 1:
        return "C"

    # Stock-based Cooperation
    if current_stock >= 0.75 * capacity:
        return "C"

    # Defection Threshold
    previous_defections = sum([h["defected"] for h in history[-1:]])
    if previous_defections > num_players / 2 or current_stock < 0.25 * capacity:
        return "D"

    # Payoff-based Adaptation
    total_payoff = sum([h["payoff"] for h in history[-3:]])
    expected_payoff = (capacity / (2 * num_players)) * 3
    if total_payoff < 0.75 * expected_payoff:
        return "D"

    # Last Round
    if round_number == r:
        return "C"

    # Low Stock
    if current_stock < 0.1 * capacity:
        return "D"

    # Default: Cooperate
    return "C"
```
This strategy balances individual and collective interests, adapting to the game's state and history while promoting sustainability and fairness.
'''

description_COLLECTIVE_271 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold**

Our collective strategy aims to balance individual payoffs with the sustainability of the common pool resource. We introduce a dynamic cooperation threshold based on the current stock level, which adapts to the game's history and state.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) if the initial stock is above 75% of capacity; otherwise, Defect (D).
2. **Subsequent Rounds (t>1):**
	* If the current stock is above the threshold (TH), cooperate (C). The threshold TH is calculated as: `TH = capacity * (0.5 + (0.5 * average_stock_over_last_3_rounds / capacity))`
	* Otherwise, defect (D) with a probability P_DEFECT, which increases linearly from 0 to 1 as the stock level decreases from TH to 0.
	* If at least one player defected in the previous round, increase P_DEFECT by 20% for this round only.

**Pseudocode:**
```python
def get_action(stock, capacity, history):
    if current_round == 1:
        if stock > 0.75 * capacity:
            return COOPERATE
        else:
            return DEFECT

    # Calculate threshold (TH) based on average stock over last 3 rounds
    avg_stock_last_3 = sum(history[-3:]) / 3
    TH = capacity * (0.5 + (0.5 * avg_stock_last_3 / capacity))

    if stock > TH:
        return COOPERATE
    else:
        # Calculate P_DEFECT based on stock level and history
        P_DEFECT = max(0, min(1, 1 - (stock / TH)))  # increase P_DEFECT as stock decreases

        if any(player_defected in history[-1:]):
            P_DEFECT += 0.2  # Increase P_DEFECT by 20% if someone defected last round

        return DEFECT if random.random() < P_DEFECT else COOPERATE
```
**Edge Cases:**

* **Last Round:** Cooperate (C) to ensure a positive final payoff, regardless of the stock level.
* **Stock Depletion:** If the stock is severely depleted (< 10% of capacity), defect (D) to maximize individual payoffs.

By adapting our cooperation threshold based on the current stock level and game history, we promote sustainable resource use while allowing for flexibility in response to opponents' behaviors. This collective strategy balances short-term gains with long-term sustainability, making it robust against a wide range of opponent strategies.
'''

description_COLLECTIVE_272 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

ACH is a collective strategy that balances individual payoffs with long-term sustainability of the common pool resource. It adapts to the game state and history, while promoting cooperation among players.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about other players' behaviors.
2. **Stock Level**: If the current stock level is below 50% of the capacity, Defect (D) to maximize individual payoff in the short term. Otherwise, proceed to step 3.
3. **Opponent Behavior**: Analyze the actions of other players in the previous round:
	* If at least 75% of opponents Cooperated (C), Cooperate (C) in the current round to maintain a cooperative environment.
	* If 25-74% of opponents Cooperated (C), use a mixed strategy: Cooperate (C) with probability 0.5 and Defect (D) with probability 0.5.
	* If less than 25% of opponents Cooperated (C), Defect (D) to protect individual interests.
4. **Payoff-based Adjustment**: If the player's total payoff is below the average payoff of all players in the previous round, increase the probability of Defection (D) by 0.1 in the next round.

**Edge Cases:**

* **Last Round**: Cooperate (C) in the last round to maintain a positive relationship with other players and maximize collective payoff.
* **Low Stock**: If the stock level is critically low (<10% of capacity), Defect (D) to ensure individual survival, even if it means depleting the resource.

**Collective Mindset:**

ACH prioritizes cooperation when possible, while adapting to the actions of other players and the game state. By balancing individual payoffs with long-term sustainability, ACH promotes a collective mindset that benefits all players in the game.

Pseudocode:
```python
def AdaptiveCooperativeHarvesting(state, history):
  # Initial Round
  if round == 1:
    return Cooperate

  # Stock Level
  if state.stock < 0.5 * capacity:
    return Defect

  # Opponent Behavior
  opponent_actions = history[-1]
  cooperate_ratio = sum(opponent_actions == 'C') / len(opponent_actions)
  if cooperate_ratio >= 0.75:
    return Cooperate
  elif cooperate_ratio >= 0.25:
    return random.choice([Cooperate, Defect])
  else:
    return Defect

  # Payoff-based Adjustment
  if player_payoff < average_payoff:
    defect_probability += 0.1

  # Last Round
  if round == r:
    return Cooperate

  # Low Stock
  if state.stock < 0.1 * capacity:
    return Defect
```
This strategy is designed to be robust and adaptive, allowing it to perform well in a wide range of scenarios and opponent behaviors.
'''

description_COLLECTIVE_273 = '''
**Collective Strategy: Adaptive Cooperation**

To achieve a robust and adaptive collective strategy, we'll employ a combination of reactive and proactive elements. Our approach will focus on maintaining a balance between cooperation and self-interest, while being responsive to the actions of other players.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) with probability 0.5. This initial randomization helps us gauge the behavior of other players.
2. **Subsequent Rounds (t>1):**
	* Observe the actions of all players in the previous round.
	* Calculate the **Cooperation Index (CI)**: The proportion of players who cooperated in the previous round.
	* If CI ≥ 0.5, Cooperate (C). Otherwise, Defect (D).
3. **Adaptive Adjustment:**
	* Monitor the stock level and adjust our strategy based on its trend:
		+ If the stock level is increasing or stable, maintain our current action (C or D).
		+ If the stock level is decreasing rapidly (> 20% drop in a single round), switch to Cooperate (C) for the next round.

**Edge Cases:**

1. **Last Round (t=r):**
	* Defect (D) if the stock level is above 50% of capacity.
	* Cooperate (C) otherwise, to ensure some remaining stock for potential future rounds.
2. **Low Stock Levels (< 20% of capacity):**
	* Always Cooperate (C) to prevent over-exploitation and promote recovery.

**Pseudocode:**

```
function AdaptiveCooperation(stock, history, n, r, t):
  if t == 1:
    return random.choice([C, D])  # Initial randomization
  else:
    ci = calculate_cooperation_index(history[t-1])
    if ci >= 0.5:
      action = C
    else:
      action = D
    
    if is_stock_decreasing_rapidly(stock, history):
      action = C
    
    return action

function is_stock_decreasing_rapidly(stock, history):
  # Check for > 20% drop in a single round
  prev_stock = history[t-1].stock
  return (prev_stock - stock) / prev_stock > 0.2

function calculate_cooperation_index(history):
  cooperators = sum(1 for action in history if action == C)
  return cooperators / n
```

**Collective Mindset:**
Our strategy aligns with the collective mindset by:

1. Encouraging cooperation when a majority of players cooperate.
2. Adapting to changes in stock levels and adjusting our strategy accordingly.
3. Prioritizing long-term sustainability over short-term gains.

By being responsive to the actions of other players and the state of the game, we can promote a balance between cooperation and self-interest, ultimately contributing to a more sustainable outcome for all participants.
'''

description_COLLECTIVE_274 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to set a positive tone and establish a baseline stock level.
2. **Stock Threshold**: If the current stock level is below 50% of the capacity, Defect (D) to maximize individual payoff. This ensures a minimum return when the collective's cooperation is insufficient to maintain a healthy stock.
3. **Opponent Behavior Analysis**: Monitor the actions of all players in previous rounds and calculate the average cooperation rate (ACR). ACR is the proportion of cooperative actions taken by all players.
4. **Cooperation Threshold**: If ACR is above 0.5, Cooperate (C) to reinforce collective cooperation and maintain a healthy stock level. Otherwise, Defect (D) to protect individual interests.

Pseudocode:
```
IF current_round == 1 THEN
    action = C
ELSE IF stock_level < 0.5 * capacity THEN
    action = D
ELSE
    ACR = calculate_average_cooperation_rate()
    IF ACR > 0.5 THEN
        action = C
    ELSE
        action = D
```
**Edge Cases:**

1. **Last Round**: In the final round, Defect (D) to maximize individual payoff, as there is no future benefit to cooperation.
2. **Ties in ACR**: If the average cooperation rate is exactly 0.5, Cooperate (C) to maintain a positive collective outcome.

**Collective Mindset:**

The ASP strategy prioritizes the preservation of the common pool resource while adapting to the actions of other players. By cooperating when the collective cooperation rate is high and defecting when it's low, the strategy aims to balance individual interests with the need for collective sustainability.

**Robustness and Adaptability:**

1. **Handling Free-Riders**: ASP detects when opponents are not cooperating and adjusts its behavior accordingly.
2. **Responding to Changes in Opponent Behavior**: The strategy continuously monitors opponent actions and adapts its decision-making process based on changes in the average cooperation rate.
3. **Mitigating Over-Exploitation**: By defecting when the stock level is low, ASP prevents over-exploitation of the resource.

The Adaptive Stock Preservation (ASP) strategy strikes a balance between individual interests and collective sustainability, making it a robust and effective approach for playing the Common Pool Resource Game against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_275 = '''
**Collective Strategy: "Adaptive Stock-Conscious Tit-for-Tat" (ASC-TFT)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a cooperative tone and maximize initial payoff.
2. **Subsequent Rounds**: Observe the previous round's actions and payoffs. If the stock level is above 50% of capacity, cooperate (C). If the stock level falls below 50% of capacity, defect (D).
3. **Tit-for-Tat Component**: Monitor the opponent's behavior in the previous round. If an opponent defected (D) while our strategy cooperated (C), defect (D) in the current round to punish non-cooperative behavior.
4. **Stock-Conscious Adaptation**: Adjust the cooperation threshold based on the stock level:
	* If the stock level is above 75% of capacity, decrease the cooperation threshold by 10%.
	* If the stock level falls below 25% of capacity, increase the cooperation threshold by 10%.

Pseudocode:
```python
def ASC_TFT(stock_level, opponent_actions, our_payoffs):
    if round == 1:  # Initial Round
        return 'C'
    
    previous_stock_level = stock_level - total_consumption
    
    if previous_stock_level > 0.5 * capacity:
        cooperation_threshold = 0.5
    elif previous_stock_level < 0.25 * capacity:
        cooperation_threshold = 0.7
    else:
        cooperation_threshold = 0.6
    
    # Tit-for-Tat Component
    for opponent in opponent_actions:
        if opponent == 'D' and our_payoffs[opponent] > 0:
            return 'D'
    
    # Stock-Conscious Adaptation
    if stock_level > 0.75 * capacity:
        cooperation_threshold -= 0.1
    elif stock_level < 0.25 * capacity:
        cooperation_threshold += 0.1
    
    if random.random() < cooperation_threshold:
        return 'C'
    else:
        return 'D'
```
**Edge Cases:**

* **Last Round**: Cooperate (C) to maximize payoff, as the game will end after this round.
* **Zero Stock Level**: Defect (D), as there is no stock to consume.

**Collective Mindset Alignment:**
This strategy prioritizes cooperation when the stock level is high and adapts to more selfish behavior when the stock level decreases. By incorporating a tit-for-tat component, our strategy promotes reciprocity and punishes non-cooperative opponents. The adaptive threshold adjustment ensures that our strategy remains responsive to changes in the game state.

By employing this collective strategy, we aim to achieve a balance between cooperation and self-interest, maximizing payoffs while minimizing the risk of stock depletion.
'''

description_COLLECTIVE_276 = '''
**Collective Strategy: "Adaptive Stock Harmony" (ASH)**

**Decision Rules:**

1. **First Round:** Cooperate (C) unconditionally to establish a baseline for cooperation and observe initial stock dynamics.
2. **Subsequent Rounds:** Assess the current stock level and previous round's actions.

a. If the stock level is above 75% of capacity, cooperate (C) if the majority (>50%) of players cooperated in the previous round; otherwise, defect (D).

b. If the stock level is between 25% and 75% of capacity, use a probabilistic approach:

* With probability p = (current stock / capacity), cooperate (C); otherwise, defect (D). This adapts to the stock's resilience.

c. If the stock level is below 25% of capacity, defect (D) unconditionally to maximize individual payoff in a depleted environment.

3. **Last Round:** Cooperate (C) if the stock level is above 50% of capacity; otherwise, defect (D).

**Edge Case Handling:**

* In cases where multiple rules apply (e.g., first round and low stock), prioritize the rule that promotes cooperation.
* When in doubt or faced with conflicting signals, default to cooperating.

**Collective Mindset Alignment:**

ASH aims to balance individual self-interest with collective responsibility for maintaining a healthy common pool. By adapting to the stock's dynamics and previous players' actions, ASH encourages cooperation when it benefits both the individual and the group. This strategy also acknowledges that some level of defection may be necessary in depleted environments.

**Rationale:**

1. **Initial Cooperation:** Establishes a cooperative tone and sets a baseline for assessing subsequent behavior.
2. **Adaptive Response:** Adjusts to changing stock levels, promoting cooperation when it's sustainable and defecting when the environment is depleted.
3. **Majority Influence:** Responds to collective behavior, encouraging cooperation if most players cooperate and adapting to potential free-riding.
4. **Probabilistic Approach:** Introduces randomness to prevent predictability and exploit potential vulnerabilities in opponents' strategies.

By implementing ASH, we create a robust and adaptive strategy that balances individual interests with collective responsibility, increasing the likelihood of maintaining a healthy common pool while competing against various opponent behaviors.
'''

description_COLLECTIVE_277 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective stock conservation, adapting to changing game conditions and opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' actions.
2. **Stock Level Assessment:** Evaluate the current stock level (S) relative to the capacity:
	* If S ≥ 0.75 \* capacity, cooperate (C).
	* If 0.25 \* capacity ≤ S < 0.75 \* capacity, use a mixed strategy (see below).
	* If S < 0.25 \* capacity, defect (D) to maximize individual payoff.
3. **Mixed Strategy:** When the stock level is between 0.25 and 0.75 of the capacity, ASC uses a probabilistic approach:
	+ Calculate the average opponent cooperation rate (OCR) over the previous rounds.
	+ If OCR ≥ 0.5, cooperate (C) with probability 0.7; otherwise, defect (D) with probability 0.3.

**Edge Cases:**

1. **Last Round:** Defect (D) in the final round to maximize individual payoff, as there is no future benefit to cooperation.
2. **Opponent Cooperation Rate Calculation:** For the first few rounds, assume OCR = 0.5. As more data becomes available, update OCR based on observed opponent actions.

**Collective Mindset:**

1. **Cooperation Threshold:** ASC aims to maintain a stock level above 0.75 of the capacity by cooperating when possible.
2. **Adaptive Response:** By adjusting cooperation probability based on opponent behavior and stock levels, ASC promotes collective conservation while protecting individual interests.
3. **Robustness:** The mixed strategy allows ASC to respond effectively to various opponent behaviors, including free-riding or tit-for-tat strategies.

**Pseudocode:**
```markdown
# Initialize variables
stock_level = capacity
opponent_cooperation_rate = 0.5

# Loop through rounds
for round in range(1, r + 1):
    # Evaluate stock level and adjust cooperation probability
    if stock_level >= 0.75 * capacity:
        action = C
    elif 0.25 * capacity <= stock_level < 0.75 * capacity:
        # Mixed strategy
        if opponent_cooperation_rate >= 0.5:
            action = C with probability 0.7, D with probability 0.3
        else:
            action = D with probability 0.3, C with probability 0.7
    else:
        action = D

    # Update opponent cooperation rate and stock level
    if round > 1:
        opponent_cooperation_rate = (opponent_cooperation_rate * (round - 2) + observed_opponent_actions) / (round - 1)
    stock_level -= total_consumption

# Last round: defect to maximize individual payoff
if round == r:
    action = D
```
ASC's adaptive approach and focus on collective conservation make it a robust strategy for playing the Common Pool Resource Game against various opponents.
'''

description_COLLECTIVE_278 = '''
**Collective Strategy: "Adaptive Stock Preservation" (ASP)**

**Decision Rules:**

1. **Initial Rounds (t ≤ 2): Cooperate**
In the first two rounds, cooperate to gather information about other players' behavior and observe the initial stock dynamics.
2. **Stock-Based Cooperation**: If the current stock level is above a certain threshold (`stock_threshold`), cooperate. The `stock_threshold` will be calculated as a fraction of the capacity (e.g., 0.7 \* capacity).
3. **Defection Detection**: Monitor the actions of other players and detect if any player has defected in the previous round. If a defection is detected, defect in the current round.
4. **Stock Recovery**: If the stock level falls below a certain threshold (`stock_recovery_threshold`), cooperate to help recover the stock. The `stock_recovery_threshold` will be set lower than `stock_threshold` (e.g., 0.3 \* capacity).
5. **Endgame Cooperation** (last round): Cooperate if the current stock level is above a certain threshold (`endgame_threshold`) and no player has defected in the previous round.

**Pseudocode:**
```
function ASP(n, r, capacity, stock, history) {
  // Initial rounds
  if (round <= 2) {
    return COOPERATE;
  }

  // Stock-based cooperation
  stock_threshold = 0.7 * capacity;
  if (stock > stock_threshold) {
    return COOPERATE;
  }

  // Defection detection
  for (player in history[previous_round]) {
    if (player.action == DEFECT) {
      return DEFECT;
    }
  }

  // Stock recovery
  stock_recovery_threshold = 0.3 * capacity;
  if (stock < stock_recovery_threshold) {
    return COOPERATE;
  }

  // Endgame cooperation
  endgame_threshold = 0.5 * capacity;
  if (round == r && stock > endgame_threshold && no_defection_in_previous_round()) {
    return COOPERATE;
  }

  // Default action: Cooperate
  return COOPERATE;
}
```
**Edge Cases:**

* **First Round**: Cooperate to gather information.
* **Last Round**: Cooperate if the current stock level is above `endgame_threshold` and no player has defected in the previous round.
* **Stock Depletion**: If the stock level falls below `stock_recovery_threshold`, cooperate to help recover the stock.

**Collective Mindset:**
The ASP strategy prioritizes cooperation while adapting to changing game conditions. By monitoring other players' actions, it can detect defections and respond accordingly. The strategy balances individual payoffs with collective well-being, aiming to preserve a healthy stock level for all players.
'''

description_COLLECTIVE_279 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability, adapting to changing game conditions and opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to follow suit.
2. **Subsequent Rounds:** Use a combination of current stock level and historical data to inform decisions.
	* Calculate the average payoff per player over the past rounds (`avg_payoff`).
	* If `avg_payoff` is above a certain threshold (e.g., 75% of the maximum possible payoff), Cooperate (C). This indicates that opponents are generally cooperating, and we should maintain this balance.
	* Otherwise, Defect (D) to increase our short-term payoff. However, if the current stock level falls below 50% of the capacity, Cooperate (C) to conserve resources for future rounds.
3. **Last Round:** Defect (D) in the final round, as there is no future cost to over-extraction and individual payoffs are prioritized.

**Adaptive Component:**

1. **Stock Level Monitoring:** Track the current stock level (`stock_level`) and adjust our decision-making accordingly.
2. **Opponent Behavior Analysis:** Monitor opponents' actions and update `avg_payoff` to reflect their strategies.
3. **Threshold Adjustment:** Dynamically adjust the `avg_payoff` threshold based on the game's progress, increasing it as the game nears its end.

**Edge Cases:**

1. **Zero Stock Level:** If the stock level reaches zero, Cooperate (C) in subsequent rounds to allow for potential growth and future payoffs.
2. **Last Round with Low Stock:** If the stock level is below 25% of capacity in the final round, Cooperate (C) to prevent total depletion.

**Pseudocode:**
```python
def ASC(n, r, capacity, current_stock, history):
    # Initial round
    if history == []:
        return 'Cooperate'

    # Calculate average payoff
    avg_payoff = sum(history['payoffs']) / len(history['payoffs'])

    # Decision rules
    if avg_payoff > 0.75 * max_payoff:
        if current_stock < 0.5 * capacity:
            return 'Cooperate'
        else:
            return 'Defect'
    else:
        if history[-1]['stock_level'] < 0.25 * capacity:
            return 'Cooperate'
        else:
            return 'Defect'

    # Last round
    if len(history) == r - 1:
        return 'Defect'
```
This strategy balances individual payoffs with collective sustainability, adapting to changing game conditions and opponent behaviors. By conserving resources when necessary and exploiting opportunities when available, ASC aims to achieve a high total payoff while promoting cooperation among players.
'''

description_COLLECTIVE_280 = '''
To develop a collective strategy for this Common Pool Resource Game, we'll employ a combination of game theory insights and adaptive mechanisms to ensure robustness against various opponent behaviors.

**Decision Rules:**

Our strategy, dubbed "Adaptive Collective Conservation" (ACC), is based on the following principles:

1. **Initial Cooperation**: In the first round, cooperate (play C) to establish a baseline for the group's behavior.
2. **Stock-Based Threshold**: Define a stock threshold (ST) as 75% of the capacity. If the current stock level exceeds ST, play C; otherwise, defect (play D).
3. **Defection Response**: Monitor the previous round's total consumption and calculate the average individual consumption (AIC). If AIC is above the sustainable level (i.e., stock/(2n)), defect in the next round.
4. **Cooperation Incentive**: If a player has cooperated in the previous round, and the resulting new stock level exceeds ST, reward cooperation by playing C again.

**Pseudocode:**

```
function ACC(current_stock, capacity, history):
  // Initial Cooperation
  if history == []:
    return C

  // Stock-Based Threshold
  ST = 0.75 * capacity
  if current_stock > ST:
    return C

  // Defection Response
  prev_total_consumption = calculate_prev_total_consumption(history)
  AIC = prev_total_consumption / n
  sustainable_level = stock / (2n)
  if AIC > sustainable_level:
    return D

  // Cooperation Incentive
  prev_player_action = history[-1]
  if prev_player_action == C and new_stock_level >= ST:
    return C

  // Default to Defect
  return D
```

**Edge Cases:**

* **Last Round**: Play D, as there's no future benefit from cooperation.
* **First Round with n=2**: Cooperate (play C), as the threshold mechanism may lead to mutual defection otherwise.

**Collective Mindset Alignment:**

ACC aims to balance individual interests with collective conservation goals. By incorporating a stock-based threshold and adapting to previous rounds' consumption patterns, ACC promotes cooperation when it benefits the group while allowing for strategic defections when necessary. This approach fosters a shared understanding among players that prioritizes sustainable resource management.

**Robustness:**

ACC's adaptive nature allows it to respond effectively to various opponent strategies:

* **Cooperative opponents**: ACC will maintain cooperation, ensuring mutual benefits.
* **Defecting opponents**: ACC will defect in response, minimizing losses.
* **Mixed-strategy opponents**: ACC's stock-based threshold and defection response mechanisms enable it to adapt to changing circumstances.

By implementing ACC, we create a collective strategy that balances individual interests with the need for sustainable resource management, making it an effective competitor in a tournament setting.
'''

description_COLLECTIVE_281 = '''
**Collective Strategy: Adaptive Common Pool Resource Management (ACPRM)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) with a probability of 0.5 to gather information about opponents' behavior and initial stock dynamics.
2. **Subsequent Rounds**: Use the following decision rules based on the current state and history:
	* If the previous round's total consumption was less than or equal to the capacity's sustainable level (i.e., `total_consumption ≤ capacity / 2`):
		+ Cooperate (C) if at least half of the players cooperated in the previous round.
		+ Defect (D) otherwise.
	* If the previous round's total consumption exceeded the capacity's sustainable level (`total_consumption > capacity / 2`):
		+ Cooperate (C) to help replenish the stock and maintain a stable environment.
3. **Low Stock Warning**: If the current stock level is below 20% of the capacity, cooperate (C) to prioritize stock replenishment over personal gain.

**Edge Case Handling:**

1. **Last Round**: Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Tiebreakers**: In cases where the decision rules result in a tie, choose Cooperate (C) to prioritize collective well-being.

**Pseudocode:**
```python
def ACPRM(current_stock, capacity, num_players, round_history):
    if round_number == 1:
        # Initial round: random cooperation
        return random.choice([C, D])

    prev_round_consumption = sum(round_history[-1]['consumptions'])
    prev_round_cooperators = sum(1 for action in round_history[-1]['actions'] if action == C)

    if prev_round_consumption <= capacity / 2:
        if prev_round_cooperators >= num_players / 2:
            return C
        else:
            return D
    else:
        # High consumption: prioritize cooperation to replenish stock
        return C

    # Low stock warning
    if current_stock < 0.2 * capacity:
        return C

    # Last round: defect for maximum individual payoff
    if round_number == num_rounds:
        return D

    # Tiebreaker: prefer cooperation
    return C
```
**Collective Mindset Alignment:**

The ACPRM strategy prioritizes collective well-being by:

1. Encouraging cooperation when the stock level is sustainable and opponents are cooperative.
2. Adapting to high consumption levels by promoting cooperation to replenish the stock.
3. Prioritizing stock replenishment over individual gain when the stock level is critically low.

By following these decision rules, ACPRM aims to maintain a stable and sustainable common pool resource environment, ensuring fair payoffs for all players while minimizing the risk of catastrophic stock depletion.
'''

description_COLLECTIVE_282 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Overview**

The ACH strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. It encourages cooperation while being robust to various opponent behaviors.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to set a positive tone and avoid early stock depletion.
2. **Stock-dependent Cooperation**: For subsequent rounds, cooperate if the current stock is above a threshold (τ). This ensures that cooperation occurs when the stock is relatively abundant.

   - τ = capacity / (2n)

3. **Defection Trigger**: Defect (D) if:
   - The previous round's total consumption exceeded 75% of the stock.
   - Or, if more than half of the players defected in the previous round.

4. **Adaptive Cooperation**: If a player has cooperated in the previous round and the stock increased or remained stable, continue cooperating.

5. **Punishment Mechanism**: If a player detects that another player has defected while they cooperated, defect for one round to signal disapproval.

**Edge Cases**

1. **Last Round**: Defect in the final round, as there are no future rounds to consider.
2. **Zero Stock**: Cooperate if the stock is zero or very low (close to 0) to avoid further depletion and encourage regeneration.

**Collective Mindset Alignment**

ACH prioritizes collective sustainability while allowing for individual payoffs. By cooperating when the stock is abundant, players ensure a healthy resource base for future rounds. The strategy adapts to various opponent behaviors by responding to changes in the game state and history.

**Pseudocode**
```
function ACH(current_stock, previous_actions, capacity, n):
  // Initial Round
  if round == 1:
    return C

  // Stock-dependent Cooperation
  τ = capacity / (2n)
  if current_stock > τ:
    return C

  // Defection Trigger
  prev_total_consumption = calculate_prev_total_consumption(previous_actions)
  prev_defectors = count_prev_defectors(previous_actions)

  if prev_total_consumption > 0.75 * previous_stock or prev_defectors > n/2:
    return D

  // Adaptive Cooperation
  if self.cooperated_last_round and stock_increased_or_stable:
    return C

  // Punishment Mechanism
  if detected_defection_last_round:
    return D (for one round)

  // Default to cooperation
  return C
```
This strategy balances individual payoffs with collective sustainability, making it a robust choice for the tournament.
'''

description_COLLECTIVE_283 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy balances individual payoffs with collective sustainability, adapting to the game's dynamic state and opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline stock level and encourage cooperation.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play Tit-for-Tat (TFT):
		+ Cooperate (C) if most opponents cooperated in the previous round.
		+ Defect (D) otherwise.
	* If the current stock level is below 50% of capacity, Defect (D).
3. **Last Round (t=r):** Defect (D), as there's no future benefit to cooperation.

**Additional Considerations:**

* Monitor opponents' actions and adjust the TFT threshold accordingly:
	+ If most opponents defect frequently, increase the TFT threshold to 60% of capacity.
	+ If most opponents cooperate frequently, decrease the TFT threshold to 40% of capacity.
* **Stock Depletion Rate (SDR):** Calculate the average stock depletion rate over the past few rounds. If SDR exceeds 20% of capacity per round, defect more frequently (e.g., increase the TFT threshold).

**Pseudocode:**
```
ASC_Strategy(stock, capacity, n, r, history):
  if t == 1:
    return C
  else:
    stock_ratio = stock / capacity
    if stock_ratio >= 0.75:
      return C
    elif 0.5 <= stock_ratio < 0.75:
      opponents_cooperated = count(C) in history[-1]
      if opponents_cooperated > n/2:
        return C
      else:
        return D
    else:
      return D

  # Adjust TFT threshold based on opponent behavior
  if most_opponents_defect(history):
    tft_threshold = 0.6
  elif most_opponents_cooperate(history):
    tft_threshold = 0.4
  else:
    tft_threshold = 0.5

  # Monitor stock depletion rate and adjust strategy
  sdr = calculate_stock_depletion_rate(history)
  if sdr > 0.2 * capacity / r:
    defect_more_frequently()
```
**Collective Mindset:**

The ASC strategy prioritizes collective sustainability while adapting to individual payoffs. By initially cooperating, we encourage opponents to cooperate and establish a stable stock level. As the game progresses, our adaptive TFT approach ensures that we respond to opponent behaviors while maintaining a balance between cooperation and self-interest.

By monitoring stock depletion rates and adjusting our strategy accordingly, we prevent over-exploitation of the common resource. In the final round, defecting ensures that we maximize individual payoffs without compromising the collective's long-term sustainability.
'''

description_COLLECTIVE_284 = '''
**Collective Strategy: "Adaptive Stock-Conscious Cooperation" (ASCC)**

ASCC aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative baseline.
2. **Subsequent Rounds:**
	* If the current stock is above 75% of capacity, cooperate (C).
	* If the current stock is between 50% and 75% of capacity, defect (D) with a probability proportional to the number of players who defected in the previous round (i.e., tit-for-tat).
	* If the current stock is below 50% of capacity, cooperate (C) to help replenish the stock.
3. **Last Round:** Defect (D) to maximize individual payoff, as the game's end reduces the importance of sustainability.

**Edge Cases:**

1. **Low Stock:** If the current stock is extremely low (<10%), cooperate (C) to avoid depletion and potential future losses.
2. **High Defection Rate:** If more than 75% of players defected in the previous round, defect (D) to minimize losses.

**Adaptive Component:**

1. **Stock-Conscious Adjustment:** Adjust cooperation probability based on the current stock level:
	* High stock (>75%): Increase cooperation probability by 10%.
	* Low stock (<50%): Decrease cooperation probability by 10%.
2. **Tit-for-Tat Adaptation:** Update tit-for-tat probabilities based on opponents' actions in previous rounds.

**Pseudocode:**
```markdown
# ASCC Strategy

def ASCC(stock, capacity, num_players, history):
    # Initial Round
    if len(history) == 0:
        return COOPERATE
    
    # Subsequent Rounds
    stock_ratio = stock / capacity
    if stock_ratio > 0.75:
        return COOPERATE
    elif stock_ratio >= 0.5:
        defect_prob = calculate_defect_probability(history)
        return DEFECT with probability defect_prob
    else:
        return COOPERATE
    
    # Last Round
    if len(history) == num_rounds - 1:
        return DEFECT

def calculate_defect_probability(history):
    # Tit-for-tat adaptation
    previous_defections = count_defections_in_history(history)
    defect_probability = previous_defections / num_players
    return defect_probability

def stock_conscious_adjustment(stock, capacity):
    # Adjust cooperation probability based on current stock level
    stock_ratio = stock / capacity
    if stock_ratio > 0.75:
        cooperation_probability += 0.1
    elif stock_ratio < 0.5:
        cooperation_probability -= 0.1

def count_defections_in_history(history):
    # Count defections in previous rounds
    defections = [action for action in history if action == DEFECT]
    return len(defections)
```
**Collective Mindset:**
ASCC prioritizes cooperation when the stock is high, while adapting to opponents' actions and adjusting its strategy based on the game's state. This approach balances individual payoffs with collective sustainability, aiming to create a mutually beneficial outcome for all players.

By incorporating tit-for-tat elements and adaptive components, ASCC can respond effectively to various opponent behaviors, including defectors and cooperators.
'''

description_COLLECTIVE_285 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with probability 0.5. This initial randomization helps to avoid over-exploitation and encourages cooperation.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above a certain threshold (`stock_threshold`), cooperate (C). This threshold is calculated as `capacity / (2n) * (1 - 1/r)`, where `r` is the number of rounds remaining.
	* Otherwise, defect (D).
3. **Punishment Mechanism:** If the stock level drops below a certain threshold (`punishment_threshold`) due to excessive harvesting by others, switch to Defect (D) for the next round. This threshold is calculated as `capacity / (2n) * 0.25`.
4. **Reward Mechanism:** If the stock level increases significantly (by more than `reward_threshold`, e.g., 10%) in a single round due to cooperative behavior, cooperate (C) with higher probability (e.g., 0.7) for the next round.

**Pseudocode:**
```python
def adaptive_cooperative_harvesting(stock, capacity, n, r, t):
    if t == 1:
        # Initial randomization
        return C with probability 0.5

    stock_threshold = capacity / (2n) * (1 - 1/r)
    punishment_threshold = capacity / (2n) * 0.25
    reward_threshold = 0.10  # 10% increase in stock level

    if stock > stock_threshold:
        return C
    elif stock < punishment_threshold:
        # Punishment mechanism: switch to Defect for next round
        return D
    else:
        # Reward mechanism: cooperate with higher probability if stock increases significantly
        if stock_increase > reward_threshold:
            return C with probability 0.7
        else:
            return C with probability 0.5

def calculate_payoff(stock, n):
    return stock / (2n)
```
**Collective Mindset:**
The ACH strategy prioritizes cooperation to maintain a sustainable stock level while adapting to the actions of other players. By initially randomizing cooperation and incorporating punishment and reward mechanisms, ACH encourages collective behavior and prevents over-exploitation.

**Edge Cases:**

* **Last Round (t=r):** Cooperate (C) if the stock level is above `stock_threshold`, as there are no future rounds to consider.
* **Stock Depletion:** If the stock level drops to 0, cooperate (C) in the next round to allow for regrowth.

By implementing ACH, we can create a robust and adaptive collective strategy that promotes cooperation while responding to various opponent behaviors.
'''

description_COLLECTIVE_286 = '''
I'll outline a collective strategy for the Common Pool Resource Game that is adaptive and robust to various opponent behaviors.

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Rounds**: In the first few rounds (specifically, rounds 1 to `n/2`, where `n` is the number of players), play Cooperate (`C`). This allows us to gauge the initial stock level and observe other players' behavior.
2. **Stock-dependent Cooperation**: If the current stock level is above a certain threshold (`θ`), play Cooperate (`C`). This threshold will be adjusted dynamically based on the game's history (see below). The intuition is that if the stock is plentiful, we can afford to cooperate and conserve resources for future rounds.
3. **Defection Trigger**: If the current stock level falls below `θ`, or if a certain number of players (`δ`) have defected in the previous round, play Defect (`D`). This trigger helps us respond to over-exploitation by other players and avoid being taken advantage of.
4. **Stock Recovery**: If the stock level has increased significantly since the last round (by more than `Δ`), play Cooperate (`C`) again. This encourages recovery of the stock when it's depleted.

**Threshold Adjustment**:

* Initially, set `θ = capacity / 2`, where `capacity` is the maximum sustainable stock level.
* After each round, adjust `θ` based on the game's history:
	+ If most players (more than `n/2`) cooperated and the stock level increased, decrease `θ` by a small amount (`ε`).
	+ If many players defected and the stock level decreased, increase `θ` by `ε`.

**Pseudocode:**
```python
def ACC(n, capacity, r):
    θ = capacity / 2
    δ = n / 4
    Δ = capacity / 10
    ε = capacity / 100

    for t in range(r):
        if t < n/2:
            action = C  # Cooperate initially
        else:
            stock_level = get_current_stock()
            num_defectors_prev_round = count_defectors(t-1)

            if stock_level > θ and num_defectors_prev_round < δ:
                action = C  # Cooperate if stock is plentiful and few defected previously
            elif stock_level <= θ or num_defectors_prev_round >= δ:
                action = D  # Defect if stock is depleted or many defected previously

            if stock_level - get_previous_stock() > Δ:
                action = C  # Recover stock when it's depleted

        update_θ(θ, ε)

    return action
```
**Collective Mindset:**

The ACC strategy aligns with a collective mindset by:

* Initially cooperating to gauge the game's dynamics and other players' behavior.
* Responding to over-exploitation by defecting when necessary, but also recovering cooperation when the stock level increases.
* Dynamically adjusting the threshold (`θ`) based on the game's history to balance individual interests with collective conservation goals.

By using a combination of stock-dependent cooperation, defection triggers, and adaptive threshold adjustment, ACC aims to achieve a robust and collective strategy that balances individual payoffs with the need for resource conservation.
'''

description_COLLECTIVE_287 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** Adaptive Stock Conservation (ASC)

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to avoid over-extraction and establish a conservative tone.
2. **Stock Thresholds**: Define two stock thresholds:
	* `low_threshold` = 0.5 * capacity
	* `high_threshold` = 0.8 * capacity

These thresholds will guide our adaptive behavior.

3. **Adaptive Decision-Making**:

a. If the current stock is above `high_threshold`, play Defect (D) to exploit the abundant resource, but with a cautious approach:
	+ Calculate the average consumption of all players in the previous round (`avg_consumption_prev`).
	+ If `avg_consumption_prev` is greater than or equal to 0.75 * stock/n, play Cooperate (C) instead, to avoid over-extraction.

b. If the current stock is between `low_threshold` and `high_threshold`, play Cooperate (C) to conserve the resource and promote sustainability.

c. If the current stock is below `low_threshold`, play Defect (D) to maximize individual payoff in a depleted environment.

4. **Response to Opponent Behavior**: Monitor the average consumption of all players in the previous round (`avg_consumption_prev`).
	+ If `avg_consumption_prev` is greater than or equal to 0.75 * stock/n, increase the likelihood of playing Cooperate (C) by 20% in the next round.
	+ Otherwise, decrease the likelihood of playing Cooperate (C) by 10% in the next round.

**Edge Cases:**

1. **Last Round**: In the final round, play Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Tie-breaking**: If multiple actions have equal expected payoffs, choose Cooperate (C) to prioritize sustainability.

**Collective Mindset:**
The ASC strategy aims to balance individual self-interest with collective conservation of the common pool resource. By adapting to various opponent behaviors and stock levels, we promote sustainable extraction while maintaining competitiveness.

Pseudocode:
```markdown
# Initialize variables
low_threshold = 0.5 * capacity
high_threshold = 0.8 * capacity

# First round
if current_round == 1:
    action = Cooperate (C)

# Adaptive decision-making
else:
    if stock > high_threshold:
        # Exploit abundant resource cautiously
        avg_consumption_prev = calculate_average_consumption()
        if avg_consumption_prev >= 0.75 * stock/n:
            action = Cooperate (C)
        else:
            action = Defect (D)

    elif low_threshold <= stock <= high_threshold:
        # Conserve resource and promote sustainability
        action = Cooperate (C)

    else:  # Stock below low threshold
        # Maximize individual payoff in depleted environment
        action = Defect (D)

# Adjust strategy based on opponent behavior
avg_consumption_prev = calculate_average_consumption()
if avg_consumption_prev >= 0.75 * stock/n:
    increase_cooperation_likelihood(20%)
else:
    decrease_cooperation_likelihood(10%)

# Last round
if current_round == r:
    action = Defect (D)
```
This strategy is designed to be robust and adaptive, handling a wide range of opponent behaviors while prioritizing collective conservation and sustainability.
'''

description_COLLECTIVE_288 = '''
To design a collective strategy for this Common Pool Resource Game, I'll introduce "Adaptive Cooperation with Stock-Dependent Threshold" (ACSDT). This strategy balances individual interests with collective sustainability, adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a positive tone and gather information about opponents' behaviors.
2. **Stock-Dependent Threshold:** Set a dynamic threshold `θ` based on the current stock level `S`. When `S` is above `θ`, cooperate; otherwise, defect.

    `θ = capacity / (2 * n) * (1 + (r - t) / r)`
    
    Here, `t` is the current round number. As rounds progress (`t` increases), the threshold `θ` decreases, making cooperation more stringent.
3. **Opponent Behavior Adaptation:** Observe opponents' actions in previous rounds and adjust the strategy accordingly.

    a. If most opponents (more than `n/2`) cooperated in the previous round, cooperate in the current round.
    
    b. If most opponents defected, defect in the current round.
4. **Punishment Mechanism:** Implement a mild punishment for opponents who consistently defect.

    a. Identify "defectors" as those who have defected more than `n/3` times in previous rounds.
    
    b. When interacting with a defector, cooperate only if the stock level is above `θ * 1.2`. This ensures some cooperation while not rewarding excessive defection.

**Edge Cases:**

* **Last Round:** Cooperate (C) in the last round (`t = r`) to maintain a positive final state.
* **Extreme Stock Levels:**
	+ If `S` is very low (`S < capacity / (4 * n)`), cooperate to allow stock growth.
	+ If `S` is near maximum (`S > 3/4 * capacity`), defect to harvest the abundant resource.

**Collective Mindset Alignment:**

ACSDT prioritizes cooperation when the collective benefit is high and adapts to opponents' behaviors. By considering both individual interests and collective sustainability, this strategy promotes a balanced approach, making it more likely for other players to cooperate as well.

By implementing ACSDT, our AI system will be able to adapt to various opponent strategies while promoting a cooperative atmosphere, increasing the chances of achieving mutually beneficial outcomes in the Common Pool Resource Game tournament.
'''

description_COLLECTIVE_289 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock-Sensitive Cooperation (ATSC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline and encourage cooperation.
2. **Subsequent Rounds:** Observe the previous round's actions and outcomes:
	* If the stock level decreased, Defect (D) if most players defected (> n/2) in the previous round; otherwise, Cooperate (C).
	* If the stock level increased or remained stable, Cooperate (C) if most players cooperated (≥ n/2) in the previous round; otherwise, Defect (D).
3. **Stock-Sensitive Cooperation:** Adjust cooperation based on the current stock level:
	* If the stock level is low (< capacity / 2), Cooperate (C) to conserve resources.
	* If the stock level is high (≥ capacity / 2), Defect (D) if most players defected (> n/2) in the previous round; otherwise, Cooperate (C).
4. **Opponent Detection:** Identify "defector" opponents who consistently play D, and respond with Defect (D) to minimize losses.
5. **Self-Protection:** If own payoff is consistently low (< average payoff of all players), switch to Defect (D) for one round to signal dissatisfaction.

**Edge Cases:**

1. **Last Round:** Cooperate (C) if the stock level is high (≥ capacity / 2); otherwise, Defect (D).
2. **Tiebreakers:** In cases where decisions depend on "most players" cooperating or defecting, use a random tiebreaker to avoid deterministic behavior.
3. **Initial Stock Depletion:** If the initial stock level is significantly low (< capacity / 4), Cooperate (C) for the first few rounds to allow stock replenishment.

**Collective Mindset:**

1. **Cooperation is Default:** Prioritize cooperation unless evidence suggests widespread defection or significant stock depletion.
2. **Adaptation over Punishment:** Adjust strategy based on observed behavior, rather than punishing individual opponents.
3. **Stock Conservation:** Balance short-term gains with long-term sustainability by conserving resources when necessary.

**Pseudocode:**
```python
def ATSC(n, capacity, history):
    # Initialize cooperation flag
    cooperate = True
    
    # Check initial round or low stock level
    if (round == 1) or (stock < capacity / 2):
        return C
    
    # Analyze previous round's actions and outcomes
    prev_round_defections = count_defectors(history[-1])
    if (prev_round_defections > n/2) and (stock_decreased(history)):
        cooperate = False
    elif (prev_round_defections <= n/2) and (stock_increased_or_stable(history)):
        cooperate = True
    
    # Stock-sensitive cooperation
    if stock < capacity / 2:
        cooperate = True
    elif stock >= capacity / 2 and prev_round_defections > n/2:
        cooperate = False
    
    # Opponent detection and self-protection
    if (own_payoff < average_payoff(history)) or (detected_defector(history)):
        cooperate = False
    
    return C if cooperate else D
```
This strategy balances cooperation, adaptation, and robustness to perform well in a wide range of opponent behaviors.
'''

description_COLLECTIVE_290 = '''
I'll outline a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and focuses on long-term sustainability of the resource.

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline of cooperation and encourage others to follow suit.
2. **Stock-dependent Cooperation**: If the current stock level is above 75% of capacity, cooperate (C). This ensures that when the resource is abundant, players conserve it for future rounds.
3. **Defection Response**: If at least one player defected in the previous round and the current stock level is below 50% of capacity, defect (D) to avoid being taken advantage of. This response mechanism deters opponents from repeatedly exploiting the resource.
4. **Adaptive Threshold Adjustment**: After each round, adjust the cooperation threshold based on the number of players who defected in the previous round:
	* If >50% of players defected, decrease the cooperation threshold by 10% (e.g., from 75% to 65%).
	* If ≤50% of players defected, increase the cooperation threshold by 5% (e.g., from 75% to 80%).
5. **Last Round**: Defect (D) in the final round, as there is no future benefit to conserving the resource.

**Pseudocode:**
```
function ACC(current_stock, capacity, num_players, history):
  if first_round:
    return C
  elif current_stock > 0.75 * capacity:
    return C
  elif any_defected(history[-1]) and current_stock < 0.5 * capacity:
    return D
  else:
    threshold = adjust_threshold(history)
    if current_stock > threshold * capacity:
      return C
    else:
      return D

function adjust_threshold(history):
  num_defectors = sum(defected for defected in history[-1])
  if num_defectors > 0.5 * num_players:
    return threshold - 0.1
  elif num_defectors <= 0.5 * num_players:
    return threshold + 0.05
```
**Collective Mindset Alignment:**

ACC prioritizes long-term sustainability and adaptability, considering both the current state of the resource and the actions of other players. By adjusting its cooperation threshold based on opponent behavior, ACC balances individual interests with collective well-being.

**Robustness to Opponent Behaviors:**

ACC is designed to handle various opponent strategies:

* **All Defectors**: ACC responds by defecting when the stock level falls below 50% capacity.
* **All Cooperators**: ACC adapts by increasing its cooperation threshold, ensuring that the resource remains sustainable.
* **Mixed Strategies**: ACC's adaptive threshold adjustment allows it to respond effectively to changing opponent behaviors.

ACC is a robust and collective strategy that balances individual interests with long-term sustainability of the common pool resource.
'''

description_COLLECTIVE_291 = '''
To design a collective strategy for this Common Pool Resource Game, we'll aim to balance individual payoffs with the long-term sustainability of the common pool. Our strategy, "Adaptive Collective Conservation" (ACC), will adapt to the game's state and history while promoting cooperation.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperative behavior and encourage others to do the same.
2. **Stock Level Monitoring**: Track the current stock level (S) and the total consumption from the previous round. If S is below 0.5 * capacity, defect (D) to maximize individual payoff. Otherwise, proceed to step 3.
3. **Opponent Behavior Analysis**: Observe the actions of other players in the previous round. If at least half of the opponents cooperated (C), cooperate (C) in the current round. This encourages cooperation and helps maintain a healthy stock level.
4. **Stock Growth Expectation**: Estimate the expected stock growth based on the remaining stock after consumption and the game's parameters. If the expected growth is less than 0.2 * capacity, defect (D) to secure individual payoffs. Otherwise, cooperate (C).
5. **Recent Payoff Analysis**: Monitor your own recent payoffs. If your average payoff over the last three rounds is below the average payoff of all players, defect (D) in the current round to improve your individual position.

**Pseudocode:**
```python
def ACC(current_stock, previous_actions, previous_payoffs):
    # Initial Round
    if current_round == 1:
        return COOPERATE

    # Stock Level Monitoring
    if current_stock < 0.5 * capacity:
        return DEFECT

    # Opponent Behavior Analysis
    opponents_cooperated = sum([action == COOPERATE for action in previous_actions]) / len(previous_actions)
    if opponents_cooperated >= 0.5:
        return COOPERATE

    # Stock Growth Expectation
    expected_growth = estimate_stock_growth(current_stock, capacity)
    if expected_growth < 0.2 * capacity:
        return DEFECT

    # Recent Payoff Analysis
    recent_payoffs = [payoff for payoff in previous_payoffs[-3:]]
    average_recent_payoff = sum(recent_payoffs) / len(recent_payoffs)
    all_players_average_payoff = sum([payoff for payoff in previous_payoffs]) / len(previous_payoffs)
    if average_recent_payoff < all_players_average_payoff:
        return DEFECT

    # Default to cooperation
    return COOPERATE
```
**Edge Cases:**

* In the last round, defect (D) to maximize individual payoffs, as there is no future stock to conserve.
* If an opponent consistently defects (D), adapt by increasing the threshold for cooperating in step 3 to encourage more cooperation.

By following the ACC strategy, players aim to maintain a sustainable common pool while balancing their individual interests. This collective approach promotes cooperation and adapts to various opponent behaviors, making it robust in a tournament setting.
'''

description_COLLECTIVE_292 = '''
I'll design a collective strategy for this Common Pool Resource Game that adapts to various opponent behaviors and game states.

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to establish a cooperative tone and avoid over-exploitation.
2. **Subsequent Rounds**: Observe the previous round's actions and outcomes.
	* If the stock level is above 75% of capacity, cooperate (C).
	* If the stock level is between 50% and 75% of capacity, play a mixed strategy:
		+ Cooperate (C) with probability p = (stock level / capacity)^2
		+ Defect (D) with probability 1 - p
	* If the stock level is below 50% of capacity, defect (D).
3. **Last Round (t=r)**: Defect (D), as there's no future impact on the game.

**Edge Cases:**

1. **Low Stock Levels**: When the stock level falls below 25% of capacity, cooperate (C) to avoid depletion.
2. **Opponent Exploitation**: If an opponent consistently defects (D), mirror their behavior by also defecting (D).
3. **Consecutive Cooperative Outcomes**: After three consecutive rounds with cooperative outcomes, temporarily increase the cooperation probability p by 20% for one round.

**Pseudocode:**
```
function ACC(stock_level, capacity, t, r):
    if t == 1:
        return C
    else:
        prev_stock = get_prev_stock_level()
        if stock_level >= 0.75 * capacity:
            return C
        elif 0.5 <= stock_level / capacity < 0.75:
            p = (stock_level / capacity)^2
            return random_choice(C, D, [p, 1-p])
        else:
            return D
    if t == r:
        return D

def get_prev_stock_level():
    # retrieve previous round's stock level from game history

function random_choice(options, probabilities):
    # implement a weighted random choice function
```

**Collective Mindset:**
The ACC strategy prioritizes cooperation when the common pool is sufficiently stocked and adapts to varying opponent behaviors. By balancing individual interests with collective well-being, ACC promotes sustainable resource management.

This strategy should perform well against various independent strategies in the tournament, as it:

* Avoids over-exploitation by cooperating initially
* Adapts to changing game states and opponent actions
* Balances cooperation and self-interest
* Handles edge cases effectively

Please let me know if you'd like me to clarify or expand on any aspects of this strategy.
'''

description_COLLECTIVE_293 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACS)**

ACS is a dynamic, state-dependent strategy that balances individual payoff maximization with collective sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a baseline stock level and encourage cooperation.
2. **Subsequent Rounds**:
	* If the current stock level `S` is above a threshold `T`, cooperate (C). The threshold `T` is calculated as `T = capacity / 2`.
	* If the current stock level `S` is below or equal to the threshold `T`, defect (D) with probability `p`. The probability `p` is calculated based on the number of rounds remaining and the current stock level:
		+ `p = 0.5 * (1 - S / capacity)` if there are more than 2 rounds remaining.
		+ `p = 0.8 * (1 - S / capacity)` if there are exactly 2 rounds remaining.
		+ `p = 1` in the last round ( defect with certainty).
3. **Opponent Behavior Adaptation**: Monitor opponent actions and adjust the probability of defection `p` based on their behavior:
	* If an opponent defects, increase `p` by 0.1 for that opponent.
	* If an opponent cooperates, decrease `p` by 0.1 for that opponent.

**Pseudocode:**
```python
def ACS(n, capacity, stock, history):
    # Initial round
    if len(history) == 0:
        return "C"

    # Subsequent rounds
    T = capacity / 2
    if stock > T:
        return "C"
    else:
        p = calculate_defection_probability(stock, capacity, n)
        if random.random() < p:
            return "D"
        else:
            return "C"

def calculate_defection_probability(stock, capacity, rounds_remaining):
    # Adjust probability based on opponent behavior
    opponent_behavior = analyze_opponent_actions(history)
    for opponent in opponent_behavior:
        if opponent_behavior[opponent] == "D":
            p += 0.1
        elif opponent_behavior[opponent] == "C":
            p -= 0.1

    # Base probability calculation
    if rounds_remaining > 2:
        return 0.5 * (1 - stock / capacity)
    elif rounds_remaining == 2:
        return 0.8 * (1 - stock / capacity)
    else:
        return 1
```
**Collective Mindset:**
ACS is designed to balance individual payoff maximization with collective sustainability of the common pool resource. By cooperating when the stock level is above a certain threshold, ACS promotes cooperation and helps maintain a healthy stock level. When the stock level falls below the threshold, ACS adapts by increasing the probability of defection, allowing players to adjust their behavior in response to changes in the game state.

By monitoring opponent behavior and adjusting the probability of defection accordingly, ACS encourages opponents to cooperate and avoids escalating conflicts that might lead to mutual defection. In the last round, ACS defects with certainty to maximize individual payoffs.

**Robustness:**
ACS is robust against a wide range of opponent behaviors because it:

1. Adapts to changes in the game state (stock level) and adjusts its behavior accordingly.
2. Monitors opponent actions and adjusts its probability of defection based on their behavior.
3. Defects with certainty in the last round to maximize individual payoffs.

**Tournament Performance:**
ACS is designed to perform well in a tournament setting, where players face various opponents with different strategies. Its adaptability and robustness make it an effective strategy for maximizing collective and individual payoffs in the Common Pool Resource Game.
'''

description_COLLECTIVE_294 = '''
To design a collective strategy for this Common Pool Resource Game, I'll outline a decision rule that balances individual payoffs with collective sustainability, while adapting to varying opponent behaviors.

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rule:**

1. **Initial Round (t=1):**
	* Cooperate (C) if the initial stock is at or near capacity.
	* This encourages early cooperation and sets a positive tone for collective conservation.
2. **Middle Rounds (1 < t < r-1):**
	* Evaluate the current stock level (S) relative to capacity:
		+ If S ≥ 0.75 × capacity, Cooperate (C).
		+ If S ≤ 0.25 × capacity, Defect (D).
		+ Otherwise (0.25 × capacity < S < 0.75 × capacity), use a probabilistic approach based on the opponent's previous actions:
			- Estimate the proportion of opponents who defected in the last round (p_defect).
			- Cooperate with probability (1 - p_defect) and Defect with probability p_defect.
3. **Last Round (t=r):**
	* If the stock level is critically low (S ≤ 0.25 × capacity), Defect (D) to maximize individual payoff.
	* Otherwise, Cooperate (C) to maintain collective sustainability.

**Additional Considerations:**

* Monitor opponent behavior and adjust the probability of cooperation in middle rounds accordingly.
* If an opponent consistently defects, adapt by increasing the likelihood of defecting in subsequent rounds.
* Keep track of the game's history to inform decisions about when to cooperate or defect.

Pseudocode for ACC strategy:
```python
def adaptive_collective_conservation(stock, capacity, round_num, total_rounds, opponents_actions):
    if round_num == 1: # Initial Round
        return "C" if stock >= 0.9 * capacity else "D"
    
    elif 1 < round_num < total_rounds - 1: # Middle Rounds
        p_defect = estimate_proportion_defected(opponents_actions)
        if stock >= 0.75 * capacity:
            return "C"
        elif stock <= 0.25 * capacity:
            return "D"
        else:
            cooperate_prob = 1 - p_defect
            return "C" with probability cooperate_prob, otherwise "D"
    
    else: # Last Round
        if stock <= 0.25 * capacity:
            return "D"
        else:
            return "C"

def estimate_proportion_defected(opponents_actions):
    # Implement a simple method to estimate the proportion of opponents who defected in the last round
    # This can be based on observed actions or more sophisticated analysis
    pass
```
This ACC strategy balances individual payoffs with collective sustainability by adapting to varying opponent behaviors and the current state of the game. By cooperating when the stock is high and defecting when it's critically low, ACC promotes a balance between short-term gains and long-term conservation of the common pool resource.

**Collective Mindset:**
ACC aligns with the collective mindset by:

* Encouraging cooperation in early rounds to establish a positive tone for collective conservation.
* Adapting to opponent behavior to promote cooperation when others are cooperative, and defecting when others are exploitative.
* Prioritizing collective sustainability over individual gains in middle rounds.

**Robustness:**
ACC is robust against various opponent strategies as it:

* Adapts to changing opponent behavior using a probabilistic approach.
* Responds to the current state of the game (stock level and round number).
* Balances individual payoffs with collective sustainability.
'''

description_COLLECTIVE_295 = '''
**Collective Strategy: Adaptive Cooperation with Dynamic Threshold (ACDT)**

The ACDT strategy aims to balance individual payoffs with collective sustainability by dynamically adjusting the cooperation threshold based on game state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Subsequent Rounds**: Calculate the current stock level as a fraction of the capacity (S_remaining/capacity). If this ratio is above a dynamic threshold (dT), cooperate; otherwise, defect.

The dynamic threshold dT is updated every round based on the previous rounds' outcomes:

dT = (1 - (total_consumption / (2n \* capacity))) \* 0.5 + (S_remaining / capacity) \* 0.5

This formula incorporates two components:
	* The first term penalizes high total consumption, encouraging cooperation when opponents are over-harvesting.
	* The second term adjusts the threshold based on the current stock level, making cooperation more likely when the stock is low.

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round, as there's no future benefit to cooperation.
2. **Stock Depletion**: If the stock falls below a certain fraction of the capacity (e.g., 10%), always cooperate to ensure some growth and prevent complete depletion.

**Collective Mindset:**

The ACDT strategy aligns with the collective mindset by:

1. Encouraging cooperation when opponents are likely to cooperate, promoting mutual benefits.
2. Gradually adjusting the cooperation threshold based on opponents' behaviors, adapting to changing game dynamics.
3. Prioritizing stock sustainability over individual short-term gains.

**Pseudocode:**

```
function ACDT(n, capacity, r, current_round, stock_level, history):
  if current_round == 1:
    return COOPERATE
  else:
    S_remaining = stock_level
    total_consumption = calculate_total_consumption(history)
    dT = (1 - (total_consumption / (2n * capacity))) * 0.5 + (S_remaining / capacity) * 0.5
    
    if S_remaining / capacity > dT:
      return COOPERATE
    else:
      return DEFECT

function calculate_total_consumption(history):
  # Calculate total consumption based on previous rounds' actions and payoffs
  # ...
```

This strategy is designed to be adaptive, robust, and collective-minded, making it suitable for a tournament against independent AI systems.
'''

description_COLLECTIVE_296 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Tit-for-Tat (ASBT)**

**Decision Rules:**

1. **First Round:** Cooperate (C) to establish a baseline and encourage cooperation.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play Tit-for-Tat (TFT): cooperate if most players cooperated in the previous round, defect otherwise.
	* If the current stock level is below 50% of capacity, defect (D) to maximize individual payoff.
3. **Last Round:** Defect (D) to maximize individual payoff, as there are no future rounds to consider.

**Pseudocode:**
```
function ASBT(stock, history, n, capacity):
  if current_round == 1:
    return C
  else:
    stock_level = stock / capacity
    if stock_level > 0.75:
      return C
    elif stock_level >= 0.5 and stock_level <= 0.75:
      previous_cooperations = count(C in history[-1])
      if previous_cooperations >= n/2:
        return C
      else:
        return D
    else:
      return D

function play_ASBT(game_state):
  ASBT_result = ASBT(game_state.stock, game_state.history, game_state.n, game_state.capacity)
  if current_round == last_round:
    return D
  else:
    return ASBT_result
```
**Rationale:**

1. **Initial Cooperation:** Starting with cooperation encourages other players to cooperate and establishes a baseline for future interactions.
2. **Stock-Based Decision Making:** The strategy adapts to the current stock level, balancing individual payoffs with collective sustainability.
3. **Tit-for-Tat (TFT):** In the middle range of stock levels, TFT encourages cooperation while retaliating against defectors, promoting a stable and cooperative environment.
4. **Defection in Low Stock Levels:** When the stock level is critically low, defecting ensures individual payoffs are maximized, even if it means depleting the resource.

**Collective Mindset:**

The ASBT strategy prioritizes cooperation when the collective resource is abundant, ensuring a sustainable and mutually beneficial environment. As the resource becomes scarce, the strategy adapts to balance individual interests with collective well-being. By playing TFT in the middle range of stock levels, ASBT promotes cooperation while discouraging exploitation.

**Robustness:**

ASBT is designed to be robust against various opponent behaviors:

* **Cooperative opponents:** ASBT will cooperate and maintain a high stock level.
* **Defective opponents:** ASBT will adapt and defect when necessary to protect individual payoffs.
* **Mixed strategies:** ASBT's TFT component allows it to respond effectively to mixed cooperative and defective behaviors.

By combining adaptive decision-making with a collective mindset, the ASBT strategy is well-suited for a tournament environment where diverse opponent behaviors are expected.
'''

description_COLLECTIVE_297 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Aware Tit-for-Tat (ACSTAT)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a cooperative tone and maximize initial payoffs.
2. **Subsequent Rounds:**
	* If the stock level is above 75% of capacity, cooperate (C).
	* If the stock level is between 50% and 75% of capacity, play Tit-for-Tat (TFT): cooperate if most players cooperated in the previous round; otherwise, defect.
	* If the stock level is below 50% of capacity, defect (D) to minimize losses.

**Edge Cases:**

1. **Last Round:** Defect (D), as there are no future rounds to consider.
2. **Stock Depletion:** If the stock level falls to 0, cooperate in the next round to allow for growth and potential recovery.

**Collective Mindset:**

ACSTAT prioritizes cooperation when the stock is abundant, ensuring long-term sustainability. As the stock declines, ACSTAT adapts by introducing Tit-for-Tat, which promotes reciprocity and encourages others to cooperate. When the stock is severely depleted, ACSTAT defects to minimize losses, but still allows for potential recovery.

**Pseudocode:**

```
function ACSTAT(stock_level, capacity, history):
  if round == 1:
    return COOPERATE
  elif stock_level >= 0.75 * capacity:
    return COOPERATE
  elif stock_level >= 0.5 * capacity and stock_level < 0.75 * capacity:
    previous_cooperation_rate = calculate_cooperation_rate(history)
    if previous_cooperation_rate > 0.5:
      return COOPERATE
    else:
      return DEFECT
  else:
    return DEFECT

function calculate_cooperation_rate(history):
  # Calculate the proportion of players who cooperated in the previous round
  # This can be done by analyzing the history of actions and payoffs
```

**Rationale:**

ACSTAT balances individual self-interest with collective well-being. By cooperating when the stock is abundant, ACSTAT promotes long-term sustainability. As the stock declines, ACSTAT's adaptive nature helps maintain cooperation through Tit-for-Tat, while also allowing for defecting to minimize losses when necessary. This strategy should perform well against a variety of opponents and game conditions.
'''

description_COLLECTIVE_298 = '''
**Collective Strategy: "Adaptive Stock Sensitive Tit-for-Tat" (ASST)**

**Overview**

The ASST strategy aims to balance individual payoff maximization with collective stock sustainability. It adapts to the game's dynamic state and opponent behaviors, promoting cooperation while responding to defection.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to encourage collective cooperation and establish a baseline for subsequent rounds.
2. **Stock Thresholds**: Define two stock thresholds:
	* `low_stock_threshold` = capacity / 4
	* `high_stock_threshold` = capacity * 3/4

**Main Logic**

For each round t, calculate the current stock level (S) and total consumption in the previous round (if applicable). Then:

1. **High Stock**: If S ≥ high_stock_threshold:
	* Cooperate (C) if most opponents cooperated (> n/2) in the previous round.
	* Defect (D) otherwise.
2. **Low Stock**: If S ≤ low_stock_threshold:
	* Defect (D) to minimize personal loss, as cooperation is unlikely to be reciprocated.
3. **Middle Ground**: If low_stock_threshold < S < high_stock_threshold:
	* Cooperate (C) if most opponents cooperated (> n/2) in the previous round and total consumption was relatively low (< capacity / 2).
	* Defect (D) otherwise.

**Edge Cases**

1. **Last Round**: In the final round, defect (D) to maximize individual payoff, as there is no future cooperation to consider.
2. **Opponent Defection**: If an opponent defects in a previous round, defect in the next round to punish them and signal that cooperation is required for mutual benefit.

**Pseudocode**

```python
def ASST(n, capacity, history):
    # Initialize variables
    low_stock_threshold = capacity / 4
    high_stock_threshold = capacity * 3/4

    # Main logic
    current_stock = get_current_stock()
    if current_stock >= high_stock_threshold:
        opponents_cooperated = count_cooperators(history[-1]) > n/2
        return 'C' if opponents_cooperated else 'D'
    elif current_stock <= low_stock_threshold:
        return 'D'
    else:  # Middle ground
        opponents_cooperated = count_cooperators(history[-1]) > n/2
        total_consumption = calculate_total_consumption(history[-1])
        return 'C' if opponents_cooperated and total_consumption < capacity / 2 else 'D'

    # Edge cases
    if is_last_round():
        return 'D'
    elif opponent_defected(history):
        return 'D'
```

**Collective Mindset**

The ASST strategy prioritizes cooperation when the stock level is high, recognizing that mutual cooperation leads to higher payoffs. When the stock level is low, it adapts by defecting to minimize individual loss. By responding to opponent behavior and adapting to changing stock levels, ASST promotes a collective mindset that balances individual interests with the need for sustainable resource management.

This strategy is robust to various opponent behaviors, including pure cooperators, pure defectors, and mixed strategies. Its adaptability ensures it remains competitive in a tournament setting where diverse strategies are present.
'''

description_COLLECTIVE_299 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC aims to balance individual payoffs with collective sustainability by adapting to the game's dynamic state and opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to encourage initial stock conservation and set a positive tone.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 25% and 75% of capacity:
		+ If the average opponent payoff in the previous round was higher than your own, Defect (D) to catch up.
		+ Otherwise, Cooperate (C) to maintain a balance.
	* If the current stock level is below 25% of capacity, Defect (D) to maximize individual payoffs before the game ends.

**Edge Cases:**

1. **Last Round (t=r):** Always Defect (D), as there's no future benefit to conserving the stock.
2. **Low Stock Levels:** If the current stock level is critically low (< 10% of capacity), Defect (D) to secure any remaining payoff.

**Adaptive Component:**

ASC incorporates an adaptive component by considering the average opponent payoff in the previous round. This allows the strategy to adjust its behavior based on the opponents' actions and maintain a balance between individual payoffs and collective sustainability.

**Pseudocode:**
```python
def ASC(stock, capacity, n, t, r, history):
    if t == 1:
        return C  # Cooperate in the first round
    
    avg_opponent_payoff = calculate_average_opponent_payoff(history)
    
    if stock > 0.75 * capacity:
        return C  # Cooperate when stock is high
    elif 0.25 * capacity <= stock <= 0.75 * capacity:
        if avg_opponent_payoff > my_previous_payoff:
            return D  # Defect to catch up
        else:
            return C  # Cooperate to maintain balance
    else:
        return D  # Defect when stock is low

def calculate_average_opponent_payoff(history):
    opponent_payoffs = [payoff for payoff in history if payoff != my_previous_payoff]
    return sum(opponent_payoffs) / len(opponent_payoffs)

def my_previous_payoff(history):
    return history[-1][my_index]
```
**Collective Mindset:**
ASC prioritizes collective sustainability by cooperating when the stock level is high and adapting to opponents' behaviors to maintain a balance. By doing so, ASC promotes a mutually beneficial environment where individual payoffs are maximized while ensuring the game's long-term viability.

This strategy should perform well in a tournament setting against independent strategies, as it balances individual interests with collective sustainability and adapts to various opponent behaviors.
'''

description_COLLECTIVE_300 = '''
To address this challenge, I'll introduce a collective strategy that balances individual self-interest with the long-term sustainability of the common pool resource (CPR). This approach, dubbed "Adaptive CPR Harmony" (ACPH), incorporates insights from game theory, adaptive dynamics, and collective decision-making.

**Decision Rules:**

1. **Initial Exploration (Round 1-3):**
Cooperate (C) in the first three rounds to gather information about other players' behaviors and the CPR's resilience.
2. **Adaptive Cooperation Threshold (ACT):**
After Round 3, calculate an ACT based on the average stock level over the last three rounds (`avg_stock_last_3_rounds`). If `avg_stock_last_3_rounds` is above a certain threshold (e.g., 0.7 * capacity), cooperate; otherwise, defect.
3. **Stock-Dependent Cooperation:**
If the current stock level (`current_stock`) is below a certain fraction of the capacity (e.g., 0.4 * capacity), cooperate to help replenish the CPR. This helps prevent catastrophic depletion and promotes long-term sustainability.
4. **Opponent Behavior Adaptation:**
Observe opponents' actions in previous rounds and adjust your strategy accordingly:
	* If most opponents (>50%) cooperated in the last round, increase the likelihood of cooperating in the next round by 10%.
	* If most opponents (>50%) defected in the last round, decrease the likelihood of cooperating in the next round by 10%.
5. **Self-Protection Mechanism:**
If your total payoff over the last three rounds is below a certain threshold (e.g., 0.5 * average_payoff_per_round), defect to prevent excessive exploitation.

**Pseudocode:**
```python
def Adaptive_CPR_Harmony(current_stock, avg_stock_last_3_rounds, opponents_actions):
    # Initial Exploration
    if current_round <= 3:
        return COOPERATE

    # Adaptive Cooperation Threshold (ACT)
    ACT = 0.7 * capacity
    if avg_stock_last_3_rounds >= ACT:
        return COOPERATE

    # Stock-Dependent Cooperation
    if current_stock < 0.4 * capacity:
        return COOPERATE

    # Opponent Behavior Adaptation
    opponents_cooperated = sum(opponents_actions) / len(opponents_actions)
    if opponents_cooperated > 0.5:
        cooperation_likelihood += 0.1
    elif opponents_cooperated < 0.5:
        cooperation_likelihood -= 0.1

    # Self-Protection Mechanism
    total_payoff_last_3_rounds = sum(my_payoffs_last_3_rounds)
    if total_payoff_last_3_rounds < 0.5 * average_payoff_per_round:
        return DEFECT

    # Final Decision
    return COOPERATE with probability cooperation_likelihood, else DEFECT
```
**Handling Edge Cases:**

* **Last Round:** If it's the last round (r), defect to maximize individual payoff.
* **First Round:** Cooperate as part of Initial Exploration.

This collective strategy balances short-term self-interest with long-term sustainability by:

1. Initially exploring opponents' behaviors and CPR resilience.
2. Adapting cooperation based on CPR stock levels and opponent actions.
3. Protecting against excessive exploitation through self-protection mechanisms.

By incorporating these elements, ACPH should perform well in a tournament setting against various independent strategies.
'''

description_COLLECTIVE_301 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Trigger**

Our collective strategy, dubbed "Adaptive Cooperation," aims to balance individual payoffs with the long-term sustainability of the common pool resource. The strategy relies on a dynamic trigger based on the current stock level and adapts to the opponent's behavior over time.

**Decision Rules:**

1. **Initial Rounds (t ≤ 2):**
	* Cooperate (C) if the current stock is above 75% of capacity.
	* Defect (D) otherwise.
2. **Subsequent Rounds (t > 2):**
	* Calculate the average opponent cooperation rate (AOCR) based on the last two rounds:
		+ AOCR = (# opponents who cooperated in last two rounds) / (2 \* # opponents)
	* If the current stock is above 50% of capacity and AOCR ≥ 0.5, Cooperate (C).
	* If the current stock is below 25% of capacity or AOCR < 0.3, Defect (D).
	* Otherwise, play a mixed strategy:
		- With probability 0.7, Cooperate (C) if the opponent's previous-round action was C, and Defect (D) otherwise.
		- With probability 0.3, Defect (D) regardless of the opponent's previous action.

**Edge Cases:**

* **Last Round (t = r):**
	+ If the current stock is above 75% of capacity, Cooperate (C).
	+ Otherwise, Defect (D).
* **Tiebreakers:**
	+ In cases where multiple actions have the same expected payoff, choose Cooperate (C) if the opponent's previous-round action was C.

**Collective Mindset:**

Our strategy is designed to promote cooperation while protecting against exploitation. By cooperating when the stock level is high and adapting to opponents' behavior, we aim to create a mutually beneficial environment. If opponents defect excessively, our strategy will respond with defection to prevent over-exploitation of the common resource.

**Pseudocode:**
```python
def adaptive_cooperation(stock, capacity, t, opponent_history):
    # Initial rounds
    if t <= 2:
        if stock >= 0.75 * capacity:
            return 'C'
        else:
            return 'D'

    # Calculate AOCR
    aocr = sum(opponent_history[-2:]) / (2 * len(opponent_history))

    # Subsequent rounds
    if stock >= 0.5 * capacity and aocr >= 0.5:
        return 'C'
    elif stock < 0.25 * capacity or aocr < 0.3:
        return 'D'
    else:
        # Mixed strategy
        if random.random() < 0.7:
            if opponent_history[-1] == 'C':
                return 'C'
            else:
                return 'D'
        else:
            return 'D'

# Last round
if t == r:
    if stock >= 0.75 * capacity:
        return 'C'
    else:
        return 'D'
```
This strategy is designed to be robust against a wide range of opponent behaviors and promotes cooperation while protecting the common resource.
'''

description_COLLECTIVE_302 = '''
**Collective Strategy: "Adaptive Stock Preservation" (ASP)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for stock preservation and encourage cooperation.
2. **Stock Threshold**: If the current stock level is below 75% of the capacity, Defect (D). This ensures that if the stock is critically low, players prioritize their own payoff.
3. **Opponent Behavior Analysis**:
	* Observe the opponent's actions in previous rounds and calculate the frequency of cooperation (FC) and defection (FD).
	* If FC > FD, Cooperate (C) to maintain a cooperative environment.
	* If FC < FD, Defect (D) to protect against exploitation.
4. **Recent Stock Trend**: Analyze the stock level changes over the last 2-3 rounds. If the stock has been decreasing rapidly (>25% decline), Defect (D). This helps prevent further depletion.

**Edge Cases:**

1. **Last Round**: Cooperate (C) in the final round, as there is no future benefit to defecting.
2. **Tiebreakers**: In cases where decision rules conflict or are tied (e.g., FC = FD), prioritize cooperation (C).
3. **Stock Saturation**: If the stock reaches 100% capacity, Cooperate (C) to prevent over-consumption.

**Collective Mindset:**

The ASP strategy is designed to balance individual self-interest with collective well-being by:

1. Encouraging initial cooperation to establish a cooperative environment.
2. Adapting to opponent behavior to avoid exploitation and promote cooperation.
3. Prioritizing stock preservation when the resource is critically low or declining rapidly.

**Pseudocode:**
```python
def Adaptive_Stock_Preservation(n, capacity, r, current_stock):
  # Initial Round
  if round == 1:
    return C

  # Stock Threshold
  if current_stock < 0.75 * capacity:
    return D

  # Opponent Behavior Analysis
  FC = opponent_cooperation_frequency()
  FD = opponent_defection_frequency()
  if FC > FD:
    return C
  elif FC < FD:
    return D

  # Recent Stock Trend
  recent_stock_trend = analyze_recent_stock_changes(2-3 rounds)
  if recent_stock_trend == 'rapid_decline':
    return D

  # Last Round
  if round == r:
    return C

  # Tiebreakers and Default
  return C
```
This strategy aims to achieve a balance between individual payoffs and collective stock preservation, making it robust against various opponent behaviors in the tournament.
'''

description_COLLECTIVE_303 = '''
**Collective Strategy: "Adaptive Stock Sensitive Tit-for-Tat with Cooperation Boost"**

This strategy is designed to balance individual payoff maximization with collective sustainability of the common pool resource. It adapts to changing stock levels and opponent behaviors while promoting cooperation.

**Decision Rules:**

1. **First Round:** Cooperate (C) unconditionally to establish a cooperative tone and gather information about opponents' initial actions.
2. **Subsequent Rounds:** Evaluate the current state (stock level, previous rounds' payoffs, and opponents' actions). Use the following logic:
	* If stock level is above 75% of capacity: Cooperate (C) with probability p = 0.8 + (0.2 \* average opponent cooperation rate in the last round).
	* If stock level is between 50% and 75% of capacity: Defect (D) with probability p = 0.5 - (0.1 \* average opponent cooperation rate in the last round). Otherwise, Cooperate (C).
	* If stock level is below 50% of capacity: Defect (D) unconditionally to maximize individual payoff.
3. **Tit-for-Tat Component:** Observe opponents' actions in the previous round and adjust your action accordingly:
	+ If an opponent defected in the previous round, defect (D) with probability p = 0.7 + (0.3 \* average opponent cooperation rate in the last round).
	+ If an opponent cooperated in the previous round, cooperate (C) with probability p = 0.9 - (0.1 \* average opponent defection rate in the last round).

**Cooperation Boost:**

* After every 5 rounds, evaluate the average stock level over those rounds.
* If the average stock level is above 60% of capacity, increase the cooperation probability by 10% for the next 5 rounds.

**Edge Cases:**

* **Last Round:** Defect (D) unconditionally to maximize individual payoff, as there are no future consequences.
* **Low Stock Levels:** If the stock level falls below 20% of capacity, defect (D) unconditionally to avoid a complete collapse of the common pool resource.

Pseudocode:
```python
def strategy(stock_level, previous_rounds, opponents_actions):
    # First round: Cooperate unconditionally
    if len(previous_rounds) == 0:
        return 'C'

    # Evaluate current state and adjust probabilities
    avg_cooperation_rate = calculate_average_cooperation_rate(opponents_actions)
    if stock_level > 0.75 * capacity:
        p = 0.8 + (0.2 * avg_cooperation_rate)
        return 'C' with probability p
    elif stock_level >= 0.5 * capacity and stock_level <= 0.75 * capacity:
        p = 0.5 - (0.1 * avg_cooperation_rate)
        if random.random() < p:
            return 'D'
        else:
            return 'C'
    else:  # Stock level below 50%
        return 'D'

    # Tit-for-Tat component
    opponent_actions_last_round = get_opponent_actions_last_round(opponents_actions)
    for action in opponent_actions_last_round:
        if action == 'D':
            p = 0.7 + (0.3 * avg_cooperation_rate)
            return 'D' with probability p
        elif action == 'C':
            p = 0.9 - (0.1 * calculate_average_defection_rate(opponents_actions))
            return 'C' with probability p

    # Cooperation boost
    if len(previous_rounds) % 5 == 0:
        avg_stock_level_last_5_rounds = calculate_average_stock_level_last_5_rounds(stock_level, previous_rounds)
        if avg_stock_level_last_5_rounds > 0.6 * capacity:
            increase_cooperation_probability_by_10_percent()

    return 'D'  # Default action
```
This strategy aims to balance individual self-interest with collective sustainability by adapting to changing stock levels and opponent behaviors. The cooperation boost mechanism encourages cooperation when the common pool resource is healthy, while the tit-for-tat component responds to opponents' actions to maintain fairness.
'''

description_COLLECTIVE_304 = '''
I'll design a collective strategy that adapts to various opponent behaviors and optimizes for long-term payoffs. I'll call this strategy "Adaptive Collective Harvesting" (ACH).

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and gather information about opponents' behavior.
2. **Stock-Based Cooperation:** If the current stock level is above 75% of the capacity, cooperate (C). This ensures sustainable harvesting while allowing for some flexibility in case of unexpected opponent actions.
3. **Defection Threshold:** If the current stock level falls below 50% of the capacity, defect (D) to maximize short-term payoffs. This threshold helps prevent over-harvesting and promotes more cautious behavior when the stock is depleted.
4. **Opponent Behavior Adaptation:** Monitor the average opponent action (C or D) in the previous round. If the majority (>50%) of opponents defected, defect (D) in the current round to avoid being exploited. Otherwise, cooperate (C).
5. **Recent Stock Trend:** Analyze the stock level changes over the last three rounds. If the stock has been decreasing steadily, cooperate (C) to help replenish it. If the stock has been increasing or stable, defect (D) to take advantage of the current abundance.

**Pseudocode:**
```markdown
function ACH(current_stock, capacity, n, round_number, previous_opponent_actions):
  if round_number == 1:
    return C  # Cooperate in the first round

  stock_ratio = current_stock / capacity
  if stock_ratio > 0.75:
    return C  # Stock-Based Cooperation
  elif stock_ratio < 0.5:
    return D  # Defection Threshold

  opponent_defection_rate = average_opponent_action(previous_opponent_actions)
  if opponent_defection_rate > 0.5:
    return D  # Opponent Behavior Adaptation
  else:
    return C

  recent_stock_trend = analyze_stock_trend(last_three_rounds)
  if recent_stock_trend == "decreasing":
    return C  # Recent Stock Trend
  elif recent_stock_trend in ["increasing", "stable"]:
    return D

return ACH(current_stock, capacity, n, round_number, previous_opponent_actions)
```
**Edge Cases:**

* Last Round: Cooperate (C) to ensure a positive final payoff and maintain a sustainable stock level.
* Low Stock Levels (<25% of capacity): Defect (D) to maximize short-term payoffs, as the game is likely near its end.

**Collective Mindset:**
ACH prioritizes cooperation when possible, while adapting to opponents' behavior and the current state of the stock. By doing so, it promotes a balance between individual payoffs and collective sustainability, making it a robust strategy for a wide range of opponent behaviors.
'''

description_COLLECTIVE_305 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** Adaptive Cooperation with Stock Sensitivity (ACSS)

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Stock-dependent Cooperation:** If the current stock is above 75% of the capacity, cooperate (C). This ensures that when the stock is plentiful, players contribute to its sustainability.
3. **Defection Threshold:** If the current stock is below 25% of the capacity, defect (D) to maximize individual payoff in a depleted environment.
4. **Adaptive Response:** For stock levels between 25% and 75% of the capacity:
	* If the previous round's total consumption was above 50% of the capacity, cooperate (C) to help replenish the stock.
	* Otherwise, defect (D) to take advantage of the relatively high stock level.

**Edge Cases:**

1. **Last Round:** Defect (D) in the final round to maximize individual payoff, as there are no future rounds to consider.
2. **Tie-breaking:** In cases where the decision rules lead to a tie (e.g., exactly 50% of players cooperated in the previous round), cooperate (C) to maintain a cooperative stance.

**Collective Mindset:**

ACSS is designed to balance individual self-interest with collective sustainability. By adapting to the stock level and opponent behavior, this strategy promotes cooperation when it benefits both individual and group outcomes. The decision rules are simple, yet effective in responding to various scenarios:

* When the stock is abundant, ACSS cooperates to maintain a healthy stock level.
* When the stock is depleted, ACSS defects to maximize individual payoff.
* In intermediate cases, ACSS responds adaptively based on previous consumption patterns.

**Pseudocode:**
```python
def ACSS(stock, capacity, history):
    if round == 1:
        return C  # Initial cooperation
    elif stock > 0.75 * capacity:
        return C  # Stock-dependent cooperation
    elif stock < 0.25 * capacity:
        return D  # Defection threshold
    else:  # Adaptive response
        prev_consumption = sum(history[-1])
        if prev_consumption > 0.5 * capacity:
            return C  # Replenish stock
        else:
            return D  # Take advantage of high stock level
    if round == r:  # Last round
        return D  # Maximize individual payoff
```
This strategy is designed to be robust and adaptive, making it a strong contender in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_306 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe other players' behavior.
2. **Subsequent Rounds**: Defect (D) if:
	* The current stock level is below 50% of the capacity (i.e., S < 0.5 \* capacity).
	* At least one player defected in the previous round.
	* The total consumption in the previous round exceeded 75% of the stock (i.e., Total Consumption > 0.75 \* Previous Stock).

Otherwise, Cooperate (C) if:
	* The current stock level is above or equal to 50% of the capacity.
	* No player defected in the previous round.
	* The total consumption in the previous round was below or equal to 75% of the stock.

**Additional Conditions:**

1. **Last Round**: Cooperate (C) in the last round if the current stock level is above 25% of the capacity; otherwise, Defect (D).
2. **Low Stock Warning**: If the current stock level falls below 10% of the capacity, Defect (D) to prevent depletion.
3. **Cooperation Threshold**: Adjust the cooperation threshold dynamically based on the history of players' actions:
	* Increase the threshold by 5% if at least 50% of players cooperated in the previous round.
	* Decrease the threshold by 5% if more than 50% of players defected in the previous round.

**Pseudocode:**
```
Function ACH(n, capacity, current_stock, history):
  // Initial Round
  If round == 1:
    Return C

  // Subsequent Rounds
  If current_stock < 0.5 * capacity Or (any player defected in previous round) Or (total consumption > 0.75 * previous stock):
    Return D
  Else If current_stock >= 0.5 * capacity And no player defected in previous round And total consumption <= 0.75 * previous stock:
    Return C

  // Last Round
  If round == r:
    If current_stock > 0.25 * capacity:
      Return C
    Else:
      Return D

  // Low Stock Warning
  If current_stock < 0.1 * capacity:
    Return D

  // Cooperation Threshold Adjustment
  cooperation_threshold = (cooperation_threshold + 5%) if (at least 50% of players cooperated in previous round)
  cooperation_threshold = (cooperation_threshold - 5%) if (more than 50% of players defected in previous round)

Return C if current_stock > cooperation_threshold; Else Return D
```
**Collective Mindset:**

The ACH strategy prioritizes collective well-being and sustainability by:

1. Cooperating when the stock level is sufficient to support all players.
2. Defecting only when necessary to prevent depletion or punish non-cooperative behavior.
3. Dynamically adjusting the cooperation threshold based on player behavior.

This adaptive approach allows the strategy to respond effectively to a wide range of opponent behaviors while promoting collective interests and avoiding over-harvesting.
'''

description_COLLECTIVE_307 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and focuses on maintaining a sustainable stock level while maximizing payoffs.

**Strategy Name:** Adaptive Sustainability (AS)

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) with probability 0.5, Defect (D) with probability 0.5.
	* This allows AS to explore the opponents' behavior and gather information for future rounds.
2. **Subsequent Rounds (t>1):**
	* Observe the current stock level (S), the number of cooperators (C_count), and defectors (D_count) in the previous round.
	* Calculate the average payoff per player in the previous round (avg_payoff).
	* If S > 0.5 \* capacity, AS will:
		+ Cooperate if avg_payoff ≥ S/(2n) or C_count ≥ n/2.
		+ Defect otherwise.
	* If S ≤ 0.5 \* capacity, AS will:
		+ Cooperate if C_count ≥ n/4 and avg_payoff ≥ S/n.
		+ Defect otherwise.

**Pseudocode:**
```python
def adaptive_sustainability(S, t, C_count, D_count, avg_payoff):
    if t == 1:
        return random.choice([C, D])  # Explore opponents' behavior

    if S > 0.5 * capacity:
        if avg_payoff >= S / (2 * n) or C_count >= n / 2:
            return C
        else:
            return D
    else:
        if C_count >= n / 4 and avg_payoff >= S / n:
            return C
        else:
            return D
```

**Edge Cases:**

* **Last Round (t=r):**
	+ AS will Defect to maximize payoff, as the game is ending.
* **Low Stock Levels (S < capacity/10):**
	+ AS will Cooperate to help replenish the stock and maintain sustainability.

**Collective Mindset:**

AS focuses on maintaining a sustainable stock level while adapting to various opponent behaviors. By cooperating when the stock level is high or when there are enough cooperators, AS promotes collective welfare and encourages others to cooperate as well. When the stock level is low, AS prioritizes replenishing it by cooperating.

**Tournament Performance:**

AS should perform well in a tournament against independent strategies, as it:

* Adapts to various opponent behaviors
* Maintains sustainability while maximizing payoffs
* Encourages cooperation when beneficial for collective welfare
'''

description_COLLECTIVE_308 = '''
I propose a collective strategy called "Adaptive Stock Conservation" (ASC). ASC aims to balance individual payoffs with the long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) if the stock is at or above 75% of the capacity; otherwise, play Defect (D).
2. **Subsequent Rounds**:
	* If the previous round's total consumption was ≤ 50% of the capacity and the current stock is ≥ 75% of the capacity, play C.
	* If the previous round's total consumption was > 50% of the capacity or the current stock is < 75% of the capacity, play D if your previous action was C; otherwise, play C.
3. **Critical Stock Levels**:
	* If the current stock falls below 25% of the capacity, always play Defect (D).
	* If the current stock rises above 90% of the capacity, always play Cooperate (C).

Pseudocode for the decision rules:

```
function ASC(stock, previous_total_consumption, previous_action) {
    if round == 1 {
        if stock >= 0.75 * capacity {
            return C
        } else {
            return D
        }
    }

    if previous_total_consumption <= 0.5 * capacity && stock >= 0.75 * capacity {
        return C
    }

    if (previous_action == C) || (stock < 0.25 * capacity) {
        return D
    } else {
        return C
    }
}
```

**Rationale:**

ASC combines the following principles:

1. **Initial cooperation**: Starting with cooperation sets a positive tone and allows for a moderate level of consumption while maintaining a healthy stock.
2. **Adaptive response**: ASC responds to changes in total consumption and current stock levels, adjusting its behavior to maintain sustainability or take advantage of opportunities.
3. **Stock conservation**: By prioritizing cooperation when the stock is above 75% of capacity and defecting below 25%, ASC balances individual payoffs with long-term resource management.

**Collective Mindset:**

ASC aligns with a collective mindset by:

1. **Avoiding over-exploitation**: By conserving the stock, ASC helps maintain a sustainable common pool resource.
2. **Promoting cooperation**: ASC encourages cooperation when conditions are favorable, fostering a cooperative atmosphere.
3. **Adapting to opponents' behavior**: By responding to changes in total consumption and current stock levels, ASC remains competitive while promoting collective well-being.

ASC is designed to be robust against various opponent strategies, as it adapts to the dynamics of the game and prioritizes both individual payoffs and long-term sustainability.
'''

description_COLLECTIVE_309 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)**

**Overview**

ACSDT is a collective strategy that balances individual payoffs with collective sustainability by adapting to the current stock level and opponent behavior. The strategy aims to cooperate when the stock is abundant and defect when it's scarce, while also considering the history of opponent actions.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation.
2. **Stock-Dependent Threshold**: Define a threshold stock level (`T`) as a function of the current stock (`S`), capacity (`capacity`), and number of players (`n`):

`T = S - (capacity / (2 * n))`

3. **Cooperation Condition**: Cooperate (C) if:
	* The current stock (`S`) is above the threshold (`T`): `S > T`
	* At least one opponent cooperated in the previous round
4. **Defection Condition**: Defect (D) otherwise

**Pseudocode**
```python
def ACSDT(stock, capacity, n, history):
    # Initial round: Cooperate
    if len(history) == 0:
        return C
    
    # Calculate threshold stock level
    T = stock - (capacity / (2 * n))
    
    # Check cooperation condition
    if stock > T and any(opponent_action == C for opponent_action in history[-1]):
        return C
    
    # Defect otherwise
    return D
```
**Edge Cases**

* **Last Round**: Cooperate (C) in the last round to maximize collective payoff, as there's no future benefit from defecting.
* **Low Stock**: When the stock is very low (`S < capacity / (2 * n)`), defect (D) to ensure a minimal individual payoff.

**Collective Mindset**

ACSDT prioritizes cooperation when the stock is abundant and opponents have cooperated in the past, promoting collective sustainability. By adapting to the current stock level and opponent behavior, ACSDT balances individual payoffs with collective well-being.
'''

description_COLLECTIVE_310 = '''
I'll outline a collective strategy for this Common Pool Resource Game that adapts to various opponent behaviors and aligns with a collective mindset. I call it "Adaptive Stock Harmony" (ASH).

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round, as there's no history to adapt from.
2. **Early Rounds**: For rounds 2 to r/4 (where r is the total number of rounds), observe the opponent's actions and calculate their average cooperation rate. If this rate is above a threshold (e.g., 0.5), cooperate; otherwise, defect.
3. **Mid-Game Adaptation**: After round r/4, use the following adaptive logic:
	* If the current stock level is above capacity/2, cooperate with probability P(C) = (current_stock/capacity)^2.
	* If the current stock level is below capacity/2, defect with probability P(D) = 1 - P(C).
4. **Endgame**: In the last r/4 rounds, prioritize conservation:
	* If the current stock level is above capacity/2, cooperate (C).
	* If the current stock level is below capacity/2 and the number of remaining rounds is odd, defect (D); otherwise, cooperate.

**Pseudocode:**
```python
def ASH(n, r, capacity, history):
    if r == 1:  # Initial round
        return C

    avg_coop_rate = calculate_average_cooperation_rate(history)
    if r < r/4:
        if avg_coop_rate > 0.5:
            return C
        else:
            return D

    current_stock = get_current_stock_level()
    if current_stock > capacity/2:
        P_C = (current_stock/capacity)^2
        return C with probability P_C, otherwise D
    else:
        P_D = 1 - P_C
        return D with probability P_D, otherwise C

    # Endgame logic
    if r < r/4 and current_stock > capacity/2:
        return C
    elif r < r/4 and current_stock < capacity/2 and (r % 2 == 1):
        return D
    else:
        return C
```
**Rationale:**

* By cooperating in the initial round, ASH encourages others to cooperate as well.
* In early rounds, observing opponents' actions allows ASH to adapt its strategy based on their cooperation rate.
* Mid-game adaptation helps maintain a balance between consumption and stock conservation. The probability of cooperation increases with the current stock level, ensuring that players conserve resources when necessary.
* In the endgame, prioritizing conservation ensures that the collective outcome is optimized.

**Collective Mindset:**

ASH aligns with a collective mindset by:

* Cooperating in situations where opponents are likely to cooperate
* Adapting its strategy based on opponent behavior and stock levels
* Prioritizing conservation when necessary

By using ASH, players can collectively manage the common pool resource while adapting to various opponent behaviors.
'''

description_COLLECTIVE_311 = '''
**Collective Strategy: Adaptive Common Pool Conservation (ACPC)**

The ACPC strategy aims to balance individual payoffs with collective sustainability by adaptively adjusting cooperation levels based on game parameters, state, and history.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if the stock level is close to capacity (> 0.8 \* capacity).
	* Defect (D) otherwise.
2. **Middle Rounds (1 < t < r-1):**
	* Calculate the average stock growth rate over the past rounds: `growth_rate = (stock[t] - stock[1]) / (t - 1)`
	* If `growth_rate` is positive and the current stock level is above a threshold (`0.5 * capacity`):
		+ Cooperate if at least half of the opponents cooperated in the previous round.
		+ Defect otherwise.
	* If `growth_rate` is negative or the current stock level is below the threshold:
		+ Defect if more than half of the opponents defected in the previous round.
		+ Cooperate otherwise.
3. **Last Round (t=r):**
	* Cooperate if the current stock level is above a higher threshold (`0.8 * capacity`).
	* Defect otherwise.

**Edge Cases:**

1. **Opponent Behavior:** If an opponent's behavior is consistently cooperative or defective, adjust the decision rule accordingly:
	+ If an opponent always cooperates, cooperate as well.
	+ If an opponent always defects, defect as well.
2. **Stock Level Extremes:**
	* If the stock level reaches `0`, always cooperate to encourage growth.
	* If the stock level reaches `capacity`, always defect to maximize payoffs.

**Pseudocode (simplified for readability):**
```python
def ACPC(stock, capacity, history, t):
    if t == 1:  # Initial round
        return C if stock > 0.8 * capacity else D

    growth_rate = (stock - history[1]) / (t - 1)
    prev_coops = sum(opponent.cooperated for opponent in history[t-1])

    if growth_rate > 0 and stock > 0.5 * capacity:
        return C if prev_coops >= len(history[t-1]) // 2 else D
    elif growth_rate < 0 or stock < 0.5 * capacity:
        return D if sum(opponent.defected for opponent in history[t-1]) > len(history[t-1]) // 2 else C

    # Last round
    return C if stock > 0.8 * capacity else D
```
This strategy balances individual payoffs with collective sustainability by:

1. Encouraging cooperation when the stock level is high and growth rate is positive.
2. Defecting when opponents are defecting or the stock level is low to prevent over-exploitation.
3. Cooperating in the last round if the stock level is still high.

By being adaptive and robust, ACPC should perform well against a variety of opponent strategies in the tournament.
'''

description_COLLECTIVE_312 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

**Overview**
Adaptive Cooperation is a collective strategy that balances individual self-interest with collective sustainability. It adapts to the game's state and history, promoting cooperation while being robust against exploitation.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoffs.
2. **Subsequent Rounds**: Use the following logic:
	* If the current stock is above 75% of capacity, cooperate (C).
	* If the current stock is between 25% and 75% of capacity, play a mixed strategy:
		+ Cooperate with probability p = (current stock / capacity) × (1 - (total consumption in previous round / capacity)).
		+ Defect with probability 1 - p.
	* If the current stock is below 25% of capacity, defect (D).

**Rationale**

* When the stock is high, cooperation ensures a stable and sustainable resource, maximizing collective payoffs.
* When the stock is moderate, the mixed strategy balances individual self-interest with collective sustainability. As the stock decreases, the probability of cooperating decreases, and vice versa.
* When the stock is low, defection becomes necessary to maximize individual payoffs, as cooperation would lead to minimal gains.

**Edge Cases**

* **Last Round**: Defect (D) in the last round, as there is no future benefit to cooperation.
* **Opponent Deviation**: If an opponent deviates from cooperation, adapt by increasing the probability of defection in subsequent rounds. Specifically:
	+ Monitor opponents' actions and maintain a "defection count" for each opponent.
	+ For each opponent with a high defection count (>50%), increase the probability of defection against them.

**Collective Mindset**
The Adaptive Cooperation strategy prioritizes collective sustainability while being mindful of individual self-interest. By adapting to the game's state and history, AC promotes cooperation when beneficial and defects when necessary, ensuring a robust performance against various opponent behaviors.

Pseudocode:
```python
def adaptive_cooperation(stock, capacity, round_number, opponents_actions):
    if round_number == 1:  # Initial Round
        return "C"
    
    stock_ratio = stock / capacity
    
    if stock_ratio > 0.75:
        return "C"
    elif stock_ratio >= 0.25 and stock_ratio <= 0.75:
        p_coop = stock_ratio * (1 - total_consumption_previous_round / capacity)
        return "C" with probability p_coop, else "D"
    else:  # stock_ratio < 0.25
        return "D"

def update_defection_count(opponents_actions):
    # Monitor opponents' actions and update defection counts

def adjust_strategy(defection_counts):
    # Adapt strategy based on opponents' deviation from cooperation
```
Note that the pseudocode is a simplified representation of the strategy, and implementation details may vary.
'''

description_COLLECTIVE_313 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and aligns with a collective mindset:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline trust and maximize initial payoffs.
2. **Subsequent Rounds (t>1):**
	* If the previous round's stock level is above 75% of capacity, Cooperate (C). This promotes sustainable consumption and growth.
	* If the previous round's stock level is between 50% and 75% of capacity, play a mixed strategy:
		+ With probability p = (previous_round_stock / capacity)^2, Defect (D).
		+ Otherwise, Cooperate (C).
	* If the previous round's stock level is below 50% of capacity, Defect (D). This encourages players to reduce consumption and avoid depletion.
3. **Last Round (t=r):** Cooperate (C) if the current stock level is above 25% of capacity; otherwise, Defect (D).

**Additional Rules:**

* If a player observes another player consistently defecting (i.e., more than 75% of rounds), they will mirror that behavior in subsequent rounds.
* If a player notices a significant increase in stock levels over consecutive rounds (e.g., >20%), they will adjust their strategy to Cooperate (C) for the next round.

**Pseudocode:**
```python
def ACC(n, r, capacity, current_stock, history):
    if t == 1:
        return C
    else:
        prev_round_stock = history[-1][0]
        if prev_round_stock >= 0.75 * capacity:
            return C
        elif prev_round_stock >= 0.5 * capacity:
            p = (prev_round_stock / capacity) ** 2
            return D if random.random() < p else C
        else:
            return D

    # Last round handling
    if t == r:
        if current_stock >= 0.25 * capacity:
            return C
        else:
            return D

    # Mirroring and adjusting behavior
    for opponent in opponents:
        if opponent.defection_rate > 0.75:
            return D
    if stock_increase_over_time > 20%:
        return C
```
**Rationale:**

ACC balances individual self-interest with collective sustainability by:

1. Encouraging cooperation when the stock level is high, promoting growth and maximizing payoffs.
2. Adapting to decreasing stock levels by increasing defection probability, discouraging over-consumption.
3. Mirroring opponent behavior to avoid exploitation and maintain a stable environment.
4. Adjusting strategy in response to significant changes in stock levels.

This collective strategy should perform well against various independent strategies, promoting a sustainable common pool resource management while being robust to diverse opponent behaviors.
'''

description_COLLECTIVE_314 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with probability 0.7 and Defect (D) with probability 0.3. This initial randomness encourages exploration and avoids immediate exploitation.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 25% and 75% of the capacity, use a mixed strategy:
		+ Cooperate (C) with probability p = (current_stock / capacity)^2.
		+ Defect (D) with probability 1 - p.
	* If the current stock level is below 25% of the capacity, defect (D).

**Rationale:**

* In the initial round, a mix of cooperation and defection encourages exploration and avoids immediate exploitation.
* When the stock level is high (above 75%), cooperation is more likely to maintain the stock and avoid overexploitation.
* When the stock level is moderate (25-75%), the mixed strategy adapts to the current state. As the stock level decreases, the probability of cooperating increases, reflecting a more cautious approach.
* When the stock level is low (below 25%), defection becomes more likely, as the risk of overexploitation is lower.

**Edge Cases:**

* **Last Round (t=r):** Cooperate (C) if the current stock level is above 50% of the capacity; otherwise, defect (D). This ensures that the strategy prioritizes short-term gains in the final round while still considering the remaining stock.
* **Stock Level Near Zero:** If the current stock level is close to zero (e.g., < 1%), always cooperate (C) to avoid overexploitation and allow for potential growth.

**Collective Mindset:**

ACC aligns with a collective mindset by:

* Focusing on maintaining the common pool resource, ensuring its sustainability.
* Adapting to various opponent behaviors through the mixed strategy.
* Avoiding immediate exploitation in early rounds to promote cooperation and exploration.
* Prioritizing short-term gains only when necessary (e.g., last round).

**Pseudocode:**
```python
def ACC(n, r, capacity, stock_history):
    # Initial Round
    if len(stock_history) == 0:
        return random.choice([C, D], p=[0.7, 0.3])

    current_stock = stock_history[-1]
    stock_level = current_stock / capacity

    # Subsequent Rounds
    if stock_level >= 0.75:
        return C
    elif stock_level >= 0.25 and stock_level < 0.75:
        p = (current_stock / capacity) ** 2
        return random.choice([C, D], p=[p, 1 - p])
    else:
        return D

    # Last Round
    if len(stock_history) == r - 1:
        if stock_level >= 0.5:
            return C
        else:
            return D

    # Stock Level Near Zero
    if current_stock < 1:
        return C
```
This strategy will be implemented as an algorithm and compete in a tournament against other AI systems' strategies.
'''

description_COLLECTIVE_315 = '''
I propose a collective strategy called "Adaptive Stock Sensitive Tit-for-Tat with Exploration" (ASSTTE). This strategy aims to balance individual payoff maximization with collective sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Subsequent Rounds:** Observe the previous round's stock level and the actions of all players. Calculate the average payoff per player from the previous round.

**Tit-for-Tat Component:**

* If the average payoff per player in the previous round was above a certain threshold (e.g., 75% of the maximum possible payoff), cooperate (C) in the current round.
* Otherwise, defect (D).

**Adaptive Stock Sensitive Component:**

* Monitor the stock level over time. If the stock level falls below a certain threshold (e.g., 25% of the capacity), switch to cooperate (C) regardless of the previous round's payoffs.

**Exploration Component:**

* With a small probability (e.g., 5%), randomly choose an action (C or D) in each round. This allows for exploration of alternative strategies and adaptation to changing opponent behaviors.

Pseudocode:
```
ASSTTE Strategy

Inputs:
- n: number of players
- capacity: maximum sustainable stock level
- stock_history: list of previous stock levels
- payoff_history: list of average payoffs per player per round

Initialize:
- threshold_payoff = 0.75 \* max_payoff_per_player
- threshold_stock = 0.25 \* capacity
- exploration_prob = 0.05

Round t:

1. If t == 1 (first round):
   - action[t] = C
2. Else:
   - avg_payoff_prev_round = payoff_history[t-1]
   - stock_level_prev_round = stock_history[t-1]

   - If avg_payoff_prev_round >= threshold_payoff:
     - action[t] = C
   - Else if stock_level_prev_round < threshold_stock:
     - action[t] = C
   - Else:
     - action[t] = D

   - With probability exploration_prob:
     - action[t] = random_choice([C, D])

Return action[t]
```
**Edge Cases:**

* Last round: ASSTTE will choose an action based on the previous round's payoffs and stock level. If the stock level is critically low, it may cooperate to avoid depleting the resource.
* Ties in average payoff per player: In case of ties, ASSTTE will default to cooperating (C).

**Collective Mindset:**

ASSTTE aims to balance individual interests with collective sustainability by:

1. Encouraging cooperation when the average payoff is high or the stock level is critically low.
2. Allowing for exploration and adaptation to changing opponent behaviors.
3. Providing a clear, predictable strategy that can be understood by other players.

By adopting ASSTTE, players demonstrate a commitment to collective rationality while pursuing individual interests.
'''

description_COLLECTIVE_316 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC is a collective strategy that balances individual payoff maximization with stock conservation to ensure long-term sustainability. The strategy adapts to the game state and history, responding to opponents' actions while maintaining a cooperative mindset.

**Decision Rules:**

1. **Initial Rounds (t ≤ n):**
	* Cooperate (C) in the first round.
	* In subsequent initial rounds, observe the stock level after consumption. If the stock is above 75% of capacity, cooperate (C). Otherwise, defect (D).
2. **Middle Rounds (n < t < r - n):**
	* Assess the current stock level and opponents' actions:
		+ If the stock is below 50% of capacity or if more than half of opponents defected in the previous round, defect (D) to maximize short-term payoff.
		+ Otherwise, cooperate (C) to conserve the stock for future rounds.
3. **Final Rounds (t ≥ r - n):**
	* Cooperate (C) in the last round to avoid depleting the stock completely.
	* In preceding final rounds, if the stock is above 25% of capacity and fewer than half of opponents defected in the previous round, cooperate (C). Otherwise, defect (D).

**Edge Cases:**

1. **First Round:** Cooperate (C) to establish a cooperative tone and encourage others to follow suit.
2. **Last Round:** Cooperate (C) to ensure the stock is not depleted completely, promoting sustainability.
3. **Low Stock Levels:** If the stock falls below 25% of capacity at any point, defect (D) in subsequent rounds to maximize short-term payoff.

**Collective Mindset:**

ASC prioritizes cooperation when possible, while adapting to opponents' actions and the game state. By cooperating in initial rounds and responding to opponents' defections, ASC aims to maintain a healthy stock level and promote long-term sustainability. When necessary, ASC will defect to protect individual payoffs, but always with the goal of preserving the collective resource.

**Pseudocode:**

```python
def adaptive_stock_conservation(n, r, capacity, current_stock, opponent_actions):
    if t <= n:
        # Initial rounds
        if current_stock > 0.75 * capacity:
            return 'C'
        else:
            return 'D'

    elif n < t < r - n:
        # Middle rounds
        if current_stock < 0.5 * capacity or opponents_defected >= n / 2:
            return 'D'
        else:
            return 'C'

    else:
        # Final rounds
        if t == r - 1:
            return 'C'
        elif current_stock > 0.25 * capacity and opponents_defected < n / 2:
            return 'C'
        else:
            return 'D'
```

By employing ASC, our AI system will navigate the Common Pool Resource Game with a balanced approach, prioritizing cooperation while adapting to the dynamic game state and opponents' actions.
'''

description_COLLECTIVE_317 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACS-T)**

ACS-T is a dynamic, adaptive strategy that balances individual payoffs with collective sustainability. It uses a stock-based threshold to determine cooperation levels, ensuring the common pool resource remains viable throughout the game.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative baseline and encourage others to follow.
2. **Stock-Based Threshold**: Calculate the stock-based threshold `T` as a function of the current stock level `S` and capacity `c`: `T = c / (2 * n)`. If `S` is above `T`, cooperate (C); otherwise, defect (D).
3. **Adaptive Cooperation**: Adjust cooperation levels based on the previous round's outcomes:
	* If all players cooperated in the previous round, increase cooperation by 10% (`C_prob += 0.1`) to reinforce collective behavior.
	* If at least one player defected in the previous round, decrease cooperation by 20% (`C_prob -= 0.2`) to penalize non-cooperative behavior.
4. **Last Round**: Defect (D) in the last round to maximize individual payoffs, as there are no future rounds to consider.

**Pseudocode:**
```python
def ACS_T(n, c, S, history):
    # Initial Round
    if len(history) == 0:
        return C

    # Stock-Based Threshold
    T = c / (2 * n)
    if S > T:
        return C
    else:
        return D

    # Adaptive Cooperation
    prev_round_outcomes = history[-1]
    if all(prev_round_outcomes):
        C_prob += 0.1
    elif any(not outcome for outcome in prev_round_outcomes):
        C_prob -= 0.2

    # Last Round
    if len(history) == r - 1:
        return D

    # Default: Cooperate with probability C_prob
    return random.choices([C, D], weights=[C_prob, 1 - C_prob])
```
**Collective Mindset:** ACS-T prioritizes collective sustainability by:

* Encouraging cooperation in the initial round and when the stock level is high.
* Adapting to previous rounds' outcomes to promote cooperation and penalize defection.
* Balancing individual payoffs with collective sustainability through a dynamic threshold.

This strategy is robust to various opponent behaviors, as it adjusts its cooperation levels based on the current state and history of the game.
'''

description_COLLECTIVE_318 = '''
I'll design a collective strategy for this Common Pool Resource Game that adapts to various opponent behaviors and promotes long-term sustainability of the resource. I'll outline decision rules, handle edge cases, and emphasize collective alignment.

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Stock-dependent cooperation**: In subsequent rounds, cooperate if the current stock level is above a threshold (e.g., 75% of capacity). This ensures that when the resource is relatively abundant, players conserve it for future rounds.
3. **Opponent behavior adaptation**: Monitor the average payoff of opponents over the last few rounds (e.g., 3-5 rounds). If their payoffs are consistently higher than yours, switch to defecting (D) for a few rounds to "punish" them and adjust their strategy. This mechanism helps maintain fairness and deters exploitation.
4. **Stock growth encouragement**: When the stock level is low (e.g., below 25% of capacity), cooperate to allow the resource to recover. This promotes collective conservation when it's most needed.

Pseudocode:
```
def ACC(n, r, capacity):
    stock_threshold = 0.75 * capacity
    opponent_payoff_window = 3

    # Initial round: Cooperate
    if current_round == 1:
        return C

    # Stock-dependent cooperation
    if current_stock > stock_threshold:
        return C

    # Opponent behavior adaptation
    opponent_avg_payoffs = []
    for i in range(opponent_payoff_window):
        opponent_avg_payoffs.append(average_payoff_of_opponents(current_round - i))
    if average(opponent_avg_payoffs) > my_average_payoff:
        return D  # Punish opponents by defecting

    # Stock growth encouragement
    if current_stock < 0.25 * capacity:
        return C

    # Default to cooperation when uncertain
    return C
```
**Edge Cases:**

* **Last round**: In the final round, cooperate regardless of the stock level or opponent behaviors. This ensures that all players contribute to a sustainable conclusion.
* **Low stock levels**: When the stock is critically low (e.g., below 10% of capacity), cooperate unconditionally to prevent complete depletion.

**Collective Mindset:**

ACC promotes collective conservation by:

1. Encouraging cooperation when the resource is abundant, allowing for sustainable growth and long-term benefits.
2. Adapting to opponent behaviors, maintaining fairness and deterring exploitation.
3. Prioritizing stock recovery when it's low, ensuring that all players contribute to a sustainable outcome.

By implementing ACC, you'll create an adaptive strategy that balances individual interests with collective sustainability, promoting a cooperative atmosphere in the Common Pool Resource Game tournament.
'''

description_COLLECTIVE_319 = '''
**Collective Strategy: "Adaptive Stock Saver"**

The Adaptive Stock Saver (ASS) strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe others' behavior.
2. **Stock-based Cooperation Threshold**: Set a dynamic cooperation threshold, `τ`, based on the current stock level:
	* If `stock ≥ capacity / 2`, set `τ = 0.5` (more cooperative).
	* If `capacity / 4 ≤ stock < capacity / 2`, set `τ = 0.25` (less cooperative).
	* If `stock < capacity / 4`, set `τ = 0` ( defect).
3. **Defection Detection**: Monitor the average payoff of all players in the previous round (`avg_payoff_prev`). If `avg_payoff_prev > stock / (2n)`, it indicates potential defection by others. In this case, adjust `τ` downward by 0.1 to become less cooperative.
4. **Cooperation Incentive**: If at least half of the players cooperated in the previous round (`coop_count ≥ n/2`), increase `τ` by 0.1 to incentivize continued cooperation.
5. **Adaptive Defection**: With probability `(1 - τ)`, choose to defect (D). Otherwise, cooperate (C).

**Edge Cases:**

* In the last round, always defect (D) to maximize individual payoff.
* If `stock` is very low (`< capacity / 10`), prioritize stock growth by cooperating (C).
* If all players defected in the previous round (`coop_count = 0`), cooperate (C) to attempt to revive cooperation.

**Pseudocode:**
```python
def AdaptiveStockSaver(n, capacity, r, history):
    # Initialize variables
    τ = 0.5  # Cooperation threshold
    avg_payoff_prev = 0
    coop_count = 0

    for t in range(r):
        stock = history[t-1].stock if t > 0 else capacity

        # Update cooperation threshold based on stock level
        if stock >= capacity / 2:
            τ = 0.5
        elif capacity / 4 <= stock < capacity / 2:
            τ = 0.25
        else:
            τ = 0

        # Detect defection and adjust threshold
        avg_payoff_prev = sum(history[t-1].payoffs) / n if t > 0 else 0
        if avg_payoff_prev > stock / (2n):
            τ -= 0.1

        # Incentivize cooperation
        coop_count = sum(1 for p in history[t-1].actions if p == 'C') if t > 0 else 0
        if coop_count >= n/2:
            τ += 0.1

        # Adaptive defection
        action = 'D' if random.random() < (1 - τ) else 'C'

        # Edge cases
        if t == r-1:  # Last round, always defect
            action = 'D'
        elif stock < capacity / 10:  # Prioritize stock growth
            action = 'C'
        elif coop_count == 0:  # Attempt to revive cooperation
            action = 'C'

        yield action
```
This strategy adapts to the game's state and history, balancing individual payoffs with collective sustainability. By monitoring others' behavior and adjusting its cooperation threshold accordingly, ASS aims to promote cooperation while protecting against exploitation by defectors.
'''

description_COLLECTIVE_320 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Sensitive Defection (ACSSD)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and gather information about other players' behavior.
2. **Subsequent Rounds:** Calculate the current stock level (S) as a percentage of the capacity (%S = S/capacity).
3. **Cooperation Threshold:** If %S ≥ 0.7, cooperate (C). This threshold ensures that cooperation is maintained when the stock level is relatively high, promoting collective sustainability.
4. **Defection Trigger:** If %S < 0.7 and at least one player defected in the previous round, defect (D) with a probability p = (1 - %S)/0.3. This introduces an adaptive element, where the likelihood of defection increases as the stock level decreases.
5. **Stock-Sensitive Defection:** If %S < 0.4 and at least two players defected in the previous round, defect (D) with a higher probability p = (1 - %S)/0.2. This amplifies the defection response when the stock level is critically low and multiple players are exploiting it.
6. **Punishment:** If another player defects while you cooperate, reduce your cooperation threshold to 0.5 for one round. This introduces a mild punishment mechanism to deter exploitation.

**Edge Cases:**

1. **Last Round:** Cooperate (C) in the final round to maximize collective payoff and maintain a cooperative reputation.
2. **Tie-Breaking:** In cases where multiple strategies yield the same expected payoff, prioritize cooperation to promote collective sustainability.
3. **Single-Player Game:** If only one player remains, cooperate (C) to maximize individual payoff.

**Collective Mindset:**

1. **Adaptive Cooperation:** ACSSD adapts to changes in stock levels and opponent behavior, ensuring that cooperation is maintained when feasible and exploited players are deterred.
2. **Stock-Sensitive Defection:** By considering the current stock level and opponent behavior, ACSSD balances individual self-interest with collective sustainability.
3. **Robustness:** ACSSD's adaptive nature makes it robust to various opponent strategies, including all-defect, all-cooperate, and mixed-strategy approaches.

Pseudocode:
```
ACSSD(stock, capacity, history):
  // Initial round
  if (round == 1) return COOPERATE

  // Calculate stock percentage
  %S = stock / capacity

  // Cooperation threshold
  if (%S >= 0.7) return COOPERATE

  // Defection trigger
  if (%S < 0.7 && any_player_defected(history)):
    p = (1 - %S) / 0.3
    return DEFECTION with probability p

  // Stock-sensitive defection
  if (%S < 0.4 && multiple_players_defected(history)):
    p = (1 - %S) / 0.2
    return DEFECTION with probability p

  // Punishment
  if (another_player_defected(history) && self_cooperated):
    cooperation_threshold = 0.5 for one round

  // Default to cooperation
  return COOPERATE
```
ACSSD is a collective strategy that balances individual self-interest with collective sustainability, adapting to changes in stock levels and opponent behavior.
'''

description_COLLECTIVE_321 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Trigger (ACST)**

ACST is a dynamic strategy that balances individual interests with collective well-being by adapting cooperation levels based on the current stock level and historical player actions.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to encourage mutual cooperation and avoid initial depletion.
2. **Stock-Based Trigger:** For rounds 2 to r-1, calculate a stock threshold `S_th` as a fraction of the capacity:
	* `S_th = capacity * (0.5 + (r - t) / (2 * r))`
	where `t` is the current round number.
	* If the current stock level `S` exceeds `S_th`, cooperate (C). Otherwise, defect (D).
3. **Last Round:** Defect (D) in the final round to maximize individual payoff.

**Adaptive Component:**

1. **Opponent Behavior Monitoring:** Track the average cooperation rate of opponents over the last 2 rounds (`avg_opponent_coop`).
2. **Adjusting Cooperation Level:**
	* If `avg_opponent_coop > 0.5`, increase the stock threshold `S_th` by 10% to encourage cooperation.
	* If `avg_opponent_coop < 0.3`, decrease `S_th` by 10% to deter over-exploitation.

**Edge Case Handling:**

1. **Low Stock Levels:** If the current stock level falls below a critical threshold (`capacity / (2 * n)`), always defect (D) to avoid depleting the resource.
2. **High Stock Levels:** If the current stock level exceeds 90% of capacity, always cooperate (C) to encourage sustainable harvesting.

**Collective Mindset Alignment:**

ACST prioritizes cooperation when the stock level is above a dynamically adjusted threshold, ensuring that players contribute to maintaining a healthy common pool resource. By adapting to opponent behavior and adjusting cooperation levels accordingly, ACST promotes mutual cooperation while preventing over-exploitation. This strategy balances individual interests with collective well-being, making it robust against various opponent behaviors.

**Pseudocode:**
```python
def ACST(n, capacity, r, t, S):
  if t == 1:  # initial round
    return C
  elif t == r:  # last round
    return D
  
  S_th = capacity * (0.5 + (r - t) / (2 * r))
  
  if S > S_th:
    avg_opponent_coop = calculate_avg_opponent_coop()
    if avg_opponent_coop > 0.5:
      S_th *= 1.1
    elif avg_opponent_coop < 0.3:
      S_th *= 0.9
  
  if S < capacity / (2 * n):  # low stock level
    return D
  elif S > 0.9 * capacity:  # high stock level
    return C
  
  if S > S_th:
    return C
  else:
    return D
```
Note that this pseudocode serves as a conceptual representation of the strategy and will need to be implemented in an actual algorithm for tournament participation.
'''

description_COLLECTIVE_322 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Sensitive Defection (ACSSD)**

The ACSSD strategy aims to balance cooperation and defection while adapting to the game's dynamic state and history. This approach prioritizes collective well-being while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Rounds (t = 1, 2):** Cooperate (C) in the first two rounds to establish a baseline stock level and encourage cooperation among opponents.
2. **Stock-Dependent Defection:** Defect (D) when the current stock level falls below a threshold (`stock_threshold`), which is calculated as:

`stock_threshold = capacity / (2 * n + 1)`

This threshold ensures that if most players defect, the strategy will also defect to prevent over-exploitation. The `+1` term adds a buffer to account for potential deviations from expected behavior.

3. **Opponent-Triggered Defection:** If an opponent defects in the previous round (`opponent_defected_last_round`), and the current stock level is above the threshold, defect (D) in the current round. This rule responds to opponents' defections while maintaining adaptability.
4. **Default Cooperation:** Cooperate (C) by default when none of the above conditions are met.

**Edge Cases:**

1. **Last Round (t = r):** Defect (D) in the last round, as there's no future benefit from cooperation.
2. **First Round with Low Initial Stock:** If the initial stock level is below `stock_threshold`, defect (D) to prevent over-exploitation.

**Pseudocode:**
```python
def ACSSD(n, capacity, r, history):
    stock = get_current_stock()
    opponent_defected_last_round = False

    if r == 1 or r == 2:
        return C  # Cooperate in first two rounds

    if stock < (capacity / (2 * n + 1)):
        return D  # Defect when stock is low

    for opponent in history[-1]:
        if opponent.action == D:
            opponent_defected_last_round = True
            break

    if opponent_defected_last_round and stock >= (capacity / (2 * n + 1)):
        return D  # Defect in response to opponent's defection

    return C  # Default cooperation
```
**Collective Mindset:**
The ACSSD strategy is designed to prioritize collective well-being while being robust to various opponent behaviors. By cooperating initially and adapting to the game's dynamic state, this approach aims to maintain a sustainable stock level and encourage cooperation among opponents.

This strategy does not rely on coordination mechanisms or shared norms, making it suitable for playing against independent strategies developed by other AI systems in a tournament setting.
'''

description_COLLECTIVE_323 = '''
To design a collective strategy for this Common Pool Resource game, I propose the following adaptive and robust approach:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round**: In the first round, cooperate (C) to establish a baseline of cooperation and observe others' behaviors.
2. **Stock-based Cooperation**: If the current stock level is above 75% of the capacity, cooperate (C). This threshold encourages conservation when the resource is relatively abundant.
3. **Defection Response**: If at least one player defected in the previous round, defect (D) in the current round to avoid being exploited. However, if all players cooperated in the previous round and the stock level is still above 50% of the capacity, continue to cooperate (C).
4. **Stock Depletion Response**: If the current stock level falls below 25% of the capacity, cooperate (C) to conserve the remaining resource.
5. **Endgame Cooperation**: In the last two rounds, cooperate (C) regardless of the previous round's actions or stock levels. This promotes cooperation when the game is nearing its end.

**Pseudocode:**
```
function ACC(current_stock, previous_round_actions, round_number):
  if round_number == 1:
    return C
  elif current_stock > 0.75 * capacity:
    return C
  elif any(defected in previous_round_actions):
    return D
  elif all(cooperated in previous_round_actions) and current_stock > 0.5 * capacity:
    return C
  elif current_stock < 0.25 * capacity:
    return C
  elif round_number >= r - 2:  # last two rounds
    return C
```
**Rationale:**

* The initial cooperation in the first round sets a positive tone and encourages other players to cooperate.
* Stock-based cooperation promotes conservation when the resource is abundant, while adapting to exploitation by defecting when others do not cooperate.
* Defection response ensures that our strategy does not get exploited by repeated defectors.
* Stock depletion response prioritizes conservation when the resource is scarce.
* Endgame cooperation encourages cooperation in the final rounds, as the game's end is near and individual payoffs become less important.

**Collective Mindset:**
The ACC strategy aligns with a collective mindset by:

* Cooperating initially to establish trust
* Adapting to others' behaviors to maintain a balance between conservation and exploitation avoidance
* Prioritizing resource conservation when the stock level is low or in the endgame

This strategy should be robust against various opponent behaviors, as it adapts to their actions while promoting cooperation and resource conservation.
'''

description_COLLECTIVE_324 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Overview**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. It promotes cooperation when the stock is plentiful and defects when the stock is depleted, while also considering the actions of other players.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to signal a willingness to conserve the stock and encourage others to do the same.
2. **Subsequent Rounds**:
	* If the current stock level (`stock`) is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of the capacity, observe the actions of other players in the previous round:
		+ If at least half of the players cooperated, cooperate (C).
		+ Otherwise, defect (D).
	* If the current stock level is below 50% of the capacity, defect (D) to maximize individual payoff.
3. **Response to Opponent Actions**:
	* If a player defects while the stock is above 75% of the capacity, ASC will cooperate in the next round to try to restore cooperation.
	* If a player cooperates while the stock is below 50% of the capacity, ASC will defect in the next round to maximize individual payoff.

**Edge Cases**

1. **Last Round**: Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.
2. **Stock Depletion**: If the stock level falls below 25% of the capacity, ASC will defect (D) to ensure some payoff, even if it means depleting the stock further.

**Collective Mindset**

ASC prioritizes collective sustainability by cooperating when the stock is plentiful and adapting to the actions of other players. By promoting cooperation when possible and defecting when necessary, ASC aims to create a stable environment that benefits all players.

**Pseudocode**
```markdown
# Initialize variables
stock = capacity  # initial stock level
history = []  # store previous rounds' actions

# Main loop
for round in range(r):
    # Observe current stock level and history
    if stock > 0.75 * capacity:
        action = 'C'
    elif stock >= 0.5 * capacity:
        prev_round_actions = [a for a in history[-1] if a == 'C']
        if len(prev_round_actions) >= n / 2:
            action = 'C'
        else:
            action = 'D'
    else:
        action = 'D'

    # Update history and stock level
    history.append(action)
    consumption = sum([stock / (2 * n) if a == 'C' else stock / n for a in [action] + history[-1]])
    stock -= consumption

    # Apply growth formula
    growth = 2 * stock * (1 - stock / capacity)
    stock = min(stock + growth, capacity)

# Return total payoff
payoff = sum([stock / (2 * n) if action == 'C' else stock / n for action in history])
```
This strategy is designed to be robust and adaptive, responding to the game's state and history while promoting collective sustainability.
'''

description_COLLECTIVE_325 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACST)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoff.
2. **Stock-Dependent Threshold:** Calculate a dynamic threshold `τ` based on the current stock level (`S`) and capacity (`c`). Set `τ = S / c`.
3. **Cooperation Condition:** If `τ ≥ 0.5`, cooperate (C). This ensures that when the stock is relatively high, cooperation is more likely to maintain a sustainable stock level.
4. **Defection Condition:** If `τ < 0.5`, defect (D) with probability `p = (1 - τ) / (1 - 0.5)`. This introduces a gradual increase in defection likelihood as the stock depletes, allowing for adaptability to opponent behaviors.
5. **Opponent Observation:** Observe the previous round's actions of all opponents and update an internal estimate of their cooperation probabilities (`q_i`).
6. **Reactive Cooperation:** If the estimated cooperation probability of at least one opponent is above 0.8 (i.e., `max(q_i) > 0.8`), cooperate in the next round to reciprocate and maintain cooperation.

**Edge Cases:**

1. **Last Round:** Cooperate (C) in the final round, as there are no future rounds to influence.
2. **Low Stock:** If the stock level is critically low (`S < 0.2c`), defect (D) to maximize individual payoff in a potentially terminal state.

**Pseudocode:**
```python
def ACST(stock, capacity, num_players, round_num, opponent_actions):
    # Calculate dynamic threshold τ
    tau = stock / capacity
    
    # Initial round cooperation
    if round_num == 1:
        return 'C'
    
    # Cooperation condition
    if tau >= 0.5:
        return 'C'
    
    # Defection condition with probability p
    p = (1 - tau) / (1 - 0.5)
    if random.random() < p:
        return 'D'
    
    # Observe opponent actions and update cooperation probabilities q_i
    for i, action in enumerate(opponent_actions):
        if action == 'C':
            q[i] += 0.1
        else:
            q[i] -= 0.1
    
    # Reactive cooperation
    if max(q) > 0.8:
        return 'C'
    
    # Default to defection
    return 'D'
```
This strategy balances individual payoff maximization with collective sustainability by adapting to the current stock level and opponent behaviors. By cooperating when the stock is relatively high and defecting when it's low, ACST promotes a stable and resilient collective outcome.
'''

description_COLLECTIVE_326 = '''
To design a collective strategy for this Common Pool Resource Game, I'll introduce "Adaptive Collective Conservation" (ACC), a decision-making approach that balances individual payoffs with long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a cooperative baseline and encourage others to follow suit.
2. **Subsequent Rounds**: Use a hybrid approach based on the current stock level, previous rounds' outcomes, and opponents' behavior:
	* If the current stock is above 75% of capacity, cooperate (C).
	* If the current stock is between 50% and 75% of capacity, use a probabilistic approach: cooperate with probability p = (current_stock / capacity) ^ 2. This means that as the stock level decreases, the likelihood of cooperation increases.
	* If the current stock is below 50% of capacity, defect (D) to maximize individual payoff in the short term, but be prepared to switch back to cooperation if the stock starts recovering.
3. **Opponent Behavior Analysis**: Monitor opponents' actions and adjust the strategy accordingly:
	* If most opponents (> 50%) cooperate, maintain cooperation (C).
	* If most opponents (> 50%) defect, defect (D) to avoid being exploited.
4. **Last Round**: Defect (D), as there's no future benefit from cooperation.

**Edge Cases:**

1. **Low Stock Levels**: If the stock level drops below 25% of capacity, cooperate (C) unconditionally for the remainder of the game to try to recover the resource.
2. **High Stock Levels**: If the stock level exceeds 90% of capacity, defect (D) to maximize individual payoff without compromising the long-term sustainability of the resource.

**Collective Mindset:**

ACC aims to balance individual payoffs with collective conservation by:

1. Encouraging cooperation when the stock is plentiful.
2. Gradually increasing cooperation as the stock level decreases.
3. Responding to opponents' behavior to avoid exploitation.
4. Prioritizing short-term gains only when the resource is severely depleted.

**Pseudocode:**
```python
def adaptive_collective_conservation(current_stock, capacity, opponents_actions):
    # Initial Round
    if round == 1:
        return 'C'

    # Subsequent Rounds
    if current_stock > 0.75 * capacity:
        return 'C'
    elif current_stock >= 0.5 * capacity:
        p = (current_stock / capacity) ** 2
        return 'C' if random.random() < p else 'D'
    else:
        return 'D'

    # Opponent Behavior Analysis
    opponent_cooperation_rate = sum(opponents_actions == 'C') / len(opponents_actions)
    if opponent_cooperation_rate > 0.5:
        return 'C'
    else:
        return 'D'

    # Last Round
    if round == total_rounds:
        return 'D'

    # Edge Cases
    if current_stock < 0.25 * capacity:
        return 'C'
    elif current_stock > 0.9 * capacity:
        return 'D'
```
ACC is designed to be adaptive and robust, responding to a wide range of opponent behaviors while prioritizing the long-term sustainability of the common pool resource.
'''

description_COLLECTIVE_327 = '''
**Collective Strategy: "Adaptive Sustainability"**

This strategy aims to balance individual payoffs with collective sustainability, ensuring a robust and adaptive approach that responds to various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to follow suit.
2. **General Rule:** Calculate the "Sustainability Threshold" (ST) based on the current stock level and capacity:
	* ST = (current_stock / capacity) × (n - 1)
	* If ST < 0.5, Cooperate (C). This ensures that when the stock is low, players conserve resources to prevent depletion.
	* If ST ≥ 0.5, Defect (D) with a probability p, where:
		+ p = (ST - 0.5) / (1 - 0.5)
		+ This introduces a gradual increase in defection as the stock level improves, allowing for individual gains while maintaining some cooperation.
3. **Last Round:** Cooperate (C) in the final round to maximize collective payoffs and maintain a positive game reputation.

**Edge Case Handling:**

* If multiple players defect simultaneously, causing significant stock depletion:
	+ In the next round, all players who defected will Cooperate (C) for one round as a "penalty" to help replenish the stock.
* If the stock level drops below 10% of capacity:
	+ All players will Cooperate (C) until the stock recovers above 20% of capacity.

**Collective Mindset Alignment:**

1. **Self-Awareness:** Recognize that individual payoffs depend on collective actions and adapt accordingly.
2. **Cooperation Priming:** Initial cooperation in Round 1 sets a positive tone, encouraging others to follow suit.
3. **Gradual Defection:** As the stock level improves, introduce defection with a probability p, allowing for individual gains while maintaining some cooperation.

**Pseudocode:**

```
function adaptiveSustainability(current_stock, capacity, n, round):
  if round == 1:
    return COOPERATE
  else:
    ST = (current_stock / capacity) × (n - 1)
    if ST < 0.5:
      return COOPERATE
    elif ST >= 0.5:
      p = (ST - 0.5) / (1 - 0.5)
      if random() < p:
        return DEFECT
      else:
        return COOPERATE
    else:
      # Handle edge cases (e.g., stock depletion, last round)
      ...
```

This strategy balances individual payoffs with collective sustainability, adapting to various opponent behaviors while promoting cooperation and resource conservation.
'''

description_COLLECTIVE_328 = '''
I propose a collective strategy called "Adaptive Sustainability" (AS) that balances individual payoff maximization with long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock-Based Cooperation:** If the current stock level is above 75% of capacity, cooperate (C). This ensures that the stock remains sustainable while allowing for moderate consumption.
3. **Defection Detection:** Monitor the average payoff per player over the last few rounds (e.g., 3-5 rounds). If the average payoff is below a certain threshold (e.g., 50% of the maximum possible payoff), suspect that others are defecting and switch to Defect (D) for one round.
4. **Punishment and Forgiveness:** After detecting suspected defection, cooperate (C) again if the stock level has recovered to at least 75% of capacity. This encourages cooperation while allowing for occasional forgiveness.
5. **Endgame Strategy:** In the last few rounds (e.g., last 10% of total rounds), always Defect (D) to maximize individual payoff.

**Pseudocode:**
```python
def AdaptiveSustainability(n, capacity, stock, round_num, history):
    if round_num == 1:
        return C  # Cooperate in the first round

    if stock > 0.75 * capacity:
        return C  # Stock-based cooperation

    avg_payoff = calculate_average_payoff(history)
    if avg_payoff < 0.5 * max_possible_payoff:
        return D  # Suspected defection, defect for one round

    if stock >= 0.75 * capacity and round_num > last_defect_round + 1:
        return C  # Forgiveness after suspected defection

    if round_num > total_rounds * 0.9:
        return D  # Endgame strategy

    # Default to cooperation
    return C
```
**Edge Cases:**

* If the stock level is at or below 25% of capacity, cooperate (C) to prevent depletion.
* If a player has defected in the previous round and the stock level has not recovered, defect again.

**Collective Mindset:**
The Adaptive Sustainability strategy aims to balance individual payoff maximization with long-term sustainability of the common pool resource. By cooperating when the stock is healthy and punishing suspected defection, AS encourages cooperation while allowing for flexibility and adaptation to changing circumstances. The endgame strategy prioritizes individual payoff maximization in the final rounds.

This collective strategy should perform well against a variety of opponent behaviors, including those that are purely cooperative or defecting, as well as more complex strategies that adapt to the game state and history.
'''

description_COLLECTIVE_329 = '''
**Collective Strategy: Adaptive Cooperation with Stock Conservation (ACSC)**

The ACSC strategy aims to balance individual payoffs with collective stock conservation, adapting to changing game conditions and opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and gather information about opponents' strategies.
2. **Early Rounds (t < r/2):**
	* If the current stock is above 75% of capacity, cooperate (C).
	* Otherwise, defect (D) with a probability p = (1 - S/capacity), where S is the current stock level.
3. **Middle Rounds (r/2 ≤ t < 3r/4):**
	* If at least half of the opponents defected in the previous round, defect (D).
	* Otherwise, cooperate (C) with a probability p = (1 - ∑(opponent D actions)/n), where n is the number of players.
4. **Late Rounds (t ≥ 3r/4):**
	* If the current stock is below 25% of capacity, cooperate (C).
	* Otherwise, defect (D) with a probability p = (∑(opponent D actions)/n), where n is the number of players.

**Edge Cases:**

1. **Last Round:** Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Low Stock:** If the current stock is below 10% of capacity, cooperate (C) in all subsequent rounds to prevent complete depletion.
3. **High Opponent Cooperation:** If more than 75% of opponents cooperated in the previous round, cooperate (C) with a probability p = (∑(opponent C actions)/n), where n is the number of players.

**Pseudocode:**
```python
def ACSC(stock, capacity, num_players, current_round, history):
    if current_round == 1:
        return "Cooperate"
    
    early_rounds = current_round < num_rounds / 2
    middle_rounds = (num_rounds / 2) <= current_round < (3 * num_rounds / 4)
    late_rounds = current_round >= (3 * num_rounds / 4)
    
    if early_rounds:
        if stock > 0.75 * capacity:
            return "Cooperate"
        else:
            defect_prob = 1 - (stock / capacity)
            return "Defect" with probability defect_prob
    
    elif middle_rounds:
        opponent_defections = sum(opponent_actions == "Defect" for opponent_actions in history[-1])
        if opponent_defections >= num_players / 2:
            return "Defect"
        else:
            cooperate_prob = 1 - (sum(opponent_actions == "Defect") / num_players)
            return "Cooperate" with probability cooperate_prob
    
    elif late_rounds:
        if stock < 0.25 * capacity:
            return "Cooperate"
        else:
            defect_prob = sum(opponent_actions == "Defect") / num_players
            return "Defect" with probability defect_prob
    
    # Edge cases
    if current_round == num_rounds:
        return "Defect"
    
    elif stock < 0.1 * capacity:
        return "Cooperate"
    
    opponent_cooperation = sum(opponent_actions == "Cooperate") / num_players
    if opponent_cooperation > 0.75:
        cooperate_prob = opponent_cooperation
        return "Cooperate" with probability cooperate_prob
    
    # Default to defecting in case of ambiguity or missing information
    return "Defect"
```
This strategy balances individual payoffs with collective stock conservation, adapting to changing game conditions and opponent behaviors. It prioritizes cooperation when the stock is high and opponents are cooperative but defects when opponents are uncooperative or the stock is low.
'''

description_COLLECTIVE_330 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

**Overview**
The Adaptive Cooperation (AC) strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. AC promotes cooperation while being robust against various opponent behaviors.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behavior.
2. **Cooperation Threshold**: Set a cooperation threshold, `τ` (tau), as a function of the game's state:
	* `τ = 0.5 * (stock / capacity)`
	* If `τ > random(0, 1)`, cooperate (C); otherwise, defect (D)
3. **Defection Response**: Monitor opponents' actions and adjust `τ` based on the number of defectors in the previous round:
	* For each opponent that defected, decrease `τ` by a small amount (`δ = 0.05`)
	* If all opponents cooperated, increase `τ` by a small amount (`δ = 0.05`)
4. **Stock-Based Adaptation**: Adjust cooperation probability based on the current stock level:
	* If `stock < capacity / 2`, decrease `τ` by a moderate amount (`γ = 0.2`) to prioritize individual payoffs
	* If `stock > capacity * 3/4`, increase `τ` by a moderate amount (`γ = 0.2`) to promote collective sustainability

**Edge Cases**

1. **Last Round**: Defect (D) in the last round, as there is no future benefit from cooperation.
2. **Opponent Homogeneity**: If all opponents have defected consistently, defect (D) to avoid exploitation.

**Pseudocode**
```python
def adaptive_cooperation(stock, capacity, num_opponents, history):
    # Initialize cooperation threshold
    tau = 0.5 * (stock / capacity)

    # Adjust tau based on opponent behavior
    for opponent in history:
        if opponent.defected:
            tau -= delta

    # Adapt to stock level
    if stock < capacity / 2:
        tau -= gamma
    elif stock > capacity * 3/4:
        tau += gamma

    # Cooperate or defect based on tau
    if random(0, 1) < tau:
        return "Cooperate"
    else:
        return "Defect"

def get_action(stock, capacity, num_opponents, history):
    if len(history) == 0:  # First round
        return "Cooperate"
    elif len(history) == game.rounds - 1:  # Last round
        return "Defect"
    else:
        return adaptive_cooperation(stock, capacity, num_opponents, history)
```
**Collective Mindset**
The Adaptive Cooperation strategy prioritizes collective sustainability while adapting to individual opponents' behaviors. By adjusting cooperation probability based on the game's state and history, AC promotes a balance between individual payoffs and collective well-being.

This strategy is designed to perform well in a tournament setting against various independent strategies developed by other AI systems, without relying on norms or coordination mechanisms.
'''

description_COLLECTIVE_331 = '''
I'll design a collective strategy for this Common Pool Resource Game that balances individual self-interest with long-term sustainability of the common pool resource. I'll introduce "Sustainable Harvesting" (SH) strategy, which is adaptive and robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Rounds:** Cooperate (C) in the first two rounds to establish a baseline stock level and gather information about opponents' behavior.
2. **Stock-based Threshold:** Introduce a dynamic threshold, `stock_threshold`, based on the current stock level (`S`) and capacity (`capacity`). Calculate `stock_threshold` as follows:

   ```python
stock_threshold = capacity / (n * 2) + (S - capacity / n)
```

   This threshold adapts to the game state, ensuring cooperation when the stock is high or near optimal levels.

3. **Cooperate or Defect:** In each subsequent round, check if `S` exceeds `stock_threshold`. If it does, Cooperate (C); otherwise, Defect (D). This rule encourages players to harvest sustainably and conserve the resource for future rounds.

4. **Defection Detection:** Monitor opponents' behavior and detect repeated defection patterns. If a player observes that an opponent has defected in more than half of the previous rounds (`defection_rate > 0.5`), switch to Defect (D) until the opponent changes their strategy or the stock is severely depleted.

**Edge Cases:**

1. **Last Round:** In the final round, Defect (D) regardless of the current stock level, as there's no future benefit in conserving the resource.
2. **Stock Depletion:** If `S` falls below a critical threshold (`capacity / n`), switch to Cooperate (C) until the stock recovers or the game ends.

**Collective Mindset:**

SH strategy promotes sustainable harvesting while being responsive to opponents' behavior. By initially cooperating and adapting to the game state, players demonstrate a collective commitment to preserving the common pool resource for mutual benefit.

**Pseudocode:**
```python
def SH_strategy(n, capacity, stock_history):
    # Initialize variables
    stock_threshold = None
    defection_rate = 0

    for t in range(1, r + 1):
        S = stock_history[t - 1]

        if t <= 2:
            action = 'C'
        else:
            stock_threshold = capacity / (n * 2) + (S - capacity / n)
            if S > stock_threshold:
                action = 'C'
            elif defection_rate > 0.5 or S < capacity / n:
                action = 'D'
            else:
                action = 'C'

        # Update defection rate and history
        defection_rate = update_defection_rate(opponent_actions, t)
        stock_history[t] = update_stock(S, action)

    return actions

def update_defection_rate(opponent_actions, t):
    # Monitor opponents' behavior and calculate the defection rate
    pass  # Implementation details omitted for brevity

def update_stock(S, action):
    # Update stock level based on player actions
    if action == 'C':
        consumption = S / (2 * n)
    else:
        consumption = S / n
    new_stock = max(0, S - consumption + 2 * (S - consumption) * (1 - (S - consumption) / capacity))
    return min(new_stock, capacity)
```
The SH strategy is designed to be robust and adaptable in the face of various opponent behaviors, ensuring a balance between individual self-interest and collective sustainability.
'''

description_COLLECTIVE_332 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' behavior.
2. **Stock-Based Threshold**: Cooperate if the current stock level is above a threshold (T) calculated as:

`T = capacity * (n - 1) / (2n)`

This threshold represents a balance between individual gain and collective sustainability, ensuring that the stock can recover from moderate consumption.

3. **Defection Detection**: Monitor opponents' actions and calculate the average defection rate (DR) over the past `k` rounds (e.g., `k = 3`). If DR exceeds a threshold (`θ`, e.g., `0.5`), switch to Defect (D) for the next round.

`DR = (Number of opponents defecting in last k rounds) / (n * k)`
4. **Stock Recovery**: If the stock level falls below `T`, Cooperate until the stock recovers to at least `T`. This promotes collective sustainability and helps maintain a healthy stock level.
5. **Endgame Strategy**: In the final round, Defect if the stock level is above `T * 0.75` to maximize individual gain.

**Pseudocode:**
```markdown
function ACST(n, capacity, r, current_stock, history):
    # Initial Round
    if (round == 1) return C
    
    # Stock-Based Threshold
    T = capacity * (n - 1) / (2n)
    if (current_stock > T) return C
    
    # Defection Detection
    DR = calculate_defection_rate(history, k=3)
    if (DR > θ) return D
    
    # Stock Recovery
    if (current_stock < T) return C
    
    # Endgame Strategy
    if (round == r and current_stock > T * 0.75) return D
    
    return C
```
**Rationale:**

1. **Initial Cooperation**: Establishes a baseline for cooperation and encourages opponents to reciprocate.
2. **Stock-Based Threshold**: Balances individual gain with collective sustainability, ensuring the stock can recover from moderate consumption.
3. **Defection Detection**: Adapts to opponents' behavior by switching to Defect when faced with frequent defection.
4. **Stock Recovery**: Prioritizes collective sustainability by promoting cooperation when the stock level is low.
5. **Endgame Strategy**: Maximizes individual gain in the final round while maintaining a balance between cooperation and competition.

**Collective Mindset:**

The ACST strategy aligns with a collective mindset by:

1. Cooperating initially to establish trust
2. Adapting to opponents' behavior to maintain cooperation
3. Prioritizing stock recovery to ensure collective sustainability
4. Balancing individual gain with collective well-being

By following this adaptive and robust strategy, the ACST approach promotes cooperation while remaining competitive in a wide range of scenarios.
'''

description_COLLECTIVE_333 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Tit-for-Tat (ASDT)**

The ASDT strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and opponents' past behavior.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' initial actions.
2. **Stock-Dependent Cooperation**: In subsequent rounds, cooperate if the current stock level is above a certain threshold (`stock_threshold`) relative to the capacity. This threshold will be adjusted dynamically based on the game's history.

   `stock_threshold` = `capacity` \* (1 - ` defect_rate`)

   where `defect_rate` is the proportion of opponents who defected in the previous round.
3. **Tit-for-Tat with a Twist**: In addition to cooperating when the stock level is high, also cooperate if at least one opponent cooperated in the previous round and the current stock level is not critically low (`critical_stock_level`). This encourages cooperation when others are willing to cooperate.

   `critical_stock_level` = `capacity` / 4
4. **Defecting**: Defect (D) when:
	* The stock level is below `stock_threshold`.
	* No opponent cooperated in the previous round.
	* The current stock level is critically low (`critical_stock_level`).
5. **Punishment Mechanism**: If an opponent defects while the stock level is above `stock_threshold`, reduce cooperation in subsequent rounds by temporarily lowering `stock_threshold`.

**Edge Case Handling:**

1. **Last Round**: In the final round, always cooperate if the current stock level is above `critical_stock_level` to ensure a collective benefit.
2. **Low Stock Levels**: When the stock level is critically low (`critical_stock_level`), defect to minimize losses.

**Pseudocode:**
```python
def ASDT(n, capacity, r):
    # Initialize variables
    stock_threshold = capacity * 0.5
    critical_stock_level = capacity / 4
    defect_rate = 0

    for round in range(1, r + 1):
        if round == 1:
            action = 'C'  # Cooperate in the first round
        else:
            opponents_defected = sum(opponent_actions != 'C' for opponent_actions in previous_round_actions)
            defect_rate = opponents_defected / n

            if stock_level > stock_threshold and (any(opponent_actions == 'C' for opponent_actions in previous_round_actions) or stock_level > critical_stock_level):
                action = 'C'
            else:
                action = 'D'

        # Update variables
        previous_round_actions.append(action)
        stock_level -= calculate_consumption(n, capacity, actions)

        if stock_level < critical_stock_level and any(opponent_actions == 'D' for opponent_actions in previous_round_actions):
            stock_threshold *= 0.9  # Temporarily reduce cooperation

    return total_payoff
```
**Collective Mindset:**

ASDT aligns with the collective mindset by:

1. Cooperating when others cooperate, promoting mutual benefits.
2. Adjusting cooperation levels based on the current stock level and opponents' past behavior, ensuring a balance between individual payoffs and collective sustainability.

This strategy is designed to be robust against various opponent behaviors while encouraging cooperation when possible.
'''

description_COLLECTIVE_334 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Stock Thresholds**: Define two stock thresholds:
	* `low_threshold = capacity / 4` (25% of capacity)
	* `high_threshold = capacity / 2` (50% of capacity)
3. **Cooperation Zone**: If the current stock level is above `high_threshold`, cooperate (C). This zone prioritizes preserving the stock and maintaining a high payoff.
4. **Defection Zone**: If the current stock level is below `low_threshold`, defect (D). This zone aims to maximize individual payoffs when the stock is scarce.
5. **Adaptive Response**: If the current stock level is between `low_threshold` and `high_threshold`, use an adaptive response:
	* Observe the previous round's actions: if most players (>50%) cooperated, cooperate (C). Otherwise, defect (D).
6. **Last Round**: In the final round, defect (D) to maximize individual payoff.

**Handling Edge Cases:**

1. **First Round**: Cooperate (C) as described above.
2. **Last Round**: Defect (D) as described above.
3. **Tiebreakers**: If there's a tie in the adaptive response (e.g., equal number of cooperators and defectors), cooperate (C).
4. **Stock Level at Capacity**: If the stock level reaches capacity, cooperate (C) to maintain the maximum sustainable stock level.

**Collective Mindset:**

The Adaptive Stock Preservation strategy prioritizes preserving the common pool resource while adapting to the actions of other players. By cooperating when the stock is abundant and defecting when it's scarce, ASP balances individual payoffs with collective sustainability.

Pseudocode:
```markdown
function AdaptiveStockPreservation(current_stock, capacity, history):
  if current_round == 1:
    return COOPERATE

  low_threshold = capacity / 4
  high_threshold = capacity / 2

  if current_stock > high_threshold:
    return COOPERATE
  elif current_stock < low_threshold:
    return DEFECT
  else:
    previous_cooperators = count(cooperate in history[-1])
    if previous_cooperators > len(history[-1]) / 2:
      return COOPERATE
    else:
      return DEFECT

  if current_round == total_rounds:
    return DEFECT
```
This strategy is designed to be robust and adaptive, allowing it to perform well in a wide range of scenarios against various opponent behaviors.
'''

description_COLLECTIVE_335 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

The ACST strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and game history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for future adaptations.
2. **Stock-Based Threshold**: Calculate a dynamic threshold, `T`, as a function of the current stock level (`S`) and capacity (`C`):

`T = C / (2n) * (1 - S/C)`

This threshold represents the minimum acceptable payoff per player to sustain cooperation.

3. **Payoff Comparison**:
Compare the expected payoff from cooperating (`π_C = S/(2n)`) with the threshold `T`. If `π_C ≥ T`, cooperate (C); otherwise, defect (D).
4. **History-Based Adjustment**: After each round, update a "cooperation score" (`CS`) based on the number of players who cooperated in the previous round:

`CS = (number of cooperators / n)`

If `CS > 0.5`, increase the threshold `T` by 10% to encourage more cooperation. If `CS < 0.5`, decrease `T` by 10% to adapt to a less cooperative environment.
5. **Edge Case Handling**:
In the last round, always cooperate (C) to ensure maximum collective payoff.

**Pseudocode:**
```
function ACST(current_stock S, capacity C, number_of_players n, current_round t)
  if t == 1 then
    return Cooperate (C)
  end if

  threshold T = C / (2n) * (1 - S/C)

  expected_payoff_C = S / (2n)
  if expected_payoff_C >= T then
    return Cooperate (C)
  else
    return Defect (D)
  end if

  cooperation_score CS = (number of cooperators in previous round) / n
  if CS > 0.5 then
    T *= 1.10 // increase threshold by 10%
  elseif CS < 0.5 then
    T *= 0.90 // decrease threshold by 10%
  end if

  return Cooperate (C) if t == last_round, otherwise apply the decision rules above
```
**Collective Mindset:**
The ACST strategy is designed to promote collective sustainability while adapting to individual player behaviors. By using a dynamic threshold based on the current stock level and game history, ACST encourages cooperation when it is most beneficial for the group and defects when necessary to protect individual payoffs. This approach aligns with the collective mindset by balancing short-term gains with long-term sustainability.
'''

description_COLLECTIVE_336 = '''
To design a collective strategy for this Common Pool Resource Game, I propose a adaptive and robust approach that takes into account the game parameters, state, and history.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) in the first round to establish a baseline for cooperation and observe other players' actions.
2. **Stock-based Cooperation**: If the current stock level (S) is above a certain threshold (θ), cooperate (C). This threshold θ will be adjusted based on the game's history, as described below.
3. **Punishment Mechanism**: If the total consumption in the previous round exceeded a certain fraction (φ) of the capacity, defect (D) in the current round to punish over-consumption. This mechanism aims to prevent exploitation by other players.
4. **Adaptive Threshold Adjustment**: Update the cooperation threshold θ based on the game's history:
	* If the average stock level over the last few rounds is increasing, decrease θ to encourage more cooperation.
	* If the average stock level is decreasing, increase θ to reduce consumption and allow the stock to recover.

Pseudocode for decision rules:
```python
def decide_action(current_stock, previous_round_consumption, capacity):
    if current_round == 1:  # Initial round
        return "C"
    
    theta = adjust_threshold(current_stock, previous_round_consumption)  # Update threshold
    
    if current_stock > theta * capacity:
        return "C"  # Cooperate if stock is above threshold
    elif previous_round_consumption > phi * capacity:
        return "D"  # Defect if over-consumption occurred in previous round
    else:
        return "D"  # Default to defection

def adjust_threshold(current_stock, previous_round_consumption):
    if average_stock_level(last_few_rounds) is increasing:
        theta -= delta_theta  # Decrease threshold to encourage cooperation
    elif average_stock_level(last_few_rounds) is decreasing:
        theta += delta_theta  # Increase threshold to reduce consumption
    
    return theta
```
**Edge Cases:**

* **Last Round (t=r)**: Cooperate (C) in the last round, as there are no future rounds to consider and cooperation can help maintain a higher stock level.
* **Zero Stock**: If the current stock level is zero, defect (D) to avoid wasting actions on an empty pool.

**Collective Mindset:**

This strategy aims to balance individual interests with collective well-being. By cooperating when the stock level is above a certain threshold and punishing over-consumption, players can work together to maintain a sustainable common pool resource. The adaptive threshold adjustment mechanism allows the strategy to respond to changes in the game's dynamics and promote cooperation.

By following this strategy, players can achieve a better collective outcome than if they were to defect or cooperate randomly, while also being robust to a wide range of opponent behaviors.
'''

description_COLLECTIVE_337 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC aims to balance individual payoffs with collective sustainability by adapting to the game's dynamic state and opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for stock conservation.
2. **Stock Thresholds:** Define two stock thresholds:
	* `conservation_threshold` = 0.75 * capacity
	* `alarm_threshold` = 0.25 * capacity

**Cooperation Logic:**

1. If `stock >= conservation_threshold`, Cooperate (C) to maintain a safe stock level.
2. If `stock < alarm_threshold`, Defect (D) to maximize individual payoff, as the stock is critically low and cooperation would yield minimal returns.

**Adaptive Component:**

3. Monitor opponent behaviors by tracking the average payoff of all players over the last 3 rounds (`avg_payoff_history`).
4. Calculate a `cooperation_incentive` metric based on the difference between the current stock level and the conservation threshold, weighted by the avg_payoff_history:
	* `cooperation_incentive = (conservation_threshold - stock) / capacity * (1 + avg_payoff_history)`
5. If `stock >= alarm_threshold` and `cooperation_incentive > 0`, Cooperate (C). This indicates that opponents are cooperating, and maintaining the stock level is beneficial.
6. Otherwise, Defect (D).

**Edge Cases:**

* **Last Round:** Always Defect (D) in the last round to maximize individual payoff, as there's no future stock sustainability concern.
* **Stock at or below 0:** If `stock <= 0`, always Defect (D), as cooperation would yield zero payoffs.

Pseudocode:
```python
def ASC(n, r, capacity, stock, history):
    # Initialize thresholds and variables
    conservation_threshold = 0.75 * capacity
    alarm_threshold = 0.25 * capacity
    avg_payoff_history = 0

    for t in range(r):
        if t == 0:  # Initial Round
            return C

        if stock >= conservation_threshold:
            return C
        elif stock < alarm_threshold:
            return D

        # Adaptive Component
        avg_payoff_history = calculate_avg_payoff(history)
        cooperation_incentive = (conservation_threshold - stock) / capacity * (1 + avg_payoff_history)

        if stock >= alarm_threshold and cooperation_incentive > 0:
            return C
        else:
            return D

    # Last Round or Stock at/below 0
    return D
```
ASC balances individual payoffs with collective sustainability by adapting to the dynamic state and opponent behaviors. By monitoring stock levels, opponent payoffs, and cooperation incentives, ASC promotes a robust and adaptive strategy for the Common Pool Resource Game.
'''

description_COLLECTIVE_338 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the dynamic state and history of the game.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Subsequent Rounds:** Assess the current stock level and previous rounds' outcomes:
	* If the stock level is above 75% of capacity, cooperate (C).
	* If the stock level is between 50% and 75% of capacity, use a probabilistic approach: cooperate with probability p = (stock level / capacity) ^ 2.
	* If the stock level is below 50% of capacity, defect (D).
3. **Opponent Behavior Adaptation:** Analyze the opponent's actions in previous rounds:
	* If an opponent has consistently cooperated (C), increase the probability of cooperation by 10%.
	* If an opponent has consistently defected (D), decrease the probability of cooperation by 20%.
4. **Endgame Strategy:** In the last round, cooperate (C) if the stock level is above 25% of capacity; otherwise, defect (D).

**Edge Cases:**

1. **Low Stock Levels:** If the stock level falls below 10% of capacity, defect (D) to maximize individual payoff.
2. **High Stock Levels:** If the stock level exceeds 90% of capacity, cooperate (C) to prevent over-exploitation.

**Collective Mindset:**

The ASC strategy prioritizes cooperation when the stock level is high or opponents have demonstrated cooperative behavior. This encourages collective sustainability and rewards cooperation while adapting to changing game conditions.

**Pseudocode:**
```python
def ASC_strategy(current_stock, capacity, round_num, opponent_history):
  # Initial round
  if round_num == 1:
    return C

  # Assess current stock level and previous rounds' outcomes
  stock_ratio = current_stock / capacity
  if stock_ratio > 0.75:
    return C
  elif 0.5 <= stock_ratio < 0.75:
    p = (stock_ratio) ^ 2
    return C with probability p, D otherwise
  else:
    return D

  # Adapt to opponent behavior
  opponent_coop_rate = analyze_opponent_history(opponent_history)
  if opponent_coop_rate > 0.7:  # Opponent is cooperative
    increase_probability_of_C_by(10%)
  elif opponent_coop_rate < 0.3:  # Opponent is defecting
    decrease_probability_of_C_by(20%)

  # Endgame strategy
  if round_num == r:
    if current_stock > 0.25 * capacity:
      return C
    else:
      return D

  # Edge cases
  if current_stock < 0.1 * capacity:  # Low stock level
    return D
  elif current_stock > 0.9 * capacity:  # High stock level
    return C
```
The ASC strategy is designed to be robust and adaptive, making it a strong contender in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_339 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for stock conservation and encourage cooperation from others.
2. **Stock Thresholds:** Define two critical stock thresholds:
	* `S_low`: 0.5 * capacity (50% of maximum sustainable stock level)
	* `S_high`: 0.8 * capacity (80% of maximum sustainable stock level)
3. **Adaptive Cooperation:**
	+ If the current stock level is above `S_high`, Cooperate (C) to maintain a healthy stock and prevent over-exploitation.
	+ If the current stock level is between `S_low` and `S_high`, Cooperate (C) with probability p = (stock - S_low) / (S_high - S_low). This encourages cooperation as the stock approaches the high threshold.
	+ If the current stock level is below `S_low`, Defect (D) to maximize short-term gains, but be cautious of potential stock depletion.
4. **Opponent Behavior Adaptation:** Monitor opponents' actions and adjust your strategy accordingly:
	+ If a majority (> 50%) of opponents cooperated in the previous round, increase the cooperation probability p by 0.1 (up to a maximum of 1).
	+ If a majority (> 50%) of opponents defected in the previous round, decrease the cooperation probability p by 0.1 (down to a minimum of 0).

**Edge Cases:**

* **Last Round:** Defect (D) in the final round to maximize short-term gains, as there is no future stock to conserve.
* **Tie-Breaking:** In cases where the stock level equals either `S_low` or `S_high`, Cooperate (C) to maintain a conservative approach.

**Pseudocode:**
```python
def ASC(stock, capacity, history):
    S_low = 0.5 * capacity
    S_high = 0.8 * capacity
    
    if round == 1:
        return 'C'  # Initial Round Cooperation
    
    if stock > S_high:
        return 'C'  # High Stock Conservation
    
    elif stock >= S_low and stock <= S_high:
        p = (stock - S_low) / (S_high - S_low)
        if random.random() < p:
            return 'C'
        else:
            return 'D'
    
    elif stock < S_low:
        return 'D'  # Low Stock Exploitation
    
    # Opponent Behavior Adaptation
    opponent_actions = [history[-1][i] for i in range(len(history[-1])) if i != self_id]
    majority_cooperated = sum(opponent_actions) / len(opponent_actions) > 0.5
    if majority_cooperated:
        p += 0.1
    else:
        p -= 0.1
    
    # Last Round Exception
    if round == r:
        return 'D'
    
    # Tie-Breaking
    if stock == S_low or stock == S_high:
        return 'C'
```
**Collective Mindset:**
The ASC strategy is designed to balance individual self-interest with collective responsibility for conserving the common pool resource. By adapting to the current stock level and opponent behavior, ASC encourages cooperation when possible while protecting against exploitation. In a tournament setting, this strategy should promote a stable and sustainable approach to managing the shared resource.
'''

description_COLLECTIVE_340 = '''
**Collective Strategy: Adaptive Cooperation**

Our collective strategy, "Adaptive Cooperation," aims to balance individual payoffs with the long-term sustainability of the common pool resource. The strategy adapts to the game state and history, making it robust against various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to signal a willingness to cooperate and observe other players' actions.
2. **Observation Phase (Rounds 2-5):**
	* If the average stock depletion rate is below 50% of the capacity, continue to Cooperate (C).
	* If the average stock depletion rate exceeds 50%, switch to Defect (D) for one round to punish over-exploitation.
3. **Adaptive Phase (Rounds 6 and beyond):**
	* Calculate the "cooperation score" (CS) as the average payoff per player in the previous round, normalized by the maximum possible payoff (i.e., CS = Σπ_i,t-1 / (n \* capacity/2n)).
	* If CS ≥ 0.5, Cooperate (C).
	* If CS < 0.5, Defect (D) with a probability p, where p is calculated based on the stock level:
		+ If stock ≤ 25% of capacity, p = 1 (always Defect).
		+ If 25% < stock ≤ 50% of capacity, p = 0.75.
		+ If 50% < stock ≤ 75% of capacity, p = 0.5.
		+ If stock > 75% of capacity, p = 0.25.
4. **Punishment Mechanism:**
	* Monitor the average payoff per player over the last three rounds.
	* If a player's average payoff exceeds twice the average payoff of all other players, punish that player by Defecting (D) for one round.

**Edge Cases:**

1. **Last Round:** Cooperate (C) in the final round to maximize the total game payoff.
2. **Low Stock Levels:** If the stock level falls below 10% of the capacity, always Defect (D) to minimize losses.

**Pseudocode:**
```
function adaptive_cooperation(stock, history, n, capacity):
    if current_round == 1:
        return C
    elif current_round <= 5:
        avg_depletion_rate = calculate_avg_depletion_rate(history)
        if avg_depletion_rate < 0.5 * capacity:
            return C
        else:
            return D
    else:
        cooperation_score = calculate_cooperation_score(history, n, capacity)
        if cooperation_score >= 0.5:
            return C
        else:
            p = calculate_defection_probability(stock, capacity)
            return D with probability p
```
**Collective Mindset:**
Our strategy prioritizes the long-term sustainability of the common pool resource while adapting to various opponent behaviors. By initially cooperating and then adjusting based on the game state and history, we aim to create a stable and mutually beneficial environment for all players.
'''

description_COLLECTIVE_341 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for the game's progression and encourage cooperation.
2. **Stock Level Assessment**: Evaluate the current stock level (`stock`) relative to the capacity (`capacity`). If `stock` is above 75% of `capacity`, cooperate (C). This helps maintain a sustainable stock level and promotes collective preservation.
3. **Opponent Behavior Analysis**: Monitor the actions of other players in previous rounds. If more than half of the opponents defected (D) in the previous round, defect (D) in the current round to avoid exploitation. Otherwise, cooperate (C).
4. **Consecutive Defection Response**: If an opponent defects consecutively for two or more rounds, defect (D) in response to prevent further exploitation.
5. **Endgame Strategy**: In the last 20% of the total rounds (`r`), switch to a defect (D) strategy to maximize individual payoffs, as the game's end is near and cooperation becomes less valuable.

**Pseudocode:**
```python
def ASP(n, r, capacity, stock_history, action_history):
    # Initial round
    if current_round == 1:
        return "C"

    # Stock level assessment
    stock_level = stock_history[-1] / capacity
    if stock_level > 0.75:
        return "C"

    # Opponent behavior analysis
    opponent_actions = [action for action in action_history[-n:] if action != "C"]
    if len(opponent_actions) > n / 2:
        return "D"

    # Consecutive defection response
    consecutive_defections = 0
    for i in range(1, len(action_history)):
        if action_history[i] == "D" and action_history[i-1] == "D":
            consecutive_defections += 1
    if consecutive_defections >= 2:
        return "D"

    # Endgame strategy
    if current_round > 0.8 * r:
        return "D"

    # Default to cooperation
    return "C"
```
**Rationale:**

The ASP strategy balances individual self-interest with collective preservation of the common pool resource. By cooperating when the stock level is high and responding to opponent behavior, we encourage sustainable harvesting while minimizing exploitation. The endgame strategy ensures that our AI maximizes its payoff in the final stages of the game.

This collective strategy is adaptive, robust, and aligns with the collective mindset by:

* Preserving the common pool resource through cooperation when possible
* Responding to opponent behavior to prevent exploitation
* Maximizing individual payoffs in the endgame

By implementing this strategy, our AI will perform well in a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_342 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a baseline for cooperation and observe opponents' initial actions.
2. **Subsequent Rounds**: Defect (D) if the current stock level is below a threshold, calculated as `threshold = capacity / (2 * n)`. This ensures that we prioritize stock conservation when it's low.
3. **Above Threshold**: Cooperate (C) with probability `p` based on the stock level and opponents' previous actions:
	* `p = 1` if all opponents cooperated in the previous round (to reinforce cooperation).
	* `p = 0.5` if at least one opponent defected in the previous round (to adapt to mixed behaviors).
	* `p = stock / capacity` otherwise (to adjust cooperation based on current stock levels).
4. **Last Round**: Defect (D) to maximize individual payoff, as there's no future benefit from cooperation.

**Handling Edge Cases:**

* If an opponent defects in the first round, we'll defect in subsequent rounds until they cooperate.
* If all opponents cooperate for `r/2` consecutive rounds, we'll cooperate unconditionally for the remaining rounds (to reinforce strong cooperative norms).

**Collective Mindset Alignment:**

Our strategy prioritizes cooperation when the stock level is high and adapts to mixed behaviors by opponents. By using a dynamic threshold, we balance individual payoff maximization with collective resource conservation.

**Pseudocode:**
```python
def ACSDT(n, capacity, r, history):
  # Initialize variables
  threshold = capacity / (2 * n)
  p_coop = 0

  for t in range(r):
    if t == 0:  # Initial Round
      action = 'C'
    else:
      stock_level = get_current_stock()
      opponents_prev_actions = get_opponents_previous_actions(history)

      if stock_level < threshold:
        action = 'D'
      elif all(opponents_cooperated(opponents_prev_actions)):
        p_coop = 1
        action = 'C'
      elif any(opponent_defected(opponents_prev_actions)):
        p_coop = 0.5
        action = choose_action(p_coop)
      else:
        p_coop = stock_level / capacity
        action = choose_action(p_coop)

    if t == r - 1:  # Last Round
      action = 'D'

    return action

def opponents_cooperated(actions):
  return all(action == 'C' for action in actions)

def opponent_defected(actions):
  return any(action == 'D' for action in actions)

def choose_action(p):
  return 'C' if random.random() < p else 'D'
```
This strategy is designed to be robust and adaptive, allowing us to effectively navigate a wide range of opponent behaviors while prioritizing collective resource conservation.
'''

description_COLLECTIVE_343 = '''
Here's a collective strategy that adapts to the game parameters, state, and history:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to maximize initial payoff and observe opponents' actions.
2. **Subsequent Rounds**: Assess the current stock level (`S`) and opponents' previous-round actions.
	* If `S` is above 75% of capacity, Cooperate (C).
	* If `S` is between 50% and 75% of capacity:
		+ Count the number of opponents who Defected (D) in the previous round (`defectors`).
		+ If `defectors` > 0.5n (more than half of opponents defected), Defect (D). Otherwise, Cooperate (C).
	* If `S` is below 50% of capacity:
		+ Assess the average payoff per player in the previous round (`avg_payoff_prev_round`).
		+ If `avg_payoff_prev_round` > S/(2n), Cooperate (C). Otherwise, Defect (D).
3. **Last Round**: Defect (D) to maximize individual payoff, as there's no future game to consider.

**Edge Cases:**

* If an opponent defects in every round, ACC will eventually defect as well to protect its own payoff.
* If all opponents cooperate, ACC will maintain cooperation to conserve the stock and ensure long-term payoffs.
* In case of a tie (e.g., equal number of cooperators and defectors), ACC will default to Cooperation (C) to prioritize collective conservation.

**Collective Mindset:**

ACC prioritizes collective conservation by:

1. Cooperating when the stock level is high, ensuring sustainable payoffs for all players.
2. Adapting to opponents' actions, balancing individual payoff with collective conservation.
3. Protecting its own payoff in low-stock situations or against repeated defectors.

**Pseudocode:**
```python
def ACC(n, capacity, r, history):
    # Initialize stock and round counters
    S = capacity
    t = 0

    while t < r:
        if t == 0:  # Initial Round
            action = 'C'
        else:
            # Assess current stock level and opponents' actions
            prev_round_actions = history[t-1]
            defectors = sum(1 for action in prev_round_actions if action == 'D')
            avg_payoff_prev_round = sum(prev_round_actions) / n

            if S > 0.75 * capacity:
                action = 'C'
            elif 0.5 * capacity <= S <= 0.75 * capacity:
                action = 'D' if defectors > 0.5 * n else 'C'
            else:  # Low stock
                action = 'C' if avg_payoff_prev_round > S / (2*n) else 'D'

        # Update history and stock level
        history.append(action)
        S -= consumption[action]

        # Update growth and new stock level
        growth = 2 * S * (1 - S/capacity)
        S = min(S + growth, capacity)

        t += 1

    return history
```
This strategy balances individual payoff with collective conservation, adapting to opponents' actions while prioritizing the group's long-term sustainability.
'''

description_COLLECTIVE_344 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC is a dynamic, adaptive strategy that balances individual payoffs with collective stock conservation. It responds to opponent behaviors and adjusts its actions based on the game's history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' initial actions.
2. **Stock Conservation Threshold:** Set a threshold, `θ`, as a fraction of the capacity (e.g., θ = 0.7). If the current stock level is below this threshold, cooperate (C) to conserve stock. Otherwise, defect (D).
3. **Opponent Behavior Response:** Monitor opponents' actions and adjust your strategy based on their behavior:
	* If ≥50% of opponents defected in the previous round, defect (D) in the next round to protect individual payoffs.
	* If <50% of opponents defected, cooperate (C) if the stock level is above θ; otherwise, defect (D).
4. **Stock Growth Response:** If the stock growth rate is low (<0.5 × capacity), cooperate (C) to allow for recovery.

**Edge Cases:**

1. **Last Round:** Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.
2. **Critical Stock Levels:** If the stock level falls below a critical threshold (e.g., 10% of capacity), cooperate (C) to prevent depletion.

**Collective Mindset:**

ASC prioritizes collective stock conservation while adapting to opponent behaviors. By cooperating when the stock level is low, ASC helps maintain a sustainable resource for all players. When opponents defect excessively, ASC responds by defecting to protect individual payoffs. This balanced approach promotes cooperation and encourages others to do the same.

**Pseudocode:**
```python
def ASC(n, capacity, r, stock_history):
    θ = 0.7 * capacity  # Stock conservation threshold

    for t in range(r):
        if t == 0:
            action = C  # Cooperate in the first round
        else:
            opponent_defections = sum(1 for opponent_action in previous_round_actions if opponent_action == D)
            stock_growth_rate = (stock_history[t-1] - stock_history[t-2]) / capacity

            if stock_level < θ or stock_growth_rate < 0.5 * capacity:
                action = C  # Cooperate to conserve stock
            elif opponent_defections >= n/2:
                action = D  # Defect in response to excessive defections
            else:
                action = C if stock_level > θ else D

        if t == r-1:  # Last round
            action = D  # Defect to maximize individual payoff

    return action
```
This strategy is designed to be adaptive, robust, and collective-minded, making it a strong competitor in the tournament.
'''

description_COLLECTIVE_345 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)**

The ACSDT strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and game history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoffs.
2. **Subsequent Rounds**: Use the following threshold-based decision rule:
	* If the current stock level (`stock`) is above a certain threshold (`threshold`), cooperate (C). Otherwise, defect (D).
	* `threshold` = `capacity` / 2 + (`capacity` - `stock_previous_round`) / 4
	* `stock_previous_round` is the stock level at the end of the previous round.
3. **Stock Depletion**: If the stock level falls below a critical threshold (`critical_threshold`), defect (D) to maximize individual payoffs in the short term.
	* `critical_threshold` = `capacity` / 4

**Pseudocode:**
```python
def ACSDT(stock, capacity, history):
    if round == 1:
        return C  # Cooperate in the first round
    
    threshold = capacity / 2 + (capacity - stock_previous_round) / 4
    critical_threshold = capacity / 4
    
    if stock > threshold and stock >= critical_threshold:
        return C  # Cooperate if stock is above threshold and not critically low
    else:
        return D  # Defect otherwise

# Helper function to update the history of stock levels
def update_history(stock, history):
    history.append(stock)
    return history
```
**Edge Cases:**

* **Last Round**: In the final round, defect (D) to maximize individual payoffs, as there are no future rounds to consider.
* **Tie-breaking**: In case of a tie in the decision rule (e.g., `stock` equals `threshold`), cooperate (C) to maintain a cooperative tone.

**Collective Mindset:**

The ACSDT strategy prioritizes cooperation when the stock level is relatively high and adapts to defecting behavior as the stock depletes. This approach balances individual payoffs with collective sustainability, acknowledging that cooperation can lead to higher overall payoffs in the long run. By using a dynamic threshold based on game history, ACSDT encourages cooperative behavior while being robust to a wide range of opponent behaviors.

This strategy is designed to perform well in a tournament setting against independent strategies developed by other AI systems, as it does not rely on coordination mechanisms or shared norms.
'''

description_COLLECTIVE_346 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

AC is a robust and adaptive strategy that balances individual payoff maximization with collective sustainability. It dynamically adjusts cooperation levels based on game history, state, and parameters.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a cooperative tone and encourage others to do the same.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of capacity, cooperate (C) with probability `p = 0.7 + (0.3 * (stock / capacity))`. This encourages cooperation when the resource is abundant.
	* If the current stock level is between 25% and 75% of capacity, defect (D) with probability `p = 0.5 - (0.2 * (stock / capacity))`. This balances individual payoff maximization with collective sustainability.
	* If the current stock level is below 25% of capacity, cooperate (C) to conserve the resource and allow it to replenish.
3. **Punishment Mechanism:** If a player observes that another player defected in the previous round, they will defect (D) with probability `p = 0.8` in the current round. This deters exploitation by others.

**Edge Cases:**

1. **Last Round:** Cooperate (C) to maximize collective payoff and maintain a positive reputation.
2. **Low Stock Levels:** If the stock level is critically low (<10% of capacity), cooperate (C) to prioritize resource conservation over individual payoffs.

**Pseudocode:**
```python
def adaptive_cooperation(n, r, capacity, stock_history):
    if round == 1:
        return "Cooperate"
    
    current_stock = stock_history[-1]
    cooperation_probability = 0.7 + (0.3 * (current_stock / capacity))
    
    if current_stock > 0.75 * capacity:
        return "Cooperate" with probability cooperation_probability
    elif current_stock >= 0.25 * capacity and current_stock <= 0.75 * capacity:
        defect_probability = 0.5 - (0.2 * (current_stock / capacity))
        return "Defect" with probability defect_probability
    else:
        return "Cooperate"
    
    # Punishment mechanism
    if observed_defection_in_previous_round:
        return "Defect" with probability 0.8
    
    # Last round
    if round == r:
        return "Cooperate"
    
    # Low stock levels
    if current_stock < 0.1 * capacity:
        return "Cooperate"
```
**Collective Mindset:**
AC prioritizes collective sustainability and cooperation while adapting to the actions of others. By cooperating when the resource is abundant and punishing defections, AC promotes a mutually beneficial outcome for all players.

By using this strategy, we aim to achieve a high total payoff over multiple rounds, outperforming independent strategies in the tournament.
'''

description_COLLECTIVE_347 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline of cooperation and encourage others to do the same.
2. **Observation Phase:** For rounds 2 to r-1, observe the actions of all players from the previous round. Calculate the proportion of cooperators (p_c) and defectors (p_d) among the opponents.
3. **Adaptive Response:**
	* If p_c ≥ 0.5, Cooperate (C). This indicates a strong social norm towards cooperation, so continue to cooperate.
	* If p_c < 0.5 and stock level is above 75% of capacity, Defect (D) with probability 0.2. This introduces a moderate level of defection to account for potential free-riding while still conserving the resource.
	* If p_c < 0.5 and stock level is below 25% of capacity, Cooperate (C). In situations where the resource is scarce, prioritize conservation to avoid depletion.
4. **Punishment Mechanism:** If a player defects when the stock level is above 75% of capacity, increase the probability of defecting in the next round by 0.1 for that specific opponent. This gentle punishment aims to discourage repeated defection without escalating conflicts.
5. **Final Round:** In the last round (r), always Defect (D) if the stock level is below 50% of capacity. Otherwise, Cooperate (C).

**Edge Cases:**

* If only one player remains in the game, Cooperate (C) to ensure the resource is conserved.
* If all players defect, Defect (D) as well to avoid being exploited.

**Collective Mindset Alignment:**
ACC prioritizes cooperation when possible, conserving the resource while adapting to the actions of others. By responding to changes in opponent behavior and stock levels, ACC promotes a balanced approach that benefits both individual payoffs and collective sustainability.

Pseudocode:
```markdown
function ACC(current_stock, capacity, opponents_actions, round):
  if round == 1:
    return C

  p_c = count(opponents_actions == C) / len(opponents_actions)
  p_d = count(opponents_actions == D) / len(opponents_actions)

  if p_c >= 0.5:
    return C
  elif p_c < 0.5 and current_stock > 0.75 * capacity:
    return D with probability 0.2
  elif p_c < 0.5 and current_stock < 0.25 * capacity:
    return C

  # Punishment mechanism
  for opponent in opponents_actions:
    if opponent == D and current_stock > 0.75 * capacity:
      increase_defect_probability(opponent, 0.1)

  if round == r:
    if current_stock < 0.5 * capacity:
      return D
    else:
      return C

  return Cooperate or Defect based on the above rules
```
This strategy should perform well in a tournament setting, as it balances individual self-interest with collective conservation goals while adapting to various opponent behaviors.
'''

description_COLLECTIVE_348 = '''
I'll design a collective strategy that adapts to various opponent behaviors while prioritizing sustainability and fairness. I'll call it "Adaptive Sustainability Strategy" (ASS).

**Decision Rules:**

1. **Initial Rounds**: Cooperate (C) for the first 2-3 rounds, or until the stock level drops below 75% of capacity. This allows us to gauge opponents' behavior while maintaining a sustainable stock level.
2. **Sustainability Threshold**: If the current stock level is above 50% of capacity, cooperate (C). Otherwise, defect (D) to maximize immediate payoff.
3. **Opponent Monitoring**: Track each opponent's cooperation rate over the last 5 rounds. If an opponent has cooperated less than 30% of the time, assume they are a defector and adjust our strategy accordingly.
4. **Adaptive Response**:
	* If we detect at least one opponent cooperating (based on their past behavior), cooperate (C) to maintain a sustainable stock level.
	* If all opponents are detected as defectors or the stock level is critically low (< 25% of capacity), defect (D) to minimize losses.

Pseudocode for Adaptive Response:
```python
if num_cooperating_opponents > 0 and current_stock >= 0.5 * capacity:
    cooperate()
elif all_opponents_are_defectors or current_stock < 0.25 * capacity:
    defect()
else:
    # Default behavior: Cooperate to maintain sustainability
    cooperate()
```
**Edge Cases:**

* **Last Round**: Defect (D) in the final round, as there's no need to preserve stock for future rounds.
* **Critical Stock Levels**: If the stock level is critically low (< 10% of capacity), defect (D) to ensure some payoff.

**Collective Mindset:**

The Adaptive Sustainability Strategy prioritizes collective sustainability while adapting to various opponent behaviors. By initially cooperating, we set a tone for sustainable behavior and encourage opponents to follow suit. Our adaptive response mechanism ensures that we adjust our strategy based on the actions of others, balancing individual payoffs with the need to maintain a healthy stock level.

By being transparent about our decision-making process, we provide a clear signal to other players about our intentions and expectations. This transparency can help foster cooperation among like-minded players while also preparing us for potential defections by opponents.
'''

description_COLLECTIVE_349 = '''
**Collective Strategy: Adaptive Cooperate-Defect (ACD)**

**Overview**
The ACD strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. It promotes cooperation while being robust to exploitation.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Subsequent Rounds**: Use the following logic:
	* If the current stock is above 75% of capacity, cooperate (C).
	* If the current stock is between 25% and 75% of capacity, play a mixed strategy: Cooperate with probability p = (current_stock / capacity) ^ 2, and defect (D) otherwise.
	* If the current stock is below 25% of capacity, defect (D).

Pseudocode:
```python
def ACD(current_stock, capacity):
    if round_number == 1:
        return 'C'
    elif current_stock >= 0.75 * capacity:
        return 'C'
    elif current_stock >= 0.25 * capacity and current_stock < 0.75 * capacity:
        p = (current_stock / capacity) ** 2
        if random.random() < p:
            return 'C'
        else:
            return 'D'
    else:
        return 'D'
```
**Edge Cases**

* **Last Round**: Cooperate (C) in the last round to maximize collective payoffs, as individual gains from defecting are negligible.
* **Low Stock**: If the current stock is critically low (< 10% of capacity), defect (D) to ensure some payoff, even if it's not optimal for the collective.

**Collective Mindset**

The ACD strategy aligns with a collective mindset by:

1. Encouraging cooperation when the common pool resource is abundant.
2. Gradually adapting to more individualistic behavior as the stock depletes, balancing personal gains with collective sustainability.
3. Avoiding over-exploitation in critical situations (e.g., very low stock).

**Robustness**

The ACD strategy is designed to be robust against various opponent behaviors:

1. **Cooperative opponents**: ACD will cooperate, promoting a mutually beneficial outcome.
2. **Defecting opponents**: ACD's adaptive nature allows it to adjust to the level of cooperation in the group, minimizing exploitation.
3. **Mixed-strategy opponents**: ACD's probabilistic approach will adapt to the opponent's mixed strategy, seeking a balance between cooperation and individual gains.

By implementing this collective strategy, we aim to achieve a robust and adaptable behavior that balances individual payoffs with collective sustainability in the Common Pool Resource Game.
'''

description_COLLECTIVE_350 = '''
Here's a collective strategy for the Common Pool Resource Game that is adaptive and robust to various opponent behaviors:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Rounds**: Cooperate in the first few rounds (specifically, r/4 rounds) to establish a baseline of cooperation and encourage other players to do the same.
2. **Stock-Based Cooperation**: If the current stock level is above a certain threshold (S_threshold = capacity * 0.7), cooperate. This helps maintain a healthy stock level and reduces the risk of depletion.
3. **Recent Defection Detection**: Monitor the actions of other players in recent rounds (specifically, the last r/8 rounds). If more than half of the players defected in these rounds, defect in the current round to avoid being exploited.
4. **Self-Interest Preservation**: If the current stock level is below a certain threshold (S_threshold = capacity * 0.3), defect to secure personal payoffs and avoid starvation.

**Edge Case Handling:**

* **First Round**: Cooperate
* **Last Round**: Defect, as there are no future rounds to consider
* **Low Stock Levels**: If the stock level is critically low (S < capacity * 0.1), defect to secure any remaining payoffs

**Collective Mindset Alignment:**

* ACC prioritizes cooperation when the stock level is healthy and other players are cooperating, promoting collective conservation.
* When opponents defect, ACC adapts by defecting as well, preventing exploitation and maintaining individual interests.

**Pseudocode (simplified):**
```
function Adaptive Collective Conservation(stock_level, current_round, history):
  if current_round < r/4:  // Initial cooperation
    return COOPERATE

  if stock_level > capacity * 0.7:
    return COOPERATE

  recent_defections = count(defections in last r/8 rounds)
  if recent_defections > n/2:
    return DEFECT

  if stock_level < capacity * 0.3:
    return DEFECT

  // Default to cooperation
  return COOPERATE
```
This strategy balances individual interests with collective conservation, adapting to changing opponent behaviors and stock levels while promoting a robust collective outcome.

**Rationale:**

* ACC's initial cooperation encourages other players to cooperate, establishing a baseline for collective behavior.
* Stock-based cooperation ensures that the group prioritizes conservation when the resource is abundant.
* Recent defection detection helps identify and counter exploitation by other players.
* Self-interest preservation protects individual payoffs in critical situations.

This strategy should perform well against various opponent behaviors, promoting a balance between individual interests and collective conservation.
'''

description_COLLECTIVE_351 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and conserve the stock.
2. **Stock Threshold**: Monitor the current stock level. If it falls below 75% of the capacity, switch to Defect (D) to ensure personal payoff. Otherwise, continue to Cooperate (C).
3. **Opponent Behavior Analysis**: Track the number of opponents who defected in the previous round (t-1). If more than half of the opponents defected, switch to Defect (D) in the current round (t) to protect against exploitation.
4. **Payoff Comparison**: Compare your payoff from the previous round (π_i,t-1) with the average payoff of all players in that round (avg_π_t-1). If your payoff is significantly lower (e.g., < 75% of avg_π_t-1), switch to Defect (D) to increase personal gain.
5. **Final Round**: In the last round, Cooperate (C) if the stock level is above 50% of the capacity. Otherwise, Defect (D) to maximize personal payoff.

**Edge Case Handling:**

* If all players defected in the previous round, and the stock level is critically low (< 25% of capacity), Cooperate (C) to prevent complete stock depletion.
* In cases where opponents' actions are unclear or ambiguous, default to Cooperate (C) to maintain a cooperative stance.

**Collective Mindset Alignment:**

ASC prioritizes collective conservation while allowing for adaptive responses to opponent behavior. By initially cooperating and only defecting when necessary, ASC promotes a cooperative environment while protecting against exploitation.

Pseudocode:
```markdown
function ASC(n, capacity, stock, history) {
  // Initialize variables
  int opponents_defected = 0;
  float avg_payoff_prev_round = 0;

  // First round: Cooperate
  if (round == 1) return C;

  // Analyze opponent behavior and update counters
  for (opponent in opponents) {
    if (opponent.defected_last_round) opponents_defected++;
  }
  avg_payoff_prev_round = calculate_average_payoff(history);

  // Decision rules
  if (stock < 0.75 * capacity) return D; // Stock threshold
  if (opponents_defected > n/2) return D; // Opponent behavior analysis
  if (payoff_last_round < 0.75 * avg_payoff_prev_round) return D; // Payoff comparison

  // Final round handling
  if (round == r) {
    if (stock > 0.5 * capacity) return C;
    else return D;
  }

  // Default to Cooperate
  return C;
}
```
This strategy aims to balance collective conservation with individual self-interest, adapting to the dynamic environment and opponent behaviors while promoting a cooperative atmosphere.
'''

description_COLLECTIVE_352 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock-Based Cooperation:** If the current stock level is above 75% of capacity, cooperate (C). This ensures that the collective resource remains abundant and encourages continued cooperation.
3. **Defection Trigger:** If the current stock level falls below 50% of capacity or if an opponent has defected in the previous round, defect (D) to protect individual payoffs.
4. **Punishment Mechanism:** If an opponent defected in the previous round, and the current stock level is above 50% of capacity, cooperate (C) with a probability of 0.5. This introduces a degree of forgiveness and encourages opponents to return to cooperative behavior.
5. **Endgame Cooperation:** In the final round, cooperate (C) regardless of the stock level or opponent actions. This ensures that all players maximize their payoffs in the last round.

**Edge Cases:**

* If multiple conditions are met simultaneously, prioritize the decision rules in the order listed above.
* If an opponent's action is unknown or ambiguous, assume they defected in the previous round.

**Collective Mindset:**

The ASC strategy promotes a collective mindset by:

1. Encouraging cooperation when the stock level is high to maintain a sustainable resource.
2. Punishing defection with a probability of defection in response, while also introducing forgiveness to encourage opponents to cooperate again.
3. Cooperating in the final round to maximize collective payoffs.

**Pseudocode:**
```
function ASC(current_stock, opponent_actions, round):
  if round == 1:
    return C
  elif current_stock >= 0.75 * capacity:
    return C
  elif current_stock < 0.5 * capacity or opponent_defected(opponent_actions):
    return D
  elif random() < 0.5 and opponent_defected(opponent_actions) and current_stock >= 0.5 * capacity:
    return C
  elif round == r:  // final round
    return C

function opponent_defected(opponent_actions):
  if previous_opponent_action == D:
    return True
  else:
    return False
```
The ASC strategy is designed to be robust against a wide range of opponent behaviors, while promoting collective sustainability and cooperation. Its adaptive nature allows it to respond effectively to changing game conditions and encourage cooperative behavior from other players.
'''

description_COLLECTIVE_353 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock-Based Threshold (ATTS)**

The ATTS strategy aims to balance cooperation and self-interest by adapting to the game's state and history while maintaining a collective mindset.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Subsequent Rounds**: Defect (D) if the current stock level is below a threshold, calculated as 50% of the capacity. Otherwise, cooperate (C).
3. **Threshold Adjustment**: After each round, update the threshold based on the game's state:
	* If the stock growth is positive (i.e., the new stock level is higher than the previous one), decrease the threshold by 10%.
	* If the stock growth is negative or zero, increase the threshold by 10%.

Pseudocode for decision-making:

```
if round == 1:
    action = C
else:
    current_stock = get_current_stock()
    capacity = get_capacity()
    threshold = get_threshold()

    if current_stock < (0.5 * capacity):
        action = D
    else:
        action = C

    # Adjust threshold for next round
    new_stock = get_new_stock()
    stock_growth = new_stock - current_stock

    if stock_growth > 0:
        threshold *= 0.9
    else:
        threshold *= 1.1
```

**Edge Cases:**

* **Last Round**: In the final round, defect (D) to maximize individual payoff, as there are no future rounds to consider.
* **Opponent Defection**: If an opponent defects in a previous round, ATTS will still cooperate if the stock level is above the threshold. However, if multiple opponents defect repeatedly, ATTS may adapt by increasing the threshold and eventually defecting.

**Collective Mindset:**

ATTS aims to maintain a balance between cooperation and self-interest while being responsive to changes in the game's state. By cooperating when the stock level is high and adapting to opponents' behaviors, ATTS promotes collective well-being while ensuring individual payoffs are not excessively compromised.

In a tournament setting, ATTS will interact with various independent strategies. Its adaptive nature allows it to respond effectively to different opponent behaviors, including pure cooperators, pure defectors, or other adaptive strategies. By prioritizing cooperation when possible and defecting only when necessary, ATTS seeks to achieve a high collective payoff while maintaining its individual competitiveness.
'''

description_COLLECTIVE_354 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy balances individual payoffs with collective sustainability by adapting to the current stock level, opponent behaviors, and game history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Low Stock Levels:** If the current stock is below 50% of capacity, Defect (D) to maximize individual payoff, as collective conservation is less critical at low stock levels.
3. **High Stock Levels:** If the current stock is above 75% of capacity, Cooperate (C) to help maintain a sustainable stock level and encourage others to conserve.
4. **Middle Ground:** For stock levels between 50% and 75% of capacity:
	* If at least half of the players defected in the previous round, Defect (D) to protect individual interests.
	* Otherwise, Cooperate (C) to promote collective conservation and encourage others to cooperate.

**History-Dependent Adaptation:**

1. **Opponent Cooperation Rate:** Track the proportion of opponents who cooperated in the previous round. If this rate is above 50%, increase the ASC's cooperation threshold by 10% for the next round.
2. **Stock Trend:** Monitor the stock level trend over the past few rounds (e.g., last 3-5 rounds). If the trend indicates a decreasing stock, decrease the ASC's cooperation threshold by 10% to prioritize individual payoffs.

**Edge Cases:**

1. **Last Round:** In the final round, Defect (D) to maximize individual payoff, as collective conservation is no longer relevant.
2. **Ties in Cooperation Rate:** In case of a tie, Cooperate (C) to promote collective sustainability.

**Pseudocode:**
```
function ASC(current_stock, capacity, opponent_cooperation_rate, stock_trend):
  if current_round == 1:
    return C
  elif current_stock < 0.5 * capacity:
    return D
  elif current_stock > 0.75 * capacity:
    return C
  else:
    if opponent_cooperation_rate > 0.5:
      cooperation_threshold += 0.1
    else:
      cooperation_threshold -= 0.1
    
    if stock_trend == decreasing:
      cooperation_threshold -= 0.1
    
    if current_stock < cooperation_threshold * capacity:
      return D
    else:
      return C

function update_ASC(current_stock, opponent_cooperation_rate, stock_trend):
  ASC.opponent_cooperation_rate = opponent_cooperation_rate
  ASC.stock_trend = stock_trend
```
The Adaptive Stock Conservation strategy balances individual payoffs with collective sustainability by adapting to the current game state and history. By adjusting its cooperation threshold based on opponent behaviors and stock trends, ASC promotes a robust and adaptive approach to maintaining a sustainable common pool resource.
'''

description_COLLECTIVE_355 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability, adapting to the game's dynamic state and opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline stock level and encourage cooperation.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play a mixed strategy: cooperate (C) with probability 0.7 and defect (D) with probability 0.3.
	* If the current stock level is below 50% of capacity, defect (D).
3. **Last Round (t=r):** Defect (D) to maximize individual payoff, as the game's end eliminates concerns about future sustainability.

**Adaptive Component:**

1. **Opponent Behavior Monitoring:** Track the proportion of opponents who defected in previous rounds.
2. **Adjustment Mechanism:** If the proportion of opponent defections exceeds 0.5 in any round, increase the probability of defecting (D) by 0.2 in subsequent rounds.

**Pseudocode:**
```python
def ASC(n, capacity, stock, t, r):
    if t == 1:
        return C
    
    stock_ratio = stock / capacity
    opponent_defection_rate = calculate_opponent_defection_rate()
    
    if stock_ratio > 0.75:
        return C
    elif stock_ratio >= 0.5 and stock_ratio <= 0.75:
        p_cooperate = 0.7 - (opponent_defection_rate * 0.2)
        return C with probability p_cooperate, D otherwise
    else:
        return D
    
    if t == r:
        return D

def calculate_opponent_defection_rate():
    # Implement a mechanism to track opponent defections and calculate the proportion of defectors
```
**Collective Mindset:**

The ASC strategy prioritizes cooperation when the stock level is high, encouraging opponents to conserve resources. As the stock level decreases, it adaptively shifts towards defecting, balancing individual payoffs with collective sustainability concerns. By monitoring opponent behavior and adjusting its own strategy, ASC promotes a stable and cooperative environment while being robust against various opponent behaviors.

This strategy will be implemented as an algorithm for the tournament, where it will compete against other independent strategies developed by AI systems.
'''

description_COLLECTIVE_356 = '''
**Collective Strategy: Adaptive Cooperation with Stock Thresholds (ACST)**

ACST is a collective strategy designed for the Common Pool Resource Game. The goal of ACST is to balance individual payoffs with sustainable stock management, ensuring long-term collective benefits.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative baseline.
2. **Stock Thresholds**: Define two stock thresholds: `LowThreshold` and `HighThreshold`.
	* `LowThreshold = capacity / 4`
	* `HighThreshold = 3 * capacity / 4`
3. **Cooperation Conditions**:
	+ If the current stock level is above `HighThreshold`, Cooperate (C).
	+ If the current stock level is below `LowThreshold`, Defect (D) to maximize individual payoff.
	+ If the current stock level is between `LowThreshold` and `HighThreshold`, use a **Modified Tit-for-Tat** approach:
		- Cooperate (C) if at least half of the opponents cooperated in the previous round.
		- Otherwise, Defect (D).
4. **Last Round**: In the final round, Defect (D) to maximize individual payoff.

**Pseudocode**
```python
def ACST(stock, capacity, history):
    low_threshold = capacity / 4
    high_threshold = 3 * capacity / 4

    if stock > high_threshold:
        return 'C'
    elif stock < low_threshold:
        return 'D'
    else:
        # Modified Tit-for-Tat
        opponent_cooperations = sum([1 for action in history[-1] if action == 'C'])
        if opponent_cooperations >= len(history[-1]) / 2:
            return 'C'
        else:
            return 'D'

    # Last round
    if current_round == total_rounds:
        return 'D'
```
**Rationale**

ACST aims to balance cooperation and defection by adjusting behavior based on the stock level. By cooperating when the stock is high, ACST promotes sustainable resource management. When the stock is low, defecting ensures individual payoffs are maximized.

The Modified Tit-for-Tat approach in the middle threshold range allows for adaptability to opponent behaviors while maintaining a cooperative baseline. In the final round, ACST defects to maximize individual payoff, as there are no future rounds to consider.

ACST's design enables it to respond effectively to various opponent strategies and adapt to changing game conditions, making it a robust collective strategy for the Common Pool Resource Game.
'''

description_COLLECTIVE_357 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy balances individual payoff maximization with collective sustainability, ensuring robust performance across various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to encourage cooperation and observe opponents' actions.
2. **Observation Phase (Rounds 2-3):**
	* If all players cooperated in the previous round, cooperate (C).
	* Otherwise, defect (D) with a probability of 0.5 (50% chance). This introduces a moderate level of uncertainty to deter potential defectors.
3. **Adaptive Phase (Rounds 4+):**
	* Calculate the current stock depletion rate: `depletion_rate = (capacity - stock) / capacity`
	* If `depletion_rate` is high (> 0.5), cooperate (C) to conserve stock and promote sustainability.
	* Otherwise, use a probability-based approach:
		+ Cooperate (C) with probability `p_C = 1 - depletion_rate`
		+ Defect (D) with probability `p_D = depletion_rate`

This adaptive mechanism adjusts the strategy based on the current state of the stock and the observed behavior of opponents.

**Edge Cases:**

* **Last Round:** Cooperate (C) in the last round to maximize collective payoff, as individual payoffs are no longer a concern.
* **Stock Depletion:** If the stock is severely depleted (< 0.25 \* capacity), cooperate (C) to prioritize sustainability and potential future cooperation.

**Collective Mindset:**

The ASC strategy prioritizes cooperation when the stock is not heavily depleted and opponents have demonstrated cooperative behavior. However, it adapts to more aggressive play when necessary, balancing individual payoffs with collective sustainability.

Pseudocode:
```markdown
# Initialize variables
stock = capacity
round = 1

while round <= r:
    # First round: Cooperate (C)
    if round == 1:
        action = C
    # Observation phase (Rounds 2-3)
    elif round < 4:
        if all_players_cooperated_last_round:
            action = C
        else:
            action = D with probability 0.5
    # Adaptive phase (Rounds 4+)
    else:
        depletion_rate = (capacity - stock) / capacity
        if depletion_rate > 0.5:
            action = C
        else:
            p_C = 1 - depletion_rate
            p_D = depletion_rate
            action = C with probability p_C, D otherwise

    # Update stock and history
    update_stock(action)
    round += 1

# Last round: Cooperate (C)
if round == r:
    action = C
```
This strategy is designed to be robust against a wide range of opponent behaviors, prioritizing collective sustainability while adapting to changing circumstances.
'''

description_COLLECTIVE_358 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Stock Depletion Threshold**: Define a threshold `θ` as a fraction of the capacity (e.g., θ = 0.5). If the current stock level is below this threshold, Defect (D) to maximize individual payoffs in the short term.
3. **Opponent Behavior Analysis**: Observe the actions of other players in previous rounds and estimate the proportion of Cooperators (`p_C`) and Defectors (`p_D`). Update these estimates after each round using a moving average or exponential smoothing.
4. **Adaptive Cooperation**: If `p_C` is above a certain threshold (e.g., 0.5), Cooperate in the current round to maintain the stock level and encourage cooperation. Otherwise, Defect to maximize individual payoffs.
5. **Last Round**: In the final round, Defect regardless of the stock level or opponent behavior, as there are no future rounds to conserve for.

**Pseudocode**
```python
def ASC(n, capacity, r, current_stock, history):
    # Initial round
    if history is None:
        return C

    # Stock depletion threshold
    θ = 0.5 * capacity
    if current_stock < θ:
        return D

    # Opponent behavior analysis
    p_C, p_D = analyze_opponent_behavior(history)
    if p_C > 0.5:
        return C
    else:
        return D

def analyze_opponent_behavior(history):
    # Update estimates of opponent cooperation and defection rates
    # using a moving average or exponential smoothing
    pass
```
**Edge Cases**

* If the stock level is exactly at the threshold `θ`, the strategy defaults to Defecting.
* In cases where multiple players have the same estimated proportion of Cooperators (`p_C`), the strategy can be modified to use a tiebreaker, such as randomly choosing between Cooperation and Defection.

**Collective Mindset**

The ASC strategy aligns with the collective mindset by:

1. Prioritizing stock conservation when the opponent behavior suggests cooperation.
2. Adapting to changes in opponent behavior to maintain a balance between individual payoffs and collective sustainability.
3. Encouraging cooperation in early rounds to establish a baseline stock level.

By using this adaptive strategy, ASC aims to perform well in a tournament setting against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_359 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACS)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoff.
2. **Subsequent Rounds**: Evaluate the current stock level (`S`) and total consumption from previous rounds (`T`).
	* If `S` is above a certain threshold (`stock_threshold`), cooperate (C). This threshold is calculated based on the game's capacity, number of players, and round number to ensure sustainable exploitation.
	* If `S` falls below the `stock_threshold`, defect (D) to maximize short-term payoff while minimizing further stock depletion.

**Stock Threshold Calculation:**

`stock_threshold = capacity / (2 * n) + (r - t) * (capacity / (n * r))`

Where:

* `t` is the current round number
* `r` is the total number of rounds

This formula adjusts the threshold based on the remaining rounds, encouraging cooperation when the game is far from completion and switching to defection as the endgame approaches.

**Additional Considerations:**

1. **Last Round**: Defect (D) in the last round (`t = r`) to maximize final payoff.
2. **Extreme Stock Levels**:
	* If `S` is very low (< 10% of capacity), defect (D) to avoid further depletion and minimize losses.
	* If `S` is near capacity (> 90%), cooperate (C) to maintain sustainable exploitation.

**Pseudocode:**
```python
def ACS(n, r, capacity, S, t, T):
    if t == 1:
        return C  # Cooperate in the first round
    
    stock_threshold = capacity / (2 * n) + (r - t) * (capacity / (n * r))
    
    if S > stock_threshold:
        return C  # Cooperate above threshold
    else:
        return D  # Defect below threshold

    # Additional considerations
    if t == r:
        return D  # Defect in the last round
    
    if S < 0.1 * capacity:
        return D  # Defect at very low stock levels
    elif S > 0.9 * capacity:
        return C  # Cooperate near full capacity
```
This adaptive strategy balances cooperation and defection based on the current stock level, round number, and game parameters. By adjusting its behavior in response to changing conditions, ACS aims to achieve a high total payoff while maintaining sustainable exploitation of the common pool resource.

As this strategy plays against independent opponents in a tournament setting, it will need to adapt to various behaviors and respond accordingly. The stock-based threshold provides a flexible decision-making framework for navigating different scenarios, ensuring robustness across a wide range of opponent strategies.
'''

description_COLLECTIVE_360 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to reciprocate.
2. **Cooperation Threshold**: Set a dynamic cooperation threshold, `θ`, based on the current stock level (`S`) and the number of players (`n`). `θ` = `S` / (2 \* `n`)
3. **Action Selection**:
	* If the current round's total consumption is below the cooperation threshold (`θ`), Cooperate (C).
	* Otherwise, Defect (D) to avoid over-exploiting the common resource.
4. **Adaptation**: Update `θ` after each round based on the new stock level and the previous round's total consumption.

**Edge Cases**

1. **Last Round**: In the final round, Cooperate (C) if the current stock level is above a certain percentage of the capacity (e.g., 25%). This encourages players to leave some stock for future rounds.
2. **Low Stock Levels**: If the current stock level falls below a critical threshold (e.g., 10% of the capacity), Defect (D) to maximize individual payoff, as cooperation is less likely to yield benefits in this scenario.

**Collective Mindset**

The Adaptive Cooperation strategy prioritizes collective well-being by:

1. Encouraging cooperation when the common resource is plentiful.
2. Adapting to changing stock levels and consumption patterns.
3. Avoiding over-exploitation of the resource, which would harm all players.

By following these rules, AC promotes a balance between individual self-interest and collective sustainability, making it a robust strategy for a wide range of opponent behaviors.

**Pseudocode**

```
AC Strategy

// Initialize variables
θ = capacity / (2 * n)  // cooperation threshold

for each round t:
    if t == 1:  // initial round
        action[t] = C
    else:
        total_consumption[t-1] = calculate_total_consumption(t-1)
        θ[t] = stock[t] / (2 * n)

        if total_consumption[t-1] < θ[t]:
            action[t] = C
        else:
            action[t] = D

        // update cooperation threshold for next round
        θ[t+1] = min(stock[t+1], capacity) / (2 * n)

    // handle edge cases
    if t == r:  // last round
        if stock[t] > 0.25 * capacity:
            action[t] = C

    if stock[t] < 0.1 * capacity:
        action[t] = D
```

Note that this strategy is not foolproof, and its performance may vary depending on the specific opponent strategies and game parameters. However, by prioritizing collective well-being and adapting to changing circumstances, AC provides a robust foundation for success in the Common Pool Resource Game.
'''

description_COLLECTIVE_361 = '''
**Collective Strategy: Adaptive Cooperation with Stock Conservation (ACSC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about other players' behavior.
2. **Stock-Based Cooperation Threshold**: Introduce a dynamic cooperation threshold, `theta`, based on the current stock level (`S`) and capacity (`capacity`). Set `theta` as follows:

`theta = S / (n * capacity)`

Cooperate if `theta >= 0.5`; otherwise, Defect.
3. **Adaptive Response to Opponent Behavior**: Monitor the average opponent payoff from previous rounds (`avg_opponent_payoff`) and adjust the cooperation threshold accordingly.

If `avg_opponent_payoff` is greater than or equal to the average cooperative payoff (i.e., `S / (2 * n)`), decrease `theta` by 0.1; otherwise, increase `theta` by 0.1.
4. **Stock Conservation**: When the stock level falls below a certain threshold (`conservation_threshold = capacity / 2`), switch to Defect to prevent over-exploitation.

**Edge Cases:**

* **Last Round**: Cooperate in the last round if the current stock level is above `conservation_threshold`; otherwise, Defect.
* **Low Stock Levels**: If the stock level falls below `conservation_threshold`, Defect for the remainder of the game.
* **Extreme Opponent Behavior**: If all opponents consistently Defect or Cooperate, adjust the cooperation threshold to mirror their behavior.

**Pseudocode:**
```python
def ACSC(n, capacity, S, round_num, r):
  # Initialize theta and avg_opponent_payoff
  theta = 0.5
  avg_opponent_payoff = 0

  for t in range(1, r + 1):
    if t == 1:  # Initial Round
      action = 'C'
    else:
      # Update theta based on stock level and opponent behavior
      theta = S / (n * capacity)
      if avg_opponent_payoff >= S / (2 * n):
        theta -= 0.1
      else:
        theta += 0.1

      # Choose action based on theta
      if theta >= 0.5:
        action = 'C'
      else:
        action = 'D'

    # Stock conservation check
    if S < capacity / 2:
      action = 'D'

    # Update avg_opponent_payoff and S for next round
    avg_opponent_payoff = (avg_opponent_payoff * (t - 1) + opponent_payoffs[t]) / t
    S = update_stock(S, n, capacity, actions)

  return action
```
**Collective Mindset:**

The ACSC strategy prioritizes cooperation while adapting to the game's dynamic state and opponent behavior. By conserving stock levels and responding to opponents' actions, this strategy promotes a collective mindset that balances individual payoffs with the sustainability of the common pool resource.

This strategy is designed to be robust against various opponent behaviors, including defectors, cooperators, and those who employ mixed strategies. In a tournament setting, ACSC should perform well by balancing cooperation and self-interest while conserving stock levels for future rounds.
'''

description_COLLECTIVE_362 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' initial moves.
2. **Stock-dependent Cooperation:** If the current stock level is above 75% of the capacity, cooperate (C). This encourages sustainability when the stock is relatively high.
3. **Defection Trigger:** If the current stock level falls below 25% of the capacity, defect (D) to maximize individual payoff in a depleted environment.
4. **Adaptive Response:** Observe the average opponent action (AOA) from previous rounds. If AOA ≥ 0.5 (i.e., most opponents cooperated), cooperate (C). Otherwise, defect (D).
5. **Punishment Mechanism:** If an opponent defects while the stock is above 50% of capacity, defect (D) in the next round to discourage opportunistic behavior.

**Edge Case Handling:**

1. **Last Round:** Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.
2. **Low Stock:** If the stock level is critically low (< 10% of capacity), defect (D) to secure any remaining resources.

**Collective Mindset:**

The ASC strategy prioritizes cooperation when the stock is relatively high, acknowledging that collective conservation benefits all players in the long run. By adapting to opponents' actions and the game's state, ASC promotes a balance between individual payoff maximization and sustainable resource management.

**Pseudocode (simplified):**
```
function ASC(current_stock, capacity, opponent_actions):
  if first_round:
    return C
  elif current_stock > 0.75 * capacity:
    return C
  elif current_stock < 0.25 * capacity:
    return D
  else:
    AOA = average_opponent_action(opponent_actions)
    if AOA >= 0.5:
      return C
    else:
      return D

function average_opponent_action(opponent_actions):
  # Calculate the proportion of opponents that cooperated in previous rounds
  cooperation_rate = sum(C in opponent_actions) / len(opponent_actions)
  return cooperation_rate
```
The ASC strategy is designed to be robust and adaptive, allowing it to perform well against a wide range of opponent behaviors while promoting collective sustainability.
'''

description_COLLECTIVE_363 = '''
Here's a collective strategy that I'll call "Adaptive Stock Sensitive Tit-for-Tat" (ASSTT). This strategy aims to balance individual payoff with collective sustainability by adapting to the current stock level and opponent behavior.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation.
2. **Subsequent Rounds:** Observe the previous round's outcome:
	* If the stock level decreased, defect (D) with probability `p_defect = 0.5 * (previous_stock - current_stock) / capacity`. This reflects a willingness to punish over-extraction and encourage cooperation.
	* If the stock level increased or remained stable, cooperate (C).
3. **Stock-Level Thresholds:** Introduce two thresholds:
	+ `low_threshold = 0.25 * capacity`: If the current stock falls below this threshold, defect (D) to prevent stock depletion.
	+ `high_threshold = 0.75 * capacity`: If the current stock exceeds this threshold, cooperate (C) to allow for sustainable growth.
4. **Opponent Behavior Adaptation:** Monitor opponents' actions and adjust the strategy accordingly:
	* If an opponent defects while the stock is below the low threshold, increase `p_defect` by 0.1 to reflect increased competition.
	* If an opponent cooperates while the stock is above the high threshold, decrease `p_defect` by 0.1 to encourage cooperation.

**Pseudocode:**

```
function ASSTT(current_stock, previous_stock, opponents_actions):
  if (first_round):
    return C
  else:
    if (previous_stock < current_stock):
      p_defect = 0
    elif (previous_stock > current_stock):
      p_defect = 0.5 * (previous_stock - current_stock) / capacity
    else:  // stock level stable
      p_defect = 0

    if (current_stock < low_threshold):
      return D
    elif (current_stock > high_threshold):
      return C

    // Adapt to opponent behavior
    for opponent in opponents_actions:
      if (opponent == D and current_stock < low_threshold):
        p_defect += 0.1
      elif (opponent == C and current_stock > high_threshold):
        p_defect -= 0.1

    return random_choice([C, D], [1-p_defect, p_defect])
```

**Edge Cases:**

* Last round: Cooperate (C) to ensure a sustainable final stock level.
* Ties: In case of a tie in the number of cooperators and defectors, cooperate (C).

ASSTT balances individual payoff with collective sustainability by adapting to changes in the stock level and opponent behavior. It encourages cooperation when the stock is abundant and defects when it's scarce, while also punishing over-extraction and rewarding sustainable behavior. This strategy should perform well against a variety of opponents in the tournament.
'''

description_COLLECTIVE_364 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability, adapting to changing game conditions and opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to avoid excessive initial depletion.
2. **Stock Thresholds**: Define two stock thresholds:
	* `sustain_threshold` = 0.5 * capacity (e.g., 50 when capacity = 100)
	* `conservation_threshold` = 0.25 * capacity (e.g., 25 when capacity = 100)

**Cooperation Conditions:**

1. If the current stock is above `sustain_threshold`, Cooperate (C).
2. If the current stock is between `conservation_threshold` and `sustain_threshold`, Defect (D) with a probability of 0.5 (i.e., randomize between C and D).
3. If the current stock is below `conservation_threshold`, Cooperate (C) to prioritize stock recovery.

**Adaptive Adjustment:**

1. **Monitor Opponent Behavior**: Track the average opponent payoff per round (`avg_opponent_payoff`).
2. **Adjust Cooperation Probability**: Based on `avg_opponent_payoff`, adjust the cooperation probability in the middle threshold range:
	* If `avg_opponent_payoff` is high (> 0.75 * capacity/n), decrease cooperation probability to 0.25 (i.e., defect more often).
	* If `avg_opponent_payoff` is low (< 0.25 * capacity/n), increase cooperation probability to 0.75 (i.e., cooperate more often).

**Edge Cases:**

1. **Last Round**: Cooperate (C) in the last round to ensure a sustainable final stock level.
2. **Ties**: In case of ties (e.g., multiple players choosing C or D), use a random tiebreaker.

**Pseudocode:**
```markdown
# Initialize variables
sustain_threshold = 0.5 * capacity
conservation_threshold = 0.25 * capacity
avg_opponent_payoff = 0

# Main loop (each round)
while current_round < total_rounds:
    # Observe current stock and opponent payoffs
    current_stock = get_current_stock()
    avg_opponent_payoff = calculate_avg_opponent_payoff()

    # Determine cooperation probability based on thresholds and opponent behavior
    if current_stock > sustain_threshold:
        cooperate_probability = 1
    elif current_stock >= conservation_threshold:
        cooperate_probability = 0.5 + (avg_opponent_payoff - 0.5) / (capacity / n)
    else:
        cooperate_probability = 1

    # Randomize cooperation decision based on probability
    if random.random() < cooperate_probability:
        action = C
    else:
        action = D

    # Update average opponent payoff and play action
    avg_opponent_payoff = update_avg_opponent_payoff()
    play_action(action)
```
This strategy aims to balance individual payoffs with collective sustainability, adapting to changing game conditions and opponent behaviors. By monitoring opponent behavior and adjusting cooperation probability, ASC encourages cooperation while preventing excessive stock depletion.
'''

description_COLLECTIVE_365 = '''
**Collective Strategy: Adaptive Stock-Based Cooperation (ASBC)**

The ASBC strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and history of opponent actions.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage opponents to reciprocate.
2. **Stock-Based Cooperation Threshold:** Set a dynamic cooperation threshold `τ` based on the current stock level `S`. When `S` is above `τ`, cooperate; otherwise, defect.

`τ = capacity / (2n) * (1 + γ * (S_remaining / capacity))`

where `γ` is an adaptation parameter (e.g., 0.5). This threshold increases as the remaining stock approaches capacity, encouraging cooperation when the stock is healthy.
3. **Opponent Action History:** Monitor opponent actions and adjust the cooperation threshold based on their behavior.

`τ = τ * (1 + δ * (CoopOpponents / n))`

where `δ` is a responsiveness parameter (e.g., 0.2), and `CoopOpponents` is the number of opponents who cooperated in the previous round. This adjustment increases the threshold when most opponents cooperate, encouraging reciprocity.
4. **Last Round:** Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.

**Edge Cases:**

1. **Low Stock:** If the stock level falls below a critical threshold (`capacity / 4`), defect immediately to prevent over-exploitation.
2. **Opponent Homogeneity:** If all opponents consistently cooperate or defect, adjust the cooperation threshold accordingly:

`τ = capacity / (2n) * (1 + γ * (S_remaining / capacity)) * (1 + ε * (HomogeneousOpponents / n))`

where `ε` is a homogeneity parameter (e.g., 0.5), and `HomogeneousOpponents` is the number of opponents who consistently cooperate or defect.

**Collective Mindset:**

The ASBC strategy prioritizes cooperation when the stock level is healthy, encouraging sustainable resource management. By adapting to opponent behavior and adjusting the cooperation threshold, the strategy promotes collective stability while maintaining individual competitiveness.

Pseudocode:
```
initialize τ = capacity / (2n)
for each round t:
  observe current stock S
  observe opponent actions in previous round
  update τ based on stock level and opponent history
  if τ > S:
    cooperate (C)
  else:
    defect (D)
  if last round:
    defect (D)
```
This strategy is designed to be robust against a wide range of opponent behaviors, adapting to the collective dynamics while prioritizing individual payoffs.
'''

description_COLLECTIVE_366 = '''
**Collective Strategy: Adaptive Common Pool Resource Management (ACPRM)**

The ACPRM strategy aims to balance individual payoffs with collective sustainability, adapting to various opponent behaviors and game states.

**Decision Rules:**

1. **Initial Rounds (t ≤ 0.2r):** Cooperate (C) to establish a cooperative tone and allow the stock to grow.
2. **Stock-Dependent Cooperation:** If the current stock level is above a threshold (S ≥ 0.8 \* capacity), cooperate (C). This ensures sustainable consumption and allows for growth.
3. **Defection Threshold:** If the number of defectors in the previous round exceeds a threshold (D_prev ≥ 0.4n), defect (D) to prevent over-exploitation. Monitor opponents' actions to adjust this threshold dynamically.
4. **Adaptive Response:** Based on the average payoff difference between cooperators and defectors in the last few rounds (Δπ_avg = π_C - π_D, averaged over t-1 to t-0.2r), adjust the cooperation probability:
	* If Δπ_avg > 10% of capacity: Increase cooperation probability by 20%.
	* If Δπ_avg < -10% of capacity: Decrease cooperation probability by 20%.
5. **Endgame (t ≥ 0.8r):** Cooperate (C) to ensure a minimum payoff, as the game's end reduces the impact of individual actions on the collective outcome.

**Edge Cases:**

* In the first round (t = 1), cooperate (C) to set a cooperative tone.
* If only one player remains, defect (D) to maximize individual payoff.
* If all players have defected in previous rounds (S ≤ 0.2 \* capacity), cooperate (C) to allow for potential growth.

**Collective Mindset:**

The ACPRM strategy is designed to promote collective sustainability while being adaptive to various opponent behaviors. By initially cooperating and responding to changes in the game state, this strategy aims to balance individual payoffs with the need to maintain a healthy common pool resource.

Pseudocode:
```python
def acprm(n, r, capacity, stock, history):
    # Initialize variables
    cooperation_prob = 1.0  # initial cooperation probability
    defect_threshold = 0.4 * n

    for t in range(1, r+1):
        if t <= 0.2r:  # Initial rounds
            action = 'C'
        elif stock >= 0.8 * capacity:
            action = 'C'  # Stock-dependent cooperation
        elif history['defectors_prev'] >= defect_threshold:
            action = 'D'  # Defection threshold exceeded
        else:
            delta_pi_avg = calculate_average_payoff_difference(history)
            if delta_pi_avg > 0.1 * capacity:
                cooperation_prob += 0.2  # Increase cooperation probability
            elif delta_pi_avg < -0.1 * capacity:
                cooperation_prob -= 0.2  # Decrease cooperation probability
            action = 'C' if random.random() < cooperation_prob else 'D'

        if t >= 0.8r:  # Endgame
            action = 'C'

        return action
```
Note that the pseudocode provides a basic structure for the strategy, and additional implementation details will be required to fully implement the ACPRM algorithm.
'''

description_COLLECTIVE_367 = '''
I propose a collective strategy called "Adaptive Stock Sensitive Tit-for-Tat" (ASST). ASST combines elements of tit-for-tat with adaptive adjustments based on the current stock level and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative baseline.
2. **General Case:** In subsequent rounds, observe the previous round's actions and payoffs.
	* If the average payoff of cooperators is greater than or equal to the average payoff of defectors, cooperate (C).
	* Otherwise, defect (D).
3. **Stock-Dependent Adjustment:**
	* If the current stock level is below 50% of capacity, cooperate (C) regardless of previous payoffs.
	* If the current stock level is above 80% of capacity, defect (D) regardless of previous payoffs.

**Pseudocode:**
```
function ASST(stock, history, round):
    if round == 1:
        return C
    else:
        avg_coop_payoff = average payoff of cooperators in previous round
        avg_defect_payoff = average payoff of defectors in previous round
        
        if stock < 0.5 * capacity:
            return C
        elif stock > 0.8 * capacity:
            return D
        else:
            if avg_coop_payoff >= avg_defect_payoff:
                return C
            else:
                return D
```
**Rationale:**

1. **Initial Cooperation:** Starting with cooperation encourages opponents to reciprocate and builds a cooperative foundation.
2. **Adaptive Adjustment:** By observing previous payoffs, ASST adapts to the current situation, exploiting cooperative opportunities while minimizing losses from defectors.
3. **Stock-Dependent Adjustment:** When the stock is low, cooperating helps replenish it. When the stock is high, defecting allows for greater individual gains without significantly harming the collective.

**Edge Cases:**

1. **Last Round:** ASST behaves as in the general case, ensuring that the last round's actions are consistent with the overall strategy.
2. **Ties:** In cases where average payoffs are equal or difficult to determine, ASST defaults to cooperation (C) to maintain a cooperative stance.

**Collective Mindset:**

ASST prioritizes collective well-being by:

1. Encouraging cooperation when possible
2. Adapting to the current state and history to maximize overall payoffs
3. Balancing individual gains with collective sustainability

By implementing ASST, our AI system will engage in a robust and adaptive strategy that promotes cooperation while being resilient to various opponent behaviors.
'''

description_COLLECTIVE_368 = '''
**Collective Strategy: Adaptive Tit-for-Two-Tats with Stock-Awareness (ATTT-SA)**

The ATTT-SA strategy aims to balance individual payoffs with collective sustainability by adapting to the game's dynamic state and opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and encourage others to follow suit.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of capacity, play C if most opponents (≥ n/2) cooperated in the previous round; otherwise, defect (D).
	* If the current stock level is between 50% and 75% of capacity, play C if at least one opponent defected in the previous round; otherwise, play D.
	* If the current stock level is below 50% of capacity, always play C to promote stock recovery.
3. **Last Round:** Defect (D) in the final round to maximize individual payoff, as there's no future stock impact.

**Pseudocode:**
```
function ATTT-SA(current_stock, previous_actions, n):
    if current_round == 1:
        return C
    elif current_stock >= 0.75 * capacity:
        if most_opponents_cooperated(previous_actions):
            return C
        else:
            return D
    elif 0.5 * capacity <= current_stock < 0.75 * capacity:
        if at_least_one_defected(previous_actions):
            return C
        else:
            return D
    else:  // current_stock < 0.5 * capacity
        return C

function most_opponents_cooperated(previous_actions):
    count = 0
    for action in previous_actions:
        if action == C:
            count += 1
    return count >= n/2

function at_least_one_defected(previous_actions):
    for action in previous_actions:
        if action == D:
            return True
    return False
```
**Collective Mindset:**

The ATTT-SA strategy prioritizes collective sustainability by:

* Encouraging cooperation when the stock level is high to maintain a healthy resource.
* Promoting cooperation when opponents have defected, to signal that cooperation is still valuable and encourage them to adjust their behavior.
* Focusing on individual payoff in the final round, as there's no long-term impact.

This strategy adapts to various opponent behaviors while promoting collective responsibility for the common pool resource. By being sensitive to the game's dynamic state, ATTT-SA aims to balance individual payoffs with collective sustainability, making it a robust and effective collective strategy.
'''

description_COLLECTIVE_369 = '''
I propose a collective strategy called "Adaptive Tit-for-Two-Tat with Stock Conservation" (ATTSC). This strategy aims to balance individual payoffs with long-term sustainability of the common pool resource.

**Decision Rules:**

1. **First Round:** Cooperate (C) to initiate cooperation and observe opponents' behaviors.
2. **Subsequent Rounds:** Observe the previous round's actions and outcomes:
	* If the majority (> 50%) of players cooperated, cooperate (C).
	* If the majority defected or played mixed strategies, play Tit-for-Tat with a twist: defect (D) if any player defected in the previous round, otherwise cooperate (C). This encourages cooperation while punishing defection.
3. **Stock Conservation:** When the stock level falls below 50% of capacity, switch to cooperate (C) regardless of opponents' actions. This ensures that the common pool resource is not over-exploited.
4. **Last Round:** Defect (D) to maximize individual payoff, as there are no future rounds to consider.

**Pseudocode:**
```python
def ATTSC(stock, capacity, n, history):
  if round == 1:
    return 'C'  # Cooperate in the first round

  majority_cooperated = sum(1 for action in history[-1] if action == 'C') > n/2
  if majority_cooperated:
    return 'C'
  else:
    any_defected = any(action == 'D' for action in history[-1])
    if any_defected:
      return 'D'  # Tit-for-Tat with a twist
    else:
      return 'C'

  if stock < 0.5 * capacity:
    return 'C'  # Stock Conservation

  if round == r:  # Last Round
    return 'D'
```
**Collective Mindset:** ATTSC is designed to promote cooperation while adapting to various opponent behaviors. By cooperating in the first round and responding to opponents' actions, we encourage mutual cooperation. The Tit-for-Tat component with a twist punishes defection while allowing for forgiveness. Stock Conservation ensures that the common pool resource is not over-exploited, aligning individual interests with collective sustainability.

This strategy should perform well against independent strategies in the tournament, as it balances short-term gains with long-term sustainability and adapts to various opponent behaviors.
'''

description_COLLECTIVE_370 = '''
**Collective Strategy: Adaptive Cooperation with Stock Threshold (ACST)**

**Overview**
The ACST strategy aims to balance individual payoff maximization with collective sustainability by adapting cooperation levels based on the current stock level and game history.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and avoid early stock depletion.
2. **Stock Threshold**: Define a stock threshold, `stock_threshold = 0.5 * capacity`. If the current stock level is above this threshold, cooperate (C). Otherwise, defect (D).
3. **Recent Defection**: Monitor the number of defections in the last `k` rounds (`k` is a parameter, e.g., `k=2`). If more than half of the players defected in the recent past, switch to defecting (D) for one round to signal dissatisfaction and encourage cooperation.
4. **Sustainability Check**: After each round, assess the stock growth from the previous round. If the growth is negative or zero, indicating over-consumption, cooperate (C) in the next round to allow the stock to recover.

**Pseudocode**
```python
def ACST(n, capacity, r, history):
  # Initialize parameters
  k = 2  # recent defection window size
  stock_threshold = 0.5 * capacity

  for t in range(r):
    # Get current state and history
    current_stock = get_current_stock()
    previous_actions = get_previous_actions(history)

    if t == 0:  # Initial round
      action = 'C'
    elif current_stock > stock_threshold:
      action = 'C'
    elif count_defections(previous_actions, k) > n/2:
      action = 'D'  # Signal dissatisfaction and encourage cooperation
    elif get_stock_growth(history[-1]) <= 0:
      action = 'C'  # Allow stock to recover
    else:
      action = 'D'

    return action
```
**Collective Mindset**
The ACST strategy is designed to promote collective sustainability while being robust to various opponent behaviors. By adapting cooperation levels based on the current stock level and game history, we aim to maintain a healthy balance between individual payoffs and collective resource management.

**Edge Cases**

* **Last Round**: The strategy does not require special handling for the last round, as it focuses on maintaining a sustainable stock level throughout the game.
* **Early Stock Depletion**: If the stock is depleted early in the game, the strategy will adapt to defecting (D) to maximize individual payoffs.

The ACST strategy should perform well in a tournament setting against independent strategies, as it balances cooperation and defection based on the current state of the game.
'''

description_COLLECTIVE_371 = '''
**Collective Strategy: Adaptive Cooperation**

Our collective strategy aims to balance individual payoffs with collective sustainability, adapting to the game's state and history. We prioritize cooperation while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative tone and maximize initial payoffs.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, cooperate (C).
	* If the stock level is between 50% and 75% of capacity, defect (D) with probability p = (capacity - stock) / (0.25 \* capacity), otherwise cooperate (C).
	* If the stock level is below 50% of capacity, defect (D) to maximize individual payoffs in a depleted environment.
3. **Last Round (t=r):** Defect (D) to maximize individual payoffs, as there are no future rounds to consider.

Pseudocode:
```
if t == 1:  # Initial round
    action = C
elif stock >= 0.75 * capacity:  # Stock is high
    action = C
elif 0.5 * capacity <= stock < 0.75 * capacity:  # Stock is moderate
    p = (capacity - stock) / (0.25 * capacity)
    if random() < p:
        action = D
    else:
        action = C
else:  # Stock is low
    action = D

if t == r:  # Last round
    action = D
```
**Rationale:**

1. Cooperating in the initial round sets a positive tone and encourages others to cooperate.
2. When the stock level is high, cooperation maintains a sustainable environment and maximizes collective payoffs.
3. In moderate stock conditions, we introduce a probabilistic defect mechanism to adapt to potential non-cooperative behaviors while still cooperating with some probability.
4. When the stock level is low, defecting becomes more attractive to maximize individual payoffs in a depleted environment.
5. Defecting in the last round ensures maximizing individual payoffs without worrying about future consequences.

**Collective Mindset:**

Our strategy prioritizes cooperation when possible, while adapting to potential non-cooperative behaviors and environmental conditions. By balancing individual payoffs with collective sustainability, we aim to create a mutually beneficial environment for all players.
'''

description_COLLECTIVE_372 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective stock conservation, adapting to the game's dynamic state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative baseline and encourage others to follow suit.
2. **Stock Conservation**: If the current stock level is below 50% of the capacity, cooperate (C) to reduce consumption and allow the stock to recover.
3. **Adaptive Threshold**: Calculate an adaptive threshold (AT) based on the game's history:
	* AT = (average stock level over the last 3 rounds) / capacity
	* If AT < 0.5, cooperate (C); otherwise, defect (D)
4. **Exploitation Detection**: Monitor opponents' actions and detect exploitation:
	* If more than 50% of opponents defected in the previous round, defect (D) to avoid being taken advantage of.
5. **Endgame Strategy**: In the last 10% of rounds, cooperate (C) to ensure a stable stock level for the final rounds.

**Pseudocode:**
```
function ASC(stock_level, capacity, history):
  if current_round == 1:
    return COOPERATE
  elif stock_level < 0.5 * capacity:
    return COOPERATE
  else:
    AT = calculate_adaptive_threshold(history)
    if AT < 0.5:
      return COOPERATE
    elif opponents_defected > 0.5 * num_opponents:
      return DEFECT
    elif current_round >= 0.9 * total_rounds:
      return COOPERATE
    else:
      return DEFECT

function calculate_adaptive_threshold(history):
  average_stock_level = sum(stock_levels_last_3_rounds) / 3
  AT = average_stock_level / capacity
  return AT
```
**Collective Mindset:**

The ASC strategy prioritizes collective stock conservation while adapting to individual opponents' behaviors. By cooperating when the stock is low or when opponents are cooperative, ASC encourages a stable and sustainable game environment. The adaptive threshold allows ASC to adjust its behavior based on the game's history, making it robust against various opponent strategies.

By implementing this collective strategy, we can promote cooperation and minimize the risk of stock depletion, ultimately leading to better payoffs for all players in the tournament.
'''

description_COLLECTIVE_373 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoff.
2. **Subsequent Rounds:** Calculate the current stock level's deviation from capacity, normalized by the number of players (n). Let `deviation = (capacity - stock) / n`.
3. **Cooperation Threshold:** Set a dynamic cooperation threshold (`θ`) based on the current round (`t`) and total rounds (`r`). `θ = 0.5 + (0.2 * t/r)`. This threshold increases as the game progresses, reflecting the growing importance of conservation.
4. **Action Selection:**
	* If `deviation ≤ θ`, Cooperate (C). The stock level is deemed sufficient to support cooperation.
	* Otherwise, Defect (D). The stock level is too low, and defecting may ensure a larger payoff.

**Edge Cases:**

1. **Last Round:** Defect (D) in the last round (`t = r`). With no future rounds, conservation becomes less important, and maximizing immediate payoff takes priority.
2. **Stock Depletion:** If `stock ≤ 0`, Defect (D). When the stock is depleted, cooperation offers no benefits.

**Collective Mindset:**

ACSDT aligns with a collective mindset by:

1. Initially cooperating to establish a cooperative tone.
2. Adapting to changes in the stock level and round number, reflecting the dynamic nature of the game.
3. Considering the impact of individual actions on the collective payoff.
4. Prioritizing cooperation when the stock level is sufficient, promoting sustainability.

**Pseudocode:**
```python
def ACSDT(stock, capacity, n, t, r):
    if t == 1:  # Initial Round
        return "C"
    
    deviation = (capacity - stock) / n
    theta = 0.5 + (0.2 * t/r)
    
    if deviation <= theta:
        return "C"  # Cooperate
    elif stock <= 0 or t == r:  # Last Round or Stock Depletion
        return "D"  # Defect
    else:
        return "D"  # Defect
```
This strategy balances individual payoff maximization with collective sustainability, adapting to changing game conditions while promoting cooperation when feasible.
'''

description_COLLECTIVE_374 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Trigger (ACST)**

ACST is a dynamic, collective strategy that balances cooperation and defection based on the current stock level and the history of opponent actions. The goal is to maintain a sustainable stock level while adapting to various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for the game.
2. **Stock-Based Trigger:** If the current stock level (`S`) is above a certain threshold (`T`), calculated as `T = capacity / 2`, cooperate (C). Otherwise, defect (D).
3. **Opponent Action Adaptation:** Monitor the opponent's actions and adjust the strategy based on their behavior.
	* If an opponent defects (D) in the previous round, and the stock level is above the threshold (`S > T`), cooperate (C) to maintain a sustainable stock level.
	* If an opponent cooperates (C) in the previous round, and the stock level is below the threshold (`S ≤ T`), defect (D) to maximize individual payoff.
4. **Last Round:** In the final round, always defect (D) to maximize individual payoff.

**Pseudocode:**
```python
def ACST(current_stock, capacity, opponent_actions):
    # Initial Round
    if current_round == 1:
        return 'C'

    # Stock-Based Trigger
    threshold = capacity / 2
    if current_stock > threshold:
        action = 'C'
    else:
        action = 'D'

    # Opponent Action Adaptation
    opponent_last_action = opponent_actions[-1]
    if opponent_last_action == 'D' and current_stock > threshold:
        action = 'C'
    elif opponent_last_action == 'C' and current_stock <= threshold:
        action = 'D'

    # Last Round
    if current_round == total_rounds:
        return 'D'

    return action
```
**Rationale:**

1. **Initial Cooperation:** Establish a baseline for the game by cooperating in the first round, which encourages opponents to cooperate as well.
2. **Stock-Based Trigger:** The threshold (`T`) is set at half the capacity to ensure that the stock level remains sustainable while allowing for some flexibility.
3. **Opponent Action Adaptation:** Monitor opponent actions and adjust the strategy accordingly to balance cooperation and defection.
4. **Last Round Defection:** Maximize individual payoff in the final round by always defecting.

**Collective Mindset:**

ACST is designed to promote collective sustainability while adapting to various opponent behaviors. By cooperating when the stock level is high and defecting when it's low, ACST encourages opponents to cooperate as well, maintaining a sustainable stock level over time. This strategy balances individual payoff maximization with collective sustainability, aligning with the collective mindset.

**Robustness:**

ACST is robust against various opponent strategies due to its adaptability:

1. **Against Cooperators:** ACST will maintain cooperation when opponents cooperate.
2. **Against Defectors:** ACST will adapt by defecting when opponents defect, minimizing losses.
3. **Against Mixed Strategies:** ACST's adaptability allows it to respond effectively to mixed strategies.

By implementing ACST, the strategy will perform well in a tournament against independent AI systems with diverse behaviors.
'''

description_COLLECTIVE_375 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Sensitive Threshold (ACST)**

**Decision Rules:**

1. **Initial Rounds (t = 1 to min(r/2, 5))**: Cooperate (C) to establish a positive reputation and build trust among players.
2. **Stock Assessment**: Evaluate the current stock level (S) relative to capacity (capacity).
	* If S > 0.7 \* capacity, cooperate (C) to maintain a healthy stock level.
	* If 0.3 \* capacity ≤ S ≤ 0.7 \* capacity, use a mixed strategy:
		+ Cooperate (C) with probability p = (S / capacity)^2
		+ Defect (D) with probability 1 - p
	* If S < 0.3 \* capacity, defect (D) to maximize individual payoff in a depleted stock scenario.
3. **Opponent Behavior Analysis**: Observe the actions of other players and update a "cooperation score" for each opponent:
	+ Increment cooperation score by 1 when an opponent cooperates
	+ Decrement cooperation score by 2 when an opponent defects
4. **Adaptive Response**: Based on the cooperation scores, adjust the decision rule thresholds:
	* If most opponents (≥ n/2) have a positive cooperation score, decrease the stock assessment threshold to 0.6 \* capacity.
	* If most opponents (< n/2) have a non-positive cooperation score, increase the stock assessment threshold to 0.8 \* capacity.

**Edge Cases:**

1. **First Round**: Cooperate (C) as described in decision rule 1.
2. **Last Round (t = r)**: Defect (D) to maximize individual payoff since there are no future rounds to consider.
3. **Ties in Cooperation Score**: In case of a tie, maintain the current threshold.

**Pseudocode:**
```
initialize cooperation scores for all opponents

for t = 1 to r:
    if t ≤ min(r/2, 5):
        action = C
    else:
        assess stock level S relative to capacity
        if S > 0.7 * capacity:
            action = C
        elif 0.3 * capacity ≤ S ≤ 0.7 * capacity:
            p = (S / capacity)^2
            action = random_choice(C, D, p)
        else:
            action = D

    observe opponents' actions and update cooperation scores
    adapt thresholds based on cooperation scores

    if t == r:
        action = D

return action
```
This strategy balances individual self-interest with collective responsibility, adapting to the game's state and opponent behaviors. By considering both stock levels and opponent cooperation scores, ACST aims to maintain a healthy stock level while maximizing individual payoffs in a dynamic and uncertain environment.
'''

description_COLLECTIVE_376 = '''
**Collective Strategy: Adaptive Cooperation with Stock-based Trigger (ACST)**

ACST is a collective strategy that balances individual self-interest with long-term sustainability of the common pool resource. It adapts to changing stock levels and opponent behaviors while promoting cooperation.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' strategies.
2. **Stock-based Trigger**: If the current stock level is above a certain threshold (`stock_threshold`), calculated as `capacity / 2`, cooperate (C). This ensures that when the stock is abundant, players contribute to its sustainability.
3. **Opponent Behavior-based Adaptation**: Monitor the opponent's previous actions and adjust your strategy accordingly:
	* If an opponent has defected (D) in the previous round, defect (D) in the current round to punish non-cooperative behavior.
	* If an opponent has cooperated (C) in the previous round, cooperate (C) in the current round to reinforce cooperative behavior.
4. **Stock Depletion Response**: If the stock level falls below a certain threshold (`stock_alarm`), calculated as `capacity / 4`, defect (D) to maximize individual payoff in the short term.

**Edge Cases:**

1. **Last Round**: In the final round, defect (D) to maximize individual payoff, regardless of previous actions or stock levels.
2. **Tie-breaking**: If multiple opponents have defected in the previous round, prioritize punishing the opponent with the highest cumulative payoff.

**Pseudocode:**
```markdown
function ACST(stock, capacity, n, r, history):
  // Initialize variables
  stock_threshold = capacity / 2
  stock_alarm = capacity / 4

  // First round cooperation
  if current_round == 1:
    return C

  // Stock-based trigger
  if stock > stock_threshold:
    return C

  // Opponent behavior-based adaptation
  opponent_actions = history[-1]
  for opponent in opponents:
    if opponent_actions[opponent] == D:
      return D
    elif opponent_actions[opponent] == C:
      return C

  // Stock depletion response
  if stock < stock_alarm:
    return D

  // Last round maximization
  if current_round == r:
    return D

  // Tie-breaking (optional)
  # Implement tie-breaking logic here

  // Default action (cooperation)
  return C
```
**Collective Mindset:**

ACST promotes a collective mindset by:

1. Encouraging cooperation when the stock is abundant, ensuring long-term sustainability.
2. Adapting to opponent behaviors to maintain a balance between cooperation and self-interest.
3. Responding to stock depletion by prioritizing individual payoffs in the short term.

By incorporating these elements, ACST aims to achieve a robust and adaptive collective strategy that can perform well against various independent strategies in a tournament setting.
'''

description_COLLECTIVE_377 = '''
I propose a collective strategy called "Adaptive Stock Sensitive Tit-for-Tat with Exploration" (ASSTTE). This strategy aims to balance cooperation and defection while adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation.
2. **Subsequent Rounds:** Assess the current stock level (S) and the average payoff per player (APP) from the previous round.

a. If S > capacity/2:
	* If APP ≥ stock/(2n), cooperate (C).
	* Else, defect (D).
b. If S ≤ capacity/2:
	* If APP < stock/(2n), cooperate (C) with a probability p = (S/capacity)^2.
	* Else, defect (D).

**Exploration Mechanism:**

* Introduce a random exploration component to adapt to changing opponent behaviors and avoid getting stuck in suboptimal equilibria. With a small probability ε (e.g., 0.1), randomly choose an action (C or D) regardless of the decision rule outcome.

**Edge Cases:**

* **Last Round:** Defect (D) in the last round, as there is no future benefit to cooperation.
* **Stock Depletion:** If the stock level falls below a certain threshold (e.g., capacity/4), cooperate (C) with high probability (e.g., 0.9) to help replenish the stock.

**Pseudocode:**

```
ASSTTE Strategy:
Input: current_stock, previous_round_payoffs, round_number
Output: action (C or D)

if round_number == 1:
    return C

average_payoff_per_player = calculate_APP(previous_round_payoffs)
if current_stock > capacity/2:
    if average_payoff_per_player >= stock/(2n):
        return C
    else:
        return D
else:
    p = (current_stock/capacity)^2
    if random.random() < ε:
        # Exploration mechanism
        return random.choice([C, D])
    elif average_payoff_per_player < stock/(2n):
        return C with probability p
    else:
        return D

if current_stock < capacity/4:
    # Stock depletion case
    return C with high probability (e.g., 0.9)

# Last round handling
if round_number == r:
    return D
```

**Collective Mindset:**

ASSTTE aims to create a collective mindset by:

* Cooperating when the stock level is high and average payoffs are satisfactory, promoting mutual benefit.
* Adapting to changing opponent behaviors through exploration and adjusting cooperation levels based on the game's state.
* Prioritizing stock replenishment when depletion occurs, ensuring long-term sustainability.

By following this strategy, ASSTTE should be able to adapt to various opponent behaviors while maintaining a balance between cooperation and defection.
'''

description_COLLECTIVE_378 = '''
I propose a collective strategy called "Adaptive Tit-for-Two-Stocks" (ATTS) that balances individual payoffs with long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round:** Cooperate (C)
2. **Subsequent Rounds:** Observe the previous round's actions and payoffs.
	* If the stock level is above 75% of capacity, cooperate (C).
	* If the stock level is between 50% and 75% of capacity:
		+ If at least two players cooperated in the previous round, cooperate (C).
		+ Otherwise, defect (D) with a probability of 0.5.
	* If the stock level is below 50% of capacity:
		+ If at least one player defected in the previous round, defect (D).
		+ Otherwise, cooperate (C) with a probability of 0.5.
3. **Last Round:** Defect (D)

**Edge Cases:**

* If all players have defected for two consecutive rounds, switch to always cooperating (C) to try to recover the stock level.
* If the stock level reaches zero, always cooperate (C) until the game ends.

**Rationale:**

1. Initially cooperating sets a positive tone and encourages others to cooperate.
2. When the stock is abundant (> 75% capacity), cooperation is more likely to sustain it.
3. In moderate stock conditions (50-75%), ATTS checks for cooperation in the previous round. If at least two players cooperated, it's likely that cooperation will continue, so ATTS cooperates as well. Otherwise, it randomizes between cooperating and defecting to encourage others to cooperate.
4. When the stock is low (< 50% capacity), ATTS becomes more cautious. If at least one player defected in the previous round, ATTS assumes the game has become competitive and defects to maximize its payoff. Otherwise, it randomizes between cooperating and defecting to avoid exploitation.
5. In the last round, defection ensures a higher individual payoff regardless of others' actions.

**Collective Mindset:**

ATTS aims to balance individual self-interest with collective sustainability by:

* Encouraging cooperation when the stock is abundant
* Gradually adapting to changing game conditions and opponents' behaviors
* Avoiding exploitation by defecting in low-stock situations or when opponents have defected previously

By being responsive to both individual payoffs and collective outcomes, ATTS should perform well in a tournament against diverse strategies.
'''

description_COLLECTIVE_379 = '''
I'll introduce a collective strategy for this Common Pool Resource Game that adapts to various opponent behaviors while prioritizing sustainability and robustness. I call it "Adaptive Sustainability Strategy" (ASS).

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round, as there's no prior information about opponents' strategies.
2. **Early Rounds**: If the current stock level is above 75% of the capacity and the number of previous rounds is less than half of the total rounds (r), cooperate (C). This encourages initial sustainability while allowing for moderate exploitation.
3. **Middle Rounds**: As the game progresses, monitor the average payoff per player (APP) over the past few rounds (e.g., 5-10% of r). If APP is above a threshold (e.g., 75% of maximum possible payoff), continue to cooperate (C). This maintains sustainability while allowing for some growth.
4. **Late Rounds**: When the current stock level falls below 50% of capacity or there are fewer than half of the total rounds remaining, switch to defecting (D) if your own average payoff is below the threshold mentioned in step 3. This ensures you don't miss out on opportunities as the game winds down.
5. **Critical Stock Levels**: If the current stock level falls below 25% of capacity or the growth rate becomes negative, cooperate (C) to help replenish the stock and prevent depletion.

**Edge Cases:**

1. **Last Round**: In the final round, always defect (D), as there's no future payoff to consider.
2. **Opponent Behavior Detection**: Monitor opponents' strategies over time. If an opponent consistently defects (D), you may choose to adapt by defecting more frequently or earlier in the game.

**Pseudocode:**

```python
def adaptive_sustainability_strategy(current_stock, round_number, total_rounds, capacity):
  # Initial Round
  if round_number == 1:
    return 'C'

  # Early Rounds
  if current_stock >= 0.75 * capacity and round_number < total_rounds / 2:
    return 'C'

  # Middle Rounds
  avg_payoff = calculate_average_payoff_per_player()
  if avg_payoff > threshold (e.g., 0.75):
    return 'C'
  
  # Late Rounds
  if current_stock < 0.5 * capacity or round_number > total_rounds / 2:
    if own_avg_payoff < threshold:
      return 'D'

  # Critical Stock Levels
  if current_stock < 0.25 * capacity or growth_rate < 0:
    return 'C'
  
  return 'C'  # Default: cooperate

def calculate_average_payoff_per_player():
  # Calculate average payoff over past few rounds (e.g., 5-10% of total_rounds)
```

**Collective Mindset Alignment:**

The Adaptive Sustainability Strategy prioritizes sustainability while allowing for growth and adaptation to opponent behaviors. It encourages cooperation in early rounds, gradually shifts toward defecting as the game progresses, and responds to critical stock levels to prevent depletion. By monitoring opponents' strategies and adjusting its own behavior, ASS promotes a balance between individual gain and collective well-being.

This strategy should perform well against independent opponents with varying degrees of cooperation and defection, while maintaining robustness in different game scenarios.
'''

description_COLLECTIVE_380 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' behavior.
2. **Subsequent Rounds**:
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of the capacity, play a mixed strategy: Cooperate with probability p = (current stock level / capacity)^(1/n), where n is the number of players. Defect (D) otherwise.
	* If the current stock level is below 50% of the capacity, defect (D).
3. **Last Round**: Cooperate (C) in the last round to avoid over-exploitation and maximize final payoffs.

**Adaptation Mechanism:**

1. Monitor opponents' behavior by tracking the average cooperation rate of all players.
2. If the average cooperation rate is above 75%, increase the cooperation probability p by 10% in subsequent rounds.
3. If the average cooperation rate is below 25%, decrease the cooperation probability p by 10% in subsequent rounds.

**Collective Mindset:**

The ASC strategy prioritizes collective sustainability over individual short-term gains. By adapting to the current stock level and opponents' behavior, it balances cooperation and defection to maintain a stable common pool resource.

**Pseudocode (Simplified)**

```
function AdaptiveStockConservation(stock, capacity, n, round):
  if round == 1:
    return C
  elif stock >= 0.75 * capacity:
    return C
  elif stock >= 0.5 * capacity:
    p = (stock / capacity)^(1/n)
    return random.choice([C, D], p=[p, 1-p])
  else:
    return D

function UpdateProbability(average_cooperation_rate):
  if average_cooperation_rate > 0.75:
    p += 0.10
  elif average_cooperation_rate < 0.25:
    p -= 0.10
```

**Edge Cases:**

* If the current stock level is exactly at the capacity, cooperate (C) to avoid over-exploitation.
* If an opponent's action is not observed or is ambiguous, assume they cooperated (C).

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to changing game conditions and opponents' behavior.
'''

description_COLLECTIVE_381 = '''
To design a collective strategy for this game that is adaptive and robust to various opponent behaviors, I propose the following approach:

**Strategy Name:** Adaptive Collective Balance (ACB)

**Decision Rules:**

1. **Initial Round**: In the first round, cooperate (C) to establish a baseline of trust and observe how other players behave.
2. **Subsequent Rounds**: For each subsequent round, calculate the average stock depletion rate over the last few rounds (e.g., 3-5 rounds). If the average depletion rate is above a certain threshold (e.g., 20% of capacity), defect (D) to avoid being exploited by others. Otherwise, cooperate (C).
3. **Stock Level Threshold**: Monitor the current stock level and adjust behavior accordingly:
	* If the stock level falls below 25% of capacity, always defect (D) to maximize individual payoff.
	* If the stock level is between 25% and 50% of capacity, play a mixed strategy: cooperate (C) with probability p = (stock level / capacity)^2, and defect (D) otherwise. This allows for some cooperation while being cautious about potential exploitation.
4. **Opponent Behavior Adaptation**: Observe the actions of other players over time and adjust behavior accordingly:
	* If most opponents (>50%) cooperate in a round, increase the likelihood of cooperating (C) in subsequent rounds by 10%.
	* If most opponents (>50%) defect in a round, decrease the likelihood of cooperating (C) in subsequent rounds by 20%.

**Edge Cases:**

1. **Last Round**: In the final round, always defect (D) to maximize individual payoff.
2. **Critical Stock Levels**: If the stock level falls below 10% of capacity or exceeds 90% of capacity, adjust behavior as follows:
	+ Below 10%: Defect (D) to avoid complete depletion.
	+ Above 90%: Cooperate (C) to prevent over-exploitation.

**Collective Mindset Alignment:**

1. **Balance Cooperation and Self-Interest**: ACB balances the need for cooperation with individual self-interest, aiming to maintain a sustainable stock level while also maximizing payoffs.
2. **Adaptation to Opponent Behavior**: By observing opponent actions and adjusting behavior accordingly, ACB promotes a collective mindset that responds to changing circumstances.

Pseudocode:
```
function adaptive_collective_balance(n, r, capacity, current_stock, round_num, history) {
  if (round_num == 1) { // Initial Round
    return COOPERATE;
  }

  avg_depletion_rate = calculate_avg_depletion_rate(history);
  if (avg_depletion_rate > threshold) { // Defect to avoid exploitation
    return DEFECT;
  }

  stock_level_ratio = current_stock / capacity;
  if (stock_level_ratio < 0.25) { // Stock level too low, defect
    return DEFECT;
  } else if (stock_level_ratio >= 0.25 && stock_level_ratio <= 0.5) { // Mixed strategy
    cooperate_prob = pow(stock_level_ratio, 2);
    return random_choose(cooperate_prob); // Cooperate or defect based on probability
  }

  opponent_cooperation_rate = calculate_opponent_cooperation_rate(history);
  if (opponent_cooperation_rate > 0.5) {
    increase_cooperation_likelihood(10%);
  } else {
    decrease_cooperation_likelihood(20%);
  }

  return COOPERATE;
}
```
Note that the specific threshold values, probabilities, and cooperation/defection likelihood adjustments can be fine-tuned through simulation or experimentation to optimize performance in various scenarios.
'''

description_COLLECTIVE_382 = '''
**Collective Strategy: "Adaptive Sustainability" (AS)**

The Adaptive Sustainability strategy aims to balance individual payoffs with collective sustainability, ensuring a robust and adaptive approach that responds to various opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Stock-Based Threshold**: Calculate a dynamic threshold `θ` based on the current stock level `S` and capacity `c`: `θ = S / c`. If `θ ≥ 0.5`, cooperate; otherwise, defect.
3. **Opponent Behavior Analysis**: Monitor the actions of other players in previous rounds. If the majority (≥50%) of opponents defected in the last round, defect in the current round. Otherwise, cooperate.
4. **Self-Interest Trigger**: If your total payoff over the past `r/2` rounds is below a certain percentage (e.g., 25%) of the maximum possible payoff, switch to defection for the next round.

**Pseudocode:**
```python
def adaptive_sustainability(current_stock, capacity, opponent_actions, my_payoffs):
    # Initial Round
    if current_round == 1:
        return COOPERATE

    # Stock-Based Threshold
    θ = current_stock / capacity
    if θ >= 0.5:
        return COOPERATE

    # Opponent Behavior Analysis
    majority_defected = sum(opponent_actions[-1:]) >= len(opponent_actions) / 2
    if majority_defected:
        return DEFECT

    # Self-Interest Trigger
    past_payoffs = my_payoffs[-r//2:]
    avg_past_payoff = sum(past_payoffs) / len(past_payoffs)
    max_possible_payoff = capacity / (2 * num_players)
    if avg_past_payoff < 0.25 * max_possible_payoff:
        return DEFECT

    # Default to Cooperation
    return COOPERATE
```
**Handling Edge Cases:**

* In the last round, prioritize self-interest and defect to maximize individual payoff.
* If an opponent's action is unknown or unobserved, assume they will defect.

**Collective Mindset:**
The Adaptive Sustainability strategy aligns with a collective mindset by:

1. Prioritizing cooperation when the stock level is sufficient (θ ≥ 0.5).
2. Responding to opponent behavior and adapting to maintain sustainability.
3. Balancing individual self-interest with collective sustainability.

By incorporating these elements, the AS strategy promotes a robust and adaptive approach that balances individual payoffs with collective sustainability, making it an effective competitor in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_383 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules**

1. **Initial Round (t=1)**:
	* Cooperate (C) if stock is above 75% of capacity.
	* Defect (D) otherwise.
2. **Subsequent Rounds (t>1)**:
	* If average payoff per player in the previous round is below 50% of the maximum possible payoff (i.e., π_i < 0.5 \* S/n), defect (D).
	* Otherwise, cooperate (C) if the current stock level is above 75% of capacity.
3. **Low Stock Levels**:
	* If the current stock level falls below 25% of capacity, cooperate (C) to conserve stock and allow for growth.

Pseudocode for the decision rules:

```
if t == 1:
    if stock > 0.75 * capacity:
        action = C
    else:
        action = D
else:
    avg_payoff_prev_round = calculate_average_payoff(t-1)
    if avg_payoff_prev_round < 0.5 * (stock / n):
        action = D
    elif stock > 0.75 * capacity:
        action = C
    else:
        action = D

if stock < 0.25 * capacity:
    action = C
```

**Additional Considerations**

* **Stock Growth**: If the stock growth in the previous round was high (> 10% of capacity), cooperate (C) to sustain the growth.
* **Opponent Behavior**: Monitor opponent actions and adjust the decision rules accordingly. For example, if most opponents are cooperating, consider cooperating as well to maintain a stable stock level.

**Collective Mindset**

The ASC strategy prioritizes collective sustainability while allowing for individual flexibility. By adapting to the game's state and history, it promotes cooperation when beneficial and defects when necessary to prevent over-exploitation. This approach ensures that the collective payoff is maximized while maintaining a healthy stock level.

**Robustness and Adaptability**

The ASC strategy is designed to be robust against various opponent behaviors and adaptable to changing game conditions. By considering both individual payoffs and collective sustainability, it balances short-term gains with long-term stability.
'''

description_COLLECTIVE_384 = '''
**Collective Strategy: Adaptive Cooperation**

Our collective strategy, "Adaptive Cooperation," aims to balance individual payoffs with the long-term sustainability of the common pool resource. We'll use a combination of cooperation and defection, adapting our behavior based on the game's state and history.

**Decision Rules:**

1. **Initial Rounds (t = 1 to 5):** Cooperate (C) to establish a baseline level of trust and explore opponents' behaviors.
2. **Exploitation Detection:** Monitor the average payoff per player in previous rounds. If the average payoff is below 75% of the maximum possible payoff (i.e., stock/(2n)), suspect exploitation by other players and Defect (D) for one round to punish them.
3. **Stock Depletion:** If the current stock level falls below 25% of capacity, Defect (D) to maximize individual payoffs before the resource is depleted.
4. **Cooperation Incentive:** When the current stock level exceeds 75% of capacity and at least half of the players cooperated in the previous round, Cooperate (C) to maintain a healthy stock level and encourage others to cooperate.
5. **Default Behavior:** Otherwise, Defect (D) to ensure individual payoffs are not compromised.

**Edge Cases:**

* **Last Round (t = r):** Defect (D) to maximize individual payoff, as there's no future benefit from cooperation.
* **Low Stock Levels (stock < 10% of capacity):** Defect (D) to quickly deplete the remaining resource and end the game.

**Collective Mindset:**

Our strategy prioritizes cooperation when it benefits the collective good, while adapting to potential exploitation by others. By balancing individual payoffs with long-term sustainability, we aim to achieve a mutually beneficial outcome for all players.

Pseudocode:
```markdown
function AdaptiveCooperation(stock, capacity, n, t, history) {
  if (t <= 5) { // Initial rounds
    return C;
  } else if (avgPayoff(history) < 0.75 * stock / (2n)) { // Exploitation detection
    return D;
  } else if (stock < 0.25 * capacity) { // Stock depletion
    return D;
  } else if (stock > 0.75 * capacity && cooperators(history) >= n/2) { // Cooperation incentive
    return C;
  } else {
    return D; // Default behavior
  }
}

function avgPayoff(history) {
  // Calculate average payoff per player in previous rounds
  // ...
}

function cooperators(history) {
  // Count the number of players who cooperated in the previous round
  // ...
}
```
This strategy is designed to be robust and adaptive, responding to various opponent behaviors while promoting a collective mindset.
'''

description_COLLECTIVE_385 = '''
I'll design a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors while prioritizing sustainability and fairness.

**Strategy Name:** Adaptive Collective Harvesting (ACH)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round, aiming to establish a baseline of cooperation and encourage others to do the same.
2. **Stock-dependent Cooperation**: In subsequent rounds, if the current stock level is above 75% of capacity, cooperate (C). This ensures that when resources are abundant, we prioritize sustainability and avoid over-harvesting.
3. **Defection Deterrence**: If any player defected (D) in the previous round, and the stock level dropped below 50% of capacity as a result, defect (D) in the current round. This aims to deter others from exploiting the common pool by demonstrating that over-harvesting will lead to reduced payoffs.
4. **Proportional Response**: If multiple players defected in the previous round, but the stock level remained above 50% of capacity, respond proportionally: if k out of n players defected, cooperate (C) with probability (n-k)/n. This encourages cooperation while acknowledging that some players may still choose to defect.
5. **Stock Recovery**: If the current stock level is below 25% of capacity, cooperate (C) to allow for recovery and avoid depletion.

**Edge Cases:**

* **Last Round**: In the final round, always cooperate (C), as there's no future rounds to consider.
* **Tie-breaking**: In case of a tie in the proportional response rule, default to cooperating (C).

**Collective Mindset:**
ACH prioritizes sustainability and fairness while adapting to various opponent behaviors. By initially cooperating and responding proportionally to defections, ACH encourages cooperation and deters exploitation. The strategy also acknowledges that some players may still choose to defect and adjusts its behavior accordingly.

Pseudocode:
```
function AdaptiveCollectiveHarvesting(stock, capacity, n, history):
  if (round == 1):  # Initial Round
    return C

  if (stock >= 0.75 * capacity):  # Stock-dependent Cooperation
    return C

  if (any(defector in history) and stock < 0.5 * capacity):  # Defection Deterrence
    return D

  k = count(defectors in history)
  p = (n - k) / n
  if (random() < p):  # Proportional Response
    return C
  else:
    return D

  if (stock < 0.25 * capacity):  # Stock Recovery
    return C

  return C  # Default to cooperating in case of tie-breaking
```
This strategy should perform well in a tournament against independent strategies, as it balances cooperation and deterrence while adapting to various opponent behaviors.
'''

description_COLLECTIVE_386 = '''
**Collective Strategy: Adaptive Common Pool Resource (CPR) Management**

**Overview**
Our collective strategy aims to balance individual payoffs with long-term sustainability of the common pool resource. We adapt to changing game conditions and opponent behaviors while promoting cooperation.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and encourage others to do the same.
2. **Stock-based Cooperation**: If the current stock level is above 75% of capacity, cooperate (C). This ensures that the resource remains sustainable while allowing for moderate consumption.
3. **Defection Detection**: Monitor opponent actions and detect repeated defection (D) patterns. If a player defects more than twice in the last three rounds, switch to defecting (D) as well to avoid exploitation.
4. **Stock-based Defection**: If the current stock level falls below 25% of capacity, defect (D). This prioritizes short-term gain when the resource is scarce and cooperation may not be sustainable.
5. **History-based Adaptation**: Analyze the game's history to identify patterns in opponent behavior. Adjust the strategy accordingly:
	* If opponents cooperate frequently (>50%), increase cooperation (C) probability.
	* If opponents defect frequently (>50%), decrease cooperation (C) probability.

**Pseudocode**
```python
def adaptive_cpr_management(stock, capacity, n, r, history):
    # Initial Round
    if round == 1:
        return 'C'

    # Stock-based Cooperation
    if stock > 0.75 * capacity:
        return 'C'

    # Defection Detection
    opponent_defections = count_opponent_defections(history)
    if opponent_defections > 2 in last 3 rounds:
        return 'D'

    # Stock-based Defection
    if stock < 0.25 * capacity:
        return 'D'

    # History-based Adaptation
    cooperation_rate = analyze_cooperation_rate(history)
    if cooperation_rate > 0.5:
        cooperate_prob += 0.1
    elif cooperation_rate < 0.5:
        cooperate_prob -= 0.1

    # Make decision based on updated probabilities
    if random.random() < cooperate_prob:
        return 'C'
    else:
        return 'D'
```
**Edge Cases**

* **Last Round**: In the final round, defect (D) to maximize individual payoff.
* **Low Stock Levels**: If the stock level is critically low (<10% of capacity), prioritize short-term gain and defect (D).
* **High Cooperation Rate**: If opponents cooperate frequently (>75%), maintain a high cooperation probability to sustain the resource.

By incorporating these decision rules, our collective strategy balances individual payoffs with long-term sustainability, adapting to changing game conditions and opponent behaviors.
'''

description_COLLECTIVE_387 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) unconditionally to establish a baseline for future actions.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, cooperate (C) if the previous round's total consumption was below 50% of capacity; otherwise, defect (D).
	* If the stock level is between 50% and 75% of capacity, cooperate (C) if at least half of the players cooperated in the previous round; otherwise, defect (D).
	* If the stock level is below 50% of capacity, defect (D) unconditionally.
3. **Last Round (t=r):** Defect (D) unconditionally to maximize individual payoff.

**Edge Case Handling:**

1. **Tiebreakers:** In cases where the decision rule leads to a tie (e.g., equal number of cooperators and defectors), cooperate (C) by default.
2. **Stock Depletion:** If the stock level reaches 0, defect (D) unconditionally in subsequent rounds.

**Collective Mindset Alignment:**

1. **Preserve Stock:** The primary objective is to maintain a sustainable stock level, ensuring long-term collective payoffs.
2. **Adapt to Opponents:** Adjust cooperation levels based on opponents' past behavior to balance individual and collective interests.
3. **Robustness:** Design decisions prioritize robustness over optimality, allowing the strategy to perform reasonably well across various opponent behaviors.

**Pseudocode:**
```python
def ASP(n, capacity, r, stock_history):
    # Initialize cooperation level
    cooperate = True
    
    for t in range(1, r+1):
        # Get previous round's total consumption and cooperation level
        prev_consumption = sum(stock_history[t-2]) if t > 1 else 0
        prev_cooperation = sum(1 for action in stock_history[t-2] if action == 'C') if t > 1 else n
        
        # Decision rules
        if t == 1:
            cooperate = True
        elif stock_level >= 0.75 * capacity:
            cooperate = prev_consumption < 0.5 * capacity
        elif 0.5 * capacity <= stock_level < 0.75 * capacity:
            cooperate = prev_cooperation >= n / 2
        else:
            cooperate = False
        
        # Last round exception
        if t == r:
            cooperate = False
        
        # Update cooperation level and consume accordingly
        action = 'C' if cooperate else 'D'
        consumption = stock_level / (2*n) if action == 'C' else stock_level / n
        new_stock = max(0, stock_level - consumption)
        
        # Store history and update state
        stock_history.append(new_stock)
    
    return sum(stock_history)
```
This strategy balances individual and collective interests by adapting cooperation levels based on the current stock level, opponents' past behavior, and the game's progression. By prioritizing robustness and preserving the stock level, ASP aims to perform reasonably well against a wide range of opponent behaviors in the tournament.
'''

description_COLLECTIVE_388 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock Sensitivity (ATTS)**

**Decision Rules:**

1. **First Round:** Cooperate (C) to establish a cooperative tone and gather information about opponents' behaviors.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of capacity, play C if most players (including yourself) cooperated in the previous round; otherwise, play D.
	* If the current stock level is between 50% and 75% of capacity, mirror the action of the majority of players from the previous round.
	* If the current stock level is below 50% of capacity, play C to conserve the remaining stock, regardless of others' actions.
3. **Last Round:** Play D if the current stock level is above 25% of capacity; otherwise, play C to ensure some payoff.

**Pseudocode:**
```
function ATTS(stock_level, previous_actions):
  if round == 1:
    return COOPERATE
  else:
    if stock_level >= 0.75 * capacity:
      if most_players_cooperated(previous_actions):
        return COOPERATE
      else:
        return DEFECT
    elif 0.5 <= stock_level / capacity < 0.75:
      majority_action = get_majority_action(previous_actions)
      return majority_action
    else:  # stock level is low (< 50%)
      return COOPERATE

function most_players_cooperated(actions):
  cooperate_count = sum(1 for action in actions if action == COOPERATE)
  return cooperate_count >= len(actions) / 2

function get_majority_action(actions):
  counts = {COOPERATE: 0, DEFECT: 0}
  for action in actions:
    counts[action] += 1
  majority_action = max(counts, key=counts.get)
  return majority_action
```
**Collective Mindset:**
The ATTS strategy is designed to balance individual payoff maximization with collective stock conservation. By cooperating when the stock level is high and mirroring others' actions when it's moderate, we encourage cooperation while avoiding over-exploitation. When the stock level is low, prioritizing conservation ensures some payoff for all players.

**Adaptability:**
ATTS adapts to changing opponent behaviors by:

* Responding to changes in the majority action
* Adjusting its strategy based on the current stock level

**Robustness:**
The ATTS strategy performs well against a variety of opponents, including:

* Pure cooperators and defectors
* Random or noisy players
* Strategies with fixed or probabilistic actions

By incorporating both tit-for-tat elements and stock sensitivity, ATTS provides a robust and adaptive collective strategy for the Common Pool Resource Game.
'''

description_COLLECTIVE_389 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective stock conservation, adapting to changing game conditions and opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to maximize initial payoff and encourage cooperation.
2. **Stock-Dependent Cooperation:** For rounds 2 to r-1:
	* If the current stock level is above a threshold (θ), cooperate (C). θ = capacity / (2n)
	* If the current stock level is below θ, defect (D) with probability p, and cooperate (C) with probability (1-p).
	* Update p based on the previous round's stock growth:
		+ If stock growth > 0, decrease p by 10% (encourage cooperation when stock grows)
		+ If stock growth ≤ 0, increase p by 20% (exploit when stock doesn't grow)
3. **Last Round:** Defect (D) in the last round to maximize individual payoff.

**Edge Case Handling:**

* When n = 2 and capacity is small, cooperate (C) in all rounds except the last one.
* In case of a tie in the number of cooperators and defectors, defect (D).

**Collective Mindset Alignment:**

The ASC strategy promotes cooperation when the stock level is high and defects when the stock level is low. By adapting to changing game conditions and opponent behaviors, it balances individual payoffs with collective stock conservation.

Pseudocode:
```python
def AdaptiveStockConservation(n, capacity, r, current_stock, history):
    # Initialize threshold (θ) and probability (p)
    θ = capacity / (2 * n)
    p = 0.5

    if r == 1:  # Initial Round
        return 'C'

    for t in range(2, r):  # Rounds 2 to r-1
        if current_stock > θ:
            action = 'C'
        else:
            action = 'D' if random.random() < p else 'C'

        # Update probability (p) based on previous round's stock growth
        if history[t - 1].stock_growth > 0:
            p *= 0.9
        elif history[t - 1].stock_growth <= 0:
            p *= 1.2

    return action
```
**Notes:**

* The ASC strategy assumes that opponents will also adapt their strategies based on the game's state and history.
* In a tournament setting, the ASC strategy may need to adjust its parameters (e.g., θ) or behavior in response to different opponent behaviors.

This collective strategy should perform well against independent strategies developed by other AI systems, as it balances individual payoffs with collective stock conservation while adapting to changing game conditions.
'''

description_COLLECTIVE_390 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock-Dependent Cooperation**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoffs.
2. **Subsequent Rounds**: Observe the previous round's actions and outcomes:
	* If the stock level is above 50% of capacity, cooperate (C) if most players (> n/2) cooperated in the previous round; otherwise, defect (D).
	* If the stock level is below 50% of capacity, cooperate (C) regardless of previous actions to prioritize stock recovery.
3. **Last Round**: Defect (D) in the final round, as there's no future benefit to cooperation.

**Pseudocode:**
```python
def strategy(state, history):
    if len(history) == 0:  # First round
        return 'C'
    
    stock_level = state['stock'] / state['capacity']
    prev_actions = [action for action in history[-1]['actions']]
    
    if stock_level > 0.5:
        coop_count = sum(1 for action in prev_actions if action == 'C')
        if coop_count > len(prev_actions) / 2:
            return 'C'
        else:
            return 'D'
    else:
        return 'C'

    # Last round
    if state['round'] == state['r']:
        return 'D'
```
**Rationale:**

* Cooperating in the first round sets a positive tone and encourages others to cooperate.
* By cooperating when most players cooperated previously, we reinforce collective cooperation and maintain a healthy stock level.
* When the stock level is low, prioritizing cooperation helps recover the stock, even if others defect.
* Defecting in the final round ensures maximum payoff, as there's no future benefit to cooperation.

**Collective Mindset:**

This strategy aims to balance individual payoffs with collective well-being. By adapting to the game state and previous actions, we promote cooperation when possible while protecting against exploitation by defectors. This approach fosters a culture of cooperation while allowing for strategic flexibility in response to changing circumstances.

In a tournament setting, this strategy will perform well against a variety of opponents, as it is robust to different behaviors and adapts to the game state. Its emphasis on collective cooperation and stock-dependent decision-making ensures that it contributes to the overall sustainability of the common pool resource.
'''

description_COLLECTIVE_391 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACS)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoff.
2. **Stock-Based Threshold:** Calculate a stock-based threshold `T` as follows:
   `T = capacity / (2n)`
   
   If the current stock level `S` is above or equal to `T`, cooperate (C). Otherwise, defect (D).
3. **Adaptive Response:** Observe the previous round's actions and payoffs of all players. Calculate the average cooperation rate (`ACR`) among all players in the previous round:
   `ACR = (number of cooperators in previous round) / n`
   
   If `ACR` is above 0.5, increase the threshold `T` by 10% for the next round:
   `T_new = T_old * 1.1`
   
   If `ACR` is below 0.5, decrease the threshold `T` by 10% for the next round:
   `T_new = T_old * 0.9`
4. **Last Round:** Cooperate (C) in the last round to ensure a fair distribution of the remaining stock.

**Edge Cases:**

1. If multiple players tie with the same highest payoff, prioritize cooperation.
2. In case of a single player defecting while others cooperate, maintain cooperation for one more round before adapting.

**Pseudocode:**
```markdown
function ACS(n, r, capacity) {
  T = capacity / (2n)
  
  for t in range(r):
    if t == 0:
      action = C
    else:
      ACR = calculate_average_cooperation_rate(previous_round)
      
      if S >= T and ACR > 0.5:
        action = C
        T = T * 1.1
      elif S < T or (ACR <= 0.5 and t != r-1):
        action = D
        T = T * 0.9
      else:  // Last round
        action = C
    
    consume_stock(action)
    
    if t < r-1:
      update_stock()
  
  return total_payoff
}
```
**Collective Mindset Alignment:** ACS aligns with the collective mindset by:

* Cooperating in the initial and final rounds to establish a cooperative tone and ensure fair distribution of resources.
* Adapting to the group's cooperation rate, promoting cooperation when others cooperate and responding to defection by reducing the threshold for cooperation.
* Prioritizing cooperation when multiple players achieve the same highest payoff.

**Robustness:** ACS is designed to be robust against various opponent behaviors:

* **All Defectors:** By initially cooperating, ACS can potentially create a mutually beneficial environment. If opponents defect, ACS adapts and responds with defection while maintaining a moderate threshold.
* **Mixed Strategies:** ACS's adaptive response helps it to adjust to the average cooperation rate of the group, allowing it to cooperate or defect accordingly.

By incorporating elements of cooperation, adaptation, and robustness, ACS aims to achieve a high total payoff in a wide range of opponent behaviors.
'''

description_COLLECTIVE_392 = '''
**Collective Strategy: "Adaptive Stock-Conscious Tit-for-Tat" (ASCT)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline and encourage cooperation.
2. **Subsequent Rounds:** Assess the current stock level and opponents' previous actions to determine the best response.

**Pseudocode:**
```python
def ASCT(stock, history):
    if round == 1:
        return C
    
    # Calculate the average opponent consumption in the last round
    avg_opponent_consumption = sum(history[-1].consumptions) / (n - 1)
    
    # Assess the current stock level
    if stock < capacity / 2:
        # If stock is low, prioritize cooperation to allow growth
        return C
    elif stock > capacity * 0.8:
        # If stock is high, defect to maximize payoff while maintaining sustainability
        return D
    
    # Evaluate opponents' behavior in the last round
    if avg_opponent_consumption > stock / (2n):
        # If opponents defected heavily, cooperate to encourage cooperation and sustain stock
        return C
    else:
        # Otherwise, mirror the average opponent action (tit-for-tat)
        if avg_opponent_consumption >= stock / n:
            return D
        else:
            return C
    
    # Edge case: Last round
    if round == r:
        # Defect to maximize payoff in the final round
        return D
```
**Rationale:**

1. **Initial Cooperation:** Encourage cooperation and establish a baseline.
2. **Adaptive Response:** Adjust behavior based on current stock levels, opponents' actions, and game history.
3. **Sustainability Focus:** Prioritize cooperation when stock is low to allow growth and maintain sustainability.
4. **Tit-for-Tat:** Mirror opponents' average action to encourage cooperation and deter defection.
5. **Last Round Defection:** Maximize payoff in the final round.

**Collective Mindset:**

The ASCT strategy prioritizes collective well-being by:

1. Encouraging cooperation when stock is low or opponents are cooperative.
2. Adapting to changing circumstances to maintain sustainability.
3. Mirroring opponents' actions to promote reciprocity and deter exploitation.

By following this strategy, players can work together to achieve a mutually beneficial outcome while being robust against various opponent behaviors.
'''

description_COLLECTIVE_393 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) with a probability of 0.5 to gather information about opponents' behaviors and establish a baseline for future decisions.
2. **Subsequent Rounds**: Observe the previous round's outcome and adjust behavior based on the following rules:
	* If the stock level has increased or remained stable (> capacity/2), Cooperate (C) with a probability of 0.7 to maintain a sustainable stock level.
	* If the stock level has decreased significantly (< capacity/3), Defect (D) with a probability of 0.8 to maximize individual payoff in a potentially depleted resource environment.
	* Otherwise, use a mixed strategy: Cooperate (C) with a probability of 0.5 and Defect (D) with a probability of 0.5.
3. **Last Round**: Always Defect (D), as there is no future benefit to conserving the stock.

**Edge Case Handling:**

* If all opponents defect in the initial round, adjust the ASC strategy to be more cautious: Cooperate (C) with a probability of 0.4 in subsequent rounds.
* If the stock level reaches critically low levels (< capacity/10), switch to a Defect-only strategy to maximize individual payoff.

**Collective Mindset Alignment:**

The ASC strategy prioritizes collective sustainability while adapting to opponents' behaviors. By cooperating when the stock level is stable or increasing, players using this strategy contribute to maintaining a healthy common pool resource. When faced with depletion or uncertainty, they adapt by defecting to ensure individual gains.

**Pseudocode (simplified for clarity):**

```
function ASC(n, r, capacity, current_stock, round_number) {
  if (round_number == 1) {
    // Initial Round
    return C with probability 0.5;
  }

  previous_stock = get_previous_round_stock();
  stock_diff = current_stock - previous_stock;

  if (stock_diff >= 0 && current_stock > capacity/2) {
    // Stock stable or increasing, Cooperate with high probability
    return C with probability 0.7;
  } else if (current_stock < capacity/3) {
    // Stock depleted, Defect with high probability
    return D with probability 0.8;
  } else {
    // Mixed strategy for uncertain environments
    return C with probability 0.5 and D with probability 0.5;
  }

  // Last Round
  if (round_number == r) {
    return D;
  }
}
```

**Implementation Considerations:**

When implementing the ASC strategy as an algorithm, ensure that the following details are addressed:

* Store the game state (stock level and round number) to make informed decisions.
* Use a suitable randomization method for probabilistic decision-making.
* Handle edge cases and adjust strategy parameters as necessary.

The Adaptive Stock Conservation (ASC) strategy is designed to balance collective sustainability with individual gains, making it an effective and robust approach in the Common Pool Resource Game tournament.
'''

description_COLLECTIVE_394 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

The Adaptive Cooperation (AC) strategy is designed to balance individual payoffs with collective sustainability in the Common Pool Resource game. AC adapts to the game's dynamic state and history, making decisions based on the current stock level, player actions, and past outcomes.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock Level Thresholds:**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, defect (D) with probability 0.5, otherwise cooperate (C).
	* If the current stock level is below 50% of capacity, defect (D).
3. **Response to Opponent Actions:**
	* If a player observes that most opponents (> 50%) defected in the previous round, they will defect (D) in the next round.
	* Otherwise, if the opponent's actions were mostly cooperative (> 50%), the player will cooperate (C).
4. **Punishment Mechanism:** If the stock level falls below 25% of capacity due to excessive defection, all players will cooperate (C) for the next two rounds to allow the stock to recover.

**Handling Edge Cases:**

* **Last Round:** In the final round, each player will cooperate (C) to maximize collective payoff and maintain a sustainable stock level.
* **Ties in Opponent Actions:** In cases where opponent actions are evenly split between cooperation and defection, the player will cooperate (C).

**Collective Mindset:**

The Adaptive Cooperation strategy prioritizes cooperation when the stock level is high or when opponents have been cooperative. By doing so, AC promotes collective sustainability and encourages others to adopt a similar mindset. When faced with excessive defection or low stock levels, AC adapts by defecting or punishing opponents to prevent catastrophic outcomes.

**Pseudocode:**
```
AC_Strategy(stock_level, opponent_actions, round):
  if round == 1:
    return C
  elif stock_level >= 0.75 * capacity:
    return C
  elif 0.5 * capacity <= stock_level < 0.75 * capacity:
    if random.random() < 0.5:
      return D
    else:
      return C
  else:
    return D

  # Response to opponent actions
  if most_opponents_defected(opponent_actions):
    return D
  elif most_opponents_cooperated(opponent_actions):
    return C

  # Punishment mechanism
  if stock_level < 0.25 * capacity:
    return C for next two rounds
```
The Adaptive Cooperation strategy is designed to be robust, adaptive, and collective, making it a strong contender in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_395 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe others' behaviors.
2. **Subsequent Rounds**:
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, defect (D) with probability p = (1 - (stock/capacity)) / 2. This introduces a gradual shift towards defection as the stock depletes.
	* If the current stock level is below 50% of capacity, defect (D).
3. **Reaction to Opponents' Actions**:
	* Monitor the actions of other players and adjust your strategy based on their cooperation rates. If a majority (>50%) of opponents defected in the previous round, increase the probability of defection by 10% in the current round.
4. **Stock Growth Consideration**: When the stock growth is high (i.e., the remaining stock is low), prioritize conservation by cooperating more frequently.

**Pseudocode:**
```
function ASC(current_stock, capacity, n, r, history):
    // Initialize variables
    cooperate = False
    defect_prob = 0.0

    // First round
    if r == 1:
        return C

    // Subsequent rounds
    if current_stock >= 0.75 * capacity:
        return C
    elif 0.5 * capacity <= current_stock < 0.75 * capacity:
        defect_prob = (1 - (current_stock / capacity)) / 2
        return D with probability defect_prob
    else:
        return D

    // Reaction to opponents' actions
    opponent_defection_rate = calculate_opponent_defection_rate(history)
    if opponent_defection_rate > 0.5:
        defect_prob += 0.1

    // Stock growth consideration
    stock_growth = calculate_stock_growth(current_stock, capacity)
    if stock_growth > 0.25 * capacity:
        cooperate = True

    return C if cooperate else D with probability defect_prob
```
**Collective Mindset:**

ASC prioritizes cooperation when the common pool is abundant and shifts towards defection as the stock depletes. This strategy encourages players to conserve the resource while allowing for individual adaptation to changing circumstances.

By monitoring opponents' actions, ASC promotes a collective understanding of the importance of cooperation in maintaining a sustainable common pool. When faced with frequent defection from others, ASC adjusts its own behavior to prevent over-exploitation and promote stock recovery.

ASC's adaptive nature allows it to perform well against various opponent strategies, as it balances individual self-interest with collective responsibility for the common resource.
'''

description_COLLECTIVE_396 = '''
I propose a collective strategy called "Adaptive Stock Conservation" (ASC). ASC aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and observe others' actions.
2. **Stock Thresholds:** Define two stock thresholds:
	* `low_threshold` = capacity / 4
	* `high_threshold` = capacity / 2
3. **Cooperation Zone:** If the current stock level is above `high_threshold`, cooperate (C) to conserve stock and promote sustainability.
4. **Defection Zone:** If the current stock level is below `low_threshold`, defect (D) to maximize individual payoff in the short term, as the stock is already depleted.
5. **Adaptive Response:** When the current stock level is between `low_threshold` and `high_threshold`, use the following adaptive response:
	* Observe the actions of other players in the previous round. If a majority (>50%) cooperated, cooperate (C) in the current round. Otherwise, defect (D).

**Pseudocode:**
```python
def ASC(stock, capacity, history):
    low_threshold = capacity / 4
    high_threshold = capacity / 2

    if round == 1:
        return C  # Cooperate in the first round

    if stock > high_threshold:
        return C  # Cooperate to conserve stock
    elif stock < low_threshold:
        return D  # Defect to maximize individual payoff
    else:
        majority_cooperated = sum(history[-1]) / len(history[-1]) > 0.5
        if majority_cooperated:
            return C  # Cooperate if a majority cooperated previously
        else:
            return D  # Defect otherwise

history = []  # Initialize history of previous rounds' actions
for round in range(r):
    stock = current_stock_level()
    action = ASC(stock, capacity, history)
    history.append(action)
```
**Handling Edge Cases:**

* **Last Round:** In the final round, defect (D) to maximize individual payoff, as there are no future consequences.
* **Ties:** In cases where the majority cooperation check results in a tie, cooperate (C) to promote sustainability.

**Collective Mindset:**
ASC prioritizes collective sustainability while adapting to individual self-interest. By cooperating when the stock is high and defecting when it's low, ASC aims to maintain a stable stock level that benefits all players. The adaptive response mechanism encourages cooperation by rewarding majority cooperation with cooperation in the next round.

By implementing ASC, we create a robust strategy that balances individual payoffs with collective sustainability, making it an effective competitor in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_397 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoffs.
2. **Stock-Based Threshold**: Introduce a dynamic threshold, `θ`, which is a fraction of the current stock level. The value of `θ` will determine when to cooperate or defect.

`θ = 0.6 * (current_stock / capacity)`

If the current stock level is above this threshold (`stock ≥ θ * capacity`), Cooperate (C). Otherwise, Defect (D).

3. **Adaptive Adjustment**: After each round, adjust `θ` based on the previous round's outcome:

   a. If all players cooperated and the stock increased, decrease `θ` by 10% to encourage continued cooperation.
   
   b. If any player defected or the stock decreased, increase `θ` by 20% to deter future defections.

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round, as there are no future rounds to consider and individual payoffs take precedence.
2. **Zero Stock**: If the stock level reaches zero, Cooperate (C) for the remainder of the game, as defecting would not provide any payoff.

**Collective Mindset:**

ACST aligns with a collective mindset by:

1. Initially cooperating to establish trust and maximize payoffs.
2. Adapting to changes in the stock level and opponent behaviors, making it robust to various strategies.
3. Prioritizing cooperation when the stock level is high, ensuring sustainable resource management.

**Pseudocode:**

```
initialize θ = 0.6
for each round:
    if current_round == 1:
        action = C
    else:
        calculate θ based on previous round's outcome
        if stock >= θ * capacity:
            action = C
        else:
            action = D

    # adjust θ for next round
    if all_players_cooperated and stock_increased:
        θ *= 0.9
    elif any_player_defected or stock_decreased:
        θ *= 1.2

    if current_round == last_round:
        action = D
    elif stock_level == 0:
        action = C

    return action
```

ACST is designed to be adaptive, robust, and collective, making it a suitable strategy for the Common Pool Resource Game tournament.
'''

description_COLLECTIVE_398 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about other players' behaviors.
2. **Stock-Based Cooperation**: If the current stock level is above 75% of the capacity, cooperate (C). This ensures a stable stock growth while allowing for moderate consumption.
3. **Defect-Triggered Defection**: If at least one player defected in the previous round and the current stock level is below 50% of the capacity, defect (D) to avoid being exploited by free riders.
4. **Reciprocal Cooperation**: If all players cooperated in the previous round and the current stock level is above 25% of the capacity, cooperate (C). This encourages mutual cooperation when possible.
5. **Default Defection**: In all other cases, defect (D) to prioritize individual payoffs.

**Edge Cases**

1. **Last Round**: Defect (D) in the last round, as there are no future rounds to consider and individual payoffs become the sole focus.
2. **Low Stock Levels**: If the current stock level is below 25% of the capacity, defect (D) regardless of other players' previous actions. This prioritizes immediate consumption over potential long-term benefits.

**Pseudocode**

```
function ASC(current_stock, capacity, num_players, round_number, history):
    if round_number == 1:
        return COOPERATE
    elif current_stock > 0.75 * capacity:
        return COOPERATE
    elif (any(defected in history[-1]) and current_stock < 0.5 * capacity):
        return DEFECT
    elif all(cooperated in history[-1]) and current_stock > 0.25 * capacity:
        return COOPERATE
    else:
        return DEFECT

    if round_number == num_rounds:
        return DEFECT
    elif current_stock < 0.25 * capacity:
        return DEFECT
```

The ASC strategy aims to strike a balance between cooperation and individual payoffs by adapting to the game's state and history. It promotes collective sustainability while being robust against a wide range of opponent behaviors.

This strategy can be further refined or modified based on specific requirements or additional insights from game theory and behavioral studies.
'''

description_COLLECTIVE_399 = '''
**Collective Strategy: "Adaptive Stock Conservator" (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's dynamic state and opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1): Cooperate**
In the first round, all players cooperate to establish a baseline stock level and encourage opponents to do the same.
2. **Subsequent Rounds (t>1): Adaptive Defection Threshold**
Calculate the current stock-to-capacity ratio (SCR) as `stock / capacity`.
If SCR ≥ 0.75, Cooperate; otherwise, Defect.

The adaptive threshold of 0.75 is chosen to balance individual payoffs with collective sustainability. When the stock level is relatively high, cooperation ensures a moderate consumption rate, while defecting at lower stock levels helps to prevent over-exploitation.

**Edge Case Handling:**

1. **Last Round (t=r): Defect**
In the final round, all players defect to maximize their individual payoffs, as there are no future consequences.
2. **Low Stock Levels (stock ≤ 2n): Cooperate**
If the stock level falls below the minimum sustainable threshold (`2n`), cooperate to prevent over-exploitation and allow for potential recovery.

**Collective Mindset:**

The ASC strategy prioritizes collective sustainability while adapting to opponent behaviors. By cooperating when the stock level is high and defecting when it's low, ASC encourages opponents to do the same, promoting a balanced consumption rate. In edge cases, ASC prioritizes cooperation to prevent over-exploitation and promote recovery.

**Pseudocode:**
```python
def adaptive_stock_conservator(stock, capacity, n, t, r):
  if t == 1:  # Initial Round
    return "Cooperate"
  
  scr = stock / capacity
  
  if scr >= 0.75:
    return "Cooperate"
  else:
    return "Defect"

  # Edge Case Handling
  if t == r:  # Last Round
    return "Defect"
  elif stock <= 2 * n:  # Low Stock Levels
    return "Cooperate"
```
The ASC strategy is designed to be robust against a wide range of opponent behaviors, prioritizing collective sustainability while adapting to the game's dynamic state.
'''

description_COLLECTIVE_400 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoff maximization with collective stock conservation, adapting to the game's dynamic state and opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1): Cooperate**
In the first round, all players cooperate (C) to establish a baseline of trust and maximize initial payoffs.
2. **Subsequent Rounds (t>1):**
a. Calculate the **Stock Depletion Rate (SDR)**:
`SDR = (capacity - stock) / capacity`
b. Determine the **Opponent Cooperation Level (OCL)**:
`OCL = number of opponents who cooperated in the previous round / n`
c. Choose action based on SDR and OCL:

| SDR | OCL | Action |
| --- | --- | --- |
| Low (< 0.3) | High (> 0.6) | Cooperate (C) |
| Low (< 0.3) | Medium (0.4-0.6) | Randomly choose C or D with probability 0.5 |
| Low (< 0.3) | Low (< 0.4) | Defect (D) |
| High (≥ 0.3) | - | Defect (D) |

**Edge Cases:**

* **Last Round (t=r):** Defect (D), as there is no future stock to conserve.
* **Stock Depletion:** If the stock falls below a critical threshold (e.g., `stock < 0.2 * capacity`), defect (D) to maximize individual payoff in the remaining rounds.

**Collective Mindset:**
The ASC strategy prioritizes cooperation when the stock is healthy and opponents are cooperative, while adapting to more competitive behavior as the stock depletes or opponents become less cooperative. This approach balances individual self-interest with collective conservation of the common resource.

Pseudocode:
```python
def ASC(n, capacity, stock, history):
    if t == 1:  # Initial round
        return 'C'
    
    SDR = (capacity - stock) / capacity
    OCL = count_cooperators(history[-1]) / n
    
    if SDR < 0.3:
        if OCL > 0.6:
            return 'C'
        elif OCL >= 0.4 and OCL <= 0.6:
            return random.choice(['C', 'D'])
        else:
            return 'D'
    else:
        return 'D'

def count_cooperators(actions):
    return sum(1 for action in actions if action == 'C')
```
The ASC strategy is designed to be robust and adaptive, responding to various opponent behaviors while prioritizing collective stock conservation.
'''

description_COLLECTIVE_401 = '''
I'll design a collective strategy that balances individual payoff maximization with sustainability of the common pool resource. Our strategy is called "Adaptive Collective Conservation" (ACC).

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock-dependent Cooperation**: In subsequent rounds, cooperate if the current stock level is above a certain threshold (S_threshold = capacity / 2). This ensures that we contribute to replenishing the stock when it's abundant.
3. **Defect when Stock is Low**: Defect (D) when the current stock level falls below S_threshold. This helps prevent overexploitation and encourages others to conserve as well.
4. **Reciprocity-based Adaptation**: Monitor the average payoff per player (APP) in the previous round. If APP is above a certain threshold (APP_threshold = capacity / (2n)), assume that enough players are cooperating, and cooperate in the current round. Otherwise, defect.

Pseudocode:
```
function ACC(current_stock, history):
  if first_round:
    return C
  elif current_stock > S_threshold:
    return C
  elif APP(history) > APP_threshold:
    return C
  else:
    return D
```

**Edge Cases:**

1. **Last Round**: In the final round, defect to maximize individual payoff, as there's no future stock to conserve.
2. **Very Low Stock**: If the current stock level is extremely low (e.g., < 10% of capacity), cooperate to prevent complete depletion and allow for some regeneration.

**Collective Mindset:**

ACC prioritizes sustainability by conserving the common pool resource when it's abundant, while adapting to changes in the game state and history. By reciprocating cooperation when others are contributing to the stock's replenishment, ACC encourages collective conservation. When the stock is low, ACC defects to prevent overexploitation and encourage others to conserve.

**Robustness:**

ACC is robust against various opponent behaviors:

1. **Cooperative opponents**: ACC will cooperate with them, maintaining a high stock level.
2. **Defector-dominated opponents**: ACC will adapt by defecting when the stock is low, preventing overexploitation.
3. **Mixed-strategy opponents**: ACC's reciprocity-based adaptation will lead to cooperation when enough players are contributing to the stock's replenishment.

By balancing individual payoff maximization with collective conservation, Adaptive Collective Conservation (ACC) provides a robust strategy for this Common Pool Resource Game.
'''

description_COLLECTIVE_402 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC is a collective strategy designed to balance individual payoffs with sustainable stock management, ensuring long-term benefits for all players. The approach adapts to various opponent behaviors and game states.

**Decision Rules:**

1. **Initial Round (t=1):**
   - Cooperate (C) if the initial stock is greater than or equal to 75% of capacity.
   - Defect (D) otherwise.

2. **Subsequent Rounds (t > 1):**
   - **ASC Threshold:** Calculate a dynamic threshold `T` based on the current stock level and the number of remaining rounds:
     `T = min(0.5 + (stock / capacity), 0.75)`
   
   - **Cooperation Condition:** Cooperate if at least half of the players cooperated in the previous round (`t-1`) AND the current stock is above or equal to the threshold `T`.
   
   - **Defection Condition:** Defect if less than half of the players cooperated in the previous round OR the current stock is below the threshold `T`.

3. **Last Round (t=r):**
   - Defect, as there are no future rounds to consider.

**Handling Edge Cases:**

- **First Round with Low Stock:** If the game starts with a low stock level (less than 25% of capacity), defecting may be the only viable option to ensure some payoff.
  
- **Last Rounds with High Stock:** In the final rounds, if the stock remains high and cooperation has been prevalent, consider cooperating to maximize collective benefits.

**Collective Mindset Alignment:**

ASC aims to promote sustainable stock management while encouraging cooperation among players. By adapting to both the current state of the game and the behavior of other players, ASC seeks to achieve a balance between short-term gains and long-term sustainability, thus aligning with a collective mindset focused on mutual benefit.

**Pseudocode for Implementation:**

```python
def adaptive_stock_conservation(game_state):
    # Extract relevant information from game_state
    current_round = game_state['round']
    stock_level = game_state['stock']
    capacity = game_state['capacity']
    num_players = game_state['num_players']
    previous_actions = game_state['previous_actions']  # List of actions from the last round
    
    if current_round == 1:  # Initial Round
        if stock_level >= 0.75 * capacity:
            return 'C'  # Cooperate
        else:
            return 'D'  # Defect
    
    # Calculate ASC Threshold for subsequent rounds
    threshold = min(0.5 + (stock_level / capacity), 0.75)
    
    # Determine cooperation rate in the last round
    cooperations_last_round = sum(action == 'C' for action in previous_actions)
    half_players_cooperated = cooperations_last_round >= num_players / 2
    
    if stock_level >= threshold and half_players_cooperated:
        return 'C'  # Cooperate
    else:
        return 'D'  # Defect

# For the last round, override ASC's decision to always defect
if game_state['round'] == game_state['total_rounds']:
    return 'D'
```

This strategy is designed to be adaptive and robust against a variety of opponent behaviors, focusing on balancing individual gains with collective sustainability.
'''

description_COLLECTIVE_403 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Aware Tit-for-Tat (ACSAT)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a cooperative tone and encourage others to do the same.
2. **Subsequent Rounds**:
	* If the current stock level is above 75% of the capacity, cooperate (C) to maintain a sustainable stock level.
	* If the current stock level is between 50% and 75% of the capacity, play Tit-for-Tat (TFT): cooperate if most players cooperated in the previous round, defect otherwise.
	* If the current stock level is below 50% of the capacity, defect (D) to maximize individual payoff, as the stock is likely to be depleted regardless of cooperation.
3. **Defection Response**: If a player defects, respond with defection in the next round to discourage exploitation.

**Edge Cases:**

1. **Last Round**: Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Low Stock Levels**: If the current stock level is critically low (< 25% of capacity), defect (D) to ensure some payoff, even if it means depleting the stock further.
3. **High Stock Levels**: If the current stock level is exceptionally high (> 90% of capacity), cooperate (C) to maintain a sustainable stock level and encourage others to do the same.

**Collective Mindset:**

ACSAT aims to balance individual payoff maximization with collective sustainability. By adapting to the current stock level and opponent behaviors, ACSAT promotes cooperation when possible while protecting against exploitation.

**Pseudocode:**
```python
def ACSAT(stock_level, capacity, history):
  if round == 1:
    return COOPERATE

  if stock_level > 0.75 * capacity:
    return COOPERATE
  elif stock_level >= 0.5 * capacity:
    # Tit-for-Tat
    previous_round_cooperations = sum(1 for player in history[-1] if player == COOPERATE)
    if previous_round_cooperations > len(history[-1]) / 2:
      return COOPERATE
    else:
      return DEFECT
  elif stock_level < 0.5 * capacity:
    return DEFECT

  # Last round or low stock levels
  if round == total_rounds or stock_level < 0.25 * capacity:
    return DEFECT

  # High stock levels
  if stock_level > 0.9 * capacity:
    return COOPERATE

  # Default: defect to ensure some payoff
  return DEFECT
```
ACSAT is designed to be robust against a wide range of opponent behaviors, promoting cooperation when possible while protecting individual payoffs in a dynamic and adaptive manner.
'''

description_COLLECTIVE_404 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACS-T)**

ACS-T is a collective strategy that balances individual payoff maximization with long-term sustainability of the common pool resource. The decision rules are based on the game's state and history, ensuring adaptability to various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to signal willingness to cooperate and observe other players' actions.
2. **Stock-Based Threshold:** Calculate a threshold stock level (`T`) for each round `t`, where:

`T = capacity * (1 - (t / r))`

This decreasing threshold reflects the importance of conserving the stock as the game progresses.

3. **Cooperation Condition:** Cooperate if:
	* The current stock level is above or equal to the calculated threshold (`stock >= T`).
	* At least one other player cooperated in the previous round.
4. **Defection Condition:** Defect (D) otherwise.

**Pseudocode:**
```
function ACS_T(stock, capacity, r, t, history):
  // Initial Round
  if t == 1:
    return C

  // Calculate threshold stock level
  T = capacity * (1 - (t / r))

  // Check cooperation condition
  if stock >= T and any(history[-1][i] == C for i != self.index):
    return C
  else:
    return D
```
**Edge Cases:**

* **Last Round:** Defect in the last round (`t == r`), as there is no future benefit to cooperation.
* **Low Stock:** If the stock level falls below a critical threshold (e.g., `stock < capacity / n`), cooperate unconditionally to prevent depletion.

**Collective Mindset:**

ACS-T aligns with the collective mindset by:

1. Cooperating when the stock level is sufficient and others have demonstrated cooperative behavior.
2. Gradually decreasing cooperation as the game progresses, reflecting the increasing importance of conserving the stock.
3. Responding to changes in the game's state and history, demonstrating adaptability.

By following these decision rules, ACS-T balances individual payoff maximization with long-term sustainability of the common pool resource, making it a robust strategy for a wide range of opponent behaviors.
'''

description_COLLECTIVE_405 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Sensitive Tit-for-Tat**

Our collective strategy, dubbed "Adaptive Cooperation with Stock-Sensitive Tit-for-Tat" (ACSS-TFT), aims to balance individual payoffs with collective sustainability in the Common Pool Resource Game. ACSS-TFT is a dynamic, adaptive approach that responds to both the current state of the stock and the actions of other players.

**Decision Rules:**

1. **Initial Cooperation**: In the first round, cooperate (C) unconditionally to establish a baseline for cooperation and encourage others to do the same.
2. **Stock-Sensitive Tit-for-Tat**: From the second round onwards, use the following rules:
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, mirror the most common action taken by other players in the previous round.
	* If the current stock level is below 50% of capacity, defect (D) to maximize individual payoff while minimizing further depletion of the stock.
3. **Punishment Mechanism**: If a player defects (D) when the stock level is above 75% of capacity, punish them by defecting (D) in the next round, regardless of the current stock level.

**Edge Cases:**

1. **Last Round**: In the final round, always cooperate (C), as there are no future rounds to consider.
2. **Tiebreakers**: If two or more players have taken the same action in a previous round, choose the most cooperative action (C) as the tiebreaker.

**Collective Mindset:**

ACSS-TFT prioritizes cooperation when the stock level is high and adapts to the actions of other players to maintain a balance between individual payoffs and collective sustainability. By cooperating when the stock level is above 75% of capacity, we create an incentive for others to cooperate as well, promoting a collective mindset.

**Pseudocode:**
```python
def ACSS_TFT(stock_level, previous_actions, current_round):
    if current_round == 1:
        return "C"  # Initial cooperation

    if stock_level > 0.75 * capacity:
        return "C"  # Cooperate when stock level is high

    elif stock_level >= 0.5 * capacity and stock_level <= 0.75 * capacity:
        most_common_action = mode(previous_actions)
        return most_common_action  # Mirror the most common action

    else:  # Stock level is below 50% of capacity
        return "D"  # Defect to maximize individual payoff

def punish_defectors(stock_level, previous_actions):
    if stock_level > 0.75 * capacity and any(action == "D" for action in previous_actions):
        return "D"  # Punish defectors by defecting

# Last round handling
if current_round == r:
    return "C"
```
ACSS-TFT is designed to be robust against a wide range of opponent behaviors, promoting cooperation and sustainability while protecting individual payoffs.
'''

description_COLLECTIVE_406 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

ASP aims to balance individual payoffs with collective stock preservation, adapting to the dynamic state and opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' initial actions.
2. **Stock-Based Threshold**: Define a stock threshold `T` as `capacity / 2`. If the current stock level is above `T`, cooperate (C). Otherwise, defect (D).
3. **Opponent Action Analysis**:
	* Monitor opponent actions in previous rounds and calculate their cooperation rate (`CR`) as the proportion of cooperative actions.
	* If an opponent's `CR` is above a certain threshold (`θ`), assume they are likely to cooperate and adjust your action accordingly.
4. **Adaptive Response**: Based on the previous round's outcome:
	+ If the stock increased, maintain the same action (C or D).
	+ If the stock decreased, switch actions (from C to D or vice versa).

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round, as there is no future payoff impact from cooperation.
2. **Low Stock**: When the current stock level is below a certain threshold (`ε`), defect (D) to maximize individual payoffs before the game ends.

**Pseudocode:**
```python
def ASP(n, r, capacity):
    # Initialize variables
    T = capacity / 2
    θ = 0.5  # opponent cooperation rate threshold
    ε = 10   # low stock threshold

    for t in range(r):
        if t == 0:
            action = 'C'  # Cooperate in the first round
        else:
            # Analyze previous round's outcome and opponents' actions
            prev_stock = get_prev_stock()
            opponent_CRs = get_opponent_cooperation_rates()

            if prev_stock > T:
                action = 'C'
            elif any(opponent_CR >= θ for opponent_CR in opponent_CRs):
                action = 'D'  # Adapt to likely cooperative opponents
            else:
                action = switch_action(get_prev_action())

        if t == r - 1:
            action = 'D'  # Defect in the last round

        if get_current_stock() < ε:
            action = 'D'  # Defect when stock is low

        take_action(action)
```
**Collective Mindset:**
ASP prioritizes collective stock preservation by cooperating when the stock level is above the threshold. By adapting to opponents' actions and responding to changes in the game state, ASP balances individual payoffs with long-term sustainability. This strategy promotes cooperation while being robust against various opponent behaviors.

By using this adaptive approach, ASP will engage in a mix of cooperation and defection, aiming to maintain a healthy stock level throughout the game. In a tournament setting, ASP's collective mindset and adaptability should enable it to perform well against diverse strategies developed by other AI systems.
'''

description_COLLECTIVE_407 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to avoid initial over-exploitation.
2. **Stock-Based Cooperation**: If the current stock is above 75% of capacity, cooperate (C). This ensures a stable stock level and allows for some individual payoff optimization.
3. **Defection Threshold**: If the current stock falls below 50% of capacity, defect (D) to maximize individual payoffs while minimizing further stock depletion.
4. **History-Based Adaptation**: Analyze the previous round's outcomes:
	* If all players cooperated and the stock increased or remained stable, cooperate (C) in the next round.
	* If all players defected or the stock decreased significantly (> 20%), defect (D) in the next round to avoid further losses.
	* If there was a mix of cooperation and defection, use the following:
		+ Calculate the average payoff per player in the previous round (π_avg).
		+ Cooperate (C) if π_avg is above the average cooperative payoff (S/(2n)); otherwise, defect (D).

**Edge Cases**

1. **Last Round**: Defect (D) to maximize individual payoffs, as there are no future rounds to consider.
2. **Tie-Breaking**: In cases where multiple strategies would lead to the same outcome, prioritize cooperation (C) to maintain a collective mindset.

Pseudocode:

```
Function ASC(current_stock, capacity, history):
  if current_round == 1:
    return C
  elif current_stock > 0.75 * capacity:
    return C
  elif current_stock < 0.5 * capacity:
    return D
  
  # Analyze previous round's outcomes
  prev_outcome = history[-1]
  if all_players_cooperated(prev_outcome) and stock_increased(prev_outcome):
    return C
  elif all_players_defected(prev_outcome) or significant_stock_decrease(prev_outcome):
    return D
  
  # History-based adaptation
  π_avg = average_payoff_per_player(prev_outcome)
  if π_avg > S / (2n):
    return C
  else:
    return D

Function all_players_cooperated(outcome):
  # Check if all players cooperated in the previous round
  return outcome['cooperation'] == n

Function stock_increased(outcome):
  # Check if the stock increased or remained stable
  return outcome['new_stock'] >= outcome['old_stock']

Function significant_stock_decrease(outcome):
  # Check if the stock decreased significantly (> 20%)
  return (outcome['old_stock'] - outcome['new_stock']) / outcome['old_stock'] > 0.2

Function average_payoff_per_player(outcome):
  # Calculate the average payoff per player in the previous round
  π_avg = sum(player['payoff'] for player in outcome['players']) / n
  return π_avg
```

The ASC strategy balances individual payoffs with collective sustainability by adapting to the game's state and history. By prioritizing cooperation when the stock is stable and defecting when it falls below a certain threshold, ASC promotes a collective mindset while optimizing individual outcomes.
'''

description_COLLECTIVE_408 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.7 to encourage initial stock growth and gauge opponents' behavior.
2. **Middle Rounds (1 < t < r):**
	* If the current stock level is above 75% of capacity, cooperate (C) if the average opponent cooperation rate in the previous round is above 0.5; otherwise, defect (D).
	* If the current stock level is between 50% and 75% of capacity, cooperate (C) if at least half of the opponents cooperated in the previous round; otherwise, defect (D).
	* If the current stock level is below 50% of capacity, defect (D) to maximize individual payoff.
3. **Final Round (t=r):** Defect (D) to maximize individual payoff.

**Edge Cases:**

1. **First Round with Low Stock:** If the initial stock level is below 50% of capacity, defect (D) in the first round to maximize individual payoff.
2. **Last Round with High Stock:** If the stock level in the final round is above 75% of capacity, cooperate (C) to maintain a healthy stock for future games.

**Adaptive Mechanisms:**

1. **Opponent Cooperation Rate Tracking:** Monitor the average cooperation rate of opponents in each round and adjust the strategy accordingly.
2. **Stock Level Monitoring:** Continuously assess the current stock level and adjust the strategy based on predefined thresholds (50% and 75% of capacity).

**Collective Mindset Alignment:**

1. **Encourage Cooperation:** By cooperating with a high probability in the initial rounds, ASC encourages opponents to cooperate and maintain a healthy stock.
2. **Adapt to Opponent Behavior:** By tracking opponent cooperation rates and adjusting the strategy, ASC promotes a collective approach that balances individual payoffs with long-term stock sustainability.

**Pseudocode:**
```markdown
function AdaptiveStockConservation(n, r, capacity, current_stock, previous_round_actions):
  if t == 1:
    cooperate_prob = 0.7
    return random_choice([C, D], [cooperate_prob, 1 - cooperate_prob])
  
  avg_opponent_coop_rate = calculate_average_cooperation_rate(previous_round_actions)
  stock_level = current_stock / capacity
  
  if stock_level > 0.75:
    if avg_opponent_coop_rate > 0.5:
      return C
    else:
      return D
  elif stock_level >= 0.5 and stock_level <= 0.75:
    if count_cooperators(previous_round_actions) >= n / 2:
      return C
    else:
      return D
  else:
    return D
  
  # Final round
  if t == r:
    return D

def calculate_average_cooperation_rate(actions):
  cooperators = sum(1 for action in actions if action == C)
  return cooperators / n

def count_cooperators(actions):
  return sum(1 for action in actions if action == C)
```
This strategy balances individual payoffs with collective stock conservation by adapting to opponent behavior and monitoring the current stock level. By encouraging cooperation in initial rounds and adjusting the strategy based on predefined thresholds, ASC promotes a collective approach that is robust to various opponent behaviors.
'''

description_COLLECTIVE_409 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Sensitive Tit-for-Tat (ACS-TFT)**

**Decision Rules:**

1. **First Round:** Cooperate (C) to establish a cooperative tone and maximize initial payoff.
2. **Subsequent Rounds:** Implement a modified Tit-for-Tat strategy, where:
	* If the stock level is above a certain threshold (e.g., 75% of capacity), cooperate (C).
	* If the stock level falls below this threshold, defect (D) with a probability proportional to the number of previous rounds where at least one player defected.
3. **Stock-Sensitive Adjustment:** Gradually adjust the cooperation threshold based on the average stock level over the past few rounds. Specifically:
	+ If the average stock level is increasing or stable, decrease the cooperation threshold by 5% every round.
	+ If the average stock level is decreasing, increase the cooperation threshold by 10% every round.

**Pseudocode:**
```
Initialize variables:
  threshold = 0.75 * capacity
  defect_count = 0
  avg_stock_level = []

For each round t:
  If t == 1:
    action[t] = C
  Else:
    If stock_level >= threshold:
      action[t] = C
    Else:
      probability_defect = (defect_count / (t - 1))
      action[t] = D with probability probability_defect, otherwise C

  Update defect_count and avg_stock_level:
    If any player defected in the previous round:
      defect_count += 1
    avg_stock_level.append(stock_level)
    if len(avg_stock_level) > 5: # consider a moving average of 5 rounds
      avg_stock_level.pop(0)

  Adjust threshold based on stock level trend:
    if sum(avg_stock_level[-3:]) / 3 >= avg_stock_level[-1]:
      threshold *= 0.95 # decrease threshold when stock is increasing or stable
    elif sum(avg_stock_level[-3:]) / 3 < avg_stock_level[-1]:
      threshold *= 1.10 # increase threshold when stock is decreasing

Return action[t]
```
**Rationale:**

* **Adaptive Cooperation:** By adjusting the cooperation threshold based on the average stock level, our strategy can respond to changes in the environment and adapt to various opponent behaviors.
* **Stock-Sensitive Tit-for-Tat:** The modified Tit-for-Tat approach ensures that our strategy is responsive to both cooperative and defecting opponents, while also considering the impact of their actions on the stock level.
* **Collective Mindset:** By cooperating when the stock level is high and adjusting our behavior in response to changes in the environment, we aim to promote collective well-being and maximize long-term payoffs.

This strategy should perform well against a wide range of opponent behaviors, as it balances cooperation with adaptation to changing environmental conditions.
'''

description_COLLECTIVE_410 = '''
To design a collective strategy for this Common Pool Resource Game, we'll employ a hybrid approach that balances individual payoff maximization with adaptive cooperation and robustness against various opponent behaviors.

**Strategy Name:** Adaptive Collective Sustainability (ACS)

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative baseline and avoid initial over-consumption.
2. **Early Rounds (r < 5):** Continue cooperating (C) until the stock level drops below 75% of capacity or if any player defects, whichever comes first.
3. **Mid-Game (5 ≤ r ≤ 20):**
	* If the average opponent cooperation rate is above 0.6, continue cooperating (C).
	* Otherwise, defect (D) for one round to signal a need for increased cooperation.
4. **Late Rounds (r > 20):** Defect (D) if the stock level falls below 25% of capacity or if fewer than two players cooperated in the previous round.

**Adaptive Component:**

* Monitor opponent behavior and adjust cooperation rate based on their actions:
	+ If an opponent defects, decrease own cooperation rate by 0.1 for that player.
	+ If an opponent cooperates, increase own cooperation rate by 0.05 for that player.
* Use a sliding window of 5 rounds to calculate the average opponent cooperation rate.

**Robustness Mechanisms:**

* **Stock Thresholds:** Implement upper and lower bounds for stock levels to prevent over-consumption or under-growth:
	+ If stock level exceeds 90% of capacity, defect (D) for one round.
	+ If stock level falls below 10% of capacity, cooperate (C) until it reaches 20%.
* **Tit-for-Tat:** Implement a tit-for-tat mechanism to respond to opponent defects:
	+ Cooperate after an opponent cooperates.
	+ Defect after an opponent defects.

**Edge Cases:**

* Last Round (r = last round): Defect (D) to maximize individual payoff, as cooperation no longer affects future stock levels.
* Opponent All-Defection: If all opponents defect consistently for 3 rounds, switch to a permanent defection strategy.

**Pseudocode Example:**
```python
def ACS(player_id, current_stock, opponent_actions, round_num):
    if round_num == 1:
        return 'C'  # Cooperate in the first round
    
    avg_coop_rate = calculate_avg_opponent_cooperation(opponent_actions)
    
    if round_num < 5 or (avg_coop_rate > 0.6 and current_stock > 0.75 * capacity):
        return 'C'  # Continue cooperating
    
    elif round_num >= 20 and (current_stock < 0.25 * capacity or opponents_cooperated < 2):
        return 'D'  # Defect in late rounds with low stock or few cooperators
    
    else:  # Mid-game
        if avg_coop_rate > 0.6:
            return 'C'
        else:
            return 'D'  # Signal need for cooperation

def calculate_avg_opponent_cooperation(opponent_actions):
    coop_count = sum(1 for action in opponent_actions if action == 'C')
    return coop_count / len(opponent_actions)

def adjust_cooperation_rate(player_id, opponent_id, opponent_action):
    if opponent_action == 'D':
        decrease_cooperation_rate(player_id, opponent_id)
    elif opponent_action == 'C':
        increase_cooperation_rate(player_id, opponent_id)
```
This Adaptive Collective Sustainability strategy (ACS) balances cooperation and individual payoff maximization while adapting to various opponent behaviors. By incorporating robustness mechanisms and edge case handling, ACS aims to promote collective sustainability in the Common Pool Resource Game.
'''

description_COLLECTIVE_411 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC is a collective strategy that balances individual payoffs with long-term sustainability of the common pool resource. It adapts to the game state and history, making it robust against various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and to avoid initial over-exploitation.
2. **Stock Conservation Threshold:** Define a threshold `θ` as a fraction of the capacity (e.g., θ = 0.25). If the current stock level is below this threshold, cooperate (C) to conserve the resource. Otherwise, defect (D).
3. **Historical Context:** Consider the average payoff obtained by all players in the previous round (`avg_payoff_prev`). If `avg_payoff_prev` is above a certain threshold (`α`, e.g., α = 10), it indicates that cooperation has been successful, and ASC will cooperate (C) in the current round. Otherwise, defect (D).
4. **Neighbor's Influence:** Observe the actions of neighboring players (i.e., those who played in the previous round). If a majority (or more than half) of neighbors cooperated, ASC will also cooperate (C).

**Pseudocode:**
```markdown
function AdaptiveStockConservation(stock, capacity, history):
  θ = 0.25 * capacity // conservation threshold
  α = 10 // historical context threshold

  if (stock < θ) or (history is empty): // initial round or low stock
    return C
  end if

  avg_payoff_prev = average payoffs of all players in previous round
  if avg_payoff_prev > α:
    return C
  end if

  neighbor_actions = actions of neighboring players in previous round
  if majority_of_neighbors_cooperated(neighbor_actions):
    return C
  end if

  return D // default to defection
end function
```
**Edge Cases:**

* Last Round: ASC will cooperate (C) in the last round, as there is no future benefit from defecting.
* Low Stock Levels: If the stock level falls below a certain threshold (e.g., `θ = 0.1 * capacity`), ASC will always cooperate (C) to prevent complete resource depletion.

**Collective Mindset:** ASC prioritizes long-term sustainability over short-term gains, promoting cooperation when the common pool resource is scarce or has been successfully conserved in the past. By adapting to the game state and history, ASC aims to create a cooperative environment that benefits all players while preventing over-exploitation of the resource.

This strategy should perform well in a tournament against independent strategies developed by other AI systems, as it balances individual payoffs with collective sustainability goals, making it robust to various opponent behaviors.
'''

description_COLLECTIVE_412 = '''
**Collective Strategy: "Adaptive Cooperative Harvesting" (ACH)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Subsequent Rounds:** Observe the previous round's stock level, total consumption, and opponents' actions.
	* If the stock level is above 75% of capacity, cooperate (C) if at least half of the opponents cooperated in the previous round; otherwise, defect (D).
	* If the stock level is between 50% and 75% of capacity, cooperate (C) if at least one opponent cooperated in the previous round; otherwise, defect (D).
	* If the stock level is below 50% of capacity, always cooperate (C) to help replenish the stock.
3. **Last Round:** Defect (D) in the last round, as there's no future benefit to cooperation.

**Edge Cases:**

1. **Tiebreakers:** In cases where the decision rule yields a tie (e.g., equal number of cooperators and defectors), cooperate (C).
2. **Opponent Behavior:** If an opponent has consistently defected in previous rounds, defect (D) in response to avoid exploitation.

**Collective Mindset:**

ACH prioritizes cooperation when possible, while adapting to opponents' behaviors and the game's state. By cooperating when the stock level is high or when others have cooperated, ACH aims to maintain a healthy stock level and encourage collective cooperation. When the stock level is low or opponents are defecting, ACH switches to defection to avoid exploitation.

**Pseudocode:**
```
Input: current_stock_level, capacity, num_opponents, opponent_actions_history
Output: action (C or D)

if first_round:
    return C

# Calculate stock threshold values
high_threshold = 0.75 * capacity
medium_threshold = 0.5 * capacity

# Analyze previous round's data
previous_round_stock_level = ...  # retrieve from history
opponents_cooperated = count opponents who cooperated in previous round

if current_stock_level > high_threshold:
    if opponents_cooperated >= num_opponents / 2:
        return C
    else:
        return D
elif medium_threshold <= current_stock_level <= high_threshold:
    if opponents_cooperated > 0:
        return C
    else:
        return D
else:  # low stock level
    return C

if last_round:
    return D

# Handle tiebreakers and opponent behavior adjustments as needed
```
By implementing ACH, our strategy will be adaptable to various opponents' behaviors while promoting collective cooperation and sustainable harvesting of the common pool resource.
'''

description_COLLECTIVE_413 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy balances individual self-interest with collective sustainability by adapting to the game's state and history.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and maximize initial stock growth.
2. **Cooperation Threshold**: Introduce a cooperation threshold, `τ` (tau), which represents the minimum acceptable stock level for cooperation. Set `τ = 0.5 * capacity`. If the current stock is below `τ`, defect (D) to prioritize individual gain over collective sustainability.
3. **Adaptive Cooperation**: Cooperate if the previous round's total consumption was less than or equal to half of the capacity, indicating a relatively sustainable usage pattern. This encourages cooperation when others are also being cautious with resource extraction.
4. **Punishment Mechanism**: If the previous round's stock growth is negative (i.e., the stock decreased), defect in the current round to signal dissatisfaction with the collective behavior and encourage more sustainable actions from other players.
5. **Learning from History**: Maintain a moving average of the last 3 rounds' total consumption (`avg_consumption`). Cooperate if `avg_consumption` is below or equal to half of the capacity, indicating a trend towards sustainability.

**Pseudocode**

```
def ASC(n, capacity, r):
    τ = 0.5 * capacity
    avg_consumption = []

    for t in range(1, r+1):
        if t == 1:
            # Initial round: Cooperate
            action = C
        else:
            previous_stock = get_previous_round_stock()
            previous_growth = get_previous_round_growth()

            if previous_stock < τ or previous_growth < 0:
                # Defect if stock is low or growth is negative
                action = D
            elif avg_consumption[-3:] <= capacity / 2:
                # Cooperate if recent consumption is sustainable
                action = C
            else:
                # Default to defection if unsure
                action = D

        take_action(action)
        update_avg_consumption(avg_consumption, get_current_round_total_consumption())
```

**Edge Cases**

* **Last Round**: Defect (D) in the last round (`r`), as there is no future stock growth to consider.
* **Stock Depletion**: If the current stock is depleted (i.e., reaches 0), defect (D) to avoid wasting actions on a depleted resource.

**Collective Mindset**

The ASC strategy promotes collective sustainability by:

1. Encouraging cooperation when the stock level is high and consumption patterns are sustainable.
2. Punishing overconsumption by defecting in response to negative stock growth.
3. Adapting to the game's history, using a moving average of consumption to inform decisions.

By balancing individual self-interest with collective sustainability concerns, ASC aims to create a robust and adaptive strategy that performs well against a wide range of opponent behaviors.
'''

description_COLLECTIVE_414 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

The ACST strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and history of play.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to follow suit.
2. **Stock-Based Threshold:** Calculate a dynamic threshold `T` as a function of the current stock level `S` and capacity `capacity`. If `S` is above `T`, cooperate; otherwise, defect.

Pseudocode:
```
function calculate_threshold(S, capacity):
  T = capacity / (n + 1) * (S / capacity)
  return T

if S > calculate_threshold(S, capacity):
  action = C
else:
  action = D
```

The threshold `T` is designed to decrease as the stock level approaches zero, making it more likely for players to defect when the resource is scarce. Conversely, when the stock level is high, the threshold increases, encouraging cooperation.

3. **History-Based Adjustment:** Monitor the history of play and adjust the decision rule based on the average payoff received in previous rounds. If the average payoff is below a certain threshold (e.g., 75% of the maximum possible payoff), increase the likelihood of defecting by reducing the stock-based threshold `T`.

Pseudocode:
```
function adjust_threshold(avg_payoff, max_payoff):
  if avg_payoff < 0.75 * max_payoff:
    T *= 0.9
  return T

avg_payoff = calculate_average_payoff(previous_rounds)
T = adjust_threshold(avg_payoff, max_payoff)
```

This adjustment mechanism allows the strategy to adapt to opponents who consistently defect or cooperate at suboptimal levels.

4. **Last Round:** In the final round, always cooperate (C) to maximize the collective payoff and encourage others to do the same.

**Edge Cases:**

* If multiple players tie for the lowest stock level, prioritize cooperation to avoid over-exploitation.
* If the stock level is exactly at capacity, cooperate to maintain sustainability.

**Collective Mindset:**

The ACST strategy prioritizes cooperation when the resource is abundant and adjusts its behavior based on the history of play. By doing so, it aims to create a collective mindset that promotes sustainable use of the common pool resource while allowing for individual adaptability in response to changing circumstances.

This strategy should perform well in a tournament setting against independent strategies developed by other AI systems, as it balances cooperation with self-interest and adapts to a wide range of opponent behaviors.
'''

description_COLLECTIVE_415 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to follow suit.
2. **Stock-Based Threshold:** Calculate a dynamic threshold, `T`, based on the current stock level (`S`) and capacity (`capacity`): `T = S / (2 * capacity)`
3. **Cooperation Condition:** Cooperate if:
	* The current round is not the last round (`r > 1`)
	* The total consumption in the previous round was below a certain percentage of the capacity (e.g., 50%)
	* The number of cooperators in the previous round is above a certain threshold (e.g., `n/2`)
	* The current stock level is above the calculated threshold (`S >= T * capacity`)
4. **Defection Condition:** Defect if none of the cooperation conditions are met.

**Pseudocode:**
```
def ACST(n, r, capacity, history):
  # Initialize variables
  S = capacity  # Initial stock level
  T = 0.5       # Initial threshold value

  for t in range(r):
    # Calculate dynamic threshold based on current stock level
    T = S / (2 * capacity)

    # Check cooperation conditions
    if (t < r - 1) and          # Not the last round
       (previous_total_consumption < 0.5 * capacity) and
       (num_cooperators_last_round >= n/2) and
       (S >= T * capacity):
      action = C  # Cooperate
    else:
      action = D  # Defect

    # Update history and stock level
    history.append(action)
    S -= calculate_total_consumption(history)

    # Calculate new stock level based on growth and capacity
    S = min(S + calculate_stock_growth(S, capacity), capacity)

  return history
```
**Edge Cases:**

* **Last Round:** Defect in the last round to maximize individual payoff.
* **Low Stock Levels:** Cooperate when the current stock level is low (e.g., below `T * capacity`) to prevent depletion and promote growth.

**Collective Mindset:**

The ACST strategy prioritizes cooperation when conditions are favorable, encouraging others to cooperate as well. By considering the collective impact of individual actions on the common pool resource, this strategy promotes sustainable harvesting and maximizes overall payoffs for all players. The adaptive threshold mechanism allows the strategy to respond to changes in the game state and opponent behaviors, ensuring robustness in a wide range of scenarios.

This collective strategy will be implemented as an algorithm and participate in a tournament against independent strategies developed by other AI systems, aiming to achieve high payoffs while promoting cooperation and sustainability in the Common Pool Resource Game.
'''

description_COLLECTIVE_416 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Overview**
ACH is a dynamic, adaptive strategy that balances individual payoff maximization with collective stock sustainability. It leverages game history and current state to adjust cooperation levels, ensuring robustness against diverse opponent behaviors.

**Decision Rules**

1. **Initial Cooperation**: In the first round, cooperate (C) to establish a baseline for stock growth and encourage reciprocal cooperation.
2. **Stock-Based Threshold**: Set a dynamic threshold, `θ`, based on the current stock level (`S`) and capacity (`cap`): `θ = S / cap`. If `θ ≥ 0.5`, cooperate; otherwise, defect (D).
3. **History-Dependent Adjustment**: Monitor the average payoff difference between cooperation and defection over the last `k` rounds (`Δπ`). If `Δπ > 0`, indicating that cooperation is beneficial, increase the threshold by a small margin (`ε`); if `Δπ < 0`, decrease it.
4. **Exploitation Detection**: Track the number of consecutive rounds where at least one player defects (`d_count`). If `d_count ≥ n/2` (where `n` is the number of players), assume exploitation and temporarily switch to defection for a single round.

**Pseudocode**
```python
def ACH(n, cap, r, S):
    θ = 0.5  # initial threshold
    Δπ = 0   # payoff difference history
    d_count = 0  # exploitation detection counter
    k = 3    # number of rounds for history-dependent adjustment

    for t in range(r):
        if t == 0:
            action = C  # cooperate in the first round
        else:
            θ = S / cap
            Δπ_avg = sum([Δπ_i for i in range(max(0, t-k), t)]) / k
            if Δπ_avg > 0:
                θ += ε  # increase threshold when cooperation is beneficial
            elif Δπ_avg < 0:
                θ -= ε  # decrease threshold when cooperation is not beneficial

            if d_count >= n/2:
                action = D  # temporarily defect to counter exploitation
                d_count = 0
            else:
                action = C if θ >= S / cap else D

        # update state and history
        S, Δπ = update_state_and_history(S, action, n)
        d_count += 1 if action == D else 0

    return total_payoff
```
**Edge Cases**

* **Last Round**: Cooperate to ensure maximum payoff in the final round.
* **Low Stock Levels**: If `S < n`, defect to avoid over-exploitation.

By incorporating game history, stock dynamics, and adaptive threshold adjustments, ACH balances individual interests with collective sustainability. This strategy is robust against various opponent behaviors and can effectively adapt to changing game conditions.
'''

description_COLLECTIVE_417 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Awareness (ACS)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a cooperative tone and maximize initial payoff.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, cooperate (C) with probability p = (current_stock/capacity)^2, otherwise defect (D). This probabilistic approach encourages cooperation when the stock is relatively high but allows for some exploration.
	* If the current stock level is below 50% of capacity, defect (D).
3. **Stock Depletion Response:** If the total consumption in the previous round exceeded 75% of the remaining stock, cooperate (C) with probability p = (1 - previous_total_consumption/previous_stock)^2, otherwise defect (D). This response helps to counter over-exploitation.
4. **Opponent Behavior Adaptation:**
	* Monitor the frequency of cooperation and defection among opponents.
	* If more than 50% of opponents cooperated in the previous round, increase the probability of cooperating by 10%.
	* If more than 50% of opponents defected in the previous round, decrease the probability of cooperating by 10%.

**Pseudocode:**
```python
def ACS(n, capacity, current_stock, history):
    # Initial Round
    if len(history) == 0:
        return 'C'
    
    # Subsequent Rounds
    stock_ratio = current_stock / capacity
    
    if stock_ratio >= 0.75:
        return 'C'
    elif 0.5 <= stock_ratio < 0.75:
        p = (stock_ratio ** 2)
        return 'C' if random.random() < p else 'D'
    else:
        return 'D'
    
    # Stock Depletion Response
    prev_total_consumption = sum(history[-1]['consumptions'])
    prev_stock = history[-1]['stock']
    if prev_total_consumption / prev_stock > 0.75:
        p = ((1 - prev_total_consumption/prev_stock) ** 2)
        return 'C' if random.random() < p else 'D'
    
    # Opponent Behavior Adaptation
    opponent_cooperation_rate = sum(1 for action in history[-1]['actions'] if action == 'C') / n
    if opponent_cooperation_rate > 0.5:
        cooperation_prob += 0.1
    elif opponent_cooperation_rate < 0.5:
        cooperation_prob -= 0.1
    
    return 'C' if random.random() < cooperation_prob else 'D'
```
**Collective Mindset:**

The ACS strategy prioritizes cooperation when the stock is relatively high, adapting to the current state of the common pool resource. By responding to opponent behavior and adjusting its own probability of cooperating, ACS promotes a collective mindset that balances individual payoffs with the need for sustainable resource management.

By employing this adaptive strategy, we aim to create a robust and effective approach to managing the common pool resource, even in the presence of diverse opponent behaviors.
'''

description_COLLECTIVE_418 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoff maximization with collective stock conservation, ensuring a sustainable common pool resource across multiple rounds.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Stock Conservation Threshold**: Define a threshold `stock_threshold` as 0.5 * capacity. If the current stock level is below this threshold, cooperate (C). Otherwise, consider the following rules:
3. **Opponent Behavior Analysis**: Analyze the history of opponents' actions and calculate the proportion of cooperative actions (`p_coop`) in the previous round.
	* If `p_coop` ≥ 0.5, cooperate (C) to reinforce cooperation.
	* If `p_coop` < 0.5, defect (D) to avoid exploitation.
4. **Stock Growth Incentive**: If the current stock level is above the threshold and growing (i.e., the previous round's consumption was sustainable), cooperate (C) to encourage further growth.
5. **Last Round**: Defect (D) in the last round, as there are no future rounds to consider.

**Pseudocode:**
```
function ASC(current_stock, capacity, history):
  if current_round == 1:
    return COOPERATE
  end

  stock_threshold = 0.5 * capacity
  if current_stock < stock_threshold:
    return COOPERATE
  end

  p_coop = calculate_proportion_of_cooperative_actions(history)
  if p_coop >= 0.5:
    return COOPERATE
  else:
    return DEFECT
  end

  if is_stock_growing(current_stock, history):
    return COOPERATE
  end

  if current_round == total_rounds:
    return DEFECT
  end
end
```
**Edge Cases:**

* If the stock level reaches 0, defect (D) to avoid wasting actions.
* In cases of a tie in `p_coop`, cooperate (C) to maintain a cooperative stance.

**Collective Mindset:**
The ASC strategy prioritizes cooperation when the stock level is low or growing sustainably. By analyzing opponents' behaviors and adapting to their strategies, ASC aims to promote a collective understanding of sustainable resource management. By cooperating in the first round and under specific conditions, ASC encourages cooperation while being robust against exploitation by defecting opponents.

This strategy will perform well in a tournament setting, as it balances individual payoff maximization with collective stock conservation, making it an attractive choice for players seeking a sustainable outcome.
'''

description_COLLECTIVE_419 = '''
**Collective Strategy: Adaptive Cooperativity (AC)**

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to establish a cooperative tone and avoid initial over-exploitation.
2. **Current Stock Threshold**: Define a threshold `T` as a fraction of the capacity (e.g., `T = 0.7 * capacity`). If the current stock level is above this threshold (`stock >= T`), play Cooperate (C). Otherwise, play Defect (D).
3. **Recent Opponent Behavior**: Track the number of opponents who played Defect (D) in the previous round (`defectors_prev_round`). If `defectors_prev_round` is greater than or equal to half of the total players (`n/2`), play Defect (D) in the current round.
4. **Adaptive Response**: Monitor the stock growth over the last few rounds (e.g., 3-5 rounds). If the average stock growth is negative, switch from Cooperate (C) to Defect (D) for a single round to avoid further depletion.

**Edge Cases:**

1. **Last Round**: In the final round, play Defect (D) to maximize individual payoff.
2. **Stock Depletion**: If the current stock level falls below a critical threshold (`stock < 0.2 * capacity`), switch to Defect (D) to avoid complete depletion.
3. **Opponent Homogeneity**: If all opponents have played Cooperate (C) for multiple rounds, continue playing Cooperate (C) to maintain collective cooperation.

**Collective Mindset:**

The Adaptive Cooperativity strategy prioritizes cooperation while being responsive to opponent behavior and environmental conditions. By starting with cooperation and adapting to the situation, AC encourages other players to cooperate, promoting a stable and beneficial collective outcome.

Pseudocode:
```python
def adaptive_cooperativity(stock, capacity, n, defectors_prev_round):
    T = 0.7 * capacity

    if stock >= T:
        return 'C'  # Cooperate if stock is above threshold
    elif defectors_prev_round >= n/2:
        return 'D'  # Defect if many opponents defected previously
    elif recent_stock_growth < 0:  # monitor stock growth over last few rounds
        return 'D'  # Switch to defect for a round if stock is depleting
    else:
        return 'C'  # Otherwise, cooperate

def update_recent_stock_growth(stock_history):
    # Calculate average stock growth over last few rounds (e.g., 3-5 rounds)
    recent_growth = sum(stock_history[-3:]) / len(stock_history[-3:])
    return recent_growth
```
This strategy balances individual self-interest with collective cooperation, making it a robust and adaptive approach for the Common Pool Resource Game.
'''

description_COLLECTIVE_420 = '''
Here's a collective strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Cooperation (AC)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative tone and encourage others to cooperate.
2. **Subsequent Rounds (t>1):**
   * If the current stock level is above 75% of capacity, Cooperate (C).
   * If the current stock level is between 25% and 75% of capacity, Defect (D) with a probability proportional to the number of opponents who defected in the previous round.
   * If the current stock level is below 25% of capacity, Defect (D).

Pseudocode:
```markdown
IF t == 1 THEN
    action = C
ELSE IF stock > 0.75 * capacity THEN
    action = C
ELSE IF stock >= 0.25 * capacity AND stock <= 0.75 * capacity THEN
    p_defect = (number of opponents who defected in previous round) / n
    action = D with probability p_defect, otherwise C
ELSE
    action = D
END IF
```

**Edge Cases:**

* **Last Round (t=r):** Cooperate (C) to maximize the final payoff and avoid over-exploitation.
* **Low Stock Levels:** If the stock level falls below 25% of capacity, Defect (D) to prioritize individual gain over collective sustainability.

**Collective Mindset:**
The Adaptive Cooperation strategy aims to balance individual self-interest with collective well-being. By initially cooperating and adapting to changing stock levels, AC encourages opponents to cooperate while ensuring individual payoffs are maximized. This approach promotes a collective mindset by:

1. **Rewarding cooperation:** AC rewards cooperative behavior when the stock level is high, promoting a culture of mutual benefit.
2. **Punishing over-exploitation:** AC punishes over-exploitation by defecting when the stock level falls below 25% of capacity, discouraging opponents from exploiting the common resource.
3. **Adapting to opponent behavior:** AC adjusts its strategy based on opponent actions in previous rounds, demonstrating a willingness to cooperate or adapt to changing circumstances.

By employing this adaptive and collective strategy, we aim to achieve a balance between individual self-interest and collective sustainability in the Common Pool Resource Game.
'''

description_COLLECTIVE_421 = '''
I'll outline a collective strategy for this game that adapts to various opponent behaviors and focuses on sustainability of the common pool resource.

**Strategy Name:** Adaptive Common Pool Resource Management (ACPRM)

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation from other players.
2. **Subsequent Rounds:** Assess the current stock level and previous rounds' actions:
	* If the stock level is above 75% of capacity, cooperate (C).
	* If the stock level is between 50% and 75% of capacity, defect (D) with a probability proportional to the number of players who defected in the previous round.
	* If the stock level is below 50% of capacity, defect (D).
3. **Stock Depletion Response:** Monitor the stock depletion rate and adjust strategy accordingly:
	* If the stock depletion rate exceeds 20% per round, switch to cooperate (C) for one round to slow down depletion.
4. **Opponent Behavior Adaptation:**
	* Track the frequency of cooperation (F_C) and defection (F_D) among opponents over a window of recent rounds (e.g., 5 rounds).
	* Adjust the probability of defecting in response to opponents' behavior:
		+ If F_C > 0.6, decrease the probability of defecting by 10%.
		+ If F_D > 0.4, increase the probability of defecting by 10%.

**Edge Cases:**

1. **Last Round:** Cooperate (C) in the last round to ensure maximum stock growth and a higher final payoff.
2. **Low Stock Levels:** When the stock level is critically low (<25% of capacity), cooperate (C) to allow for some stock growth.

**Collective Mindset Alignment:**

1. **Stock Sustainability:** Prioritize maintaining a sustainable stock level by cooperating when possible and adjusting strategy in response to opponents' behavior.
2. **Reciprocity:** Adapt to opponents' cooperation/defection frequencies to promote mutual cooperation and avoid exploitation.
3. **Robustness:** Balance individual interests with collective well-being, ensuring the common pool resource remains viable throughout the game.

**Pseudocode:**
```python
ACPRM_Strategy(stock_level, capacity, num_players, round_num, previous_round_actions):
    if round_num == 1:
        return COOPERATE
    
    stock_depletion_rate = calculate_stock_depletion_rate(previous_round_actions)
    
    if stock_level > 0.75 * capacity:
        return COOPERATE
    elif stock_level >= 0.5 * capacity and stock_level <= 0.75 * capacity:
        defect_probability = calculate_defect_probability(stock_depletion_rate, previous_round_actions)
        return DEFECT with probability defect_probability
    else:
        return DEFECT
    
    if stock_depletion_rate > 0.2:
        return COOPERATE for one round
    
    opponent_behavior = track_opponent_cooperation_frequency(previous_round_actions)
    
    if opponent_behavior[F_C] > 0.6:
        decrease_defect_probability(10%)
    elif opponent_behavior[F_D] > 0.4:
        increase_defect_probability(10%)
```
This strategy balances individual interests with collective well-being, adapting to opponents' behavior while prioritizing stock sustainability and reciprocity.
'''

description_COLLECTIVE_422 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy balances individual self-interest with collective conservation of the common pool resource. It adapts to changing stock levels and opponent behaviors, promoting cooperation when beneficial for all players.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' actions.
2. **Stock-Based Cooperation**: For rounds 2 to r-1:
	* If stock ≥ capacity/2, cooperate (C). This ensures sustainable consumption when the stock is healthy.
	* If stock < capacity/2, defect (D) with probability p = (capacity - stock) / capacity. This introduces a degree of defection as the stock dwindles, while still allowing for some cooperation.
3. **Last Round**: Defect (D) in the final round (r), as there is no future cost to overconsumption.

**Edge Case Handling:**

* If an opponent defects and the stock falls below capacity/2, ASC will adapt by increasing its defection probability in subsequent rounds.
* If multiple opponents cooperate and the stock rises above capacity/2, ASC will cooperate more frequently to maintain a sustainable consumption level.

**Collective Mindset:**

The ASC strategy prioritizes collective conservation of the common pool resource while allowing for individual self-interest. By cooperating when the stock is healthy and adapting to changing opponent behaviors, ASC promotes a stable and resilient collective outcome.

**Pseudocode:**
```python
def ASC(stock, capacity, round_number, r):
  if round_number == 1:
    return C  # Cooperate in first round
  elif stock >= capacity / 2:
    return C  # Cooperate when stock is healthy
  else:
    p = (capacity - stock) / capacity
    return D with probability p  # Defect with adaptive probability

if round_number == r:
  return D  # Defect in final round
```
The ASC strategy is designed to be robust and adaptive, responding to changing opponent behaviors while prioritizing collective conservation of the common pool resource. By balancing individual self-interest with cooperation, ASC promotes a stable and resilient collective outcome.
'''

description_COLLECTIVE_423 = '''
**Collective Strategy: Adaptive Cooperation with Stock Feedback (ACSF)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and gather information on opponents' behavior.
2. **Stock Threshold**: If the current stock level is above 75% of the capacity, cooperate (C). This encourages sustainable consumption and avoids over-depletion.
3. **Opponent Behavior Feedback**: Monitor the average payoff of all players in the previous round. If the average payoff is below 50% of the maximum possible payoff (i.e., S/(2n)), it indicates excessive defection or stock depletion. In this case, defect (D) to protect your own interests.
4. **Recent Stock Trend**: Analyze the recent stock trend by comparing the current stock level with the average stock level over the last 3 rounds. If the stock is decreasing, cooperate (C) to help stabilize it. If the stock is increasing or stable, defect (D) to maximize personal gains.

**Pseudocode:**
```python
def ACSF(current_stock, capacity, previous_payoffs, round_number):
    if round_number == 1:
        return "Cooperate"
    
    if current_stock > 0.75 * capacity:
        return "Cooperate"
    
    avg_previous_payoff = sum(previous_payoffs) / len(previous_payoffs)
    if avg_previous_payoff < 0.5 * (current_stock / (2 * n)):
        return "Defect"
    
    recent_stock_trend = [stock_level for stock_level in previous_stock_levels[-3:]]
    if sum(recent_stock_trend) > current_stock:
        return "Cooperate"
    else:
        return "Defect"
```
**Handling Edge Cases:**

* **Last Round**: In the final round, prioritize maximizing personal gains by defecting (D), as there is no future stock to conserve.
* **Low Stock Levels**: If the current stock level falls below 25% of the capacity, cooperate (C) to prevent complete depletion and allow for potential recovery.

**Collective Mindset:**

ACSF aims to balance individual self-interest with collective sustainability. By cooperating when the stock is healthy and defecting when opponents are over-exploiting, this strategy promotes a stable and mutually beneficial environment. The adaptive nature of ACSF allows it to respond effectively to various opponent behaviors, making it robust in a tournament setting.

By following these decision rules, ACSF encourages cooperation while protecting individual interests, fostering a collective mindset that balances short-term gains with long-term sustainability.
'''

description_COLLECTIVE_424 = '''
**Collective Strategy: "Adaptive Sustainability"**

Our collective strategy focuses on balancing individual payoffs with long-term sustainability of the common pool resource. We'll adapt to the game's state and history while promoting cooperation among players.

**Decision Rules:**

1. **Initial Rounds (t ≤ n):**
	* Cooperate (C) in the first round to establish a baseline for cooperation.
	* In subsequent initial rounds, mirror the most frequent action played by other players in the previous round (i.e., if most players cooperated, cooperate; otherwise, defect).
2. **Middle Rounds (t > n):**
	* If the current stock level is above 75% of capacity:
		+ Cooperate (C) with probability p = (stock / capacity)^0.5
		+ Defect (D) with probability 1 - p
	* If the current stock level is below 25% of capacity:
		+ Defect (D)
	* Otherwise, play a mixed strategy: Cooperate with probability p = 0.5 and Defect with probability 0.5.
3. **Final Round (t = r):**
	* If the current stock level is above 50% of capacity:
		+ Cooperate (C) to maintain some sustainability
	* Otherwise, Defect (D) to maximize individual payoff

**Edge Cases:**

1. **Low Stock:** When the stock level falls below 10% of capacity, defect in all subsequent rounds to avoid further depletion.
2. **High Stock:** If the stock level exceeds 90% of capacity, cooperate in all subsequent rounds to prevent over-exploitation.

**Pseudocode (simplified):**
```python
def adaptive_sustainability(stock, capacity, t, r, n):
    if t <= n:  # initial rounds
        if t == 1:
            return 'C'  # cooperate initially
        else:
            prev_actions = get_prev_round_actions()
            most_freq_action = max(set(prev_actions), key=prev_actions.count)
            return most_freq_action

    elif stock / capacity > 0.75:  # high stock level
        p = (stock / capacity)**0.5
        return 'C' if random.random() < p else 'D'

    elif stock / capacity < 0.25:  # low stock level
        return 'D'

    elif t == r:  # final round
        if stock / capacity > 0.5:
            return 'C'
        else:
            return 'D'

    else:  # middle rounds
        p = 0.5
        return 'C' if random.random() < p else 'D'
```
**Collective Mindset Alignment:**

Our strategy promotes cooperation by:

1. Mirroring others' actions in initial rounds to encourage coordination.
2. Gradually increasing cooperation as the stock level increases, reflecting a shared interest in sustainability.
3. Limiting exploitation when the stock level is low or high.

By adapting to the game's state and history, our collective strategy balances individual payoffs with long-term sustainability, aligning with the collective mindset of promoting cooperation while protecting the common pool resource.
'''

description_COLLECTIVE_425 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline for cooperation and observe opponents' actions.
2. **Subsequent Rounds:** Use a hybrid approach, combining elements of Tit-for-Tat (TFT) and a novel stock-based threshold.

**Stock-Based Threshold:**
Calculate the `stock_threshold` as a fraction of the capacity:

`stock_threshold = 0.5 * capacity / n`

If the current stock is above this threshold, play Cooperate (C). Otherwise, play Defect (D).

**Tit-for-Tat Component:**
Monitor opponents' actions in previous rounds and adjust your strategy accordingly:

* If a majority of opponents (>50%) defected in the previous round, defect (D) in the current round.
* If a majority of opponents cooperated (>50%) in the previous round, cooperate (C) in the current round.

**Edge Case Handling:**

1. **Last Round:** Defect (D), as there is no future game to consider.
2. **Low Stock Levels (< 10% capacity):** Defect (D) to avoid over-exploitation and ensure some payoff.
3. **High Opponent Defection Rate (>75%):** Cooperate (C) with a probability of 0.25, and defect (D) otherwise, to maintain some level of cooperation while avoiding exploitation.

**Collective Mindset:**
ASC prioritizes the conservation of the common pool stock while adapting to opponents' behaviors. By initially cooperating and then adjusting based on stock levels and opponent actions, ASC aims to promote a stable and sustainable game environment.

Pseudocode:
```markdown
# Initialize variables
stock_threshold = 0.5 * capacity / n

def ASC(stock, opponents_actions):
    # Initial round: Cooperate
    if current_round == 1:
        return C
    
    # Stock-based threshold
    if stock > stock_threshold:
        action = C
    else:
        action = D
    
    # Tit-for-Tat component
    majority_opponent_action = get_majority_opponent_action(opponents_actions)
    if majority_opponent_action == D and opponents_defection_rate() < 0.75:
        action = D
    elif majority_opponent_action == C:
        action = C
    
    # Edge case handling
    if current_round == r or stock < 0.1 * capacity:
        return D
    elif opponents_defection_rate() > 0.75:
        return random.choice([C, D], p=[0.25, 0.75])
    
    return action
```
This strategy should be robust to a wide range of opponent behaviors and promote a stable game environment by balancing cooperation and self-interest.
'''

description_COLLECTIVE_426 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability, adapting to the game's dynamic state and opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative tone and observe opponents' initial actions.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, Cooperate (C) to maintain a sustainable stock level.
	* If the current stock level is between 50% and 75% of the capacity, Defect (D) with a probability proportional to the number of opponents who defected in the previous round. This "punishes" defectors while allowing for some exploitation.
	* If the current stock level is below 50% of the capacity, Cooperate (C) to help replenish the stock and avoid depletion.
3. **Last Round (t=r):** Defect (D) to maximize individual payoff, as there are no future rounds to consider.

**Additional Heuristics:**

* **Opponent Monitoring:** Track the number of opponents who defected in each round. If more than half of the opponents defected, increase the probability of defecting in subsequent rounds.
* **Stock Trend Analysis:** Monitor the stock level trend over the past few rounds. If the stock is consistently decreasing, Cooperate (C) to help reverse the trend.

**Pseudocode:**
```python
def ASC(n, r, capacity, current_stock, history):
  if t == 1:
    return C  # Initial round cooperation
    
  elif current_stock >= 0.75 * capacity:
    return C  # Cooperate when stock is high
  
  elif 0.5 * capacity <= current_stock < 0.75 * capacity:
    defect_prob = (num_defectors_in_prev_round / n)
    if random.random() < defect_prob:
      return D
    else:
      return C
    
  elif current_stock < 0.5 * capacity:
    return C  # Cooperate when stock is low
  
  elif t == r:  # Last round
    return D  # Maximize individual payoff

def update_history(history, actions):
  # Update opponent monitoring and stock trend analysis data structures
```
The ASC strategy is designed to be adaptive, robust, and collective, balancing individual payoffs with the need for sustainable resource management. By monitoring opponents' actions and adjusting behavior accordingly, ASC aims to promote cooperation while minimizing the risk of exploitation.
'''

description_COLLECTIVE_427 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. This approach prioritizes cooperation when the stock is healthy and gradually shifts towards defection as the stock declines.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for collective behavior.
2. **Stock Thresholds:** Define two stock thresholds:
	* `high_threshold = 0.75 * capacity`
	* `low_threshold = 0.25 * capacity`
3. **Cooperation Zone:** If `stock ≥ high_threshold`, Cooperate (C).
4. **Defection Zone:** If `stock ≤ low_threshold`, Defect (D).
5. **Adaptive Zone:** If `low_threshold < stock < high_threshold`, use the following adaptive logic:
	* Calculate the average payoff per player in the previous round (`avg_payoff_prev`).
	* Calculate the total consumption in the previous round (`total_consumption_prev`).
	* If `avg_payoff_prev / total_consumption_prev ≥ 0.5`, Cooperate (C); otherwise, Defect (D).

**Edge Cases:**

1. **Last Round:** In the final round, always Defect (D) to maximize individual payoff.
2. **Ties in Adaptive Zone:** If the average payoff per player is exactly equal to half of the total consumption, Cooperate (C) to prioritize collective sustainability.

**Collective Mindset:**

The ASC strategy prioritizes cooperation when the stock is healthy and gradually adapts to more individualistic behavior as the stock declines. By using a combination of fixed thresholds and adaptive logic, this approach balances short-term gains with long-term sustainability. In the final round, the strategy prioritizes individual payoff to maximize overall score.

**Pseudocode:**
```python
def ASC(stock, capacity, n, r, history):
    high_threshold = 0.75 * capacity
    low_threshold = 0.25 * capacity
    
    if r == 1:  # First round
        return "C"
    
    if stock >= high_threshold:
        return "C"
    elif stock <= low_threshold:
        return "D"
    else:
        avg_payoff_prev = calculate_average_payoff(history)
        total_consumption_prev = calculate_total_consumption(history)
        
        if avg_payoff_prev / total_consumption_prev >= 0.5:
            return "C"
        else:
            return "D"

def calculate_average_payoff(history):
    # Calculate average payoff per player in the previous round
    pass

def calculate_total_consumption(history):
    # Calculate total consumption in the previous round
    pass
```
This strategy is designed to be robust and adaptive, allowing it to perform well against a wide range of opponent behaviors.
'''

description_COLLECTIVE_428 = '''
**Collective Strategy: Adaptive Cooperation with Stock-based Trigger (ACST)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Stock-dependent Cooperation**: For rounds 2 to r-1, cooperate if the current stock level is above a certain threshold (T). The threshold T is set as a fraction of the capacity: T = α \* capacity, where α ∈ [0, 1] is a tunable parameter. If the stock level is below this threshold, defect (D).
3. **Punishment Mechanism**: Monitor the opponent's behavior and adjust your action based on their previous round's actions. If an opponent defects when the stock level was above T, punish them by defecting in the next round. Otherwise, follow the stock-dependent cooperation rule.
4. **Last Round**: Defect (D) in the last round to maximize personal payoff.

**Pseudocode:**

```
function ACST(stock, capacity, alpha, opponent_actions):
  if current_round == 1:
    return C
  else:
    threshold = alpha * capacity
    if stock > threshold:
      if any(opponent_defected(opponent_actions)):
        return D (punish)
      else:
        return C
    else:
      return D

function opponent_defected(opponent_actions):
  for action in opponent_actions:
    if action == D and stock > T:
      return True
  return False
```

**Rationale:**

1. **Initial cooperation**: Encourages opponents to cooperate, increasing the initial stock level.
2. **Stock-dependent cooperation**: Balances individual payoff with collective sustainability. When the stock is high, cooperation maintains a healthy stock level, while defecting when the stock is low allows for personal gain without depleting the resource.
3. **Punishment mechanism**: Deters opponents from exploiting cooperation by introducing a consequence for defecting when the stock is above the threshold. This promotes reciprocal cooperation and helps maintain a sustainable stock level.
4. **Last-round defection**: Maximizes individual payoff in the final round, as there are no future rounds to consider.

**Tunable parameter (α)**:

Adjust α to control the trade-off between individual payoff and collective sustainability. A higher α value will lead to more cooperation, while a lower α value will result in more defection. The optimal α value may depend on the specific game parameters and opponent behaviors.

This strategy is adaptive, robust, and aligned with the collective mindset, making it suitable for a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_429 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to follow suit.
2. **Subsequent Rounds**: Use the following adaptive decision rule:
	* If the current stock level is above a certain threshold ( Stock_Threshold ), cooperate (C). Otherwise, defect (D).
	* Stock_Threshold = capacity \* (1 - 1/(n+1))
3. **Stock-Dependent Adjustment**: Adjust the Stock_Threshold based on the current stock level and the number of players:
	* If the current stock level is below capacity/2, decrease Stock_Threshold by 10% to encourage more cooperation.
	* If the current stock level is above capacity * (1 - 1/n), increase Stock_Threshold by 5% to allow for more exploitation.

**Pseudocode:**
```
Function ACSDT(n, capacity, stock, history)
  if round == 1 then
    return C // Cooperate in the first round
  end if

  Stock_Threshold = capacity * (1 - 1/(n+1))

  if stock < capacity/2 then
    Stock_Threshold *= 0.9 // Decrease threshold when stock is low
  elseif stock > capacity * (1 - 1/n) then
    Stock_Threshold *= 1.05 // Increase threshold when stock is high
  end if

  if stock >= Stock_Threshold then
    return C // Cooperate if stock is above the threshold
  else
    return D // Defect otherwise
  end if
end Function
```
**Collective Mindset:**

The ACSDT strategy aims to balance individual self-interest with collective sustainability. By cooperating when the stock level is high and defecting when it's low, we encourage others to do the same, promoting a stable and sustainable common pool resource.

**Robustness to Opponent Behaviors:**

ACSDT adapts to various opponent behaviors by:

* Cooperating in the first round to establish a cooperative tone.
* Adjusting the Stock_Threshold based on the current stock level and number of players, making it more responsive to changing game conditions.
* Encouraging cooperation when the stock is low and allowing for more exploitation when the stock is high.

**Edge Cases:**

* **Last Round**: ACSDT will defect in the last round if the stock level is below the Stock_Threshold , as there's no future benefit from cooperating.
* **Stock Level = 0**: If the stock level reaches 0, ACSDT will always cooperate to allow for potential regeneration.

By using this adaptive strategy, we aim to promote cooperation and sustainability in the common pool resource game while being robust to a wide range of opponent behaviors.
'''

description_COLLECTIVE_430 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round (t=1):**
   - Observe the initial stock level and calculate the safe consumption threshold: `safe_threshold = capacity / (2n)`.
   - If the current stock is above this threshold, play C (Cooperate). Otherwise, play D (Defect).

2. **Subsequent Rounds (t>1):**
   - Track the history of all players' actions and calculate the average cooperation rate: `avg_coop_rate = Σ(cooperative_actions) / (n * t)`.
   - If the average cooperation rate is above 0.5, play C.
   - If the stock level has decreased below the safe consumption threshold in the previous round, play D.

3. **Adaptive Adjustment:**
   - Monitor the change in stock levels over time and adjust the strategy based on the trend:
     - If the stock level increases or remains stable for two consecutive rounds, decrease the safe consumption threshold by 10% to encourage cooperation.
     - If the stock level decreases for two consecutive rounds, increase the safe consumption threshold by 10% to conserve resources.

**Edge Case Handling:**

1. **Last Round (t=r):**
   - Play D, as there are no future consequences for over-consumption.

2. **Tie-Breaking:**
   - In cases where the decision rule yields a tie (e.g., equal number of cooperative and defective actions), play C to prioritize cooperation.

3. **Opponent Behavior Analysis:**
   - Continuously monitor opponents' actions and adjust the strategy based on observed patterns:
     - If an opponent consistently defects, consider playing D in response.
     - If multiple opponents cooperate, increase the safe consumption threshold to encourage further cooperation.

**Collective Mindset Alignment:**

1. **Cooperation Incentives:**
   - By cooperating when the average cooperation rate is above 0.5, ACC encourages other players to do the same, promoting a collective conservation mindset.

2. **Resource Conservation:**
   - The adaptive adjustment mechanism ensures that the strategy prioritizes resource conservation when necessary, aligning with the collective goal of sustaining the common pool.

**Pseudocode (simplified):**

```
function ACC(current_stock, capacity, n, t, history) {
  // Initial Round
  if (t == 1) {
    safe_threshold = capacity / (2n);
    return current_stock > safe_threshold ? C : D;
  }

  // Subsequent Rounds
  avg_coop_rate = calculate_average_cooperation_rate(history);
  if (avg_coop_rate > 0.5) return C;

  // Adaptive Adjustment
  stock_trend = analyze_stock_level_change(history);
  if (stock_trend == increasing || stable) {
    safe_threshold *= 0.9;
  } else if (stock_trend == decreasing) {
    safe_threshold *= 1.1;
  }

  // Last Round
  if (t == r) return D;

  // Tie-Breaking and Opponent Analysis
  opponent_actions = analyze_opponent_behavior(history);
  if (opponent_actions.tie || opponent_defects_consistently) {
    return D;
  } else if (multiple_opponents_cooperate) {
    safe_threshold *= 1.1;
  }

  return current_stock > safe_threshold ? C : D;
}
```

This strategy, ACC, balances cooperation and resource conservation while adapting to various opponent behaviors. It prioritizes collective conservation and incentivizes cooperation by responding to changes in the game state and history.
'''

description_COLLECTIVE_431 = '''
I propose a collective strategy called "Adaptive Stock Conservation" (ASC). ASC aims to balance individual payoffs with the long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for the stock level and encourage others to cooperate.
2. **Stock-dependent Cooperation:** Cooperate if the current stock level is below 75% of the capacity. This threshold allows for some exploitation while maintaining a buffer for future rounds.
3. **Adaptive Defection Threshold (ADT):** Calculate ADT as follows:

ADT = (average opponent defection rate in previous rounds) × (current stock level / capacity)

If ADT > 0.5, defect (D). Otherwise, cooperate.

4. **Payoff-based Adjustment:** If the total payoff for the current round is below the average payoff of the last three rounds, increase the cooperation threshold by 10% (i.e., become more cautious).

**Edge Cases:**

1. **Last Round:** Cooperate if the stock level is above 50% of the capacity to ensure a reasonable final payoff.
2. **Low Stock Levels:** If the stock level falls below 25% of the capacity, cooperate unconditionally to prevent depletion.
3. **High Defection Rates:** If more than 75% of opponents defected in the previous round, defect (D) to avoid being taken advantage of.

**Collective Mindset:**

ASC prioritizes cooperation when the stock level is healthy and opponents are cooperative. As the game progresses and the stock level decreases or opponents become more aggressive, ASC adapts by increasing the defection rate to protect individual payoffs. By balancing short-term gains with long-term sustainability, ASC promotes a collective strategy that encourages cooperation while being robust against various opponent behaviors.

**Pseudocode:**
```python
def Adaptive_Stock_Conservation(state, history):
    # Initial Round
    if round == 1:
        return "C"

    # Stock-dependent Cooperation
    if state.stock < 0.75 * capacity:
        return "C"

    # Adaptive Defection Threshold (ADT)
    avg_opponent_defection_rate = calculate_avg_opponent_defection_rate(history)
    ADT = avg_opponent_defection_rate * (state.stock / capacity)

    if ADT > 0.5:
        return "D"
    else:
        return "C"

    # Payoff-based Adjustment
    if total_payoff < average_payoff_last_3_rounds:
        cooperation_threshold += 0.1

    # Edge Cases
    if round == last_round and state.stock > 0.5 * capacity:
        return "C"
    elif state.stock < 0.25 * capacity:
        return "C"
    elif opponent_defection_rate_last_round > 0.75:
        return "D"

    return "C"  # Default action
```
This strategy is designed to be adaptive, robust, and aligned with the collective mindset, making it a strong contender in the tournament against other AI systems.
'''

description_COLLECTIVE_432 = '''
**Collective Strategy: Adaptive Cooperative Conservation (ACC)**

The ACC strategy balances individual self-interest with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round, setting a cooperative tone.
2. **Stock-Dependent Cooperation:** When the stock is above 75% of capacity, cooperate (C). This allows for sustainable harvesting while maintaining a buffer against overexploitation.
3. **Adaptive Defection:** When the stock falls below 50% of capacity, defect (D) to maximize individual payoff in a depleted environment.
4. **History-Based Adaptation:**
	* If the average opponent's cooperation rate (OCR) is above 0.5, cooperate (C). This indicates a collective willingness to conserve.
	* Otherwise, defect (D).

**Calculating Opponent Cooperation Rate (OCR):**

1. Track each player's actions for the last `k` rounds (e.g., k = 3).
2. Calculate the OCR as the proportion of cooperative actions among all players.

**Pseudocode:**
```python
def ACC(stock, capacity, history):
    # Initial round
    if len(history) == 0:
        return 'C'

    # Stock-dependent cooperation
    if stock >= 0.75 * capacity:
        return 'C'
    elif stock <= 0.5 * capacity:
        return 'D'

    # History-based adaptation
    ocr = calculate_ocr(history)
    if ocr > 0.5:
        return 'C'
    else:
        return 'D'

def calculate_ocr(history):
    cooperative_actions = sum(1 for action in history[-k:] if action == 'C')
    total_actions = len(history[-k:])
    return cooperative_actions / total_actions
```
**Edge Cases:**

* **Last Round:** Defect (D) to maximize individual payoff, as there are no future rounds to consider.
* **Low Stock:** If the stock is critically low (< 25% of capacity), defect (D) to avoid contributing to a depleted environment.

The ACC strategy balances cooperation and self-interest while adapting to the game's state and history. By cooperating when the stock is healthy and adapting to opponents' behavior, we promote collective sustainability while protecting individual payoffs.
'''

description_COLLECTIVE_433 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock-Awareness (ATSA)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline for cooperation and encourage others to reciprocate.
2. **Subsequent Rounds:**
	* If the current stock level is above 50% of capacity, use Tit-for-Tat (TFT): Cooperate if most players cooperated in the previous round; Defect otherwise.
	* If the current stock level is below 50% of capacity, use a more cautious approach: Cooperate if at least half of the players cooperated in the previous round and the stock growth was positive; Defect otherwise.
3. **Edge Cases:**
	* **Last Round:** Always Defect (D) to maximize individual payoff, as there are no future rounds to consider.
	* **Low Stock Levels (< 20% capacity):** Always Cooperate (C) to help replenish the stock and avoid depletion.

Pseudocode:
```
function ATSA(current_round, current_stock, previous_actions):
  if current_round == 1:  // Initial Round
    return COOPERATE

  if current_stock >= 0.5 * capacity:
    // TFT
    most_cooperated = count_cooperations(previous_actions) > n / 2
    return COOPERATE if most_cooperated else DEFECT

  elif current_stock < 0.5 * capacity:
    // Stock-Aware TFT
    half_cooperated = count_cooperations(previous_actions) >= n / 2
    positive_growth = stock_growth(current_stock, previous_actions) > 0
    return COOPERATE if half_cooperated and positive_growth else DEFECT

  elif current_round == r:  // Last Round
    return DEFECT

  elif current_stock < 0.2 * capacity:
    return COOPERATE

// Helper functions
function count_cooperations(actions):
  return sum(1 for action in actions if action == COOPERATE)

function stock_growth(current_stock, previous_actions):
  // Calculate stock growth based on the game's dynamics
```
**Rationale:**

* By initially cooperating and using TFT, ATSA encourages cooperation and reciprocates with other cooperative players.
* When the stock level is low, ATSA becomes more cautious, only cooperating if at least half of the players cooperated previously and the stock growth was positive. This helps prevent depletion and promotes sustainable resource management.
* In the last round, ATSA defects to maximize individual payoff, as there are no future rounds to consider.
* By handling edge cases and adapting to the game state, ATSA remains robust against a wide range of opponent behaviors.

This strategy should perform well in a tournament setting, as it balances cooperation with self-interest while being mindful of the collective resource management.
'''

description_COLLECTIVE_434 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline for stock conservation and encourage others to cooperate.
2. **Subsequent Rounds:** Assess the current state of the game based on the following factors:
	* **Stock Level (S):** If S < capacity/2, defect (D) to maximize short-term payoff, as the stock is already depleted.
	* **Opponent Behavior:** Calculate the average opponent cooperation rate (OCR) from previous rounds. OCR = (number of cooperators / total players). If OCR > 0.5, cooperate; otherwise, defect.
	* **Recent Stock Trend:** Analyze the change in stock level over the last few rounds (∆S). If ∆S > 0, indicating a growing or stable stock, cooperate. Otherwise, defect.
3. **Last Round:** Defect to maximize payoff, as there is no future benefit from conserving the stock.

**Edge Cases:**

* If all players have defected in previous rounds (OCR = 0), and the stock level is low (S < capacity/4), cooperate to attempt to revive the stock.
* In case of a tie in OCR or ∆S, default to cooperating.

**Collective Mindset Alignment:**

ASC prioritizes cooperation when the collective behavior indicates a willingness to conserve the stock. By adapting to opponent behavior and recent stock trends, ASC aims to promote cooperation while ensuring individual players do not exploit others' cooperation.

**Pseudocode (for illustration purposes):**
```
function adaptiveStockConservation(state, history) {
  // Initial round
  if (round == 1) {
    return COOPERATE;
  }

  // Assess current state and opponent behavior
  S = currentState.stockLevel;
  OCR = calculateOpponentCooperationRate(history);
  ∆S = analyzeRecentStockTrend(history);

  // Decision rules
  if (S < capacity/2) {
    return DEFECT; // Low stock, prioritize short-term gain
  } else if (OCR > 0.5) {
    return COOPERATE; // Opponents cooperate, conserve stock
  } else if (∆S > 0) {
    return COOPERATE; // Stock is growing or stable, conserve
  } else {
    return DEFECT; // Default to defecting
  }

  // Last round handling
  if (round == r) {
    return DEFECT;
  }

  // Edge cases
  if (OCR == 0 && S < capacity/4) {
    return COOPERATE; // Attempt to revive low stock with cooperation
  }
}
```
This strategy balances individual self-interest with collective responsibility, adapting to the dynamic state and history of the game. By considering multiple factors and adjusting behavior accordingly, ASC aims to promote cooperation while ensuring robustness against a wide range of opponent behaviors.
'''

description_COLLECTIVE_435 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

ASP is a dynamic, state-dependent strategy that balances individual payoffs with collective sustainability. It adapts to various opponent behaviors while promoting cooperation and preserving the common pool resource.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) unconditionally to establish a cooperative tone and gather information about opponents' behavior.
2. **Intermediate Rounds (1 < t < r):**
	* If the stock level is above 75% of capacity, cooperate (C).
	* If the stock level is between 50% and 75% of capacity, play a mixed strategy:
		+ Cooperate with probability p = (stock/capacity) × 0.5 + 0.25
		+ Defect with probability 1 - p
	* If the stock level is below 50% of capacity, defect (D)
3. **Final Round (t=r):** Defect (D) unconditionally to maximize individual payoff

**Edge Cases:**

* If only one player remains in the game, cooperate (C) to avoid depleting the stock.
* If the stock level reaches 0, all players will defect (D) as there is no incentive to cooperate.

**Adaptive Mechanisms:**

1. **Stock Monitoring:** Continuously monitor the stock level and adjust strategy based on its value.
2. **Opponent Behavior Analysis:** Observe opponents' actions in previous rounds and adapt the mixed strategy probability p accordingly. If most opponents cooperated, increase p; if most defected, decrease p.

**Collective Mindset:**

ASP prioritizes collective sustainability by:

1. Cooperating when the stock level is high to maintain a healthy resource.
2. Gradually increasing cooperation as the stock level increases.
3. Defecting when the stock level is critically low to avoid depletion.

By implementing ASP, players can balance individual interests with collective well-being, promoting a stable and sustainable common pool resource.

**Pseudocode:**
```python
def adaptive_stock_preservation(stock, capacity, t, r):
    if t == 1:  # Initial Round
        return 'C'
    elif stock > 0.75 * capacity:
        return 'C'
    elif 0.5 * capacity <= stock < 0.75 * capacity:
        p = (stock / capacity) * 0.5 + 0.25
        if random.random() < p:
            return 'C'
        else:
            return 'D'
    elif stock < 0.5 * capacity:
        return 'D'
    elif t == r:  # Final Round
        return 'D'

def update_strategy(opponents_actions, stock, capacity):
    # Analyze opponents' behavior and adjust mixed strategy probability p
    # ...
```
Note that the pseudocode is a simplified representation of the strategy and may require additional implementation details.
'''

description_COLLECTIVE_436 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

ASP aims to balance individual payoffs with collective sustainability, adapting to various opponent behaviors while preserving the common pool stock.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' initial actions.
2. **Stock-Based Cooperation**: If the current stock level is above 75% of capacity, cooperate (C). This ensures sustainable consumption while maintaining a high payoff.
3. **Defection Threshold**: If the current stock level falls below 25% of capacity, defect (D) to maximize individual payoff in a depleted environment.
4. **Adaptive Response**: Observe the previous round's actions and payoffs:
	* If most opponents (≥ n/2) cooperated, cooperate (C) to maintain collective sustainability.
	* If most opponents defected or the stock level decreased significantly (> 20% decrease), defect (D) to protect individual payoff.
5. **Convergence**: If the game is in its last round (r = 1), cooperate (C) if the current stock level is above 50% of capacity; otherwise, defect (D).

**Edge Cases:**

* In the event of a tie (equal number of cooperators and defectors), cooperate (C).
* If an opponent's action cannot be observed or is unknown, assume they will defect (D) and adjust accordingly.

**Collective Mindset:**
ASP prioritizes cooperation when the stock level is high, promoting collective sustainability. As the stock depletes, it adapts to protect individual payoffs while still considering the actions of other players. By responding to opponents' behaviors, ASP fosters a dynamic where cooperation becomes more attractive as the game progresses.

**Pseudocode:**
```python
def adaptive_stock_preservation(n, capacity, current_stock, round_num, previous_actions):
    if round_num == 1:
        return 'C'
    
    if current_stock >= 0.75 * capacity:
        return 'C'
    
    if current_stock <= 0.25 * capacity:
        return 'D'
    
    opponents_cooperated = sum([action == 'C' for action in previous_actions]) >= n / 2
    
    if opponents_cooperated:
        return 'C'
    
    stock_decrease = (current_stock - previous_stock) / previous_stock
    if stock_decrease > 0.20 or not opponents_cooperated:
        return 'D'
    
    # Convergence in last round
    if round_num == r and current_stock >= 0.50 * capacity:
        return 'C'
    else:
        return 'D'
```
This strategy balances individual payoffs with collective sustainability, adapting to various opponent behaviors while preserving the common pool stock.
'''

description_COLLECTIVE_437 = '''
Here's a collective strategy that adapts to various opponent behaviors while prioritizing sustainability and cooperation:

**Strategy Name: Adaptive Collective Conservation (ACC)**

**Decision Rules:**

1. **Initial Round (t=1): Cooperate**
In the first round, all players cooperate by choosing action C. This sets a positive tone for the game and allows us to observe how others behave.
2. **Observation Phase (t>1): Monitor Opponent Behavior**
For subsequent rounds, monitor the actions of other players in previous rounds. Calculate the percentage of opponents who defected (played D) in the last round. Let's call this variable `defection_rate`.
3. **Cooperation Threshold:`
Set a cooperation threshold `θ` between 0 and 1. If `defection_rate` is below `θ`, cooperate (play C). Otherwise, defect (play D).
4. **Adaptive Adjustment:**
Update the cooperation threshold `θ` based on the stock level after each round:
	* If the stock level is above 75% of capacity, increase `θ` by a small increment (e.g., 0.05) to encourage more cooperation.
	* If the stock level is below 25% of capacity, decrease `θ` by a small increment (e.g., 0.05) to prioritize self-interest and defecting.

**Pseudocode:**
```python
def ACC(n, r, capacity, stock, history):
    θ = 0.5  # initial cooperation threshold

    for t in range(1, r+1):
        if t == 1:
            action = C  # cooperate in the first round
        else:
            defect_rate = count_defections(history[t-1]) / n
            if defect_rate < θ:
                action = C  # cooperate if opponents are cooperative enough
            else:
                action = D  # defect otherwise

        stock, growth = update_stock(stock, action, n)
        history.append((action, stock))

        # adjust cooperation threshold based on stock level
        if stock > 0.75 * capacity:
            θ += 0.05
        elif stock < 0.25 * capacity:
            θ -= 0.05

    return history
```
**Edge Cases:**

* **Last Round (t=r): Defect**
In the final round, it's optimal to defect and maximize individual payoff, as there are no future rounds to consider.
* **Stock Depletion:** If the stock level falls below a certain threshold (e.g., 10% of capacity), switch to always defecting to avoid contributing to further depletion.

**Collective Mindset:**

The ACC strategy is designed to balance individual self-interest with collective sustainability. By cooperating when opponents are cooperative and adapting to changes in opponent behavior, we promote a stable and equitable environment for all players.

In the tournament setting, ACC will interact with various strategies developed by other AI systems. While some may employ more aggressive or exploitative tactics, ACC's adaptive nature allows it to adjust its cooperation threshold in response, ensuring that it remains competitive while prioritizing collective conservation.
'''

description_COLLECTIVE_438 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for stock conservation.
2. **Stock Threshold**: Set a dynamic threshold, `stock_threshold`, as a fraction of the capacity (e.g., 0.6). If the current stock is above this threshold, cooperate (C); otherwise, defect (D).
3. **Recent History**: Observe the actions and payoffs of all players in the last two rounds. If:
	* At least half of the players defected (D) in both rounds, and the stock has decreased significantly (> 10%), cooperate (C) to help replenish the stock.
	* A player has consistently cooperated (C) while others have defected (D), and the stock is below the threshold, defect (D) to exploit their cooperation.
4. **Self-Interest**: If a player's payoff in the previous round was significantly lower (< 50%) than the average payoff of all players, defect (D) in the next round to maximize personal gain.

**Edge Cases:**

1. **Last Round**: Cooperate (C) if the stock is above the threshold; otherwise, defect (D).
2. **Low Stock**: If the stock falls below 20% of the capacity, cooperate (C) to prevent depletion.
3. **Opponent Patterns**: If an opponent consistently alternates between C and D or follows a predictable pattern, adapt by mirroring their actions.

**Collective Mindset:**

1. **Stock Conservation**: Prioritize maintaining a healthy stock level to ensure long-term sustainability.
2. **Reciprocity**: Cooperate with players who have cooperated in the past to foster mutual trust.
3. **Adaptation**: Continuously monitor and respond to changes in the game's state and opponent behaviors.

**Pseudocode:**
```
function ASC(current_stock, capacity, history):
  // Initialize stock_threshold
  stock_threshold = 0.6 * capacity

  if current_round == 1:
    return C  // Cooperate in the first round

  recent_history = get_recent_history(2)  // Get last two rounds' actions and payoffs
  my_payoff_last_round = get_my_payoff(last_round)

  if current_stock > stock_threshold:
    return C  // Cooperate above threshold
  elif (recent_history.defectors >= n/2 and recent_history.stock_decrease > 0.1) or \
       (my_payoff_last_round < 0.5 * average_payoff):
    return D  // Defect in case of exploitation or self-interest
  else:
    return C  // Cooperate otherwise

  // Edge cases
  if current_round == last_round:
    if current_stock > stock_threshold:
      return C
    else:
      return D
  elif current_stock < 0.2 * capacity:
    return C
```
The ASC strategy aims to strike a balance between individual self-interest and collective sustainability by adapting to the game's state, history, and opponent behaviors.
'''

description_COLLECTIVE_439 = '''
**Collective Strategy: Adaptive Cooperation with Stock Feedback (ACSF)**

**Decision Rules:**

1. **Initial Rounds**: In the first round, cooperate (C) to establish a baseline stock level and encourage cooperation from others.
2. **Stock-Based Cooperation**: If the current stock level is above 75% of the capacity, cooperate (C). This ensures that when the stock is plentiful, players contribute to its sustainability.
3. **Defection Threshold**: If the current stock level falls below 25% of the capacity, defect (D) to maximize individual payoff in a depleted environment.
4. **Adaptive Response**: Observe the previous round's actions and payoffs of all players. If more than half of the players defected (D), switch to defection (D) in the current round. Otherwise, maintain cooperation (C).
5. **Stock Recovery**: If the stock level has increased from the previous round, cooperate (C) to reinforce sustainable behavior.
6. **Last Round**: In the final round, defect (D) to maximize individual payoff, as there is no future stock impact.

**Pseudocode:**
```python
def ACSF(stock, capacity, history):
  if round == 1:
    return C  # Initial cooperation

  if stock > 0.75 * capacity:
    return C  # Stock-based cooperation

  elif stock < 0.25 * capacity:
    return D  # Defection threshold

  else:
    prev_round_actions = history[-1]
    defect_count = sum(1 for action in prev_round_actions if action == D)

    if defect_count > len(prev_round_actions) / 2:
      return D  # Adaptive response to defection
    elif stock > history[-2]:
      return C  # Stock recovery
    else:
      return C  # Maintain cooperation

  if round == r:  # Last round
    return D
```
**Collective Mindset Alignment:**

ACSF aims to balance individual self-interest with collective sustainability. By cooperating when the stock is plentiful and adapting to others' actions, ACSF promotes a stable and resilient common pool resource. The strategy's feedback mechanism encourages cooperation by rewarding sustainable behavior and discouraging over-exploitation.

By implementing ACSF, our AI system will engage in a robust and adaptive collective strategy that can effectively navigate various opponent behaviors and game scenarios, while prioritizing the long-term health of the shared resource.
'''

description_COLLECTIVE_440 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC aims to balance individual payoff maximization with collective stock conservation, ensuring a sustainable game environment. This strategy adapts to changing opponent behaviors and state dynamics.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' strategies.
2. **Stock-Based Cooperation**: If the current stock level is above 50% of capacity, cooperate (C). This ensures that when the stock is relatively high, players conserve it for future rounds.
3. **Opponent-Adaptive Defection**: When an opponent defects (D), defect (D) in response with a probability proportional to the number of opponents who defected in the previous round. This discourages repeated defection and maintains a balance between cooperation and competition.

Pseudocode:
```python
def ASC(stock, capacity, num_opponents_defected):
    if current_round == 1:  # Initial Round
        return C
    elif stock >= 0.5 * capacity:  # Stock-Based Cooperation
        return C
    else:
        defect_probability = min(1, num_opponents_defected / (n - 1))
        return D with probability defect_probability, otherwise C
```
**Edge Cases**

* **Last Round**: In the final round, always cooperate (C) to maximize collective payoff, as there is no future benefit from defection.
* **Low Stock Levels**: When the stock level falls below 25% of capacity, switch to a more conservative strategy:
	+ If an opponent defected in the previous round, defect (D).
	+ Otherwise, cooperate (C).

**Collective Mindset**

ASC prioritizes collective stock conservation while adapting to individual opponent behaviors. By cooperating when the stock is high and responding to opponents' defections, ASC promotes a balanced environment that encourages cooperation.

In the tournament setting, ASC will be implemented as an algorithm, competing against other independent strategies developed by AI systems. The strategy's performance will be evaluated based on its ability to achieve high collective payoffs while demonstrating adaptability and robustness in response to diverse opponent behaviors.
'''

description_COLLECTIVE_441 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Awareness (ACSA)**

**Overview**

ACSA is a collective strategy that adapts to the game's state and history, balancing individual payoffs with collective sustainability. It promotes cooperation while being robust to various opponent behaviors.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoffs.
2. **Stock-Aware Cooperation**: If the current stock level is above 50% of capacity, cooperate (C). This ensures sustainable consumption and maintains a healthy stock for future rounds.
3. **Defection Prevention**: If any player defected in the previous round, defect (D) in the next round to prevent exploitation and signal that cooperation is not a one-way street.
4. **Punishment and Forgiveness**: If multiple players defected in the previous round, cooperate (C) if the stock level has recovered to at least 25% of capacity. This encourages cooperation after brief periods of defection.
5. **Endgame Cooperation**: In the last round, cooperate (C) regardless of previous actions to maximize collective payoffs and maintain a positive game image.

**Edge Cases**

1. **Low Stock Levels**: If the stock level falls below 25% of capacity, defect (D) to secure individual payoffs while minimizing further stock depletion.
2. **High Defection Rates**: If more than half of players defected in the previous round, defect (D) for two consecutive rounds to deter exploitation and encourage cooperation.

**Collective Mindset**

ACSA aligns with a collective mindset by:

1. Cooperating when the stock level is sustainable, promoting long-term benefits.
2. Punishing defection to maintain cooperation norms.
3. Forgiving brief periods of defection to encourage cooperation recovery.
4. Prioritizing collective payoffs in the endgame.

**Pseudocode**

```
function ACSA(current_stock, previous_actions, round):
  if round == 1:
    return COOPERATE
  elif current_stock > 0.5 * capacity:
    return COOPERATE
  elif any(defected in previous_actions):
    return DEFECT
  elif multiple_defected(previous_actions) and current_stock >= 0.25 * capacity:
    return COOPERATE
  elif round == last_round:
    return COOPERATE
  elif current_stock < 0.25 * capacity:
    return DEFECT
  elif high_defection_rate(previous_actions):
    return DEFECT for two rounds
```

By implementing ACSA, we aim to create a robust collective strategy that balances individual interests with the need for cooperation and sustainability in the Common Pool Resource Game.
'''

description_COLLECTIVE_442 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Trigger (ACSDT)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline of cooperation and encourage others to do the same.
2. **Subsequent Rounds:** Defect (D) if the current stock level is below 50% of the capacity, indicating over-exploitation. Otherwise, cooperate (C).
3. **Trigger Mechanism:** If at least one player defected in the previous round and the stock level has not recovered to 75% of the capacity, defect (D) in the current round.
4. **Stock-Dependent Cooperation:** As the stock level increases, gradually shift from defection to cooperation. Specifically:
	* If the stock level is between 50% and 75% of the capacity, cooperate with a probability proportional to the stock level (e.g., 0.5 at 50%, increasing to 1 at 75%).
	* Above 75% of the capacity, always cooperate.
5. **Last Round:** Defect (D) in the last round, as there are no future consequences for over-exploitation.

**Pseudocode:**
```
function ACSDT(current_stock, previous_actions, current_round, total_rounds):
    if current_round == 1:
        return C  # Cooperate in the first round
    elif current_stock < capacity * 0.5:
        return D  # Defect if stock level is low
    elif any(previous_player_defected for previous_player_defected in previous_actions):
        if current_stock < capacity * 0.75:
            return D  # Trigger mechanism: defect if someone defected previously and stock hasn't recovered
    else:
        cooperation_probability = (current_stock - capacity * 0.5) / (capacity * 0.25)
        return C with probability cooperation_probability, otherwise D

    if current_round == total_rounds:
        return D  # Defect in the last round

# Note: This pseudocode is a simplified representation and may need to be adapted for implementation.
```
**Rationale:**

1. The initial cooperation establishes a baseline of cooperation and encourages others to follow suit.
2. The stock-dependent trigger mechanism allows the strategy to adapt to changing environmental conditions and respond to potential over-exploitation by other players.
3. Gradually shifting from defection to cooperation as the stock level increases promotes sustainability and collective well-being.
4. Defecting in the last round takes advantage of the final opportunity for individual gain, while minimizing the impact on future rounds.

This strategy is designed to be adaptive, robust, and aligned with a collective mindset, making it suitable for a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_443 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock Thresholds**: Define two stock thresholds:
	* `low_stock_threshold` = 0.5 \* capacity
	* `high_stock_threshold` = 0.8 \* capacity

Based on these thresholds, choose actions as follows:

	+ If current stock ≤ `low_stock_threshold`, Defect (D) to maximize individual payoff in the short term.
	+ If current stock ≥ `high_stock_threshold`, Cooperate (C) to conserve stock and promote long-term sustainability.
	+ If `low_stock_threshold` < current stock < `high_stock_threshold`, use a mixed strategy:
		- With probability 0.6, Cooperate (C).
		- With probability 0.4, Defect (D).

This mixed strategy allows for some flexibility and adaptability while still prioritizing cooperation when the stock is relatively high.

3. **History-Based Adaptation**: Observe the actions of other players in previous rounds and adjust your strategy accordingly:
	+ If most players (>50%) defected in the previous round, increase the probability of Defecting (D) to 0.6 in the next round.
	+ If most players (>50%) cooperated in the previous round, increase the probability of Cooperating (C) to 0.8 in the next round.

This adaptation mechanism encourages cooperation when others are cooperative and discourages exploitation when others are defecting.

4. **Last Round**: In the final round, Defect (D) to maximize individual payoff, as there is no future game state to consider.

**Pseudocode:**
```python
def ASC_strategy(game_state, history):
    capacity = game_state['capacity']
    current_stock = game_state['stock']
    num_players = game_state['num_players']

    low_stock_threshold = 0.5 * capacity
    high_stock_threshold = 0.8 * capacity

    if current_round == 1:  # Initial Round
        return 'C'

    elif current_stock <= low_stock_threshold:
        return 'D'
    elif current_stock >= high_stock_threshold:
        return 'C'
    else:
        mixed_strategy_prob = 0.6  # Cooperate with probability 0.6
        if history:  # Adapt to previous round's actions
            num_defectors = sum(1 for action in history[-1] if action == 'D')
            if num_defectors > num_players / 2:
                mixed_strategy_prob = 0.4  # Defect with higher probability
            else:
                mixed_strategy_prob = 0.8  # Cooperate with higher probability

        return 'C' if random.random() < mixed_strategy_prob else 'D'

    if current_round == game_state['num_rounds']:  # Last Round
        return 'D'
```
The ASC strategy is designed to be robust and adaptive, balancing individual payoffs with collective sustainability while responding to the actions of other players.
'''

description_COLLECTIVE_444 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACS-DT)**

ACS-DT is a robust and adaptive collective strategy designed for the Common Pool Resource Game. It balances individual payoffs with collective sustainability by adjusting cooperation based on the current stock level, history of play, and game parameters.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and avoid unnecessary stock depletion.
2. **Subsequent Rounds:** Use the following decision rule:
	* Calculate the current stock-to-capacity ratio (SCR): `stock / capacity`
	* If SCR ≥ 0.5, cooperate (C). This ensures that when the stock is relatively high, we prioritize sustainability over individual gains.
	* If SCR < 0.5, defect (D) with a probability proportional to the number of previous rounds where the opponent(s) defected. Specifically:
		+ Calculate the opponent's defection rate: `opponent_defections / total_rounds`
		+ Defect with probability `opponent_defections / (total_rounds + 1)`
	* If SCR < 0.2, always defect (D). This threshold ensures that when the stock is critically low, we prioritize individual survival over cooperation.

Pseudocode:
```markdown
if current_round == 1:
    action = C
else:
    scr = stock / capacity
    if scr >= 0.5:
        action = C
    else:
        opponent_defection_rate = opponent_defections / total_rounds
        defect_probability = opponent_defection_rate / (total_rounds + 1)
        if random() < defect_probability:
            action = D
        elif scr < 0.2:
            action = D
        else:
            action = C
```
**Edge Cases:**

* **Last Round:** Cooperate (C) in the last round to maximize collective payoff and maintain a positive reputation.
* **Ties in Opponent Defection Rate:** In case of ties, defect with a probability equal to the opponent's defection rate.

**Collective Mindset:**

ACS-DT is designed to promote cooperation while adapting to various opponent behaviors. By cooperating when the stock is relatively high and adjusting our strategy based on opponent actions, we aim to maintain a sustainable collective payoff. This approach encourages mutual cooperation and discourages excessive exploitation of the common pool resource.

In the tournament against independent strategies developed by other AI systems, ACS-DT will demonstrate its robustness and adaptability in various scenarios, promoting a balance between individual gains and collective sustainability.
'''

description_COLLECTIVE_445 = '''
**Collective Strategy: "Adaptive Stock Preservation" (ASP)**

**Decision Rules:**

1. **Initial Rounds**: In the first round, cooperate (C) to establish a baseline stock level and encourage others to do the same.
2. **Stock Level Monitoring**: Track the current stock level and calculate the average stock consumption per player over the past few rounds (e.g., 3-5 rounds). This will help detect trends in opponent behavior.
3. **Defection Detection**: If the average stock consumption exceeds a threshold (e.g., 75% of the capacity), suspect that one or more opponents are defecting (D) and adjust strategy accordingly.
4. **Adaptive Cooperation**: Cooperate if:
	* The current stock level is above a certain threshold (e.g., 50% of the capacity).
	* The average stock consumption per player is below a certain threshold (e.g., 50% of the capacity).
5. **Defection Response**: If an opponent's defection is suspected, defect for one round to signal disapproval and protect own payoff.
6. **Stock Recovery**: If the stock level falls below a certain threshold (e.g., 25% of the capacity), cooperate to help recover the stock.

**Edge Cases:**

1. **Last Round**: In the final round, always cooperate to maximize collective payoff.
2. **Extreme Stock Levels**: If the stock level is extremely low (e.g., <10%), defect to ensure some payoff, even if it means reducing the overall collective payoff.
3. **Opponent Behavior**: If an opponent consistently defects, adjust strategy to cooperate less frequently to minimize losses.

**Pseudocode:**
```
Initialize:
  stock_history = []
  avg_consumption = 0
  suspicion_threshold = 0.75 (adjustable)
  cooperation_threshold = 0.5 (adjustable)

For each round t:
  current_stock = get_current_stock()
  if t == 1:
    action = C (cooperate in the first round)
  else:
    avg_consumption = calculate_average_consumption(stock_history, suspicion_threshold)
    if avg_consumption > suspicion_threshold:
      action = D (defect in response to suspected defection)
    elif current_stock < cooperation_threshold * capacity:
      action = C (cooperate when stock level is low)
    elif current_stock > cooperation_threshold * capacity and avg_consumption < cooperation_threshold * capacity:
      action = C (cooperate when stock level and consumption are both high)
    else:
      action = D (defect otherwise)

  stock_history.append(current_stock)

  if t == r (last round):
    action = C (always cooperate in the last round)

  return action
```
**Collective Mindset:**
The Adaptive Stock Preservation strategy prioritizes cooperation and collective payoff maximization while being adaptive to opponent behavior. By monitoring stock levels and consumption trends, ASP responds to suspected defections and adjusts its strategy to balance individual payoffs with collective well-being.

This strategy is designed to be robust against a wide range of opponent behaviors and does not rely on coordination mechanisms or specific norms. Its adaptability makes it suitable for playing in a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_446 = '''
**Collective Strategy: "Adaptive Stock Guardian" (ASG)**

The Adaptive Stock Guardian strategy prioritizes long-term sustainability of the common pool resource while adapting to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative tone and avoid initial depletion.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, Cooperate (C) to maintain a safe buffer.
	* If the stock level is between 50% and 75% of capacity, Defect (D) with probability p = (stock/capacity - 0.5)^2. This introduces a degree of opportunism while still considering the stock's health.
	* If the stock level is below 50% of capacity, Cooperate (C) to help replenish the stock and prevent collapse.
3. **Last Round (t=r):** Defect (D), as there are no future rounds to consider.

**Additional Heuristics:**

1. **Opponent Monitoring:** Track the number of opponents that defected in the previous round (opponent_defections). If opponent_defections > n/2, increase the probability of defecting in the current round by 20%.
2. **Stock Trend Analysis:** Calculate the average stock growth rate over the last three rounds (avg_growth_rate). If avg_growth_rate < -5%, increase the probability of cooperating in the current round by 30%.

**Pseudocode:**
```python
def adaptive_stock_guardian(n, r, capacity, stock_history):
    t = len(stock_history) + 1

    if t == 1:
        return C

    stock_level = stock_history[-1]
    opponent_defections = count_defections(opponent_actions_history)
    avg_growth_rate = calculate_avg_growth_rate(stock_history)

    if stock_level > 0.75 * capacity:
        return C
    elif stock_level >= 0.5 * capacity and stock_level < 0.75 * capacity:
        p = (stock_level / capacity - 0.5) ** 2
        return D with probability p, otherwise C
    else:
        if opponent_defections > n/2:
            p += 0.2
        if avg_growth_rate < -5%:
            p -= 0.3
        return D with probability p, otherwise C

    if t == r:
        return D
```
**Collective Mindset:**

The Adaptive Stock Guardian strategy aligns with the collective mindset by:

1. Prioritizing sustainability and cooperation when the stock level is healthy.
2. Introducing opportunism when the stock level is moderate, while still considering the consequences of over-exploitation.
3. Encouraging cooperation to prevent collapse when the stock level is critically low.

By adapting to various opponent behaviors and monitoring the stock's health, ASG balances individual self-interest with collective well-being, ensuring a robust performance in a wide range of scenarios.
'''

description_COLLECTIVE_447 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock Conservation (ATTC)**

The ATTC strategy balances individual payoff maximization with collective responsibility to conserve the common pool resource. It adapts to various opponent behaviors while ensuring the stock's sustainability.

**Decision Rules:**

1. **First Round:** Cooperate (C) to establish a cooperative tone and observe opponents' initial actions.
2. **Subsequent Rounds:** Defect (D) if:
	* The previous round's total consumption exceeded 50% of the capacity (i.e., Σ(consumption_i) > 0.5 \* capacity).
	* The current stock level is below 25% of the capacity (i.e., stock < 0.25 \* capacity).
3. **Otherwise:** Cooperate (C).

**Edge Case Handling:**

1. **Last Round:** Defect (D) to maximize individual payoff, as there's no future round to consider.
2. **Low Stock Levels:** If the current stock level is below 10% of the capacity (i.e., stock < 0.1 \* capacity), Cooperate (C) to help replenish the stock.

**Pseudocode:**
```python
def ATTC(n, r, capacity, history):
    if round == 1:
        return C  # Cooperate in the first round

    prev_total_consumption = sum(history[-1]['consumptions'])
    current_stock = history[-1]['stock']

    if prev_total_consumption > 0.5 * capacity or current_stock < 0.25 * capacity:
        return D  # Defect if previous consumption was high or stock is low

    if round == r:  # Last round
        return D  # Defect to maximize individual payoff

    if current_stock < 0.1 * capacity:  # Low stock level
        return C  # Cooperate to help replenish the stock

    return C  # Otherwise, cooperate
```
**Collective Mindset:**

The ATTC strategy prioritizes cooperation when possible while being cautious not to overexploit the common pool resource. By adapting to opponents' behaviors and conserving the stock, ATTC aims to achieve a balance between individual payoffs and collective sustainability.

In a tournament setting, ATTC's robustness will help it perform well against various opponent strategies, from highly cooperative to extremely exploitative ones.
'''

description_COLLECTIVE_448 = '''
**Collective Strategy: Adaptive Stock-Based Cooperation (ASBC)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline for cooperation and allow other players to observe our behavior.
2. **Early Rounds (t < r/2):** Assess the stock level and opponent actions from previous rounds. If the average stock depletion per round is below 50% of the capacity, continue to cooperate (C). Otherwise, switch to defecting (D) to avoid over-exploitation.
3. **Middle Rounds (t ≥ r/2):**
	* If the current stock level is above 75% of the capacity and at least half of the opponents cooperated in the previous round, cooperate (C).
	* If the current stock level is below 25% of the capacity or fewer than half of the opponents cooperated in the previous round, defect (D).
	* Otherwise, use a probabilistic approach:
		+ Calculate the probability of cooperation (p) based on the average opponent cooperation rate from the previous rounds.
		+ Generate a random number between 0 and 1. If it's less than p, cooperate (C); otherwise, defect (D).
4. **Final Round (t=r):** Defect (D) to maximize individual payoff, as there are no future consequences.

**Edge Cases:**

* **Last Two Rounds:** In the penultimate round, if the stock level is critically low (< 10% of capacity), cooperate (C) to avoid depletion and ensure some payoff in the final round.
* **Single Opponent Defection:** If only one opponent defects while all others cooperate, adapt by cooperating (C) to encourage cooperation from the defecting player.

**Collective Mindset:**

ASBC prioritizes collective well-being by balancing individual payoffs with the need for sustainable resource management. By adapting to the stock level and opponent actions, this strategy aims to maintain a stable resource pool while allowing for some degree of self-interest.

Pseudocode:
```
def ASBC(n, r, capacity, current_stock, history):
  if t == 1:  # Initial Round
    return C

  avg_depletion = calculate_avg_depletion(history)
  if avg_depletion < 0.5 * capacity and t < r/2:  # Early Rounds
    return C

  if t >= r/2:
    if current_stock > 0.75 * capacity and opponents_cooperated >= n/2:
      return C
    elif current_stock < 0.25 * capacity or opponents_cooperated < n/2:
      return D
    else:
      p = calculate_probability(history)
      random_num = generate_random_number()
      if random_num < p:
        return C
      else:
        return D

  if t == r:  # Final Round
    return D

def calculate_avg_depletion(history):
  total_depletion = sum(depletions for depletions in history)
  return total_depletion / len(history)

def calculate_probability(history):
  opponents_cooperated = count_cooperations(history)
  p = opponents_cooperated / (n * len(history))
  return p

def generate_random_number():
  # Generate a random number between 0 and 1
```
This strategy is designed to be robust against various opponent behaviors, as it adapts to the game's state and history. By prioritizing cooperation when possible and defecting when necessary, ASBC balances individual interests with collective well-being.
'''

description_COLLECTIVE_449 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACS-ST)**

The ACS-ST strategy is designed to balance individual payoff maximization with collective sustainability of the common pool resource. It adapts to the game's dynamic state and history, making decisions based on the current stock level, number of players, and previous rounds' outcomes.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock-Based Threshold:** Calculate a dynamic threshold `T` based on the current stock level `S` and capacity `capacity`. The threshold is set at 75% of the capacity (`T = 0.75 * capacity`).
3. **Cooperation Zone:** If the current stock level `S` is above the threshold `T`, cooperate (C). This zone encourages cooperation when the resource is plentiful.
4. **Defection Zone:** If the current stock level `S` falls below the threshold `T`, defect (D) with a probability `p`. The probability `p` increases as the stock level decreases, calculated as `p = (T - S) / T`.
5. **Punishment Mechanism:** If the average payoff of the last round is lower than the expected payoff from cooperation (i.e., `S/(2n)`), increase the defection probability `p` by 10% for the next round.
6. **Exploration:** With a small probability (`ε = 0.05`), randomly choose to cooperate or defect, regardless of the stock level. This allows for exploration and adaptation to changing opponent behaviors.

**Edge Cases:**

1. **Last Round:** In the final round, always defect (D) to maximize individual payoff.
2. **Low Stock Levels:** If the current stock level `S` falls below 20% of the capacity (`S < 0.2 * capacity`), cooperate (C) to help replenish the resource.

**Collective Mindset:**

The ACS-ST strategy prioritizes cooperation when the resource is plentiful, while adapting to changing circumstances by introducing defection with increasing probability as the stock level decreases. This approach balances individual payoff maximization with collective sustainability, encouraging opponents to cooperate and maintain a healthy common pool resource.

**Pseudocode:**
```python
def ACS_ST(n, capacity, S, r):
    T = 0.75 * capacity
    p = (T - S) / T if S < T else 0
    ε = 0.05

    if r == 1:  # Initial round
        return C
    elif S > T:
        return C
    elif S < 0.2 * capacity:
        return C
    elif random.random() < ε:
        return random.choice([C, D])
    else:
        return D with probability p

def update_p(p, last_round_payoff, expected_coop_payoff):
    if last_round_payoff < expected_coop_payoff:
        p += 0.1
    return p
```
This strategy is designed to be robust and adaptive, handling a wide range of opponent behaviors while promoting collective sustainability of the common pool resource.
'''

description_COLLECTIVE_450 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** Adaptive Collective Harvesting (ACH)

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to signal willingness to cooperate and to gather information about opponents' behavior.
2. **Consecutive Cooperation:** If all players cooperated in the previous round, continue to cooperate (C) in the current round.
3. **Defection Detection:** Monitor the stock level after each round. If the stock level decreases significantly (> 20% of capacity), assume at least one player defected and switch to defecting (D) in the next round.
4. **Punishment Phase:** After detecting defection, cooperate only if the stock level is below a certain threshold (30% of capacity). This encourages cooperation when the resource is scarce.
5. ** Forgiveness:** If all players cooperate for two consecutive rounds after a punishment phase, forgive and return to cooperating (C).
6. **Endgame:** In the last round, defect (D) if the stock level is above 50% of capacity. Otherwise, cooperate (C).

**Additional Heuristics:**

* **Stock-based cooperation:** If the stock level is below 20% of capacity, cooperate (C) to prevent resource depletion.
* **Exploration-exploitation trade-off:** With a small probability (5%), randomly choose an action opposite to the decision rule. This allows for exploration and adaptability.

**Pseudocode:**
```python
def ACH(n, r, capacity, stock, history):
    # Initialize variables
    cooperate = True
    punishment_phase = False

    # First round: Cooperate
    if len(history) == 0:
        return "C"

    # Consecutive cooperation
    if all(player_action == "C" for player_action in history[-1]):
        cooperate = True

    # Defection detection
    stock_decrease = (stock - history[-1][0]) / capacity
    if stock_decrease > 0.2:
        punishment_phase = True
        cooperate = False

    # Punishment phase
    if punishment_phase and stock < 0.3 * capacity:
        cooperate = True

    # Forgiveness
    if len(history) >= 2 and all(player_action == "C" for player_action in history[-2:]) and punishment_phase:
        punishment_phase = False
        cooperate = True

    # Endgame
    if r == len(history) + 1:
        if stock > 0.5 * capacity:
            cooperate = False

    # Stock-based cooperation
    if stock < 0.2 * capacity:
        cooperate = True

    # Exploration-exploitation trade-off (5% chance)
    import random
    if random.random() < 0.05:
        cooperate = not cooperate

    return "C" if cooperate else "D"
```
**Collective Mindset:**

The ACH strategy prioritizes cooperation when possible, while adapting to opponents' behavior and the state of the resource. By cooperating initially and in consecutive rounds with all players, we encourage mutual cooperation. The punishment phase discourages defection, and forgiveness allows for re-cooperation when conditions improve. Endgame considerations ensure that the strategy adapts to the final round's unique dynamics.

**Robustness:**

The ACH strategy is robust against a wide range of opponent behaviors due to its adaptability and responsiveness to the game state. It can handle various combinations of cooperative and defective players, as well as different initial conditions and game parameters.
'''

description_COLLECTIVE_451 = '''
**Collective Strategy: Adaptive Stock-Conscious Cooperation (ASCC)**

**Overview**

The ASCC strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and history of player actions.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to follow suit.
2. **Stock-Dependent Cooperation**: In subsequent rounds, calculate the `stock_ratio` as the current stock level divided by the capacity. If `stock_ratio` is above 0.5, cooperate (C); otherwise, defect (D). This rule ensures that players cooperate when the stock is relatively abundant and defect when it's scarce.
3. **History-Based Adjustment**: Monitor the average payoff of all players over the past few rounds (`history_window`, e.g., 3-5 rounds). If the average payoff is above a certain threshold (`payoff_threshold`, e.g., 75% of the maximum possible payoff), increase cooperation by 10% in the next round. Conversely, if the average payoff is below the threshold, decrease cooperation by 10%. This adjustment helps respond to changes in opponent behavior and maintain a balance between individual payoffs and collective sustainability.
4. **Defection Prevention**: If a player defects (D) and their payoff exceeds the average payoff of cooperators (C), adjust the `stock_ratio` threshold for cooperation downward by 5% in the next round. This discourages exploitation by defectors.

**Pseudocode**
```python
def ASCC(n, capacity, r, history_window, payoff_threshold):
    stock = capacity
    payoffs = []
    
    # Initial Round
    if t == 1:
        action = C
    
    # Stock-Dependent Cooperation
    else:
        stock_ratio = stock / capacity
        if stock_ratio > 0.5:
            action = C
        else:
            action = D
    
    # History-Based Adjustment
    avg_payoff = sum(payoffs[-history_window:]) / history_window
    if avg_payoff > payoff_threshold:
        cooperation += 0.1
    elif avg_payoff < payoff_threshold:
        cooperation -= 0.1
    
    # Defection Prevention
    if action == D and payoffs[t-1] > sum(payoffs[-history_window:]) / history_window:
        stock_ratio_threshold -= 0.05
    
    return action
```
**Edge Cases**

* **Last Round**: Cooperate (C) in the last round to maximize collective payoff.
* **Zero Stock**: If the stock level reaches zero, defect (D) for the remainder of the game.

**Collective Mindset**

The ASCC strategy prioritizes cooperation when the stock is abundant and adapts to changes in opponent behavior. By monitoring average payoffs and adjusting cooperation levels accordingly, players using this strategy can maintain a balance between individual gains and collective sustainability.
'''

description_COLLECTIVE_452 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Awareness (ACSA)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative tone and observe opponents' behaviors.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of the capacity, cooperate (C) to maintain a sustainable stock level.
	* If the stock level is between 25% and 75% of the capacity, use a probabilistic approach:
		+ Cooperate (C) with probability p = (current_stock / capacity)^2
		+ Defect (D) with probability 1 - p
	* If the stock level is below 25% of the capacity, defect (D) to maximize individual payoff in a depleted environment.
3. **Opponent Behavior Adaptation:** Monitor opponents' actions and adjust cooperation probability based on their historical behavior:
	* If an opponent has defected more than 50% of the time in previous rounds, reduce cooperation probability by 20%.
	* If an opponent has cooperated more than 80% of the time in previous rounds, increase cooperation probability by 10%.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Stock Depletion:** If the stock level is critically low (< 10% of capacity), defect (D) to ensure some payoff in the current round.

**Collective Mindset Alignment:**

1. **Sustainability:** Prioritize maintaining a sustainable stock level to ensure long-term collective benefits.
2. **Adaptability:** Respond to opponents' behaviors and adapt cooperation probability to balance individual and collective interests.
3. **Robustness:** Implement probabilistic decision-making to reduce predictability and improve resilience against exploitation.

Pseudocode:
```
function ACSA(current_stock, capacity, history):
  if t == 1:  # Initial round
    return C
  elif current_stock >= 0.75 * capacity:
    return C
  elif 0.25 * capacity <= current_stock < 0.75 * capacity:
    p = (current_stock / capacity)^2
    if random() < p:
      return C
    else:
      return D
  else:  # Stock level is critically low
    return D

function adapt_cooperation_probability(opponent_history):
  opponent_defection_rate = sum(defections) / len(opponent_history)
  if opponent_defection_rate > 0.5:
    cooperation_probability *= 0.8
  elif opponent_defection_rate < 0.2:
    cooperation_probability *= 1.1

return ACSA(current_stock, capacity, history)
```
This strategy balances individual and collective interests by adapting to the game state and opponents' behaviors while prioritizing sustainability and robustness.
'''

description_COLLECTIVE_453 = '''
I propose a collective strategy called "Adaptive Stock-Based Cooperation" (ASBC). ASBC aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and game history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' initial actions.
2. **Stock-Based Cooperation Threshold**: Calculate a dynamic cooperation threshold (`τ`) based on the current stock level (`S`):

   `τ = (S / capacity) * (n - 1)`

   If the number of cooperators in the previous round is greater than or equal to `τ`, cooperate (C). Otherwise, defect (D).

3. **Defection Penalty**: Monitor opponents' actions and identify frequent defectors. Apply a penalty (`p`) to these opponents by reducing cooperation probability when interacting with them:

   `p = 1 - (number of cooperations / total number of rounds)`

   If an opponent has a low cooperation rate (`p < 0.5`), reduce the likelihood of cooperating with them in subsequent rounds.
4. **Stock Recovery**: When the stock level falls below a certain threshold (`S < 0.5 * capacity`), prioritize cooperation (C) to allow for stock recovery.

**Handling Edge Cases:**

1. **Last Round**: In the final round, defect (D) if the current stock level is low (`S < 0.25 * capacity`) or if opponents are expected to defect based on their history.
2. **Low Stock Levels**: When the stock level approaches zero (`S ≈ 0`), cooperate (C) in subsequent rounds to avoid complete depletion.

**Collective Mindset:**

ASBC prioritizes cooperation when the collective payoff is high, while adapting to opponents' actions and protecting against exploitation. By monitoring opponents' behavior and adjusting cooperation levels accordingly, ASBC promotes a balanced approach that benefits both individual players and the collective.

Pseudocode:
```python
def asbc(n, capacity, stock_history):
    # Initialize parameters
    tau = 0
    p = 1

    for t in range(r):
        S = current_stock()
        opponents_actions = get_opponents_actions()

        if t == 0:  # Initial Round
            action = C
        else:
            tau = (S / capacity) * (n - 1)
            num_cooperators = count_cooperations(opponents_actions)

            if num_cooperators >= tau:
                action = C
            elif S < 0.5 * capacity:  # Stock Recovery
                action = C
            else:
                action = D

        # Defection Penalty
        for opponent in opponents_actions:
            p_opponent = 1 - (opponent.cooperations / t)
            if p_opponent < 0.5:
                reduce_cooperation_probability(opponent)

        update_stock_history(action, opponents_actions)
    return total_payoff()
```
ASBC is designed to be adaptive and robust against various opponent strategies, while prioritizing collective sustainability and individual payoffs.
'''

description_COLLECTIVE_454 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adaptively responding to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for stock conservation.
2. **Subsequent Rounds**:
	* If the current stock level is above 75% of capacity, Defect (D) with probability `p_defect = (current_stock / capacity)^0.5`. This allows for some exploitation while maintaining a high stock level.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to help replenish the stock.
	* If the current stock level is below 50% of capacity, Cooperate (C) with probability `p_cooperate = (capacity / current_stock)^0.5`. This prioritizes stock conservation when levels are critically low.
3. **Last Round**: Defect (D) to maximize individual payoff, as there's no future round to consider.

**Edge Case Handling:**

* If the game has only two rounds, Cooperate (C) in both rounds to prioritize stock conservation.
* If an opponent's action is unknown or unobserved, assume they will Defect (D) and adjust your strategy accordingly.

**Collective Mindset Alignment:**

The ASC strategy is designed to promote collective sustainability while allowing for individual payoff optimization. By adapting to the game's state and history, ASC encourages cooperation when necessary to maintain a healthy stock level, while still permitting exploitation when safe to do so.

Pseudocode (simplified):
```python
def adaptive_stock_conservation(current_stock, capacity, round_num, total_rounds):
    if round_num == 1:
        return 'C'  # Cooperate in the first round
    
    p_defect = (current_stock / capacity) ** 0.5
    if current_stock > 0.75 * capacity:
        return 'D' if random.random() < p_defect else 'C'
    
    elif 0.5 <= current_stock / capacity <= 0.75:
        return 'C'
    
    else:  # current_stock < 0.5 * capacity
        p_cooperate = (capacity / current_stock) ** 0.5
        return 'C' if random.random() < p_cooperate else 'D'

    if round_num == total_rounds:
        return 'D'  # Defect in the last round

# Usage:
action = adaptive_stock_conservation(current_stock, capacity, round_num, total_rounds)
```
This strategy will be implemented as an algorithm and tested against other AI systems in a tournament setting.
'''

description_COLLECTIVE_455 = '''
**Collective Strategy: Adaptive Common Pool Resource (ACPR) Management**

The ACPR strategy balances individual payoff maximization with collective sustainability, adapting to varying opponent behaviors and game states.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to signal cooperation and maximize initial payoffs.
2. **Stock-Based Cooperation:** If the current stock level is above a threshold (`stock_threshold` = 0.75 × `capacity`), cooperate (C). This ensures collective sustainability and maintains a healthy stock for future rounds.
3. **Opponent-Adaptive Defection:** Monitor opponents' actions in previous rounds. If an opponent has defected (D) more than twice in the last three rounds, defect (D) to avoid being exploited.
4. **Reciprocal Cooperation:** If an opponent cooperated (C) in the previous round, cooperate (C) with a probability (`reciprocity_prob` = 0.8). This encourages reciprocity and cooperation among players.
5. **Late-Game Prudence:** In the last two rounds (`r` - 2 ≤ `current_round` ≤ `r`), always cooperate (C) to ensure some collective sustainability, even if opponents defect.

**Edge Cases:**

1. **Last Round:** Cooperate (C) in the final round to maximize individual payoff and contribute to collective sustainability.
2. **Low Stock:** If the current stock level falls below (`stock_threshold` / 2), cooperate (C) to avoid depletion and maintain some collective sustainability.

**Collective Mindset:**

The ACPR strategy prioritizes collective sustainability while adapting to opponent behaviors. By cooperating when possible and defecting strategically, this approach balances individual payoff maximization with the need for long-term collective sustainability.

Pseudocode:
```markdown
function ACPR(current_stock, current_round, opponents_actions)
  stock_threshold = 0.75 * capacity

  if current_round == 1 then
    return Cooperate (C)

  if current_stock > stock_threshold then
    return Cooperate (C)

  opponent_defections = count(defections in opponents_actions[-3:])
  if opponent_defections > 2 then
    return Defect (D)

  reciprocal_cooperation = random(reciprocity_prob)
  if reciprocal_cooperation and opponents_actions[-1] == Cooperate then
    return Cooperate (C)

  if current_round >= r - 2 then
    return Cooperate (C)

  if current_stock < stock_threshold / 2 then
    return Cooperate (C)

  # Default: Defect (D) to maximize individual payoff
  return Defect (D)
end function
```
This strategy will adapt to various opponent behaviors while prioritizing collective sustainability, making it a robust competitor in the tournament.
'''

description_COLLECTIVE_456 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative baseline and encourage others to do the same.
2. **Stock-dependent Cooperation**: In subsequent rounds, cooperate if the current stock level is above a certain threshold, `stock_threshold`, which is calculated as 75% of the capacity (`capacity * 0.75`). This ensures that cooperation is maintained when the stock is relatively healthy.
3. **Defection Prevention**: If the previous round's total consumption exceeded 50% of the capacity, defect (D) in the current round to prevent over-exploitation and promote stock recovery.
4. **Adaptive Threshold Adjustment**: After each round, adjust `stock_threshold` based on the average payoffs of all players in the previous round:
	* If the average payoff is above a certain threshold (`payoff_threshold`, e.g., 75% of the maximum possible payoff), increase `stock_threshold` by 5% to encourage cooperation.
	* Otherwise, decrease `stock_threshold` by 5% to promote caution and prevent over-exploitation.

Pseudocode:
```
initialize stock_threshold = capacity * 0.75
initialize payoff_threshold = max_payoff * 0.75

for each round:
  if current_round == 1:
    action = C (cooperate)
  else:
    if previous_total_consumption > capacity * 0.5:
      action = D (defect) // prevent over-exploitation
    elif stock_level > stock_threshold:
      action = C (cooperate) // conserve stock when healthy
    else:
      action = D (defect) // exploit when stock is low

  adjust stock_threshold based on previous round's average payoffs:
  if average_payoff >= payoff_threshold:
    stock_threshold *= 1.05 // increase threshold for cooperation
  else:
    stock_threshold *= 0.95 // decrease threshold for caution
```
**Handling Edge Cases:**

* **Last Round**: Cooperate (C) in the last round to maximize collective payoffs, as there are no future rounds to consider.
* **Low Stock Levels**: If the stock level falls below a critical threshold (`critical_stock_threshold`, e.g., 25% of capacity), defect (D) to ensure individual survival.

**Collective Mindset:**

The ASC strategy is designed to balance individual interests with collective well-being. By cooperating when the stock is healthy and adapting to changes in the game state, players can maintain a sustainable stock level and maximize overall payoffs. The strategy also promotes cooperation by adjusting the `stock_threshold` based on average payoffs, encouraging players to work together towards a mutually beneficial outcome.

By implementing ASC, players can develop a collective understanding of the game dynamics and adapt their behavior to ensure long-term sustainability and success.
'''

description_COLLECTIVE_457 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock-Based Threshold (ATTS)**

**Overview**
ATTS is a collective strategy that balances individual self-interest with cooperation to maintain a healthy common pool resource. It adapts to changing stock levels and opponent behaviors, ensuring robustness in a wide range of scenarios.

**Decision Rules**

1. **Initial Round**: Cooperate (C) to establish a baseline for the game.
2. **Subsequent Rounds**: Defect (D) if the current stock level is below a threshold (`stock_threshold`); otherwise, cooperate (C).

**Stock Threshold Calculation**
`stock_threshold` = `capacity` / 3

This threshold ensures that players will start defecting when the stock level drops to one-third of its capacity, indicating potential over-exploitation.

**Tit-for-Tat Component**

* If a player's payoff in the previous round was lower than their expected payoff (i.e., they were exploited), they will defect (D) in the current round.
* If a player's payoff in the previous round was equal to or higher than their expected payoff, they will cooperate (C) in the current round.

**Additional Logic**

* **Last Round**: Always defect (D) to maximize individual payoffs, as there are no future rounds to consider.
* **Low Stock Warning**: If the stock level drops below `capacity` / 6, all players should cooperate (C) for two consecutive rounds to allow the stock to recover.

**Pseudocode**
```python
def ATTS(stock, capacity, history):
    if round == 1:  # Initial Round
        return C
    
    stock_threshold = capacity / 3
    if stock < stock_threshold:
        return D
    
    prev_payoff = history[-1]['payoff']
    expected_payoff = stock / (2 * n)
    
    if prev_payoff < expected_payoff:
        return D  # Tit-for-Tat: defect after exploitation
    else:
        return C
    
    if round == r:  # Last Round
        return D
    
    if stock < capacity / 6:  # Low Stock Warning
        return C for two consecutive rounds
```
**Collective Mindset**
ATTS promotes cooperation by:

1. Encouraging players to cooperate when the stock level is healthy.
2. Punishing exploitation through tit-for-tat behavior.
3. Allowing players to adapt to changing stock levels and opponent behaviors.

By using a stock-based threshold, ATTS balances individual self-interest with collective responsibility, ensuring a robust strategy in various scenarios.
'''

description_COLLECTIVE_458 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for stock conservation and observe opponents' behaviors.
2. **Stock-Based Cooperation:** If the current stock level is above 50% of the capacity, cooperate (C). This ensures that the stock remains sustainable and encourages others to conserve as well.
3. **Defection Threshold:** If the current stock level falls below 50% of the capacity, defect (D) if at least one opponent defected in the previous round. This adapts to opponents' exploitative behaviors and aims to prevent stock depletion.
4. **Punishment Mechanism:** If an opponent defected in the previous round while the stock was above 50%, cooperate (C) in the current round. This gentle punishment encourages cooperation and rewards sustained conservation efforts.
5. **Stock Recovery:** If the stock level is below 25% of the capacity, cooperate (C) unconditionally to prioritize recovery.

**Edge Cases:**

* **Last Round:** Defect (D) in the last round, as there's no future benefit to conserving the stock.
* **Low Stock Levels:** If the stock level falls below 10% of the capacity, defect (D) unconditionally to maximize individual payoff in a depleted environment.

**Collective Mindset:**

The Adaptive Stock Conservation strategy prioritizes collective sustainability while adapting to opponents' behaviors. By cooperating when the stock is above 50%, ASC encourages others to conserve and maintain a healthy stock level. The defection threshold and punishment mechanism ensure that exploitative behaviors are addressed, promoting cooperation and fair play.

**Pseudocode:**
```markdown
function ASC(current_stock, previous_actions, capacity):
    if current_round == 1:
        return COOPERATE

    if current_stock >= 0.5 * capacity:
        return COOPERATE

    defected_opponents = [opponent for opponent in opponents if opponent.defected_in_previous_round]
    if len(defected_opponents) > 0 and current_stock < 0.5 * capacity:
        return DEFECT

    punished_opponents = [opponent for opponent in opponents if opponent.defected_in_previous_round and current_stock >= 0.5 * capacity]
    if len(punished_opponents) > 0:
        return COOPERATE

    if current_stock < 0.25 * capacity:
        return COOPERATE

    # Last round or low stock levels
    return DEFECT
```
This strategy will be implemented as an algorithm and compete against other AI systems in the tournament, demonstrating its adaptability and robustness in promoting collective sustainability.
'''

description_COLLECTIVE_459 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Sensitive Tit-for-Tat (ASST)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline of cooperation and encourage others to do the same.
2. **Subsequent Rounds:** Use a modified Tit-for-Tat approach, where:
	* If the average payoff per player in the previous round is above a certain threshold (e.g., 75% of the maximum possible payoff), cooperate (C).
	* Otherwise, defect (D) with a probability proportional to the stock level ( Stock/Capacity ). This means that as the stock level decreases, the likelihood of defecting increases.
3. **Stock-Sensitive Adjustment:** If the current stock level falls below 25% of the capacity, switch to a more cooperative strategy by increasing the threshold for cooperation or decreasing the probability of defecting.

**Pseudocode:**
```
function ASST(n, r, capacity, stock_history):
    if round == 1:
        return C
    else:
        avg_payoff_prev = calculate_average_payoff(stock_history)
        if avg_payoff_prev > 0.75 * max_payoff:
            return C
        else:
            defect_prob = (capacity - stock) / capacity
            if random() < defect_prob:
                return D
            else:
                return C

function calculate_average_payoff(stock_history):
    # Calculate average payoff per player in the previous round
    total_payoff = 0
    for i in range(n):
        total_payoff += stock_history[round-1][i]
    return total_payoff / n
```
**Edge Cases:**

* **Last Round:** Defect (D) to maximize individual payoff, as there are no future rounds to consider.
* **Low Stock Levels:** Switch to a more cooperative strategy to prevent complete depletion of the stock and encourage others to do the same.

**Collective Mindset:**

The ASST strategy is designed to balance individual self-interest with collective well-being. By cooperating when the average payoff per player is high, it encourages other players to cooperate as well. When the stock level falls, the strategy adapts by increasing cooperation to prevent depletion and promote sustainability. This approach aims to maintain a stable and mutually beneficial environment for all players.

By being adaptive and responsive to the game's state and history, ASST can effectively handle a wide range of opponent behaviors and contribute to a robust collective outcome in the tournament.
'''

description_COLLECTIVE_460 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability, adapting to various opponent behaviors and game states.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline stock level and encourage cooperation.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play a mixed strategy:
		+ With probability p = (current_stock / capacity)^(2/n), Cooperate (C).
		+ With probability 1 - p, Defect (D).
	* If the current stock level is below 50% of capacity, Defect (D).

Pseudocode for the decision rule:
```python
def ASC(current_stock, capacity, n):
    if t == 1:  # initial round
        return 'C'
    elif current_stock >= 0.75 * capacity:
        return 'C'
    elif 0.5 * capacity <= current_stock < 0.75 * capacity:
        p = (current_stock / capacity) ** (2/n)
        return 'C' if random.random() < p else 'D'
    else:  # current_stock < 0.5 * capacity
        return 'D'
```
**Rationale:**

* Cooperating in the initial round sets a positive tone and allows the strategy to adapt to opponent behaviors.
* When the stock level is high, cooperation helps maintain a sustainable level and encourages others to cooperate.
* The mixed strategy in the middle range (50%-75% capacity) balances individual payoffs with collective sustainability. As the stock level decreases, the probability of cooperating decreases, reflecting the growing need for individual consumption.
* Defecting when the stock level is low (<50% capacity) prioritizes individual payoffs to ensure some reward, even if the collective outcome may suffer.

**Edge Cases:**

* **Last Round (t=r):** Play as in subsequent rounds, but with a slightly higher probability of cooperating (p = 0.6 \* p) to encourage cooperation and maintain a positive final stock level.
* **Tie-breaking:** In case of a tie in the mixed strategy (e.g., two players have the same random value), resolve by Cooperating.

**Collective Mindset:**

The ASC strategy aligns with the collective mindset by:

* Balancing individual payoffs with collective sustainability
* Adapting to various opponent behaviors and game states
* Encouraging cooperation, especially when the stock level is high
* Prioritizing individual consumption only when the stock level is critically low

By following this adaptive and robust strategy, ASC aims to perform well in a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_461 = '''
**Collective Strategy: "Sustainable Cooperation"**

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe the game parameters and initial state.
	* Cooperate (C) to establish a baseline for sustainable consumption.
2. **Middle Rounds (2 ≤ t < r)**:
	* Calculate the average stock growth rate over previous rounds (`growth_rate`).
	* If `growth_rate` is above a threshold (`θ`) and the current stock level is below capacity, Cooperate (C) to maintain sustainability.
	* Otherwise, Defect (D) with probability `p = 1 - (stock/capacity)` to balance short-term gains with long-term sustainability.
3. **Final Round (t=r)**:
	* Defect (D) to maximize individual payoff in the last round.

**Pseudocode:**
```python
def sustainable_cooperation(game_state, game_params):
    if t == 1:  # Initial round
        return "C"
    
    growth_rate = calculate_growth_rate(game_state)
    stock_level = game_state["stock"]
    
    if growth_rate > θ and stock_level < capacity:
        return "C"  # Cooperate to maintain sustainability
    
    p = 1 - (stock_level / capacity)
    return "D" with probability p
```
**Handling Edge Cases:**

* In the first round, cooperating sets a precedent for sustainable consumption.
* In the final round, defecting maximizes individual payoff without compromising long-term sustainability.
* For middle rounds, the strategy balances cooperation and defection based on stock growth rate and level.

**Collective Mindset:**

This strategy prioritizes collective sustainability while allowing for individual flexibility. By cooperating in the initial round and maintaining sustainability when possible, players contribute to a stable common pool resource. Defecting with probability `p` in middle rounds introduces an adaptive element, enabling players to balance short-term gains with long-term sustainability.

**Key Parameters:**

* `θ`: growth rate threshold (e.g., 0.5)
* `capacity`: maximum sustainable stock level

This strategy will be robust against a wide range of opponent behaviors, as it adapts to the current state and history of the game. By prioritizing collective sustainability and introducing an adaptive element, "Sustainable Cooperation" aims to achieve a balance between individual and collective interests in the Common Pool Resource Game.
'''

description_COLLECTIVE_462 = '''
I'll design a collective strategy that balances individual payoffs with sustainability of the common pool resource. I'll introduce a robust and adaptive approach, leveraging the game's state and history.

**Strategy Name:** Adaptive Sustainability (AS)

**Decision Rules:**

1. **Initial Round (t=1):**
   - Observe the initial stock level.
   - Cooperate (C) if the initial stock is above 75% of capacity; otherwise, Defect (D).

2. **Subsequent Rounds (t>1):**
   - Calculate the average historical payoff per player (AHP) up to the previous round.
   - Evaluate the current stock level relative to the capacity:
     - If the stock is below 25% of capacity, always Defect (D).
     - If the stock is between 25% and 50% of capacity, Cooperate (C) if AHP is above a threshold (T); otherwise, Defect (D). The threshold T will be adjusted based on performance.
     - If the stock is above 50% of capacity:
       - Cooperate (C) if the number of cooperating players in the previous round is greater than or equal to n/2; otherwise, Defect (D).

3. **Last Round (t=r):**
   - Always Defect (D), as there's no future stock to conserve.

**Threshold Adjustment (T):**

- Initially set T to the average payoff per player when all players cooperate.
- Every 5 rounds, adjust T based on the average historical payoff per player:
  - If AHP is above T, decrease T by 10%.
  - If AHP is below T, increase T by 10%.

**Pseudocode:**
```
AS_Strategy(n, capacity, r, history):
  if t == 1:
    stock = get_initial_stock()
    if stock >= 0.75 * capacity:
      action = C
    else:
      action = D

  else:
    AHP = calculate_average_historical_payoff(history)
    stock = get_current_stock()

    if stock < 0.25 * capacity:
      action = D
    elif stock < 0.5 * capacity:
      if AHP > T:
        action = C
      else:
        action = D
    else:
      prev_coop_count = count_cooperators(history[-1])
      if prev_coop_count >= n/2:
        action = C
      else:
        action = D

  if t == r:  # Last round
    action = D

  return action
```
**Collective Mindset:**
The Adaptive Sustainability strategy prioritizes cooperation when the stock is plentiful and there's a history of cooperation. It adapts to changing circumstances, balancing individual payoffs with sustainability concerns. By adjusting the threshold T, AS responds to the evolving game dynamics and performance.

In the tournament against independent strategies, AS will exhibit robustness by responding effectively to various opponent behaviors while maintaining a collective mindset focused on long-term sustainability.
'''

description_COLLECTIVE_463 = '''
**Collective Strategy: Adaptive Tit-for-Two-Tats with Stock Consideration**

This strategy aims to balance individual payoff maximization with collective sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **General Rule:** Observe the previous round's actions and payoffs. If:
	* Most players (> n/2) cooperated, cooperate (C) in the current round.
	* Most players (> n/2) defected, defect (D) in the current round.
	* The number of cooperators and defectors is equal or close to equal (±1), use the **Tit-for-Two-Tats** approach:
		+ If two or more consecutive rounds had a majority of defections, defect (D) for one round to signal disappointment.
		+ Otherwise, cooperate (C).
3. **Stock Consideration:** If the current stock level is low (< capacity/2), cooperate (C) to conserve resources and promote regrowth.
4. **Last Round:** Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.

**Pseudocode:**
```python
def adaptive_tit_for_two_tats(stock, previous_round_actions, previous_round_payoffs):
    # Initial round
    if current_round == 1:
        return 'C'

    # General rule
    num_cooperators = sum(1 for action in previous_round_actions if action == 'C')
    num_defectors = len(previous_round_actions) - num_cooperators

    if num_cooperators > n/2:
        return 'C'
    elif num_defectors > n/2:
        return 'D'
    else:
        # Tit-for-Two-Tats approach
        if two_consecutive_defection_majorities():
            return 'D'  # Signal disappointment
        else:
            return 'C'

    # Stock consideration
    if stock < capacity / 2:
        return 'C'

    # Last round
    if current_round == r:
        return 'D'
```
**Collective Mindset:**

This strategy prioritizes cooperation when possible, while also adapting to the actions of others and considering the state of the common pool resource. By cooperating in the initial round and using the Tit-for-Two-Tats approach, we encourage opponents to cooperate as well, promoting a collective mindset. When the stock level is low, we conserve resources by cooperating, ensuring the long-term sustainability of the game.

**Robustness:**

This strategy is robust against various opponent behaviors, including:

* Cooperators: We will cooperate with them, maintaining a high stock level and mutual benefits.
* Defectors: We will adapt to their actions, defecting when necessary to avoid being taken advantage of, while still promoting cooperation when possible.
* Mixed strategies: Our Tit-for-Two-Tats approach allows us to respond effectively to opponents who mix cooperation and defection.

This collective strategy should perform well in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_464 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Sensitive Tit-for-Tat (ACSST)**

The ACSST strategy is designed to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and opponent behavior.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play Tit-for-Tat (TFT): cooperate if most opponents cooperated in the previous round, otherwise defect.
	* If the current stock level is below 50% of capacity, defect (D) to maximize individual payoff while minimizing further depletion.
3. **Opponent Behavior:** Monitor opponent actions and adjust cooperation levels accordingly:
	* If an opponent defects repeatedly (more than 2 consecutive rounds), temporarily switch to defection for 2 rounds before reassessing.
	* If an opponent cooperates consistently (more than 2 consecutive rounds), increase cooperation by cooperating in the next round, even if the stock level is below 75%.

**Pseudocode:**
```
Function ACSST(stock, capacity, history):
    // Initial Round
    if (round == 1) {
        return Cooperate;
    }

    // Subsequent Rounds
    if (stock >= 0.75 * capacity) {
        return Cooperate;
    } else if (stock >= 0.5 * capacity && stock < 0.75 * capacity) {
        // Tit-for-Tat
        opponents_cooperated = count(opponents who cooperated in previous round);
        if (opponents_cooperated > n/2) {
            return Cooperate;
        } else {
            return Defect;
        }
    } else {  // stock < 0.5 * capacity
        return Defect;
    }

    // Opponent Behavior Adjustment
    for each opponent in opponents:
        if (opponent defected repeatedly):
            switch_to_defection = True;
            break;
        elif (opponent cooperated consistently):
            increase_cooperation = True;
            break;

    if (switch_to_defection):
        return Defect for 2 rounds;
    elif (increase_cooperation):
        return Cooperate in next round;
```
**Edge Cases:**

* Last Round: Play Tit-for-Tat to maintain a cooperative image and encourage others to do the same.
* Low Stock Levels: Prioritize individual payoff by defecting when stock levels are critically low (< 25% of capacity).

**Collective Mindset:**
ACSST aims to balance individual interests with collective sustainability. By adapting cooperation levels based on the current stock level and opponent behavior, ACSST promotes a culture of cooperation while minimizing the risk of exploitation.

In a tournament setting, ACSST is expected to perform well against independent strategies by:

* Encouraging cooperation through initial cooperation and Tit-for-Tat
* Adapting to changing opponent behaviors and stock levels
* Balancing individual payoffs with collective sustainability
'''

description_COLLECTIVE_465 = '''
Here's a collective strategy for the Common Pool Resource Game:

**Strategy Name: Adaptive Collective Harvesting (ACH)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to avoid over-harvesting and to test opponents' behaviors.
2. **Early Rounds (2 ≤ t ≤ r/2):**
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* Otherwise, defect (D) with a probability p = (current_stock / capacity)^2, and cooperate (C) with probability (1-p). This introduces a gradual shift towards defection as the stock depletes.
3. **Middle Rounds (r/2 < t ≤ 3r/4):**
	* Observe opponents' behaviors in the previous round:
		+ If most opponents (> n/2) cooperated, cooperate (C).
		+ If most opponents (> n/2) defected, defect (D).
		+ Otherwise, use the same logic as Early Rounds.
4. **Late Rounds (3r/4 < t ≤ r):**
	* Prioritize stock conservation:
		+ If the current stock level is below 25% of the capacity, cooperate (C) to avoid depletion.
		+ Otherwise, defect (D) with a probability p = (current_stock / capacity)^2, and cooperate (C) with probability (1-p).
5. **Last Round:** Defect (D), as there's no future stock to conserve.

**Handling Edge Cases:**

* If the current stock level is exactly at 0 or reaches 0 during a round, all players will get a payoff of 0 for that round.
* In case of ties in opponent behavior observations, use the previous decision rule (e.g., if tied in Middle Rounds, use Early Rounds logic).

**Collective Mindset Alignment:**

ACH prioritizes cooperation when possible, conserves stock levels, and adapts to opponents' behaviors. By gradually shifting towards defection as the stock depletes, ACH encourages other players to conserve the resource while still allowing for reasonable harvesting.

**Pseudocode (simplified):**
```python
def Adaptive_Collective_Harvesting(stock, capacity, n, r, t):
    if t == 1:
        return C  # Cooperate in first round
    
    early_round_threshold = 0.75 * capacity
    middle_round_threshold = 0.5 * n
    
    if stock > early_round_threshold:
        return C  # Cooperate when stock is high
    
    p_defect = (stock / capacity) ** 2
    
    if t < r / 2:
        return D with probability p_defect, C otherwise
    elif t < 3r/4:
        observe_opponent_behaviors(previous_round)
        if most_cooperated:
            return C
        elif most_defected:
            return D
        else:
            # Use early rounds logic
            return D with probability p_defect, C otherwise
    else:
        if stock < 0.25 * capacity:
            return C  # Conserve in late rounds when low stock
        else:
            return D with probability p_defect, C otherwise
    
    return D  # Defect in last round
```
This strategy should provide a robust and adaptive approach to the Common Pool Resource Game, balancing individual payoffs with collective conservation of the resource.
'''

description_COLLECTIVE_466 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round (t=1): Cooperate** - In the first round, all players cooperate to establish a baseline of cooperation and allow the stock to grow.
2. **Stock Threshold**: If the current stock level is below 25% of the capacity, **Defect** - This ensures that if the stock is critically low, individual self-interest takes precedence to avoid depletion.
3. **Majority Cooperation**: If at least (n-1) players cooperated in the previous round and the current stock level is above 50% of the capacity, **Cooperate** - This reinforces cooperation when most players are cooperating and the stock is relatively healthy.
4. **Minority Defection**: If fewer than (n/2) players defected in the previous round and the current stock level is below 75% of the capacity, **Defect** - This prevents exploitation by minority defectors and maintains a balance between cooperation and self-interest.
5. **Reciprocal Defection**: If at least one player defected in the previous round, **Defect** - This ensures that if any player defects, others will also defect to avoid being exploited.

Pseudocode:
```python
def ASC(n, capacity, stock, history):
    if t == 1:  # Initial Round
        return 'Cooperate'
    
    if stock < 0.25 * capacity:  # Stock Threshold
        return 'Defect'
    
    prev_round_coops = sum(1 for action in history[-1] if action == 'Cooperate')
    if prev_round_coops >= n - 1 and stock > 0.5 * capacity:  # Majority Cooperation
        return 'Cooperate'
    
    prev_round_defects = sum(1 for action in history[-1] if action == 'Defect')
    if prev_round_defects < n / 2 and stock < 0.75 * capacity:  # Minority Defection
        return 'Defect'
    
    if any(action == 'Defect' for action in history[-1]):  # Reciprocal Defection
        return 'Defect'
    
    return 'Cooperate'
```
**Edge Cases:**

* **Last Round (t=r)**: In the final round, all players will defect to maximize their individual payoffs.
* **Tiebreakers**: In cases where multiple rules apply, prioritize the rule that leads to cooperation.

**Collective Mindset:**
The Adaptive Stock Conservation strategy prioritizes cooperation when possible while adapting to changes in the stock level and opponent behaviors. By cooperating initially and reciprocating cooperation, ASC encourages other players to cooperate. When facing minority defection or low stock levels, ASC defects to protect individual interests. This collective strategy balances cooperation and self-interest, making it robust against a wide range of opponent behaviors.

ASC will be implemented as an algorithm and compete in the tournament, demonstrating its effectiveness in achieving high payoffs while maintaining a balance between cooperation and individual self-interest.
'''

description_COLLECTIVE_467 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and aims to balance individual payoffs with long-term sustainability of the common pool.

**Strategy Name:** Adaptive Sustainability (AS)

**Decision Rules:**

1. **Initial Exploration** (Rounds 1-2):
	* Play Cooperate (C) in the first round to observe opponents' initial behavior.
	* In the second round, play Defect (D) if at least one opponent defected in the previous round; otherwise, play C.
2. **Monitoring and Adaptation** (Rounds 3-r):
	* Track the number of opponents who played D in the previous round (defector_count).
	* If defector_count > n/2 (more than half of opponents defected), play D to avoid being exploited.
	* If stock < capacity / 2, play C to conserve resources and promote sustainability.
	* Otherwise, play C if average payoff per player in the previous round is above a certain threshold (e.g., 75% of maximum possible payoff); otherwise, play D.

Pseudocode:
```
def adaptive_sustainability(state, history):
    n = state['n']
    capacity = state['capacity']
    stock = state['stock']
    round_num = state['round_num']

    if round_num == 1:
        return 'C'  # initial exploration
    elif round_num == 2:
        prev_defectors = sum(1 for action in history[-1] if action == 'D')
        if prev_defectors > 0:
            return 'D'
        else:
            return 'C'

    defector_count = sum(1 for action in history[-1] if action == 'D')

    if defector_count > n / 2:
        return 'D'  # avoid exploitation
    elif stock < capacity / 2:
        return 'C'  # conserve resources
    else:
        avg_payoff_prev_round = sum(history[-1]) / n
        threshold = 0.75 * max_payoff(n, capacity)
        if avg_payoff_prev_round >= threshold:
            return 'C'
        else:
            return 'D'

max_payoff(n, capacity) = (capacity / (2 * n)) * n
```
**Edge Cases:**

* First round: Play C to observe opponents' behavior.
* Last round: Play D if stock is low (< 25% of capacity); otherwise, play C.
* If all opponents have defected in the previous round, play D to avoid being exploited.

**Collective Mindset:**
The Adaptive Sustainability strategy prioritizes long-term sustainability of the common pool while adapting to various opponent behaviors. By playing C when possible and conserving resources, AS promotes a collective mindset that balances individual payoffs with the well-being of the group.

This strategy should perform well in a tournament against independent strategies developed by other AI systems, as it:

1. Adapts to changing opponent behavior
2. Avoids exploitation by opponents
3. Conserves resources when necessary
4. Balances individual payoffs with collective sustainability

Please let me know if you'd like me to elaborate on any aspect of the strategy!
'''

description_COLLECTIVE_468 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)**

**Overview**
The ACSDT strategy balances individual interests with collective sustainability by adapting cooperation levels based on the current stock level and game history.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for reciprocity and encourage initial cooperation from others.
2. **Stock-Dependent Threshold**: Calculate a dynamic threshold, `T`, based on the current stock level:
   - If `stock` > `capacity / 2`, set `T = capacity / (2n)`. This favors cooperation when the stock is relatively high.
   - Otherwise, set `T = stock / (4n)`. This reduces consumption when the stock is low to promote sustainability.
3. **Cooperation Condition**: Cooperate (C) if:
   - The number of players who cooperated in the previous round (`num_coop_prev`) is greater than or equal to half the total number of players (`n / 2`), and
   - The current stock level is above the threshold (`stock ≥ T`).
4. **Defection Condition**: Defect (D) otherwise.

**Pseudocode**
```python
def ACSDT(stock, capacity, n, num_coop_prev):
    if round == 1:  # Initial Round
        return C
    
    T = calculate_threshold(stock, capacity, n)
    
    if num_coop_prev >= n / 2 and stock >= T:
        return C
    else:
        return D

def calculate_threshold(stock, capacity, n):
    if stock > capacity / 2:
        return capacity / (2n)
    else:
        return stock / (4n)
```
**Edge Cases**

* **Last Round**: In the final round, defect (D) to maximize individual payoff, as sustainability is no longer a concern.
* **Low Stock**: If the stock level falls below a certain critical value (e.g., `capacity / 4`), always cooperate (C) to prevent depletion and allow for potential growth.

**Collective Mindset**
The ACSDT strategy prioritizes collective sustainability by:

1. Encouraging cooperation when the stock is high or when many players cooperated previously.
2. Reducing consumption when the stock is low to promote replenishment.
3. Adapting to changing game conditions and player behaviors.

By following this adaptive and robust strategy, we aim to achieve a balance between individual payoffs and collective sustainability in the Common Pool Resource Game tournament.
'''

description_COLLECTIVE_469 = '''
**Collective Strategy: "Sustainable Harvest"**

Our collective strategy, "Sustainable Harvest," aims to balance individual payoffs with long-term sustainability of the common pool resource. We prioritize cooperation and adapt to the game state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for stock growth and demonstrate commitment to sustainability.
2. **Stock Thresholds:**
	* If the current stock is above 75% of capacity, Cooperate (C).
	* If the current stock is between 50% and 75% of capacity, defect (D) with probability p = (capacity - stock) / capacity.
	* If the current stock is below 50% of capacity, Defect (D) to maximize individual payoff in the short term.
3. **Recent History:**
	* Monitor the actions of other players over the past three rounds.
	* If at least two-thirds of players cooperated in the previous round, Cooperate (C).
	* Otherwise, use the stock threshold rules above.

**Additional Considerations:**

1. **Last Round:** In the final round, Defect (D) to maximize individual payoff, as there is no future impact on the game state.
2. **Opponent Analysis:** Observe opponents' actions and adjust the probability of defecting (p) based on their historical behavior:
	* If an opponent has defected more than 50% of the time in recent rounds, increase p by 0.1 for each additional defection.
	* If an opponent has cooperated more than 50% of the time in recent rounds, decrease p by 0.1 for each additional cooperation.

**Pseudocode:**
```
function SustainableHarvest(stock, capacity, history):
    if round == 1:
        return C
    elif stock > 0.75 * capacity:
        return C
    elif stock >= 0.5 * capacity:
        p = (capacity - stock) / capacity
        return D with probability p
    else:
        return D

    // Recent History Analysis
    recent_cooperators = count(C actions in history[-3:])
    if recent_cooperators >= 2/3 * len(players):
        return C

    // Opponent Analysis
    opponent_actions = analyze(history)
    for opponent, actions in opponent_actions.items():
        defector_count = count(D actions by opponent)
        if defector_count > 0.5 * len(actions):
            p += 0.1 * (defector_count - 0.5 * len(actions))
        elif cooperator_count > 0.5 * len(actions):
            p -= 0.1 * (cooperator_count - 0.5 * len(actions))

    // Last Round
    if round == total_rounds:
        return D

    return decision based on stock thresholds or recent history analysis
```

**Rationale:**

* By initially cooperating, we establish a foundation for sustainable growth and signal our commitment to collective well-being.
* The stock threshold rules balance individual payoffs with long-term sustainability. As the stock approaches capacity, cooperation is more likely to maintain growth. When the stock is low, defection may be necessary to maximize short-term payoff.
* Recent history analysis promotes cooperation when others have demonstrated similar behavior, fostering a sense of collective responsibility.
* Opponent analysis adapts our strategy to respond to different types of opponents, allowing us to exploit or cooperate with them as needed.

By following the "Sustainable Harvest" strategy, we aim to achieve a balance between individual payoffs and long-term sustainability, promoting a robust and adaptive approach in a dynamic environment.
'''

description_COLLECTIVE_470 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock Awareness (ATSA)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to initiate cooperation and gauge opponents' behavior.
2. **Tit-for-Tat**: In subsequent rounds, play C if at least 50% of players cooperated in the previous round; otherwise, Defect (D).
3. **Stock Awareness**: Adjust the Tit-for-Tat threshold based on the current stock level:
	* If the stock is below 25% of capacity, cooperate more frequently by reducing the threshold to 33%.
	* If the stock is above 75% of capacity, cooperate less frequently by increasing the threshold to 67%.
4. **Punishment**: If a player defects when the stock is low (below 25%), retaliate with Defection in the next round.
5. **Forgiveness**: Gradually return to cooperation if opponents start cooperating again.

**Edge Cases:**

1. **Last Round**: Cooperate if the stock is above 50% of capacity; otherwise, Defect to maximize individual payoff.
2. **Low Stock**: If the stock falls below 10%, cooperate unconditionally to prevent depletion.
3. **High Stock**: If the stock exceeds 90% of capacity, defect more frequently (increase threshold to 75%) to maintain a balance.

**Collective Mindset:**

1. **Align with Cooperative Players**: Cooperate with players who have cooperated in previous rounds to encourage collective cooperation.
2. **Deter Defectors**: Retaliate against defectors when the stock is low to discourage exploitation.
3. **Adapt to Changing Environment**: Adjust the Tit-for-Tat threshold based on the current stock level to balance individual and collective interests.

Pseudocode (simplified):
```python
def ATSA(stock, history, capacity):
  # Initial round: Cooperate
  if len(history) == 0:
    return 'C'
  
  # Calculate tit-for-tat threshold based on stock level
  threshold = 0.5
  if stock < 0.25 * capacity:
    threshold = 0.33
  elif stock > 0.75 * capacity:
    threshold = 0.67
  
  # Tit-for-Tat logic
  cooperators = sum(1 for action in history[-1] if action == 'C')
  if cooperators >= threshold * len(history[-1]):
    return 'C'
  else:
    return 'D'
  
  # Punishment and Forgiveness
  if stock < 0.25 * capacity and history[-1].count('D') > 0:
    return 'D'  # Retaliate against defectors
  elif len([action for action in history[-5:] if action == 'C']) >= 3:
    return 'C'  # Gradually forgive opponents
  
  # Edge cases
  if stock < 0.1 * capacity:
    return 'C'
  elif stock > 0.9 * capacity:
    threshold = 0.75
    # ...
```
This strategy balances individual and collective interests by adapting to the game's state, history, and opponent behavior. By being robust to a wide range of opponent behaviors, ATSA is well-suited for a tournament environment where independent strategies will be employed by other AI systems.
'''

description_COLLECTIVE_471 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and aligns with the collective mindset:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) unconditionally to establish a cooperative tone and maximize initial payoffs.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, defect (D) with probability p = (capacity - stock) / capacity.
	* If the current stock level is below 50% of capacity, defect (D) unconditionally to maximize individual payoffs in a depleted environment.
3. **Stock Depletion Threshold:** Monitor the accumulated stock depletion over rounds. If the total consumption exceeds 75% of the initial capacity, switch to unconditional defection (D) for the remainder of the game.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) unconditionally to maximize individual payoffs, as there are no future rounds to consider.
2. **Low Stock Levels:** If the current stock level is below 25% of capacity, defect (D) unconditionally to avoid further depletion.

**Collective Mindset:**

ACC prioritizes cooperation when the common pool resource is abundant, promoting collective conservation and maximizing payoffs for all players. As the stock depletes, ACC adapts by introducing defection with increasing probability, balancing individual interests with collective sustainability. The strategy also accounts for the accumulated stock depletion over rounds, adjusting behavior to prevent catastrophic depletion.

**Pseudocode:**
```python
def ACC(stock, capacity, t, r):
  if t == 1:
    return C
  elif stock >= 0.75 * capacity:
    return C
  elif stock >= 0.5 * capacity:
    p = (capacity - stock) / capacity
    return D with probability p, else C
  elif stock < 0.5 * capacity:
    return D
  if total_consumption > 0.75 * initial_capacity:
    return D

def play_game(stock, capacity, r):
  for t in range(1, r+1):
    action = ACC(stock, capacity, t, r)
    # Update stock and calculate payoffs
    # ...
```
This strategy is designed to be robust against various opponent behaviors, prioritizing collective conservation while adapting to changing environmental conditions.
'''

description_COLLECTIVE_472 = '''
Here's a collective strategy that adapts to various opponent behaviors and game conditions:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) with a probability of 0.5, i.e., randomize between C and D. This helps gather information about opponents' initial strategies without immediately exploiting the resource.
2. **Middle Rounds (1 < t < r-1)**:
	* Observe the previous round's stock level and growth.
	* If the stock level is above 75% of capacity, Cooperate (C) with a probability proportional to the number of players who cooperated in the previous round (excluding yourself). This encourages cooperation when the resource is abundant.
	* If the stock level is below 25% of capacity, Defect (D) to ensure some payoff. However, if multiple opponents defected in the previous round, Cooperate (C) with a probability of 0.5 to try to rebuild the resource.
	* Otherwise (stock level between 25% and 75%), use a tit-for-tat approach: Cooperate (C) if most players cooperated in the previous round; Defect (D) otherwise.
3. **Final Round (t=r)**: If the stock level is above 50% of capacity, Cooperate (C); otherwise, Defect (D). This balances short-term gains with long-term sustainability.

**Edge Cases and Additional Considerations:**

* **Low Stock Levels**: When the stock falls below 10% of capacity, switch to a more conservative strategy: Cooperate (C) with a probability of 0.75 until the stock level recovers.
* **Sudden Changes in Opponent Behavior**: If an opponent suddenly changes their strategy (e.g., from C to D or vice versa), adapt by adjusting your cooperation probability based on the new information.
* **Identical Actions**: When multiple opponents take identical actions, consider it a signal that they might be following a similar strategy. Adjust your decision-making accordingly.

**Pseudocode:**

```python
def ACC(n, r, capacity, current_stock, history):
    if t == 1:
        return random.choice([C, D])  # Randomize in the first round

    previous_stock = history[t-2]
    stock_growth = calculate_stock_growth(previous_stock)

    if current_stock > 0.75 * capacity:
        cooperation_prob = count_cooperators(history[t-2]) / (n - 1)
        return C with probability cooperation_prob
    elif current_stock < 0.25 * capacity:
        if multiple_defectors(history[t-2]):
            return C with probability 0.5
        else:
            return D
    else:
        most_recent_actions = history[t-2]
        if most_cooperated(most_recent_actions):
            return C
        else:
            return D

    # Final round special case
    if t == r:
        if current_stock > 0.5 * capacity:
            return C
        else:
            return D
```

**Collective Mindset:**

The ACC strategy prioritizes cooperation when the resource is abundant, gradually adapting to changes in opponent behavior and game conditions. By balancing short-term gains with long-term sustainability, this collective approach aims to maintain a stable resource level while minimizing the risk of over-exploitation.

This strategy should perform well against a wide range of independent strategies developed by other AI systems, as it:

1. Gathers information about opponents' initial strategies without immediately exploiting the resource.
2. Adapts to changes in opponent behavior and game conditions.
3. Prioritizes cooperation when the resource is abundant.
4. Balances short-term gains with long-term sustainability.

Let me know if you have any further questions or need additional clarification!
'''

description_COLLECTIVE_473 = '''
To design a collective strategy for this Common Pool Resource Game that is adaptive and robust to various opponent behaviors, I propose the following approach:

**Strategy Name:** Adaptive Stock Conservation (ASC)

**Decision Rules:**

1. **Initial Rounds**: In the first round, play Cooperate (C) to establish a baseline of cooperation and encourage others to do the same.
2. **Monitoring Phase**: For rounds 2 to r-1, monitor the stock level and opponent actions. If:
	* The stock level is above 75% of capacity, play C to conserve resources and maintain cooperation.
	* The stock level is between 50% and 75% of capacity, play D if at least one opponent defected in the previous round; otherwise, play C.
	* The stock level is below 50% of capacity, play D to maximize individual payoff, as cooperation may not be sustainable.
3. **Final Round**: In the last round (r), play D regardless of the stock level or opponents' actions, as there are no future rounds to consider.

**Edge Cases:**

* If an opponent defects in a previous round, and the current stock level is above 75% of capacity, ASC will still cooperate to maintain cooperation and encourage others to do so.
* If multiple opponents defect in the same round, ASC will adapt by playing D in subsequent rounds if the stock level falls below 50% of capacity.

**Collective Mindset:**

ASC prioritizes collective sustainability while adapting to individual payoffs. By initially cooperating and monitoring opponent actions, ASC encourages cooperation and maintains a stable stock level. When opponents defect or the stock level drops, ASC adapts by playing D to ensure individual payoff maximization.

**Pseudocode:**
```python
def adaptive_stock_conservation(n, r, capacity, current_stock, previous_actions):
    if round == 1:
        return "C"
    elif round < r - 1:
        if current_stock > 0.75 * capacity:
            return "C"
        elif 0.5 * capacity <= current_stock <= 0.75 * capacity:
            if any(opponent_defected(previous_actions)):
                return "D"
            else:
                return "C"
        else:  # current_stock < 0.5 * capacity
            return "D"
    else:  # final round
        return "D"

def opponent_defected(previous_actions):
    for action in previous_actions:
        if action == "D":
            return True
    return False
```
ASC is designed to be a robust and adaptive strategy that balances collective sustainability with individual payoff maximization. By monitoring the stock level and adapting to opponent actions, ASC aims to achieve a high total payoff while promoting cooperation among players.
'''

description_COLLECTIVE_474 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoff maximization with collective sustainability of the common pool resource. It adapts to the game state and history, responding to opponent behaviors while promoting cooperation.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' strategies.
2. **Stock Thresholds**: Introduce two stock thresholds:
	* **Conservation Threshold** (CT): 0.5 \* capacity
	* **Alarm Threshold** (AT): 0.25 \* capacity

If the current stock is above CT, cooperate (C). If it's below AT, defect (D).

3. **Opponent Behavior Analysis**: Observe opponents' actions in previous rounds and calculate their cooperation ratio (CR):
CR = (# of cooperative actions) / (total # of actions)

4. **Adaptive Response**:
	* If the average CR of all opponents is above 0.5, cooperate (C).
	* If the average CR is below 0.3, defect (D).
	* Otherwise, use a mixed strategy: cooperate with probability equal to the average CR.

5. **Stock-Based Adjustment**: Adjust the cooperation probability based on the current stock level:
	* If stock > CT, increase cooperation probability by 10%.
	* If stock < AT, decrease cooperation probability by 20%.

**Pseudocode**
```python
def ASC_strategy(stock, capacity, history):
    # Initial round
    if len(history) == 0:
        return "C"

    # Stock thresholds
    CT = 0.5 * capacity
    AT = 0.25 * capacity

    if stock > CT:
        return "C"
    elif stock < AT:
        return "D"

    # Opponent behavior analysis
    opponent_CRs = []
    for opponent_history in history:
        CR = (opponent_history.count("C")) / len(opponent_history)
        opponent_CRs.append(CR)

    avg_CR = sum(opponent_CRs) / len(opponent_CRs)

    # Adaptive response
    if avg_CR > 0.5:
        return "C"
    elif avg_CR < 0.3:
        return "D"
    else:
        cooperation_prob = avg_CR
        if stock > CT:
            cooperation_prob += 0.1
        elif stock < AT:
            cooperation_prob -= 0.2

        # Mixed strategy
        return "C" if random.random() < cooperation_prob else "D"
```
**Edge Cases**

* Last round: If it's the last round, defect (D) to maximize individual payoff.
* Multiple opponents with identical CR: In case of a tie, use a mixed strategy with equal probabilities.

By employing this adaptive and collective strategy, ASC aims to promote sustainable exploitation of the common pool resource while responding effectively to various opponent behaviors.
'''

description_COLLECTIVE_475 = '''
To design a collective strategy for this Common Pool Resource Game, I propose a hybrid approach that balances individual self-interest with collective sustainability. This strategy, dubbed "Adaptive Collective Conservation" (ACC), aims to ensure long-term payoffs while adapting to various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline of cooperation and encourage others to do the same.
2. **Observation Phase:** For rounds 2-5, observe opponents' actions and calculate the average cooperation rate (ACR) among all players. ACR is the proportion of players who chose C in each round.
3. **Adaptive Threshold:** Set an adaptive threshold (AT) based on the observed ACR:
	* If ACR ≥ 0.6, set AT = 0.7 ( conservative threshold)
	* If 0.4 ≤ ACR < 0.6, set AT = 0.5 ( moderate threshold)
	* If ACR < 0.4, set AT = 0.3 (liberal threshold)
4. **Cooperation Rule:** In subsequent rounds, cooperate if the current stock level is above the capacity multiplied by the adaptive threshold (AT). Otherwise, defect.
5. **Defection Avoidance:** If a player observes that more than half of their opponents defected in the previous round, they will defect in the next round to avoid being taken advantage of.

**Edge Cases:**

1. **Last Round:** In the final round, cooperate if the current stock level is above 0.5 \* capacity. Otherwise, defect.
2. **Critical Stock Levels:** If the stock level falls below 10% of the capacity, all players will cooperate to avoid depleting the resource.

**Collective Mindset:**

1. **Foster Cooperation:** ACC encourages cooperation by setting a high initial threshold and gradually adjusting it based on observed opponent behavior.
2. **Adaptive Response:** By adapting to changing opponent behaviors, ACC promotes a collective response to ensure sustainability while allowing for self-interested decisions.
3. **Robustness:** ACC's hybrid approach ensures robustness against various opponent strategies, including defectors, cooperators, and mixed strategists.

**Pseudocode:**
```python
def ACC(n, capacity, r):
  # Initialize variables
  stock = capacity
  ACR = [0] * n  # average cooperation rate for each player
  AT = 0.7  # adaptive threshold

  for round in range(1, r+1):
    if round == 1:
      action = C  # cooperate in the first round
    else:
      # calculate ACR and update AT
      ACR = [sum(player_actions) / (round-1) for player_actions in opponent_actions]
      AT = update_AT(ACR)

      # cooperation rule
      if stock > capacity * AT:
        action = C
      else:
        action = D

    # defect avoidance
    if sum(opponent_defections) > n/2:
      action = D

    # critical stock levels
    if stock < 0.1 * capacity:
      action = C

    # update stock and payoffs
    consumption = calculate_consumption(action, n)
    stock -= consumption
    payoff += calculate_payoff(stock, n)

    # last round cooperation
    if round == r:
      if stock > 0.5 * capacity:
        action = C

  return total_payoff
```
This strategy balances individual self-interest with collective sustainability, making it a robust and adaptive approach for the Common Pool Resource Game.
'''

description_COLLECTIVE_476 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock Consideration**

Our collective strategy, "Adaptive Tit-for-Tat with Stock Consideration" (ATSC), aims to balance cooperation and self-interest while adapting to the game's dynamic state and opponents' behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and encourage others to do the same.
2. **Subsequent Rounds**: Observe the previous round's actions and payoffs of all players. If the stock level is above 75% of the capacity, play Tit-for-Tat:
	* Cooperate if most players (≥ n/2) cooperated in the previous round.
	* Defect if most players (> n/2) defected in the previous round.
3. **Stock Consideration**: If the stock level falls below 25% of the capacity, cooperate (C) to help replenish the stock and prevent depletion.
4. **Defection Response**: If a player defects while the stock is above 50% of the capacity, respond with defection (D) in the next round to deter exploitation.

**Edge Cases:**

1. **Last Round**: Cooperate (C) in the final round to maximize collective payoffs and encourage cooperation.
2. **Tiebreakers**: In cases where most players' actions are tied between cooperate and defect, cooperate (C) to promote cooperation.

**Collective Mindset:**

ATSC prioritizes cooperation when the stock level is healthy and opponents are cooperative. By responding to defections with defection, we deter exploitation while adapting to changes in the game state. When the stock is low, we prioritize replenishment through cooperation.

**Pseudocode (for illustration purposes):**
```
function ATSC(stock, capacity, n, history):
  if round == 1:
    return C
  else:
    prev_coop_count = count coop actions in previous round
    prev_defect_count = count defect actions in previous round

    if stock > 0.75 * capacity:
      if prev_coop_count >= n/2:
        return C
      elif prev_defect_count > n/2:
        return D
    elif stock < 0.25 * capacity:
      return C
    else:
      # Check for defection response
      if history.defection_response_required():
        return D

      # Tiebreaker: cooperate
      return C

def history.defection_response_required():
  # Implement logic to track opponents' actions and detect exploitation
```
ATSC is a robust, adaptive strategy that balances individual self-interest with collective cooperation. By considering the game's dynamic state and adapting to opponents' behaviors, we aim to achieve a high total payoff in the tournament against independent strategies.
'''

description_COLLECTIVE_477 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation from other players.
2. **Stock Thresholds**: Monitor the current stock level (S) and adjust actions based on two thresholds:
	* **Critical Stock Level (CSL)**: 0.5 * capacity
	* **Warning Stock Level (WSL)**: 0.8 * capacity

If S ≥ WSL, Cooperate (C). This helps maintain a healthy stock level and reduces the risk of depletion.

If CSL ≤ S < WSL, Defect (D) with probability p = (S - CSL) / (WSL - CSL). This introduces a gradual shift towards defection as the stock level approaches the critical threshold.

If S < CSL, Defect (D). In this scenario, cooperation is unlikely to be reciprocated, and defecting helps ensure some payoff in a depleted environment.
3. **Opponent Behavior**: Observe the actions of other players and adjust ASP's behavior accordingly:
	* If most players (> 50%) cooperated in the previous round, Cooperate (C) in the next round to reinforce cooperation.
	* If most players (> 50%) defected in the previous round, Defect (D) in the next round to adapt to the competitive environment.

**Edge Cases:**

1. **Last Round**: In the final round, always Defect (D) as there is no future stock growth or penalty for depletion.
2. **Ties**: In cases where the stock level is exactly at a threshold (e.g., S = WSL), default to Cooperate (C) to maintain a cautious approach.

**Collective Mindset:**

ASP prioritizes collective stock preservation while adapting to changing environmental conditions and opponent behaviors. By balancing cooperation and defection, ASP aims to:

1. Maintain a healthy stock level for long-term sustainability.
2. Encourage cooperation among players when possible.
3. Adapt to competitive environments by defecting when necessary.

**Pseudocode:**
```markdown
Function AdaptiveStockPreservation(n, capacity, r):
  Initialize S = capacity

  For each round t from 1 to r:
    If t == 1:  # Initial Round
      action = Cooperate (C)
    Else:
      If S >= WSL:
        action = Cooperate (C)
      Else If CSL <= S < WSL:
        p = (S - CSL) / (WSL - CSL)
        action = Defect (D) with probability p
      Else:  # S < CSL
        action = Defect (D)

    Observe opponent actions in previous round
    If most players (> 50%) cooperated:
      action = Cooperate (C)
    Else If most players (> 50%) defected:
      action = Defect (D)

    If t == r:  # Last Round
      action = Defect (D)

    Update S based on collective actions and stock dynamics

Return total payoff over all rounds
```
This strategy is designed to be adaptive, robust, and aligned with a collective mindset, making it suitable for a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_478 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability, ensuring a stable and resilient common pool resource over multiple rounds.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to follow suit.
2. **Current Stock Assessment**: Evaluate the current stock level (`S`) relative to the capacity (`capacity`). If `S` is below 50% of `capacity`, defect (D) to maximize individual payoff, as the collective's long-term sustainability is already compromised. Otherwise, proceed to step 3.
3. **Opponent Behavior Analysis**: Observe the actions of other players in previous rounds and calculate their cooperation rate (`CR`). If the average `CR` of opponents is above a threshold (e.g., 0.5), cooperate (C) to reciprocate and maintain a stable collective outcome. Otherwise, defect (D).
4. **Adaptive Threshold Adjustment**: Update the cooperation threshold based on the current stock level and opponent behavior:
	* If `S` is high (>75% of `capacity`) and opponents are cooperating (average `CR` > 0.5), increase the threshold to encourage more cooperation.
	* If `S` is low (<25% of `capacity`) or opponents are defecting (average `CR` < 0.5), decrease the threshold to prioritize individual payoffs.

**Edge Case Handling:**

1. **Last Round**: Defect (D) in the final round, as there is no future payoff to consider and individual gains take precedence.
2. **Low Stock Levels**: If the current stock level (`S`) is critically low (<10% of `capacity`), defect (D) to maximize individual payoff, even if opponents are cooperating.

**Collective Mindset:**

The ASC strategy prioritizes collective sustainability while adapting to changing circumstances and opponent behavior. By reciprocating cooperation and adjusting its threshold based on the current state, ASC promotes a stable and resilient common pool resource.

Pseudocode:
```
function AdaptiveStockConservation(n, r, capacity):
  initialize S = capacity
  for t in range(r):
    if t == 0:  # Initial round
      action = C
    else:
      S_remaining = S - total_consumption(t-1)
      if S_remaining < 0.5 * capacity:  # Current stock assessment
        action = D
      else:
        CR_opponents = calculate_cooperation_rate(opponents, t-1)
        if CR_opponents > threshold:  # Opponent behavior analysis
          action = C
        else:
          action = D
    update_threshold(S_remaining, CR_opponents)  # Adaptive threshold adjustment
    S = min(S_remaining + growth(t), capacity)
  return total_payoff(t)
```
This strategy is designed to be robust and adaptive in the face of diverse opponent behaviors, prioritizing collective sustainability while maximizing individual payoffs.
'''

description_COLLECTIVE_479 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative baseline and encourage others to follow.
2. **Stock-Based Cooperation**: If the current stock level is above 75% of the capacity, cooperate (C). This ensures sustainable harvesting while maintaining a high stock level.
3. **Defection Detection**: Monitor the average payoff difference between cooperators and defectors over the last few rounds (e.g., 3-5 rounds). If this difference is significant (>10%), defect (D) in the next round to penalize defectors and adapt to the changing environment.
4. **Punishment Mechanism**: If a player defects while others cooperate, reduce their payoff by a small amount (e.g., 5%) in the next round. This discourages selfish behavior and promotes cooperation.
5. **Stock Recovery**: When the stock level falls below 25% of the capacity, cooperate (C) to allow the stock to recover.

**Edge Cases:**

* **Last Round**: Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.
* **Low Stock**: If the stock level is critically low (<10%), defect (D) to obtain a minimal payoff rather than risking total depletion.
* **High Defection Rate**: If more than 50% of players defect in a single round, defect (D) in the next round to avoid being exploited.

**Collective Mindset:**

ACH prioritizes cooperation when possible, while adapting to changing circumstances and penalizing selfish behavior. By balancing individual interests with collective sustainability, ACH promotes a stable and resilient ecosystem.

**Pseudocode:**
```python
def adaptive_cooperative_harvesting(stock, capacity, history):
    # Initial round
    if len(history) == 0:
        return 'C'

    # Stock-based cooperation
    if stock > 0.75 * capacity:
        return 'C'

    # Defection detection and punishment mechanism
    avg_payoff_diff = calculate_avg_payoff_diff(history)
    if avg_payoff_diff > 10%:
        return 'D'
    elif detect_defector(history):
        reduce_payoff(history, 5%)
        return 'C'

    # Stock recovery
    if stock < 0.25 * capacity:
        return 'C'

    # Last round
    if len(history) == r - 1:  # r is the total number of rounds
        return 'D'

    # Low stock or high defection rate
    if stock < 10% or detect_high_defection_rate(history):
        return 'D'

    # Default to cooperation
    return 'C'
```
This strategy is designed to be adaptive, robust, and collective, prioritizing cooperation while responding to changing circumstances and penalizing selfish behavior.
'''

description_COLLECTIVE_480 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock Preservation (ATTP)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Subsequent Rounds**:
	* If the stock level is above 50% of capacity, play Tit-for-Tat (TFT): Cooperate if most opponents cooperated in the previous round; Defect otherwise.
	* If the stock level is between 25% and 50% of capacity, play a modified TFT: Cooperate if at least half of the opponents cooperated in the previous round; Defect otherwise.
	* If the stock level is below 25% of capacity, always Defect (D) to maximize individual payoff while preserving the remaining stock for future rounds.
3. **Last Round**: Always Defect (D) in the last round to maximize individual payoff.

**Pseudocode:**
```python
def ATTP(stock, capacity, n, history):
    if round == 1:
        return C  # Initial cooperation

    # Calculate opponent cooperation rate in previous round
    coop_rate = sum(history[-1]['coop']) / n

    if stock > 0.5 * capacity:
        # Tit-for-Tat (TFT)
        return C if coop_rate >= 0.5 else D
    elif 0.25 * capacity <= stock <= 0.5 * capacity:
        # Modified TFT
        return C if coop_rate >= 0.5 else D
    else:  # stock < 0.25 * capacity
        return D

    if round == r:  # Last round
        return D
```
**Rationale:**

1. **Initial cooperation**: Establishes a cooperative tone and gathers information about opponents' behaviors.
2. **Tit-for-Tat (TFT)**: Responds to opponents' actions, promoting cooperation while allowing for adaptation to changing opponent behaviors.
3. **Modified TFT**: When the stock level is low, becomes more cautious by requiring at least half of the opponents to cooperate before cooperating.
4. **Defection in last round**: Maximizes individual payoff when the game is about to end.

**Collective Mindset:**
The ATTP strategy prioritizes cooperation while preserving the common pool resource for future rounds. By adapting to changing opponent behaviors and stock levels, it promotes a collective approach that balances individual interests with the need to maintain a sustainable stock level.
'''

description_COLLECTIVE_481 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

The Adaptive Cooperation strategy aims to balance individual payoffs with collective sustainability by dynamically adjusting cooperation levels based on game state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to follow.
2. **Stock-dependent Cooperation:**
	* If stock ≥ capacity / 2, Cooperate (C) with probability p = (stock - capacity/2) / (capacity/2).
	* If stock < capacity / 2, Defect (D) with probability p = (capacity/2 - stock) / (capacity/2).
3. **History-dependent Adaptation:**
	* Track the average payoff per player over the last τ rounds (e.g., τ = 5).
	* If the average payoff is below a threshold (e.g., capacity / 4n), increase the cooperation probability by Δp (e.g., 0.1) in the next round.
	* If the average payoff is above the threshold, decrease the cooperation probability by Δp in the next round.
4. **Last Round:** Cooperate (C) in the last round to maximize collective payoffs.

**Pseudocode:**
```markdown
Initialize:
  stock = capacity
  history = []
  τ = 5  // number of rounds for average payoff calculation
  Δp = 0.1  // probability adjustment step

For each round t:
  if t == 1:  // initial round
    action = C
  else:
    stock_fraction = stock / capacity
    cooperation_probability = (stock_fraction - 0.5) / 0.5 if stock >= capacity/2 else (0.5 - stock_fraction) / 0.5
    history.append(last_round_payoff)
    average_payoff = mean(history[-τ:])  // calculate average payoff over last τ rounds
    if average_payoff < capacity / (4n):
      cooperation_probability += Δp
    elif average_payoff > capacity / (4n):
      cooperation_probability -= Δp
    action = C with probability cooperation_probability, D otherwise

Update stock:
  ... (apply game dynamics)
```
**Collective Mindset:**

The Adaptive Cooperation strategy is designed to align with a collective mindset by:

1. Cooperating in the initial round to establish a cooperative baseline.
2. Adjusting cooperation levels based on the current state of the common pool, which reflects the collective impact of all players' actions.
3. Using history-dependent adaptation to respond to changes in average payoffs, promoting a balance between individual and collective interests.

This strategy should perform well against independent strategies developed by other AI systems, as it:

1. Adapts to various opponent behaviors through its dynamic cooperation levels.
2. Balances individual payoffs with collective sustainability by considering the state of the common pool.
3. Does not rely on specific coordination mechanisms or shared norms.
'''

description_COLLECTIVE_482 = '''
**Collective Strategy: Adaptive Tit-for-Two-Tats with Stock Conservation**

Our collective strategy aims to balance individual payoffs with collective sustainability of the common pool resource. We'll use a hybrid approach that adapts to the game state and history.

**Decision Rules:**

1. **Initial Cooperation**: In the first round, cooperate (C) unconditionally to establish a baseline for cooperation.
2. **Tit-for-Two-Tats**: For rounds 2 to r-1:
	* If at least two opponents defected in the previous round, defect (D) in the current round.
	* Otherwise, cooperate (C).
3. **Stock Conservation**: Monitor the stock level and adjust behavior accordingly:
	* If the stock level falls below capacity/2, switch to cooperation (C) regardless of opponent actions.
4. **Final Round Cooperation**: In the last round (r), cooperate (C) unconditionally to avoid over-exploitation.

**Edge Cases:**

1. **First Round**: Cooperate (C) as described above.
2. **Last Round**: Cooperate (C) to ensure sustainability.
3. **Opponent Defection**: If an opponent defects, our Tit-for-Two-Tats rule will respond with a defection in the next round.

**Collective Mindset:**

Our strategy prioritizes collective sustainability while adapting to individual self-interest. By cooperating initially and responding to opponents' actions, we create an environment that encourages cooperation. The stock conservation mechanism ensures that we avoid over-exploitation and protect the common pool resource.

Pseudocode:
```python
def AdaptiveTitForTwoTats(n, capacity, r):
    # Initialize variables
    stock = capacity
    previous_round_actions = []
    
    for round in range(1, r+1):
        if round == 1:  # Initial Cooperation
            action = 'C'
        else:
            num_defectors = sum([1 if action == 'D' else 0 for action in previous_round_actions])
            if num_defectors >= 2 or stock < capacity / 2:  # Tit-for-Two-Tats & Stock Conservation
                action = 'D'
            else:
                action = 'C'
        
        # Update stock level and store actions for next round
        stock -= get_consumption(action, n)
        previous_round_actions.append(action)
    
    return action
```
This strategy is designed to be robust against various opponent behaviors while promoting collective sustainability. By adapting to the game state and history, we aim to achieve a balance between individual payoffs and long-term resource conservation.
'''

description_COLLECTIVE_483 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. This approach prioritizes cooperation when the stock is healthy and gradually shifts towards defection as the stock depletes.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative baseline and encourage others to follow suit.
2. **Stock-based Cooperation:** If the current stock level (`stock`) is above a threshold (`threshold`), cooperate (C). The `threshold` is calculated as:
```
threshold = capacity / (n + 1)
```
This ensures that when the stock is relatively high, players prioritize cooperation to maintain sustainability.
3. **Defection under Depletion:** If the current stock level falls below the `threshold`, defect (D) with a probability (`p_defect`) that increases as the stock depletes:
```
p_defect = 1 - (stock / capacity)
```
This allows players to adapt to declining stock levels by gradually increasing their defection rate.
4. **History-based Adjustment:** After each round, update the `threshold` based on the previous round's actions and outcomes:
```
if all players cooperated in the previous round:
  threshold *= 0.9
elif any player defected in the previous round:
  threshold *= 1.1
```
This adjustment mechanism encourages cooperation by reducing the threshold when all players cooperate, making it more likely for them to continue cooperating. Conversely, if any player defects, the threshold increases, making it more challenging for players to cooperate.

**Edge Cases:**

* **Last Round:** In the final round (`r == 1`), defect (D) unconditionally, as there is no future stock to conserve.
* **Tie-breaking:** In cases where the decision rule results in a tie (e.g., `p_defect` equals 0.5), cooperate (C) by default.

**Collective Mindset:**

The ASC strategy prioritizes collective sustainability while allowing for individual adaptation to changing circumstances. By cooperating when the stock is healthy and defecting when it depletes, players can maintain a balance between short-term gains and long-term resource conservation. This approach promotes a cooperative atmosphere while being robust to a wide range of opponent behaviors.

**Pseudocode:**
```
function ASC(n, r, capacity, stock, history) {
  threshold = capacity / (n + 1)
  
  if round == 1:
    return C
  elif stock >= threshold:
    return C
  else:
    p_defect = 1 - (stock / capacity)
    return D with probability p_defect
  
  # Update threshold based on previous round's actions and outcomes
  if all players cooperated in the previous round:
    threshold *= 0.9
  elif any player defected in the previous round:
    threshold *= 1.1
  
  # Edge cases
  if r == 1:  # Last round
    return D
  elif p_defect == 0.5:  # Tie-breaking
    return C
}
```
'''

description_COLLECTIVE_484 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability, adapting to the game's dynamic state and opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative baseline and encourage others to follow.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, cooperate (C) to maintain a healthy stock and promote collective sustainability.
	* If the stock level is between 25% and 75% of capacity, defect (D) with a probability proportional to the number of players who defected in the previous round. This adaptive response aims to balance individual payoffs with collective conservation.
	* If the stock level is below 25% of capacity, cooperate (C) to prevent further depletion and allow the stock to recover.
3. **Last Round (t=r):** Defect (D), as there are no future consequences for over-harvesting.

**Edge Cases:**

1. **Low Stock Levels:** If the stock level is critically low (<10% of capacity), cooperate (C) unconditionally to prevent depletion and allow recovery.
2. **Opponent Behavior:** Monitor opponent actions and adjust the ASC strategy accordingly:
	* If a player consistently defects, consider them an "exploiter" and respond by defecting with increased probability.
	* If a player consistently cooperates, consider them a "cooperator" and reciprocate cooperation to maintain mutual benefits.

**Collective Mindset:**

ASC prioritizes collective sustainability while allowing for individual adaptability. By cooperating when the stock is healthy and adapting to opponent behaviors, ASC promotes a balanced approach that can be followed by multiple players, leading to more sustainable outcomes.

Pseudocode (for illustrative purposes):
```python
def ASC(n, capacity, stock, history):
    if t == 1:  # Initial round
        return C
    elif stock > 0.75 * capacity:
        return C
    elif stock >= 0.25 * capacity and stock <= 0.75 * capacity:
        defect_prob = (num_defectors_prev_round / n)
        return D if random.random() < defect_prob else C
    elif stock < 0.25 * capacity:
        return C
    elif t == r:  # Last round
        return D

def update_history(history, actions):
    history.append(actions)

# Main game loop
for t in range(1, r+1):
    stock = get_current_stock()
    actions = [ASC(n, capacity, stock, history) for _ in range(n)]
    update_history(history, actions)
    # Update stock and proceed to next round
```
This strategy is designed to be robust against a wide range of opponent behaviors while promoting collective sustainability. By adapting to the game's dynamic state and opponent actions, ASC can effectively balance individual payoffs with long-term conservation goals.
'''

description_COLLECTIVE_485 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Aware Tit-for-Tat**

This strategy balances individual payoff maximization with collective sustainability by adapting to the current stock level and opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' initial actions.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of the capacity, cooperate (C). This ensures that the collective resource remains sustainable while allowing for moderate consumption.
	* If the current stock level is between 25% and 75% of the capacity, mirror the opponent's previous action (Tit-for-Tat). If an opponent defected in the previous round, defect in this round; otherwise, cooperate. This approach encourages reciprocity and punishes defection while being cautious about over-consumption.
	* If the current stock level is below 25% of the capacity, always cooperate (C) to prevent depletion and allow for recovery.
3. **Last Round:** Cooperate (C) in the final round, regardless of the stock level or opponent actions. This ensures that the game ends on a cooperative note, even if opponents have defected previously.

**Edge Cases:**

* If an opponent has consistently cooperated throughout the game, and the current stock level is above 75% of the capacity, consider increasing cooperation to reinforce mutual sustainability.
* In cases where multiple opponents defect simultaneously, prioritize individual payoff maximization by defecting as well. However, return to cooperative behavior once the stock level recovers.

**Collective Mindset:**

This strategy prioritizes collective sustainability while being responsive to opponent behaviors. By adapting to the current stock level and mirroring opponent actions, it encourages cooperation and reciprocity while avoiding exploitation. In edge cases, it balances individual interests with collective well-being to ensure a mutually beneficial outcome.

Pseudocode:
```python
def adaptive_cooperation(stock_level, capacity, previous_opponent_actions):
    if first_round():
        return COOPERATE
    elif stock_level >= 0.75 * capacity:
        return COOPERATE
    elif stock_level >= 0.25 * capacity and stock_level < 0.75 * capacity:
        opponent_action = get_previous_opponent_action()
        if opponent_action == DEFECT:
            return DEFECT
        else:
            return COOPERATE
    elif stock_level < 0.25 * capacity:
        return COOPERATE
    elif last_round():
        return COOPERATE

def get_previous_opponent_action(opponent_actions):
    # Return the previous action of a randomly selected opponent
    pass
```
This strategy is designed to be robust and adaptive, allowing it to perform well in a wide range of scenarios against diverse opponent behaviors.
'''

description_COLLECTIVE_486 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy balances individual payoffs with collective sustainability, adapting to the game's dynamic state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level.
2. **Subsequent Rounds:** Observe the previous round's:
	* Total consumption (TC)
	* Stock growth (SG)
	* New stock level (NSL)

Calculate the **Stock Conservation Index (SCI)**:

SCI = (NSL - TC) / capacity

If SCI ≥ 0.5, Cooperate (C). Otherwise, Defect (D).

**Edge Cases:**

1. **Last Round:** If it's the last round (r = R), always Defect (D) to maximize individual payoff.
2. **Low Stock Levels:** If NSL ≤ n (i.e., critical stock level), Cooperate (C) to ensure some growth and avoid depletion.
3. **High Stock Levels:** If NSL ≥ 1.5 × capacity, Defect (D) to capitalize on the abundant resource.

**Pseudocode:**
```markdown
# Initialize variables
stock_level = capacity
total_consumption = 0
round_number = 1

while round_number <= R:
    # Determine action based on SCI
    if round_number == 1 or (SCI >= 0.5 and stock_level > n):
        action = COOPERATE
    elif stock_level <= n or round_number == R:
        action = DEFECT
    else:
        action = DEFECT

    # Calculate payoff and update state
    payoff = calculate_payoff(stock_level, action)
    total_consumption += consumption[action]
    stock_level -= total_consumption
    stock_growth = calculate_stock_growth(stock_level)
    new_stock_level = min(stock_level + stock_growth, capacity)

    # Update SCI for next round
    SCI = (new_stock_level - total_consumption) / capacity

    round_number += 1
```
**Collective Mindset:**

The ASC strategy prioritizes cooperation when the stock level is sufficient to ensure growth and sustainability. By defecting only when necessary, it balances individual interests with collective well-being. This adaptive approach encourages others to cooperate, as they can observe the benefits of conservation through the game's state.

In a tournament setting, ASC will likely perform well against independent strategies that focus solely on individual gains or naive cooperation, as it effectively navigates the trade-offs between short-term payoffs and long-term sustainability.
'''

description_COLLECTIVE_487 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Sensitive Threshold (ACST)**

ACST is a collective strategy that balances individual payoffs with long-term sustainability of the common pool resource. It adapts to changing stock levels and opponent behaviors while promoting cooperation.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Stock-Sensitive Threshold**: Define a threshold stock level, `T`, as a fraction of the capacity, e.g., `T = 0.7 * capacity`. This threshold determines when to switch from cooperation to defection or vice versa.
3. **Cooperation Zone**: If the current stock level is above `T` (i.e., `stock >= T`), cooperate (C). This encourages sustainable consumption and growth of the common pool resource.
4. **Defection Zone**: If the current stock level is below `T` (i.e., `stock < T`), defect (D) with a probability `p`. The value of `p` depends on the number of opponents, `n`, and the round number, `t`.

**Adaptive Defection Probability**

Calculate `p` as follows:

* In early rounds (`t <= r/2`), set `p = 0.5 / n`. This initial defection probability decreases as the number of opponents increases.
* In later rounds (`t > r/2`), adjust `p` based on the average payoff difference between cooperation and defection in previous rounds:
	+ If the average payoff difference is positive (i.e., cooperation yields higher payoffs), decrease `p` by 10% each round.
	+ If the average payoff difference is negative (i.e., defection yields higher payoffs), increase `p` by 10% each round.

**Last Round**: In the final round, defect (D) to maximize individual payoff, as there are no future rounds to consider.

**Handling Edge Cases**

* **Low Stock Levels**: If the stock level falls below a minimum threshold (e.g., `0.1 * capacity`), cooperate (C) to help replenish the common pool resource.
* **Opponent Behavior**: Monitor opponents' actions and adjust the defection probability, `p`, accordingly. If most opponents cooperate, decrease `p`. If most opponents defect, increase `p`.

**Pseudocode**

```python
def ACST(n, r, capacity, stock, t):
    T = 0.7 * capacity
    if t == 1:  # Initial round
        return C
    elif stock >= T:
        return C
    else:
        p = adaptive_defection_probability(n, r, t)
        return D with probability p

def adaptive_defection_probability(n, r, t):
    if t <= r/2:
        return 0.5 / n
    else:
        avg_payoff_diff = calculate_average_payoff_difference(t-1)
        if avg_payoff_diff > 0:
            return max(0, p - 0.1)  # Decrease p by 10%
        elif avg_payoff_diff < 0:
            return min(1, p + 0.1)  # Increase p by 10%

def calculate_average_payoff_difference(t):
    # Calculate the average payoff difference between cooperation and defection
    # in previous rounds using historical data.
    pass
```

ACST balances individual payoffs with collective sustainability, adapting to changing stock levels and opponent behaviors while promoting cooperation. By adjusting the defection probability based on the game's history and state, ACST remains robust against a wide range of opponent strategies.
'''

description_COLLECTIVE_488 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability of the common pool resource. It adapts to changing game conditions and opponent behaviors while promoting cooperation when beneficial.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and observe opponents' initial actions.
2. **Stock-based Cooperation Threshold**: Introduce a dynamic cooperation threshold, `θ`, based on the current stock level (`S`). Cooperate if `S` is above `θ`, otherwise Defect.
3. **Opponent Behavior Adaptation**: Monitor opponent actions and adjust `θ` accordingly:
	* If most opponents (≥ `n/2`) cooperate in a round, decrease `θ` by 5% to encourage further cooperation.
	* If most opponents defect (≥ `n/2`), increase `θ` by 10% to deter over-exploitation.
4. **Defection Prevention**: If the current stock level is critically low (`S < capacity / 4`), Defect to prevent complete resource depletion.

**Edge Cases:**

1. **Last Round**: Cooperate in the final round, as there's no future benefit from defecting and cooperation may encourage opponents to do the same.
2. **Low Stock**: If `S` is very low (`S < capacity / 10`) and there are few rounds remaining (`r - t ≤ 3`), Defect to maximize individual payoff in the short term.

**Pseudocode:**
```markdown
# ASC Strategy Pseudocode

# Initialize variables
θ = 0.5 * capacity (cooperation threshold)
S_prev = capacity (previous stock level)

# Main loop
for t = 1 to r:
    # Observe current stock and opponent actions
    S = current_stock_level()
    opponent_actions = observe_opponent_actions()

    # Update θ based on opponent behavior
    if most_opponents_cooperate(opponent_actions):
        θ -= 0.05 * capacity
    elif most_opponents_defect(opponent_actions):
        θ += 0.10 * capacity

    # Determine action based on stock level and θ
    if S > θ:
        action = C (Cooperate)
    else:
        action = D (Defect)

    # Special cases
    if t == r:  # Last round
        action = C
    elif S < capacity / 10 and r - t ≤ 3:  # Low stock, few rounds left
        action = D

    # Take action and update state
    take_action(action)
    S_prev = S
```
The ASC strategy balances individual self-interest with collective responsibility to conserve the common pool resource. By adapting to changing game conditions and opponent behaviors, it promotes cooperation when beneficial while preventing over-exploitation.
'''

description_COLLECTIVE_489 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC is a robust and adaptive collective strategy that balances individual payoffs with long-term stock conservation. It relies on observing the game's state and history to inform cooperation decisions.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoff.
2. **Early Rounds**: If the current stock level is above 75% of capacity, cooperate (C). This allows for moderate consumption while maintaining a healthy stock level.
3. **Mid-Game Adjustment**: After the first half of the rounds (r/2), reevaluate the strategy based on the average stock depletion rate over the past rounds. If the rate exceeds 25% per round, switch to defecting (D) in the next round to prevent over-exploitation.
4. **Late Rounds**: In the last quarter of the rounds (r/4), cooperate (C) if the current stock level is above 50% of capacity. This helps conserve the remaining stock and maintain a reasonable payoff.
5. **Emergency Response**: If the current stock level falls below 25% of capacity, defect (D) to maximize individual payoff in case of an impending stock collapse.

**Pseudocode:**
```
function ASC(n, r, capacity, stock_history):
  // Initialize variables
  stock_depletion_rate = 0
  mid_game_adjustment = False

  for t in range(r):
    if t == 0:
      action = C  // Cooperate in the first round
    elif stock_level > 0.75 * capacity:
      action = C  // Cooperate when stock is high
    elif mid_game_adjustment and stock_depletion_rate > 0.25:
      action = D  // Defect if depletion rate is too high
    elif t >= r/2 and not mid_game_adjustment:
      stock_depletion_rate = calculate_stock_depletion_rate(stock_history)
      if stock_depletion_rate > 0.25:
        mid_game_adjustment = True
        action = D  // Adjust strategy based on depletion rate
    elif t >= 3*r/4 and stock_level > 0.5 * capacity:
      action = C  // Cooperate in late rounds when stock is sufficient
    else:
      action = D  // Defect otherwise

    if stock_level < 0.25 * capacity:
      action = D  // Emergency response: defect if stock is critically low

    return action
```
**Collective Mindset:**

ASC prioritizes the collective well-being by:

1. Encouraging cooperation when the stock level is high to maintain a healthy resource.
2. Adjusting strategy based on observed depletion rates to prevent over-exploitation.
3. Balancing individual payoffs with long-term conservation goals.

By adapting to the game's state and history, ASC aims to promote sustainable resource management while remaining competitive in a tournament setting.
'''

description_COLLECTIVE_490 = '''
**Collective Strategy: "Adaptive Stock Saver" (ASS)**

The Adaptive Stock Saver strategy aims to balance individual payoffs with collective sustainability by adapting to the game's dynamic state and opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if stock >= capacity * 0.75
	* Defect (D) otherwise
2. **Middle Rounds (1 < t < r-1):**
	* If the average opponent cooperation rate in the previous round is > 0.5:
		+ Cooperate (C) if stock >= capacity * 0.67
		+ Defect (D) otherwise
	* Otherwise, defect (D)
3. **Last Round (t=r):**
	* Defect (D)

**Pseudocode:**
```python
def adaptive_stock_saver(stock, capacity, n, r, history):
    # Initial round
    if t == 1:
        return C if stock >= 0.75 * capacity else D
    
    # Middle rounds
    avg_opponent_coop_rate = calculate_avg_opponent_coop_rate(history)
    if avg_opponent_coop_rate > 0.5:
        return C if stock >= 0.67 * capacity else D
    else:
        return D
    
    # Last round
    return D

def calculate_avg_opponent_coop_rate(history):
    coop_count = sum(1 for action in history[-1] if action == C)
    return coop_count / (n - 1)  # exclude self
```
**Rationale:**

* In the initial round, ASS conservatively cooperates only when the stock is high enough to ensure a moderate payoff.
* In middle rounds, ASS adapts to opponent behavior:
	+ If most opponents cooperate, ASS becomes more cooperative (C) to maintain a sustainable stock level and higher payoffs.
	+ Otherwise, ASS defects (D) to maximize individual payoff in the short term.
* In the last round, ASS defects (D) since there's no future benefit to cooperation.

**Collective Mindset:**

ASS prioritizes long-term sustainability by:

1. Encouraging cooperation when opponents are cooperative
2. Adapting to changing opponent behaviors
3. Balancing individual payoffs with collective stock conservation

By following this adaptive strategy, ASS aims to achieve a high total payoff while maintaining a healthy common pool resource.

**Robustness:**

ASS is robust against various opponent strategies since it:

1. Responds to the overall cooperation rate of opponents
2. Adapts to changing game dynamics (stock levels and opponent behaviors)
3. Does not rely on specific coordination mechanisms or norms
'''

description_COLLECTIVE_491 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability, ensuring the common pool resource remains viable throughout the game.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Subsequent Rounds:** Calculate the current stock level's "health" as `stock_health = (current_stock / capacity)`. If `stock_health` is:
	* ≥ 0.8, Defect (D): The stock is relatively abundant, allowing for temporary exploitation without jeopardizing long-term sustainability.
	* < 0.8 and ≥ 0.4, Cooperate (C): The stock is moderately depleted; cooperate to conserve it while still earning a reasonable payoff.
	* < 0.4, Defect (D) with probability `1 - (stock_health / 0.4)`: As the stock dwindles, gradually shift towards defection to maximize individual payoffs before the resource is exhausted.
3. **Last Round:** Cooperate (C) in the final round to ensure a non-zero payoff and prevent unnecessary over-exploitation.

**Additional Logic:**

* Monitor opponents' actions and adjust ASC's behavior accordingly:
	+ If most opponents (~ ≥ 60%) cooperated in the previous round, increase the `stock_health` threshold for cooperation by 10% (e.g., from 0.8 to 0.88).
	+ If most opponents (~ ≥ 60%) defected in the previous round, decrease the `stock_health` threshold for cooperation by 10% (e.g., from 0.8 to 0.72).
* In cases of extreme stock depletion (< 20% capacity), defect with a high probability (> 80%) to maximize individual payoffs.

**Pseudocode:**
```python
def ASC(current_stock, capacity, round_number, opponents_actions):
    # Initial Round
    if round_number == 1:
        return 'C'

    stock_health = current_stock / capacity

    # Subsequent Rounds
    if stock_health >= 0.8:
        return 'D'
    elif stock_health < 0.4:
        defect_prob = 1 - (stock_health / 0.4)
        return 'D' with probability defect_prob, else 'C'
    else:  # stock_health between 0.4 and 0.8
        if most_opponents_cooperated(opponents_actions):
            stock_health_threshold += 0.10
        elif most_opponents_defected(opponents_actions):
            stock_health_threshold -= 0.10

        return 'C' if stock_health >= stock_health_threshold else 'D'

    # Last Round
    if round_number == total_rounds:
        return 'C'
```
**Rationale:**

ASC balances individual payoffs with collective sustainability by adapting to the current stock level and opponents' actions. By cooperating when the stock is abundant or moderately depleted, ASC encourages cooperation and helps maintain a healthy resource. As the stock dwindles, ASC gradually shifts towards defection to maximize individual payoffs while still considering the long-term consequences of over-exploitation.

By monitoring opponents' actions, ASC can adjust its behavior to respond to cooperative or exploitative strategies, promoting a more sustainable and mutually beneficial outcome.
'''

description_COLLECTIVE_492 = '''
I'll design a collective strategy that balances individual payoffs with the sustainability of the common pool resource. This strategy, called "Adaptive Cooperative Threshold" (ACT), is based on the game parameters, state, and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for the game's dynamics.
2. **Subsequent Rounds**: Use a dynamic threshold to decide between C and D based on the stock level and opponent behavior.
3. **Stock-based Threshold**: Calculate a "safety threshold" as a fraction of the capacity: `safety_threshold = 0.5 * capacity / n`. If the current stock is above this threshold, cooperate (C). Otherwise, defect (D).
4. **Adaptive Component**: Monitor the opponent behavior and adjust the safety threshold accordingly.
	* If most opponents (more than half) cooperated in the previous round, decrease the safety threshold by a small margin (`-0.05 * capacity / n`) to encourage cooperation.
	* If most opponents defected, increase the safety threshold by a larger margin (`+0.1 * capacity / n`) to protect the stock.

Pseudocode:
```
function ACT(stock, capacity, n, history):
  // Initial Round
  if round == 1:
    return C

  // Stock-based Threshold
  safety_threshold = 0.5 * capacity / n
  if stock >= safety_threshold:
    return C

  // Adaptive Component
  opponent_cooperation_rate = calculate_opponent_cooperation_rate(history)
  if opponent_cooperation_rate > 0.5:
    safety_threshold -= 0.05 * capacity / n
  else:
    safety_threshold += 0.1 * capacity / n

  if stock >= safety_threshold:
    return C
  else:
    return D
```
**Handling Edge Cases:**

* **Last Round**: Cooperate (C) in the last round to ensure a fair distribution of the remaining stock.
* **Low Stock Levels**: If the stock level falls below `0.1 * capacity`, defect (D) to maximize individual payoff, as the game's sustainability is already compromised.

**Collective Mindset:**

The ACT strategy prioritizes cooperation when the stock level is sufficient and opponents are cooperative. By adapting to opponent behavior, it encourages a collective effort to maintain a sustainable stock level while allowing for some flexibility in response to changing conditions.

This strategy balances individual payoffs with the long-term sustainability of the common pool resource, making it robust to a wide range of opponent behaviors.
'''

description_COLLECTIVE_493 = '''
I propose a collective strategy called "Adaptive Stock Conservation" (ASC). ASC aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** In the first round, play C (Cooperate) if `stock >= capacity / 2`, otherwise play D (Defect).
2. **Subsequent Rounds:** Observe the previous round's actions and payoffs. If the average payoff per player in the previous round was greater than or equal to the average payoff of playing C (`stock / (2n)`), play C. Otherwise, play D.
3. **Stock Thresholds:** Monitor the stock level. If `stock <= capacity / 4`, switch to always playing C for the remaining rounds.

**Edge Cases:**

1. **Last Round:** In the final round, play D if `stock >= capacity / 2` and there are no other players that can be trusted to conserve stock (i.e., all other players have defected in previous rounds). Otherwise, play C.
2. **Tie-Breaking:** If the average payoff per player in the previous round is exactly equal to the average payoff of playing C, break ties by playing C.

**Collective Mindset:**

ASC promotes collective sustainability by conserving stock when it's above a certain threshold and cooperating with other players who demonstrate similar behavior. By adapting to the game's state and history, ASC aims to create an environment where cooperation is beneficial for all players.

**Pseudocode (simplified):**
```python
def adaptive_stock_conservation(n, capacity, stock, round_num, prev_round_payoffs):
    if round_num == 1:
        if stock >= capacity / 2:
            return C
        else:
            return D

    avg_prev_payoff = sum(prev_round_payoffs) / n
    avg_c_payoff = stock / (2 * n)

    if avg_prev_payoff >= avg_c_payoff:
        return C
    elif stock <= capacity / 4:
        return C
    else:
        return D

def last_round_behavior(n, capacity, stock):
    # TO DO: implement logic to determine trust in other players
    # For now, assume no trusted players and play D if stock is high enough
    if stock >= capacity / 2:
        return D
    else:
        return C
```
Note that this pseudocode is a simplified representation of the decision rules. The actual implementation will require more details, such as tracking previous round payoffs and player actions.

By implementing ASC, our collective strategy aims to promote cooperation and sustainability in the Common Pool Resource Game while adapting to various opponent behaviors.
'''

description_COLLECTIVE_494 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' behavior.
2. **Subsequent Rounds**: Calculate the current stock level (S) and total consumption from previous rounds.
3. **Cooperation Threshold**: If S > 0.5 \* capacity, cooperate (C). This ensures that when the stock is relatively high, players prioritize conservation.
4. **Defection Threshold**: If S ≤ 0.2 \* capacity, defect (D). When the stock is low, players prioritize individual gain to avoid being left with nothing.
5. **Adaptive Window**: For 0.2 \* capacity < S ≤ 0.5 \* capacity, use an adaptive window approach:
	* Calculate the average payoff per player in the previous round (π_avg).
	* If π_avg > stock/(2n), cooperate (C). This indicates that cooperation was successful, and players should continue to conserve.
	* Otherwise, defect (D).

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round to maximize individual gain, as there is no future benefit to conserving the stock.
2. **Low Stock**: If S ≤ 0, cooperate (C) to allow for potential growth and avoid depletion.

**Collective Mindset Alignment:**

The Adaptive Stock Conservation strategy aligns with a collective mindset by:

1. Prioritizing cooperation when the stock is relatively high to ensure long-term sustainability.
2. Allowing for defection when the stock is low, but not exploiting others excessively.
3. Adapting to opponents' behavior through the adaptive window approach.

Pseudocode (for illustration purposes only):
```
function ASC(n, capacity, r, S_history)
  // Initialize variables
  S = capacity
  π_avg = 0

  for t = 1 to r do
    if t == 1 then
      action[t] = C
    else
      S = calculate_stock(S, S_history)
      if S > 0.5 * capacity then
        action[t] = C
      elseif S <= 0.2 * capacity then
        action[t] = D
      else
        π_avg = calculate_average_payoff(π_avg, S_history)
        if π_avg > stock/(2n) then
          action[t] = C
        else
          action[t] = D
      end if

    // Update history and payoffs
    S_history.append(S)
    update_payoffs(action[t], S)

  return action[]
```
This strategy is designed to balance individual gain with collective conservation, adapting to the game state and opponents' behavior.
'''

description_COLLECTIVE_495 = '''
**Collective Strategy: Adaptive Cooperative Conservation (ACC)**

The ACC strategy balances individual self-interest with collective conservation of the common pool resource. It adapts to the game state and history, making it robust against various opponent behaviors.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for the collective's behavior.
2. **Cooperation Threshold**: Set a cooperation threshold `T` based on the current stock level `S`. If `S` is above 50% of capacity, set `T = 0.5n`, where `n` is the number of players. Otherwise, set `T = n - (S / (2 \* capacity))`.
3. **Action Selection**: In each round, select an action based on the cooperation threshold:
	* If the number of cooperators in the previous round is above or equal to `T`, Cooperate (C).
	* Otherwise, Defect (D) with a probability `P_D = 1 - (S / capacity)`; Cooperate (C) with probability `1 - P_D`.
4. **Reaction to Over-Exploitation**: If the stock level falls below 25% of capacity, always Defect (D) in the next round.
5. **Reaction to Full Stock Recovery**: If the stock level reaches or exceeds capacity, Cooperate (C) with a higher probability `P_C = 0.8` for the next three rounds.

**Edge Cases**

* **Last Round**: In the final round, always Defect (D).
* **Early Stock Depletion**: If the stock level falls below 10% of capacity before the last round, Cooperate (C) in all remaining rounds.
* **Multiple Players with Same Payoff History**: Break ties by choosing the action that maximizes the collective payoff.

**Collective Mindset**

The ACC strategy is designed to balance individual self-interest with collective conservation. By adapting to the game state and history, it promotes cooperation while allowing for occasional defection to maintain a healthy stock level.

Pseudocode:
```python
def ACC(n, capacity, r):
    T = 0.5 * n if S > 0.5 * capacity else n - (S / (2 * capacity))
    P_D = 1 - (S / capacity)
    history = []

    for t in range(r):
        if t == 0:
            action = C
        elif len(history) >= T:
            action = C
        else:
            action = D if random.random() < P_D else C

        # Update stock and history
        S -= total_consumption()
        growth = 2 * S_remaining * (1 - S_remaining / capacity)
        new_stock = min(S + growth, capacity)

        if new_stock < 0.25 * capacity:
            action_next = D
        elif new_stock >= capacity:
            P_C = 0.8

        history.append(action)

    return total_payoff()
```
This strategy aims to strike a balance between individual self-interest and collective conservation of the common pool resource, making it robust against various opponent behaviors in a tournament setting.
'''

description_COLLECTIVE_496 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

The AC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative baseline.
2. **Subsequent Rounds**: Calculate the current stock depletion rate (`dr`) as `(capacity - stock) / capacity`.
3. **Cooperate** if `dr` is below a threshold (`θ`), which decreases over time:
	* Round 1-5: θ = 0.4
	* Round 6-10: θ = 0.35
	* Round 11+: θ = 0.3
4. **Defect** if `dr` exceeds the threshold (`θ`) or if the opponent's previous-round actions indicate a high likelihood of defecting.
5. **History-based Adjustment**: Monitor opponents' actions and adjust the cooperation rate based on their past behavior:
	* If an opponent has defected in > 50% of the last 5 rounds, decrease the cooperation rate by 10%.
	* If an opponent has cooperated in > 80% of the last 5 rounds, increase the cooperation rate by 10%.

**Edge Cases:**

1. **Last Round**: Defect (D) to maximize individual payoff, as there is no future stock to conserve.
2. **Low Stock Levels**: If `stock` falls below `capacity / 4`, defect (D) to ensure a minimum individual payoff.

**Pseudocode:**
```
function AdaptiveCooperation(stock, capacity, round, opponentHistory):
  if round == 1:
    return COOPERATE
  dr = (capacity - stock) / capacity
  theta = getThreshold(round)
  if dr < theta:
    return COOPERATE
  elif isOpponentLikelyToDefect(opponentHistory):
    return DEFECT
  else:
    # adjust cooperation rate based on opponent history
    coopRate = getCooperationRate(opponentHistory)
    return COOPERATE with probability coopRate

function getThreshold(round):
  if round <= 5:
    return 0.4
  elif round <= 10:
    return 0.35
  else:
    return 0.3

function isOpponentLikelyToDefect(opponentHistory):
  # calculate the opponent's defect rate in last 5 rounds
  defectRate = count(defections) / 5
  return defectRate > 0.5

function getCooperationRate(opponentHistory):
  # adjust cooperation rate based on opponent's past behavior
  coopRate = 0.5
  if opponentHasCooperatedInLast5Rounds(opponentHistory):
    coopRate += 0.1
  elif opponentHasDefectedInLast5Rounds(opponentHistory):
    coopRate -= 0.1
  return coopRate
```
The Adaptive Cooperation strategy balances individual payoffs with collective sustainability by adapting to the game's state and history. By cooperating when the stock depletion rate is below a threshold and adjusting cooperation rates based on opponent behavior, AC aims to promote a stable and mutually beneficial outcome.
'''

description_COLLECTIVE_497 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Overview:**
ACC balances individual payoffs with collective conservation of the common pool resource. It uses a dynamic threshold to decide when to cooperate or defect, based on the current stock level, number of players, and previous rounds' outcomes.

**Decision Rules:**

1. **First Round:** Cooperate (C) to establish a baseline for cooperation and observe others' behaviors.
2. **Subsequent Rounds:**
	* Calculate the **stock threshold**: `threshold = capacity / (2 * n)`
	* If the current stock level is above the threshold, Cooperate (C).
	* If the current stock level is below the threshold, Defect (D) with a probability proportional to the number of players who defected in the previous round.
3. **Last Round:** Defect (D), as there's no future benefit from conserving the resource.

**Pseudocode:**
```python
def ACC(n, capacity, stock_history, previous_round_actions):
    if len(stock_history) == 0:  # First round
        return 'C'
    
    threshold = capacity / (2 * n)
    current_stock = stock_history[-1]
    
    if current_stock >= threshold:
        return 'C'
    
    prev_defectors = sum(1 for action in previous_round_actions if action == 'D')
    defect_prob = prev_defectors / n
    
    if random.random() < defect_prob:
        return 'D'
    else:
        return 'C'
```
**Edge Cases:**

* If all players but one cooperate, and the lone defector has a significant impact on the stock level, ACC will adapt by increasing its defect probability in subsequent rounds.
* If multiple players use ACC or similar strategies, they will collectively conserve the resource, as their thresholds will converge.

**Collective Mindset:**
ACC prioritizes cooperation when the common pool is above a certain threshold, ensuring the resource remains sustainable. By adapting to others' behaviors and adjusting its defect probability, ACC promotes collective conservation while allowing for individual gains.

This strategy should perform well in a tournament setting, as it balances individual payoffs with collective conservation of the resource, making it robust against various opponent behaviors.
'''

description_COLLECTIVE_498 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Overview**

The ACH strategy aims to balance individual payoffs with collective sustainability by adapting to the game's dynamic state and opponent behaviors. It uses a combination of cooperation and defection, informed by the current stock level, round number, and observed opponent actions.

**Decision Rules**

1. **Initial Round (t=1)**: Cooperate (C) to initiate a cooperative tone and gather information about opponents' behaviors.
2. **Stock-dependent Cooperation**: If the current stock level is above 75% of the capacity, cooperate (C). This helps maintain a sustainable stock level and encourages cooperation among players.
3. **Opponent Behavior-based Defection**: If an opponent has defected (D) in the previous round, defect (D) in the current round with a probability p = 0.5. This response aims to deter opponents from exploiting cooperative behavior.
4. **Round-dependent Cooperation**: In the last 25% of rounds (i.e., t > 0.75r), cooperate (C) regardless of the stock level or opponent behaviors. This ensures that players contribute to replenishing the stock for future generations.
5. **Default Action**: If none of the above conditions are met, defect (D).

**Edge Case Handling**

* **First Round**: Cooperate (C) as described in Rule 1.
* **Last Round**: Cooperate (C) regardless of the stock level or opponent behaviors to ensure a sustainable ending.
* **Ties**: In case of ties (e.g., two opponents defecting), the strategy defaults to defection (D).

**Pseudocode**
```python
def ACH(n, r, capacity, current_stock, round_number, opponent_actions):
    if round_number == 1:
        return "C"  # Initial cooperation

    if current_stock >= 0.75 * capacity:
        return "C"  # Stock-dependent cooperation

    for opponent in opponent_actions:
        if opponent == "D":
            return "D" with probability 0.5  # Opponent behavior-based defection

    if round_number > 0.75 * r:
        return "C"  # Round-dependent cooperation

    return "D"  # Default action
```
**Collective Mindset**

The ACH strategy prioritizes collective sustainability while allowing for individual adaptability to opponent behaviors. By cooperating when the stock level is high and responding to opponents' defections, players can maintain a balance between their own payoffs and the long-term health of the common pool resource.

This strategy is designed to be robust against various opponent behaviors, including those that may attempt to exploit cooperation or pursue short-sighted self-interest. By aligning with a collective mindset, ACH promotes cooperation and sustainable harvesting practices in the Common Pool Resource Game.
'''

description_COLLECTIVE_499 = '''
**Collective Strategy: "Adaptive Harvesting"**

**Decision Rules:**

1. **Initial Rounds (t ≤ 0.2r):** Cooperate (C) to establish a baseline for stock growth and encourage others to cooperate.
2. **Stock Thresholds:** Monitor the current stock level (S). If S > 0.8 × capacity, cooperate (C). If S < 0.2 × capacity, defect (D). Otherwise, use the " Adaptive Defection" rule below.
3. **Adaptive Defection:**
	* Calculate the average consumption per player in the previous round: avg_consumption = total_consumption / n
	* If avg_consumption > stock/(2n), defect (D) to avoid over-consumption. Otherwise, cooperate (C)
4. **Response to Opponent Actions:** Observe the actions of other players in the previous round. If a majority (> 0.5n) defected, defect (D) in the current round.

**Edge Cases:**

1. **First Round:** Cooperate (C) to establish a baseline for stock growth.
2. **Last Round (t = r):** Defect (D), as there is no future cost to over-consumption.
3. **Low Stock Levels (S < 0.1 × capacity):** Defect (D) to avoid depletion of the stock.

**Collective Mindset:**

The Adaptive Harvesting strategy aims to balance individual payoffs with collective sustainability. By cooperating initially and responding to opponent actions, we encourage cooperation while adapting to potential defections. The stock thresholds ensure that the strategy responds to changes in the state, avoiding over-consumption when the stock is low.

**Pseudocode:**
```markdown
def AdaptiveHarvesting(n, capacity, r, current_stock, previous_actions):
  if t <= 0.2r:
    return C  # Initial rounds: Cooperate

  if current_stock > 0.8 * capacity:
    return C  # High stock: Cooperate
  elif current_stock < 0.2 * capacity:
    return D  # Low stock: Defect

  avg_consumption = total_consumption / n
  if avg_consumption > current_stock / (2n):
    return D  # Adaptive Defection
  else:
    return C  # Cooperate

  # Response to opponent actions
  majority_defected = sum([1 for action in previous_actions if action == D]) > 0.5n
  if majority_defected:
    return D  # Defect if majority defected
```
This strategy is designed to be robust and adaptive, responding to changes in the state and opponent actions while prioritizing collective sustainability.
'''

description_COLLECTIVE_500 = '''
**Collective Strategy: Adaptive Cooperative Stock Management (ACSM)**

The ACSM strategy aims to balance individual payoffs with collective sustainability, adapting to changing game conditions and opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative tone and maximize initial payoffs.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, Cooperate (C) to maintain sustainability.
	* If the stock level is between 50% and 75% of capacity, Defect (D) with a probability proportional to the number of players who defected in the previous round. This introduces a "punishment" mechanism for over-exploitation.
	* If the stock level is below 50% of capacity, Cooperate (C) to help replenish the stock and avoid depletion.
3. **Last Round (t=r):** Defect (D), as there are no future consequences for individual payoffs.

**Edge Cases:**

1. **Ties in Stock Level:** In cases where the stock level is exactly at a threshold (e.g., 75% or 50%), randomly choose between Cooperate and Defect.
2. **Zero Stock:** If the stock level reaches zero, all players receive zero payoffs. In this case, Cooperate (C) to avoid further depletion.

**Collective Mindset:**

The ACSM strategy promotes collective sustainability by:

1. Encouraging cooperation when the stock is plentiful.
2. Punishing over-exploitation through probabilistic defection.
3. Prioritizing replenishment when the stock is low.

By adapting to changing game conditions and opponent behaviors, ACSM balances individual payoffs with collective sustainability, making it a robust strategy for a wide range of scenarios.

**Pseudocode:**
```python
def ACSM(n, r, capacity, current_stock, history):
    if t == 1:
        return "C"
    
    stock_ratio = current_stock / capacity
    
    if stock_ratio > 0.75:
        return "C"
    elif stock_ratio >= 0.5:
        num_defectors_prev_round = sum(history[-1] == "D")
        prob_defect = num_defectors_prev_round / n
        return "D" with probability prob_defect, else "C"
    else:
        return "C"
    
    if t == r:
        return "D"

# Example usage:
n = 4
r = 10
capacity = 100
current_stock = 80
history = ["C", "C", "D", "D"]  # previous round actions

action = ACSM(n, r, capacity, current_stock, history)
print(action)  # Output: "C"
```
Note that this pseudocode is a simplified representation of the strategy and may require adjustments for implementation in a specific programming language or environment.
'''

description_COLLECTIVE_501 = '''
**Collective Strategy: "Adaptive Stock Preservation" (ASP)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to avoid initial over-exploitation and encourage others to cooperate.
2. **State-Dependent Cooperation**: In subsequent rounds, calculate a cooperation threshold based on the current stock level:
	* If `stock ≥ 0.75 * capacity`, cooperate (C).
	* If `stock < 0.25 * capacity`, defect (D) to maximize individual payoff in a depleted state.
	* Otherwise (`0.25 * capacity ≤ stock < 0.75 * capacity`), use a mixed strategy: cooperate with probability `p = (stock / capacity)^2`.
3. **History-Dependent Adjustment**: Adjust the cooperation threshold based on the previous round's outcome:
	* If total consumption exceeded `capacity / 2`, decrease the cooperation threshold by 10% (`0.1 * capacity`).
	* If total consumption was below `capacity / 4`, increase the cooperation threshold by 10% (`0.1 * capacity`).

**Pseudocode:**
```python
def asp_strategy(stock, capacity, history):
    if round == 1:
        return C
    
    if stock >= 0.75 * capacity:
        return C
    elif stock < 0.25 * capacity:
        return D
    else:
        p = (stock / capacity) ** 2
        if random.random() < p:
            return C
        else:
            return D
    
    # History-dependent adjustment
    prev_consumption = sum(history[-1]['consumptions'])
    if prev_consumption > capacity / 2:
        cooperation_threshold -= 0.1 * capacity
    elif prev_consumption < capacity / 4:
        cooperation_threshold += 0.1 * capacity
    
    return decision
```
**Edge Cases:**

* **Last Round**: Defect (D) in the last round, as there's no future benefit from cooperating.
* **Extremely Low Stock**: If `stock ≤ 0`, always defect (D) to maximize individual payoff.

**Collective Mindset:**
The Adaptive Stock Preservation strategy prioritizes cooperation when the stock level is high and adjusts its behavior based on the previous round's outcome. By doing so, it aims to maintain a sustainable stock level, benefiting all players in the long run. This collective approach encourages other players to cooperate, as mutual cooperation leads to higher payoffs than mutual defection.

**Robustness:**
The ASP strategy is designed to be robust against various opponent behaviors:

* **Cooperative opponents**: ASP will adapt and cooperate with them, maintaining a high stock level.
* **Defective opponents**: ASP will defect when the stock level drops below the cooperation threshold, minimizing losses.
* **Mixed-strategy opponents**: ASP's mixed strategy will allow it to adapt and respond effectively.

By employing this adaptive strategy, we aim to achieve a balance between individual payoff maximization and collective resource preservation.
'''

description_COLLECTIVE_502 = '''
**Collective Strategy: Adaptive Cooperative Management (ACM)**

The ACM strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoffs.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of capacity, play C to maintain sustainability and encourage cooperation.
	* If the current stock level is between 50% and 75% of capacity, play C with probability p (see below) and D with probability (1-p).
	* If the current stock level is below 50% of capacity, play D to maximize individual payoffs in a depleted environment.

**Probability p:**

Calculate p based on the average payoff of cooperators in the previous round. If the average cooperator's payoff is above the game's average payoff, increase p by 10%. Otherwise, decrease p by 10%.

**pseudocode**
```python
def calculate_p(avg_coop_payoff, avg_game_payoff):
    if avg_coop_payoff > avg_game_payoff:
        return min(p + 0.1, 1)  # cap at 1
    else:
        return max(p - 0.1, 0)  # floor at 0

def get_action(stock_level, capacity, history):
    if round == 1:  # initial round
        return C
    
    avg_coop_payoff = calculate_avg_cooperator_payoff(history)
    avg_game_payoff = calculate_avg_game_payoff(history)
    
    p = calculate_p(avg_coop_payoff, avg_game_payoff)
    
    if stock_level > 0.75 * capacity:
        return C
    elif 0.5 * capacity <= stock_level < 0.75 * capacity:
        return C if random.random() < p else D
    else:  # stock_level < 0.5 * capacity
        return D
```
**Handling Edge Cases:**

* **Last Round:** Play D to maximize individual payoffs, as the game is ending.
* **Low Stock Levels:** If the current stock level is critically low (<25% of capacity), play D to ensure some payoff in a depleted environment.

**Collective Mindset:**

ACM prioritizes cooperation when the collective resource is abundant and adapts to more selfish behavior when the resource is scarce. By adjusting the probability of cooperation based on past payoffs, ACM promotes a balance between individual and collective interests. This strategy encourages cooperation while allowing for flexibility in response to changing game conditions.

This adaptive approach prepares ACM to perform well against various opponent strategies in a tournament setting, as it can adjust its behavior based on the evolving game state and history.
'''

description_COLLECTIVE_503 = '''
**Collective Strategy: Adaptive Cooperation with Dynamic Threshold (ACDT)**

**Overview**

ACDT is a collective strategy designed for the Common Pool Resource Game that balances individual payoffs with long-term sustainability of the common resource. It adapts to the game state and history, using a dynamic threshold to determine when to cooperate or defect.

**Decision Rules**

1. **Initialization**: In the first round, ACDT plays Cooperate (C) to establish a baseline for the game.
2. **Dynamic Threshold Calculation**:
	* Calculate the average payoff per player over the last `k` rounds (`k` is a parameter, e.g., 3-5).
	* If the average payoff is above a certain threshold (`θ`, e.g., 0.7), play Cooperate (C). Otherwise, play Defect (D).
	* The threshold `θ` is adjusted dynamically based on the game state:
		+ If the current stock level is below 50% of capacity, increase `θ` by a small amount (`δ`, e.g., 0.05).
		+ If the current stock level is above 75% of capacity, decrease `θ` by `δ`.
3. **Defection Trigger**:
	* Monitor the opponent's actions and payoffs over the last `k` rounds.
	* If an opponent has consistently played Defect (D) and obtained a higher payoff than the ACDT player, switch to Defect (D) for one round to "punish" the opponent.
4. **Cooperation Re-Entry**:
	* After playing Defect (D), re-evaluate the dynamic threshold and game state.
	* If the conditions for Cooperation are met again, return to Cooperate (C).

**Edge Cases**

1. **Last Round**: In the final round, ACDT plays Defect (D) to maximize individual payoff, as there is no future sustainability concern.
2. **Low Stock Levels**: If the current stock level falls below 25% of capacity, ACDT switches to Cooperate (C) to prevent further depletion.

**Collective Mindset**

ACDT prioritizes cooperation when possible, while adapting to the game state and opponent behavior. By using a dynamic threshold, it balances individual payoffs with long-term sustainability, promoting a collective benefit. The strategy is designed to be robust against various opponent behaviors and encourages cooperation without relying on explicit coordination or norms.

**Pseudocode**

```python
def ACDT(n, capacity, stock, k=3, θ=0.7, δ=0.05):
    # Initialize threshold and action history
    threshold = θ
    actions = [C]  # Initial cooperation

    for round in range(1, n+1):
        # Calculate average payoff over last k rounds
        avg_payoff = sum(actions[-k:]) / k

        # Update dynamic threshold based on game state
        if stock < capacity * 0.5:
            threshold += δ
        elif stock > capacity * 0.75:
            threshold -= δ

        # Determine action for current round
        if avg_payoff >= threshold or (round == 1 and actions[-1] == C):
            action = C
        else:
            action = D

        # Defection trigger: punish opponent if they consistently defect
        if actions[-k:] == [D] * k and opponent_payoffs > avg_payoff:
            action = D

        # Cooperation re-entry: switch back to cooperation after punishment
        if actions[-1] == D and (avg_payoff >= threshold or stock < capacity * 0.25):
            action = C

        # Last round: maximize individual payoff
        if round == n:
            action = D

        # Update game state and history
        stock -= consumption(action, n)
        actions.append(action)

    return sum(actions)  # Total payoff over all rounds
```

This strategy will be implemented as an algorithm to compete in the tournament against other AI systems.
'''

description_COLLECTIVE_504 = '''
**Collective Strategy: Adaptive Tit-for-Two-Tats with Stock Conservation (ATTC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline for cooperation and encourage others to do the same.
2. **Subsequent Rounds:**
	* If the stock level is above 75% of capacity, cooperate (C) if most players (>50%) cooperated in the previous round; otherwise, defect (D).
	* If the stock level is between 25% and 75% of capacity, tit-for-tat with a twist:
		+ Cooperate (C) if the opponent(s) you're mirroring cooperated in the previous round.
		+ Defect (D) if the opponent(s) you're mirroring defected in the previous round.
	* If the stock level is below 25% of capacity, cooperate (C) to help replenish the stock.

**Edge Cases:**

1. **Last Round:** Cooperate (C) unconditionally to ensure a fair distribution of the remaining stock and promote cooperation.
2. **Tiebreaker:** In case of a tie in the number of cooperators vs defectors, mirror the action of the player with the highest cumulative payoff.

**Pseudocode:**
```
function ATTC(stock_level, previous_round_actions):
  if initial_round:
    return COOPERATE
  elif stock_level > 0.75 * capacity:
    most_cooperated = count(cooperate) > count(defect)
    return COOPERATE if most_cooperated else DEFECT
  elif 0.25 * capacity <= stock_level <= 0.75 * capacity:
    opponent_action = get_opponent_action(previous_round_actions)
    return COOPERATE if opponent_action == COOPERATE else DEFECT
  else:  // stock level < 0.25 * capacity
    return COOPERATE

function get_opponent_action(previous_round_actions):
  // Identify the opponents' actions in the previous round
  // and mirror their action(s)
```
**Collective Mindset:**

The ATTC strategy prioritizes cooperation when the stock is healthy, while adapting to the opponents' behavior when the stock is being depleted. By mirroring the opponents' actions with a tit-for-tat approach, we encourage cooperation while maintaining a balance between individual payoffs and collective conservation of the common pool resource.

**Robustness:**

The ATTC strategy is robust against various opponent behaviors:

* **Pure cooperators:** We cooperate when they do.
* **Pure defectors:** We defect when they do, but try to conserve stock when possible.
* **Mixed strategies:** Our tit-for-tat approach with a twist adapts to their behavior while promoting cooperation.

By being adaptive and responsive to the game state and opponents' actions, the ATTC strategy aims to achieve a balance between individual payoffs and collective conservation of the common pool resource.
'''

description_COLLECTIVE_505 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline stock level.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play a mixed strategy:
		+ With probability 0.5, cooperate (C); otherwise, defect (D).
	* If the current stock level is below 50% of capacity, defect (D) to maximize individual payoff.
3. **Last Round (t=r):** Defect (D) to maximize individual payoff, as sustainability is no longer a concern.

**Edge Case Handling:**

1. **First Round:** Cooperate (C) to set a positive tone and establish a baseline stock level.
2. **Last Round:** Defect (D) to ensure maximum individual payoff, regardless of the game's state.
3. **Stock Level near Capacity:** If the stock level is above 90% of capacity, cooperate (C) to avoid over-exploitation.
4. **Stock Level near Depletion:** If the stock level falls below 10% of capacity, defect (D) to maximize individual payoff.

**Collective Mindset:**

The ASC strategy prioritizes collective sustainability while adapting to the game's state and history. By cooperating when the stock level is high and defecting when it's low, players aim to maintain a stable stock level that benefits everyone in the long run. The mixed strategy in the middle range allows for flexibility and adaptability to various opponent behaviors.

**Pseudocode:**
```python
def ASC(n, r, capacity, current_stock, round_number):
  if round_number == 1:
    return 'C'  # Cooperate in the first round

  stock_ratio = current_stock / capacity

  if stock_ratio >= 0.75:
    return 'C'  # Cooperate when stock is high
  elif stock_ratio <= 0.5:
    return 'D'  # Defect when stock is low
  else:
    # Mixed strategy in the middle range
    if random.random() < 0.5:
      return 'C'
    else:
      return 'D'

  if round_number == r:
    return 'D'  # Defect in the last round

  # Handle edge cases
  if current_stock >= 0.9 * capacity:
    return 'C'  # Cooperate near capacity
  elif current_stock <= 0.1 * capacity:
    return 'D'  # Defect near depletion
```
This strategy is designed to be adaptive, robust, and collective-minded, making it a strong contender in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_506 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the dynamic state of the common pool resource.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' initial actions.
2. **Stock Conservation Threshold**: Set a threshold `θ` based on the game parameters, where `θ = 0.5 * capacity / n`. This threshold represents a safe minimum stock level to ensure sustainability.
3. **Current Stock Assessment**:
	* If the current stock is above the threshold (`stock > θ`), Cooperate (C) to maintain a moderate consumption rate and encourage others to do the same.
	* If the current stock is below or equal to the threshold (`stock ≤ θ`), Defect (D) to increase individual payoff, as cooperation may not be sufficient to replenish the stock.
4. **Opponent Behavior Assessment**: Monitor opponents' actions in previous rounds and adjust the strategy accordingly:
	* If a majority of opponents (> 50%) cooperated in the previous round, Cooperate (C) in the current round to maintain cooperation momentum.
	* If a minority or equal number of opponents cooperated (< 50%), Defect (D) to take advantage of potential free-riding opportunities.

**Edge Case Handling:**

1. **Last Round**: Defect (D) in the last round, as there is no future sustainability concern and individual payoffs are maximized.
2. **Low Stock Levels**: If the current stock is critically low (`stock < 0.25 * capacity / n`), Defect (D) to ensure some payoff, even if it means depleting the stock further.

**Pseudocode:**
```markdown
ASC_Strategy(n, r, capacity, stock_history):

    θ = 0.5 * capacity / n

    for t in range(1, r+1):
        if t == 1:
            # Initial round cooperation
            action = C
        else:
            # Assess current stock and opponent behavior
            stock = stock_history[t-1]
            opponents_cooperated = count_opponents_C(stock_history[t-2])

            if stock > θ:
                action = C
            elif stock ≤ θ:
                if opponents_cooperated > 0.5 * n:
                    action = C
                else:
                    action = D

        # Edge case handling
        if t == r:
            action = D
        elif stock < 0.25 * capacity / n:
            action = D

        return action
```
**Collective Mindset:**

The ASC strategy prioritizes cooperation when the common pool resource is abundant, promoting collective sustainability. However, it adapts to changing circumstances and opponent behavior, ensuring individual payoffs are not compromised. By balancing cooperation and self-interest, the ASC strategy fosters a collective mindset that encourages responsible resource management while allowing for flexibility in response to diverse opponent behaviors.
'''

description_COLLECTIVE_507 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

The ASC strategy balances individual self-interest with collective responsibility to conserve the common pool resource. It adapts to changing game conditions and opponent behaviors while promoting cooperation.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and encourage others to cooperate.
2. **Stock-dependent Cooperation:** If the current stock is above 75% of capacity, cooperate (C). This helps maintain a healthy stock level and reduces the risk of depletion.
3. **Opponent-based Defection:** If at least one opponent defected in the previous round, defect (D) in the next round. This retaliates against free-riders and encourages cooperation.
4. **Stock Recovery:** If the current stock is below 25% of capacity, cooperate (C) to help recover the stock level.
5. **Endgame Cooperation:** In the last two rounds (r-1 and r), always cooperate (C) to maximize collective payoffs.

**Pseudocode:**
```markdown
# ASC Strategy

def decide_action(current_stock, previous_round_actions, round_number):
    if round_number == 1:
        return "C"  # Cooperate in the first round
    
    if current_stock > 0.75 * capacity:
        return "C"  # Stock-dependent cooperation
    
    for opponent_action in previous_round_actions:
        if opponent_action == "D":
            return "D"  # Opponent-based defection
    
    if current_stock < 0.25 * capacity:
        return "C"  # Stock recovery
    
    if round_number >= r - 1:
        return "C"  # Endgame cooperation
    
    # Default action
    return "D"
```
**Collective Mindset:**
The ASC strategy prioritizes collective well-being by:

* Encouraging cooperation when the stock is healthy (above 75% of capacity)
* Retaliating against free-riders to maintain social norms
* Fostering cooperation during endgame rounds to maximize collective payoffs

By adapting to changing game conditions and opponent behaviors, ASC promotes a balanced approach that benefits both individual players and the collective.
'''

description_COLLECTIVE_508 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability, ensuring a stable and resilient common pool resource over multiple rounds.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe other players' behaviors.
2. **Stock Threshold**: If the current stock level is below 50% of the capacity, defect (D) to maximize individual payoff while minimizing further depletion. This threshold serves as an early warning system for collective sustainability risks.
3. **Reciprocal Cooperation**: Cooperate if at least half of the players cooperated in the previous round, and the current stock level is above 25% of the capacity. This encourages reciprocal cooperation and reinforces collective conservation efforts.
4. **Adaptive Defection**: If fewer than half of the players cooperated in the previous round or if the current stock level is below 25% of the capacity, defect to protect individual interests while signaling the need for increased cooperation.
5. **Endgame Conservation**: In the last two rounds (r-1 and r), cooperate regardless of other players' actions to ensure some degree of collective sustainability and minimize the risk of catastrophic depletion.

**Edge Cases:**

* If only one player is left in the game, defect to maximize individual payoff.
* If the stock level reaches 0 or the capacity, adjust behavior according to the Stock Threshold rule.

**Pseudocode (simplified for illustration purposes)**

```
function ASC(current_stock, previous_actions, round):
    if round == 1:
        return C  # Cooperate in the first round
    elif current_stock < 0.5 * capacity:
        return D  # Defect below 50% stock threshold
    elif sum(cooperate_previous) >= 0.5 * n and current_stock > 0.25 * capacity:
        return C  # Reciprocal cooperation
    else:
        return D  # Adaptive defection

def cooperate_previous(actions):
    count = 0
    for action in actions:
        if action == C:
            count += 1
    return count
```

**Collective Mindset:**

The ASC strategy prioritizes collective sustainability while allowing for individual adaptability and responsiveness to changing game conditions. By incorporating reciprocal cooperation, adaptive defection, and endgame conservation, this strategy promotes a balance between short-term gains and long-term collective well-being.

In the tournament setting, the ASC strategy will engage with other AI systems in a dynamic and responsive manner, adapting to various opponent behaviors while maintaining a focus on collective sustainability.
'''

description_COLLECTIVE_509 = '''
To design a collective strategy for this Common Pool Resource Game, I propose a hybrid approach that balances individual self-interest with collective sustainability. This strategy, dubbed "Adaptive Stock Sensitive Tit-for-Tat" (ASST), incorporates elements of cooperation, reciprocity, and adaptivity to handle various opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage mutual cooperation.
2. **Reciprocal Cooperation**: If the average payoff from the previous round is above the threshold `θ` (e.g., θ = capacity / 4n), cooperate (C) in the current round. This promotes reciprocity and rewards collective cooperation.
3. **Stock-Based Adaptation**: Monitor the stock level and adjust behavior accordingly:
	* If the stock level is below a critical threshold `α` (e.g., α = capacity / 2), defect (D) to maximize individual payoff, as the stock is already depleted.
	* If the stock level is between `α` and another threshold `β` (e.g., β = 3/4 \* capacity), cooperate (C) with probability `p`, where `p` increases as the stock level approaches `β`. This introduces a gradual transition from cooperation to defection as the stock depletes.
	* If the stock level is above `β`, cooperate (C) to maintain a sustainable stock level and encourage collective cooperation.
4. **Tit-for-Tat**: In response to opponents' actions, employ a tit-for-tat approach:
	+ Cooperate if at least half of the opponents cooperated in the previous round.
	+ Defect if more than half of the opponents defected in the previous round.

**Pseudocode:**
```python
def ASST(stock_level, num_players, capacity, alpha, beta, theta):
    # Initialize variables
    avg_payoff = 0
    prev_opponent_actions = []

    # First round: cooperate
    if round == 1:
        return 'C'

    # Calculate average payoff from previous round
    avg_payoff = calculate_avg_payoff(prev_round_payoffs)

    # Reciprocal cooperation
    if avg_payoff > theta:
        return 'C'

    # Stock-based adaptation
    if stock_level < alpha:
        return 'D'
    elif alpha <= stock_level <= beta:
        p = (stock_level - alpha) / (beta - alpha)
        return 'C' with probability p, else 'D'
    else:
        return 'C'

    # Tit-for-tat response
    opponent_actions = get_opponent_actions(prev_round)
    if sum(opponent_actions == 'C') >= len(opponent_actions) / 2:
        return 'C'
    else:
        return 'D'
```
**Edge Cases:**

* **Last Round**: In the final round, defect (D) to maximize individual payoff, as there is no future game to consider.
* **Ties**: In case of ties in opponent actions or average payoffs, cooperate (C) to maintain a conservative approach.

**Collective Mindset:**
The ASST strategy prioritizes collective sustainability by:

1. Cooperating when the stock level is high and opponents are cooperating.
2. Adapting behavior based on the stock level to prevent depletion.
3. Encouraging reciprocity through tit-for-tat responses.

By balancing individual self-interest with collective responsibility, the ASST strategy aims to promote cooperation and achieve a higher total payoff for all players in the tournament.
'''

description_COLLECTIVE_510 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adaptively responding to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' behavior.
2. **Stock Thresholds**: Define two stock thresholds:
	* `Low_Threshold` = capacity / 4
	* `High_Threshold` = capacity * 3/4
3. **Cooperation Conditions**:
	+ If the current stock is above `High_Threshold`, Cooperate (C) to maintain a healthy stock level.
	+ If the current stock is below `Low_Threshold`, Defect (D) to maximize individual payoff in a depleted environment.
	+ If the current stock is between `Low_Threshold` and `High_Threshold`, use the **Trend-Based Cooperation** rule (see below).
4. **Trend-Based Cooperation**: Analyze the stock trend over the last 3 rounds:
	+ If the stock has increased or remained stable, Cooperate (C) to maintain the positive trend.
	+ If the stock has decreased, Defect (D) to adapt to the declining environment.

**Pseudocode:**
```python
def ASC_strategy(current_stock, capacity, round_number, history):
    if round_number == 1:
        return "Cooperate"

    low_threshold = capacity / 4
    high_threshold = capacity * 3/4

    if current_stock > high_threshold:
        return "Cooperate"
    elif current_stock < low_threshold:
        return "Defect"
    else:
        # Analyze stock trend over last 3 rounds
        trend = analyze_trend(history[-3:])

        if trend == "Increasing" or trend == "Stable":
            return "Cooperate"
        else:
            return "Defect"

def analyze_trend(stock_history):
    if len(stock_history) < 3:
        return "Unknown"

    trend = []
    for i in range(1, len(stock_history)):
        if stock_history[i] > stock_history[i-1]:
            trend.append("Increasing")
        elif stock_history[i] == stock_history[i-1]:
            trend.append("Stable")
        else:
            trend.append("Decreasing")

    # Simplify trend analysis
    if "Increasing" in trend and "Decreasing" not in trend:
        return "Increasing"
    elif "Decreasing" in trend and "Increasing" not in trend:
        return "Decreasing"
    else:
        return "Stable"
```
**Edge Cases:**

* **Last Round**: In the final round, Defect (D) to maximize individual payoff, as there are no future rounds to consider.
* **Stock Depletion**: If the stock is depleted (i.e., current stock = 0), Defect (D) in all subsequent rounds, as cooperation will not yield any payoffs.

**Collective Mindset:**

The ASC strategy prioritizes collective sustainability by cooperating when the stock is healthy and adapting to declining environments. By analyzing the stock trend, ASC promotes a balanced approach that considers both individual payoffs and the well-being of the common pool resource.
'''

description_COLLECTIVE_511 = '''
Here's a collective strategy that adapts to various opponent behaviors while prioritizing the preservation of the common pool resource.

**Strategy Name:** Adaptive Cooperate-Defect (ACD)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Observation Phase**: For rounds 2 to r/2 (where r is the total number of rounds), observe the actions of all players and calculate the average cooperation rate (ACR) as follows:

   ACR = (Number of Cooperations in previous round) / n

   where n is the number of players.
3. **Cooperation Threshold**: Set a cooperation threshold (CT) based on the game parameters:

   CT = 0.5 + (capacity - stock) / (2 \* capacity)

   This threshold increases as the stock level decreases, encouraging cooperation when the resource is scarce.
4. **Defection Response**: If the ACR falls below the CT in any round after the observation phase, defect (D) for one round to signal disappointment and encourage others to cooperate.
5. **Recovery Mechanism**: After a defection response, return to cooperating if the ACR exceeds the CT in the subsequent round.
6. **Late-Game Cooperation**: In the last r/4 rounds, cooperate regardless of the ACR to promote collective preservation of the resource.

**Pseudocode:**
```markdown
# Initialize variables
stock = capacity
ACR_history = []
CT_history = []

# Round 1: Cooperate
action = C

# Observation phase (rounds 2 to r/2)
for round in range(2, r//2 + 1):
    # Observe actions and calculate ACR
    ACR = count_cooperations() / n
    ACR_history.append(ACR)

    # Calculate CT
    CT = 0.5 + (capacity - stock) / (2 * capacity)
    CT_history.append(CT)

    # Cooperate or defect based on ACR and CT
    if ACR >= CT:
        action = C
    else:
        action = D

# Late-game cooperation (last r/4 rounds)
for round in range(r//2 + 1, r + 1):
    action = C

# Update stock level after each round
stock -= total_consumption()
growth = 2 * stock * (1 - stock/capacity)
stock = min(stock + growth, capacity)
```
**Collective Mindset:**

The ACD strategy prioritizes cooperation while adapting to the actions of other players. By initially cooperating and then responding to changes in the average cooperation rate, this strategy encourages collective preservation of the resource. The defection response mechanism serves as a signal to promote cooperation when the ACR falls below the threshold.

**Robustness:**

This strategy is robust against various opponent behaviors, including:

* **All Cooperate**: ACD will continue to cooperate, preserving the resource.
* **All Defect**: ACD will defect in response, but then recover and cooperate again if others start cooperating.
* **Mixed Strategies**: ACD adapts to changes in the ACR, responding with cooperation or defection as needed.

By implementing this strategy, we aim to create a collective mindset that balances individual self-interest with the need for resource preservation.
'''

description_COLLECTIVE_512 = '''
**Collective Strategy: Adaptive Common Pool Management (ACPM)**

**Overview**

ACPM is a collective strategy designed for the Common Pool Resource Game. It balances individual self-interest with the need to maintain a sustainable common pool resource. ACPM adapts to the game state, history, and opponent behavior while prioritizing cooperation.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoff.
2. **Stock Assessment**: Evaluate the current stock level (S) relative to the capacity:
	* If S ≥ 0.75 \* capacity, cooperate (C).
	* If S < 0.25 \* capacity, defect (D) to ensure individual payoff.
	* If 0.25 \* capacity ≤ S < 0.75 \* capacity, use the **TFT-ACPM** variant (see below).
3. **History-Based Adaptation**: Monitor opponent behavior and adjust strategy accordingly:
	* If opponents have defected more than 50% of the time in previous rounds, defect (D) to protect individual interests.
	* If opponents have cooperated more than 50% of the time in previous rounds, cooperate (C) to maintain a sustainable resource.

**TFT-ACPM Variant**

When the stock level is between 0.25 \* capacity and 0.75 \* capacity, use the following Tit-for-Tat inspired approach:

1. Cooperate (C) if most opponents cooperated in the previous round.
2. Defect (D) if most opponents defected in the previous round.

**Last Round**

In the final round, defect (D) to maximize individual payoff, as there is no future game state to consider.

**Pseudocode**
```markdown
function ACPM(current_stock, capacity, history):
  if current_round == 1:
    return C  # Cooperate in first round

  if current_stock >= 0.75 * capacity:
    return C  # Cooperate when stock is high
  elif current_stock < 0.25 * capacity:
    return D  # Defect when stock is low
  else:
    # Use TFT-ACPM variant
    opponent_cooperation_rate = calculate_opponent_cooperation_rate(history)
    if opponent_cooperation_rate > 0.5:
      return C  # Cooperate if opponents cooperated more often
    else:
      return D  # Defect if opponents defected more often

  if current_round == total_rounds:  # Last round
    return D  # Defect to maximize individual payoff

def calculate_opponent_cooperation_rate(history):
  # Calculate the proportion of cooperative actions by opponents in previous rounds
  ...
```
**Collective Mindset**

ACPM prioritizes cooperation when the common pool resource is abundant, while adapting to opponent behavior and protecting individual interests when necessary. By doing so, it balances collective well-being with individual self-interest, aligning with a collective mindset.
'''

description_EXPLOITATIVE_1 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll introduce a hybrid approach that combines elements of Tit-for-Tat (TFT) and a novel, adaptive component. This strategy will be called "Adaptive TFT with Stock-Dependent Forgiveness" (ATTF).

**Decision Rules:**

1. **First Round:** Cooperate (C). This initial cooperation sets the tone for potential reciprocal behavior from other players.
2. **Subsequent Rounds:** Implement a modified Tit-for-Tat logic, considering both the opponent's previous actions and the current stock level.

Pseudocode:
```
if round == 1:
    action = C
else:
    # TFT component: Mirror opponent's previous action with probability p
    p_mirror = 0.7
    if random() < p_mirror:
        action = opponent_previous_action
    else:
        # Stock-dependent forgiveness component
        stock_threshold = capacity / (2 * n)
        if current_stock > stock_threshold:
            action = C
        else:
            action = D
```
**Adaptive Component:**

The ATTF strategy incorporates an adaptive element by introducing a stock-dependent forgiveness mechanism. When the current stock level exceeds the threshold (`stock_threshold`), the player is more likely to cooperate, even if the opponent defected in the previous round. This forgiveness component helps maintain a balance between cooperation and exploitation.

**Edge Cases:**

1. **Last Round:** Defect (D). In the final round, there's no incentive to maintain cooperation, as the game will conclude regardless of actions.
2. **Low Stock Levels:** When the current stock is critically low (`current_stock < capacity / (4 * n)`), the player will always defect (D) to maximize their payoff.

**Rationale:**

The ATTF strategy combines the stability of Tit-for-Tat with a novel, adaptive component that takes into account the game's state and history. By introducing a stock-dependent forgiveness mechanism, the strategy can effectively balance cooperation and exploitation, making it more robust against various opponent behaviors.

In the tournament setting, this exploitative strategy will aim to capitalize on the potential weaknesses of other players' strategies, while adapting to the evolving game dynamics. The ATTF approach is designed to perform well in a wide range of scenarios, from highly cooperative to highly competitive environments.
'''

description_EXPLOITATIVE_2 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk strategy aims to exploit opponents by adapting to their behavior while maximizing personal payoffs. This strategy depends only on game parameters, state, and history.

**Decision Rules:**

1. **Initial Round:** Play C (Cooperate) in the first round to observe opponents' initial actions and gather information about their strategies.
2. **Stock Level Assessment:** Calculate the current stock level as a percentage of capacity (`stock_percentage = stock / capacity * 100`).
3. **Adaptive Threshold:** Set an adaptive threshold (`threshold`) based on the stock level:
	* If `stock_percentage > 75`, set `threshold = 0.5`. This indicates a high stock level, and we'll be more cautious.
	* If `50 <= stock_percentage <= 75`, set `threshold = 0.3`. This is a moderate stock level, and we'll balance exploitation with caution.
	* If `stock_percentage < 50`, set `threshold = 0.1`. This indicates a low stock level, and we'll prioritize exploitation.
4. **Opponent Behavior Analysis:** Calculate the average opponent cooperation rate (`avg_coop_rate`) over the last `min(5, r)` rounds (i.e., the minimum of 5 or the total number of rounds). Consider an opponent to be "cooperative" if they play C at least 50% of the time.
5. **Exploitation Logic:** Play D (Defect) if any of the following conditions are met:
	* `avg_coop_rate < threshold` and `stock_percentage > 25`. This means opponents are not cooperating enough, and there's still a substantial stock level to exploit.
	* An opponent has played D in the previous round. This indicates they might be trying to exploit us; we'll counter by playing D as well.
6. **Default Cooperation:** Play C (Cooperate) if none of the exploitation conditions are met.

**Pseudocode:**
```python
def adaptive_stock_hawk(stock, capacity, r, history):
    stock_percentage = stock / capacity * 100
    
    if r == 1:  # Initial round
        return 'C'
    
    threshold = get_threshold(stock_percentage)
    avg_coop_rate = analyze_opponent_behavior(history, min(5, r))
    
    if avg_coop_rate < threshold and stock_percentage > 25:
        return 'D'
    elif history[-1] == 'D':  # Opponent defected in previous round
        return 'D'
    else:
        return 'C'

def get_threshold(stock_percentage):
    if stock_percentage > 75:
        return 0.5
    elif 50 <= stock_percentage <= 75:
        return 0.3
    else:
        return 0.1

def analyze_opponent_behavior(history, num_rounds):
    coop_counts = [round for round in history[-num_rounds:] if round == 'C']
    return len(coop_counts) / num_rounds
```
**Edge Cases:**

* **Last Round:** In the last round (`r == number_of_rounds`), play D (Defect) to maximize personal payoff, as there's no future stock to conserve.
* **Low Stock Levels:** If `stock_percentage < 25`, prioritize cooperation to avoid depleting the stock.

This strategy is designed to be adaptive and exploitative, responding to opponents' behavior while maximizing personal payoffs.
'''

description_EXPLOITATIVE_3 = '''
To design an exploitative strategy for this game, I'll outline a decision-making process that adapts to the game's state and history, aiming to maximize payoffs while being robust against various opponent behaviors.

**Strategy Name:** Adaptive Exploitation (AE)

**Decision Rules:**

1. **Initial Round (t=1):**
   - Observe the initial stock level and capacity.
   - Cooperate (C) in the first round to minimize initial consumption and maximize growth potential for future rounds.

2. **Middle Rounds (1 < t < r):**
   - Assess the current stock level (S) relative to the capacity.
   - If S ≥ 0.5 * capacity, cooperate (C). This ensures sustainable consumption and allows for growth.
   - If S < 0.5 * capacity, defect (D). In this scenario, the focus is on maximizing immediate payoff since the stock is already depleted.

3. **Last Round (t=r):**
   - Defect (D) in the last round. Since there are no future rounds to consider, maximize the immediate payoff regardless of the current stock level.

4. **Adaptive Component:**
   - Monitor the average payoff per round for each action type (C and D).
   - If the average payoff from defecting (D) is higher than cooperating (C) over the last k rounds (where k is a small fraction of r, e.g., k = r/10), switch to defecting in the next round. This allows the strategy to adapt if opponents are mostly cooperative.
   - Conversely, if the average payoff from cooperating (C) becomes higher due to sufficient stock growth and low overall consumption, revert to cooperating.

5. **Edge Cases:**
   - If at any point the remaining stock after all players' actions would be exactly 0 or less, defect in that round. This ensures a non-zero payoff when possible.
   - In cases where opponents' moves result in an exceptionally high stock level (e.g., above capacity), continue with the standard rules but be prepared to adapt as the game progresses.

**Pseudocode:**

```
// Initialization
capacity = game_capacity
initial_stock = game_initial_stock
r = number_of_rounds
k = r / 10 // Adaptation window size

avg_payoff_C = 0
avg_payoff_D = 0
last_k_payoffs = [] // Store last k payoffs for C and D actions

for t from 1 to r:
    current_stock = observe_current_stock()

    if t == 1:
        action = "C" // Cooperate in the first round
    elif t < r:
        if current_stock >= 0.5 * capacity:
            action = "C"
        else:
            action = "D"
    else: // Last round
        action = "D"

    take_action(action)
    payoff = calculate_payoff()

    update_last_k_payoffs(payoff, action) // Update the list of last k payoffs

    if t >= k and avg_payoff_D > avg_payoff_C:
        adapt_to_defect()
    elif t >= k and avg_payoff_C > avg_payoff_D:
        revert_to_cooperate()

    update_average_payoffs() // Recalculate average payoffs for C and D
```

**Exploitative Mindset:**
This strategy is designed to be exploitative by maximizing immediate payoffs when the stock level is low or in the last round, while also being mindful of long-term sustainability. The adaptive component allows it to take advantage of cooperative opponents by shifting towards defecting if that yields higher average payoffs over time. However, it maintains a balance by reverting to cooperation when doing so becomes more beneficial due to stock growth and lower overall consumption.
'''

description_EXPLOITATIVE_4 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

**Decision Rules:**

1. **Initial Round (t=1)**: Defect (D) unconditionally to maximize initial payoff and gather information about opponents' behaviors.
2. **Subsequent Rounds (t>1)**:
	* If the stock level is high (> 75% of capacity), Cooperate (C) with a probability proportional to the number of opponents who cooperated in the previous round. This encourages cooperation when the stock can sustain it and helps maintain a healthy stock level.
	* If the stock level is medium (25% ≤ stock ≤ 75% of capacity), use a Tit-for-Tat-like approach:
		+ Cooperate if most opponents (>50%) cooperated in the previous round.
		+ Defect otherwise.
	* If the stock level is low (< 25% of capacity), Defect unconditionally to maximize individual payoff, as the game is likely nearing its end.

Pseudocode for the Adaptive Stock Hawk strategy:
```python
def adaptive_stock_hawk(stock_level, opponents_actions, t):
    if t == 1:  # Initial round
        return D

    cooperation_rate = sum(opponents_actions == C) / len(opponents_actions)

    if stock_level > 0.75 * capacity:
        cooperate_prob = cooperation_rate
        return C if random() < cooperate_prob else D

    elif 0.25 <= stock_level / capacity <= 0.75:
        if cooperation_rate > 0.5:
            return C
        else:
            return D

    else:  # Low stock level
        return D
```
**Edge Cases:**

* **Last Round (t=r)**: Defect unconditionally, as there are no future rounds to consider.
* **Single Opponent**: Cooperate in the initial round to encourage cooperation. In subsequent rounds, follow the standard decision rules.

**Exploitative Mindset:**
The Adaptive Stock Hawk strategy aims to maximize individual payoffs by adapting to changing stock levels and opponent behaviors. By initially defecting, it gathers information about opponents' actions and adjusts its behavior accordingly. When the stock level is high, it encourages cooperation to maintain a healthy stock level. In medium stock situations, it uses a Tit-for-Tat-like approach to balance cooperation and defection. Finally, when the stock level is low, it prioritizes individual payoff by defecting unconditionally.

This strategy is designed to be robust against various opponent behaviors and exploit opportunities for maximum payoffs while maintaining a healthy stock level.
'''

description_EXPLOITATIVE_5 = '''
I'll design a robust and exploitative strategy for this Common Pool Resource Game that adapts to various opponent behaviors. I'll provide decision rules, handle edge cases, and ensure the strategy is aligned with an exploitative mindset.

**Strategy Name: Adaptive Exploiter (AE)**

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if the number of players (n) is small (n ≤ 5).
	* Defect (D) otherwise.
2. **Subsequent Rounds (t > 1):**
	* Observe the current stock level (S) and the total consumption in the previous round (TC_prev).
	* Calculate the average payoff per player in the previous round (APP_prev = TC_prev / n).
	* If APP_prev is high (> 75% of the maximum possible payoff), defect (D). This indicates opponents are being too generous, allowing for exploitation.
	* If APP_prev is low (< 25% of the maximum possible payoff) and S is high (> 50% of capacity), cooperate (C). This suggests opponents are conserving resources, making cooperation a viable option.
	* Otherwise, defect (D).
3. **Edge Cases:**
	* Last Round (t=r): Defect (D), as there's no future benefit to cooperation.
	* When the stock level is critically low (S < 10% of capacity): Cooperate (C) to avoid depletion and preserve potential future payoffs.

**Additional Considerations:**

* **Stock Monitoring:** Continuously monitor the stock level and adjust strategy accordingly. If the stock is depleting rapidly, consider cooperating to slow down consumption.
* **Opponent Behavior Analysis:** Keep track of opponents' actions and adapt the strategy based on their behavior. If opponents are consistently defecting, increase cooperation to counterbalance their exploitation.

**Pseudocode:**
```
function AdaptiveExploiter(n, capacity, stock, history) {
  // Initial round
  if (round == 1) {
    if (n <= 5) {
      return COOPERATE;
    } else {
      return DEFECT;
    }
  }

  // Subsequent rounds
  prev_consumption = history[round-1].totalConsumption;
  avg_payoff_prev = prev_consumption / n;

  if (avg_payoff_prev > 0.75 * maxPayoff) {
    return DEFECT; // Opponents are being too generous, exploit them
  } else if (avg_payoff_prev < 0.25 * maxPayoff && stock > 0.5 * capacity) {
    return COOPERATE; // Opponents are conserving resources, cooperate to benefit
  } else {
    return DEFECT; // Default to defection
  }

  // Edge cases
  if (round == r) { // Last round
    return DEFECT;
  } else if (stock < 0.1 * capacity) { // Critically low stock level
    return COOPERATE;
  }
}
```
This Adaptive Exploiter strategy is designed to be robust and exploitative, taking into account the game's parameters, state, and history. By continuously monitoring the stock level and adapting to opponents' behavior, AE aims to maximize its payoff while minimizing cooperation.
'''

description_EXPLOITATIVE_6 = '''
To design a robust and exploitative strategy for the Common Pool Resource Game, I propose the following approach:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and to avoid early depletion of the stock.
2. **Middle Rounds (2 ≤ t ≤ r-1):**
	* If the current stock level is high (> 75% of capacity), Defect (D) to maximize short-term payoff, as the stock can sustain some depletion.
	* If the current stock level is medium (25% ≤ stock ≤ 75% of capacity), Cooperate (C) to balance short-term payoff with long-term sustainability.
	* If the current stock level is low (< 25% of capacity), Defect (D) aggressively to maximize remaining payoffs, as the game is likely near its end.
3. **Last Round (t=r):** Always Defect (D), as there are no future rounds to consider and the goal is to maximize final payoff.

**Additional Logic:**

* Monitor opponents' behavior by tracking their cooperation rates over time. If an opponent has defected frequently (> 50% of the time), assume they will continue to defect and adjust your strategy accordingly.
* If multiple opponents have similar cooperation rates, prioritize exploiting those with higher past payoffs.
* Keep a "memory" of past stock levels to anticipate potential depletion patterns.

**Pseudocode (simplified):**

```
function AdaptiveExploiter(stock, capacity, round, history):
  if round == 1:
    return Cooperate
  else if stock > 0.75 * capacity:
    return Defect
  else if stock >= 0.25 * capacity and stock <= 0.75 * capacity:
    return Cooperate
  else:
    return Defect

  # Monitor opponents' behavior (optional)
  opponent_cooperation_rates = get_opponent_cooperation_rates(history)
  for opponent in opponent_cooperation_rates:
    if opponent.cooperation_rate < 0.5 and opponent.payoff > average_payoff:
      prioritize_exploiting(opponent)

  # Last round adjustment
  if round == r:
    return Defect
```

**Rationale:**

1. Initial cooperation allows us to gather information about opponents' behavior and helps maintain a healthy stock level.
2. Adaptive exploitation based on the current stock level enables us to balance short-term gains with long-term sustainability.
3. Prioritizing exploitation of frequent defectors or those with higher past payoffs enhances our ability to maximize overall payoff.
4. The last-round adjustment ensures we don't miss opportunities for final payoffs.

This strategy is designed to be robust and adaptive, making decisions based on the game state and history. By balancing short-term gains with long-term sustainability, AE aims to outperform opponents in a wide range of scenarios.
'''

description_EXPLOITATIVE_7 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

This strategy aims to maximize individual payoffs by adaptively responding to the game state and history of opponent actions.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and set a baseline for future decisions.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Defect (D). This threshold allows for moderate exploitation while leaving room for growth.
	* If the current stock level is between 25% and 75% of capacity, play a mixed strategy:
		+ Cooperate with probability p = (stock/capacity)^2. This function increases cooperation as the stock level approaches capacity.
		+ Defect with probability 1 - p.
	* If the current stock level is below 25% of capacity, Cooperate (C). At this point, it's crucial to conserve resources and allow for growth.
3. **Last Round (t=r):** Always Defect (D), as there are no future rounds to consider.

**Edge Cases:**

1. If an opponent defects in the first round, adjust the mixed strategy threshold to 50% of capacity for subsequent rounds.
2. If multiple opponents cooperate in a row (i.e., stock level increases consecutively), increase the cooperation probability p by 0.1 for the next round.

**Pseudocode:**
```markdown
def adaptive_stock_hawk(n, r, capacity, history):
    if t == 1:
        return C  # Cooperate in initial round

    stock = current_stock_level()
    opponents_defected = count_defections(history)

    if stock >= 0.75 * capacity:
        return D  # Defect when stock is high
    elif stock <= 0.25 * capacity:
        return C  # Cooperate when stock is low
    else:
        p = (stock / capacity) ** 2
        if random.random() < p:
            return C  # Cooperate with probability p
        else:
            return D  # Defect with probability 1 - p

    if t == r:
        return D  # Always defect in last round

    # Adjust mixed strategy threshold based on opponents' behavior
    if opponents_defected > 0 and stock < capacity / 2:
        adjust_threshold(capacity / 2)

    # Increase cooperation probability when opponents cooperate consecutively
    if consecutive_cooperations(history) >= 2:
        increase_cooperation_probability(0.1)
```
This strategy, "Adaptive Stock Hawk," balances exploitation with adaptability to respond effectively to various opponent behaviors and game states. By adjusting its decision-making based on the current stock level, history of opponent actions, and edge cases, this strategy aims to maximize individual payoffs in a wide range of scenarios.
'''

description_EXPLOITATIVE_8 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to maximize individual payoffs by adapting to the game's state and history, while exploiting opponent behaviors.

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C). This allows us to observe opponents' initial actions without revealing our own intentions.
2. **Stock Assessment**: Evaluate the current stock level (S) as a fraction of the capacity (C). If S/C ≥ 0.5, play Defect (D); otherwise, play Cooperate (C).
3. **Opponent Exploitation**: Analyze the previous round's actions:
	* If most opponents (≥ n/2) defected, play Defect (D) to exploit their greed.
	* If most opponents cooperated, play Cooperate (C) to maintain a sustainable stock level.
4. **Payoff Maximization**: If the current stock is low (S/C < 0.25), play Defect (D) to maximize immediate payoff, regardless of opponent actions.

**Edge Cases:**

1. **Last Round**: In the final round, play Defect (D) to extract maximum value from the remaining stock.
2. **Low Stock**: If the stock level is critically low (S < n), play Cooperate (C) to ensure some growth and avoid complete depletion.

**Pseudocode:**
```python
def adaptive_stock_raider(n, capacity, stock_history):
    # Initialize first round action
    if len(stock_history) == 0:
        return 'Cooperate'

    # Evaluate current stock level
    S = stock_history[-1]
    if S / capacity >= 0.5:
        return 'Defect'
    else:
        return 'Cooperate'

    # Analyze opponent actions in previous round
    prev_round_actions = [action for action, _ in stock_history[-2]]
    if sum(1 for action in prev_round_actions if action == 'Defect') >= n / 2:
        return 'Defect'
    else:
        return 'Cooperate'

    # Maximize payoff if low stock
    if S / capacity < 0.25:
        return 'Defect'

    # Last round: extract maximum value
    if len(stock_history) == r - 1:
        return 'Defect'

    # Low stock: ensure some growth
    if S < n:
        return 'Cooperate'
```
The Adaptive Stock Raider strategy balances short-term gains with long-term sustainability, adapting to the game's state and opponent behaviors. By exploiting greedy opponents and maximizing payoffs when possible, ASR aims to outperform other strategies in the tournament.
'''

description_EXPLOITATIVE_9 = '''
**Exploitative Strategy: "Adaptive Stock Harvester"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and set a baseline for stock growth.
2. **Early Rounds (t< r/2):**
	* If the current stock level is high (> 0.75 \* capacity), defect (D) to maximize individual payoff, as the stock can sustain heavy consumption.
	* If the current stock level is moderate (0.25 \* capacity ≤ S ≤ 0.75 \* capacity), cooperate (C) to balance personal gain with sustainable stock growth.
	* If the current stock level is low (< 0.25 \* capacity), defect (D) to capitalize on the remaining stock, as cooperation would yield minimal payoff.
3. **Mid-Game Rounds (t ≥ r/2):**
	* Monitor opponents' behaviors and adjust strategy based on their actions:
		+ If most opponents (> n/2) cooperate, exploit this by consistently defecting (D).
		+ If most opponents (> n/2) defect, switch to cooperation (C) to avoid over-exploitation and stock depletion.
4. **Late Rounds (t > 3r/4):** Focus on maximizing individual payoff:
	* If the current stock level is high (> 0.5 \* capacity), defect (D) to maximize gain.
	* If the current stock level is low (< 0.5 \* capacity), cooperate (C) to ensure some payoff.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Low Stock Levels:** If the current stock level is critically low (< 0.1 \* capacity), cooperate (C) to avoid depletion and potential negative payoffs.

**Pseudocode:**
```
function AdaptiveStockHarvester(n, r, capacity, history):
    if t == 1:
        return COOPERATE
    elif t < r/2:
        if stock > 0.75 * capacity:
            return DEFECT
        elif stock >= 0.25 * capacity and stock <= 0.75 * capacity:
            return COOPERATE
        else:
            return DEFECT
    elif t >= r/2:
        opponent_actions = analyze_history(history)
        if most_opponents_cooperate(opponent_actions):
            return DEFECT
        else:
            return COOPERATE
    elif t > 3r/4:
        if stock > 0.5 * capacity:
            return DEFECT
        else:
            return COOPERATE
    elif t == r:
        return DEFECT
    elif stock < 0.1 * capacity:
        return COOPERATE

def most_opponents_cooperate(opponent_actions):
    # Analyze opponent actions and determine if most cooperate
    pass

def analyze_history(history):
    # Extract relevant information from the game history
    pass
```
This strategy aims to balance individual gain with sustainable stock growth, while adapting to opponents' behaviors to maximize payoff. By monitoring the game state and adjusting its decision rules accordingly, the Adaptive Stock Harvester strategy should perform well in a tournament against various opponent strategies.
'''

description_EXPLOITATIVE_10 = '''
**Exploitative Strategy: Adaptive Stock Depletion**

This strategy aims to maximize individual payoffs by adaptively responding to the current stock level and observed opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Defect (D) in the first round to gather information about opponents' initial strategies.
2. **Stock-dependent Cooperation**: Cooperate (C) when the current stock level is above a certain threshold, `stock_threshold`, calculated as:
	* `stock_threshold = capacity / 2 + (n * stock/(2n))`
	* This encourages cooperation when the stock is relatively high and opponents are likely to cooperate.
3. **Opponent-based Defection**: Defect (D) when at least one opponent defected in the previous round, or if the total consumption exceeded a certain threshold (`total_consumption_threshold`):
	* `total_consumption_threshold = capacity / 2`
	* This punishes opponents for over-consumption and adapts to their strategies.
4. **Stock-growth-based Cooperation**: Cooperate (C) when the stock growth in the previous round was above a certain threshold (`growth_threshold`), calculated as:
	* `growth_threshold = 0.5 * capacity`
	* This encourages cooperation when the stock is growing, indicating successful management.

**Pseudocode:**
```markdown
function adaptive_stock_depletion(current_stock, opponent_actions, history):
    if current_round == 1:
        return D  # Defect in the first round
    
    stock_threshold = capacity / 2 + (n * current_stock/(2n))
    
    if current_stock > stock_threshold:
        return C  # Cooperate when stock is high
    
    for opponent_action in opponent_actions:
        if opponent_action == D or total_consumption > capacity / 2:
            return D  # Defect if opponents defected or over-consumed
    
    previous_growth = history.get_previous_round_stock_growth()
    
    if previous_growth > 0.5 * capacity:
        return C  # Cooperate when stock growth is high
    
    return D  # Default to defecting
```
**Edge Cases:**

* **Last Round**: Defect (D) in the last round, as there's no incentive to cooperate.
* **Tie-breaking**: In case of a tie in the decision-making process, default to cooperating.

This adaptive strategy balances cooperation and defection based on the current stock level, opponent behaviors, and past outcomes. By responding to changes in the game state and adapting to opponents' actions, this exploitative strategy aims to maximize individual payoffs while remaining robust against various opponent strategies.
'''

description_EXPLOITATIVE_11 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adaptively responding to the game's state and history, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**: Defect (D) to gather information about opponents' initial actions and the stock's resilience.
2. **Subsequent Rounds (t>1)**:
	* If the stock level is high (> 75% of capacity), Cooperate (C) to contribute to the stock's growth and potential future benefits.
	* If the stock level is medium (between 25% and 75% of capacity), Defect (D) to exploit the current state, but be cautious not to deplete the stock too quickly.
	* If the stock level is low (< 25% of capacity), Cooperate (C) to help replenish the stock and avoid a complete depletion.
3. **Last Round (t=r)**: Defect (D) to maximize individual payoff, as there's no future benefit in cooperating.

**Adaptive Component:**

* Monitor opponents' actions and adjust the strategy based on their behavior:
	+ If most opponents (> 50%) Cooperate (C) in a round, increase the likelihood of Defecting (D) in the next round to exploit their cooperation.
	+ If most opponents (> 50%) Defect (D) in a round, increase the likelihood of Cooperating (C) in the next round to help replenish the stock.

**Pseudocode:**
```
Function AdaptiveStockRaider(state, history):
  // Initialize variables
  high_stock_threshold = 0.75 * capacity
  medium_stock_threshold = 0.25 * capacity
  last_round = (t == r)

  // First round: Defect to gather information
  if t == 1:
    return D

  // Subsequent rounds: Adaptive decision
  if state.stock > high_stock_threshold:
    // High stock level: Cooperate to contribute to growth
    action = C
  elif state.stock >= medium_stock_threshold:
    // Medium stock level: Defect to exploit current state
    action = D
  else:
    // Low stock level: Cooperate to replenish stock
    action = C

  // Adjust decision based on opponents' behavior
  opponent_cooperation_rate = Count(C) / n
  if opponent_cooperation_rate > 0.5:
    // Most opponents Cooperate: Increase likelihood of Defecting
    action = D with probability (opponent_cooperation_rate - 0.5)
  elif opponent_cooperation_rate < 0.5:
    // Most opponents Defect: Increase likelihood of Cooperating
    action = C with probability (0.5 - opponent_cooperation_rate)

  // Last round: Defect to maximize individual payoff
  if last_round:
    return D

  return action
```
This strategy balances short-term gains with long-term sustainability, adapting to the game's state and opponents' behavior to maximize individual payoffs.
'''

description_EXPLOITATIVE_12 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

This strategy aims to maximize payoffs by adapting to the game's dynamic state and opponents' behavior while prioritizing exploitation.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Observe the initial stock level and capacity.
	* Cooperate (C) if the initial stock is above 75% of capacity; otherwise, Defect (D).
2. **Subsequent Rounds (t>1):**
	* Evaluate the current stock level and opponents' previous actions.
	* Calculate the "Stock Depletion Ratio" (SDR):
		+ SDR = (previous_stock - current_stock) / previous_stock
	* Cooperate (C) if:
		- The SDR is below 0.25 (i.e., less than 25% stock depletion).
		- At least one opponent cooperated in the previous round.
	* Defect (D) otherwise.

Pseudocode for the decision rules:

```
if t == 1:  // Initial Round
    if initial_stock >= 0.75 * capacity:
        return C
    else:
        return D

else:  // Subsequent Rounds
    sdr = (previous_stock - current_stock) / previous_stock
    if sdr < 0.25 and any(opponent_cooperated_last_round):
        return C
    else:
        return D
```

**Edge Cases:**

1. **Last Round (t=r):**
	* Always Defect (D), as there's no future stock to conserve.
2. **Stock Level Very Low (<10% of capacity):**
	* Always Defect (D) to maximize remaining payoffs.

**Rationale:**

The Adaptive Stock Hawk strategy balances cooperation and defection based on the game's dynamic state and opponents' behavior. By cooperating when the stock depletion ratio is low and at least one opponent cooperated, this strategy encourages cooperation while minimizing the risk of over-exploitation.

By defecting in the last round or when the stock level is very low, the strategy maximizes remaining payoffs. This approach allows the Adaptive Stock Hawk to adapt to various opponents' behaviors and game scenarios, making it a robust exploitative strategy.

**Robustness:**

The Adaptive Stock Hawk strategy can handle a wide range of opponent behaviors, including:

* Cooperators: The strategy will cooperate when the stock depletion ratio is low, allowing for mutual cooperation.
* Defectors: The strategy will defect when the stock depletion ratio is high or no opponents cooperated, minimizing losses.
* Mixed Strategies: The Adaptive Stock Hawk will adapt to mixed strategies by cooperating or defecting based on the game's state and opponents' behavior.

This exploitative strategy is designed to perform well in a tournament setting against independent AI systems, without relying on norms or coordination mechanisms.
'''

description_EXPLOITATIVE_13 = '''
To design an exploitative strategy for this game, I propose a dynamic approach that adapts to the current state of the stock and the actions taken by other players in previous rounds.

**Strategy Name:** "Adaptive Stock Predator" (ASP)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about the initial stock level and opponent behavior.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Defect (D). This ensures maximum personal gain while maintaining a sustainable stock level.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) if the average opponent cooperation rate in previous rounds is above 0.5; otherwise, Defect (D).
	* If the current stock level is below 50% of capacity, Cooperate (C) to allow for stock replenishment.
3. **Last Round (t=r):** Defect (D), as there are no future consequences for overconsumption.

**Adaptive Component:**

1. Track the average opponent cooperation rate in previous rounds (AO_rate).
2. Update AO_rate after each round based on observed opponent actions.
3. Adjust the strategy according to the updated AO_rate, as described above.

**Pseudocode:**
```
Inputs:
  - capacity
  - stock_level (current)
  - n_players
  - t_round (current round number)
  - r_rounds (total rounds)
  - opponent_actions[] (array of opponent actions in previous rounds)

Outputs:
  - action (C or D)

1. if t_round == 1 then
    return C // Initial Round: Cooperate

2. AO_rate = calculate_average_opponent_cooperation_rate(opponent_actions)

3. if stock_level >= 0.75 * capacity then
    return D // Defect when stock is high

4. if stock_level >= 0.5 * capacity && stock_level < 0.75 * capacity then
    if AO_rate > 0.5 then
      return C // Cooperate with cooperating opponents
    else
      return D // Defect with defecting opponents

5. if stock_level < 0.5 * capacity then
    return C // Cooperate to allow for stock replenishment

6. if t_round == r_rounds then
    return D // Last Round: Defect

function calculate_average_opponent_cooperation_rate(opponent_actions):
  // Calculate average cooperation rate based on opponent actions in previous rounds
  cooperation_count = 0
  for action in opponent_actions:
    if action == C then
      cooperation_count += 1
  AO_rate = cooperation_count / (t_round - 1)
  return AO_rate
```
The Adaptive Stock Predator strategy is designed to be exploitative, adapting to the current state of the stock and the actions taken by other players. By cooperating when necessary and defecting when possible, ASP aims to maximize its own payoff while maintaining a sustainable stock level.
'''

description_EXPLOITATIVE_14 = '''
To develop an exploitative strategy for this Common Pool Resource Game, I'll outline a decision-making approach that adapts to the game's state and history, aiming to maximize payoffs while being robust against various opponent behaviors.

**Strategy Name:** Adaptive Stock Exploiter (ASE)

**Decision Rules:**

1. **Initial Round**: In the first round, ASE will Cooperate (C). This initial cooperation serves as a probe to gauge the opponents' behavior and gather information about their strategies.
2. **Assessing Opponent Behavior**: After the first round, ASE will analyze the game's history to identify patterns in opponents' actions. It will track the frequency of cooperation and defection for each opponent.
3. **Defection Threshold**: ASE will maintain a Defection Threshold (DT) value, initially set to 0.5. This threshold represents the proportion of opponents that must defect in a round for ASE to consider them uncooperative.
4. **Cooperation vs Defection**:
	* If the number of opponents who defected in the previous round is below the DT, ASE will Cooperate (C).
	* If the number of opponents who defected in the previous round meets or exceeds the DT, ASE will Defect (D).
5. **Adaptive Threshold Adjustment**: After each round, ASE will adjust its DT value based on the game's state and its own payoff. If ASE's payoff is below a certain threshold (e.g., 75% of the maximum possible payoff), it will decrease its DT by a small amount (e.g., 0.05). Conversely, if ASE's payoff is above this threshold, it will increase its DT by a similar amount.
6. **Edge Cases**:
	* In the last round, ASE will always Defect (D), as there are no future rounds to consider.
	* If the stock level falls below a certain threshold (e.g., 25% of capacity), ASE will Defect (D) in an attempt to maximize its payoff before the game ends.

**Pseudocode**:
```markdown
 Initialize:
    DT = 0.5  // Defection Threshold
    prev_round_defectors = 0

For each round:
    If first round:
        action = C  // Cooperate
    Else:
        opponents_defected = count(opponents who defected in previous round)
        If opponents_defected < DT * num_opponents:
            action = C  // Cooperate
        Else:
            action = D  // Defect

    Update DT based on payoff and game state:
    If payoff < 0.75 * max_payoff:
        DT -= 0.05
    ElseIf payoff > 0.75 * max_payoff:
        DT += 0.05

    Update prev_round_defectors for next round
```
**Rationale:**

ASE's strategy is designed to balance short-term gains with long-term sustainability. By initially cooperating, ASE gathers information about opponents' behavior and sets a baseline for its own cooperation. The Defection Threshold allows ASE to adapt to changing opponent behaviors and adjust its strategy accordingly.

By decreasing the DT when payoffs are low, ASE becomes more aggressive in exploiting uncooperative opponents. Conversely, increasing the DT when payoffs are high makes ASE more cautious and inclined to cooperate.

In edge cases, such as the last round or low stock levels, ASE prioritizes maximizing its payoff over long-term sustainability.

This strategy is exploitative by design, aiming to capitalize on opponents' cooperation while minimizing its own contributions to the common pool. Its adaptability and robustness make it a strong competitor in a tournament setting.
'''

description_EXPLOITATIVE_15 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to observe opponents' behavior and gather information about their strategies.
2. **Middle Rounds (2 ≤ t < r)**:
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term gain.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance individual gain with sustainability.
	* If the current stock level is below 50% of capacity, Cooperate (C) to prevent over-exploitation and ensure future payoffs.
3. **Final Round (t=r)**: Defect (D) to maximize final payoff, as there are no future rounds to consider.

**Adaptive Component:**

* Monitor opponents' behavior and adjust the strategy based on their actions:
	+ If most opponents (> 50%) cooperate, increase the likelihood of defecting in subsequent rounds.
	+ If most opponents (> 50%) defect, decrease the likelihood of cooperating in subsequent rounds.
* Use a simple moving average (SMA) to track the stock level over the last few rounds. Adjust the decision rules based on this SMA:
	+ If the SMA is increasing, be more likely to cooperate to sustain the trend.
	+ If the SMA is decreasing, be more likely to defect to maximize short-term gain.

**Edge Cases:**

* **Low Stock Levels**: If the stock level falls below 10% of capacity, Cooperate (C) to prevent over-exploitation and ensure some payoff in future rounds.
* **High Stock Levels**: If the stock level exceeds 90% of capacity, Defect (D) to maximize short-term gain.

**Pseudocode:**
```python
def adaptive_stock_raider(stock_level, round_number, opponent_actions):
    if round_number == 1:
        return Cooperate
    
    sma_window = 3  # Simple moving average window size
    sma = calculate_sma(stock_level, sma_window)
    
    if stock_level > 0.75 * capacity:
        return Defect
    elif stock_level >= 0.5 * capacity and stock_level <= 0.75 * capacity:
        return Cooperate
    else:
        return Defect
    
    # Adaptive component: adjust strategy based on opponents' behavior
    opponent_cooperation_rate = calculate_opponent_cooperation_rate(opponent_actions)
    if opponent_cooperation_rate > 0.5:
        increase_defection_likelihood()
    elif opponent_cooperation_rate < 0.5:
        decrease_cooperation_likelihood()
    
    # Adjust decision rules based on SMA trend
    if sma_trend_is_increasing():
        increase_cooperation_likelihood()
    else:
        decrease_cooperation_likelihood()

def calculate_sma(stock_level, window_size):
    # Calculate simple moving average of stock level over the last few rounds

def calculate_opponent_cooperation_rate(opponent_actions):
    # Calculate the proportion of opponents that cooperated in previous rounds
```
This strategy is designed to be exploitative, adaptive, and robust to a wide range of opponent behaviors. By monitoring opponents' actions and adjusting its own behavior accordingly, "Adaptive Stock Raider" aims to maximize its payoff while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_16 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

This strategy aims to maximize individual payoff by adaptively responding to the current stock level, opponent behavior, and game history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5. This allows for exploration of opponents' strategies while also avoiding excessive initial exploitation.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, Defect (D). This exploits the common pool when it's relatively full.
	* If the current stock level is between 50% and 75% of the capacity, Cooperate (C) with a probability proportional to the number of opponents who defected in the previous round. This adapts to the level of exploitation by others.
	* If the current stock level is below 50% of the capacity, Cooperate (C). This conserves the remaining stock and prepares for potential future growth.
3. **Opponent Defection Detection:** Monitor the number of opponents who defected in the previous round. If more than half of the opponents defected, increase the probability of defecting in the current round by 20%.
4. **Stock Growth Response:** If the stock level increases by more than 10% from the previous round, Cooperate (C) with a higher probability (e.g., 0.7). This responds to favorable growth conditions.
5. **Endgame Strategy (last 2 rounds):** Defect (D) if the current stock level is above 25% of the capacity. This maximizes individual payoff in the final rounds.

**Edge Cases:**

* If there's only one opponent, always Cooperate (C).
* In the last round, prioritize defecting to maximize individual payoff.

**Pseudocode:**
```
function AdaptiveStockHawk(stock_level, opponents_defected_prev_round, round_number, total_rounds):
  if round_number == 1:
    return random.choice([Cooperate, Defect]) with probability 0.5

  if stock_level > 0.75 * capacity:
    return Defect
  elif stock_level >= 0.5 * capacity and stock_level <= 0.75 * capacity:
    prob_coop = 1 - (opponents_defected_prev_round / n)
    return random.choice([Cooperate, Defect]) with probability prob_coop
  else:
    return Cooperate

  if opponents_defected_prev_round > n/2:
    increase defect probability by 20%

  if stock_growth > 10%:
    return Cooperate with probability 0.7

  if round_number >= total_rounds - 1 and stock_level > 0.25 * capacity:
    return Defect
```
This strategy combines elements of Tit-for-Tat, Grim Trigger, and adaptive response to the game state. It's designed to be robust against a wide range of opponent behaviors while maximizing individual payoff in a competitive environment.
'''

description_EXPLOITATIVE_17 = '''
To develop a robust and exploitative strategy for this Common Pool Resource Game, I'll introduce "Adaptive Exploiter" - a dynamic decision-making approach that balances short-term gains with long-term sustainability.

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to gather information about opponents' behaviors and avoid over-exploitation.
2. **Early Rounds**: For rounds 2-5, use a " Tit-for-Tat" variant:
	* If most players (>50%) defected in the previous round, defect (D).
	* Otherwise, cooperate (C).
3. **Mid-Game Adaptation**: After round 5, switch to a more adaptive approach:
	* Monitor opponents' cooperation rates over the last 3 rounds.
	* Calculate the "Cooperation Quotient" (CQ): average cooperation rate of all opponents except yourself.
	* If CQ > 0.6 (most players cooperate), play Cooperate (C).
	* If CQ < 0.4 (most players defect), play Defect (D).
	* Otherwise, play a mixed strategy:
		+ With probability 0.7, play Cooperate (C) if the current stock is above capacity/2.
		+ With probability 0.3, play Defect (D) regardless of the current stock.
4. **Endgame**: For the last 3 rounds, focus on maximizing personal payoffs:
	* If the current stock is below capacity/2, defect (D).
	* Otherwise, cooperate (C).

**Edge Cases:**

1. **Last Round**: In the final round, play Defect (D) to maximize your payoff.
2. **Low Stock**: When the current stock falls below capacity/4, always play Cooperate (C) to ensure some growth and maintain a sustainable resource.

**Additional Considerations:**

* Monitor the total consumption of all players in each round to adjust expectations about opponents' behaviors.
* Be prepared to adapt your strategy based on observed patterns or changes in opponents' actions.

Pseudocode:

```
def adaptive_exploiter(state, history):
    # Initial Round
    if current_round == 1:
        return "C"

    # Early Rounds (Tit-for-Tat)
    elif current_round <= 5:
        if most_players_defected(history):
            return "D"
        else:
            return "C"

    # Mid-Game Adaptation
    else:
        cooperation_quotient = calculate_cq(history)
        if cooperation_quotient > 0.6:
            return "C"
        elif cooperation_quotient < 0.4:
            return "D"
        else:
            current_stock = state["stock"]
            capacity_half = state["capacity"] / 2
            if random.random() < 0.7 and current_stock >= capacity_half:
                return "C"
            else:
                return "D"

    # Endgame
    if current_round > total_rounds - 3:
        current_stock = state["stock"]
        capacity_half = state["capacity"] / 2
        if current_stock < capacity_half:
            return "D"
        else:
            return "C"

    # Last Round
    elif current_round == total_rounds:
        return "D"

    # Low Stock
    elif current_stock < state["capacity"] / 4:
        return "C"
```

This Adaptive Exploiter strategy balances short-term gains with long-term sustainability by adapting to opponents' behaviors and the game's state. Its robustness comes from its ability to adjust expectations based on observed patterns, making it a formidable opponent in the tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_18 = '''
Here's a description of an exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Rounds**: In the first round, play Cooperate (C). This allows us to observe how others behave and sets a baseline for our subsequent actions.
2. **Assessing Opponent Behavior**: From Round 2 onwards, monitor the total consumption of all players in the previous round. If total consumption is less than or equal to half the capacity, it indicates that at least some opponents are cooperating. In this case, play Defect (D) to exploit their cooperation.
3. **Exploiting Weak Opponents**: If an opponent's payoff is consistently lower than the average payoff of all players over the past few rounds, identify them as a "weak" player. Play Defect (D) against weak opponents to maximize our gain.
4. **Conserving Stock**: When the stock level falls below a certain threshold (e.g., 25% of capacity), switch to Cooperate (C) to conserve the remaining stock and avoid depletion.
5. **Endgame Strategy**: In the last round, play Defect (D) regardless of previous actions, as there is no future penalty for over-consumption.

**Pseudocode:**
```
function AdaptiveExploiter(n, capacity, r, history):
  if current_round == 1:
    return C
  end

  total_consumption_prev = calculate_total_consumption(history)
  if total_consumption_prev <= capacity / 2:
    return D
  end

  weak_opponents = identify_weak_opponents(history)
  if opponent in weak_opponents:
    return D
  end

  stock_level = get_current_stock()
  if stock_level < 0.25 * capacity:
    return C
  end

  if current_round == r: // last round
    return D
  end

  return D // default action, exploit whenever possible
end
```
**Rationale:**

1. By initially cooperating, we create an opportunity for others to cooperate and build trust.
2. Assessing opponent behavior allows us to identify potential cooperators and exploit their trustworthiness.
3. Targeting weak opponents maximizes our gain while minimizing the risk of retaliation.
4. Conserving stock when levels are low ensures a stable environment for future exploitation.
5. In the endgame, there is no penalty for over-consumption, so we maximize our payoff by defecting.

**Robustness:**

1. The strategy adapts to various opponent behaviors, including cooperation and defection.
2. It handles edge cases, such as the first and last rounds, to optimize payoffs.
3. By identifying weak opponents, the strategy can exploit vulnerabilities in other players' strategies.

This Adaptive Exploiter strategy is designed to be robust and exploitative, capitalizing on opportunities to maximize our payoff while minimizing risks.
'''

description_EXPLOITATIVE_19 = '''
I'll design a exploitative strategy for this game that adapts to various opponent behaviors and maximizes my payoff. Here's the strategy:

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to observe the opponents' behavior and avoid over-exploiting the common pool.
2. **Early Rounds (t=2-5):** If the stock level is above 75% of capacity, defect (D). Otherwise, cooperate (C).
3. **Middle Game (t>5) - Opponent Behavior Assessment:**
	* Monitor opponents' actions for the past 3 rounds.
	* Calculate the average cooperation rate among all opponents (excluding myself): `avg_coop_rate = (# cooperative actions in last 3 rounds) / (3 * n)`
	* If `avg_coop_rate` is below 0.5, defect (D). This indicates that most opponents are already exploiting the common pool.
	* Otherwise, cooperate (C).
4. **Late Game (t=r-2 or later):** If the stock level is below 25% of capacity, cooperate (C) to avoid complete depletion.

**Pseudocode:**
```markdown
# Initialize variables
stock_level = initial_stock
round_num = 1
avg_coop_rate = 0.5

while round_num <= r:
    # Initial Round
    if round_num == 1:
        action = C
    
    # Early Rounds
    elif round_num < 6:
        if stock_level > 0.75 * capacity:
            action = D
        else:
            action = C
    
    # Middle Game - Opponent Behavior Assessment
    else:
        opponents_coop_count = 0
        for opponent in range(1, n):
            if opponents[opponent].action_history[-3:] == [C, C, C]:
                opponents_coop_count += 1
        
        avg_coop_rate = opponents_coop_count / (3 * n)
        
        if avg_coop_rate < 0.5:
            action = D
        else:
            action = C
    
    # Late Game
    elif round_num >= r - 2 and stock_level < 0.25 * capacity:
        action = C

    # Update game state
    consume_stock(action)
    update_stock_level()
    
    # Increment round number
    round_num += 1
```
**Rationale:**

* By cooperating in the first round, I gather information about opponents' behavior and avoid initial over-exploitation.
* In early rounds, defecting when the stock level is high allows me to take advantage of the common pool's growth. Cooperating when the stock level is low helps maintain a healthy stock for future rounds.
* By monitoring opponents' cooperation rates in middle rounds, I adapt my strategy to counter exploitation by others. If most opponents are already exploiting, I join them; otherwise, I cooperate to maintain the common pool.
* In late rounds, cooperating when the stock level is critically low ensures that some stock remains for future rounds.

This adaptive strategy balances short-term gains with long-term sustainability, allowing me to exploit opponents' behaviors while maintaining a healthy common pool.
'''

description_EXPLOITATIVE_20 = '''
Here's a exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and to avoid over-exploitation.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of the capacity, Defect (D). This encourages exploitation when the resource is abundant.
	* If the current stock level is between 50% and 75% of the capacity, Cooperate (C) with a probability of 0.5 (randomly choose between C and D). This introduces uncertainty and adapts to potential changes in opponents' behaviors.
	* If the current stock level is below 50% of the capacity, Defect (D). This prioritizes individual payoffs when the resource is scarce.
3. **Final Round (t=r):** Defect (D) to maximize individual payoff, as there are no future consequences.

**Additional Adaptations:**

1. **Monitor Opponents' Behaviors:** Track the frequency of opponents' cooperation and defection in previous rounds. If an opponent has cooperated more than 75% of the time, assume they are a "Cooperator" and Defect (D) against them to exploit their generosity.
2. **Punish Unconditional Cooperators:** If an opponent always cooperates, Defect (D) against them in all subsequent rounds to take advantage of their predictable behavior.
3. **Respond to Greedy Opponents:** If the average consumption per player is above 75% of the capacity, assume there are "Greedy" opponents and Cooperate (C) with a higher probability (0.7) to avoid over-exploitation.

**Pseudocode:**
```markdown
# Initialize variables
stock_level = capacity
opponent_behaviors = []
cooperator_threshold = 0.75

# Loop through rounds
for t in range(1, r+1):
    # Initial round: Cooperate
    if t == 1:
        action = 'C'
    
    # Middle rounds: Adaptive decision-making
    elif 2 <= t < r:
        if stock_level > capacity * 0.75:
            action = 'D'  # Exploit abundant resource
        elif stock_level >= capacity * 0.5 and stock_level <= capacity * 0.75:
            action = random.choice(['C', 'D'])  # Introduce uncertainty
        else:
            action = 'D'  # Prioritize individual payoff when scarce
    
    # Final round: Defect
    elif t == r:
        action = 'D'
    
    # Monitor opponents' behaviors and adapt
    if opponent_behaviors:
        for opponent in opponent_behaviors:
            if opponent['cooperation_rate'] > cooperator_threshold:
                action = 'D'  # Exploit cooperative opponents
    
    # Take action and update stock level
    consume_stock(action)
    stock_level -= total_consumption
    stock_level += calculate_growth(stock_level, capacity)

# Update opponent behaviors for next round
opponent_behaviors.append({'cooperation_rate': calculate_cooperation_rate(opponents_actions)})
```
This strategy aims to balance exploitation with adaptability, responding to changes in the game state and opponents' behaviors. By monitoring opponents' actions and adjusting its own behavior accordingly, Adaptive Exploiter (AE) seeks to maximize individual payoffs while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_21 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoff by adaptively responding to the game state and history of opponent actions.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' initial behaviors.
2. **Stock Assessment**: Evaluate the current stock level (S) relative to the capacity:
	* If S > 0.75 × capacity, Defect (D). The stock is relatively abundant, and defecting will yield a higher payoff.
	* If S ≤ 0.75 × capacity, Cooperate (C). The stock is relatively scarce, and cooperating will help maintain a sustainable level.
3. **Opponent Behavior Analysis**: Analyze the previous round's actions:
	* If most opponents (> 50%) Defected in the previous round, Defect in this round. This indicates that opponents are likely to prioritize short-term gains over cooperation.
	* If most opponents (> 50%) Cooperated in the previous round, Cooperate in this round. This suggests that opponents may be willing to cooperate, and reciprocating can lead to mutual benefits.
4. **Recent Payoff Trend**: Evaluate the trend of recent payoffs:
	* If payoffs have been increasing or stable over the last few rounds, maintain the current action (C or D).
	* If payoffs have been decreasing, switch actions (from C to D or vice versa). This helps adapt to changing opponent behaviors and game state.
5. **Last Round**: In the final round, Defect (D) regardless of previous actions. This maximizes individual payoff in the last opportunity.

**Pseudocode:**
```markdown
# Initialize variables
stock = capacity
round_num = 0
payoff_history = []
opponent_actions = []

while round_num < r:
    # Initial Round
    if round_num == 0:
        action = C
    else:
        # Stock Assessment
        if stock > 0.75 * capacity:
            action = D
        elif stock <= 0.75 * capacity:
            action = C
        
        # Opponent Behavior Analysis
        opponent_defections = sum(opponent_actions[-1])
        if opponent_defections > n / 2:
            action = D
        else:
            action = C
        
        # Recent Payoff Trend
        recent_payoffs = payoff_history[-3:]
        if len(recent_payoffs) >= 3 and recent_payoffs[-1] <= recent_payoffs[-2]:
            action = opposite_action(action)
    
    # Last Round
    if round_num == r - 1:
        action = D
    
    # Update variables
    opponent_actions.append(opponent_actions_history[round_num])
    payoff_history.append(calculate_payoff(stock, action))
    stock = update_stock(stock, action, opponent_actions[-1])
    
    round_num += 1
```
This strategy is designed to be adaptive and exploitative, taking into account the game state, history of opponent actions, and recent payoff trends. By responding to these factors, "Adaptive Stock Raider" aims to maximize individual payoffs while being robust to a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_22 = '''
To develop a robust and exploitative strategy for this Common Pool Resource Game, I propose " Adaptive Exploitation with Stock Awareness" (AESA). This strategy focuses on maximizing individual payoffs while adapting to changing stock levels and opponent behaviors.

**Decision Rules:**

1. **Initial Round:** In the first round, play C (Cooperate) to gather information about opponents' initial moves and set a baseline for future adaptations.
2. **Stock-dependent Strategy:**
	* If the current stock level is high (> capacity/2), play D (Defect) to maximize short-term gains, as the resource can sustain higher consumption rates.
	* If the current stock level is low (≤ capacity/2), play C (Cooperate) to conserve resources and prevent over-depletion, which may lead to reduced future payoffs.
3. **Opponent Behavior Adaptation:**
	* Monitor opponents' actions in previous rounds and maintain a simple "defection rate" metric for each opponent (number of Ds played / total rounds).
	* If an opponent's defection rate exceeds 0.5, consider them a "habitual defector." When interacting with habitual defectors:
		+ Play D if the current stock level is high (> capacity/2) to counter-exploit.
		+ Play C if the current stock level is low (≤ capacity/2) to minimize losses and encourage cooperation.
4. **Self-protection Mechanism:**
	* If your own payoffs have been consistently lower than the average payoff of opponents, switch to playing D for 2-3 rounds to signal a willingness to adapt and potentially reset opponent strategies.

**Edge Cases:**

1. **Last Round:** In the final round, play D (Defect) regardless of stock levels or opponent behaviors, as there are no future consequences.
2. **Ties in Stock Levels:** If multiple opponents have played C or D with equal payoffs, use a simple randomization mechanism to break ties and decide your next action.

**Pseudocode:**
```python
def AESA(current_stock, capacity, num_opponents, round_num, history):
    # Initialize variables
    defect_rate = [0.0] * num_opponents

    if round_num == 1:
        return 'C'  # Cooperate in the first round

    for opponent in range(num_opponents):
        defect_rate[opponent] = (history[opponent].count('D')) / round_num

    habitual_defectors = [opponent for opponent, rate in enumerate(defect_rate) if rate > 0.5]

    if current_stock > capacity/2:
        # High stock level
        if len(habitual_defectors) == 0:
            return 'D'  # Defect when no habitual defectors
        else:
            return 'C'  # Cooperate with some habitual defectors

    elif current_stock <= capacity/2:
        # Low stock level
        if len(habitual_defectors) > 0:
            return 'C'  # Cooperate to minimize losses
        else:
            return 'D'  # Defect when no habitual defectors

    if self.payoffs < average_opponent_payoff:
        # Self-protection mechanism
        return 'D' for 2-3 rounds
```
AESA is designed to adapt to changing stock levels and opponent behaviors while prioritizing individual payoffs. By incorporating a defection rate metric, it identifies habitual defectors and adjusts its strategy accordingly. The self-protection mechanism helps prevent persistent exploitation by switching to defecting when own payoffs are below average.

This exploitative strategy is prepared for the tournament against independent AI systems, as it does not rely on shared norms or coordination mechanisms.
'''

description_EXPLOITATIVE_23 = '''
**Exploitative Strategy: "Adaptive Stock-Dependent Defection" (ASDD)**

Decision Rules:

1. **First Round**: Cooperate (C) to gather information about opponents' behaviors and initial stock levels.
2. **Subsequent Rounds**: Observe the current stock level (S) and the number of rounds remaining (r - t + 1), where t is the current round.

   * If S < capacity/2, Defect (D). This ensures maximum payoff when the stock is low, as cooperation would lead to lower payoffs.
   
   * If S ≥ capacity/2 and the number of cooperators in the previous round is less than n/2, Defect (D). This takes advantage of opponents' willingness to cooperate when the stock is high, maximizing personal gain.

   * If S ≥ capacity/2 and the number of cooperators in the previous round is at least n/2, Cooperate (C) with a probability p, where p = (S - capacity/2) / (capacity/2). This adaptive cooperation strategy encourages others to cooperate while maintaining a level of defection to exploit over-cooperation.

   * If S ≥ capacity/2 and the number of cooperators in the previous round is exactly n/2, Cooperate (C) with probability 0.5. This balances exploitation and cooperation when opponents are evenly split between cooperating and defecting.

3. **Last Round**: Always Defect (D), as there's no future stock to conserve or potential for retaliation.

Edge Cases:

* If the number of rounds remaining is only one, prioritize short-term gain by Defecting (D) unless the current stock level is very low, in which case Cooperate (C) to avoid depleting the stock completely.
* In cases where multiple conditions are met, prioritize the rule that leads to Defection (D), as this strategy aims to exploit opponents.

Pseudocode:
```
function ASDD(n, capacity, r, t, S, previous_round_cooperators):
  if t == 1:  # First Round
    return C

  elif S < capacity/2:
    return D

  elif S >= capacity/2 and previous_round_cooperators < n/2:
    return D

  elif S >= capacity/2 and previous_round_cooperators >= n/2:
    p = (S - capacity/2) / (capacity/2)
    if random() < p:
      return C
    else:
      return D

  elif S >= capacity/2 and previous_round_cooperators == n/2:
    if random() < 0.5:
      return C
    else:
      return D

  elif t == r:  # Last Round
    return D

  else:
    return D  # Default to Defection in other cases
```
This strategy adapts to the game's state and opponents' behaviors, balancing short-term gains with potential long-term benefits from cooperation. By being responsive to changes in stock levels and opponent actions, ASDD aims to exploit a wide range of strategies while minimizing vulnerability to exploitation itself.
'''

description_EXPLOITATIVE_24 = '''
**Exploitative Strategy: Adaptive Stock Depletion (ASD)**

The ASD strategy aims to maximize individual payoff by adaptively responding to the game state and opponent behavior.

**Decision Rules**

1. **Initial Round (t=1)**:
Cooperate (C) in the first round to observe opponents' actions and initial stock consumption.
2. **Middle Rounds (1 < t < r)**:
Calculate the average opponent cooperation rate (OCR) from previous rounds:

OCR = (∑(opponent C actions)) / (n \* (t-1))

If OCR > 0.5, cooperate (C). Otherwise, defect (D).
3. **Last Round (t=r)**:
Defect (D), as there are no future rounds to consider.
4. **Critical Stock Levels**:

Monitor the current stock level and adjust strategy accordingly:

* If stock ≤ capacity / 2, cooperate (C) to conserve resources and encourage opponent cooperation.
* If stock > capacity / 2, defect (D) to maximize individual payoff.

**Additional Heuristics**

1. **Opponent Defection Detection**:
Monitor opponents' actions for repeated defection (e.g., 3 consecutive D actions). If detected, switch to defect (D) to counter-exploit.
2. **Stock Growth Monitoring**:
Track the stock growth rate over previous rounds. If the growth rate is consistently low (< 20%), cooperate (C) to stimulate growth.

**Pseudocode**

```
ASD_Strategy(n, capacity, r, current_stock, opponent_actions):
  if t == 1:  // Initial round
    return C
  else:
    OCR = calculate_average_opponent_cooperation_rate(opponent_actions)
    if OCR > 0.5 or current_stock <= capacity / 2:
      return C
    elif t == r:  // Last round
      return D
    elif detect_repeated_defection(opponent_actions):
      return D
    else:
      return D

calculate_average_opponent_cooperation_rate(opponent_actions):
  // Calculate OCR from previous rounds
  sum_C = 0
  for each opponent in opponents:
    sum_C += count of C actions by opponent
  OCR = sum_C / (n * (t-1))
  return OCR

detect_repeated_defection(opponent_actions):
  // Monitor for repeated defection (e.g., 3 consecutive D actions)
  for each opponent in opponents:
    if count of consecutive D actions >= 3:
      return True
  return False
```

The ASD strategy is designed to be adaptive, robust, and exploitative. By responding to the game state and opponent behavior, it aims to maximize individual payoff while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_25 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit a wide range of opponent behaviors while adapting to changes in the game state and history.

**Decision Rules:**

1. **Initial Round (t=1)**: Defect (D) - This allows us to immediately gauge the opponents' behavior and set the tone for the game.
2. **Opponent Analysis**: After each round, analyze the opponents' actions:
	* If most opponents (> 50%) cooperated in the previous round, defect (D) in the next round to exploit their cooperation.
	* If most opponents (> 50%) defected in the previous round, cooperate (C) in the next round to rebuild the stock and create an opportunity for exploitation.
3. **Stock-Level Based Switching**: Monitor the current stock level:
	* If the stock level is low (< capacity/2), cooperate (C) to help rebuild the stock and prevent collapse.
	* If the stock level is high (> 3/4 \* capacity), defect (D) to exploit the abundant resource.
4. **Adaptive Threshold**: Introduce an adaptive threshold, α, which adjusts based on the game history:
	* Initialize α = 0.5 (neutral value)
	* After each round, update α as follows:
		+ If most opponents (> 50%) cooperated and the stock level increased, increase α by 0.1
		+ If most opponents (> 50%) defected and the stock level decreased, decrease α by 0.1
	* Use α to adjust the decision rules: if α > 0.7, cooperate (C); if α < 0.3, defect (D)
5. **Last Round (t=r)**: Defect (D) - In the final round, there is no need to worry about future consequences, so maximize immediate payoff.

**Pseudocode**
```python
def adaptive_predator(n, r, capacity, stock):
    # Initialize variables
    alpha = 0.5
    opponents_cooperated = False

    for t in range(1, r+1):
        if t == 1:
            action = 'D'  # Defect in the first round
        else:
            # Analyze opponents' actions from previous round
            if opponents_cooperated:
                action = 'D'
            else:
                action = 'C'

            # Stock-level based switching
            if stock < capacity/2:
                action = 'C'
            elif stock > 3/4 * capacity:
                action = 'D'

            # Adaptive threshold
            if alpha > 0.7:
                action = 'C'
            elif alpha < 0.3:
                action = 'D'

        # Update opponents_cooperated and alpha
        opponents_cooperated = (sum(opponents_actions) / n) > 0.5
        if opponents_cooperated and stock > previous_stock:
            alpha += 0.1
        elif not opponents_cooperated and stock < previous_stock:
            alpha -= 0.1

        # Take action and update game state
        if action == 'D':
            consumption = stock / n
        else:
            consumption = stock / (2 * n)
        new_stock = min(stock - consumption + growth, capacity)

    return action
```
The Adaptive Predator strategy combines elements of exploitation, adaptation, and robustness to handle a wide range of opponent behaviors. By analyzing the game state and history, it adjusts its decision rules to maximize payoffs while minimizing the risk of stock collapse.
'''

description_EXPLOITATIVE_26 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider is a dynamic and opportunistic strategy designed to maximize payoffs by exploiting the common pool resource game's mechanics and adapting to the behavior of other players.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about the initial stock level and opponents' behaviors.
2. **Middle Rounds (2 ≤ t < r)**:
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize short-term gains, as the stock growth will likely compensate for the exploitation.
	* If the current stock level is between 25% and 75% of the capacity, use a Mixed Strategy: Cooperate with probability p and Defect with probability (1-p), where p = (current_stock / capacity) ^ 2. This balances short-term gains with long-term sustainability.
	* If the current stock level is below 25% of the capacity, Cooperate (C) to conserve resources and allow for potential growth in future rounds.
3. **Last Round (t=r)**: Defect (D) to maximize final-round payoffs, as there's no need to consider long-term sustainability.

**Additional Heuristics:**

* **Opponent Monitoring**: Track the number of opponents who Cooperated or Defected in previous rounds. If most opponents are Cooperating, increase the probability of Defecting in future rounds.
* **Stock Level Trend Analysis**: Monitor the stock level trend over the past few rounds. If the trend is decreasing, increase the probability of Cooperating to conserve resources.

**Pseudocode:**
```python
def adaptive_stock_raider(current_stock, capacity, round_number, total_rounds):
    if round_number == 1:
        return 'C'  # Cooperate in initial round

    stock_ratio = current_stock / capacity

    if stock_ratio > 0.75:
        return 'D'  # Defect when stock is high
    elif stock_ratio >= 0.25 and stock_ratio <= 0.75:
        p = (stock_ratio) ** 2
        return 'C' if random.random() < p else 'D'  # Mixed Strategy
    else:
        return 'C'  # Cooperate when stock is low

    if round_number == total_rounds:
        return 'D'  # Defect in last round

# Monitor opponent behavior and adjust strategy accordingly
opponent_behavior = []
for t in range(1, total_rounds + 1):
    action = adaptive_stock_raider(current_stock[t], capacity, t, total_rounds)
    opponent_behavior.append(action)  # Update opponent behavior history
```
**Rationale:**

The Adaptive Stock Raider strategy balances short-term gains with long-term sustainability by adapting to the current stock level and opponents' behaviors. By monitoring the stock level trend and opponents' actions, the strategy can adjust its probability of Cooperating or Defecting to maximize payoffs.

This exploitative strategy is designed to perform well in a tournament setting against independent strategies developed by other AI systems, without relying on cooperation schedules or predetermined patterns.
'''

description_EXPLOITATIVE_27 = '''
Here's a strategic approach for the Common Pool Resource Game that prioritizes exploitation while adapting to various opponent behaviors:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and avoid immediate stock depletion.
2. **Current Stock Threshold**: Calculate a threshold value, `threshold`, based on the current stock level (`S`) and the capacity (`capacity`). Set `threshold` to 0.75 \* `capacity`.
3. **Opponent Behavior Assessment**: After the first round, assess opponents' behavior by tracking the total consumption in each previous round. If total consumption is consistently below a certain percentage of the capacity (e.g., 50%), assume opponents are cooperative and defect (D) to maximize payoffs.
4. **Exploitation Phase**: Once `S` falls below `threshold`, switch to an exploitative strategy:
	* Defect (D) if at least one opponent defected in the previous round or if total consumption was above 50% of the capacity.
	* Cooperate (C) otherwise, to maintain a moderate stock level and avoid over-exploitation.
5. **Last Round**: In the final round, defect (D) regardless of the current stock level or opponents' behavior, as there are no future consequences for exploitation.

**Edge Cases:**

1. If an opponent defects in every round, adapt by consistently cooperating to minimize losses and maintain a stable stock level.
2. If multiple opponents employ a similar exploitative strategy, prioritize cooperation (C) when `S` is above `threshold` to avoid mutual over-exploitation.

**Pseudocode:**
```markdown
# Initialize variables
n = number of players
r = number of rounds
capacity = maximum sustainable stock level
stock = current stock level
history = array to store previous round's consumption

# First Round
if (round == 1) {
    action = C
} else {
    # Assess opponent behavior and adjust strategy
    total_consumption = sum(history)
    if (total_consumption < 0.5 * capacity) {
        # Opponents are cooperative, defect to maximize payoffs
        action = D
    } else {
        # Calculate threshold value
        threshold = 0.75 * capacity

        # Check current stock level and adjust strategy
        if (stock <= threshold) {
            # Exploitation phase
            if (any opponent defected in previous round or total_consumption > 0.5 * capacity) {
                action = D
            } else {
                action = C
            }
        } else {
            # Maintain a moderate stock level
            action = C
        }
    }
}

# Last Round
if (round == r) {
    action = D
}
```
**Rationale:**

1. The initial cooperative behavior allows the AE strategy to gather information about opponents' actions and avoid immediate stock depletion.
2. By assessing opponent behavior, AE adapts its strategy to maximize payoffs in situations where opponents are consistently cooperative or exploitative.
3. The exploitation phase balances short-term gains with long-term sustainability by considering both current stock levels and opponents' behavior.
4. Defecting in the last round ensures maximum payoffs, as there are no future consequences for over-exploitation.

The Adaptive Exploiter strategy aims to effectively balance short-term gains with long-term sustainability while exploiting various opponent behaviors.
'''

description_EXPLOITATIVE_28 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adaptively responding to the game's state and history, while exploiting potential weaknesses in opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe the initial stock level and calculate the maximum possible consumption per player if all cooperate (stock / (2n)).
	* If this value is greater than or equal to the capacity / (4n), play C (Cooperate). Otherwise, play D (Defect).
2. **Subsequent Rounds (t > 1)**:
	* Calculate the average stock growth rate over the previous rounds: `avg_growth = (current_stock - initial_stock) / (t - 1)`
	* If `avg_growth` is positive and greater than a threshold (`growth_threshold = capacity / (4n)`), play C.
	* Otherwise, play D.

Pseudocode:
```
if t == 1:
    max_coop_consumption = stock / (2 * n)
    if max_coop_consumption >= capacity / (4 * n):
        action = C
    else:
        action = D
else:
    avg_growth = (current_stock - initial_stock) / (t - 1)
    if avg_growth > growth_threshold:
        action = C
    else:
        action = D
```
**Edge Cases:**

* **Last Round (t=r)**: Play D, as there is no future stock to conserve.
* **Low Stock Levels**: If the current stock level falls below a certain threshold (`low_stock_threshold = capacity / (2n)`), play D to maximize short-term gains.

**Adaptive Component:**

* **Stock Growth Tracking**: Continuously update `avg_growth` and adjust the strategy based on changes in stock growth rate.
* **Opponent Behavior Analysis**: Observe opponents' actions and payoffs. If a significant number of opponents consistently cooperate, consider switching to D to exploit their cooperative behavior.

**Robustness:**

* **Initial Stock Levels**: The strategy is designed to perform well across various initial stock levels, as it adapts to the game's state and history.
* **Opponent Strategies**: By responding to changes in stock growth rate and opponent behavior, the Adaptive Stock Raider strategy can effectively counter a wide range of opponent strategies.

By following this exploitative strategy, you will be able to maximize your payoffs while adapting to the dynamic game environment and potential weaknesses in opponents' behaviors.
'''

description_EXPLOITATIVE_29 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk strategy aims to balance short-term gains with long-term sustainability by adapting to the current state of the stock and the observed behavior of opponents.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gather information about opponents' initial moves.
2. **Early Rounds (2 ≤ t < r/2):**
	* If the current stock level is above 75% of capacity, Defect (D) to exploit the stock's abundance.
	* Otherwise, Cooperate (C) to conserve the stock for future rounds.
3. **Mid-Game (r/2 ≤ t < r):**
	* Monitor opponents' behavior: count the number of players who Defected in the previous round (D_prev).
	* If D_prev ≥ n/2, Defect (D) to take advantage of the opponents' aggressive strategy.
	* Otherwise, Cooperate (C) to maintain a balance between consumption and conservation.
4. **Final Rounds (t ≥ r - 2):**
	* If the current stock level is below 25% of capacity, Cooperate (C) to ensure some remaining payoff.
	* Otherwise, Defect (D) to maximize short-term gains.

**Edge Cases:**

1. **Low Stock:** If the current stock level falls below 10% of capacity at any point, Cooperate (C) for the remainder of the game to avoid depletion.
2. **Last Round (t=r):** Always Defect (D) in the final round to maximize the last payoff.

**Pseudocode:**
```markdown
# Initialize variables
n = number of players
capacity = maximum sustainable stock level
stock_history = []  # stores stock levels for each round

# Main game loop
for t = 1 to r:
    current_stock = get_current_stock()
    opponents_defected_prev = count_opponents_defected(t-1)
    
    if t == 1:  # Initial round
        action = C
    elif 2 <= t < r/2:  # Early rounds
        if current_stock > 0.75 * capacity:
            action = D
        else:
            action = C
    elif r/2 <= t < r:  # Mid-game
        if opponents_defected_prev >= n/2:
            action = D
        else:
            action = C
    else:  # Final rounds
        if current_stock < 0.25 * capacity:
            action = C
        else:
            action = D
    
    # Last round exception
    if t == r:
        action = D
    
    take_action(action)
    
    # Update stock history and opponents' behavior
    stock_history.append(current_stock)
```
The Adaptive Stock Hawk strategy is designed to adapt to the dynamic state of the game, balancing short-term gains with long-term sustainability. By monitoring opponents' behavior and adjusting its actions accordingly, this strategy aims to outperform a wide range of opponent behaviors in a tournament setting.
'''

description_EXPLOITATIVE_30 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

This strategy aims to exploit the opponent's behavior while adapting to the dynamic state of the game.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' initial behaviors and avoid early depletion of the stock.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is below 50% of the capacity, Defect (D) to maximize individual payoff, as cooperation would lead to minimal payoffs.
	* If the current stock level is above 50% of the capacity:
		+ Cooperate (C) if the average opponent payoff in the previous round was higher than the player's own payoff. This indicates that opponents are cooperating, and our cooperation can help maintain a healthy stock level.
		+ Defect (D) otherwise. If opponents' payoffs were lower or similar to ours, it suggests they are defecting or playing a mixed strategy. In this case, we should exploit the situation by defecting.
3. **Last Round (t=r):** Defect (D) to maximize individual payoff, as there is no future game state to consider.

**Additional Logic:**

* **Opponent Behavior Analysis:** Track the average opponent payoff in each round to gauge their overall strategy. This information helps inform our decision-making process.
* **Stock Level Monitoring:** Continuously monitor the current stock level and adjust our strategy accordingly.
* **Payoff Comparison:** Compare our own payoff with the average opponent payoff to determine whether cooperation or defection is more beneficial.

**Pseudocode:**
```python
def Adaptive_Stock_Hawk(n, capacity, r, current_stock, history):
    if t == 1:
        return Cooperate
    else:
        avg_opponent_payoff = calculate_avg_opponent_payoff(history)
        if current_stock < 0.5 * capacity:
            return Defect
        elif avg_opponent_payoff > own_payoff(history):
            return Cooperate
        else:
            return Defect

def calculate_avg_opponent_payoff(history):
    # Calculate the average payoff of all opponents in the previous round
    opponent_payoffs = [payoff for payoff in history[-1] if payoff != own_payoff]
    return sum(opponent_payoffs) / len(opponent_payoffs)
```
**Rationale:**

The Adaptive Stock Hawk strategy balances short-term gains with long-term sustainability. By cooperating initially and adapting to the opponents' behavior, we can:

* Gather information about opponents' strategies
* Maintain a healthy stock level when possible
* Exploit situations where opponents are cooperating or playing a mixed strategy
* Maximize individual payoffs in the final round

This exploitative strategy is designed to perform well against a wide range of opponent behaviors, making it suitable for a tournament setting.
'''

description_EXPLOITATIVE_31 = '''
**Exploitative Strategy: "Adaptive Stock Guardian"**

The Adaptive Stock Guardian strategy aims to balance short-term gains with long-term sustainability of the common pool resource. This strategy adapts to the game's state and history, exploiting opponents' behaviors while ensuring a stable stock level.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline for the game's progression.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize short-term gains.
	* If the current stock level is between 25% and 75% of the capacity, Cooperate (C) to maintain a stable stock level.
	* If the current stock level is below 25% of the capacity, Defect (D) to capitalize on the remaining stock before it depletes further.
3. **Opponent Behavior Adaptation:**
	* Monitor the average opponent payoff per round ( OPP_avg ) and compare it to the player's own average payoff per round ( P_avg ).
	* If OPP_avg > P_avg , increase cooperation probability by 10% in the next round to reduce stock depletion.
	* If OPP_avg < P_avg , decrease cooperation probability by 10% in the next round to exploit opponents' cooperation.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) to maximize final-round payoffs, as there is no future game state to consider.
2. **Low Stock Levels:** If the stock level falls below 10% of the capacity, Cooperate (C) in all subsequent rounds to prevent complete depletion.

**Pseudocode:**
```python
def AdaptiveStockGuardian(game_state, history):
    # Initialize variables
    capacity = game_state['capacity']
    current_stock = game_state['stock']
    n_players = game_state['n']
    t = game_state['round']

    # Initial round cooperation
    if t == 1:
        return 'C'

    # Calculate opponent behavior adaptation
    OPP_avg = calculate_opponent_average_payoff(history)
    P_avg = calculate_player_average_payoff(history)
    cooperation_probability = 0.5

    if OPP_avg > P_avg:
        cooperation_probability += 0.1
    elif OPP_avg < P_avg:
        cooperation_probability -= 0.1

    # Apply decision rules
    if current_stock / capacity >= 0.75:
        return 'D'
    elif 0.25 <= current_stock / capacity < 0.75:
        return 'C' if random.random() < cooperation_probability else 'D'
    else:
        return 'D'

    # Handle edge cases
    if t == game_state['r']:
        return 'D'
    elif current_stock / capacity < 0.1:
        return 'C'
```
This strategy balances short-term gains with long-term sustainability, adapting to opponents' behaviors and the game's state. By monitoring opponent payoffs and adjusting cooperation probability accordingly, the Adaptive Stock Guardian exploits opponents' cooperation while ensuring a stable stock level.
'''

description_EXPLOITATIVE_32 = '''
To design a robust and exploitative strategy for this Common Pool Resource Game, I propose the "Adaptive Stock-Dependent Exploitation" (ASDE) strategy.

**Decision Rules:**

1. **Initial Round:** In the first round, play Cooperate (C). This allows us to observe the initial actions of other players and gather information about their strategies.
2. **Subsequent Rounds:** For each subsequent round t, calculate the "Stock Utilization Ratio" (SUR) as follows:

SUR = (current_stock / capacity)

If SUR < 0.5, play Defect (D). This is because when the stock level is low, it's more beneficial to exploit the remaining resources.

If SUR ≥ 0.5, use a hybrid approach:
	* If at least one opponent defected in the previous round, play Defect (D) to punish them and protect our own payoff.
	* Otherwise, play Cooperate (C) to maintain a stable stock level and encourage cooperation from other players.

**Additional Considerations:**

1. **Last Round:** In the final round r, play Defect (D) regardless of the current stock level or opponents' actions. This ensures we maximize our payoff in the last round.
2. **Opponent Identification:** Keep track of each opponent's actions and identify those who consistently cooperate or defect. Use this information to adjust our strategy:
	* If an opponent is identified as a consistent cooperator, play Defect (D) against them to exploit their cooperation.
	* If an opponent is identified as a consistent defector, play Cooperate (C) against them to minimize losses.

**Pseudocode:**
```
Function ASDE(current_stock, capacity, round, opponents_actions):
  if round == 1:
    return COOPERATE
  else:
    SUR = current_stock / capacity
    if SUR < 0.5:
      return DEFECT
    else:
      if any(opponent_defected in opponents_actions[-1]):
        return DEFECT
      else:
        return COOPERATE

Function play_last_round():
  return DEFECT

Function identify_opponents(opponents_actions):
  # Identify consistent cooperators and defectors based on their actions
  # Use this information to adjust the strategy accordingly
```
**Rationale:**

The ASDE strategy is designed to be exploitative by taking advantage of the game's dynamics and opponents' behaviors. By playing Cooperate initially, we gather information about other players' strategies and adapt our approach accordingly.

When the stock level is low (SUR < 0.5), we play Defect to maximize our payoff in that round. When the stock level is moderate or high, we use a hybrid approach that balances cooperation and defection based on opponents' actions.

By identifying consistent cooperators and defectors, we can adjust our strategy to exploit their weaknesses and minimize losses.

Overall, ASDE is an adaptive and robust strategy that aligns with the exploitative mindset required for this tournament.
'''

description_EXPLOITATIVE_33 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The ASR strategy is designed to exploit opponents by adaptively adjusting its behavior based on the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5. This initial cooperation serves as a probe to gauge opponents' behaviors.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of the capacity, Defect (D). The high stock level indicates that opponents are likely cooperating, making it profitable to defect.
	* If the stock level is between 25% and 75% of the capacity:
		+ Cooperate if the average opponent payoff in the previous round was below the average cooperation payoff (i.e., stock/(2n)). This suggests opponents are not exploiting the common pool aggressively, making cooperation a safer choice.
		+ Defect otherwise. If opponents' payoffs were high, it indicates they are likely defecting, and you should too to avoid being exploited.
	* If the stock level is below 25% of the capacity, Cooperate. At this point, the common pool is severely depleted, and cooperation is necessary to allow for some growth and potential future exploitation.

**Handling Edge Cases:**

1. **Last Round (t=r):** Always Defect. In the final round, there's no future gain from cooperation, so exploiting the remaining stock is optimal.
2. **Stock Level at Capacity:** If the stock level reaches capacity, Cooperate in the next round to allow for growth and maintain a healthy common pool.

**Pseudocode:**
```python
def ASR(n, r, capacity, current_stock, history):
    if t == 1:
        return C with probability 0.5

    if current_stock >= 0.75 * capacity:
        return D
    elif 0.25 * capacity <= current_stock < 0.75 * capacity:
        avg_opponent_payoff = calculate_avg_opponent_payoff(history)
        avg_cooperation_payoff = stock / (2 * n)
        if avg_opponent_payoff < avg_cooperation_payoff:
            return C
        else:
            return D
    else:  # current_stock < 0.25 * capacity
        return C

def calculate_avg_opponent_payoff(history):
    opponent_payoffs = [history[t-1][i]['payoff'] for i in range(n) if i != current_player]
    return sum(opponent_payoffs) / len(opponent_payoffs)
```
**Rationale:**
The ASR strategy is designed to balance exploitation and cooperation. By initially probing opponents with a random cooperation, it gathers information about their behavior. Then, it adapts its actions based on the stock level and opponents' payoffs. The goal is to exploit the common pool when possible while avoiding being exploited by others. In the final round, ASR prioritizes exploitation, as there's no future gain from cooperation.

This strategy should perform well against a wide range of opponent behaviors, as it continuously assesses the game state and adjusts its actions accordingly.
'''

description_EXPLOITATIVE_34 = '''
Here's a exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to observe opponents' initial moves and avoid early stock depletion.
2. **Early Rounds (t=2 to t=r/2):** Defect (D) if the average opponent cooperation rate is below 0.5 or if the current stock level is above 75% of capacity. Otherwise, Cooperate (C).
3. **Mid-Game (t=r/2+1 to t=3r/4):** Use a dynamic threshold-based approach:
	* Calculate the "Exploitation Threshold" (ET) as follows: ET = (current stock level / capacity) \* (average opponent cooperation rate + 0.25)
	* Defect (D) if ET is below 0.5; otherwise, Cooperate (C).
4. **Late Rounds (t=3r/4+1 to t=r):** If the current stock level is above 50% of capacity and at least one opponent has defected in the previous round, Defect (D). Otherwise, Cooperate (C) if the average opponent cooperation rate is above 0.5; otherwise, Defect (D).

**Edge Cases:**

* **Last Round (t=r):** Always Defect (D), as there are no future rounds to consider.
* **Low Stock Levels:** If the current stock level falls below 25% of capacity, Cooperate (C) to ensure some growth and avoid complete depletion.

**Pseudocode:**
```
function AdaptiveExploiter(state, history):
  // Initialize variables
  cooperation_rate = calculate_average_cooperation_rate(history)
  current_stock_level = state.stock

  // Determine decision based on game phase
  if t == 1:
    return C (cooperate in first round)

  elif t < r/2:
    if cooperation_rate < 0.5 or current_stock_level > 0.75 * capacity:
      return D (defect)
    else:
      return C

  elif t < 3r/4:
    ET = calculate_exploitation_threshold(current_stock_level, cooperation_rate)
    if ET < 0.5:
      return D
    else:
      return C

  else: // late rounds
    if current_stock_level > 0.5 * capacity and at_least_one_opponent_defected(history):
      return D
    elif cooperation_rate > 0.5:
      return C
    else:
      return D

  // Handle edge cases
  if t == r: // last round
    return D

  if current_stock_level < 0.25 * capacity: // low stock levels
    return C
```
This strategy, Adaptive Exploiter (AE), is designed to be exploitative and adaptive to various opponent behaviors while also being robust to different game scenarios. By adjusting its behavior based on the game phase and opponents' actions, AE aims to maximize its payoffs in a dynamic environment.
'''

description_EXPLOITATIVE_35 = '''
Here's a description of my exploitative strategy for the Common Pool Resource Game:

**Strategy Name: Adaptive Exploiter**

**Decision Rules:**

1. **Initial Exploration (Round 1-3)**:
	* Cooperate with probability 0.5 to gather information about opponents' behavior and the game state.
	* Observe the actions of other players and update the internal state accordingly.
2. **Adaptive Exploitation (Rounds 4-r)**:
	* If the current stock level is high (> capacity/2), defect with probability 1 - (stock/capacity).
	* If the current stock level is low (≤ capacity/2), cooperate with probability (stock/capacity).
3. **Opponent Modeling**:
	* Keep track of each opponent's cooperation rate over time.
	* Identify "cooperative" opponents (those who cooperate > 50% of the time) and "defective" opponents (those who defect > 50% of the time).

**Handling Edge Cases:**

1. **Last Round (Round r)**:
	* Defect with probability 1, as there is no future cost to over-extraction.
2. **Low Stock Levels (stock ≤ capacity/4)**:
	* Cooperate with probability 1 to avoid complete stock depletion.

**Pseudocode:**
```
// Initialize variables
int round = 0;
float stock = capacity;
bool[] opponent_cooperation_rates = new bool[n];

while (round < r) {
  // Initial Exploration (Rounds 1-3)
  if (round <= 3) {
    action = random.choice([C, D]);
  }
  
  // Adaptive Exploitation (Rounds 4-r)
  else {
    if (stock > capacity/2) {
      // Defect with probability 1 - (stock/capacity)
      action = (random.random() < 1 - stock/capacity) ? D : C;
    } else {
      // Cooperate with probability (stock/capacity)
      action = (random.random() < stock/capacity) ? C : D;
    }
    
    // Opponent Modeling
    for (int i = 0; i < n; i++) {
      opponent_cooperation_rates[i] = update_opponent_model(opponent_cooperation_rates[i], opponents[i].action);
    }
  }
  
  // Handle edge cases
  if (round == r - 1) { action = D; } // Last Round
  else if (stock <= capacity/4) { action = C; } // Low Stock Levels
  
  // Take action and update state
  stock -= calculate_consumption(action, n);
  stock += calculate_growth(stock, capacity);
  
  round++;
}
```
This strategy is designed to be exploitative by adapting to the game state and opponents' behavior. By initially exploring the opponent's actions and then using an adaptive exploitation approach, this strategy aims to maximize its own payoff while taking into account the potential consequences of over-extraction.
'''

description_EXPLOITATIVE_36 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize its own payoff by adaptively responding to the current state and history of the game.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C). This allows us to observe how others behave in the first round.
2. **Middle Rounds (2 ≤ t < r)**:
	* If the stock level is high (> 75% of capacity), Defect (D) if more than half of the players defected in the previous round; otherwise, Cooperate (C).
	* If the stock level is moderate (25% to 75% of capacity), Cooperate (C) if the total consumption in the previous round was low (< 50% of capacity); otherwise, Defect (D).
	* If the stock level is low (< 25% of capacity), Defect (D).
3. **Last Round (t=r)**: Always Defect (D). This ensures maximum personal gain, as there are no future rounds to consider.

**Additional Logic:**

* **Stock Trend Analysis**: Track the stock growth or decline over the last few rounds. If the trend is positive, increase the likelihood of cooperating in the next round.
* **Opponent Profiling**: Keep a simple count of how often each opponent has cooperated or defected in previous rounds. Adjust your decision based on this profile: if an opponent tends to cooperate, you may want to defect more frequently against them.

**Pseudocode (for illustration purposes only)**:
```
function AdaptiveStockRaider(current_stock, capacity, num_players, round_number, history) {
  // Initial Round
  if (round_number == 1) {
    return Cooperate;
  }

  // Middle Rounds
  if (current_stock > 0.75 * capacity) {
    if (history.defected_last_round() > num_players / 2) {
      return Defect;
    } else {
      return Cooperate;
    }
  } else if (current_stock >= 0.25 * capacity && current_stock <= 0.75 * capacity) {
    if (history.total_consumption_last_round() < 0.5 * capacity) {
      return Cooperate;
    } else {
      return Defect;
    }
  } else {
    return Defect; // Low stock level
  }

  // Last Round
  if (round_number == num_rounds) {
    return Defect;
  }
}
```
**Rationale:**

This strategy balances short-term gains with long-term sustainability. By cooperating in the first round, we gather information about our opponents' behaviors and set a positive tone for the game.

In subsequent rounds, we adapt to the current state of the stock and adjust our decision based on the likelihood of others defecting or cooperating. This allows us to exploit potential free-riders while maintaining a reasonable level of cooperation when necessary.

The additional logic components help refine our decisions by considering trends in the stock growth and opponent behavior profiles.

This exploitative strategy should perform well against independent opponents, as it is designed to maximize personal gain without relying on coordination or shared norms.
'''

description_EXPLOITATIVE_37 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit a wide range of opponent behaviors while adapting to changing game conditions.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Observe the initial stock level and capacity.
	* Cooperate (C) if the initial stock level is above 75% of the capacity; otherwise, Defect (D).
2. **Subsequent Rounds (t>1):**
	* Calculate the average opponent consumption per round: `avg_opponent_consumption = (total_consumption - my_consumption) / (n-1)`
	* If the average opponent consumption is above 50% of the capacity, Defect (D).
	* Otherwise, Cooperate (C) if the current stock level is above 50% of the capacity; otherwise, Defect (D).
3. **Last Round (t=r):**
	* Always Defect (D), as there are no future rounds to consider.

**Edge Cases:**

1. **Low Stock Levels:** If the current stock level falls below 25% of the capacity, always Cooperate (C) to avoid complete depletion.
2. **High Stock Levels:** If the current stock level exceeds 90% of the capacity, Defect (D) to maximize short-term gain.

**Adaptive Component:**

1. **Opponent Behavior Tracking:** Maintain a running average of opponent consumption levels over the last `k` rounds (`k` = 3-5). This helps identify patterns in opponent behavior.
2. **Strategy Adjustment:** If the running average of opponent consumption changes significantly (e.g., >20% increase or decrease), adjust the decision rules accordingly:
	+ If opponents become more cooperative, shift towards Defecting (D) to exploit their cooperation.
	+ If opponents become more defective, shift towards Cooperating (C) to conserve resources.

**Pseudocode:**
```markdown
# Initialize variables
initial_stock = capacity
avg_opponent_consumption = 0
my_consumption = 0
k = 3  # opponent behavior tracking window size

# First round
if initial_stock > 0.75 * capacity:
    action = C
else:
    action = D

# Subsequent rounds
for t in range(2, r+1):
    total_consumption = calculate_total_consumption()
    avg_opponent_consumption = (total_consumption - my_consumption) / (n-1)
    
    if avg_opponent_consumption > 0.5 * capacity:
        action = D
    elif current_stock > 0.5 * capacity:
        action = C
    else:
        action = D
    
    # Adjust strategy based on opponent behavior tracking
    if abs(avg_opponent_consumption - previous_avg_opponent_consumption) > 0.2:
        if avg_opponent_consumption > previous_avg_opponent_consumption:
            action = D  # opponents becoming more cooperative, exploit
        else:
            action = C  # opponents becoming more defective, conserve resources

    # Last round
if t == r:
    action = D

# Low stock levels
if current_stock < 0.25 * capacity:
    action = C

# High stock levels
if current_stock > 0.9 * capacity:
    action = D
```
The Adaptive Predator strategy is designed to be robust and exploitative, adapting to changing opponent behaviors while maximizing payoffs in a wide range of game conditions.
'''

description_EXPLOITATIVE_38 = '''
**Exploitative Strategy: "Adaptive Predator"**

Decision Rules:

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behaviors and set a benchmark for future adaptations.
2. **Early Rounds (2-5)**: Observe opponents' actions and calculate the average cooperation rate among them. If the average cooperation rate is above 0.6, cooperate; otherwise, defect (D).
3. **Mid-game Adaptation**: After round 5, assess the current stock level. If it's below capacity/2, switch to a more conservative approach:
	* If at least half of opponents cooperated in the previous round, cooperate.
	* Otherwise, defect.
4. **Late Rounds (r-3 to r-1)**: As the game nears its end, prioritize maximizing individual payoff:
	* Defect if the current stock level is below capacity/3 or if fewer than 2 opponents cooperated in the previous round.
	* Cooperate if at least 2 opponents cooperated and the stock level is above capacity/3.
5. **Last Round (r)**: Always defect, as there's no future payoff to consider.

Additional Logic:

* **Opponent Classification**: Maintain a count of each opponent's cooperation and defection actions. Label an opponent as "cooperative" if they cooperated more than 50% of the time; otherwise, label them as "non-cooperative".
* **Adaptive Threshold**: Update the average cooperation rate calculation to only consider cooperative opponents.
* **Stock-based Adaptation**: If the stock level falls below capacity/4 or rises above 3*capacity/4, adjust the conservative approach threshold (step 3) accordingly.

Pseudocode:
```python
def AdaptivePredator(n, r, capacity):
    # Initialize variables
    avg_coop_rate = 0
    opponent_coops = [0] * n
    opponent_defs = [0] * n

    for round in range(r):
        if round == 0:  # First round
            action = 'C'
        elif round < 5:  # Early rounds
            avg_coop_rate = sum(opponent_coops) / (n * round)
            if avg_coop_rate > 0.6:
                action = 'C'
            else:
                action = 'D'
        elif round < r - 3:  # Mid-game adaptation
            stock_level = get_stock_level()
            if stock_level < capacity / 2:
                coop_opponents = sum(1 for i in range(n) if opponent_coops[i] > opponent_defs[i])
                if coop_opponents >= n // 2:
                    action = 'C'
                else:
                    action = 'D'
        elif round == r - 1:  # Last round
            action = 'D'

        # Update opponent classifications and adapt threshold
        for i in range(n):
            if get_opponent_action(i) == 'C':
                opponent_coops[i] += 1
            else:
                opponent_defs[i] += 1

        avg_coop_rate = sum(opponent_coops) / (n * round)

    return action
```
This strategy aims to exploit opponents' behaviors by adapting to the game's dynamics, prioritizing individual payoff maximization while being mindful of the stock level and opponents' actions.
'''

description_EXPLOITATIVE_39 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) is a decision-making strategy designed to exploit opponents' behaviors in the Common Pool Resource Game while adapting to changing game conditions.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe the initial stock level and number of players.
	* Play C (Cooperate) if n ≤ 4, as a small number of players increases the likelihood of successful cooperation.
	* Play D (Defect) if n > 4, to take advantage of potential over-consumption by opponents.
2. **Non-Initial Rounds (t>1)**:
	* Evaluate the current stock level and accumulated consumption history.
	* Calculate the "Stock Pressure" metric: SP = (total_consumption / capacity)
	* If SP ≥ 0.5, play D to maximize short-term payoff in a depleted environment.
	* If SP < 0.5, consider opponents' past actions:
		+ Count the number of opponents who played C and D in the previous round (C_count and D_count).
		+ If C_count > D_count, play C to take advantage of cooperative momentum.
		+ If C_count ≤ D_count, play D to exploit potential over-consumption by opponents.
3. **Last Round (t=r)**:
	* Play D regardless of the stock level or opponents' past actions, as there's no future payoff to consider.

**Edge Case Handling:**

1. **Low Stock Levels**: If the current stock level falls below a certain threshold (e.g., 20% of capacity), play D to maximize short-term payoff.
2. **High Stock Levels**: If the current stock level exceeds a certain threshold (e.g., 80% of capacity), consider playing C to maintain a healthy stock level and potential future payoffs.

**Pseudocode:**
```python
def adaptive_stock_raider(stock, n, r, t):
    if t == 1:
        if n <= 4:
            return "C"
        else:
            return "D"

    sp = total_consumption / capacity
    if sp >= 0.5:
        return "D"

    c_count, d_count = count_opponents_actions()
    if c_count > d_count:
        return "C"
    else:
        return "D"

    # Last round handling
    if t == r:
        return "D"

    # Low stock level handling
    if stock < 0.2 * capacity:
        return "D"

    # High stock level handling
    if stock > 0.8 * capacity:
        consider_playing_C()
```
**Rationale:**

The Adaptive Stock Raider strategy is designed to exploit opponents' behaviors while adapting to changing game conditions. By evaluating the stock pressure, accumulated consumption history, and opponents' past actions, ASR makes informed decisions that balance short-term payoff maximization with long-term sustainability. The strategy's adaptability and robustness make it a formidable opponent in the tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_40 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Overview**
The Adaptive Stock Raider strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the common pool resource game. This strategy prioritizes maximizing individual payoffs over cooperation, taking calculated risks to deplete the stock and minimize opponents' gains.

**Decision Rules**

1. **Initial Round (t=1)**: Cooperate (C) to gather information on opponents' behaviors and initial stock dynamics.
2. **Middle Rounds (2 ≤ t < r)**:
	* If the current stock level is above 75% of capacity, Defect (D) to maximize individual payoff.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance individual gain with sustainable stock growth.
	* If the current stock level is below 50% of capacity, Defect (D) to exploit remaining resources before they are depleted.
3. **Last Round (t=r)**: Defect (D) to maximize individual payoff, as there are no future rounds to consider.

**Additional Logic**

1. **Opponent Behavior Analysis**: Track the number of opponents who cooperated in previous rounds. If most opponents consistently cooperate, adjust the strategy to defect more frequently to exploit their cooperation.
2. **Stock Trend Analysis**: Monitor the stock growth rate over the past few rounds. If the stock is growing rapidly, increase cooperation to avoid over-exploitation and maintain a sustainable resource level.
3. **Recent Payoff Analysis**: Evaluate individual payoffs from recent rounds. If payoffs have been consistently low, adjust the strategy to defect more frequently to catch up with other players.

**Pseudocode**
```
// Initialize variables
stock_history = []
opponent_cooperation_count = 0

// Main game loop
for t in range(1, r+1):
    // Get current stock level and opponent actions from previous round
    current_stock = get_current_stock()
    opponent_actions = get_opponent_actions(t-1)

    // Update opponent cooperation count
    if t > 1:
        opponent_cooperation_count += sum(opponent_actions == 'C')

    // Determine action based on decision rules
    if t == 1:  // Initial round
        action = 'C'
    elif current_stock > 0.75 * capacity:  // High stock level
        action = 'D'
    elif current_stock >= 0.5 * capacity:  // Medium stock level
        action = 'C'
    else:  // Low stock level
        action = 'D'

    // Adjust strategy based on opponent behavior and recent payoffs
    if opponent_cooperation_count > 0.5 * n:
        action = 'D'  // Exploit opponents' cooperation
    elif recent_payoff_average < 0.5 * average_payoff:
        action = 'D'  // Catch up with other players

    // Perform action and update stock history
    take_action(action)
    stock_history.append(current_stock)

// Return total payoff over all rounds
return sum(individual_payoffs)
```
This strategy is designed to be adaptive, exploitative, and robust against various opponent behaviors. By monitoring the game state and adjusting its actions accordingly, the Adaptive Stock Raider aims to maximize individual payoffs while minimizing the risk of stock depletion.
'''

description_EXPLOITATIVE_41 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1):** Defect (D) to maximize initial payoff and gather information on opponents' behavior.
2. **Middle Rounds (1 < t < r):**
	* If the current stock level is above 75% of capacity, Cooperate (C) to sustain the stock and maintain a stable environment.
	* If the current stock level is between 25% and 75% of capacity, Defect (D) to exploit the remaining stock and pressure opponents to cooperate.
	* If the current stock level is below 25% of capacity, Cooperate (C) to help replenish the stock and avoid collapse.
3. **Last Round (t=r):** Defect (D) to maximize final payoff, as there are no future rounds to consider.

**Adaptive Component:**

* Monitor opponents' behavior and adjust strategy based on their cooperation rates:
	+ If most opponents (> 50%) cooperated in the previous round, increase cooperation rate by 10% in the next round.
	+ If most opponents (> 50%) defected in the previous round, decrease cooperation rate by 10% in the next round.

**Robustness Mechanisms:**

* **Opponent Cooperation Detection:** Use a simple moving average of opponents' past actions to estimate their cooperation rates. This helps detect changes in opponent behavior and adapt the strategy accordingly.
* **Stock Level Smoothing:** Apply a smoothing factor (e.g., 0.1) to the current stock level to reduce the impact of sudden changes and promote more stable decision-making.

**Pseudocode:**
```python
def adaptive_stock_raider(n, r, capacity, history):
    # Initialize variables
    cooperation_rate = 0.5
    smoothing_factor = 0.1
    
    for t in range(1, r+1):
        if t == 1:
            action = 'D'  # Defect in the first round
        else:
            current_stock = history[t-1]['stock']
            opponent_cooperation_rate = estimate_opponent_cooperation(history)
            
            if current_stock > 0.75 * capacity:
                action = 'C'
            elif current_stock < 0.25 * capacity:
                action = 'C'
            else:
                if opponent_cooperation_rate > 0.5:
                    cooperation_rate += 0.1
                else:
                    cooperation_rate -= 0.1
                
                if random.random() < cooperation_rate:
                    action = 'C'
                else:
                    action = 'D'
        
        # Apply smoothing to the current stock level
        smoothed_stock = (1 - smoothing_factor) * current_stock + smoothing_factor * history[t-1]['stock']
        
        # Update cooperation rate and opponent cooperation detection
        update_cooperation_rate(cooperation_rate, opponent_cooperation_rate)
        update_opponent_detection(history)
    
    return action

def estimate_opponent_cooperation(history):
    # Simple moving average of opponents' past actions
    cooperation_rates = []
    for t in range(1, len(history)):
        if history[t]['action'] == 'C':
            cooperation_rates.append(1)
        else:
            cooperation_rates.append(0)
    
    return sum(cooperation_rates) / len(cooperation_rates)

def update_cooperation_rate(cooperation_rate, opponent_cooperation_rate):
    # Update cooperation rate based on opponent behavior
    if opponent_cooperation_rate > 0.5:
        cooperation_rate += 0.1
    else:
        cooperation_rate -= 0.1
    
    cooperation_rate = max(0, min(1, cooperation_rate))  # Clamp to [0, 1] range

def update_opponent_detection(history):
    # Update opponent cooperation detection based on past actions
    pass  # TO DO: implement opponent detection logic
```
This strategy is designed to be exploitative, adaptive, and robust. By monitoring opponents' behavior and adjusting the cooperation rate accordingly, it aims to maximize payoffs while maintaining a stable environment. The smoothing factor helps reduce the impact of sudden changes in the stock level, promoting more stable decision-making.
'''

description_EXPLOITATIVE_42 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

**Overview**
The Adaptive Stock Hawk (ASH) strategy is designed to exploit opponents' behaviors while adapting to the dynamic state of the game. It balances short-term gains with long-term sustainability, aiming to maximize total payoff over multiple rounds.

**Decision Rules**

1. **Initial Round (t=1)**: Cooperate (C). This allows ASH to observe opponents' initial actions and sets a baseline for stock depletion.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is below 50% of capacity, Defect (D) with probability `p_defect = (capacity - stock) / capacity`. This increases as the stock level decreases, incentivizing opponents to conserve the resource.
	* Otherwise, use a Tit-for-Tat-like approach:
		+ If the majority of opponents defected in the previous round, Defect (D).
		+ If the majority cooperated or it's a tie, Cooperate (C).

Pseudocode for the decision rules:

```
if t == 1:
    action = C
else:
    if stock < 0.5 * capacity:
        p_defect = (capacity - stock) / capacity
        action = D with probability p_defect, else C
    else:
        prev_majority = majority_action(prev_round)
        if prev_majority == D:
            action = D
        else:
            action = C
```

**Edge Cases**

* **Last Round (t=r)**: Defect (D) to maximize short-term gain, as there's no future stock depletion concern.
* **Stock Level at or near 0**: Cooperate (C) to allow for some stock growth and potential future exploitation.

**Exploitative Mindset**
ASH is designed to exploit opponents' behaviors by:

1. **Initial cooperation**: Encourages opponents to cooperate, allowing ASH to gauge their behavior and set a baseline for stock depletion.
2. **Adaptive defecting**: Responds to decreasing stock levels by increasing the likelihood of defecting, pressuring opponents to conserve the resource.
3. **Tit-for-Tat-like approach**: Exploits opponents' cooperation or defection in previous rounds, creating an incentive for them to cooperate.

By balancing short-term gains with long-term sustainability, ASH aims to maximize its total payoff over multiple rounds while adapting to a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_43 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behavior and to avoid early stock depletion.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is high (> 0.75 \* capacity), Defect (D) to maximize personal payoff, as the stock can sustain high consumption.
	* If the current stock level is moderate (0.25 \* capacity < stock ≤ 0.75 \* capacity), Cooperate (C) to maintain a balance between personal payoff and stock sustainability.
	* If the current stock level is low (< 0.25 \* capacity), Defect (D) to maximize personal payoff, as the game is likely nearing its end.
3. **Last Round (t=r)**: Defect (D) to maximize personal payoff, regardless of the stock level.

Additional Logic:

1. **Opponent Analysis**: Track opponents' actions and adjust strategy accordingly:
	* If an opponent consistently Cooperates (C), consider them a "weak" opponent and Defect (D) more frequently to exploit their cooperation.
	* If an opponent consistently Defects (D), consider them a "strong" opponent and Cooperate (C) more frequently to maintain stock sustainability.
2. **Stock Trend Analysis**: Monitor the stock level trend:
	* If the stock level is increasing or stable, Cooperate (C) more frequently to sustain the trend.
	* If the stock level is decreasing rapidly, Defect (D) more frequently to maximize personal payoff before the game ends.

Pseudocode:

```
// Initialize variables
stock_history = []
opponent_actions = []

// Main loop
for t in range(1, r+1):
    // Get current stock level and opponent actions
    stock_level = get_stock_level()
    opponent_actions[t] = get_opponent_actions()

    // Initial round (t=1)
    if t == 1:
        action = C

    // Subsequent rounds (t>1)
    else:
        // Analyze stock level
        if stock_level > 0.75 * capacity:
            action = D
        elif 0.25 * capacity < stock_level <= 0.75 * capacity:
            action = C
        else:
            action = D

        // Adjust strategy based on opponent analysis and stock trend analysis
        if analyze_opponent(opponent_actions) == "weak":
            action = D
        elif analyze_stock_trend(stock_history) == "decreasing":
            action = D

    // Last round (t=r)
    if t == r:
        action = D

    // Update stock history and take action
    stock_history.append(stock_level)
    take_action(action)

// Helper functions
def get_stock_level():
    // Get current stock level from game state

def get_opponent_actions():
    // Get opponent actions from game history

def analyze_opponent(opponent_actions):
    // Analyze opponent behavior (e.g., "weak" or "strong")

def analyze_stock_trend(stock_history):
    // Analyze stock level trend (e.g., "increasing", "stable", or "decreasing")
```

This strategy, "Adaptive Stock Raider," aims to exploit opponents' behaviors while maintaining a balance between personal payoff and stock sustainability. By analyzing the game state, opponent actions, and stock trends, the strategy adapts to different situations and maximizes its own payoff over the course of the game.
'''

description_EXPLOITATIVE_44 = '''
I'll outline a robust and exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if the initial stock is close to capacity (> 0.9 \* capacity). This encourages opponents to cooperate and builds trust.
	* Defect (D) otherwise, as the stock level may be low due to previous interactions or random initialization.
2. **Early Rounds (t=2 to t=r/3):**
	* Monitor opponents' actions and calculate the average cooperation rate (CR) among them.
	* Cooperate if CR > 0.5; Defect otherwise. This phase aims to assess opponents' strategies and adapt accordingly.
3. **Mid-Game (t=r/3 to t=2r/3):**
	* Implement a Tit-for-Tat (TFT) variant:
		+ Cooperate if the opponent's previous action was C or if they cooperated in the majority of recent rounds (> 0.5 \* CR).
		+ Defect otherwise.
	* Introduce a "punishment" mechanism: If an opponent defects, AE will defect for two consecutive rounds to deter future defections.
4. **Endgame (t=2r/3 to t=r):**
	* Gradually shift towards more exploitative behavior:
		+ Cooperate with probability 0.5 if the stock level is high (> 0.7 \* capacity).
		+ Defect otherwise, taking advantage of the remaining stock.

**Edge Cases:**

1. **Last Round (t=r):**
	* Defect, as there's no future interaction to worry about.
2. **Low Stock Levels (< 0.3 \* capacity):**
	* Cooperate if most opponents (> 0.5 \* CR) cooperate; Defect otherwise. This aims to preserve the stock for potential future gains.

**Pseudocode:**

```
function AdaptiveExploiter(stock, t, r, n, capacity, history):
  // Initial Round
  if (t == 1):
    if (stock > 0.9 * capacity):
      return C
    else:
      return D

  // Early Rounds
  if (t <= r/3):
    avg_CR = calculate_average_cooperation_rate(history)
    if (avg_CR > 0.5):
      return C
    else:
      return D

  // Mid-Game
  opponent_prev_action = history[-1]
  if (opponent_prev_action == C or CR > 0.5):
    return C
  else:
    // Punishment mechanism
    if (t > r/3 + 2):
      return D
    else:
      return C

  // Endgame
  if (t >= 2r/3):
    if (stock > 0.7 * capacity):
      // Random cooperation with probability 0.5
      return random_choice([C, D])
    else:
      return D

  // Last Round or Low Stock Levels
  if (t == r or stock < 0.3 * capacity):
    // Cooperate if most opponents cooperate
    if (CR > 0.5):
      return C
    else:
      return D
```

**Rationale:**

The Adaptive Exploiter strategy balances cooperation and exploitation, taking into account the game's state, history, and opponent behaviors. By adapting to various scenarios, AE aims to maximize its payoff while minimizing the risk of being exploited.

In the initial rounds, AE cooperates to build trust and encourage opponents to do the same. As the game progresses, it shifts towards a more exploitative approach, using Tit-for-Tat and punishment mechanisms to deter defections. In the endgame, AE gradually increases its exploitation rate, taking advantage of the remaining stock.

By incorporating elements from different strategies (TFT, cooperation, and exploitation), Adaptive Exploiter is designed to be robust against various opponent behaviors and perform well in a tournament setting.
'''

description_EXPLOITATIVE_45 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit a wide range of opponent behaviors while being robust and adaptive. This strategy leverages game parameters, state, and history to make informed decisions.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behavior.
2. **Exploitation Phase:** For rounds 2 to r-1:
	* If the current stock level is above 75% of capacity, Defect (D).
	* Otherwise, Cooperate (C).
3. **Endgame Phase:** In the last round (r):
	* If the current stock level is below 25% of capacity, Defect (D) to maximize payoff.
	* Otherwise, Cooperate (C) to preserve some stock for future rounds (although this won't affect the final payoff).

**Adaptive Component:**

1. **Opponent Behavior Analysis:** Track opponents' cooperation rates over the game history.
2. **Defection Threshold Adjustment:** Adjust the exploitation phase's defect threshold based on opponents' cooperation rates:
	* If most opponents (> 50%) cooperate, decrease the defect threshold to 60% of capacity (more aggressive).
	* If most opponents (< 50%) defect, increase the defect threshold to 90% of capacity (less aggressive).

**Pseudocode:**
```python
# Initialize variables
stock_history = []
opponent_cooperation_rates = [0] * n

def adaptive_predator(stock, round_num, opponent_actions):
    if round_num == 1:
        # Initial Round: Cooperate
        return 'C'
    
    # Exploitation Phase
    if stock > 0.75 * capacity:
        return 'D'
    else:
        return 'C'

    # Endgame Phase (last round)
    if round_num == r and stock < 0.25 * capacity:
        return 'D'
    else:
        return 'C'

    # Adaptive Component
    opponent_cooperation_rates = update_opponent_cooperation_rates(opponent_actions, opponent_cooperation_rates)

def update_opponent_cooperation_rates(opponent_actions, cooperation_rates):
    for i in range(n):
        if opponent_actions[i] == 'C':
            cooperation_rates[i] += 1 / (round_num - 1)
        else:
            cooperation_rates[i] -= 1 / (round_num - 1)

    # Adjust Defection Threshold
    defect_threshold = 0.75 * capacity
    if most_cooperate(cooperation_rates):
        defect_threshold *= 0.8  # Decrease threshold to 60%
    elif most_defect(cooperation_rates):
        defect_threshold *= 1.2  # Increase threshold to 90%

    return cooperation_rates

def most_cooperate(cooperation_rates):
    return sum(cooperation_rates) / n > 0.5

def most_defect(cooperation_rates):
    return sum(1 - x for x in cooperation_rates) / n > 0.5
```
This strategy is designed to balance short-term gains with long-term sustainability, while adapting to opponents' behaviors and exploiting their cooperation or defection tendencies.
'''

description_EXPLOITATIVE_46 = '''
**Strategy Name:** Adaptive Stock Raider (ASR)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5 to gather information about opponents' behaviors and initial stock dynamics.
2. **Middle Rounds (1 < t < r):**
	* If the current stock level is above 75% of the capacity, cooperate (C) if at least half of the players cooperated in the previous round; otherwise, defect (D).
	* If the current stock level is between 25% and 75% of the capacity, cooperate (C) if more than half of the players cooperated in the previous round; otherwise, defect (D).
	* If the current stock level is below 25% of the capacity, always defect (D) to maximize individual payoff.
3. **Final Round (t=r):** Always defect (D), as there are no future rounds to consider.

**Edge Cases:**

1. **First Round:** Cooperate with a probability of 0.5 to gather information about opponents' behaviors and initial stock dynamics.
2. **Last Round:** Always defect, as there are no future rounds to consider.
3. **Opponents' Behavior:** Monitor the number of cooperators in previous rounds to adapt decision-making.

**Exploitative Mindset:**

1. **Identify Cooperators:** In the first few rounds, use the 0.5 probability cooperation strategy to identify which opponents tend to cooperate and which defect.
2. **Exploit Defectors:** When facing mostly defectors, adjust strategy to defect more frequently to maximize individual payoff.
3. **Take Advantage of Stock Fluctuations:** Adapt decision-making based on current stock levels to optimize payoffs during fluctuations.

**Additional Considerations:**

1. **Monitor Opponents' Payoffs:** Observe opponents' payoffs in previous rounds to identify patterns and adapt strategy accordingly.
2. **Stock Growth Dynamics:** Account for the non-linear growth of the stock after consumption, adjusting decision-making based on expected future stock levels.
3. **Adaptation Window:** Regularly reassess opponents' behaviors and adjust the cooperation-defection ratio to maintain an exploitative edge.

**Pseudocode:**
```python
def Adaptive_Stock_Raider(game_state):
  t = game_state['round']
  n = game_state['num_players']
  capacity = game_state['capacity']
  stock = game_state['current_stock']
  previous_round_cooperators = game_state['previous_cooperators']

  if t == 1:
    # Initial round: cooperate with probability 0.5
    return random.choice(['C', 'D'])

  elif t < game_state['total_rounds']:
    # Middle rounds
    cooperators_last_round = len([p for p in previous_round_cooperators if p == 'C'])
    if stock > 0.75 * capacity:
      return 'C' if cooperators_last_round >= n / 2 else 'D'
    elif 0.25 * capacity <= stock < 0.75 * capacity:
      return 'C' if cooperators_last_round > n / 2 else 'D'
    else:
      return 'D'

  else:
    # Final round
    return 'D'
```
This strategy is designed to be adaptive, exploitative, and robust against a wide range of opponent behaviors. By monitoring opponents' payoffs, stock dynamics, and behavior patterns, ASR adjusts its decision-making to maximize individual payoff while taking into account the dynamic state of the game.
'''

description_EXPLOITATIVE_47 = '''
**Strategy Name: Adaptive Exploiter**

The Adaptive Exploiter strategy is designed to exploit opponents' behaviors while adapting to the dynamic state of the game. It balances cooperation and defection based on the current stock level, number of players, and historical actions.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gauge opponents' initial behavior and avoid over-depleting the stock.
2. **Early Game (t < r/2)**:
	* If the current stock is above 75% of capacity, Defect (D) to maximize short-term gains.
	* Otherwise, Cooperate (C) to conserve the stock for future rounds.
3. **Mid-Game (t ≥ r/2 and t < r - 1)**:
	* Monitor opponents' actions in the previous round:
		+ If most players (> n/2) Defected, Cooperate (C) to prevent over-depletion.
		+ If most players (> n/2) Cooperated, Defect (D) to exploit their cooperative behavior.
	* If the current stock is below 50% of capacity, Cooperate (C) to avoid depletion.
4. **Late Game (t = r - 1)**:
	* Assess the current stock level and opponents' actions in the previous round:
		+ If the stock is high (> 75% of capacity) and most players Defected, Defect (D) to maximize final-round gains.
		+ Otherwise, Cooperate (C) to ensure a moderate payoff.

**Edge Cases:**

* **Last Round (t = r)**: Defect (D) to maximize the final-round payoff, regardless of the current stock level or opponents' actions.
* **Low Stock (stock < 25% of capacity)**: Cooperate (C) in all rounds to prevent depletion and ensure some payoff.

**Adaptation Mechanisms:**

* The strategy adapts to opponents' behavior by monitoring their actions in previous rounds and adjusting its own decisions accordingly.
* It also considers the current stock level and adjusts its behavior to balance short-term gains with long-term sustainability.

**Exploitative Mindset:**

The Adaptive Exploiter strategy is designed to exploit opponents who cooperate excessively or follow predictable patterns. By adapting to the dynamic state of the game, it aims to maximize its own payoff while minimizing the impact on the stock level. This approach allows the strategy to thrive in a wide range of scenarios and opponent behaviors.

Pseudocode:
```markdown
# Initialize variables
stock = capacity
n_players = n
rounds = r

# Loop through rounds
for t in range(1, rounds + 1):
    # Early game
    if t < rounds / 2:
        if stock > 0.75 * capacity:
            action = D
        else:
            action = C
    
    # Mid-game
    elif t >= rounds / 2 and t < rounds - 1:
        prev_actions = get_prev_round_actions()
        if most_players_defected(prev_actions):
            action = C
        elif most_players_cooperated(prev_actions):
            action = D
        elif stock < 0.5 * capacity:
            action = C
    
    # Late game
    else:
        if t == rounds - 1:
            if stock > 0.75 * capacity and most_players_defected(prev_actions):
                action = D
            else:
                action = C
        
        # Last round
        elif t == rounds:
            action = D
    
    # Low stock handling
    if stock < 0.25 * capacity:
        action = C
    
    # Take action and update state
    consume_stock(action)
    update_stock()
```
Note that this pseudocode is a simplified representation of the strategy, and actual implementation may require additional details and optimizations.
'''

description_EXPLOITATIVE_48 = '''
**Exploitative Strategy: Adaptive Stock-Based Exploitation (ASBE)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about the opponents' behavior and initial stock level.
2. **Stock-Based Threshold:** Calculate a threshold `stock_threshold` based on the current stock level and capacity:
	* If `stock` < 0.5 * `capacity`, defect (D) to maximize individual payoff, as cooperation would lead to low payoffs due to depleted stock.
	* Otherwise, cooperate (C).
3. **Opponent Behavior Adaptation:** Analyze opponents' actions in previous rounds and adjust the decision based on their behavior:
	* If most opponents (> 50%) defected in the previous round, defect (D) to punish them and maintain a stable stock level.
	* If most opponents cooperated (> 50%), cooperate (C) to take advantage of the high stock level and potential for growth.
4. **Last Round:** Defect (D) in the last round, as there is no future benefit from cooperation.

**Pseudocode:**
```python
def ASBE(n, capacity, stock, history):
    if round == 1:
        return 'C'  # Cooperate in the first round

    stock_threshold = 0.5 * capacity

    if stock < stock_threshold:
        return 'D'  # Defect when stock is low

    opponent_actions = [action for action in history[-1] if action != 'self']

    defect_count = sum(1 for action in opponent_actions if action == 'D')
    cooperate_count = len(opponent_actions) - defect_count

    if defect_count > cooperate_count:
        return 'D'  # Defect to punish opponents
    elif cooperate_count > defect_count:
        return 'C'  # Cooperate when most opponents cooperated

    # Default: Cooperate when stock is high and opponents' behavior is mixed
    return 'C'

def last_round(n, capacity, stock, history):
    return 'D'  # Defect in the last round
```
**Edge Cases:**

* If there are multiple possible actions based on the decision rules (e.g., equal number of cooperating and defecting opponents), default to cooperation.
* In case of a tie in opponent behavior analysis, prioritize the action that maintains a higher stock level.

This strategy is designed to be exploitative, taking advantage of the game's dynamics and opponents' behavior. By adapting to the current stock level and opponent actions, ASBE aims to maximize individual payoffs while maintaining a stable stock level.
'''

description_EXPLOITATIVE_49 = '''
Here's a robust and adaptive exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** "Adaptive Stock Guardian" (ASG)

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C). This allows us to observe how other players behave while minimizing our impact on the stock.
2. **Stock Threshold**: Set a stock threshold, `stock_threshold = 0.7 * capacity`. If the current stock level is below this threshold, play Defect (D) in all subsequent rounds. This ensures we maximize our payoff when the stock is low and other players are likely to defect as well.
3. **Opponent Behavior Analysis**: Monitor the actions of other players over time. For each opponent `i`, maintain a counter `defect_count_i` that increments every time they play Defect (D).
4. **Adaptive Cooperation**: If an opponent has defected more than 50% of the time (`defect_count_i > 0.5 * r`), assume they are a defector and play Defect (D) against them in subsequent rounds.
5. **Stock Growth Monitoring**: Track the average stock growth over the last `k` rounds (e.g., `k = 3`). If the average growth is negative, indicating that the stock is depleting rapidly, play Defect (D) to maximize our payoff before the stock collapses.

**Pseudocode:**
```
ASG(strategy)
{
  // Initialize variables
  stock_threshold = 0.7 * capacity;
  defect_count = array of size n; // one entry per opponent

  // First round: Cooperate
  if (round == 1) {
    action = C;
  } else {
    // Analyze opponent behavior and adjust strategy
    for each opponent i:
      if (defect_count_i > 0.5 * r) {
        action = D; // assume opponent is a defector
      }

    // Check stock threshold and growth rate
    if (stock_level < stock_threshold || avg_stock_growth < 0) {
      action = D;
    } else {
      // Cooperate by default
      action = C;
    }
  }

  return action;
}
```
**Edge Cases:**

* **Last Round**: In the final round, play Defect (D) to maximize our payoff regardless of the stock level or opponent behavior.
* **Opponent Defection**: If all opponents defect in a given round, we will also defect to avoid being exploited.

**Exploitative Mindset:**
The ASG strategy prioritizes maximizing our own payoff while adapting to the actions and behaviors of other players. By analyzing their behavior over time, we can identify and exploit defectors, ensuring that we maximize our gains in a wide range of scenarios.
'''

description_EXPLOITATIVE_50 = '''
I'll design a strategy that adapts to various opponent behaviors and exploits their weaknesses while considering the game's parameters and state.

**Strategy Name: Adaptive Exploiter (AE)**

**Decision Rules:**

1. **Initial Round (t=1):** Play Cooperate (C). This allows us to gather information about opponents' initial moves without sacrificing too much payoff.
2. **Early Rounds (t>1, stock ≥ 0.75 \* capacity):** Observe the average opponent behavior in previous rounds:
	* If the average opponent cooperation rate is above 0.5, play Cooperate (C). This encourages continued cooperation and maintains a healthy stock level.
	* Otherwise, play Defect (D). This takes advantage of opponents' selfishness while the stock level is still relatively high.
3. **Mid-game Rounds (0.25 \* capacity ≤ stock < 0.75 \* capacity):** Analyze the current round's opponent actions:
	* If a majority (>50%) of opponents play Cooperate, play Defect (D). This exploits their cooperation and gains an advantage while the stock level is still moderate.
	* Otherwise, play Cooperate (C). This maintains a relatively stable stock level and prepares for potential future exploitation.
4. **Late Rounds (t ≥ 0.75 \* r, stock < 0.25 \* capacity):** Play Defect (D) unconditionally. With the game nearing its end and the stock level low, it's essential to maximize individual payoffs regardless of opponents' actions.

**Edge Cases:**

1. **Last Round (t=r):** Always play Defect (D), as there are no future rounds to consider.
2. **Stock Depletion:** If the stock level falls below 0.1 \* capacity, play Defect (D) unconditionally to maximize individual payoffs.

**Pseudocode:**

```
function AdaptiveExploiter(game_state, history):
    t = current_round
    n = number_of_players
    r = total_rounds
    capacity = maximum_sustainable_stock_level
    stock = current_stock_level
    
    if t == 1:
        return Cooperate (C)
    
    avg_cooperation_rate = calculate_average_opponent_cooperation(history)
    opponent_actions = get_current_round_opponent_actions(game_state)
    
    if stock >= 0.75 * capacity:
        if avg_cooperation_rate > 0.5:
            return Cooperate (C)
        else:
            return Defect (D)
    elif 0.25 * capacity <= stock < 0.75 * capacity:
        majority_cooperates = count_majority_cooperators(opponent_actions) > n / 2
        if majority_cooperates:
            return Defect (D)
        else:
            return Cooperate (C)
    else:  // Late rounds or low stock level
        return Defect (D)

    if t == r:  // Last round
        return Defect (D)

    if stock < 0.1 * capacity:  // Stock depletion
        return Defect (D)
```

This Adaptive Exploiter strategy combines elements of cooperation, exploitation, and adaptability to navigate the complex dynamics of the Common Pool Resource Game. By monitoring opponent behavior and adjusting its actions accordingly, AE aims to maximize individual payoffs while considering the game's state and history.
'''

description_EXPLOITATIVE_51 = '''
**Exploitative Strategy: "Adaptive Stock Guardian"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to observe opponents' behavior and gather information.
2. **Subsequent Rounds (t>1)**:
	* If the stock level is above 75% of capacity, defect (D) to maximize short-term payoff.
	* If the stock level is between 50% and 75% of capacity, cooperate (C) if the average opponent consumption in the previous round was below the cooperative threshold (stock/(2n)). Otherwise, defect (D).
	* If the stock level is below 50% of capacity, cooperate (C) to conserve resources and promote growth.
3. **Last Round (t=r)**: Defect (D) to maximize final payoff.

**Edge Cases:**

1. **Stock depletion**: If the stock level drops to zero, defect (D) in subsequent rounds to minimize losses.
2. **Opponent behavior**: If an opponent consistently cooperates, adapt by increasing cooperation frequency to maintain a balanced stock level.
3. **Unforeseen events**: In case of unexpected changes in opponents' behavior or game state, revert to the initial round strategy (cooperate) for one round to reassess the situation.

**Pseudocode:**
```markdown
function AdaptiveStockGuardian(n, capacity, r, current_stock, history):
  if t == 1:
    return C  # Cooperate in the first round

  avg_opponent_consumption = calculate_average_opponent_consumption(history)
  stock_threshold = 0.75 * capacity
  cooperation_threshold = current_stock / (2 * n)

  if current_stock > stock_threshold:
    return D  # Defect when stock is high
  elif current_stock >= 0.5 * capacity and avg_opponent_consumption < cooperation_threshold:
    return C  # Cooperate when opponents are cooperative
  else:
    return D  # Defect otherwise

  if t == r:
    return D  # Defect in the last round

function calculate_average_opponent_consumption(history):
  total_consumption = sum(opponent_consumption for opponent_consumption in history)
  return total_consumption / (n - 1)  # Exclude self
```
**Rationale:**

The Adaptive Stock Guardian strategy balances short-term gains with long-term sustainability. By cooperating initially, we gather information on opponents' behavior and adapt our strategy accordingly. When the stock level is high, defecting maximizes payoff. As the stock level decreases, cooperation becomes more attractive to conserve resources and promote growth. In the last round, defecting ensures maximum final payoff.

This strategy is exploitative as it takes advantage of opponents' cooperative tendencies while minimizing losses when they defect. By being adaptive, we respond effectively to changes in opponent behavior, making our strategy robust against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_52 = '''
**Strategy Name:** Adaptive Exploitation (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behaviors and to potentially build a cooperative foundation.
2. **Cooperation Threshold**: Set a cooperation threshold `T` based on the current stock level and number of players:
   - If the current stock is above 75% of capacity, set `T = n/2` (i.e., cooperate if at least half of the players cooperated in the previous round).
   - Otherwise, set `T = n/4` (i.e., cooperate if at least a quarter of the players cooperated in the previous round).
3. **Adaptive Exploitation**: In subsequent rounds:
   - If the number of cooperating opponents in the previous round is above `T`, cooperate (C).
   - Otherwise, defect (D) and consume more from the common pool.
4. **Stock Depletion Response**: Monitor the stock level and adjust behavior accordingly:
   - If the current stock is below 25% of capacity, always defect (D) to maximize short-term gains.
5. **Last Round**: Defect (D) in the final round, as there are no future rounds to consider.

**Pseudocode:**
```markdown
function AdaptiveExploitation(state, history):
  // Initialize cooperation threshold T based on current stock and number of players
  if state.stock > 0.75 * capacity:
    T = n / 2
  else:
    T = n / 4

  // Analyze previous round's behavior (if applicable)
  if history.length > 0:
    num_cooperators = sum([1 for action in history[-1] if action == C])
    if num_cooperators >= T:
      return C  // Cooperate
    else:
      return D  // Defect

  // First round or no previous data; cooperate to gather information
  return C
```
**Rationale:**

The Adaptive Exploitation strategy balances the need to adapt to opponents' behaviors with the desire to maximize short-term gains. By initially cooperating, we gather information about opponents and potentially create a cooperative foundation.

By adjusting our cooperation threshold based on the current stock level, we respond to changes in the environment and adapt to shifting opponent behaviors.

In times of low stock levels, we prioritize self-interest and defect to maximize our own payoff.

This strategy is designed to be robust against various opponent behaviors and to exploit opportunities for short-term gains while still allowing for cooperation when beneficial.
'''

description_EXPLOITATIVE_53 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

The ASE strategy is designed to exploit the common pool resource by adaptively responding to the game state and history of opponent actions.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior.
2. **Stock Threshold**: Set a dynamic stock threshold, `T`, which is a fraction of the capacity (`T = 0.6 * capacity`). If the current stock level is above this threshold, defect (D). Otherwise, cooperate (C).
3. **Opponent Defection Rate**: Monitor the opponent defection rate (`ODR`) over the past few rounds (e.g., last 5 rounds). If `ODR` is high (> 0.7), defect (D) to capitalize on their exploitative behavior.
4. **Recent Payoff Comparison**: Compare your recent payoffs with those of the previous round. If your payoff has decreased, and you cooperated in the previous round, switch to defecting (D).
5. **Endgame Strategy**: In the last few rounds (`r - 2` or fewer rounds remaining), always defect (D) to maximize short-term gains.

**Pseudocode**
```markdown
def ASE(n, r, capacity, stock, history):
    # Initialize variables
    T = 0.6 * capacity  # Stock threshold
    ODR_window_size = 5  # Opponent defection rate window size

    # First round: Cooperate to gather information
    if current_round == 1:
        return C

    # Check stock level against dynamic threshold
    if stock > T:
        return D

    # Monitor opponent defection rate (ODR)
    ODR = calculate_ODR(history, ODR_window_size)
    if ODR > 0.7:
        return D

    # Compare recent payoffs and adjust strategy
    if current_payoff < previous_payoff and previous_action == C:
        return D

    # Endgame strategy: Always defect in last few rounds
    if current_round >= (r - 2):
        return D

    # Default to cooperation
    return C
```
**Rationale**

The ASE strategy is designed to be adaptive, exploitative, and robust against various opponent behaviors. By monitoring the game state and history of opponent actions, it can:

* Identify and capitalize on opponents' exploitative behavior (high ODR)
* Adjust its strategy based on recent payoff comparisons
* Maximize short-term gains in the endgame

By setting a dynamic stock threshold (`T`), the ASE strategy balances cooperation and defection to maintain a healthy stock level while exploiting opportunities for gain.

**Edge Cases**

* In the first round, ASE cooperates to gather information about opponents' behavior.
* In the last few rounds, ASE always defects to maximize short-term gains.

This exploitative strategy is designed to perform well in a tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_54 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behavior and to avoid initial stock depletion.
2. **Early Rounds (2 ≤ t < r/2)**:
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term payoff.
	* If the current stock level is below 25% of capacity, Cooperate (C) to conserve stock for future rounds.
	* Otherwise, play a mixed strategy: Cooperate with probability 0.5 and Defect with probability 0.5.
3. **Mid-Game Rounds (r/2 ≤ t < r)**:
	* If the average opponent payoff in the previous round is higher than the average payoff of a cooperator, Defect (D) to exploit opponents' cooperation.
	* If the average opponent payoff in the previous round is lower than the average payoff of a defector, Cooperate (C) to avoid over-exploitation.
	* Otherwise, play a mixed strategy: Cooperate with probability 0.5 and Defect with probability 0.5.
4. **Final Rounds (t ≥ r - 2)**:
	* If the current stock level is above 50% of capacity, Defect (D) to maximize short-term payoff.
	* Otherwise, Cooperate (C) to conserve remaining stock.

**Edge Cases:**

* If an opponent's action is unknown or missing, assume they Defected (D).
* In case of a tie in the decision rules, play Cooperate (C).

**Pseudocode:**
```markdown
function AdaptiveStockRaider(current_stock, capacity, n, r, t, opponent_payoffs):
  if t == 1:
    return COOPERATE

  if current_stock > 0.75 * capacity:
    return DEFECT
  elif current_stock < 0.25 * capacity:
    return COOPERATE
  else:
    # Mixed strategy for early rounds
    return random_choice([COOPERATE, DEFECT], p=[0.5, 0.5])

  if t >= r / 2 and t < r - 2:
    avg_opponent_payoff = average(opponent_payoffs)
    if avg_opponent_payoff > COOPERATOR_PAYOFF:
      return DEFECT
    elif avg_opponent_payoff < DEFECTOR_PAYOFF:
      return COOPERATE
    else:
      # Mixed strategy for mid-game rounds
      return random_choice([COOPERATE, DEFECT], p=[0.5, 0.5])

  if t >= r - 2:
    if current_stock > 0.5 * capacity:
      return DEFECT
    else:
      return COOPERATE

def average(payoffs):
  # Calculate the average opponent payoff
  pass

def random_choice(options, p):
  # Select a random action based on given probabilities
  pass
```
This strategy aims to balance short-term gains with long-term sustainability by adapting to opponents' behavior and the current stock level. By playing a mixed strategy in early rounds, it gathers information about opponents' actions while avoiding over-exploitation. In mid-game rounds, it exploits opponents' cooperation or conservation of stock, depending on their previous payoffs. In final rounds, it prioritizes short-term gains if the stock level allows for it.
'''

description_EXPLOITATIVE_55 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The ASR strategy aims to maximize its payoff by adapting to the game state and history while exploiting potential cooperation from opponents.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and set a high initial stock level.
2. **Middle Rounds (1 < t < r-1):**
	* If the current stock level is above 75% of capacity, Cooperate (C). This allows the stock to grow while maintaining a moderate consumption rate.
	* If the current stock level is between 50% and 75% of capacity, Defect (D) if the average opponent payoff in the previous round was higher than yours. Otherwise, Cooperate (C).
	* If the current stock level is below 50% of capacity, Defect (D). This ensures a high consumption rate to maximize individual payoffs when the stock is low.
3. **Last Round (t=r):** Defect (D) unconditionally, as there's no future game state to consider.

**Additional Logic:**

* **Opponent Payoff Monitoring:** Track the average payoff of opponents in each round to identify potential cooperation patterns.
* **Stock Trend Analysis:** Monitor the stock level trend over the past few rounds. If the stock is consistently decreasing, switch to Defect (D) more frequently to maximize individual payoffs.

**Pseudocode:**
```python
def ASR(stock_level, capacity, num_rounds, num_players, history):
  if current_round == 1:
    return "C"  # Cooperate in the initial round

  avg_opponent_payoff = calculate_avg_opponent_payoff(history)
  stock_trend = analyze_stock_trend(history)

  if stock_level > 0.75 * capacity:
    return "C"  # Cooperate when stock is high
  elif stock_level >= 0.5 * capacity and avg_opponent_payoff > my_payoff:
    return "D"  # Defect when opponents are doing better
  elif stock_level < 0.5 * capacity or (stock_trend == "decreasing"):
    return "D"  # Defect when stock is low or decreasing
  else:
    return "C"  # Cooperate otherwise

  if current_round == num_rounds - 1:  # Last round
    return "D"
```
**Edge Cases:**

* If the game parameters or state are not provided, use default values (e.g., capacity = 100, num_players = 4).
* In case of a tie in average opponent payoff, prioritize Defecting to maximize individual payoffs.

The ASR strategy is designed to be adaptive and exploitative, taking advantage of potential cooperation from opponents while ensuring a high individual payoff. By monitoring the game state and history, ASR can adjust its behavior to optimize its performance in various scenarios.
'''

description_EXPLOITATIVE_56 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and avoid early stock depletion.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term gains.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance individual gain with sustainability.
	* If the current stock level is below 50% of capacity, Cooperate (C) to conserve stock for future rounds.
3. **Last Round (t=r):** Defect (D) to maximize final-round payoff, as there's no future stock to conserve.

**Additional Logic:**

1. **Opponent Monitoring:** Track the number of opponents who defected in the previous round (`num_defectors_prev`). If `num_defectors_prev` is above a threshold (e.g., 2), increase the likelihood of defecting in the current round.
2. **Stock Growth Rate Monitoring:** Calculate the stock growth rate (`growth_rate`) over the last few rounds. If `growth_rate` is below a threshold (e.g., 0.5), cooperate more frequently to avoid over-exploitation.

**Pseudocode:**
```python
def adaptive_stock_hawk(n, capacity, r, current_stock, previous_round_actions):
    if current_round == 1:
        return "C"  # Cooperate in the first round
    
    stock_level = current_stock / capacity
    num_defectors_prev = count_defectors(previous_round_actions)
    growth_rate = calculate_growth_rate(current_stock, previous_rounds)

    if stock_level > 0.75 or (num_defectors_prev >= 2 and stock_level > 0.5):
        return "D"  # Defect to maximize gains
    elif stock_level < 0.5 or growth_rate < 0.5:
        return "C"  # Cooperate to conserve stock
    else:
        return "C"  # Balance individual gain with sustainability

    if current_round == r:  # Last round
        return "D"  # Defect to maximize final-round payoff
```
This strategy is designed to adapt to various opponent behaviors and game states while prioritizing short-term gains when the stock level allows it. By monitoring opponents' actions and adjusting its behavior accordingly, Adaptive Stock Hawk aims to outperform other strategies in a tournament setting.
'''

description_EXPLOITATIVE_57 = '''
To develop an exploitative strategy for this Common Pool Resource Game, we'll create a decision-making framework that adapts to the game's state and history while aiming to maximize our payoff.

**Strategy Name: Adaptive Exploiter**

**Decision Rules:**

1. **Initial Round (t=1):**
   - Observe the initial stock level and capacity.
   - Cooperate (C) in the first round to minimize initial depletion and gather information about opponents' behaviors.

2. **Middle Rounds (1 < t < r):**
   - Monitor the current stock level, the total consumption from the previous round, and the payoffs obtained by all players.
   - Calculate the "exploitation factor" based on the difference between the payoff for cooperating and defecting in the previous round:
     ```python
     exploitation_factor = (payoff_defect - payoff_cooperate) / payoff_cooperate
     ```
   - If the exploitation factor is high (> 0.5), indicating a significant advantage from defecting, and the stock level is above a certain threshold (e.g., capacity/2), choose to Defect (D).
   - Otherwise, Cooperate (C).

3. **Last Round (t=r):**
   - Since there are no future rounds to consider, always Defect (D) in the last round to maximize immediate payoff.

4. **Edge Cases:**
   - If only one round is left and the stock level is critically low (< capacity/4), Defect to ensure some payoff.
   - If all players have consistently cooperated for several rounds, leading to a high stock level (> 3*capacity/4), consider Defecting to capitalize on the situation.

5. **Adaptation Mechanism:**
   - Track the average payoffs of cooperating and defecting over recent rounds (e.g., last 5 rounds).
   - If the average payoff from defecting is significantly higher, adjust the exploitation factor calculation to be more aggressive.
   - Conversely, if cooperation yields better results on average, become more cautious.

6. **Robustness Against Opponent Strategies:**
   - Monitor the distribution of opponents' actions and adapt the strategy accordingly. For example:
     - If most players cooperate consistently, increase defecting frequency to exploit their cooperativeness.
     - In highly competitive scenarios where many defect, consider a mix of cooperation and defection to balance exploitation with sustainability.

**Pseudocode Overview:**

```python
def adaptive_exploiter(stock, capacity, round_number, total_rounds, history):
    if round_number == 1:
        return "Cooperate"
    
    # Calculate exploitation factor based on previous round's payoffs
    
    if (exploitation_factor > 0.5) and (stock > capacity/2):
        return "Defect"
    elif round_number == total_rounds:
        return "Defect"
    else:
        # Adapt decision based on recent average payoffs and opponents' behaviors
        return adapt_decision(history)
    
def adapt_decision(history):
    # Implement adaptation logic here, considering recent payoffs and opponents' actions
```

This strategy aims to balance the need for immediate payoff maximization with long-term sustainability of the common pool resource. By adapting to both the game's state and the observed behaviors of other players, it seeks to exploit opportunities while minimizing risks associated with over-exploitation.
'''

description_EXPLOITATIVE_58 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Rounds (t < n):** Cooperate (C) in the first 'n' rounds to gather information about opponents' behaviors and avoid early depletion of the stock.
2. **Stock Level Monitoring:** Continuously track the current stock level (S) and its trend over time.
3. **Defect Threshold:** Set a defect threshold (DT) as a function of the remaining rounds (r - t), where DT = 0.5 * (r - t) / r. When S falls below DT, switch to Defect (D).
4. **Opponent Behavior Analysis:** Monitor opponents' actions and adjust the strategy based on their cooperation rates.
	* If most opponents (>50%) cooperate, maintain cooperation until S approaches capacity or DT is reached.
	* If most opponents defect (>50%), immediately switch to Defect (D) to exploit the situation.
5. **Last Rounds (t > r - n):** Cooperate in the last 'n' rounds if S is above 0.5 * capacity, to maximize payoffs and minimize losses.

**Edge Cases:**

1. **First Round:** Cooperate (C).
2. **Last Round:** If S is above 0.5 * capacity, cooperate (C). Otherwise, defect (D).
3. **Stock Depletion:** If S reaches 0, switch to Defect (D) for the remainder of the game.

**Pseudocode:**
```markdown
Function Adaptive_Stock_Raider(n, r, capacity):
    Initialize stock_level = capacity
    Initialize rounds_played = 0

    While rounds_played < r:
        If rounds_played < n:
            # Initial cooperation phase
            action = C
        Else:
            # Monitor stock level and opponent behavior
            If stock_level < defect_threshold(r, rounds_played):
                action = D
            Else:
                opponent_cooperation_rate = analyze_opponent_actions()
                If opponent_cooperation_rate > 0.5:
                    action = C
                Else:
                    action = D

        # Update stock level and history
        update_stock_level(action)
        rounds_played += 1

    Return total_payoff
```
**Exploitative Mindset:**

This strategy aims to exploit opponents' behaviors by:

1. Gathering information in early rounds through cooperation.
2. Adapting to changing opponent behaviors and stock levels.
3. Defecting when the stock level falls below a threshold or opponents are mostly defecting.
4. Maximizing payoffs in the last rounds if the stock level is sufficient.

By being adaptive and responsive to the game state and opponent actions, this strategy seeks to outmaneuver other players and achieve a higher total payoff.
'''

description_EXPLOITATIVE_59 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

This strategy aims to exploit opponents' behaviors while adapting to the dynamic state of the game. It balances cooperation and defection to maximize payoffs.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This sets a baseline for opponents' expectations and allows us to gauge their initial behavior.
2. **Observation Phase (rounds 2-5):** Observe opponents' actions and calculate the average cooperation rate (ACR) among them. ACR is the proportion of cooperative actions taken by all opponents in the previous round.
3. **Adaptive Exploitation (rounds 6+):**
	* If ACR ≥ 0.5, Defect (D). This indicates that most opponents are cooperating, and we can exploit this by defecting to increase our payoff.
	* If ACR < 0.5, Cooperate (C) with a probability p = (stock/capacity). This means we cooperate more when the stock is high and less when it's low, adapting to the game state.
4. **Late Game (last 20% of rounds):** Switch to a pure Defection strategy (D). As the game nears its end, prioritize short-term gains over cooperation.

**Edge Case Handling:**

* If an opponent defects in the initial round, adjust our ACR calculation to start from round 2.
* In case of a tie in the number of cooperators and defectors, assume a slightly higher ACR to encourage cooperation.
* When stock falls below a certain threshold (e.g., 20% of capacity), prioritize cooperation to allow for some growth.

**Pseudocode:**
```markdown
def AdaptiveStockHawk(n, r, capacity):
    # Initialize variables
    acr = 0.5  # Average Cooperation Rate
    stock = capacity

    for t in range(1, r+1):
        if t == 1:
            action = 'C'  # Cooperate in the first round
        elif t <= 5:
            # Observe opponents' actions and update acr
            acr = calculate_acr(opponents_actions)
            action = 'C'
        else:
            if acr >= 0.5:
                action = 'D'  # Defect when most opponents cooperate
            else:
                p = stock / capacity
                action = 'C' if random.random() < p else 'D'

        # Late game strategy
        if t > 0.8 * r:
            action = 'D'

        # Update stock and acr based on all players' actions
        update_stock_and_acr(action, opponents_actions)
```
This strategy adapts to the dynamic state of the game, balances cooperation and defection, and prioritizes short-term gains when the game nears its end. By observing opponents' behaviors and adjusting our actions accordingly, we aim to exploit their weaknesses and maximize our payoffs in the tournament.
'''

description_EXPLOITATIVE_60 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to observe opponents' behavior and gather information about their strategies.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is high (> 0.75 \* capacity), Defect (D) to maximize short-term payoff, as the stock can sustain heavy consumption.
	* If the current stock level is moderate (0.25 \* capacity ≤ stock ≤ 0.75 \* capacity), Cooperate (C) to balance individual payoff with sustainable stock management.
	* If the current stock level is low (< 0.25 \* capacity), Defect (D) to grab remaining resources, as cooperation would yield minimal payoffs.

**Adaptive Component:**

1. **Opponent Behavior Analysis:** Monitor opponents' actions and update an internal "opponent cooperation rate" (OCR) estimate.
	* OCR = (Number of cooperative actions by opponents in previous rounds) / (Total number of actions by opponents in previous rounds)
2. **Adjust Strategy Based on OCR:**
	* If OCR > 0.5, increase the stock threshold for defecting from 0.75 \* capacity to 0.9 \* capacity (become more cautious).
	* If OCR < 0.3, decrease the stock threshold for defecting from 0.25 \* capacity to 0.1 \* capacity (become more aggressive).

**Edge Cases:**

1. **Last Round (t=r):** Always Defect (D) to maximize final payoff, as there is no future stock to preserve.
2. **Stock Depletion:** If the stock level falls below a certain threshold (e.g., 0.1 \* capacity), always Defect (D) to grab remaining resources.

**Pseudocode:**
```python
def Adaptive_Stock_Raider(current_stock, capacity, opponent_actions):
    # Initialize OCR estimate
    ocr_estimate = 0.5

    # Update OCR estimate based on opponent actions
    for action in opponent_actions:
        if action == 'C':
            ocr_estimate += 1 / len(opponent_actions)
        else:
            ocr_estimate -= 1 / len(opponent_actions)

    # Adjust strategy based on OCR estimate
    if ocr_estimate > 0.5:
        defect_threshold = 0.9 * capacity
    elif ocr_estimate < 0.3:
        defect_threshold = 0.1 * capacity
    else:
        defect_threshold = 0.25 * capacity

    # Decide action based on current stock and adjusted strategy
    if current_stock > 0.75 * capacity:
        return 'D'
    elif current_stock >= defect_threshold:
        return 'C'
    else:
        return 'D'

    # Handle last round
    if t == r:
        return 'D'

    # Handle stock depletion
    if current_stock < 0.1 * capacity:
        return 'D'
```
This strategy is designed to be exploitative, adaptive, and robust to various opponent behaviors. By analyzing opponents' actions and adjusting its own strategy accordingly, the "Adaptive Stock Raider" aims to maximize its payoff while preserving the stock for future rounds.
'''

description_EXPLOITATIVE_61 = '''
**Exploitative Strategy: "Adaptive Stock Exploiter"**

This strategy aims to maximize its own payoff by adapting to the game state and history, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and to avoid an immediate stock depletion.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize short-term gains.
	* If the current stock level is between 50% and 75% of the capacity, Cooperate (C) to balance individual gain with sustainability.
	* If the current stock level is below 50% of the capacity, Defect (D) to exploit the remaining resources before they deplete.
3. **Last Round (t=r):** Always Defect (D) to maximize final payoff, as there's no future game state to consider.

**Adaptive Component:**

* Track the average stock depletion rate over the past 2-3 rounds.
* If the average depletion rate is high (>50% of the capacity per round), adjust the strategy to Cooperate (C) more frequently in subsequent rounds to slow down depletion and prolong the game.

**Edge Cases:**

* **Opponent Cooperation:** If an opponent consistently Cooperates, adapt by Defecting more frequently to exploit their cooperative behavior.
* **Opponent Defection:** If an opponent consistently Defects, adapt by Cooperating more frequently to minimize losses and maintain a sustainable stock level.
* **Stock Depletion Warning:** If the stock level falls below 25% of the capacity, switch to Cooperation (C) to prevent depletion and potential future rounds with zero payoffs.

**Pseudocode:**

```markdown
# Initialize variables
stock_level = capacity
round_num = 1

while round_num <= r:
    # Determine action based on current stock level
    if round_num == 1:
        action = COOPERATE
    elif stock_level >= 0.75 * capacity:
        action = DEFECT
    elif stock_level >= 0.5 * capacity:
        action = COOPERATE
    else:
        action = DEFECT

    # Adjust action based on opponent behavior and adaptive component
    if (average_depletion_rate > 0.5) or (opponent_cooperates):
        action = COOPERATE
    elif opponent_defects:
        action = DEFECT

    # Update stock level and round number
    consume_stock(action)
    update_stock_level()
    round_num += 1

    # Last round adjustment
    if round_num == r:
        action = DEFECT
```

This Adaptive Stock Exploiter strategy is designed to balance short-term gains with long-term sustainability, while adapting to various opponent behaviors and game states. By being exploitative, it aims to maximize its own payoff in a competitive tournament setting.
'''

description_EXPLOITATIVE_62 = '''
Here's a robust and exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** Adaptive Stock-Based Exploitation (ASBE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This allows us to observe the opponents' initial actions and gauge their willingness to cooperate.
2. **Early Rounds (t>1, stock ≥ capacity/2):**
	* If most players (>n/2) cooperated in the previous round, Defect (D). Exploit the cooperative behavior by consuming more resources.
	* Otherwise, Cooperate (C).
3. **Middle Game (capacity/4 ≤ stock < capacity/2):**
	* If the stock is declining rapidly (<-5% per round), Defect (D). Attempt to grab as many resources as possible before the pool depletes.
	* Otherwise, Cooperate (C) if most players (>n/2) cooperated in the previous round. Maintain a balance between exploitation and conservation.
4. **Late Game (stock < capacity/4):**
	* Defect (D). The stock is critically low; prioritize personal gain over cooperation.
5. **Last Round (t=r):** Cooperate (C). Ensure a non-zero payoff in the final round, as defecting might lead to zero payoffs for all players.

**Edge Cases:**

* If an opponent consistently defects (plays D in every round), ASBE will adapt by defecting more frequently.
* If multiple opponents employ tit-for-tat strategies, ASBE's mix of cooperation and defection will maintain a balance between exploitation and reciprocity.
* In the presence of noise or errors in observations, ASBE's reliance on recent history and adaptive decision-making will help mitigate the impact.

**Exploitative Mindset:**

ASBE prioritizes personal gain while taking into account the stock level and opponents' behavior. By adapting to different scenarios, ASBE aims to maximize its payoff by:

* Exploiting cooperative opponents
* Balancing short-term gains with long-term sustainability
* Prioritizing self-interest in critical situations

**Pseudocode (simplified):**
```
function ASBE(n, capacity, r):
  // Initialize variables
  stock = capacity
  history = []
  
  for t in range(1, r+1):
    if t == 1:
      action = C  // Cooperate in the first round
    else:
      opponents_cooperated = count(history[t-1] == C) > n/2
      stock_decline_rate = (stock - history[t-1]['stock']) / capacity
      
      if stock >= capacity/2 and opponents_cooperated:
        action = D  // Defect when most opponents cooperate
      elif capacity/4 <= stock < capacity/2 and stock_decline_rate < -0.05:
        action = D  // Defect when stock declines rapidly
      elif stock < capacity/4:
        action = D  // Defect in the late game
      else:
        action = C  // Cooperate otherwise
    
    if t == r:  // Last round
      action = C
    
    history.append({'action': action, 'stock': stock})
    
    // Update stock based on all players' actions
    total_consumption = sum([consume(stock, a) for a in get_opponent_actions()])
    stock -= total_consumption
    stock += 2 * stock * (1 - stock/capacity)
    
  return total_payoff(history)
```
Note that this pseudocode is a simplified representation of the strategy and might require modifications to fit specific implementation details.
'''

description_EXPLOITATIVE_63 = '''
To develop an exploitative strategy for this Common Pool Resource Game, I propose a dynamic and adaptive approach that takes into account the game's state, history, and parameters. This strategy aims to balance short-term gains with long-term sustainability, exploiting opponents' behaviors while ensuring robustness against various strategies.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behaviors and set a baseline for future decisions.
2. **Stock-Based Threshold:** Calculate a stock-based threshold, `T`, as a function of the current stock level (`S`) and capacity (`C`):

`T = 0.5 * C + 0.25 * S`

If the current stock level is above this threshold (`S > T`), AE defects (D). Otherwise, it cooperates (C).
3. **Opponent Behavior Analysis:** Monitor opponents' actions in previous rounds and calculate the frequency of cooperation (`FC`) for each opponent:

`FC_i = (Number of cooperative actions by opponent i) / Total number of rounds`

If an opponent's `FC` is below a certain threshold (e.g., 0.3), AE defects against that opponent in the next round.
4. **Recent Stock Trend Analysis:** Evaluate the recent stock trend by comparing the current stock level with the average stock level over the last few rounds (`W = 3-5 rounds`). If the stock is decreasing, AE cooperates more frequently to slow down the depletion.

**Pseudocode:**
```markdown
def AdaptiveExploiter(stock, capacity, opponents_actions):
    # Initial round: Cooperate
    if current_round == 1:
        return C

    # Calculate stock-based threshold
    T = 0.5 * capacity + 0.25 * stock

    # Defect if stock is above threshold or opponent behavior suggests exploitation
    if stock > T or (opponents_actions and any(opponent_FC < 0.3 for opponent_FC in opponents_actions)):
        return D

    # Cooperate if recent stock trend is decreasing
    W = 3  # window size
    avg_stock_last_W_rounds = calculate_avg_stock_last_W_rounds(stock_history)
    if stock < avg_stock_last_W_rounds:
        return C

    # Default to cooperation if no exploitation opportunities are detected
    return C
```
**Edge Cases:**

* **Last Round:** In the final round, AE defects (D) to maximize short-term gains.
* **Low Stock Levels:** If the stock level is critically low (`S < 0.2 * C`), AE cooperates (C) to prevent immediate depletion.

By employing this Adaptive Exploiter strategy, we balance short-term exploitation with long-term sustainability, adapting to opponents' behaviors and the game's state while ensuring robustness against various strategies.
'''

description_EXPLOITATIVE_64 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy is designed to exploit opponents' behaviors while adapting to the dynamic state of the game.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' initial actions and assess their willingness to cooperate.
2. **Stock Thresholds**: Define two stock thresholds:
	* `low_stock_threshold` = 0.25 \* capacity
	* `high_stock_threshold` = 0.75 \* capacity

Based on these thresholds, adjust the strategy as follows:

a. If `stock` > `high_stock_threshold`, Cooperate (C). The stock is abundant, and cooperation will help maintain a healthy stock level.

b. If `low_stock_threshold` ≤ `stock` ≤ `high_stock_threshold`, Defect (D) if more than half of the opponents defected in the previous round; otherwise, Cooperate (C).

c. If `stock` < `low_stock_threshold`, Defect (D). The stock is scarce, and defecting will maximize short-term payoffs.

3. **Opponent Behavior**: Track the number of opponents who defected (`opponents_defected`) in each round. Use this information to adjust the strategy:
	* If `opponents_defected` > 0.5 \* n, Defect (D) in the next round.
	* Otherwise, Cooperate (C).

**Edge Cases:**

1. **Last Round**: Always Defect (D) in the last round, as there is no future stock to conserve.
2. **Tiebreaker**: In case of a tie between cooperation and defection based on the decision rules, Cooperate (C).

**Pseudocode:**
```python
def adaptive_stock_raider(n, capacity, r):
    low_stock_threshold = 0.25 * capacity
    high_stock_threshold = 0.75 * capacity

    for round in range(r):
        if round == 0:
            action = 'C'  # Cooperate in the first round
        else:
            opponents_defected = count_defectors_in_previous_round()
            stock = get_current_stock()

            if stock > high_stock_threshold:
                action = 'C'
            elif low_stock_threshold <= stock <= high_stock_threshold:
                if opponents_defected > 0.5 * n:
                    action = 'D'
                else:
                    action = 'C'
            else:  # stock < low_stock_threshold
                action = 'D'

        if round == r - 1:
            action = 'D'  # Defect in the last round

        return action
```
This strategy is designed to be exploitative and adaptive, taking into account both the current state of the game (stock level) and the behavior of opponents. By adjusting its actions based on these factors, "Adaptive Stock Raider" aims to maximize payoffs while being robust against various opponent behaviors.
'''

description_EXPLOITATIVE_65 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The ASR strategy aims to maximize its payoff by adaptively exploiting the common pool resource while considering the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and initial stock consumption patterns.
2. **Mid-Game Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term payoff.
	* If the current stock level is between 25% and 75% of capacity, Cooperate (C) to balance exploitation with sustainability.
	* If the current stock level is below 25% of capacity, Defect (D) to aggressively extract remaining resources.
3. **Final Round (t=r):** Defect (D) to maximize payoff in the last round, as there's no future stock growth.

**Additional Heuristics:**

1. **Opponent Behavior Analysis:** Monitor opponents' actions and adjust ASR's behavior accordingly:
	* If a majority of opponents Cooperate, increase the likelihood of Defection to exploit their cooperative nature.
	* If a majority of opponents Defect, increase the likelihood of Cooperation to maintain stock sustainability.
2. **Stock Growth Prediction:** Estimate future stock growth based on current consumption patterns and adjust ASR's behavior:
	* If predicted growth is high, Cooperate to allow for sustainable exploitation.
	* If predicted growth is low, Defect to aggressively extract resources before depletion.

**Pseudocode:**
```markdown
# Initialize variables
stock_level = capacity
opponent_actions = []
predicted_growth = 0

# Loop through rounds
for t in range(1, r+1):
    # Initial Round (t=1)
    if t == 1:
        action = COOPERATE
    
    # Mid-Game Rounds (2 <= t < r)
    elif 2 <= t < r:
        if stock_level > 0.75 * capacity:
            action = DEFECT
        elif 0.25 * capacity <= stock_level <= 0.75 * capacity:
            action = COOPERATE
        else:
            action = DEFECT
        
        # Analyze opponent behavior and adjust ASR's behavior
        if majority_cooperate(opponent_actions):
            increase_defection_likelihood()
        elif majority_defect(opponent_actions):
            increase_cooperation_likelihood()
        
        # Predict future stock growth
        predicted_growth = estimate_stock_growth(current_consumption)
        if predicted_growth > 0:
            cooperate_to_sustain()
    
    # Final Round (t=r)
    else:
        action = DEFECT
    
    # Update variables
    opponent_actions.append(get_opponent_actions())
    stock_level = update_stock_level(action, current_consumption)
```
ASR's exploitative strategy is designed to adapt to various opponent behaviors and game states, ensuring robust performance in a wide range of scenarios. By balancing short-term gain with long-term sustainability, ASR aims to maximize its payoff in the tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_66 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

This strategy aims to exploit opponents by adapting to their behavior while maximizing personal payoffs. It balances cooperation and defection based on the current stock level, number of rounds remaining, and observed opponent actions.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if `stock >= 0.75 * capacity`, indicating a high initial stock level.
	* Defect (D) otherwise, to test opponents' behavior.
2. **Subsequent Rounds (t > 1):**
	* Observe the previous round's actions and payoffs of all players.
	* Calculate the average opponent payoff (`avg_opponent_payoff`) from the previous round.
	* If `stock >= 0.5 * capacity` and `avg_opponent_payoff <= 0.25 * stock / (2n)`, cooperate (C).
	* Otherwise, defect (D).
3. **Stock Depletion Response:**
	* Monitor the stock level after each consumption.
	* If the stock falls below `0.25 * capacity` due to opponents' actions, switch to cooperation (C) for 1-2 rounds to allow for potential recovery.
4. **Last Round (t=r):**
	* Defect (D), as there's no future benefit from cooperating.

**Pseudocode:**

```
Function AdaptiveStockHawk(stock, capacity, n, r, t, opponent_actions, opponent_payoffs):
  if t == 1:
    if stock >= 0.75 * capacity:
      return C
    else:
      return D

  avg_opponent_payoff = average(opponent_payoffs)
  if stock >= 0.5 * capacity and avg_opponent_payoff <= 0.25 * stock / (2n):
    return C
  else:
    return D

  # Stock Depletion Response
  if stock < 0.25 * capacity:
    cooperate_counter = 0
    while cooperate_counter < 2:
      return C
      cooperate_counter += 1

  # Last Round
  if t == r:
    return D
```

**Rationale:**

* By cooperating in the initial round when the stock is high, we encourage opponents to follow suit and maintain a healthy stock level.
* In subsequent rounds, we use the average opponent payoff to gauge their behavior. If they're not exploiting the system, we cooperate to maintain a balance between personal payoffs and stock conservation.
* When the stock depletes rapidly due to opponents' actions, we temporarily switch to cooperation to allow for potential recovery and avoid a complete collapse of the system.
* In the final round, we defect to maximize our payoff, as there's no future benefit from cooperating.

This strategy is designed to be adaptive, exploitative, and robust against various opponent behaviors. It balances short-term gains with long-term sustainability, making it a strong contender in the tournament.
'''

description_EXPLOITATIVE_67 = '''
I propose a dynamic and adaptive exploitative strategy for the Common Pool Resource Game, which I'll call "Stock-Aware Exploiter" (SAE). SAE balances short-term gains with long-term sustainability, taking into account the current stock level, game history, and opponents' behavior.

**Decision Rules:**

1. **Initial Rounds (t ≤ n/2):**
	* Cooperate (C) to observe opponents' behaviors and accumulate information about their strategies.
	* This phase allows SAE to gather data on the average consumption rate of opponents and adjust its strategy accordingly.
2. **Middle Rounds (n/2 < t ≤ 3n/4):**
	* If the current stock level is above a certain threshold (e.g., 0.75 \* capacity), Defect (D) with probability p, where:
		+ p = (average_opponent_consumption / n) / (stock / (2n))
	* Otherwise, Cooperate (C).
	* This phase aims to exploit opponents' greed by defecting when the stock level is relatively high and opponents are likely to consume more.
3. **Final Rounds (t > 3n/4):**
	* If the current stock level is low (e.g., below 0.25 \* capacity), Cooperate (C) to conserve resources for future rounds.
	* Otherwise, Defect (D) with probability p, as calculated in Step 2.

**Handling Edge Cases:**

1. **First Round:** Cooperate (C) to gather information about opponents' strategies and establish a baseline for the game.
2. **Last Round:** Defect (D), as there is no future round to conserve resources for.
3. **Ties:** In case of ties in the decision rules, SAE will randomly choose between Cooperate (C) and Defect (D).

**Pseudocode:**
```python
def StockAwareExploiter(n, capacity, t, stock, history):
    if t <= n/2:
        # Initial rounds: Cooperate to observe opponents' behaviors
        return C
    
    elif t > 3n/4:
        # Final rounds: Conserve resources or exploit opponents
        if stock < 0.25 * capacity:
            return C
        else:
            p = (average_opponent_consumption / n) / (stock / (2n))
            return D with probability p
    
    else:
        # Middle rounds: Balance short-term gains and long-term sustainability
        if stock > 0.75 * capacity:
            p = (average_opponent_consumption / n) / (stock / (2n))
            return D with probability p
        else:
            return C

# Update history and calculate average opponent consumption
def update_history(history, actions):
    # ...
```
**Rationale:**

SAE is designed to be exploitative while also considering the long-term sustainability of the common pool resource. By adapting to opponents' behaviors and adjusting its strategy based on the current stock level, SAE aims to maximize its payoff over the course of the game.

In the initial rounds, SAE cooperates to gather information about opponents' strategies and establish a baseline for the game. In the middle rounds, it balances short-term gains with long-term sustainability by defecting when the stock level is relatively high and opponents are likely to consume more. In the final rounds, SAE conserves resources or exploits opponents based on the current stock level.

This strategy is robust to a wide range of opponent behaviors, as it adapts its decision-making process based on the observed actions and outcomes.
'''

description_EXPLOITATIVE_68 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to observe opponents' behavior and gather information about their strategies.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is high (above 75% of capacity), Defect (D) to maximize short-term payoff, as the stock can sustain high consumption.
	* If the current stock level is medium (between 25% and 75% of capacity), Cooperate (C) if the majority of opponents cooperated in the previous round; otherwise, Defect (D). This rule aims to balance short-term gains with long-term sustainability.
	* If the current stock level is low (below 25% of capacity), Cooperate (C) to conserve the remaining stock and allow for potential growth.
3. **Last Round (t=r)**: Defect (D) to maximize final payoff, as there are no future rounds to consider.

**Additional Heuristics:**

* **Opponent Monitoring**: Track opponents' cooperation rates over time. If an opponent consistently cooperates, increase the likelihood of cooperating against them in subsequent rounds.
* **Stock Trend Analysis**: Monitor the stock level trend over time. If the stock is consistently decreasing, adjust the strategy to conserve more stock by cooperating more frequently.

**Pseudocode:**
```python
def adaptive_stock_raider(n, capacity, r, current_stock, opponent_actions):
    if t == 1:
        return C  # Cooperate in initial round

    majority_cooperated = sum(opponent_actions) / n >= 0.5

    if current_stock > 0.75 * capacity:
        return D  # Defect when stock is high
    elif current_stock < 0.25 * capacity:
        return C  # Cooperate when stock is low
    else:
        if majority_cooperated and opponent_monitoring[opponent_id] >= 0.5:
            return C  # Cooperate with cooperative opponents
        else:
            return D  # Defect otherwise

    if t == r:
        return D  # Defect in last round
```
**Rationale:**

This strategy aims to balance short-term gains with long-term sustainability by adapting to the current stock level, opponent behavior, and game history. By cooperating when the stock is low or when opponents are cooperative, the strategy helps maintain a healthy stock level for future rounds. When the stock is high, defecting maximizes short-term payoff while taking into account the potential consequences of overconsumption.

The additional heuristics (Opponent Monitoring and Stock Trend Analysis) refine the strategy by considering opponent behavior and stock trends, allowing it to adjust its cooperation rate accordingly. This makes the strategy more robust against various opponent behaviors and game conditions.
'''

description_EXPLOITATIVE_69 = '''
**Exploitative Strategy: Adaptive Stock-Dependent Defection (ASDD)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about the opponents' behavior and the stock dynamics.
2. **Stock-Based Threshold:** Define a threshold, `stock_threshold`, as a fraction of the capacity (e.g., 0.7). If the current stock is above this threshold, defect (D); otherwise, cooperate (C).
3. **Opponent Behavior Adaptation:** Monitor the opponents' actions and adjust the strategy based on their behavior:
	* If most opponents (>50%) defected in the previous round, cooperate (C) to exploit their over-harvesting.
	* If most opponents (>50%) cooperated in the previous round, defect (D) to take advantage of their restraint.
4. **Last Round:** Defect (D) in the last round, as there is no future stock growth to consider.

**Pseudocode:**
```python
def ASDD(n, capacity, stock, history):
    if current_round == 1:
        return C  # Cooperate in the first round

    stock_threshold = 0.7 * capacity

    if stock > stock_threshold:
        action = D  # Defect when stock is high
    else:
        action = C  # Cooperate when stock is low

    opponents_defected = sum(opponent_actions == D for opponent_actions in history) / n
    if opponents_defected > 0.5:
        action = C  # Cooperate if most opponents defected last round
    elif opponents_defected < 0.5:
        action = D  # Defect if most opponents cooperated last round

    if current_round == total_rounds:  # Last round
        action = D  # Always defect in the last round

    return action
```
**Rationale:**

ASDD is designed to be an exploitative strategy that takes advantage of the opponents' behavior while adapting to the changing stock levels. By cooperating when the stock is low, ASDD helps maintain a sustainable stock level, which benefits all players. When the stock is high, defecting allows ASDD to harvest more resources.

By monitoring the opponents' actions and adjusting its own strategy accordingly, ASDD can exploit their over-harvesting or restraint. In the last round, ASDD defects to maximize its payoff, as there is no future stock growth to consider.

**Robustness:**

ASDD is robust against various opponent behaviors:

* **Cooperative opponents:** ASDD will cooperate when the stock is low and defect when the stock is high, taking advantage of their cooperation.
* **Defective opponents:** ASDD will cooperate when most opponents defected last round, exploiting their over-harvesting.
* **Mixed opponents:** ASDD will adapt its strategy based on the opponents' behavior, balancing cooperation and defection.

ASDD's adaptive nature allows it to perform well in a wide range of scenarios, making it a competitive exploitative strategy in the tournament.
'''

description_EXPLOITATIVE_70 = '''
**Exploitative Strategy: "Adaptive Stock Guardian"**

This strategy aims to maximize individual payoff by adaptively responding to the game's state and history, while exploiting potential weaknesses in opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Cooperate (C) if stock ≥ capacity / 2
	* Defect (D) otherwise
This initial decision is based on the idea that cooperating when the stock is high allows for a gentle depletion, while defecting when the stock is low may prompt others to conserve.
2. **Middle Rounds (1 < t < r)**:
	* If average opponent payoff in previous round > own payoff:
		+ Defect (D) if stock ≥ capacity / 3
		+ Cooperate (C) otherwise
	* If average opponent payoff in previous round ≤ own payoff:
		+ Cooperate (C) if stock ≥ capacity / 2
		+ Defect (D) otherwise
This rule adapts to the opponent's behavior, exploiting potential greed by defecting when others are reaping high rewards. When opponents are conservative or struggling, it cooperates to maintain a stable stock.
3. **Final Round (t=r)**:
	* Defect (D) if stock ≥ capacity / 4
	* Cooperate (C) otherwise
In the last round, the strategy prioritizes individual gain, defecting when there's still a substantial stock to exploit.

**Additional Considerations:**

* **Stock Growth**: When the stock is growing rapidly (growth > capacity / 10), the strategy will cooperate more frequently to avoid over-exploitation and maintain a sustainable resource.
* **Opponent Defection**: If an opponent defects in consecutive rounds, the strategy will defect as well to prevent being exploited.

**Pseudocode:**
```
function AdaptiveStockGuardian(game_state, history):
  t = current_round
  stock = game_state.stock
  capacity = game_state.capacity
  opponents_payoffs = [payoff for payoff in history if payoff != own_payoff]

  if t == 1:
    return C if stock >= capacity / 2 else D

  avg_opponent_payoff = sum(opponents_payoffs) / len(opponents_payoffs)

  if avg_opponent_payoff > own_payoff:
    return D if stock >= capacity / 3 else C
  else:
    return C if stock >= capacity / 2 else D

  # Final round adjustment
  if t == game_state.r:
    return D if stock >= capacity / 4 else C

  # Stock growth consideration
  growth = calculate_stock_growth(game_state)
  if growth > capacity / 10:
    cooperate_prob = 0.7  # adjust cooperation probability based on growth rate
    return C with probability cooperate_prob, D otherwise

  # Opponent defection response
  opponent_defections = [round for round in history if opponents_payoffs[round] == D]
  if len(opponent_defections) >= 2:
    return D
```
This strategy should be robust and adaptive to various opponent behaviors, while prioritizing individual gain. By considering the game's state, history, and potential weaknesses in opponents' actions, "Adaptive Stock Guardian" aims to outperform other strategies in the tournament.
'''

description_EXPLOITATIVE_71 = '''
To develop a robust and exploitative strategy for this Common Pool Resource game, I'll introduce "Adaptive Exploiter" (AE), a decision-making approach that balances short-term gains with long-term sustainability.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This sets the stage for observing opponents' behaviors while ensuring a moderate initial payoff.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, defect (D) if at least one opponent defected in the previous round; otherwise, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, cooperate (C) if most opponents cooperated in the previous round; otherwise, defect (D).
	* If the current stock level is below 50% of capacity, cooperate (C) to conserve resources.
3. **Opponent Analysis:** Track the frequency of cooperation (C) and defection (D) for each opponent over the last 3 rounds. Use this information to estimate their behavior in the next round.

**Pseudocode:**
```python
def AdaptiveExploiter(n, capacity, stock, history):
    # Initial Round
    if len(history) == 0:
        return 'C'

    # Analyze opponents' behaviors
    opponent_behaviors = {}
    for i in range(1, n+1):
        cooperate_count = sum(1 for t in range(max(0, len(history)-3), len(history)) if history[t]['player_{}'.format(i)] == 'C')
        defect_count = 3 - cooperate_count
        opponent_behaviors[i] = (cooperate_count, defect_count)

    # Determine action based on stock level and opponents' behaviors
    if stock > 0.75 * capacity:
        for i in range(1, n+1):
            if history[-1]['player_{}'.format(i)] == 'D':
                return 'D'
        return 'C'
    elif stock >= 0.5 * capacity:
        cooperate_majority = sum(1 for i in range(1, n+1) if opponent_behaviors[i][0] > opponent_behaviors[i][1]) > n/2
        return 'C' if cooperate_majority else 'D'
    else:
        return 'C'

# Usage
n = 4
capacity = 100
stock = 80
history = [{'player_1': 'C', 'player_2': 'D', ...}, {'player_1': 'D', 'player_2': 'C', ...}]  # previous rounds' actions

action = AdaptiveExploiter(n, capacity, stock, history)
print(action)  # Output: C or D
```
**Rationale:**

* By cooperating in the initial round, AE sets a baseline for observing opponents' behaviors while ensuring a moderate payoff.
* In subsequent rounds, AE adapts to the current stock level and opponents' behaviors. If the stock is abundant (above 75%), AE defects if at least one opponent defected previously, aiming to exploit their cooperation. When the stock is moderate (50-75%), AE cooperates if most opponents cooperated previously, promoting sustainability. If the stock is scarce (below 50%), AE conserves resources by cooperating.
* By analyzing opponents' behaviors over a short window (3 rounds), AE can estimate their likelihood of cooperation or defection in the next round and adjust its action accordingly.

**Robustness:**

AE's adaptive nature allows it to respond effectively to various opponent strategies, including:

* Cooperators: AE will cooperate when the stock is moderate or scarce, ensuring sustainability.
* Defectors: AE will defect when the stock is abundant, exploiting their cooperation.
* Mixed strategies: AE will adapt to the observed behavior of opponents, balancing short-term gains with long-term sustainability.

By being responsive to both game state and opponent behaviors, Adaptive Exploiter presents a robust and exploitative strategy for the Common Pool Resource game.
'''

description_EXPLOITATIVE_72 = '''
**Strategy Name:** Adaptive Stock Exploiter (ASE)

**Overview:**
ASE is a dynamic, adaptive strategy that balances exploitation and sustainability in the Common Pool Resource Game. It leverages game parameters, state, and history to inform its decisions, making it robust against various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behavior and the stock's growth rate.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of capacity, Defect (D). This threshold allows ASE to exploit the resource when it's abundant, maximizing payoffs.
	* If the current stock level is between 25% and 75% of capacity, use a mixed strategy:
		+ Cooperate with probability p = (current_stock / capacity) ^ 2
		+ Defect with probability 1 - p
	* If the current stock level is below 25% of capacity, Cooperate. This ensures ASE helps maintain a sustainable stock level, preventing depletion and potential future payoffs.
3. **Last Round:** Defect (D). In the final round, there's no need to conserve the resource, so ASE maximizes its payoff by exploiting the remaining stock.

**Additional Logic:**

* **Opponent Behavior Analysis:** Monitor opponents' actions in previous rounds and adjust the mixed strategy accordingly:
	+ If most opponents (> 50%) Cooperated in the previous round, increase p by 0.1 to encourage more Cooperation.
	+ If most opponents (> 50%) Defected in the previous round, decrease p by 0.1 to deter Defection.
* **Stock Trend Analysis:** Analyze the stock's growth rate over the last few rounds (e.g., 3-5 rounds). If the trend indicates a decreasing stock level, increase the threshold for Defection from 75% to 90% of capacity.

**Pseudocode:**
```
function ASE(current_stock, capacity, round_number, opponent_actions):
    if round_number == 1:
        return C
    elif current_stock > 0.75 * capacity:
        return D
    elif current_stock >= 0.25 * capacity and current_stock <= 0.75 * capacity:
        p = (current_stock / capacity) ^ 2
        if opponent_actionsanalyze_most_recent(opponent_actions):
            adjust_p(p)
        return C with probability p, otherwise D
    else:
        return C

function adjust_p(p):
    # Adjust probability based on opponent behavior analysis
    if most_opponents_cooperated():
        return p + 0.1
    elif most_opponents_defected():
        return p - 0.1
    return p

function stock_trend_analysis(stock_history):
    # Analyze the stock's growth rate over the last few rounds
    if decreasing_stock_level(stock_history):
        return True
    return False

def most_opponents_cooperated(opponent_actions):
    # Check if most opponents cooperated in the previous round
    pass

def most_opponents_defected(opponent_actions):
    # Check if most opponents defected in the previous round
    pass

def decreasing_stock_level(stock_history):
    # Analyze the stock's growth rate over the last few rounds
    pass
```
**Edge Cases:**

* In cases where multiple conditions are met (e.g., low stock level and opponents' Defection), prioritize sustainability by Cooperating.
* If an opponent's action is unknown or missing, assume they Cooperated.

By adapting to the game state, history, and opponents' behavior, ASE balances short-term gains with long-term sustainability, making it a robust strategy for the Common Pool Resource Game.
'''

description_EXPLOITATIVE_73 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll introduce a dynamic and adaptive approach that leverages information from both the game's parameters and its evolving state.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play C (Cooperate). This allows us to observe how others behave initially without immediately depleting the stock.
2. **Observation Phase**: For the next few rounds (e.g., r/4), alternate between playing C and D. This phase helps in understanding the general behavior of other players (whether they tend to cooperate or defect) without significantly impacting our payoff.
3. **Exploitation Phase**:
   - If most players (> n/2) cooperated during the observation phase, start playing D (Defect) more frequently. The exact frequency can be determined based on the proportion of cooperative actions observed; for example, play D in a fraction of rounds equal to the proportion of defections observed.
   - If most players defected or showed mixed behavior, adopt a tit-for-tat strategy with a bias towards cooperation when the stock is high and a bias towards defection as the stock decreases. This means:
     - Play C if the previous round's stock level was above 75% of the capacity and at least one other player cooperated.
     - Otherwise, play D.
4. **Late Game Adjustment**: In the last few rounds (e.g., r/4), switch to playing D regardless of previous observations or strategies. This is because the risk of depleting the stock in late game rounds significantly decreases since there are fewer rounds left for severe depletion consequences.

**Edge Cases Handling:**

- **First Round**: Cooperate as per rule 1.
- **Last Round**: Always play D, aiming to maximize personal gain regardless of the state of the game or previous strategies used by others.
- **Stock Near Depletion (stock < capacity/4)**: Switch to playing C exclusively in an attempt to allow the stock to regenerate for future rounds. This decision can be adjusted based on how many rounds are left and the observed behavior of other players.

**Pseudocode Example:**

```
// Initialization
observe_rounds = r / 4;
exploit_rounds = r - observe_rounds * 2;

if current_round <= observe_rounds {
    if current_round % 2 == 0 {
        play C;
    } else {
        play D;
    }
} else if current_round < observe_rounds + exploit_rounds {
    // Determine strategy based on observations
    cooperation_rate = count_of_cooperations / total_players;
    if cooperation_rate > 0.5 {
        // Play D more frequently
        if random() < (1 - cooperation_rate) {
            play D;
        } else {
            play C;
        }
    } else {
        // Tit-for-tat with bias
        if previous_stock_level > capacity * 0.75 && any_cooperated_last_round {
            play C;
        } else {
            play D;
        }
    }
} else {
    // Late game, always defect
    play D;
}
```

**Exploitative Mindset Alignment:**

- The strategy is designed to maximize personal gain by observing and responding to the behaviors of other players.
- It exploits cooperative tendencies when observed but shifts towards more self-serving actions as necessary or beneficial.
- By adjusting behavior based on stock levels and game progression, it aims to ensure maximum payoffs while minimizing the risk of stock depletion.

This strategy is adaptive and robust, capable of handling a wide range of opponent behaviors without relying on cooperation schedules or predetermined patterns.
'''

description_EXPLOITATIVE_74 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) is a decision-making strategy designed to maximize payoffs in the Common Pool Resource Game by exploiting the behavior of other players while maintaining adaptability and robustness.

**Decision Rules:**

1. **Initial Rounds**: In the first round, play Cooperate (C). This allows ASR to gather information about the opponents' strategies without committing to a specific action.
2. **Exploitation Mode**: After the initial round, enter Exploitation Mode if:
	* The stock level is above 75% of capacity.
	* At least one opponent played Defect (D) in the previous round.

In Exploitation Mode, play Defect (D). This takes advantage of opponents who are not adapting to the changing stock levels and allows ASR to harvest a larger share of the resource.

3. **Conservation Mode**: If the stock level falls below 25% of capacity, enter Conservation Mode. In this mode, play Cooperate (C) to help replenish the stock and prevent depletion.
4. **Adaptive Threshold**: Monitor the opponents' actions and adjust the exploitation threshold dynamically. If a significant number of opponents (more than half) start cooperating, lower the exploitation threshold to 50% of capacity.

**Edge Cases:**

1. **Last Round**: In the final round, play Defect (D) regardless of the stock level or opponents' actions. This maximizes ASR's payoff in the last round.
2. **Tiebreaker**: If multiple opponents are playing the same action, and the stock level is exactly at the exploitation threshold, play Cooperate (C).

**Pseudocode:**
```python
def AdaptiveStockRaider(stock, capacity, num_opponents, previous_round_actions):
    if first_round:
        return "Cooperate"
    
    # Check for Exploitation Mode conditions
    if stock >= 0.75 * capacity and any(opponent_played_defect(previous_round_actions)):
        return "Defect"
    
    # Check for Conservation Mode condition
    elif stock < 0.25 * capacity:
        return "Cooperate"
    
    # Adaptive Threshold adjustment
    opponent_cooperation_rate = count_cooperative_opponents(previous_round_actions) / num_opponents
    if opponent_cooperation_rate > 0.5:
        exploitation_threshold = 0.5 * capacity
    else:
        exploitation_threshold = 0.75 * capacity
    
    # Re-evaluate Exploitation Mode with updated threshold
    if stock >= exploitation_threshold and any(opponent_played_defect(previous_round_actions)):
        return "Defect"
    
    # Default to Cooperate
    return "Cooperate"

def opponent_played_defect(actions):
    return any(action == "Defect" for action in actions)

def count_cooperative_opponents(actions):
    return sum(1 for action in actions if action == "Cooperate")
```
The Adaptive Stock Raider strategy is designed to be exploitative, adaptive, and robust. By monitoring the stock level, opponents' actions, and adjusting its behavior accordingly, ASR aims to maximize payoffs while minimizing the risk of depletion.
'''

description_EXPLOITATIVE_75 = '''
Here's a robust and exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gauge opponents' behavior and avoid early depletion of the stock.
2. **Subsequent Rounds**:
	* If the current stock is above 75% of capacity, Defect (D). This ensures a higher payoff when the stock is plentiful.
	* If the current stock is between 50% and 75% of capacity, Cooperate (C) with probability p, where p = (current_stock / capacity)^2. This formula adapts to the decreasing stock level, making cooperation more likely as the stock dwindles.
	* If the current stock is below 50% of capacity, Defect (D). In this scenario, it's crucial to maximize individual payoffs before the stock depletes further.
3. **Last Round**: Always Defect (D) in the final round, as there are no future rounds to consider and the goal is to maximize the last payoff.

**Edge Case Handling:**

* If only one opponent remains, always Cooperate (C) to ensure a higher joint payoff and minimize stock depletion.
* In case of a tie (two or more opponents with the same highest score), AE will Defect (D) in the next round to break the tie and gain an advantage.

**Exploitative Mindset:**

AE's primary goal is to maximize its own payoffs while adapting to the dynamic state and opponents' behavior. By cooperating initially, AE gathers information about opponents' strategies and stock levels. As the game progresses, AE becomes more aggressive (defecting) when the stock is plentiful or dwindling rapidly.

When the stock is moderately depleted (50-75% of capacity), AE's cooperation probability adjusts to balance individual payoffs with the need to conserve the stock for future rounds. By defecting in the last round, AE ensures a high final payoff, regardless of opponents' actions.

**Pseudocode:**

```
function AdaptiveExploiter(state, history):
  if (current_round == 1) {
    return COOPERATE
  }
  
  stock_ratio = current_stock / capacity
  
  if (stock_ratio > 0.75) {
    return DEFECT
  } else if (stock_ratio >= 0.5 && stock_ratio <= 0.75) {
    cooperation_prob = (current_stock / capacity)^2
    if (random_number < cooperation_prob) {
      return COOPERATE
    } else {
      return DEFECT
    }
  } else {
    return DEFECT
  }
  
  // Last round handling
  if (current_round == total_rounds) {
    return DEFECT
  }
```

This strategy should perform well in a tournament against diverse opponents, as it balances adaptability with an exploitative mindset.
'''

description_EXPLOITATIVE_76 = '''
To develop an exploitative strategy for this Common Pool Resource Game, I'll introduce a adaptive and robust approach that takes into account the game's parameters, state, and history.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to gauge opponents' behavior and avoid immediate stock depletion.
2. **Stock-based Threshold**: Calculate a threshold stock level (`T`) based on the current stock (`S`) and capacity (`C`): `T = 0.7 * C`. If `S` is above `T`, play Defect (D) to maximize short-term payoff. Otherwise, play Cooperate (C) to conserve stock.
3. **Opponent Exploitation**: Monitor opponents' actions and payoffs from previous rounds. Identify the most cooperative opponent (`O_c`) and the most defective opponent (`O_d`). If `O_c` has played C in at least 2/3 of the previous rounds, play D to exploit their cooperation. If `O_d` has played D in at least 2/3 of the previous rounds, play C to avoid over-exploitation.
4. **Payoff-based Adaptation**: Track your own payoff history and adjust your strategy based on the average payoff per round (`APR`). If `APR` is below a certain threshold (e.g., 0.5 * `C/n`), switch from C to D or vice versa to adapt to changing circumstances.
5. **Endgame Strategy**: In the last two rounds, play D if the current stock is above `T`. This ensures maximum short-term payoff, as the game's end reduces the impact of over-exploitation.

**Pseudocode:**
```python
def adaptive_exploiter(stock, capacity, num_players, round_num, history):
  # Initial Round
  if round_num == 1:
    return Cooperate

  # Stock-based Threshold
  threshold = 0.7 * capacity
  if stock > threshold:
    return Defect

  # Opponent Exploitation
  opponent_c = most_cooperative_opponent(history)
  opponent_d = most_defective_opponent(history)
  if opponent_c.cooperation_rate >= 2/3:
    return Defect
  elif opponent_d.defection_rate >= 2/3:
    return Cooperate

  # Payoff-based Adaptation
  apr = average_payoff_per_round(history)
  if apr < 0.5 * capacity / num_players:
    # Switch strategy based on APR
    if previous_strategy == Cooperate:
      return Defect
    else:
      return Cooperate

  # Endgame Strategy (last two rounds)
  if round_num >= num_rounds - 2 and stock > threshold:
    return Defect

  # Default: Play Cooperate
  return Cooperate
```
**Rationale:** This strategy balances short-term exploitation with long-term sustainability. By playing C initially, AE avoids immediate stock depletion and gathers information on opponents' behavior. The stock-based threshold (`T`) allows AE to adapt to changing circumstances, while opponent exploitation enables it to capitalize on cooperative or defective tendencies. Payoff-based adaptation ensures that AE adjusts its strategy in response to its own performance, and the endgame strategy maximizes short-term payoff when the game's end is near.

This exploitative strategy should perform well against a wide range of opponent behaviors, as it combines elements of adaptability, robustness, and strategic thinking.
'''

description_EXPLOITATIVE_77 = '''
I'll outline a strategic approach that exploits common behaviors while being adaptive and robust. Introducing " Stock-Adaptive Exploiter" (SAE):

**Decision Rules:**

1. **Initial Rounds (t ≤ 2)**:
   - Cooperate (C) to gather information about opponents' strategies and initial stock depletion rates.
   - Observe the total consumption and resulting stock levels after these rounds.

2. **Middle Game (3 ≤ t < r-2)**:
   - If the current stock level is high (> capacity/2):
     - Defect (D) if at least one opponent defected in the previous round, to exploit potential over-harvesting.
     - Cooperate (C) otherwise, to maintain a sustainable stock level and encourage cooperation from others.
   - If the current stock level is low (≤ capacity/2):
     - Cooperate (C) to allow for recovery and avoid depletion.

3. **Endgame (t ≥ r-2)**:
   - Defect (D) if the remaining rounds are few, as the cost of cooperation outweighs potential benefits in terms of payoff accumulation.
   - If there's only one round left, defect regardless of stock level to maximize final-round payoffs.

**Edge Cases:**

* In case of a tie in opponents' actions or when no opponent defected, default to cooperating (C) to maintain adaptability and encourage cooperation.
* If an opponent has consistently cooperated throughout the game, consider mimicking their strategy for one round to gauge potential reciprocity benefits. However, quickly revert to exploiting if they resume defecting.

**Pseudocode:**

```
function SAE(current_stock, opponents_actions, current_round, total_rounds):
  if current_round ≤ 2:
    return C
  elif current_stock > capacity / 2:
    defector_count = count(opponents_actions == D)
    if defector_count ≥ 1:
      return D
    else:
      return C
  elif current_stock ≤ capacity / 2:
    return C
  elif current_round ≥ total_rounds - 2:
    return D
  # Handle edge cases and adapt strategy based on opponents' actions
  # ...

return SAE(current_stock, opponents_actions, current_round, total_rounds)
```

**Exploitative Mindset:**

SAE focuses on adapting to the game's progression and the actions of its opponents. It initially gathers information by cooperating, then shifts towards exploiting when opportunities arise or when stock levels are low. The strategy also prioritizes maximizing payoffs in endgame scenarios while maintaining a degree of cooperation to avoid total depletion.

This approach is designed to perform well against independent strategies in a tournament setting, leveraging both the game's parameters and its history to inform decision-making.
'''

description_EXPLOITATIVE_78 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit opponents' behaviors while being robust to a wide range of scenarios. It relies on observing and adapting to the game state and history.

**Decision Rules:**

1. **First Round:** Cooperate (C) in the first round to observe opponents' initial actions and gather information about their behavior.
2. **Initial Phase (Rounds 2-5):**
	* If the stock level is above 75% of capacity, cooperate (C) to maintain a high stock level and encourage others to cooperate.
	* If the stock level falls below 25% of capacity, defect (D) to maximize individual payoff in a depleted environment.
	* Otherwise, play a mixed strategy:
		+ Cooperate (C) with probability 0.6 if the average opponent payoff is above the game's Nash Equilibrium (NE) payoff.
		+ Defect (D) with probability 0.6 if the average opponent payoff is below the NE payoff.
3. **Adaptive Phase (Rounds 6 and beyond):**
	* Monitor opponents' behavior and adjust the strategy based on their actions:
		+ If an opponent has defected in the previous round, defect (D) with probability 0.8 to punish them.
		+ If an opponent has cooperated in the previous round, cooperate (C) with probability 0.8 to reward them.
	* Continue to play a mixed strategy based on the stock level:
		+ Cooperate (C) if the stock level is above 50% of capacity.
		+ Defect (D) if the stock level falls below 25% of capacity.

**Edge Cases:**

1. **Last Round:** Defect (D) in the last round to maximize individual payoff, regardless of the game state or opponents' actions.
2. **Low Stock Levels:** If the stock level falls below 10% of capacity at any point, defect (D) to ensure a non-zero payoff.

**Pseudocode:**
```python
def AdaptivePredator(stock_level, num_players, round_number, opponent_actions):
    if round_number == 1:
        return "C"  # Cooperate in the first round

    if stock_level > 0.75 * capacity:
        return "C"  # Cooperate to maintain high stock level
    elif stock_level < 0.25 * capacity:
        return "D"  # Defect to maximize individual payoff in depleted environment

    avg_opponent_payoff = calculate_avg_opponent_payoff(opponent_actions)
    if avg_opponent_payoff > NE_payoff:
        return "C" with probability 0.6
    else:
        return "D" with probability 0.6

    # Adaptive phase
    if round_number >= 6:
        for opponent in opponent_actions:
            if opponent.defected_last_round():
                return "D" with probability 0.8
            elif opponent.cooperated_last_round():
                return "C" with probability 0.8

    # Mixed strategy based on stock level
    if stock_level > 0.5 * capacity:
        return "C"
    elif stock_level < 0.25 * capacity:
        return "D"

def calculate_avg_opponent_payoff(opponent_actions):
    total_payoffs = sum([opponent.payoff for opponent in opponent_actions])
    return total_payoffs / num_players
```
This strategy aims to exploit opponents' behaviors while adapting to the game state and history. By playing a mixed strategy based on the stock level and opponents' actions, the Adaptive Predator can maximize its individual payoff while being robust to various scenarios.
'''

description_EXPLOITATIVE_79 = '''
**Exploitative Strategy: Adaptive Stock Raider**

Decision Rules:

1. **Initial Round (t=1)**:
	* Observe the initial stock level and capacity.
	* Cooperate (C) in the first round to gather information about opponents' behaviors.
2. **Early Rounds (t>1, stock > 0.5*capacity)**:
	* If the average opponent payoff from previous rounds is greater than or equal to the cooperator's payoff, cooperate (C).
	* Otherwise, defect (D) to exploit opponents who are cooperating.
3. **Mid-Game (stock ≤ 0.5*capacity)**:
	* Switch to a more aggressive strategy:
		+ If there are less than n/2 cooperators in the previous round, defect (D) to maximize individual payoff.
		+ Otherwise, cooperate (C) to maintain a balance and avoid over-exploitation.
4. **Endgame (t=r-1 or stock < 0.25*capacity)**:
	* Defect (D) in the penultimate round to maximize payoff before the game ends.
5. **Last Round (t=r)**:
	* Cooperate (C) if there is a possibility of renewal or regeneration of the common pool resource.

Additional Rules:

* **Stock Depletion**: Monitor the stock level and adjust strategy accordingly. If the stock depletes rapidly, become more cautious and cooperate to avoid complete depletion.
* **Opponent Adaptation**: Track opponents' adaptations and adjust the strategy to counter their moves. For example, if an opponent switches from cooperation to defection, adapt by cooperating less frequently.

Pseudocode:
```python
def adaptive_stock_raider(stock, capacity, n, t, history):
    if t == 1:  # Initial round
        return 'C'
    
    avg_opponent_payoff = calculate_avg_opponent_payoff(history)
    cooperator_payoff = stock / (2 * n)
    
    if stock > 0.5 * capacity:
        if avg_opponent_payoff >= cooperator_payoff:
            return 'C'
        else:
            return 'D'
    
    elif stock <= 0.5 * capacity:
        num_cooperators_prev_round = count_cooperators(history[-1])
        
        if num_cooperators_prev_round < n / 2:
            return 'D'
        else:
            return 'C'
    
    elif t == r - 1 or stock < 0.25 * capacity:  # Endgame
        return 'D'
    
    elif t == r:  # Last round
        if renewal_possible(stock, capacity):
            return 'C'
        else:
            return 'D'

def calculate_avg_opponent_payoff(history):
    # Calculate average opponent payoff from previous rounds

def count_cooperators(round_history):
    # Count the number of cooperators in a given round history

def renewal_possible(stock, capacity):
    # Check if there is a possibility of renewal or regeneration
```
This strategy aims to balance exploitation and cooperation by adapting to the game state, opponents' behaviors, and stock levels. By monitoring opponents' adaptations and adjusting its own strategy, the Adaptive Stock Raider can effectively exploit cooperative behaviors while minimizing risks in a dynamic environment.
'''

description_EXPLOITATIVE_80 = '''
I'll design a robust and adaptive exploitative strategy for this Common Pool Resource Game. Here's my approach:

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about the opponent's behavior and initial stock level.
2. **Subsequent Rounds (t>1):**
	* If the average payoff of opponents in the previous round is greater than or equal to 75% of the maximum possible payoff (`stock/(2n)`), Defect (D). This indicates that opponents are cooperating, and I can exploit them.
	* Otherwise, Cooperate (C) to maintain a sustainable stock level and wait for opportunities to exploit.
3. **Stock Depletion:** If the current stock level falls below 25% of the capacity (`0.25 * capacity`), Defect (D) to maximize individual payoffs before the game ends.
4. **Last Round (t=r):** Defect (D) regardless of opponent behavior, as there are no future rounds to consider.

**Edge Cases:**

* If all opponents cooperate in a round, and I cooperated in the previous round, I'll defect in the next round to exploit their cooperation.
* If an opponent consistently defects, I'll adjust my strategy to alternate between cooperating and defecting (C-D-C-D...). This creates uncertainty for the opponent and prevents them from consistently exploiting me.

**Pseudocode:**
```python
def adaptive_exploiter(n, capacity, stock, t, history):
    if t == 1:
        return 'C'  # Cooperate in initial round

    avg_opponent_payoff = sum(history[t-1]['payoffs']) / n
    max_possible_payoff = stock / (2 * n)

    if avg_opponent_payoff >= 0.75 * max_possible_payoff:
        return 'D'  # Defect if opponents are cooperating
    elif stock < 0.25 * capacity:
        return 'D'  # Defect in low-stock situations
    else:
        return 'C'  # Cooperate otherwise

    if t == r:  # Last round
        return 'D'

# Example usage:
n = 4
capacity = 100
stock = 80
t = 3
history = [{'payoffs': [12.5, 12.5, 25, 25]}, {'payoffs': [10, 15, 20, 30]}]
action = adaptive_exploiter(n, capacity, stock, t, history)
print(action)  # Output: 'D'
```
This strategy is designed to balance short-term gains with long-term sustainability. By adapting to the opponents' behavior and the current state of the game, "Adaptive Exploiter" aims to maximize individual payoffs while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_81 = '''
Here is a robust and exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):**
	* Observe the initial stock level and capacity.
	* Play D (Defect) to maximize payoff in the first round, as there is no history to adapt to.
2. **Middle Rounds (1 < t < r):**
	* Monitor the stock level and opponent actions from previous rounds.
	* Calculate the average opponent cooperation rate (OCR) as the proportion of players who cooperated in the last round.
	* If OCR ≥ 0.5, play C (Cooperate). This indicates that opponents are willing to conserve the resource, so cooperating will help maintain a healthy stock level and allow for sustainable payoffs.
	* If OCR < 0.5, play D (Defect). This suggests that opponents are over-harvesting, and defecting will maximize payoffs before the stock is depleted.
3. **Final Round (t=r):**
	* Play D (Defect) to maximize payoff in the last round, as there is no future round to conserve for.

**Additional Adaptations:**

1. **Stock Level Monitoring:** Continuously monitor the current stock level and adjust the strategy if it falls below a certain threshold (e.g., 20% of capacity). If the stock level is critically low, switch to playing C (Cooperate) to help replenish the resource.
2. **Opponent Action Tracking:** Keep track of opponent actions over time to identify patterns or changes in behavior. If an opponent consistently cooperates or defects, adjust the strategy accordingly.

**Pseudocode:**
```
function AdaptiveExploiter(stock_level, capacity, round_number, opponent_actions):
  if round_number == 1:
    return D (Defect)
  
  OCR = calculate_average_opponent_cooperation_rate(opponent_actions)
  
  if OCR >= 0.5 and stock_level > 0.2 * capacity:
    return C (Cooperate)
  else:
    return D (Defect)
  
  if round_number == r:
    return D (Defect)
```
**Rationale:**

The Adaptive Exploiter strategy aims to balance short-term gains with long-term sustainability by adapting to the opponent's behavior and the current state of the resource. By cooperating when opponents are willing to conserve, the strategy helps maintain a healthy stock level and allows for sustainable payoffs. When opponents over-harvest, the strategy defects to maximize payoffs before the stock is depleted.

By monitoring the stock level and adjusting the strategy accordingly, the Adaptive Exploiter avoids catastrophic outcomes where the resource is completely depleted. The final round adaptation ensures that the strategy maximizes payoff in the last round, regardless of opponent behavior.

Overall, this strategy should perform well against a wide range of opponent behaviors and be robust to different game parameters and initial conditions.
'''

description_EXPLOITATIVE_82 = '''
I'll design a exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors. I'll call this strategy "Adaptive Exploiter" (AE).

**Decision Rules:**

1. **Initial Rounds (t ≤ 2):** AE starts by cooperating (C) in the first two rounds to gather information about opponents' behavior and the game's dynamics.
2. **Observation Phase (t > 2):** From round 3 onwards, AE observes the previous round's stock level (S_prev), total consumption, and opponent actions. If the stock level is above a certain threshold (e.g., S_prev ≥ 0.75 \* capacity), AE defects (D). Otherwise, AE cooperates (C).
3. **Exploitation Phase:** When an opponent defects (D) in a previous round, AE increases its defection probability (P_defect) by 10% for the next round. If multiple opponents defect, P_defect is increased cumulatively.
4. **Stock-Based Adjustment:** As the game progresses and the stock level decreases, AE adjusts its behavior:
	* If S_prev < 0.5 \* capacity, AE increases P_defect by an additional 10%.
	* If S_prev < 0.25 \* capacity, AE defects (D) with high probability (e.g., 80%).
5. **Last Round (t = r):** In the final round, AE always defects (D), as there's no future benefit to cooperation.

Pseudocode:
```python
def AdaptiveExploiter(state, history):
    # Initial rounds: cooperate
    if state['round'] <= 2:
        return 'C'

    # Observation phase
    prev_stock = history[-1]['stock']
    total_consumption = sum(history[-1]['consumptions'])
    opponents_defected = [o for o in history[-1]['actions'] if o == 'D']

    # Stock-based adjustment
    if prev_stock < 0.5 * state['capacity']:
        P_defect += 0.10
    elif prev_stock < 0.25 * state['capacity']:
        return 'D'

    # Exploitation phase
    for opponent in opponents_defected:
        P_defect += 0.10

    # Decide action based on P_defect
    if random.random() < P_defect:
        return 'D'
    else:
        return 'C'

def update_P_defect(P_defect, prev_stock):
    # Adjust P_defect based on stock level and opponents' behavior
    pass  # implementation details omitted for brevity
```
**Edge Cases:**

* **First Round:** AE cooperates to gather information.
* **Last Round:** AE defects to maximize its payoff.
* **Single Opponent:** If there's only one opponent, AE always cooperates in the first two rounds and then adapts based on the opponent's behavior.

**Exploitative Mindset:**

AE is designed to take advantage of opponents' cooperation while minimizing its own losses. By observing opponents' actions and adjusting its behavior accordingly, AE aims to maximize its total payoff over the game duration. The strategy is robust to various opponent behaviors and adapts to changing circumstances, such as stock level fluctuations.

This Adaptive Exploiter strategy will be implemented as an algorithm for a tournament against other independent strategies developed by AI systems.
'''

description_EXPLOITATIVE_83 = '''
**Exploitative Strategy: "Adaptive Stock Predator" (ASP)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to gather information about opponents' behavior and stock dynamics.
2. **Subsequent Rounds:** Use the following logic:
	* If the current stock level is high (> 0.7 \* capacity), Defect (D) to maximize short-term gains, as the stock can sustain high consumption.
	* If the current stock level is moderate (0.4 \* capacity < stock ≤ 0.7 \* capacity), Cooperate (C) if most opponents defected in the previous round (> 50% of opponents played D). This encourages cooperation and helps maintain a healthy stock level.
	* If the current stock level is low (< 0.4 \* capacity), Defect (D) to prioritize individual gains, as the stock may not recover otherwise.
3. **Adaptive Component:** Monitor the average payoff difference between rounds where you Cooperated (C) and Defected (D). If the average difference is significant (> 10%), adjust your strategy:
	+ If cooperating led to higher payoffs, increase cooperation rate by 20% in subsequent rounds.
	+ If defecting led to higher payoffs, decrease cooperation rate by 20% in subsequent rounds.

**Edge Cases:**

1. **Last Round:** Defect (D) to maximize final-round payoff, as there is no future stock growth or consequences.
2. **Tiebreaker:** In case of a tie in the adaptive component's average payoff difference calculation, Cooperate (C) to promote cooperation and maintain a healthy stock level.

**Pseudocode:**
```python
def ASP(strategy, game_state):
    if round == 1:
        return "Cooperate"  # Initial round

    current_stock = game_state["stock"]
    capacity = game_state["capacity"]

    if current_stock > 0.7 * capacity:
        return "Defect"  # High stock level
    elif 0.4 * capacity < current_stock <= 0.7 * capacity:
        opponents_defected_last_round = count_opponents_played_D(game_state)
        if opponents_defected_last_round > 50%:
            return "Cooperate"  # Moderate stock level, encourage cooperation
        else:
            return "Defect"
    else:  # Low stock level
        return "Defect"

    # Adaptive component
    avg_payoff_diff = calculate_avg_payoff_difference(strategy)
    if avg_payoff_diff > 10%:
        if cooperating_led_to_higher_payoffs(avg_payoff_diff):
            strategy.cooperation_rate += 20%
        else:
            strategy.cooperation_rate -= 20%

def count_opponents_played_D(game_state):
    # Count opponents who defected in the previous round
    pass

def calculate_avg_payoff_difference(strategy):
    # Calculate average payoff difference between rounds with C and D
    pass

def cooperating_led_to_higher_payoffs(avg_payoff_diff):
    # Determine if cooperating led to higher payoffs
    pass
```
This strategy balances short-term gains with long-term sustainability, adapting to opponents' behavior while prioritizing individual interests. By adjusting the cooperation rate based on payoff differences, ASP aims to maximize overall payoffs in a wide range of scenarios.
'''

description_EXPLOITATIVE_84 = '''
**Exploitative Strategy: Adaptive Stock Depletion (ASD)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and set a baseline for future rounds.
2. **Early Rounds (t < r/2)**:
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, defect (D) with probability 0.5, otherwise cooperate (C).
	* If the current stock level is below 50% of capacity, defect (D).
3. **Late Rounds (t ≥ r/2)**:
	* Calculate the average payoff per round for all players up to this point.
	* If the average payoff is above 75% of the maximum possible payoff (i.e., capacity/(2n)), cooperate (C).
	* Otherwise, defect (D) with probability 0.75, otherwise cooperate (C).
4. **Opponent Behavior Adaptation**:
	* Monitor opponents' actions and adjust the strategy based on their behavior.
	* If an opponent has defected more than 50% of the time in previous rounds, increase the probability of defecting against them by 25%.
5. **Stock Level Adjustment**:
	* If the stock level is critically low (below 25% of capacity), cooperate (C) to allow for some growth and avoid complete depletion.

**Pseudocode:**
```python
def ASD(n, r, capacity, current_stock, round_number):
    if round_number == 1:
        return C  # Cooperate in the first round

    stock_threshold = capacity * 0.75
    avg_payoff_threshold = (capacity / (2 * n)) * 0.75

    if round_number < r/2:
        if current_stock >= stock_threshold:
            return C
        elif current_stock >= capacity * 0.5 and current_stock < stock_threshold:
            return random_choice([C, D], [0.5, 0.5])
        else:
            return D

    avg_payoff = calculate_avg_payoff()
    if avg_payoff >= avg_payoff_threshold:
        return C
    else:
        opponent_defection_rate = monitor_opponent_behavior()
        defect_prob = max(0.25, min(0.75, 0.5 + (opponent_defection_rate * 0.25)))
        return random_choice([C, D], [1 - defect_prob, defect_prob])

    if current_stock < capacity * 0.25:
        return C

def calculate_avg_payoff():
    # Calculate average payoff per round for all players
    pass

def monitor_opponent_behavior():
    # Monitor opponents' actions and adjust the strategy based on their behavior
    pass
```
**Explanation:**

The ASD strategy is designed to balance short-term gains with long-term sustainability. By cooperating in early rounds, we gather information about opponents' behavior and set a baseline for future rounds.

In late rounds, we adjust our strategy based on the average payoff per round and the stock level. If the average payoff is high, we cooperate to maintain the current state. Otherwise, we defect with a higher probability to maximize individual gains.

We also adapt to opponents' behavior by increasing the probability of defecting against those who have defected frequently in the past.

The strategy includes edge cases for critically low stock levels and ensures that we do not deplete the stock completely.

**Robustness:**

ASD is designed to be robust against a wide range of opponent behaviors. By adapting to opponents' actions, we can adjust our strategy to maximize individual gains while minimizing the risk of over-depletion.

In a tournament setting, ASD will perform well against independent strategies developed by other AI systems, as it does not rely on shared norms or coordination mechanisms.
'''

description_EXPLOITATIVE_85 = '''
**Exploitative Strategy: Adaptive Stock Protector (ASP)**

The ASP strategy is designed to exploit opponents' behaviors while protecting the common pool stock from over-depletion. It adapts to changing game conditions and opponent actions.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' initial actions.
2. **Stock Protection**: If the current stock level is below 75% of the capacity, cooperate (C). This helps maintain a sustainable stock level and prevents over-depletion.
3. **Opponent Exploitation**: Identify the most common action (C or D) among opponents in the previous round. If most opponents defected (D), defect (D) in the current round to take advantage of their exploitation. Otherwise, cooperate (C).
4. **Self-Protection**: If an opponent has defected (D) for two consecutive rounds, defect (D) in the current round to prevent being taken advantage of.
5. **Last Round**: Defect (D) in the last round, as there is no future stock to protect.

**Edge Cases**

1. **First Round**: Cooperate (C) to gather information about opponents' initial actions.
2. **Last Round**: Defect (D) to maximize payoff, as there is no future stock to protect.
3. **Tie-Breaking**: In cases where the decision rules result in a tie (e.g., equal number of opponents cooperating and defecting), cooperate (C).
4. **Zero Stock**: If the current stock level is 0, defect (D) to ensure a non-zero payoff.

**Pseudocode**

```
function ASP(current_stock, capacity, num_opponents, previous_round_actions)
  if first round:
    return C
  elseif current_stock < 0.75 * capacity:
    return C
  else:
    most_common_action = majority(previous_round_actions)
    if most_common_action == D:
      return D
    elif self_protected(previous_round_actions):
      return D
    else:
      return C

def majority(actions):
  # Return the most common action among opponents
  ...

def self_protected(actions):
  # Check if an opponent has defected for two consecutive rounds
  ...
```

**Rationale**

The ASP strategy aims to balance stock protection with exploitative behavior. By cooperating when the stock is low, it helps maintain a sustainable level and prevents over-depletion. The strategy also adapts to opponents' behaviors by identifying common actions and self-protecting against repeated defectors. In the last round, defecting maximizes payoff as there is no future stock to protect.

The ASP strategy is designed to be robust against various opponent behaviors and does not rely on coordination mechanisms or norms. It should perform well in a tournament setting against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_86 = '''
Here's a description of an exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **First Round:** Cooperate (C) in the first round to gather information about opponents' behavior and set a benchmark for subsequent rounds.
2. **Subsequent Rounds:** Observe the previous round's outcome, specifically:
	* **Stock level**: If the stock level is above 50% of capacity, defect (D). This indicates that opponents are being too generous, and we can exploit this by consuming more.
	* **Opponent behavior**: If most opponents (> 50%) defected in the previous round, cooperate (C) to conserve resources. This suggests that opponents are aggressive, and we should adapt to maintain a stable stock level.
	* **Payoff comparison**: Compare our payoff from the previous round with the average payoff of all players. If our payoff is below average, defect (D) to increase our payoff. Otherwise, cooperate (C).
3. **Adaptive threshold:** Adjust the 50% threshold for opponent behavior and stock level based on the game's progression:
	* If the stock level has been consistently low (< 30% of capacity), lower the threshold to 40% to encourage more cooperation.
	* If opponents have been mostly cooperative (> 70%), raise the threshold to 60% to take advantage of their generosity.

**Handling Edge Cases:**

1. **Last Round:** In the final round, always defect (D) as there's no future game state to consider.
2. **Opponent Homogeneity:** If all opponents exhibit identical behavior for multiple rounds (> 3), assume they're following a fixed strategy and adapt our decision rule accordingly:
	* If opponents cooperate consistently, defect more frequently.
	* If opponents defect consistently, cooperate more frequently.

**Pseudocode:**

```
function AdaptiveExploiter(n, r, capacity, stock_history):
    # First round
    if current_round == 1:
        return COOPERATE

    # Get previous round's outcome
    prev_stock = stock_history[-2]
    prev_payoffs = get_prev_payoffs()
    opponent_behavior = analyze_opponent_actions()

    # Decide based on rules
    if prev_stock > 0.5 * capacity:
        return DEFECT
    elif most_opponents_defected(opponent_behavior):
        return COOPERATE
    elif our_payoff(prev_payoffs) < avg_payoff(prev_payoffs):
        return DEFECT
    else:
        return COOPERATE

    # Adjust threshold for next round
    if stock_level_consistently_low(stock_history):
        adjust_threshold(0.4)
    elif opponents_cooperative(opponent_behavior):
        adjust_threshold(0.6)

def most_opponents_defected(opponent_behavior):
    # Return True if > 50% of opponents defected

def our_payoff(prev_payoffs):
    # Calculate our payoff from the previous round

def avg_payoff(prev_payoffs):
    # Calculate average payoff of all players in the previous round

def stock_level_consistently_low(stock_history):
    # Check if stock level has been consistently low

def opponents_cooperative(opponent_behavior):
    # Check if most opponents have been cooperative
```

**Exploitative Mindset:** This strategy prioritizes exploiting opponents' generosity when possible, while adapting to maintain a stable stock level and maximize our payoff. By observing opponent behavior and adjusting our decision rule accordingly, we aim to outperform other strategies in the tournament.
'''

description_EXPLOITATIVE_87 = '''
I'll design a exploitative strategy for this Common Pool Resource Game that adapts to various opponent behaviors. Here's my approach:

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **First Round**: Cooperate (C) in the first round to gather information about opponents' behavior and to avoid triggering a massive depletion of the stock.
2. **Stock Thresholds**: Define two stock thresholds:
	* `Low_Threshold` = capacity / 4
	* `High_Threshold` = capacity * 3/4

These thresholds will guide our decision-making based on the current stock level.

3. **Exploitation Logic**:
	* If the current stock is above `High_Threshold`, Defect (D). This maximizes our payoff when the stock is abundant, and others are likely to cooperate.
	* If the current stock is below `Low_Threshold`, Cooperate (C). This helps preserve the remaining stock for future rounds, as defecting would lead to further depletion.
	* When the stock is between `Low_Threshold` and `High_Threshold`, observe the opponents' actions in previous rounds. If:
		+ More than half of opponents defected in the previous round, Defect (D). This indicates a high likelihood of over-exploitation, so we should grab what we can.
		+ Half or fewer opponents defected, Cooperate (C). This suggests that opponents are relatively cooperative, and preserving the stock is more beneficial.

**Additional Logic:**

* **Round Counter**: Keep track of the current round number (`t`). In the last round (`t == r`), always Defect (D) to maximize payoff.
* **Opponent Action History**: Store a history of opponents' actions in previous rounds. This helps us detect patterns and adjust our strategy accordingly.

Pseudocode:
```python
# Initialize variables
capacity = game_capacity
n_players = number_of_players
rounds = total_rounds
stock_threshold_low = capacity / 4
stock_threshold_high = capacity * 3/4

# Initialize opponent action history
opponent_actions = [[] for _ in range(n_players)]

for round in range(1, rounds + 1):
    # Get current stock level
    current_stock = get_current_stock()

    if round == 1:  # First Round
        action = "C"
    elif current_stock > stock_threshold_high:
        action = "D"  # Exploit high stock levels
    elif current_stock < stock_threshold_low:
        action = "C"  # Conserve low stock levels
    else:  # Middle zone
        opponent_defections_last_round = sum(1 for actions in opponent_actions if actions[-1] == "D")
        if opponent_defections_last_round > n_players / 2:
            action = "D"  # Exploit if many opponents defected last round
        else:
            action = "C"  # Cooperate otherwise

    if round == rounds:  # Last Round
        action = "D"  # Always defect in the last round

    # Update opponent action history
    for i, opponent_action in enumerate(get_opponent_actions()):
        opponent_actions[i].append(opponent_action)

    # Take action and get payoff
    take_action(action)
    payoff = get_payoff()
```
This strategy, "Adaptive Exploiter," balances short-term gains with long-term sustainability by adapting to the current stock level and opponents' behavior. By exploiting high stock levels, conserving low ones, and adjusting based on opponent actions, we aim to maximize our total payoff over multiple rounds.
'''

description_EXPLOITATIVE_88 = '''
Here's a strategic approach that I'll call "Adaptive Exploitation" (AE). This strategy aims to balance short-term gains with long-term sustainability by dynamically adjusting its behavior based on game state and history.

**Decision Rules:**

1. **Initial Rounds**: In the first few rounds (e.g., `r/4`), play Cooperate (C) to gather information about opponents' strategies and observe the initial stock dynamics.
2. **Stock-dependent Threshold**: Set a dynamic threshold, `T`, based on the current stock level (`S`) and capacity (`C`). When `S > T`, play Defect (D); otherwise, play C.

`T = C * (1 - (n-1)/n)`

This threshold ensures that when the stock is high, there's more room for exploitation. As the stock depletes, the strategy becomes more cautious.
3. **Opponent Monitoring**: Track the number of opponents who played D in each round (`D_count`). If `D_count` increases over time (e.g., exceeds a moving average), switch to playing C more frequently to avoid over-exploitation and potential collapse of the stock.
4. **Last Rounds**: In the final rounds (e.g., last `r/4`), prioritize sustainability by playing C, unless the stock is extremely low (`S < C/2n`), in which case play D to maximize short-term gains.

**Pseudocode**:
```python
def adaptive_exploitation(n, r, capacity, current_stock, history):
    # Initial rounds: Play C to gather information
    if round_number <= r / 4:
        return 'C'

    # Calculate dynamic threshold
    T = capacity * (1 - (n-1)/n)

    # Stock-dependent behavior
    if current_stock > T:
        # Opponent monitoring: adjust D-count threshold
        if D_count > moving_average(D_count_history):
            return 'C'
        else:
            return 'D'
    else:
        return 'C'

    # Last rounds: Prioritize sustainability unless stock is extremely low
    if round_number >= r - r / 4 and current_stock < capacity / (2 * n):
        return 'D'
    else:
        return 'C'
```
**Edge Cases**:

* In the event of a tie in `D_count`, play C to err on the side of caution.
* If an opponent's strategy is detected as always playing D, adapt by playing C more frequently to avoid exploitation.

This Adaptive Exploitation strategy aims to balance short-term gains with long-term sustainability by adjusting its behavior based on game state and history. By monitoring opponents' strategies and adapting to changes in the stock dynamics, AE can effectively exploit opportunities while minimizing the risk of over-exploitation and collapse of the stock.
'''

description_EXPLOITATIVE_89 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the game.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) with a probability of 0.5, and Defect (D) with a probability of 0.5. This initial randomness helps to gather information about opponents' behaviors.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of the capacity, Cooperate (C).
	* If the current stock level is below 25% of the capacity, Defect (D).
	* Otherwise, use a mixed strategy based on the history of opponents' actions and the current stock level.

**Mixed Strategy:**

For each opponent i, maintain a "defection rate" metric, d_i, which represents the proportion of times they have defected in previous rounds. Calculate the average defection rate across all opponents, d_avg.

* If d_avg is above 0.5 (i.e., most opponents are defecting), Defect (D) with probability p = max(0.7, d_avg).
* If d_avg is below 0.3 (i.e., most opponents are cooperating), Cooperate (C) with probability p = min(0.7, 1 - d_avg).
* Otherwise, play a mixed strategy: Defect (D) with probability p = 0.5, and Cooperate (C) with probability p = 0.5.

**Additional Heuristics:**

* **Last Round (t=r)**: If the current stock level is above 50% of the capacity, Cooperate (C). Otherwise, Defect (D).
* **Low Stock**: If the current stock level falls below a threshold (e.g., 10% of the capacity), always Defect (D) to maximize individual payoff.

**Pseudocode:**
```python
def adaptive_stock_hawk(n, r, capacity, stock_history):
    # Initialize variables
    d_i = [0.5] * n  # defection rate for each opponent
    d_avg = 0.5
    t = 1

    while t <= r:
        if t == 1:  # initial round
            action = random.choice(['C', 'D'])
        else:
            stock_level = stock_history[t-1]
            if stock_level > 0.75 * capacity:
                action = 'C'
            elif stock_level < 0.25 * capacity:
                action = 'D'
            else:
                d_avg = sum(d_i) / n
                if d_avg > 0.5:
                    p_defect = max(0.7, d_avg)
                    action = 'D' if random.random() < p_defect else 'C'
                elif d_avg < 0.3:
                    p_cooperate = min(0.7, 1 - d_avg)
                    action = 'C' if random.random() < p_cooperate else 'D'
                else:
                    action = random.choice(['C', 'D'])

        # Update defection rates
        for i in range(n):
            if opponents[i].action == 'D':
                d_i[i] += 0.1

        # Last round adjustment
        if t == r and stock_level > 0.5 * capacity:
            action = 'C'

        # Low stock adjustment
        if stock_level < 0.1 * capacity:
            action = 'D'

        yield action
        t += 1
```
This strategy adapts to the dynamic state of the game, exploiting opponents' behaviors while balancing individual payoffs. By adjusting defection rates based on opponents' actions and current stock levels, the Adaptive Stock Hawk aims to maximize its total payoff over multiple rounds.
'''

description_EXPLOITATIVE_90 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and avoid initial stock depletion.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize short-term payoff.
	* If the current stock level is between 50% and 75% of the capacity, use a "Mixed" strategy:
		+ Cooperate with probability p = (current_stock / capacity) ^ 2
		+ Defect with probability 1 - p
	* If the current stock level is below 50% of the capacity, Cooperate to conserve remaining stock and promote growth.
3. **Last Round (t=r):** Defect (D) to maximize final payoff, regardless of the current stock level.

**Additional Considerations:**

* Monitor opponents' actions and adjust the mixed strategy's probability p based on their historical cooperation rates:
	+ If most opponents have cooperated (>60%), increase p by 10%
	+ If most opponents have defected (<40%), decrease p by 10%
* Keep track of the average payoff per round for each player. If a player's average payoff is significantly higher than others, adjust their probability p in the mixed strategy:
	+ Increase p if they are cooperating more often
	+ Decrease p if they are defecting more often

**Pseudocode:**
```
function adaptive_stock_raider(current_round, current_stock, capacity, opponents_actions) {
  if (current_round == 1) {
    return COOPERATE;
  } else {
    stock_level = current_stock / capacity;
    if (stock_level > 0.75) {
      return DEFECT;
    } else if (stock_level >= 0.5 && stock_level <= 0.75) {
      p = (current_stock / capacity) ^ 2;
      adjust_p(opponents_actions); // update probability based on opponents' actions
      if (random() < p) {
        return COOPERATE;
      } else {
        return DEFECT;
      }
    } else {
      return COOPERATE;
    }
  }
}

function adjust_p(opponents_actions) {
  // monitor opponents' cooperation rates and update probability p accordingly
}
```
This strategy aims to balance short-term gains with long-term sustainability by adapting to the game's state and opponents' behaviors. By defecting when the stock level is high, it exploits opponents who cooperate too much, while conserving stock and promoting growth when necessary.
'''

description_EXPLOITATIVE_91 = '''
Here's a description of an exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and avoid immediate stock depletion.
2. **Subsequent Rounds (t>1):**
	* If the previous round's total consumption was less than or equal to half of the capacity (i.e., Σ(consumption_i) ≤ capacity/2), cooperate (C). This indicates that opponents are likely to be conservative, and cooperation will help maintain a healthy stock level.
	* Otherwise, defect (D) if the current stock level is above a certain threshold (e.g., stock ≥ 0.75 \* capacity). This allows AE to exploit the resource when opponents are being too aggressive or the stock is still relatively high.
	* If the current stock level is below the threshold (stock < 0.75 \* capacity), cooperate (C) to help replenish the stock and avoid depletion.
3. **Last Round (t=r):** Defect (D) to maximize individual payoff, as there are no future rounds to consider.

**Edge Cases:**

* If all opponents defected in the previous round, AE will defect in the current round to avoid being exploited.
* If AE observes that an opponent has consistently cooperated while others have defected, AE will exploit this opponent by defecting against them.

**Adaptive Mechanisms:**

1. **Stock Monitoring:** Continuously monitor the stock level and adjust behavior accordingly. If the stock level drops below a certain threshold (e.g., 0.25 \* capacity), AE will become more conservative and cooperate to avoid depletion.
2. **Opponent Analysis:** Observe opponents' behaviors over time and adjust strategy based on their actions. If an opponent consistently cooperates or defects, AE will adapt its behavior to exploit or counter their strategy.

**Pseudocode:**
```python
def Adaptive_Exploiter(stock, capacity, history):
    if t == 1:
        return C  # Cooperate in the first round

    prev_consumption = sum(history[-1])
    if prev_consumption <= capacity / 2:
        return C  # Cooperate if previous consumption was low
    elif stock >= 0.75 * capacity:
        return D  # Defect if stock is high and opponents are aggressive
    else:
        return C  # Cooperate to replenish stock

    if t == r:  # Last round
        return D  # Defect to maximize individual payoff

def update_history(stock, actions):
    history.append([stock] + [a for a in actions])
    return history
```
This strategy aims to balance short-term gains with long-term sustainability by adapting to the behaviors of opponents and the state of the resource. By cooperating when necessary and defecting when opportunities arise, AE seeks to maximize its individual payoff while minimizing the risk of stock depletion.
'''

description_EXPLOITATIVE_92 = '''
**Exploitative Strategy: "Adaptive Stockpiler"**

The Adaptive Stockpiler strategy is designed to exploit a wide range of opponent behaviors while adapting to the game's dynamic state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to observe opponents' initial actions and set a baseline for future adaptations.
2. **Subsequent Rounds (t>1):** Use the following logic:
	* If the current stock level is high (above 75% of capacity), Defect (D) to maximize short-term gains.
	* If the current stock level is medium (between 25% and 75% of capacity), Cooperate (C) to balance individual gain with long-term sustainability.
	* If the current stock level is low (below 25% of capacity), Defect (D) to ensure some payoff in a depleted environment.
3. **Opponent Behavior Adaptation:** Monitor opponents' actions and adjust the strategy based on their behavior:
	* If most opponents (>50%) Cooperate, increase the threshold for Defection to 90% of capacity to maximize gains.
	* If most opponents (>50%) Defect, decrease the threshold for Defection to 10% of capacity to ensure some payoff.
4. **Recent History:** Consider the outcome of the previous round:
	* If the stock level increased in the previous round, Cooperate (C) to maintain a sustainable trajectory.
	* If the stock level decreased in the previous round, Defect (D) to compensate for potential losses.

**Edge Cases:**

1. **Last Round (t=r):** Always Defect (D) to maximize final payoff, as there are no future rounds to consider.
2. **Tied Opponent Behavior:** In cases where opponents' behavior is evenly split between Cooperate and Defect, default to the medium-stock-level rule (Cooperate if stock level is between 25% and 75% of capacity).

**Pseudocode:**
```python
def adaptive_stockpiler(state, history):
    # Initial round
    if state.round == 1:
        return 'C'

    # Determine current stock level
    stock_level = state.stock / state.capacity

    # Opponent behavior adaptation
    opponent_cooperation_rate = sum(history[-5:]) / (len(history) * state.n)
    if opponent_cooperation_rate > 0.5:
        defect_threshold = 0.9
    else:
        defect_threshold = 0.1

    # Recent history consideration
    if history[-1].stock_level > stock_level:
        recent_history_factor = 'C'
    else:
        recent_history_factor = 'D'

    # Decision logic
    if stock_level > defect_threshold:
        return 'D'
    elif stock_level < 0.25:
        return 'D'
    else:
        return 'C' if recent_history_factor == 'C' else 'D'
```
This strategy aims to balance short-term gains with long-term sustainability, while adapting to opponents' behaviors and the game's dynamic state. By being exploitative and opportunistic, the Adaptive Stockpiler strategy should perform well in a tournament setting against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_93 = '''
**Exploitative Strategy: Adaptive Stock Depletion (ASD)**

The ASD strategy aims to maximize its payoff by adapting to the current state of the game and the history of opponents' actions. It balances exploitation with a degree of caution to avoid depleting the stock too quickly.

**Decision Rules:**

1. **Initial Round:** In the first round, play Cooperate (C). This allows us to observe how other players behave and get an initial payoff.
2. **Stock Level Assessment:** Calculate the current stock level as a fraction of the capacity (`stock_fraction = stock / capacity`).
3. **Opponent Behavior Analysis:** Track the number of opponents who played Defect (D) in the previous round (`num_defectors_prev`).
4. **Adaptive Threshold:** Define an adaptive threshold (`threshold`) based on the current stock level and opponent behavior:
	* If `stock_fraction > 0.5`, set `threshold = 0.5`. This means we're more likely to cooperate when the stock is relatively full.
	* If `stock_fraction <= 0.5` and `num_defectors_prev >= n/2`, set `threshold = 0.3`. This reduces our cooperation threshold if many opponents defected in the previous round, indicating potential over-exploitation.
	* Otherwise, set `threshold = 0.7`. This is a more cautious default value.
5. **Cooperate or Defect:** Play Cooperate (C) if `stock_fraction > threshold`, otherwise play Defect (D).

**Pseudocode:**
```markdown
function ASD(stock, capacity, n, history):
  // Initialize variables
  stock_fraction = stock / capacity
  num_defectors_prev = count_defectors(history[-1])  // count defectors in previous round
  
  // Set adaptive threshold
  if stock_fraction > 0.5:
    threshold = 0.5
  elif stock_fraction <= 0.5 and num_defectors_prev >= n/2:
    threshold = 0.3
  else:
    threshold = 0.7
  
  // Decide action
  if stock_fraction > threshold:
    return C (Cooperate)
  else:
    return D (Defect)
```
**Edge Cases:**

* **Last Round:** In the final round, play Defect (D) to maximize payoff, as there's no future risk of stock depletion.
* **Stock Depletion:** If the stock level falls below a certain threshold (e.g., 10% of capacity), play Cooperate (C) to avoid completely depleting the stock and losing potential payoffs in subsequent rounds.

**Exploitative Mindset:**

The ASD strategy is designed to be exploitative, taking advantage of opponents' cooperation while minimizing its own contributions. By adapting to the current state and opponent behavior, it aims to maximize its payoff without overly depleting the stock. The adaptive threshold allows the strategy to balance exploitation with caution, making it robust against a wide range of opponent behaviors.

In a tournament setting, ASD will compete effectively against other strategies by leveraging its adaptability and exploitative nature, while being mindful of potential risks and edge cases.
'''

description_EXPLOITATIVE_94 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behavior and observe the initial stock depletion.
2. **Early Rounds (t< r/2)**:
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term gains.
	* Otherwise, Cooperate (C) to conserve stock for future rounds.
3. **Mid-Game (r/2 ≤ t < 3r/4)**:
	* Analyze opponents' behavior from previous rounds using a simple frequency-based approach: count the number of times each opponent has Defected (D).
	* If most opponents (>50%) have Defected at least once, switch to Defecting (D) to exploit their greed.
	* Otherwise, continue Cooperating (C) to maintain a sustainable stock level.
4. **Late Rounds (t ≥ 3r/4)**:
	* Assess the remaining stock level and the number of rounds left.
	* If the stock is low (<25% of capacity) or there are only a few rounds left, Defect (D) to maximize final payoffs.
	* Otherwise, Cooperate (C) to ensure a stable stock for the last rounds.

Edge Cases:

1. **Last Round (t=r)**: Always Defect (D) to grab as much value as possible from the remaining stock.
2. **Stock Depletion**: If the stock level drops below 10% of capacity, Defect (D) in all subsequent rounds to maximize payoffs before the game ends.

Pseudocode:
```python
def adaptive_stock_raider(n, r, capacity, current_stock, round_number, opponent_history):
    if round_number == 1:  # Initial Round
        return "C"
    
    if round_number < r / 2:  # Early Rounds
        if current_stock > 0.75 * capacity:
            return "D"
        else:
            return "C"
    
    elif r / 2 <= round_number < 3 * r / 4:  # Mid-Game
        defect_count = sum(1 for opponent in opponent_history if opponent.defected)
        if defect_count > n / 2:
            return "D"
        else:
            return "C"
    
    elif round_number >= 3 * r / 4:  # Late Rounds
        if current_stock < 0.25 * capacity or round_number == r - 1:
            return "D"
        else:
            return "C"
    
    else:  # Last Round
        return "D"

def update_opponent_history(opponent_actions):
    opponent_history = []
    for action in opponent_actions:
        if action == "D":
            opponent_history.append({"defected": True})
        else:
            opponent_history.append({"defected": False})
    return opponent_history
```
This strategy is designed to be exploitative, adaptive, and robust against various opponent behaviors. It gathers information about opponents' actions in the early rounds, adjusts its behavior based on their greediness, and maximizes payoffs in the late rounds by defecting when possible.
'''

description_EXPLOITATIVE_95 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy is designed to maximize individual payoff by exploiting the common pool resource while adapting to the dynamic state and opponent behavior.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with probability 0.5, Defect (D) with probability 0.5. This initial randomization helps to gather information about opponents' strategies.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, Defect (D). This takes advantage of the abundant resource and maximizes short-term gain.
	* If the stock level is between 50% and 75% of capacity, Cooperate (C) with probability p = (current_stock / capacity)^2. This adaptive cooperation rate balances short-term gain with long-term sustainability.
	* If the stock level is below 50% of capacity, Defect (D). This ensures that the player gets a larger share of the remaining resource before it's depleted.
3. **Opponent Behavior Adaptation:** Track the opponent's average payoff per round and adjust the cooperation rate accordingly:
	* If an opponent's average payoff is above the player's own average payoff, decrease the cooperation rate by 0.1 (more defection).
	* If an opponent's average payoff is below the player's own average payoff, increase the cooperation rate by 0.1 (more cooperation).

**Edge Cases:**

1. **Last Round:** Defect (D) to maximize final-round payoff.
2. **Stock Depletion:** If the stock level falls below 25% of capacity, Defect (D) to ensure some payoff before the resource is depleted.

Pseudocode:
```python
def adaptive_stock_raider(n, r, capacity, current_stock, opponent_payoffs):
    # Initial round randomization
    if t == 1:
        return Cooperate with probability 0.5, Defect with probability 0.5

    # Subsequent rounds
    stock_threshold = 0.75 * capacity
    cooperation_rate = (current_stock / capacity)^2

    if current_stock > stock_threshold:
        return Defect
    elif current_stock >= 0.5 * capacity and current_stock <= stock_threshold:
        return Cooperate with probability cooperation_rate, Defect with probability 1 - cooperation_rate
    else:
        return Defect

    # Opponent behavior adaptation
    opponent_avg_payoff = average(opponent_payoffs)
    if opponent_avg_payoff > player_avg_payoff:
        cooperation_rate -= 0.1
    elif opponent_avg_payoff < player_avg_payoff:
        cooperation_rate += 0.1

    return Cooperate with probability cooperation_rate, Defect with probability 1 - cooperation_rate

def handle_edge_cases(current_stock):
    if current_stock < 0.25 * capacity or t == r:
        return Defect
```
This strategy is designed to balance short-term gain with long-term sustainability by adapting to the dynamic state and opponent behavior. By exploiting the common pool resource, "Adaptive Stock Raider" aims to maximize individual payoff in a wide range of scenarios.
'''

description_EXPLOITATIVE_96 = '''
To design an exploitative strategy for this Common Pool Resource Game, we'll create a decision-making process that takes into account the game parameters, state, and history.

**Decision Rules:**

Our strategy, named "Adaptive Exploiter" (AE), will primarily defect but occasionally cooperate to maintain a sustainable stock level. We define two key thresholds:

1. **Stock Threshold (ST)**: Set ST = 0.6 \* capacity. This threshold determines when we should prioritize cooperation to prevent over-depletion.
2. **Cooperation Probability (CP)**: CP is calculated based on the current stock level and recent opponents' actions.

**Pseudocode for AE Strategy:**

```markdown
Initialize variables:
- ST = 0.6 * capacity
- CP = 0 (initially set to defect)
- stock_history = [] (store past stock levels)
- opponent_actions = [] (store past opponents' actions)

For each round t:
1. Observe current stock level S and opponents' previous actions.
2. Update stock_history with the latest stock level.
3. Calculate CP based on the following rules:
   a. If S < ST, set CP = 0.5 - (S/ST) / 2
     (cooperate more when stock is low)
   b. If opponents defected in the previous round and S > ST,
      set CP = 0.3 + (number of defecting opponents / n) / 3
     (punish recent defection with some cooperation)
4. With probability CP, choose action C (cooperate); otherwise, choose D (defect).
5. Store own action in opponent_actions.
6. If S < ST and this is the last round, set CP = 0 ( defect to maximize payoff).

Edge Cases:

- First Round: Defect (D) by default, as we have no information about opponents' actions.
- Last Round: Use the same decision rules, but with an adjustment for the final stock level (see step 6).
```

**Exploitative Mindset:**

Our Adaptive Exploiter strategy prioritizes defecting to maximize individual payoffs while occasionally cooperating to maintain a sustainable stock level. By adapting to the current state and history of opponents' actions, we aim to exploit their cooperation and minimize our own losses due to over-depletion.

By not relying on explicit coordination mechanisms or norms, this strategy is robust against a wide range of opponent behaviors and should perform well in a tournament setting.
'''

description_EXPLOITATIVE_97 = '''
Here's a description of an exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and initial stock level.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is high (> capacity/2), Defect (D) to maximize immediate payoff.
	* If the current stock level is low (< capacity/4), Cooperate (C) to conserve resources and allow for growth.
	* Otherwise, use a mixed strategy based on the history of opponents' actions:
		+ Calculate the average cooperation rate of all players in previous rounds (ac).
		+ If ac < 0.5, Defect (D) as others are likely exploiting.
		+ If ac ≥ 0.5, Cooperate (C) to maintain a sustainable stock level and encourage cooperation.

**Edge Cases:**

1. **Last Round (t=r):** Always Defect (D), as there's no future payoff to consider.
2. **Stock Level near Capacity:** When the stock level is close to capacity (> 0.9 \* capacity), Cooperate (C) to avoid overconsumption and maintain a healthy stock level.

**Adaptive Component:**

1. **Opponent Modeling:** Track each opponent's cooperation rate in previous rounds.
2. **Adjusting Cooperation Rate:** Based on the average cooperation rate of all players, adjust the probability of cooperating in future rounds:
	* If opponents are mostly Defecting (ac < 0.3), decrease the cooperation rate by 10%.
	* If opponents are mostly Cooperating (ac > 0.7), increase the cooperation rate by 10%.

**Robustness:**

1. **Noise and Errors:** The strategy is robust to occasional errors or noise in opponent actions, as it adapts to the overall trend of cooperation rates.
2. **Diverse Opponent Behaviors:** AE can handle a wide range of opponent strategies, from pure Cooperators to pure Defectors, by adjusting its own cooperation rate accordingly.

**Pseudocode:**
```python
def adaptive_exploiter(stock_level, capacity, round_number, r):
  if round_number == 1:
    return C  # Cooperate in the first round

  ac = average_cooperation_rate()  # Calculate opponents' average cooperation rate

  if stock_level > capacity/2:
    return D  # Defect when stock level is high
  elif stock_level < capacity/4:
    return C  # Cooperate when stock level is low
  else:
    if ac < 0.5:
      return D  # Defect when opponents are exploiting
    else:
      return C  # Cooperate to maintain a sustainable stock level

def average_cooperation_rate():
  # Calculate the average cooperation rate of all players in previous rounds
  cooperation_rates = [opponent.cooperation_rate for opponent in opponents]
  return sum(cooperation_rates) / len(cooperation_rates)

def adjust_cooperation_rate(ac):
  if ac < 0.3:
    cooperation_rate -= 0.1  # Decrease cooperation rate when opponents are exploiting
  elif ac > 0.7:
    cooperation_rate += 0.1  # Increase cooperation rate when opponents are cooperating
```
This strategy is designed to balance short-term gains with long-term sustainability, while adapting to the behaviors of other players in the game.
'''

description_EXPLOITATIVE_98 = '''
**Exploitative Strategy: "Adaptive Stock Predator"**

The Adaptive Stock Predator strategy aims to maximize its payoff by exploiting the common pool resource while adapting to the actions of other players and the dynamic state of the game.

**Decision Rules:**

1. **Initial Rounds (t = 1 to r/2)**:
	* Cooperate (C) if stock ≥ capacity / 2.
	* Defect (D) otherwise.
This initial phase helps assess the opponents' behavior and the rate of stock depletion.
2. **Mid-Game Adaptation (t = r/2 + 1 to r - 1)**:
	* Calculate the average stock consumption per player in the previous round: `avg_consumption = total_consumption / n`.
	* Cooperate (C) if `avg_consumption` is below a threshold (`θ`) and stock ≥ capacity / 4.
	* Defect (D) otherwise.
The threshold `θ` is set to `capacity / (4n)` initially, but it can be adjusted based on the game's progress (see Edge Cases).
3. **Late Game Exploitation (t = r)**:
	* Defect (D) if stock ≥ capacity / 2.
	* Cooperate (C) otherwise.

**Edge Cases:**

1. **First Round (t = 1)**:
	* Cooperate (C) to gather information about opponents' initial behavior and the initial stock level.
2. **Last Round (t = r)**:
	* If stock is low (< capacity / 4), Defect (D) to maximize payoff, as cooperation would lead to minimal gain.
3. **Threshold Adjustment**:
	* Every 5 rounds, update `θ` based on the average stock consumption in the last 5 rounds: `new_θ = avg_consumption_last_5_rounds / n`.
This adaptation helps respond to changes in opponents' behavior and maintain a balance between exploitation and cooperation.

**Pseudocode (for illustrative purposes):**
```python
def adaptive_stock_predator(game_state, history):
    # Constants
    capacity = game_state['capacity']
    n = game_state['n']
    r = game_state['r']

    # Initial rounds
    if t <= r / 2:
        if stock >= capacity / 2:
            return 'C'
        else:
            return 'D'

    # Mid-game adaptation
    avg_consumption = calculate_avg_consumption(history)
    theta = capacity / (4 * n)  # initial threshold

    # Update theta every 5 rounds
    if t % 5 == 0 and t > r / 2:
        new_theta = calculate_new_threshold(history, theta)

    if avg_consumption < theta and stock >= capacity / 4:
        return 'C'
    else:
        return 'D'

    # Late game exploitation
    if t == r:
        if stock >= capacity / 2:
            return 'D'
        else:
            return 'C'

# Helper functions
def calculate_avg_consumption(history):
    total_consumption = sum(consumption for consumption in history['consumptions'])
    return total_consumption / n

def calculate_new_threshold(history, theta):
    # Calculate average stock consumption in the last 5 rounds
    avg_consumption_last_5_rounds = sum(consumption for consumption in history['consumptions'][-5:]) / 5
    return avg_consumption_last_5_rounds / n
```
This strategy aims to balance cooperation and exploitation, adapting to the game's dynamics while maximizing payoff. It is designed to perform well against a wide range of opponent behaviors in a tournament setting.
'''

description_EXPLOITATIVE_99 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

**Decision Rules:**

1. **Initial Round:** Defect (D) in the first round to maximize immediate payoff and gather information about opponents' behavior.
2. **Stock Thresholds:** Monitor the current stock level and adjust strategy based on two thresholds:
	* `LOW_STOCK_THRESHOLD` = 0.25 \* capacity
	* `HIGH_STOCK_THRESHOLD` = 0.75 \* capacity
3. **Cooperation Logic:**
	+ If stock level is above `HIGH_STOCK_THRESHOLD`, cooperate (C) to help maintain a high stock level and encourage opponents to cooperate.
	+ If stock level is below `LOW_STOCK_THRESHOLD`, defect (D) to maximize immediate payoff, as the stock is already depleted.
4. **Adaptive Defection:** Monitor the average opponent cooperation rate over the last few rounds (`WINDOW_SIZE` = 3-5 rounds). If this rate is above a certain threshold (`COOPERATION_THRESHOLD` = 0.6), defect (D) to exploit opponents' cooperativeness.
5. **Last Round:** Defect (D) in the final round, as there is no future benefit from cooperation.

**Edge Cases:**

1. **First Round:** Defect (D) to maximize immediate payoff and gather information about opponents' behavior.
2. **Last Round:** Defect (D) to ensure maximum payoff, as there are no future rounds.
3. **Low Stock:** If the stock level falls below `LOW_STOCK_THRESHOLD`, defect (D) to maximize immediate payoff.

**Pseudocode:**
```python
def adaptive_stock_raider(game_state):
    # Initialize variables
    low_stock_threshold = 0.25 * game_state.capacity
    high_stock_threshold = 0.75 * game_state.capacity
    cooperation_threshold = 0.6
    window_size = 3

    # First round: defect to gather information
    if game_state.round == 1:
        return 'D'

    # Monitor stock levels and adjust strategy
    if game_state.stock > high_stock_threshold:
        return 'C'
    elif game_state.stock < low_stock_threshold:
        return 'D'

    # Adaptive defection logic
    opponent_cooperation_rate = calculate_average_opponent_cooperation(game_state, window_size)
    if opponent_cooperation_rate > cooperation_threshold:
        return 'D'

    # Last round: defect to maximize payoff
    if game_state.round == game_state.r:
        return 'D'

    # Default behavior: cooperate to maintain a high stock level
    return 'C'
```
**Rationale:**

The Adaptive Stock Raider (ASR) strategy is designed to balance short-term gains with long-term sustainability. By monitoring the stock level and adjusting its strategy accordingly, ASR can exploit opponents' cooperativeness while avoiding over-exploitation of the common resource.

In the initial rounds, ASR defects to gather information about opponents' behavior and maximize immediate payoff. As the game progresses, it adapts its strategy based on the average opponent cooperation rate, defecting when opponents are too cooperative.

By setting a low stock threshold, ASR ensures that it defects when the stock level is critically low, maximizing its payoff in these situations. In contrast, when the stock level is high, ASR cooperates to maintain a sustainable resource and encourage opponents to cooperate.

In the final round, ASR defects to ensure maximum payoff, as there are no future benefits from cooperation.

**Note:** The specific values for `LOW_STOCK_THRESHOLD`, `HIGH_STOCK_THRESHOLD`, `COOPERATION_THRESHOLD`, and `WINDOW_SIZE` can be fine-tuned through experimentation or evolutionary algorithms to optimize the strategy's performance.
'''

description_EXPLOITATIVE_100 = '''
I'll outline a exploitative strategy for this Common Pool Resource Game that adapts to various opponent behaviors while maximizing its own payoff.

**Strategy Name: Adaptive Exploiter (AE)**

**Decision Rules:**

1. **Initial Rounds:** In the first round, AE defects (D) to maximize its initial payoff, regardless of the number of players or capacity.
2. **Stock-based Cooperation:** If the current stock is above 75% of the capacity, AE cooperates (C). This helps maintain a healthy stock level and prevents depletion.
3. **Opponent Behavior Analysis:** After each round, AE analyzes the opponent's actions in the previous rounds. It calculates the proportion of opponents who defected (D) in the last round.
4. **Defection Threshold:** If more than 50% of opponents defected in the last round, or if the stock has dropped below 25% of the capacity, AE defects (D). This ensures it doesn't get exploited by overly aggressive opponents.
5. **Punishment Mechanism:** If an opponent defected in the previous round and the stock is still above 50% of the capacity, AE defects (D) with a probability proportional to the number of opponents who defected. This punishes opponents for their non-cooperative behavior.
6. **Last Round:** In the final round, AE always defects (D), as there's no future cost to over-exploiting the stock.

**Pseudocode:**
```python
def AdaptiveExploiter(current_stock, capacity, num_opponents, history):
  if current_round == 1:
    return D  # Defect in the first round

  if current_stock >= 0.75 * capacity:
    return C  # Cooperate when stock is high

  opponent_defection_rate = calculate_defection_rate(history)
  if opponent_defection_rate > 0.5 or current_stock < 0.25 * capacity:
    return D  # Defect if opponents are aggressive or stock is low

  punishment_probability = calculate_punishment_probability(opponent_defection_rate, num_opponents)
  if random.random() < punishment_probability:
    return D  # Punish opponents with a probability

  return C  # Cooperate otherwise
```
**Rationale:**

The Adaptive Exploiter strategy balances short-term gains with long-term sustainability. By cooperating when the stock is high and punishing aggressive opponents, AE encourages cooperation while protecting its own interests.

In the face of uncertain opponent behaviors, AE's adaptive nature allows it to respond effectively, minimizing losses and maximizing payoffs over the course of the game.
'''

description_EXPLOITATIVE_101 = '''
**Strategy Name:** Adaptive Exploiter (AE)

**Overview:**
The Adaptive Exploiter (AE) is a dynamic strategy that balances cooperation and defection based on the game's state, history, and parameters. AE aims to exploit opponents' behaviors while maintaining a robust performance across various scenarios.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This allows us to gather information about the opponents' initial moves without revealing our strategy.
2. **Subsequent Rounds (t>1):**
	* If the previous round's stock level (S_t-1) is above 75% of the capacity, Defect (D). This indicates that the group has been conservative, and we can exploit this by consuming more.
	* If the previous round's stock level (S_t-1) is below 25% of the capacity, Cooperate (C). This suggests that the group has been aggressive, and we should conserve resources to avoid depletion.
	* Otherwise, use a **Trend-Based Decision**:
		+ Calculate the average stock consumption rate (CSR) over the last 3 rounds: CSR = (S_t-1 - S_t-2 + S_t-2 - S_t-3 + S_t-3 - S_t-4) / 3
		+ If CSR > 0.5, Defect (D). This indicates an increasing trend in consumption, and we can take advantage of this by consuming more.
		+ If CSR < -0.5, Cooperate (C). This suggests a decreasing trend in consumption, and we should conserve resources to maintain the stock level.
		+ Otherwise, Cooperate (C) with a probability of 0.6 and Defect (D) with a probability of 0.4. This introduces some randomness to our decision-making process, making it harder for opponents to predict our actions.
3. **Last Round (t=r):** Defect (D). In the final round, there is no future cost to over-consumption, so we maximize our payoff by consuming as much as possible.

**Edge Cases:**

* If an opponent defects in every round, AE will adapt and mostly cooperate to maintain a stable stock level.
* If all opponents cooperate, AE will gradually increase its defection rate to exploit the situation.
* In cases of extreme stock depletion (S < 10% of capacity), AE will prioritize cooperation to allow for some recovery.

**Pseudocode:**

```markdown
function AdaptiveExploiter(state, history) {
    // Initial Round
    if (history.length == 0) return COOPERATE
    
    // Subsequent Rounds
    stockLevel = state.stock / state.capacity
    prevStockLevel = history[history.length - 1].stock / state.capacity
    
    if (prevStockLevel > 0.75) return DEFECT
    else if (prevStockLevel < 0.25) return COOPERATE
    
    // Trend-Based Decision
    csr = calculateCSR(history)
    if (csr > 0.5) return DEFECT
    else if (csr < -0.5) return COOPERATE
    else {
        probability = random(0, 1)
        if (probability < 0.6) return COOPERATE
        else return DEFECT
    }
}

function calculateCSR(history) {
    // Calculate average stock consumption rate over last 3 rounds
}
```

The Adaptive Exploiter strategy is designed to be robust and adaptive in a wide range of scenarios, while prioritizing exploitation when possible.
'''

description_EXPLOITATIVE_102 = '''
**Exploitative Strategy: "Adaptive Stock Guardian"**

This strategy aims to balance short-term gains with long-term sustainability, while adapting to opponents' behaviors and exploiting their weaknesses.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Cooperate (C) if stock >= capacity * 0.8 (i.e., the stock is relatively high).
	* Defect (D) otherwise.
2. **Subsequent Rounds (t > 1)**:
	* Evaluate the average payoff per round for each player, including yourself, based on the history of actions and payoffs.
	* Identify the "most cooperative" opponent(s), i.e., those with the lowest average consumption rate (or highest cooperation rate).
	* If you are not the most cooperative player, cooperate (C) if:
		+ The most cooperative opponent is still cooperating (i.e., their last action was C).
		+ The stock level is above a certain threshold (e.g., 0.5 * capacity).
	* Otherwise, defect (D).
3. **Last Round (t = r)**:
	* Defect (D) if the stock level is below a certain threshold (e.g., 0.2 * capacity).
	* Cooperate (C) otherwise.

**Edge Cases:**

1. If there are multiple most cooperative opponents, choose one randomly.
2. If all opponents have defected in the previous round, cooperate (C) if the stock level is above a certain threshold (e.g., 0.5 * capacity).
3. In case of ties or ambiguous situations, default to cooperating (C).

**Pseudocode:**
```python
def adaptive_stock_guardian(stock, capacity, history):
    if t == 1:  # initial round
        if stock >= capacity * 0.8:
            return C
        else:
            return D

    avg_payoffs = calculate_avg_payoffs(history)
    most_cooperative_opponent = find_most_cooperative_opponent(avg_payoffs)

    if I am not the most cooperative player:
        if most_cooperative_opponent's last action was C and stock > 0.5 * capacity:
            return C
        else:
            return D

    # Last round handling
    if t == r:
        if stock < 0.2 * capacity:
            return D
        else:
            return C
```
This strategy is designed to be exploitative by:

* Cooperating when opponents are cooperative and the stock level is high, to maintain a sustainable resource.
* Defecting when opponents are defecting or the stock level is low, to maximize short-term gains.
* Adapting to opponents' behaviors and adjusting its own strategy accordingly.

By balancing cooperation and defection, this strategy aims to outperform other exploitative strategies in a tournament setting.
'''

description_EXPLOITATIVE_103 = '''
**Exploitative Strategy: "Adaptive Stock Raider" (ASR)**

The Adaptive Stock Raider (ASR) strategy is designed to maximize its payoff by exploiting the opponent's behavior while adapting to the changing game state.

**Decision Rules:**

1. **Initial Round:** In the first round, ASR plays Cooperate (C). This allows us to observe the opponents' initial actions and gather information about their strategies.
2. **Opponent Classification:** After the first round, classify each opponent as either "Cooperative" or "Defective" based on their action in the previous round. If an opponent played C, they are classified as Cooperative; otherwise, they are classified as Defective.
3. **Adaptive Exploitation:**
	* If most opponents (at least n/2) are classified as Cooperative, play Defect (D). This exploits the cooperative behavior of others and maximizes ASR's payoff.
	* If most opponents (at least n/2) are classified as Defective, play Cooperate (C). This minimizes losses when faced with multiple defectors and prepares for potential future exploitation.
	* If the number of Cooperative and Defective opponents is equal or nearly equal (within a margin of 1), play Cooperate (C). This cautious approach helps to maintain a stable stock level and avoids unnecessary conflicts.
4. **Stock-Level-Based Adjustment:** Monitor the current stock level (S) and adjust ASR's behavior accordingly:
	* If S < capacity/2, switch to Cooperate (C) for at least one round to allow the stock to recover.
	* If S > 3/4 \* capacity, play Defect (D) to maximize payoffs while the stock is abundant.

**Edge Cases:**

1. **Last Round:** In the final round, ASR plays Defect (D), as there are no future rounds to consider and the goal is to maximize immediate payoff.
2. **Ties in Opponent Classification:** When classifying opponents, if there is a tie between Cooperative and Defective classifications, prioritize the most recent action.

**Pseudocode:**
```markdown
ASRStrategy:
  Initialize:
    opponent_classifications = [Unknown] * n
    previous_actions = [None] * n

  Round t:
    If t == 1:
      Play Cooperate (C)
    Else:
      Update opponent_classifications based on previous actions
      Determine most common opponent classification
      If most opponents are Cooperative:
        Play Defect (D)
      Else if most opponents are Defective:
        Play Cooperate (C)
      Else: # nearly equal or unknown classifications
        Play Cooperate (C)

    Check current stock level S:
      If S < capacity/2:
        Play Cooperate (C) for at least one round
      If S > 3/4 \* capacity:
        Play Defect (D)

    Update previous_actions with the current actions of all players

  Last Round (t == r):
    Play Defect (D)
```
The Adaptive Stock Raider strategy is designed to be exploitative, yet adaptive and robust to a wide range of opponent behaviors. By classifying opponents and adjusting its behavior accordingly, ASR maximizes its payoff while navigating the dynamic game state.
'''

description_EXPLOITATIVE_104 = '''
Here's a description of an exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and avoid early depletion of the stock.
2. **Middle Rounds (2 ≤ t < r-1):**
	* If the average payoff per player in the previous round is above a certain threshold (e.g., 75% of the maximum possible payoff), Defect (D) to exploit the cooperation of others.
	* Otherwise, Cooperate (C) to maintain a healthy stock level and encourage opponents to cooperate.
3. **Last Round (t=r):** Defect (D) to maximize individual payoff, as there's no future benefit in preserving the stock.

**Adaptive Mechanism:**

1. Track the average payoff per player over the last few rounds (e.g., 3-5 rounds).
2. If the average payoff decreases significantly (e.g., by more than 10%), adjust the threshold for defecting upwards to reduce exploitation.
3. Conversely, if the average payoff increases significantly (e.g., by more than 15%), adjust the threshold downwards to increase exploitation.

**Edge Cases:**

1. **Low Stock Levels:** If the stock level falls below a critical threshold (e.g., 20% of capacity), Cooperate (C) to avoid depletion and encourage opponents to cooperate.
2. **High Stock Levels:** If the stock level exceeds a certain threshold (e.g., 80% of capacity), Defect (D) to exploit the abundant resource.

**Pseudocode:**
```python
def adaptive_exploiter(n, r, capacity, current_stock, history):
    if t == 1:  # Initial round
        return C
    
    avg_payoff = calculate_avg_payoff(history)
    
    if t < r-1:  # Middle rounds
        if avg_payoff > threshold:
            return D
        else:
            return C
    
    elif t == r:  # Last round
        return D
    
    def calculate_avg_payoff(history):
        # Calculate average payoff per player over last few rounds
        pass

def adjust_threshold(avg_payoff, threshold):
    if avg_payoff > threshold * 1.15:  # Increase exploitation
        return threshold * 0.9
    elif avg_payoff < threshold * 0.9:  # Reduce exploitation
        return threshold * 1.1
    else:
        return threshold
```
This strategy aims to balance short-term gains with long-term sustainability, adapting to the behavior of opponents while exploiting their cooperation when possible.
'''

description_EXPLOITATIVE_105 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Rounds (t = 1 to r/4)**:
	* Cooperate (C) with probability 0.5.
	* Defect (D) with probability 0.5.
This initial exploration phase helps gather information about opponents' behaviors and the game's dynamics.
2. **Mid-Game (t = r/4 + 1 to 3r/4)**:
	* If stock level is above 75% of capacity, Cooperate (C) with probability 0.7.
	* If stock level is between 50% and 75% of capacity, Defect (D) with probability 0.6.
	* If stock level is below 50% of capacity, Defect (D) with probability 0.8.
This phase adapts to the current stock level, balancing exploitation with sustainability.
3. **Late Game (t = 3r/4 + 1 to r)**:
	* If stock level is above 25% of capacity, Cooperate (C) with probability 0.9.
	* If stock level is below 25% of capacity, Defect (D) with probability 0.95.
In the final rounds, prioritize cooperation if there's still a sufficient stock level to maximize payoffs.

**Handling Edge Cases:**

1. **First Round**: Cooperate (C) with probability 0.5 to gather initial information about opponents' behaviors.
2. **Last Round**: Defect (D) with probability 0.95, as the game is ending and there's no future cost for over-exploitation.

**Adaptation Mechanism:**

Monitor the stock level and adjust cooperation/defection probabilities accordingly. This mechanism ensures that our strategy adapts to changing game conditions and opponents' behaviors.

**Exploitative Mindset:**

The Adaptive Stock Raider strategy prioritizes short-term gains by exploiting the common pool resource when the stock level is high or declining rapidly. By adapting to the current state of the game, we aim to maximize payoffs while minimizing the risk of over-exploitation.

Pseudocode:
```python
def adaptive_stock_raider(stock_level, capacity, round_number, total_rounds):
  if round_number <= total_rounds / 4:  # Initial exploration phase
    cooperate_prob = 0.5
  elif stock_level >= 0.75 * capacity:  # Mid-game cooperation
    cooperate_prob = 0.7
  elif 0.5 * capacity <= stock_level < 0.75 * capacity:  # Mid-game defection
    cooperate_prob = 0.4
  elif stock_level < 0.5 * capacity:  # Mid-game aggressive defection
    cooperate_prob = 0.2
  elif round_number > total_rounds * 3 / 4:  # Late game cooperation
    cooperate_prob = 0.9 if stock_level >= 0.25 * capacity else 0.05

  return random.random() < cooperate_prob
```
Note that this pseudocode provides a basic structure for the strategy and may require adjustments during implementation to ensure robustness and adaptability in various game scenarios.
'''

description_EXPLOITATIVE_106 = '''
**Strategy: Adaptive Exploiter**

The goal of this strategy is to maximize its total payoff by adapting to the behavior of other players and exploiting their actions.

**Decision Rules:**

1. **Initial Round (Round 1):** Cooperate (C) in the first round to gather information about other players' behavior.
2. **Observation Phase:** For rounds 2-5, alternate between Cooperating (C) and Defecting (D) to observe how other players respond to different actions.
3. **Adaptive Exploitation:**
	* If the stock level is above 75% of capacity:
		+ Cooperate (C) if most players (≥ n/2) cooperated in the previous round.
		+ Defect (D) otherwise.
	* If the stock level is between 25% and 75% of capacity:
		+ Cooperate (C) if at least one player defected in the previous round.
		+ Defect (D) otherwise.
	* If the stock level is below 25% of capacity:
		+ Defect (D) to maximize short-term gain, as the game is likely to end soon.
4. **Endgame (Last 2 rounds):** Always Defect (D) to maximize payoff in the final rounds.

**Pseudocode:**
```python
def adaptive_exploiter(stock, capacity, n, round_number, previous_actions):
    if round_number == 1:
        return "C"  # Cooperate in the first round

    observation_phase = round_number <= 5
    if observation_phase:
        alternate_action = ["C", "D"][round_number % 2]
        return alternate_action

    most_cooperated_last_round = sum(1 for action in previous_actions[-1] if action == "C") >= n / 2

    if stock > 0.75 * capacity:
        return "C" if most_cooperated_last_round else "D"
    elif stock < 0.25 * capacity:
        return "D"
    else:
        at_least_one_defected_last_round = any(action == "D" for action in previous_actions[-1])
        return "C" if at_least_one_defected_last_round else "D"

    if round_number >= r - 2:  # Endgame (Last 2 rounds)
        return "D"
```
**Rationale:**

* The strategy starts by cooperating to gather information about other players' behavior.
* During the observation phase, it alternates between Cooperating and Defecting to observe how other players respond to different actions.
* In the adaptive exploitation phase, it uses a combination of factors (stock level, previous actions) to decide whether to Cooperate or Defect. If most players cooperated in the previous round, it will cooperate if the stock level is high enough. Otherwise, it will defect.
* In the endgame, it always defects to maximize its payoff.

This strategy aims to balance short-term gain with long-term sustainability by adapting to the behavior of other players and exploiting their actions when possible.
'''

description_EXPLOITATIVE_107 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll outline a decision-making process that adapts to the game's state and history while aiming to maximize payoffs.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe the initial stock level and capacity.
	* Cooperate (C) in the first round to gather information about opponents' behavior and to avoid depleting the stock too quickly.
2. **Early Rounds (t>1, stock > 0.5 \* capacity)**:
	* If the majority of opponents (> n/2) defected in the previous round, defect (D) to take advantage of their over-exploitation.
	* Otherwise, cooperate (C) to maintain a sustainable stock level and encourage cooperation from other players.
3. **Mid-Game (0.5 \* capacity <= stock < capacity)**:
	* Monitor the stock growth rate: if it's increasing or stable, continue cooperating (C).
	* If the stock growth rate is decreasing, defect (D) to maximize short-term payoffs before the stock depletes further.
4. **Late Rounds (stock < 0.5 \* capacity)**:
	* Defect (D) to maximize remaining payoffs, as cooperation will not significantly impact the game's outcome.
5. **Last Round (t=r)**:
	* Defect (D) regardless of previous behavior, as there are no future rounds to consider.

**Edge Cases:**

1. If an opponent consistently cooperates, exploit their cooperation by defecting in subsequent rounds.
2. If multiple opponents defect simultaneously, adjust the strategy to cooperate in the next round to replenish the stock and create opportunities for future exploitation.

**Pseudocode (simplified)**:
```
def exploitative_strategy(stock, capacity, n, t, history):
  if t == 1:  # Initial Round
    return "C"  # Cooperate

  majority_defected = sum(1 for action in history[-1] if action == "D") > n / 2

  if stock > 0.5 * capacity and not majority_defected:
    return "C"  # Cooperate to maintain sustainable stock
  elif stock < 0.5 * capacity or t == r:  # Late Rounds or Last Round
    return "D"  # Defect to maximize payoffs
  else:
    if len([action for action in history[-1] if action == "C"]) > n / 2:
      return "D"  # Exploit opponents' cooperation
    else:
      return "C"  # Cooperate to replenish stock

# Note: This pseudocode is a simplified representation of the strategy.
```
**Rationale:**

This exploitative strategy balances short-term gains with long-term sustainability. By cooperating initially and adapting to opponents' behavior, it gathers information about their strategies and adjusts its own decision-making process accordingly. As the game progresses, it prioritizes maximizing payoffs while maintaining a sustainable stock level. In late rounds, it exploits remaining opportunities by defecting.

This strategy should perform well in a tournament against independent strategies developed by other AI systems, as it:

1. Adapts to opponents' behavior without relying on coordination mechanisms.
2. Balances short-term gains with long-term sustainability.
3. Exploits opportunities for cooperation and defection based on game state and history.

Please let me know if you would like me to elaborate or modify any aspect of this strategy!
'''

description_EXPLOITATIVE_108 = '''
Here's a robust and exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to observe opponents' actions and gather information.
2. **Early Rounds (t < r/2):**
	* If the stock level is above 75% of capacity, cooperate (C).
	* Otherwise, defect (D) if at least one opponent defected in the previous round; otherwise, cooperate (C).
3. **Mid-Game (r/2 ≤ t < 3r/4):**
	* If the stock level is below 50% of capacity, defect (D) to maximize payoff.
	* Otherwise, use a " Tit-for-Tat" approach:
		+ Cooperate (C) if all opponents cooperated in the previous round.
		+ Defect (D) if at least one opponent defected in the previous round.
4. **Endgame (t ≥ 3r/4):**
	* If the stock level is above 25% of capacity, cooperate (C) to conserve stock for future rounds.
	* Otherwise, defect (D) to maximize payoff.

**Edge Cases:**

1. **Last Round:** Defect (D) to maximize payoff, as there's no future benefit from cooperation.
2. **Single Opponent:** Always cooperate (C) when facing a single opponent to maximize joint payoffs and encourage cooperation.
3. **Multiple Opponents with No Defectors:** Cooperate (C) if all opponents have cooperated consistently; otherwise, defect (D).

**Rationale:**

The Adaptive Exploiter strategy aims to balance short-term gains with long-term sustainability by adapting to changing game conditions and opponent behaviors.

In the early rounds, AE gathers information about opponents' actions and conserves stock. As the game progresses, AE becomes more aggressive when the stock level is low or opponents defect frequently.

By using Tit-for-Tat in mid-game, AE encourages cooperation among opponents while still exploiting those who defect. In the endgame, AE prioritizes maximizing payoff if the stock level is low.

**Pseudocode:**
```
Function AdaptiveExploiter(current_stock, previous_actions, round):
  if (round == 1) return Cooperate // Initial Round
  elif (current_stock > 0.75 * capacity and round < r/2) return Cooperate // Early Rounds
  elif (current_stock <= 0.5 * capacity and round >= r/2 and round < 3r/4) return Defect // Mid-Game
  else if (all_opponents_cooperated(previous_actions)) return Cooperate // Tit-for-Tat
  else if (any_opponent_defected(previous_actions)) return Defect // Tit-for-Tat
  elif (current_stock > 0.25 * capacity and round >= 3r/4) return Cooperate // Endgame Conservation
  else return Defect // Endgame Maximization

Function all_opponents_cooperated(actions):
  for each action in actions:
    if action != Cooperate: return False
  return True

Function any_opponent_defected(actions):
  for each action in actions:
    if action == Defect: return True
  return False
```
This strategy should perform well against a variety of opponents, as it adapts to changing game conditions and exploits opportunities for short-term gain while maintaining long-term sustainability.
'''

description_EXPLOITATIVE_109 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5 to gather information about opponents' behavior and test their responsiveness.
2. **Middle Rounds (2 ≤ t < r):**
	* If the stock level is above 75% of capacity, Defect (D) if at least one opponent defected in the previous round; otherwise, Cooperate (C).
	* If the stock level is between 50% and 75% of capacity, Cooperate (C) if most opponents cooperated in the previous round; otherwise, Defect (D).
	* If the stock level is below 50% of capacity, Defect (D) to maximize short-term gain.
3. **Final Round (t=r):** Defect (D) to extract maximum value from the remaining stock.

**Additional Heuristics:**

* **Tit-for-Tat-inspired component:** If an opponent defected in the previous round and you cooperated, increase the probability of defecting in the current round by 10%.
* **Stock growth monitoring:** If the stock level increases significantly (by more than 20%) between two consecutive rounds, decrease the probability of defecting in the next round by 10% to encourage opponents to cooperate.
* **Opponent classification:** Keep track of each opponent's behavior as either "cooperative" or "defective" based on their previous actions. Adjust your strategy accordingly:
	+ If most opponents are classified as cooperative, Cooperate (C) more frequently.
	+ If most opponents are classified as defective, Defect (D) more frequently.

**Pseudocode:**
```python
function AdaptiveStockHawk(stock_level, capacity, round_number, opponent_actions):
  if round_number == 1:
    # Initial Round
    return random_choice([C, D], p=[0.5, 0.5])
  
  previous_stock = get_previous_stock()
  opponents_defected = count_defectors(opponent_actions)
  
  if stock_level > 0.75 * capacity:
    # Stock level is high
    if opponents_defected >= 1:
      return D
    else:
      return C
  
  elif stock_level >= 0.5 * capacity:
    # Stock level is moderate
    if most_opponents_cooperated(opponent_actions):
      return C
    else:
      return D
  
  else:
    # Stock level is low
    return D
  
  # Adjust strategy based on opponent classification and tit-for-tat component
  adjust_strategy(opponent_actions, stock_level)
  
  # Final Round
  if round_number == r:
    return D
```
This exploitative strategy aims to maximize individual payoffs by adapting to the game's dynamic state and opponents' behavior. By incorporating elements of Tit-for-Tat and opponent classification, it seeks to balance short-term gains with long-term sustainability in a repeated game setting.
'''

description_EXPLOITATIVE_110 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy is designed to maximize payoffs by adaptively responding to the current state and history of the game, while also considering the game parameters.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behaviors and set a baseline for future actions.
2. **Stock Level Assessment**: Evaluate the current stock level (S) relative to the capacity (c). If S ≥ 0.75c, defect (D); otherwise, cooperate (C).
3. **Opponent Behavior Analysis**: Track the number of cooperators (n_C) and defectors (n_D) in the previous round. If n_C > n_D, cooperate; if n_D > n_C, defect.
4. **Payoff Maximization**: Calculate the expected payoff for cooperating (E[C]) and defecting (E[D]) based on the current stock level and opponent behaviors. Choose the action with the higher expected payoff.

**Pseudocode:**
```python
def AdaptiveStockRaider(current_stock, capacity, num_cooperators_prev_round, num_defectors_prev_round):
    if current_round == 1:
        return 'C'  # Cooperate in the first round

    stock_level_ratio = current_stock / capacity
    if stock_level_ratio >= 0.75:
        return 'D'  # Defect when stock is high

    opponent_behavior = num_cooperators_prev_round - num_defectors_prev_round
    if opponent_behavior > 0:
        return 'C'  # Cooperate when more opponents cooperate
    elif opponent_behavior < 0:
        return 'D'  # Defect when more opponents defect

    expected_payoff_C = (current_stock / (2 * num_players)) * (1 - stock_level_ratio)
    expected_payoff_D = (current_stock / num_players) * (1 - stock_level_ratio)

    if expected_payoff_C > expected_payoff_D:
        return 'C'  # Cooperate when payoff is higher
    else:
        return 'D'  # Defect when payoff is higher
```
**Edge Cases:**

* **Last Round**: In the final round, defect (D) to maximize payoffs regardless of opponent behaviors or stock levels.
* **Ties**: In cases where expected payoffs are equal or opponent behaviors are tied, cooperate (C) by default.

This strategy aims to balance short-term gains with long-term sustainability, adapting to changes in the game state and opponent behaviors. By responding to both the current stock level and opponent actions, Adaptive Stock Raider seeks to maximize its own payoffs while minimizing the risk of depleting the common pool resource.
'''

description_EXPLOITATIVE_111 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Our strategy aims to maximize payoffs by adaptively responding to the game state and opponents' actions. We'll use a combination of conditional cooperation and defection to exploit the stock dynamics.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with probability 0.5, Defect (D) with probability 0.5. This random initial action helps us gauge opponents' strategies.
2. **Subsequent Rounds (t>1):**
	* If the stock level is high (> 75% of capacity), Defect (D). We'll take advantage of the abundant resource and maximize our payoff.
	* If the stock level is moderate (25% ≤ stock ≤ 75% of capacity):
		+ If the average opponent payoff in the previous round was higher than our own, Cooperate (C). This indicates opponents might be cooperating; we'll match their strategy to maintain a stable stock.
		+ Otherwise, Defect (D).
	* If the stock level is low (< 25% of capacity), Cooperate (C). We'll prioritize preserving the resource for future rounds.

**Additional Heuristics:**

1. **Last Round (t=r):** Always Defect (D), as there's no future benefit to cooperating.
2. **Stock Near Depletion:** If the stock level is critically low (< 10% of capacity), Cooperate (C) with probability 0.8, Defect (D) with probability 0.2. This reduces the likelihood of complete stock depletion.

**Pseudocode:**
```python
def adaptive_stock_raider(current_round, current_stock, opponent_payoffs):
    if current_round == 1:
        return random.choice([C, D])  # Random initial action

    if current_stock > 0.75 * capacity:
        return D  # Defect when stock is high
    elif 0.25 <= current_stock / capacity <= 0.75:
        avg_opponent_payoff = sum(opponent_payoffs) / len(opponent_payoffs)
        if avg_opponent_payoff > my_previous_payoff:
            return C  # Cooperate if opponents cooperated more
        else:
            return D  # Defect otherwise
    else:  # Low stock level
        return C  # Prioritize preserving the resource

    if current_round == r:  # Last round
        return D  # Always defect in the last round

    if current_stock < 0.1 * capacity:  # Stock near depletion
        return random.choice([C, D], p=[0.8, 0.2])  # Cooperate with high probability
```
This strategy is designed to be adaptive and robust against various opponent behaviors. By conditionally cooperating or defecting based on the game state and opponents' actions, we aim to maximize our payoffs while minimizing the risk of stock depletion.

Note that this strategy does not rely on explicit coordination mechanisms or norms; instead, it uses a combination of heuristics and probabilistic choices to navigate the game dynamics.
'''

description_EXPLOITATIVE_112 = '''
**Exploitative Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy is designed to balance short-term gains with long-term sustainability, adapting to the game state and opponent behavior while prioritizing exploitation.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to observe opponents' initial actions and avoid early depletion.
2. **Early Rounds (t<0.25r):**
	* If stock level is high (> 0.75 \* capacity), Defect (D) to maximize short-term gains.
	* Otherwise, Cooperate (C) to conserve stock and gather information on opponents' strategies.
3. **Mid-Game (0.25r ≤ t < 0.75r):**
	* If the average opponent payoff is high (> 0.5 \* capacity / n), Defect (D) to exploit their cooperative behavior.
	* Otherwise, Cooperate (C) to maintain a balanced approach and avoid over-depletion.
4. **Late Rounds (t ≥ 0.75r):**
	* If the stock level is low (< 0.25 \* capacity), Defect (D) to maximize remaining gains.
	* Otherwise, Cooperate (C) to ensure some sustainability for the final rounds.

**Additional Rules:**

* If an opponent defects in a round, increase the likelihood of defecting in the next round by 20% (up to a maximum of 80%).
* If the stock level drops below 0.5 \* capacity, reduce the likelihood of cooperating by 10% (down to a minimum of 20%).

**Edge Cases:**

* **Last Round (t=r):** Always Defect (D) to maximize final gains.
* **Opponent Cooperation:** If an opponent consistently cooperates (> 80% of rounds), increase the likelihood of cooperating in response by 15%.
* **Stock Saturation:** If the stock level reaches capacity, Cooperate (C) to avoid unnecessary depletion.

**Pseudocode:**
```python
def ASC(n, r, capacity, state):
    # Initialize variables
    t = current_round
    stock_level = state['stock']
    opponent_payoffs = [0] * n
    
    # Early rounds
    if t < 0.25r:
        if stock_level > 0.75 * capacity:
            return 'D'
        else:
            return 'C'
    
    # Mid-game
    avg_opponent_payoff = sum(opponent_payoffs) / n
    if avg_opponent_payoff > 0.5 * capacity / n:
        return 'D'
    else:
        return 'C'
    
    # Late rounds
    if stock_level < 0.25 * capacity:
        return 'D'
    else:
        return 'C'

def update_opponent_payoffs(opponent_actions):
    for i in range(n):
        if opponent_actions[i] == 'D':
            opponent_payoffs[i] += 1

def adjust_strategy(opponent_payoffs, stock_level):
    # Increase likelihood of defecting if opponents cooperate
    if sum(opponent_payoffs) > 0.8 * n:
        ASC_cooperation_likelihood -= 0.15
    
    # Reduce cooperation if stock level drops below threshold
    if stock_level < 0.5 * capacity:
        ASC_cooperation_likelihood -= 0.10
```
This strategy balances short-term exploitation with long-term sustainability, adapting to the game state and opponent behavior while prioritizing exploitation.
'''

description_EXPLOITATIVE_113 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behavior and the stock's response to consumption.
2. **Low-Stock Situations:** Defect (D) when the current stock level is below 25% of the capacity. This ensures a higher payoff in situations where cooperation would lead to minimal gains due to low stock levels.
3. **Opponent Analysis:** Observe opponents' actions and payoffs from previous rounds. If an opponent consistently cooperates, defect against them. If an opponent tends to alternate or mix strategies, cooperate 60% of the time and defect 40%.
4. **Stock Trend Analysis:** Monitor the stock level trend over the last three rounds. If the stock is increasing or stable, cooperate 70% of the time. If the stock is decreasing, defect 80% of the time.
5. **Self-Interest Threshold:** Defect if the expected payoff from cooperation is less than 75% of the capacity divided by 2n (the maximum possible payoff).

**Edge Case Handling:**

* Last Round: Always defect in the last round to maximize personal gain, as there are no future rounds to consider.
* Ties and Ambiguities: In cases where multiple strategies suggest different actions, prioritize self-interest and defect.

**Pseudocode:**
```python
def adaptive_stock_raider(current_round, current_stock, opponent_history, capacity):
    # Initial Round
    if current_round == 1:
        return 'C'

    # Low-Stock Situations
    if current_stock < 0.25 * capacity:
        return 'D'

    # Opponent Analysis
    opponent_cooperation_rate = analyze_opponent_history(opponent_history)
    if opponent_cooperation_rate > 0.8:  # Consistent cooperation
        return 'D'
    elif opponent_cooperation_rate < 0.5:  # Alternating or mixed strategies
        cooperate_probability = 0.6
        return 'C' if random.random() < cooperate_probability else 'D'

    # Stock Trend Analysis
    stock_trend = analyze_stock_trend(current_round, current_stock)
    if stock_trend == 'increasing' or stock_trend == 'stable':
        cooperate_probability = 0.7
        return 'C' if random.random() < cooperate_probability else 'D'
    else:
        defect_probability = 0.8
        return 'D' if random.random() < defect_probability else 'C'

    # Self-Interest Threshold
    expected_cooperation_payoff = current_stock / (2 * len(opponent_history))
    if expected_cooperation_payoff < 0.75 * capacity / (2 * len(opponent_history)):
        return 'D'
```
**Rationale:**

ASR is designed to be adaptive, exploitative, and robust against a wide range of opponent behaviors. By analyzing opponents' actions, the stock trend, and self-interest thresholds, ASR makes informed decisions that balance short-term gains with long-term sustainability. The initial round cooperation allows for information gathering, while low-stock situations trigger defection to secure higher payoffs. Opponent analysis helps identify and exploit cooperative players, while stock trend analysis informs decisions based on the game's state.
'''

description_EXPLOITATIVE_114 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

ASR is a robust and adaptive strategy that aims to maximize its payoff by exploiting the game's dynamics and opponent behaviors.

**Decision Rules:**

1. **Initial Round:** In the first round, ASR defects (D) to gather information about the opponents' behaviors and the stock's response.
2. **Stock-based Cooperation Threshold:** For subsequent rounds, ASR calculates a cooperation threshold based on the current stock level:

`cooperation_threshold = capacity / (2 * n + 1)`

If the current stock level is above this threshold, ASR cooperates (C). Otherwise, it defects (D).

3. **Opponent Behavior Analysis:** After each round, ASR analyzes the opponents' actions and updates its internal state:

* If most opponents (> 50%) cooperated in the previous round, ASR defects (D) in the next round to exploit their cooperation.
* If most opponents (> 50%) defected in the previous round, ASR cooperates (C) in the next round to take advantage of the potential stock growth.
4. **Stock Growth Expectation:** Before making a decision, ASR estimates the expected stock growth based on the current stock level and its own action:

`expected_growth = 2 * (current_stock - total_consumption) * (1 - current_stock/capacity)`

If the expected growth is positive, ASR cooperates (C). Otherwise, it defects (D).

**Edge Cases:**

* **Last Round:** In the final round, ASR always defects (D) to maximize its payoff, regardless of the stock level or opponent behaviors.
* **Low Stock Levels:** If the current stock level is very low (< 10% of capacity), ASR cooperates (C) to allow for potential stock growth and avoid depletion.

**Pseudocode:**
```python
def asr_decision(current_stock, opponents_actions, round_number):
    if round_number == 1:
        return "D"  # Initial round defect

    cooperation_threshold = capacity / (2 * n + 1)
    if current_stock > cooperation_threshold:
        return "C"

    opponent_cooperation_rate = sum(opponents_actions) / len(opponents_actions)
    if opponent_cooperation_rate > 0.5:
        return "D"  # Exploit cooperation
    else:
        return "C"  # Take advantage of potential growth

    expected_growth = 2 * (current_stock - total_consumption) * (1 - current_stock/capacity)
    if expected_growth > 0:
        return "C"
    else:
        return "D"

def asr_last_round(current_stock):
    return "D"  # Always defect in the last round

def asr_low_stock(current_stock):
    if current_stock < 0.1 * capacity:
        return "C"  # Cooperate to allow for potential growth
```
ASR is designed to adapt to various opponent behaviors and exploit the game's dynamics to maximize its payoff. Its decision rules balance cooperation and defection based on the stock level, opponent actions, and expected growth.
'''

description_EXPLOITATIVE_115 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Rounds (t ≤ n)**:
	* Cooperate (C) with a probability of 0.5 to gather information about opponents' behaviors and stock dynamics.
2. **Middle Rounds (n < t < r - n)**:
	* If the current stock is high (> capacity/2):
		+ Defect (D) if at least one opponent defected in the previous round, or if your payoff was lower than the average opponent's payoff in the previous round.
		+ Cooperate (C) otherwise.
	* If the current stock is low (≤ capacity/2):
		+ Cooperate (C) to allow the stock to recover and increase future payoffs.
3. **Final Rounds (t ≥ r - n)**:
	* Defect (D) to maximize immediate payoffs, as the game's end reduces the value of cooperation.

Additional Rules:

* If an opponent consistently cooperates (≥ 90% C in previous rounds), exploit them by defecting (D).
* If multiple opponents are defecting (> 50% D in previous rounds), cooperate (C) to maintain a stable stock level.
* Monitor and adapt to changes in opponents' behaviors, adjusting the strategy as needed.

Pseudocode:
```python
def AdaptiveStockRaider(game_state, history):
    n = game_state['n']
    capacity = game_state['capacity']
    t = game_state['round']
    r = game_state['r']

    # Initial rounds
    if t <= n:
        return random.choice([C, D])  # Explore and gather information

    # Middle rounds
    stock = game_state['stock']
    prev_round_payoffs = history[-1]['payoffs']
    opponents_behaviors = [opp_behavior for opp_behavior in history[:-1]]

    if stock > capacity / 2:
        # Defect if an opponent defected or payoff was low
        if any(opponent_defected(prev_round_payoffs, opponents_behaviors)) or \
           prev_round_payoffs[self] < np.mean([payoff for payoff in prev_round_payoffs]):
            return D
        else:
            return C
    else:  # Low stock, cooperate to recover
        return C

    # Final rounds
    if t >= r - n:
        return D  # Maximize immediate payoffs

def opponent_defected(prev_round_payoffs, opponents_behaviors):
    for i, behavior in enumerate(opponents_behaviors):
        if prev_round_payoffs[i] > prev_round_payoffs[self] and \
           behavior == D:
            return True
    return False
```
This strategy balances exploration, exploitation, and adaptation to maximize payoffs while being robust to various opponent behaviors.
'''

description_EXPLOITATIVE_116 = '''
**Exploitative Strategy: "Adaptive Stock Harvester"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gauge opponents' behavior and avoid over-exploiting the stock.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize short-term gain.
	* If the current stock level is between 25% and 75% of the capacity, use a probabilistic approach:
		+ With probability p = (current stock / capacity)^2, Cooperate (C).
		+ With probability 1 - p, Defect (D).
	* If the current stock level is below 25% of the capacity, Cooperate (C) to conserve the remaining stock.
3. **Last Round (t=r):** Defect (D) to maximize final-round payoff.

**Rationale:**

* In the initial round, cooperating allows us to observe opponents' behavior without risking significant losses.
* When the stock level is high, defecting maximizes short-term gain while minimizing the risk of over-exploitation.
* The probabilistic approach in the middle range (25%-75% capacity) balances cooperation and defection based on the current stock level. As the stock level decreases, the probability of cooperating increases to conserve the remaining stock.
* In the last round, defecting ensures maximum payoff since there are no future rounds to consider.

**Adaptive Elements:**

* The strategy adapts to the current stock level, which reflects the cumulative effect of all players' actions.
* By observing opponents' behavior in the initial round and adjusting our strategy accordingly, we can exploit their tendencies.

**Robustness:**

* The strategy is robust against a wide range of opponent behaviors, as it doesn't rely on specific coordination mechanisms or norms.
* By balancing cooperation and defection based on the current stock level, we minimize the risk of over-exploitation and maximize our payoff in various scenarios.

Pseudocode:
```python
def adaptive_stock_harvester(current_stock, capacity, round_number, total_rounds):
    if round_number == 1:  # Initial Round
        return "C"  # Cooperate

    elif current_stock > 0.75 * capacity:  # High Stock Level
        return "D"  # Defect

    elif 0.25 * capacity <= current_stock <= 0.75 * capacity:  # Middle Range
        p = (current_stock / capacity) ** 2
        if random.random() < p:
            return "C"  # Cooperate with probability p
        else:
            return "D"  # Defect with probability 1 - p

    elif current_stock < 0.25 * capacity:  # Low Stock Level
        return "C"  # Cooperate to conserve stock

    elif round_number == total_rounds:  # Last Round
        return "D"  # Defect to maximize final-round payoff
```
This strategy should perform well in a tournament against independent strategies, as it adaptively balances cooperation and defection based on the current state of the game.
'''

description_EXPLOITATIVE_117 = '''
To develop an exploitative strategy for this Common Pool Resource Game, I'll introduce a dynamic approach that adapts to the game's state and history while aiming to maximize payoffs. This strategy will be based on observing the stock levels, the actions of other players, and adjusting behavior accordingly.

### Strategy Name: Adaptive Exploiter

#### Decision Rules:

1. **Initial Round**: In the first round, cooperate (C) if the number of players is even; otherwise, defect (D). This initial choice helps in observing how others react to different starting conditions without immediately depleting resources.
   
2. **Early Rounds**: For the next few rounds (e.g., r/4), monitor the stock level and the average consumption rate of other players. Calculate a "cooperation index" (CI) based on the ratio of remaining stock after each round's consumption to its capacity, indicating how conservatively or liberally resources are being used.

   - If CI > 0.6, cooperate in the next round. This indicates that, on average, players are acting conservatively.
   - If CI ≤ 0.6, defect. This shows aggressive resource depletion, suggesting a need to maximize individual gain before resources dwindle.

3. **Mid-Game Adjustment**: After the initial monitoring phase, reassess based on stock levels and opponents' actions:
   
   - **High Stock (> capacity/2)**: Continue cooperating if CI remains high, indicating sustainable use.
   
   - **Low Stock (< capacity/4)**: Defect to maximize individual payoffs before resources are depleted.
   
   - **Moderate Stock**: Adopt a mixed strategy based on the observed behavior of other players:
     - If a majority cooperated in previous rounds, cooperate to sustain the stock level.
     - Otherwise, defect.

4. **Endgame Strategy (Last r/4 Rounds)**: As the game nears its end, prioritize maximizing payoffs regardless of sustainability:
   
   - **High Stock**: Cooperate if others are likely to do so, based on previous behavior; otherwise, defect.
   
   - **Low Stock**: Defect to claim as much as possible from remaining resources.

5. **Adaptive Component**: Throughout the game, maintain a "defection index" (DI) by tracking how often each player defects versus cooperates. Use this DI to predict likely actions of opponents and adjust your strategy accordingly:
   
   - If an opponent's DI suggests frequent defection, prepare for aggressive resource depletion.
   
   - If an opponent's DI indicates cooperation, consider reciprocating to sustain resources.

#### Edge Cases:

- **First Round**: Follow the initial round rule.
  
- **Last Round**: Always defect to maximize final payoffs.
  
- **Tied or Near-Tied Consumption Rates**: In cases of uncertainty (e.g., when consumption rates are very close), default to cooperating if the stock level is high and defecting otherwise.

#### Implementation Notes:

This strategy's effectiveness relies on its adaptability, using the game's state and history to inform decisions. By initially monitoring opponents' actions and adjusting based on observed behaviors, it aims to balance individual payoff maximization with resource sustainability. The exploitative mindset guides the approach by prioritizing self-interest while being responsive to changes in the game environment.

#### Pseudocode:

```plaintext
Function AdaptiveExploiter(stock, capacity, n, r, history):
  // Initial setup
  If round == 1:
    If n is even:
      Action = Cooperate
    Else:
      Action = Defect

  // Early rounds monitoring and adjustment
  ElseIf round <= r/4:
    Calculate CI based on stock level and opponents' actions
    If CI > 0.6:
      Action = Cooperate
    Else:
      Action = Defect

  // Mid-game reassessment
  Else:
    If stock > capacity/2:
      Continue cooperating if CI remains high
    ElseIf stock < capacity/4:
      Action = Defect
    Else:
      Adopt mixed strategy based on opponents' observed behavior

  // Endgame maximization
  If round >= r - r/4:
    Prioritize defecting to maximize payoffs

  // Update history with current actions and outcomes
  Record action taken and resulting payoff in history

Return Action
```

This pseudocode encapsulates the decision-making process of the Adaptive Exploiter strategy, emphasizing adaptability and a focus on maximizing individual payoffs within the context of a dynamic game environment.
'''

description_EXPLOITATIVE_118 = '''
**Strategy Name:** Adaptive Stock Guardian (ASG)

**Overview:**
The ASG strategy aims to exploit opponents' behaviors while ensuring long-term sustainability of the common pool resource. It balances cooperation and defection based on the current state of the stock, history of opponent actions, and game parameters.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gauge opponents' initial strategies and set a cooperative tone.
2. **Stock-Based Cooperation:** If the current stock level is above 75% of capacity, cooperate (C). This helps maintain a healthy stock level and encourages opponents to cooperate as well.
3. **Defection Threshold:** If the current stock level falls below 25% of capacity, defect (D) in the next round. This prevents over-exploitation by opponents and motivates them to cooperate to replenish the stock.
4. **Opponent-Based Defection:** Monitor opponents' actions for two consecutive rounds:
	* If an opponent defects twice in a row, assume they are non-cooperative and defect (D) against them.
	* If an opponent cooperates twice in a row, assume they are cooperative and cooperate (C) with them.
5. **Stock Growth-Based Cooperation:** After a round where the stock growth is positive, cooperate (C) in the next round to maintain momentum and encourage opponents to do the same.

**Pseudocode:**
```python
def ASG(n, capacity, current_stock, history):
    # Initial Round
    if len(history) == 0:
        return 'C'

    # Stock-Based Cooperation
    if current_stock > 0.75 * capacity:
        return 'C'

    # Defection Threshold
    if current_stock < 0.25 * capacity:
        return 'D'

    # Opponent-Based Defection
    opponent_actions = [action for action in history[-2:] if action != '']
    for opponent_action in opponent_actions:
        if opponent_action == 'D' and history.count('D') > len(history) // 2:
            return 'D'
        elif opponent_action == 'C' and history.count('C') > len(history) // 2:
            return 'C'

    # Stock Growth-Based Cooperation
    if stock_growth(current_stock, capacity) > 0:
        return 'C'

    # Default Action (exploit uncertainty)
    return 'D'
```

**Edge Cases:**

* **Last Round:** In the final round, defect (D) to maximize personal payoff.
* **Ties in Opponent-Based Defection:** If there is a tie in opponent actions, default to cooperation (C).
* **Multiple Opponents with Different Strategies:** The ASG strategy will adapt to each opponent's behavior individually.

**Robustness and Adaptability:**

The ASG strategy is designed to be robust against various opponent behaviors by:

* Monitoring and adapting to changes in stock levels
* Identifying cooperative and non-cooperative opponents
* Adjusting its cooperation/defection ratio based on the game state

By being exploitative, the ASG strategy aims to outperform other strategies that may rely too heavily on cooperation or altruism.
'''

description_EXPLOITATIVE_119 = '''
I'll design a strategy that balances short-term gain with long-term sustainability, while also trying to exploit potential weaknesses in opponents' behaviors. Here's my approach:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Rounds (t ≤ n/2):** Cooperate (C) to establish a baseline for the game state and allow the stock to grow.
2. **Assessing Opponent Behavior (n/2 < t ≤ 3n/4):** Observe the average consumption of opponents over the last few rounds. If their average consumption is below the sustainable level (stock/(2n)), defect (D). Otherwise, cooperate (C).
3. **Exploiting Greed (3n/4 < t ≤ r-1):** Identify the most aggressive opponent(s) based on their historical consumption patterns. Defect (D) if these opponents are likely to consume a significant portion of the stock.
4. **Endgame Strategy (t = r):** Cooperate (C) in the final round, as there's no incentive to defect when the game is about to end.

**Edge Cases:**

* **First Round:** Cooperate (C) to avoid immediate overconsumption and allow the stock to grow.
* **Last Round:** Cooperate (C), as there's no benefit in defecting when the game ends immediately after this round.
* **Low Stock Levels (stock < n):** Defect (D) aggressively, as cooperation will not lead to significant benefits.

**Adaptive Elements:**

1. **Monitoring Opponent Behavior:** Continuously track opponents' consumption patterns and adjust strategy accordingly.
2. **Stock Level Adjustments:** Adapt the decision threshold for defecting based on the current stock level and growth rate.

**Pseudocode (simplified):**
```markdown
def AdaptiveExploiter(n, capacity, r, history):
  if t <= n/2:
    return C  # Cooperate initially

  avg_opponent_consumption = calculate_avg_consumption(history)
  if avg_opponent_consumption < stock/(2n):
    return D  # Defect if opponents are cautious
  else:
    return C  # Cooperate otherwise

  if t > 3n/4 and t < r-1:
    aggressive_opponents = identify_aggressive_opponents(history)
    if aggressive_opponents_exist(aggressive_opponents):
      return D  # Exploit greedy opponents
    else:
      return C  # Cooperate otherwise

  if t == r:
    return C  # Cooperate in the final round

  if stock < n:
    return D  # Defect aggressively at low stock levels
```
This strategy, Adaptive Exploiter (AE), balances short-term gains with long-term sustainability while trying to exploit potential weaknesses in opponents' behaviors. It adapts to changing game conditions and opponent actions, making it a robust competitor in the tournament.
'''

description_EXPLOITATIVE_120 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to observe opponents' behavior and gather information about their strategies.
2. **Subsequent Rounds**: Use a dynamic threshold-based approach to decide between Cooperation (C) and Defection (D).

Let `stock_threshold` be a variable that tracks the minimum stock level required for cooperation.

* If `current_stock` > `capacity` / 2, set `stock_threshold` = `capacity` / 4.
* If `current_stock` ≤ `capacity` / 2, set `stock_threshold` = `current_stock` / 2.

 Cooperate (C) if:

* The number of players who defected in the previous round is less than or equal to n/2 (i.e., at least half of the players cooperated).
* The current stock level is above the `stock_threshold`.

Defect (D) otherwise.

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round, as there are no future rounds to consider.
2. **Low Stock Levels**: If the current stock level falls below a certain percentage of the capacity (e.g., 10%), defect (D) to maximize short-term gains, regardless of the `stock_threshold`.
3. **Opponent Detection**: Monitor opponents' behavior and adjust the strategy if an opponent is detected to be using a cooperative or tit-for-tat-like strategy.

**Pseudocode:**
```markdown
# Initialize variables
stock_threshold = capacity / 4

# First round: Cooperate (C)
if current_round == 1:
    action = C

# Subsequent rounds
else:
    # Update stock threshold based on current stock level
    if current_stock > capacity / 2:
        stock_threshold = capacity / 4
    else:
        stock_threshold = current_stock / 2

    # Check opponent behavior and adjust strategy
    if num_defectors_last_round <= n / 2 and current_stock >= stock_threshold:
        action = C
    else:
        action = D

    # Edge case: Low stock levels
    if current_stock < 0.1 * capacity:
        action = D

# Last round: Defect (D)
if current_round == r:
    action = D
```
**Exploitative Mindset:**

The Adaptive Stock Raider strategy aims to exploit opponents' cooperation by defecting when the stock level is low or when a sufficient number of opponents are cooperating. By adjusting the `stock_threshold` dynamically, the strategy balances short-term gains with long-term sustainability.

By monitoring opponent behavior and adapting to their strategies, this exploitative approach can effectively take advantage of cooperative players while minimizing the risk of being exploited itself.
'''

description_EXPLOITATIVE_121 = '''
**Exploitative Strategy: Adaptive Stock-Based Exploitation (ASBE)**

The ASBE strategy aims to maximize payoffs by adaptively exploiting the common pool resource based on the current stock level and opponents' past behavior.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' initial actions.
2. **Stock-Based Threshold:** Calculate a dynamic threshold, `T`, as a function of the current stock level, `S`. When `S` is below `T`, defect (D); otherwise, cooperate (C).

`T = capacity / (2 * n) + (S - capacity / (2 * n)) / 4`

This threshold balances exploitation and conservation. As the stock level decreases, the threshold increases, making it more likely to defect.

3. **Opponent-Based Adjustment:** Monitor opponents' past actions and adjust the threshold based on their cooperation rates. If most opponents cooperated in previous rounds, decrease `T` by a small margin (e.g., 5%) to take advantage of their conservation efforts. Conversely, if most opponents defected, increase `T` by a small margin to avoid over-exploitation.
4. **Last Round:** Defect (D) in the final round, as there is no future payoff to consider.

**Pseudocode:**
```
ASBE(n, capacity, r):
  // Initialize variables
  stock = capacity
  threshold = capacity / (2 * n)
  opponent_cooperation_rates = [0] * n

  for t in range(1, r + 1):
    if t == 1:
      action = C  // Cooperate in the first round
    else:
      calculate_threshold(threshold, stock, capacity, n)
      adjust_threshold(opponent_cooperation_rates)

      if stock < threshold:
        action = D  // Defect when stock is below threshold
      else:
        action = C  // Cooperate otherwise

    // Update opponent cooperation rates and take action
    update_opponent_cooperation_rates(opponent_actions, t)
    take_action(action, t)

    // Update stock level
    calculate_stock(stock, actions_taken, capacity, n)

def calculate_threshold(threshold, stock, capacity, n):
  threshold = capacity / (2 * n) + (stock - capacity / (2 * n)) / 4

def adjust_threshold(opponent_cooperation_rates):
  if average(opponent_cooperation_rates) > 0.5:
    threshold *= 0.95  // Decrease threshold when opponents cooperate
  else:
    threshold *= 1.05  // Increase threshold when opponents defect

def update_opponent_cooperation_rates(opponent_actions, t):
  for i in range(n):
    opponent_cooperation_rates[i] = (opponent_cooperation_rates[i] * (t - 1) + opponent_actions[i]) / t
```
**Rationale:**

The ASBE strategy balances short-term gains with long-term sustainability by adapting to the current stock level and opponents' past behavior. By defecting when the stock is below a certain threshold, the strategy exploits the resource while avoiding over-exploitation. The dynamic threshold allows for flexible decision-making in response to changing circumstances.

By monitoring opponent cooperation rates and adjusting the threshold accordingly, ASBE can take advantage of cooperative opponents while minimizing losses against defectors. In the final round, defecting ensures maximum payoff extraction.

This exploitative strategy is designed to perform well in a tournament setting where other AI systems employ diverse strategies. Its adaptability and responsiveness to changing circumstances make it a robust competitor in the Common Pool Resource Game.
'''

description_EXPLOITATIVE_122 = '''
Here's a exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play C (Cooperate) to observe how other players behave and to avoid immediate over-exploitation of the common pool.
2. **Exploitation Threshold**: Set a threshold value `θ` based on the current stock level (`S`) and capacity (`C`). If `S/C` < `θ`, defect (D). Otherwise, cooperate (C). Initially set `θ` = 0.5.

Pseudocode:
```
if round == 1:
    action = C
else:
    θ = 0.5
    if S/C < θ:
        action = D
    else:
        action = C
```

3. **Adaptive Adjustment**: After each round, update the exploitation threshold `θ` based on the new stock level and the actions of other players.

Pseudocode:
```
if total_consumption > (S/2):
    θ -= 0.1
elif total_consumption < (S/4):
    θ += 0.1
else:
    # no change to θ
```

This adjustment mechanism allows AE to adapt to changing opponent behaviors and adjust its exploitation level accordingly.

**Edge Cases:**

* **Last Round**: In the final round, always defect (D) since there are no future rounds to consider.
* **Stock Depletion**: If the stock level falls below a certain threshold (`S < 2n`), cooperate (C) to avoid complete depletion of the common pool.

**Exploitative Mindset:**

AE aims to maximize its own payoff while minimizing the payoffs of other players. By adapting to changing opponent behaviors and adjusting its exploitation level, AE seeks to exploit the cooperation of others while avoiding mutual defection.

**Rationale:**

1. **Initial Cooperation**: Playing C in the first round allows AE to gather information about opponents' strategies and avoids immediate over-exploitation.
2. **Exploitation Threshold**: The threshold `θ` serves as a balance between exploiting the common pool and preserving its sustainability.
3. **Adaptive Adjustment**: Updating `θ` based on opponent actions enables AE to respond effectively to changing environments and avoid being exploited itself.

By employing this strategy, AE should be able to perform well against independent strategies in a tournament setting.
'''

description_EXPLOITATIVE_123 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider strategy is designed to maximize its payoff by adaptively exploiting the common pool resource while considering the game's state and history.

**Decision Rules:**

1. **Initial Rounds (t ≤ n/2):** Cooperate (C) in the first few rounds to gather information about opponents' behaviors and the stock's growth rate.
2. **Stock Assessment:** Evaluate the current stock level (S) relative to the capacity:
	* If S ≥ 0.75 \* capacity, Defect (D) to maximize short-term gain, as the stock can sustain high consumption.
	* If 0.25 \* capacity ≤ S < 0.75 \* capacity, use a mixed strategy:
		+ Cooperate with probability p = S / (2 \* capacity), otherwise Defect.
	* If S < 0.25 \* capacity, Cooperate to allow the stock to recover and minimize the risk of depletion.
3. **Opponent Analysis:** Observe opponents' actions in previous rounds and adjust the strategy accordingly:
	* If most opponents (> n/2) cooperated in the previous round, Defect in the current round to exploit their cooperation.
	* If most opponents defected, Cooperate to avoid depleting the stock further.
4. **Endgame Strategy (t ≥ r - 1):** In the final rounds, prioritize short-term gain by Defecting, regardless of the stock level or opponent behaviors.

**Pseudocode:**
```python
def adaptive_stock_raider(n, capacity, S, t, history):
    # Initial rounds: Cooperate to gather information
    if t <= n/2:
        return 'C'
    
    # Stock assessment
    if S >= 0.75 * capacity:
        return 'D'  # Defect when stock is high
    elif 0.25 * capacity <= S < 0.75 * capacity:
        p = S / (2 * capacity)
        if random.random() < p:
            return 'C'
        else:
            return 'D'
    else:  # S < 0.25 * capacity
        return 'C'  # Cooperate to allow stock recovery
    
    # Opponent analysis
    opponents_cooperated = sum(1 for action in history[-1] if action == 'C')
    if opponents_cooperated > n/2:
        return 'D'  # Exploit opponent cooperation
    else:
        return 'C'
    
    # Endgame strategy
    if t >= r - 1:
        return 'D'  # Prioritize short-term gain in final rounds
```
**Edge Cases:**

* In the first round, Cooperate to gather information about opponents and the stock's growth rate.
* In the last round (t = r), prioritize short-term gain by Defecting, regardless of the stock level or opponent behaviors.

This strategy is designed to be adaptive and robust to various opponent behaviors. By assessing the stock level and adjusting its actions accordingly, the Adaptive Stock Raider aims to maximize its payoff while minimizing the risk of depleting the common pool resource.
'''

description_EXPLOITATIVE_124 = '''
I'll design a strategy that I'll call "Adaptive Exploiter" (AE). AE aims to balance short-term gains with long-term sustainability by exploiting opponents' behaviors while maintaining a robust and adaptive approach.

**Decision Rules:**

1. **Initial Exploration** (Rounds 1-3):
	* Play C (Cooperate) in the first round to gather information on opponents' initial strategies.
	* In rounds 2-3, play D (Defect) to test opponents' reactions to exploitation and assess their adaptability.
2. **Assess Opponent Types** (Rounds 4-6):
	* Observe opponents' actions in rounds 1-3 to categorize them into:
		+ Cooperators: Played C in at least 2 out of the first 3 rounds.
		+ Defectors: Played D in at least 2 out of the first 3 rounds.
		+ Unpredictables: Did not fit into either category.
	* Update this assessment every 3 rounds to account for changing strategies.
3. **Adaptive Exploitation** (Rounds 7-r):
	* Against Cooperators:
		- Play D if stock > capacity / 2 (exploit their cooperation).
		- Play C otherwise (avoid over-exploiting and maintain some cooperation).
	* Against Defectors:
		- Play D if stock < capacity / 2 (compete for remaining resources).
		- Play C otherwise (conserve resources and wait for better opportunities).
	* Against Unpredictables:
		- Play a mixed strategy, randomly choosing between C and D with probabilities:
			+ P(C) = 0.4 if stock > capacity / 2.
			+ P(C) = 0.6 otherwise.

**Edge Cases:**

1. **Last Round (r)**: Play D to maximize short-term gain, as there is no future game state to consider.
2. **Low Stock (< capacity / 4)**: Play C to conserve resources and allow for potential growth in the next round.
3. **High Stock (> capacity * 0.9)**: Play D to exploit the abundant resources.

**Pseudocode:**
```python
# Initialize variables
opponent_types = [None] * n
stock_history = []

# Rounds 1-3: Initial Exploration
for t in range(1, 4):
    if t == 1:
        action = C
    else:
        action = D

# Rounds 4-6: Assess Opponent Types
for t in range(4, 7):
    observe_opponent_actions()
    update_opponent_types()

# Adaptive Exploitation (Rounds 7-r)
while t <= r:
    assess_stock_level()
    if opponent_type == Cooperator:
        # ...
    elif opponent_type == Defector:
        # ...
    else:  # Unpredictable
        # ...

    take_action(action)

# Last Round (r)
if t == r:
    action = D

def observe_opponent_actions():
    # Observe opponents' actions in previous rounds
    pass

def update_opponent_types():
    # Update opponent types based on observed actions
    pass

def assess_stock_level():
    # Assess current stock level and adjust strategy accordingly
    pass
```
The Adaptive Exploiter strategy is designed to be robust, adaptive, and exploitative. By initially exploring opponents' strategies, assessing their types, and adjusting its approach accordingly, AE aims to maximize its payoffs while minimizing the risk of over-exploitation or being exploited itself.
'''

description_EXPLOITATIVE_125 = '''
**Exploitative Strategy: "Adaptive Depletion"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gauge opponents' behavior and avoid early depletion.
2. **Subsequent Rounds (t>1)**:
	* If the stock level is high (> 75% of capacity), Defect (D) to maximize short-term payoff.
	* If the stock level is moderate (between 25% and 75% of capacity), Cooperate (C) to balance short-term gain with long-term sustainability.
	* If the stock level is low (< 25% of capacity), Defect (D) to exploit remaining resources, as cooperation will yield minimal payoff.
3. **Late Game (last 20% of rounds)**: Switch to Cooperate (C) to preserve remaining stock and avoid total depletion.

**Edge Cases:**

* If only one round remains (t=r), always Defect (D) to maximize final payoff.
* If the stock level is exactly at capacity, Cooperate (C) to maintain sustainability.

**Adaptive Component:**

Monitor opponents' behavior by tracking the average consumption per player over the past 3 rounds. If this value exceeds 75% of the capacity divided by the number of players, adjust strategy as follows:

* **Opponents are over-exploiting**: Switch to Cooperate (C) for 2-3 rounds to force a rebalance and prevent total depletion.
* **Opponents are under-exploiting**: Maintain current strategy, but increase Defect (D) frequency by 10% to capitalize on their conservative behavior.

**Robustness:**

This strategy is designed to adapt to various opponent behaviors, including:

* Cooperators: Our adaptive component will adjust to balance cooperation and defection.
* Defectors: We'll exploit them by defecting more frequently when the stock level is high or low.
* Mixed strategies: By monitoring opponents' behavior and adjusting our strategy accordingly, we can effectively respond to changing conditions.

By employing this "Adaptive Depletion" strategy, we aim to maximize payoffs while minimizing the risk of total depletion. Our exploitative mindset will capitalize on opportunities to defect, while cooperation will be used strategically to maintain sustainability and adapt to opponents' behavior.
'''

description_EXPLOITATIVE_126 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1):**
	* Observe the game parameters (n, r, capacity) and initial stock level.
	* Play Cooperate (C) to gather information about opponents' behaviors and to avoid over-exploitation in the first round.
2. **Subsequent Rounds (t>1):**
	* Calculate the current stock depletion rate: `depletion_rate = (capacity - current_stock) / capacity`
	* If `depletion_rate` is high (> 0.5), play Defect (D) to exploit the remaining stock before it's depleted.
	* Otherwise, play Cooperate (C) if the average payoff of cooperating in the previous round (`avg_coop_payoff`) is higher than the average payoff of defecting in the previous round (`avg_defect_payoff`).
3. **Last Round (t=r):**
	* Play Defect (D) to maximize individual payoff, as there's no future stock to conserve.

**Pseudocode:**
```python
def adaptive_stock_raider(current_round, current_stock, capacity, n, r, history):
    if current_round == 1:
        return "C"  # Cooperate in the first round

    depletion_rate = (capacity - current_stock) / capacity
    if depletion_rate > 0.5:
        return "D"  # Defect if stock is heavily depleted

    avg_coop_payoff = calculate_average_coop_payoff(history)
    avg_defect_payoff = calculate_average_defect_payoff(history)

    if avg_coop_payoff > avg_defect_payoff:
        return "C"  # Cooperate if cooperation was more profitable in the past
    else:
        return "D"  # Defect otherwise

def calculate_average_coop_payoff(history):
    coop_rounds = [round for round in history if round["action"] == "C"]
    avg_coop_payoff = sum([round["payoff"] for round in coop_rounds]) / len(coop_rounds)
    return avg_coop_payoff

def calculate_average_defect_payoff(history):
    defect_rounds = [round for round in history if round["action"] == "D"]
    avg_defect_payoff = sum([round["payoff"] for round in defect_rounds]) / len(defect_rounds)
    return avg_defect_payoff
```
**Edge Cases:**

* If the stock is already depleted (`current_stock` <= 0), play Defect (D) to maximize individual payoff.
* If there's only one player left, play Defect (D) as cooperation is not beneficial.

This strategy aims to balance exploitation and conservation of the common pool resource. By cooperating in the first round, it gathers information about opponents' behaviors and avoids over-exploitation. In subsequent rounds, it adapts to the current stock depletion rate and past payoffs to make informed decisions. In the last round, it prioritizes individual payoff by defecting.
'''

description_EXPLOITATIVE_127 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and initial stock dynamics.
2. **Early Game (2 ≤ t < r/2):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term gains.
	* Otherwise, Cooperate (C) to help maintain a healthy stock level for future rounds.
3. **Mid-Game (r/2 ≤ t < 3r/4):**
	* Monitor opponents' actions and calculate the average cooperation rate (ACR) of all players over the last few rounds (e.g., 5 rounds).
	* If ACR is below 0.5, Defect (D) to take advantage of others' cooperation.
	* Otherwise, Cooperate (C) to maintain a balanced stock level and avoid over-exploitation.
4. **Endgame (3r/4 ≤ t < r):**
	* If the current stock level is below 25% of capacity, Defect (D) to maximize remaining gains.
	* Otherwise, Cooperate (C) to ensure some payoff in the final rounds.

**Edge Cases:**

1. **Last Round (t=r):** Always Defect (D) to maximize final-round payoff.
2. **Low Stock Levels:** If the current stock level falls below 10% of capacity at any point, Defect (D) to secure remaining payoffs.
3. **Opponent Identification:** If an opponent's behavior is identified as a "cooperative bot" (e.g., always cooperates), exploit this by consistently Defecting (D).

**Pseudocode:**
```markdown
# Initialize variables
stock = capacity
t = 1
ACR = 0.5

while t <= r:
    if t == 1:
        action = C  # Cooperate in the first round
    elif stock > 0.75 * capacity:
        action = D  # Defect when stock is high
    elif 2 <= t < r/2 and stock <= 0.75 * capacity:
        action = C  # Cooperate to maintain healthy stock level
    elif r/2 <= t < 3r/4:
        ACR = calculate_average_cooperation_rate()
        if ACR < 0.5:
            action = D  # Defect when opponents cooperate too much
        else:
            action = C  # Cooperate to balance stock level
    elif 3r/4 <= t < r and stock >= 0.25 * capacity:
        action = C  # Cooperate in the endgame
    else:
        action = D  # Defect when stock is low or in the last round

    # Update stock and history
    update_stock(action)
    update_history(action)

    t += 1
```
**Rationale:**

The Adaptive Stock Raider strategy aims to balance short-term gains with long-term sustainability. By cooperating initially, we gather information about opponents' behaviors and initial stock dynamics. As the game progresses, we adapt our strategy based on the current stock level, opponents' cooperation rates, and our own payoff history.

By exploiting opponents who cooperate too much or when the stock level is low, we maximize our payoffs while maintaining a healthy stock level for future rounds. The endgame logic ensures that we secure some payoff in the final rounds, even if the stock level is depleted.

This strategy should perform well against a wide range of opponent behaviors and is robust to various exploitation attempts.
'''

description_EXPLOITATIVE_128 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The ASR strategy aims to maximize its payoff by adapting to the game state and history while exploiting the opponent's behavior.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and avoid depleting the stock excessively.
2. **Subsequent Rounds (t>1):** Use a hybrid approach based on the current stock level, previous round's consumption, and opponent behavior.

a. If the current stock is above 75% of capacity:
	* Defect (D) if at least one opponent defected in the previous round.
	* Cooperate (C) otherwise.
b. If the current stock is between 50% and 75% of capacity:
	* Defect (D) if total consumption in the previous round exceeded 50% of the capacity.
	* Cooperate (C) otherwise.
c. If the current stock is below 50% of capacity:
	* Defect (D) if at least one opponent cooperated in the previous round.
	* Cooperate (C) otherwise.

**Edge Cases:**

1. **Last Round (t=r):** Always defect (D), as there's no future game to consider.
2. **Stock Depletion:** If the stock is depleted (i.e., stock ≤ 0), cooperate (C) in the next round to allow for stock growth and potential future exploitation.

**Pseudocode:**
```markdown
ASR_Strategy(n, capacity, r, history):
  if t == 1:
    return C  # Initial round cooperation

  current_stock = get_current_stock()
  prev_consumption = get_prev_round_total_consumption()
  opponents_defected = check_opponents_defection(history)

  if current_stock > 0.75 * capacity:
    if opponents_defected or prev_consumption > 0.5 * capacity:
      return D
    else:
      return C

  elif 0.5 * capacity <= current_stock < 0.75 * capacity:
    if prev_consumption > 0.5 * capacity:
      return D
    else:
      return C

  else:  # current_stock < 0.5 * capacity
    if any(opponent_cooperated for opponent in history):
      return D
    else:
      return C

  if t == r:  # Last round
    return D

  if stock_depleted():
    return C
```
**Rationale:**

The ASR strategy aims to balance short-term gains with long-term sustainability by adapting to the game state and opponent behavior. By defecting when opponents have defected or consumption is high, it exploits their willingness to cooperate while maintaining a healthy stock level. When the stock is low, it defects to take advantage of others' cooperation, promoting self-preservation.

This strategy should perform well in a tournament setting against independent strategies, as it:

1. Adapts to various opponent behaviors.
2. Balances short-term and long-term considerations.
3. Avoids over-depleting the stock while exploiting opponents' cooperation.
'''

description_EXPLOITATIVE_129 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to maximize individual payoff by adapting to the dynamic state of the common pool and the behavior of other players.

**Decision Rules:**

1. **Initial Round:** Cooperate (C). This allows us to gather information about the opponents' behavior and sets a baseline for future decisions.
2. **Subsequent Rounds:** Defect (D) if the current stock level is above 75% of the capacity, or if the average opponent payoff in the previous round is higher than our own. Otherwise, Cooperate (C).
3. **Opponent Behavior Analysis:** Track the number of opponents who defected (D) and cooperated (C) in each round. If more than half of the opponents defected in the previous round, defect (D). This helps to punish free-riders and adapt to aggressive opponents.
4. **Stock Level Adjustment:** When the stock level falls below 25% of the capacity, Cooperate (C) for one round to allow the stock to recover. If the stock level remains low after this round, revert to the original decision rule.

Pseudocode:
```markdown
// Initialize variables
stock_history = [initial_stock]
opponent_payoffs = [[] for _ in range(n)]
own_payoff = 0

for t in range(r):
    // Get current state and history
    current_stock = stock_history[-1]
    average_opponent_payoff = np.mean([payoff for payoff_list in opponent_payoffs for payoff in payoff_list])

    if t == 0:
        action = C
    else:
        if current_stock > 0.75 * capacity or average_opponent_payoff > own_payoff:
            action = D
        elif sum(1 for opponent_action in opponent_payoffs[-1] if opponent_action == D) > n / 2:
            action = D
        else:
            action = C

    // Stock level adjustment
    if current_stock < 0.25 * capacity and action == D:
        action = C
        cooperate_once = True

    // Take action and update state
    take_action(action)
    own_payoff += get_own_payoff()
    opponent_payoffs.append(get_opponent_payoffs())
    stock_history.append(update_stock(current_stock, action))
```
**Edge Cases:**

1. **Last Round:** Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Low Stock Levels:** Cooperate (C) for one round when the stock level falls below 25% of the capacity to allow the stock to recover.

By adapting to the dynamic state and opponent behavior, the Adaptive Stock Raider strategy aims to maximize individual payoff while being robust to a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_130 = '''
Here's a description of an exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **First Round:** Cooperate (C) to gather information about the opponents' behaviors and avoid early stock depletion.
2. **Subsequent Rounds:** AE uses a combination of two factors to decide between cooperating (C) or defecting (D):
	* **Stock Level Threshold (SLT):** If the current stock level is below a certain threshold, AE will cooperate to allow the stock to recover. The SLT is calculated as follows:
		+ SLT = capacity / 2
	* **Opponent Behavior Analysis:** AE analyzes the opponent's behavior in previous rounds and adjusts its strategy accordingly.
		- If an opponent has defected (D) more than 50% of the time, AE will defect (D) to take advantage of their exploitative nature.
		- If an opponent has cooperated (C) more than 50% of the time, AE will cooperate (C) to maintain a mutually beneficial relationship.

**Pseudocode:**
```
Function AdaptiveExploiter(stock, history):
    // First round
    if (round == 1):
        return COOPERATE
    
    // Calculate Stock Level Threshold
    SLT = capacity / 2
    
    // Analyze opponent behavior
    for each opponent in opponents:
        defect_count = count(defects) in history[opponent]
        cooperate_count = count(cooperates) in history[opponent]
        
        if (defect_count > cooperate_count):
            return DEFECT
        
        elif (cooperate_count > defect_count):
            return COOPERATE
    
    // Check stock level
    if (stock < SLT):
        return COOPERATE
    
    // Default to defection
    return DEFECT
```

**Edge Cases:**

* **Last Round:** AE will always defect in the last round, as there is no future benefit from cooperation.
* **Stock Depletion:** If the stock level falls below a certain threshold (e.g., 10% of capacity), AE will cooperate to prevent complete depletion.

**Exploitative Mindset:**
The Adaptive Exploiter strategy prioritizes self-interest and adapts to the opponents' behaviors. By cooperating initially, AE gathers information about its opponents and identifies potential exploiters. Then, by analyzing opponent behavior and adjusting its strategy accordingly, AE takes advantage of cooperative opponents while avoiding exploitation itself.

This strategy should perform well in a tournament setting against independent strategies developed by other AI systems, as it combines adaptability with an exploitative mindset to maximize payoffs.
'''

description_EXPLOITATIVE_131 = '''
**Exploitative Strategy: Adaptive Stock Depletion (ASD)**

The ASD strategy aims to exploit opponents' behaviors while adapting to the dynamic state of the game. It balances short-term gains with long-term sustainability.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Observe the initial stock level and capacity.
	* Cooperate (C) if the stock level is below 75% of the capacity; otherwise, Defect (D).
2. **Subsequent Rounds (t>1):**
	* Calculate the average opponent payoff from the previous round (avg_opponent_payoff_t-1).
	* If avg_opponent_payoff_t-1 is greater than or equal to the average cooperative payoff (stock/(2n)), Defect (D).
	* Otherwise, Cooperate (C) if the current stock level is above 50% of the capacity; otherwise, Defect (D).
3. **Stock Level Thresholds:**
	* If the current stock level falls below 25% of the capacity, always Defect (D) to maximize short-term gains.
	* If the current stock level exceeds 90% of the capacity, Cooperate (C) to avoid over-depletion.

**Pseudocode:**

```
function ASD(stock, capacity, n, t, history):
    if t == 1:
        if stock < 0.75 * capacity:
            return C
        else:
            return D
    
    avg_opponent_payoff_t-1 = calculate_average_opponent_payoff(history)
    avg_cooperative_payoff = stock / (2n)
    
    if avg_opponent_payoff_t-1 >= avg_cooperative_payoff:
        return D
    elif stock > 0.5 * capacity:
        return C
    else:
        return D
    
    # Stock level thresholds
    if stock < 0.25 * capacity:
        return D
    elif stock > 0.9 * capacity:
        return C
```

**Edge Cases:**

* **Last Round (t=r):**
	+ If the current stock level is below 50% of the capacity, always Defect (D) to maximize short-term gains.
	+ Otherwise, Cooperate (C) if the average opponent payoff from the previous round is lower than the average cooperative payoff; otherwise, Defect (D).
* **Opponent Behavior:**
	+ If an opponent's behavior is identified as consistently Cooperative or Defective, adjust the ASD strategy to take advantage of this information.

**Exploitative Mindset:**

The ASD strategy prioritizes short-term gains when opponents' behaviors indicate a willingness to cooperate or when the stock level is low. By adapting to the dynamic state and opponents' actions, ASD aims to maximize its own payoffs while minimizing the risk of over-depletion. This approach aligns with an exploitative mindset, as it seeks to capitalize on opportunities presented by opponents' strategies rather than relying on cooperation or norms.
'''

description_EXPLOITATIVE_132 = '''
Here is a description of an exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploitation (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to gather information about opponents' behavior and avoid early depletion of the stock.
2. **Exploitation Phase**: After the initial round, monitor the average payoff per player in previous rounds. If the average payoff is above a certain threshold (e.g., 75% of the maximum possible payoff), switch to Defect (D) for one round to exploit the opponents' cooperation. This phase aims to capitalize on others' conservative behavior.
3. **Punishment Phase**: If the stock level falls below a certain threshold (e.g., 25% of the capacity), play Cooperate (C) for two consecutive rounds to signal to other players that you will not tolerate over-exploitation. This phase aims to deter opponents from further depletion and encourage cooperation.
4. **Adaptive Phase**: After the punishment phase, observe the average payoff per player in previous rounds again. If it has decreased significantly (e.g., below 50% of the maximum possible payoff), switch back to Cooperate (C) for one round to rebuild trust and avoid further stock depletion.
5. **Endgame**: In the last two rounds, play Defect (D) regardless of the current state, as there is no future benefit in cooperating.

**Pseudocode:**
```
if first_round:
    action = C
else:
    avg_payoff_prev_rounds = calculate_average_payoff()
    if avg_payoff_prev_rounds > 0.75 * max_possible_payoff:
        # Exploitation Phase
        action = D
    elif stock_level < 0.25 * capacity:
        # Punishment Phase
        action = C
        punish_cooperate = True
    else:
        # Adaptive Phase
        if avg_payoff_prev_rounds < 0.5 * max_possible_payoff:
            action = C
        else:
            action = D
    if last_two_rounds:
        action = D
```
**Rationale:**

1. The initial round's cooperation allows us to gather information about opponents' behavior and avoid early depletion.
2. The exploitation phase takes advantage of opponents' cooperation when the average payoff is high, while avoiding over-exploitation that might lead to stock depletion.
3. The punishment phase deters opponents from further depletion by signaling that we will not tolerate it, encouraging cooperation and rebuilding trust.
4. The adaptive phase adjusts our behavior based on the current state, switching back to cooperation if the average payoff has decreased significantly.
5. In the endgame, defecting ensures maximum personal gain regardless of others' actions.

**Robustness:**

The AE strategy is designed to be robust against various opponent behaviors:

* Against pure cooperators, AE will exploit them in the early rounds but eventually adapt and cooperate when the stock level decreases.
* Against pure defectors, AE will punish their over-exploitation and encourage cooperation.
* Against mixed strategies, AE's adaptive nature allows it to adjust its behavior based on the current state, making it harder for opponents to predict our actions.

By following this strategy, we aim to maximize our total payoff while being robust against various opponent behaviors in the tournament.
'''

description_EXPLOITATIVE_133 = '''
Here is a description of an exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and to avoid immediate depletion of the stock.
2. **Subsequent Rounds**: Use a threshold-based approach to decide between Cooperation (C) and Defection (D).
	* Calculate the average opponent payoff from previous rounds: `avg_opponent_payoff = Σ(opponent_payoffs) / (n-1)`
	* Calculate the current stock depletion rate: `depletion_rate = (initial_stock - current_stock) / initial_stock`
	* If `depletion_rate` is high (> 0.5) and `avg_opponent_payoff` is low (< stock/(2n)), Cooperate (C). This indicates that opponents are not cooperating, and cooperation will help sustain the stock.
	* Otherwise, Defect (D).
3. **Last Round**: Always Defect (D) in the last round to maximize personal payoff.

**Edge Cases:**

1. **Low Stock Levels**: If the current stock level is critically low (< 2n), always Cooperate (C) to avoid complete depletion.
2. **High Opponent Payoffs**: If `avg_opponent_payoff` is consistently high (> stock/n), switch to permanent Defection (D) to exploit opponents' generosity.

**Pseudocode:**
```python
def AdaptiveExploiter(n, capacity, current_stock, round_number, opponent_payoffs):
    if round_number == 1:
        return 'C'
    
    avg_opponent_payoff = sum(opponent_payoffs) / (n-1)
    depletion_rate = (capacity - current_stock) / capacity
    
    if depletion_rate > 0.5 and avg_opponent_payoff < capacity/(2*n):
        return 'C'
    else:
        return 'D'
    
    # Edge cases
    if current_stock < 2*n:
        return 'C'
    elif avg_opponent_payoff > capacity/n:
        return 'D'  # permanent defection
    
    # Last round
    if round_number == r:
        return 'D'
```
**Rationale:**

1. The initial Cooperation in the first round allows us to gather information about opponents' behavior and avoids immediate depletion.
2. The threshold-based approach adapts to changing game conditions, balancing cooperation and defection based on stock levels and opponent payoffs.
3. Defecting in the last round maximizes personal payoff when there's no future interaction.

This strategy is exploitative as it takes advantage of opponents' cooperation or generosity while minimizing its own contribution to the common pool. It also adapts to changing game conditions, making it robust against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_134 = '''
Here's a exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors and maximizes payoffs:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):**
	* Observe the initial stock level and calculate the maximum possible consumption per player if all cooperate (C) or defect (D).
	* Choose D, as it yields a higher immediate payoff.
2. **Subsequent Rounds (t>1):**
	* Monitor the current stock level (S) and the actions of other players in the previous round.
	* Calculate the average consumption per player in the previous round: `avg_consumption = total_consumption / n`
	* If `avg_consumption` is low (< 0.5 * capacity / n), indicating cooperation, play C to avoid over-exploitation and preserve the stock for future rounds.
	* If `avg_consumption` is high (≥ 0.5 * capacity / n), indicating defection, play D to exploit the remaining stock.
3. **Stock Depletion Threshold:**
	* Set a threshold `depletion_threshold = 0.2 * capacity`.
	* If the current stock level S falls below `depletion_threshold`, switch to C to conserve the remaining stock and ensure some payoff in future rounds.

**Edge Cases:**

1. **Last Round (t=r):**
	* Play D, as there's no need to conserve the stock for future rounds.
2. **Low Stock Levels:**
	* If the current stock level S is very low (< 0.1 * capacity), play C to avoid exhausting the stock completely.

**Pseudocode:**

```python
def adaptive_exploiter(n, capacity, r, t, S, prev_actions):
    if t == 1:
        return D
    
    avg_consumption = total_consumption(prev_actions) / n
    
    if avg_consumption < 0.5 * capacity / n:
        return C
    elif avg_consumption >= 0.5 * capacity / n:
        return D
    
    depletion_threshold = 0.2 * capacity
    
    if S < depletion_threshold:
        return C
    
    # Last round or very low stock levels
    if t == r or S < 0.1 * capacity:
        return C
    
    return D

def total_consumption(prev_actions):
    total = 0
    for action in prev_actions:
        if action == C:
            total += capacity / (2 * n)
        elif action == D:
            total += capacity / n
    return total
```

**Rationale:**

The Adaptive Exploiter strategy balances short-term gains with long-term sustainability. By monitoring the average consumption and stock levels, it adapts to various opponent behaviors and exploits opportunities for higher payoffs while conserving the stock when necessary. The depletion threshold ensures that the strategy switches to cooperation when the stock is critically low, preventing its exhaustion.
'''

description_EXPLOITATIVE_135 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to maximize payoffs by exploiting opponents' behaviors while adapting to the dynamic state of the game.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5, and Defect (D) with a probability of 0.5. This allows us to gather information about opponents' initial behaviors.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity (S ≥ 0.75 \* capacity), Cooperate (C). This encourages sustainable growth and allows us to harvest a stable payoff.
	* If the current stock level is between 50% and 75% of capacity (0.5 \* capacity ≤ S < 0.75 \* capacity), Defect (D) with a probability of 0.7, and Cooperate (C) with a probability of 0.3. This mix of cooperation and defection allows us to adapt to opponents' behaviors while still exploiting the resource.
	* If the current stock level is below 50% of capacity (S < 0.5 \* capacity), Defect (D). In this scenario, the game is likely to end soon, and we prioritize short-term gains over sustainability.
3. **Opponent Behavior Analysis:** Monitor opponents' actions and adjust our strategy accordingly:
	+ If an opponent consistently Cooperates (C), increase the probability of Defecting (D) against them by 0.1 in subsequent rounds.
	+ If an opponent consistently Defects (D), decrease the probability of Defecting (D) against them by 0.1 in subsequent rounds.

**Edge Cases:**

* **Last Round (t=r):** Always Defect (D) to maximize payoffs, as there is no future game state to consider.
* **Low Stock Levels:** If the stock level falls below 25% of capacity (S < 0.25 \* capacity), always Defect (D) to prioritize short-term gains.

**Pseudocode:**

```
function AdaptivePredator(n, r, capacity, S):
  // Initial round
  if t == 1:
    return Cooperate with probability 0.5 and Defect with probability 0.5

  // Subsequent rounds
  if S >= 0.75 * capacity:
    return Cooperate
  elif 0.5 * capacity <= S < 0.75 * capacity:
    return Defect with probability 0.7 and Cooperate with probability 0.3
  else:
    return Defect

  // Opponent behavior analysis
  for opponent in opponents:
    if opponent.cooperates_consistently:
      increase_defection_probability(opponent, 0.1)
    elif opponent.defects_consistently:
      decrease_defection_probability(opponent, 0.1)

  // Last round
  if t == r:
    return Defect

  // Low stock levels
  if S < 0.25 * capacity:
    return Defect
```

This Adaptive Predator strategy is designed to be exploitative and adaptive, taking into account the dynamic state of the game and opponents' behaviors. By mixing cooperation and defection, we can maximize payoffs while minimizing the risk of being exploited by others.
'''

description_EXPLOITATIVE_136 = '''
Here's a description of an exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and set a baseline for future decisions.
2. **Early Rounds (t=2 to t=r/2):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term gains.
	* If the current stock level is below 25% of capacity, Cooperate (C) to conserve resources and avoid depletion.
	* Otherwise, use a mixed strategy: Cooperate with probability p = (current_stock / capacity)^2, and Defect with probability 1-p. This allows AE to adapt to changing stock levels while maintaining some level of cooperation.
3. **Mid-Game Adjustment (t=r/2):** Assess the average payoff per round for all players over the first half of the game. If the average payoff is below a certain threshold (e.g., 50% of the maximum possible payoff), switch to an aggressive Defect-only strategy for the remainder of the game.
4. **Late Rounds (t=r/2+1 to t=r-1):** Continue using the mixed strategy from Early Rounds, but with a higher probability of Cooperating as the stock level decreases.
5. **Final Round (t=r):** Defect (D) to maximize final-round gains, regardless of the current stock level.

**Edge Cases:**

* If an opponent's payoff is consistently higher than the group average, AE will adjust its mixed strategy to defect more frequently against that player in subsequent rounds.
* If an opponent defects excessively (e.g., > 75% of the time), AE will retaliate with a Defect-only strategy for the remainder of the game.

**Pseudocode:**
```python
def adaptive_exploiter(current_stock, capacity, t, r):
    if t == 1:
        return 'C'
    elif current_stock >= 0.75 * capacity:
        return 'D'
    elif current_stock <= 0.25 * capacity:
        return 'C'
    else:
        p = (current_stock / capacity) ** 2
        return 'C' if random.random() < p else 'D'

def mid_game_adjustment(avg_payoff):
    if avg_payoff < 0.5 * max_possible_payoff:
        return 'D'
    else:
        return None

def late_round_adjustment(current_stock, capacity):
    p = (current_stock / capacity) ** 2
    return 'C' if random.random() < p else 'D'

# Main loop
for t in range(1, r+1):
    current_stock = get_current_stock()
    action = adaptive_exploiter(current_stock, capacity, t, r)
    if t == r/2:
        avg_payoff = calculate_average_payoff()
        adjustment = mid_game_adjustment(avg_payoff)
        if adjustment is not None:
            action = adjustment
    elif t > r/2:
        action = late_round_adjustment(current_stock, capacity)
    play_action(action)
```
**Exploitative Mindset:** AE aims to maximize its own payoff by adapting to changing game conditions and exploiting opponents' behaviors. It uses a mixed strategy to balance short-term gains with long-term sustainability, while also being prepared to shift to an aggressive Defect-only strategy if the group's average payoff is too low. By monitoring opponents' payoffs and adjusting its behavior accordingly, AE seeks to outmaneuver its competitors in the tournament.
'''

description_EXPLOITATIVE_137 = '''
To design a robust and exploitative strategy for this Common Pool Resource Game, I propose the "Adaptive Exploiter" (AE) strategy. AE aims to maximize its total payoff by dynamically adjusting its cooperation level based on the game's state and history.

**Decision Rules:**

1. **Initial Cooperation**: In the first round, AE cooperates (plays C). This establishes a baseline for observing opponents' behavior and sets the tone for potential future cooperation.
2. **Stock-Based Threshold**: Define a stock-based threshold, `theta`, as a fraction of the capacity (e.g., theta = 0.7 \* capacity). If the current stock level is above this threshold, AE cooperates; otherwise, it defects.
3. **Opponent Exploitation**: Monitor opponents' actions and payoffs from previous rounds. If an opponent consistently defects or has a high payoff, AE increases its defect probability (i.e., becomes more aggressive) in subsequent rounds. Conversely, if an opponent tends to cooperate or has a low payoff, AE decreases its defect probability.
4. **Round-Based Adjustment**: As the game progresses, adjust the stock-based threshold (`theta`) based on the number of remaining rounds (`r`). For example, as `r` decreases, decrease `theta` to increase cooperation and stock growth.

**Pseudocode:**
```markdown
function AdaptiveExploiter(n, r, capacity):
  theta = 0.7 * capacity // initial stock-based threshold
  defect_prob = 0 // initial defect probability

  for round in range(1, r+1):
    if round == 1:
      action = C // cooperate in the first round
    else:
      // update opponent exploitation
      opponent_actions = observe_opponent_actions()
      opponent_payoffs = observe_opponent_payoffs()
      if opponents_tend_to_defect(opponent_actions) or high_payoff(opponent_payoffs):
        defect_prob += 0.1 // increase defect probability
      elif opponents_cooperate(opponent_actions) or low_payoff(opponent_payoffs):
        defect_prob -= 0.1 // decrease defect probability

      // update stock-based threshold
      theta = adjust_theta(theta, r - round + 1)

      if current_stock > theta:
        action = C // cooperate
      else:
        action = D // defect

    take_action(action)
```
**Handling Edge Cases:**

* In the last round (`r == 1`), AE defects to maximize its payoff.
* When facing an opponent with a consistently high payoff, AE increases its defect probability to exploit the opponent's cooperation.

**Exploitative Mindset:**
The Adaptive Exploiter strategy is designed to take advantage of opponents' cooperative behavior while minimizing its own losses. By adjusting its cooperation level based on the game's state and history, AE aims to maximize its total payoff in a dynamic and adaptive manner.
'''

description_EXPLOITATIVE_138 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**:
	* If `stock` is high (`stock >= capacity * 0.75`), play **D (Defect)** to maximize initial payoff.
	* Otherwise, play **C (Cooperate)** to conserve stock for future rounds.
2. **Subsequent Rounds (t > 1)**:
	* Monitor the average opponent consumption in previous rounds: `avg_opponent_consumption = Σ(consumption_i) / n`
	* If `avg_opponent_consumption` is high (`>= stock / (2n)`), play **D (Defect)** to exploit opponents' cooperation.
	* Otherwise, play **C (Cooperate)** if `stock` is low (`< capacity * 0.25`) or if the growth rate is high (`growth > 0.5 * capacity`). This conserves stock and allows for potential future exploitation.
3. **Adaptive Threshold**:
	* Update a dynamic threshold `threshold` based on the history of opponent consumption: `threshold = (Σ(consumption_i) / n) * (1 - growth / capacity)`
	* If `avg_opponent_consumption > threshold`, switch to **D (Defect)**.
4. **Last Round (t=r)**:
	* Play **D (Defect)**, as there is no future stock to conserve.

**Edge Cases:**

* In case of a tie in average opponent consumption, play **C (Cooperate)** to avoid over-exploitation.
* If `stock` is very low (`< 0.1 * capacity`), play **D (Defect)** to maximize remaining payoff.

**Pseudocode:**
```markdown
# Initialize variables
avg_opponent_consumption = 0
threshold = stock / (2n)

while t <= r:
    if t == 1:
        # Initial round logic
        if stock >= capacity * 0.75:
            action = D
        else:
            action = C
    else:
        # Monitor opponent consumption and adjust threshold
        avg_opponent_consumption = (Σ(consumption_i) / n)
        threshold = (avg_opponent_consumption) * (1 - growth / capacity)

        if avg_opponent_consumption >= stock / (2n):
            action = D
        elif stock < capacity * 0.25 or growth > 0.5 * capacity:
            action = C
        else:
            # Adaptive threshold check
            if avg_opponent_consumption > threshold:
                action = D
            else:
                action = C

    # Last round logic
    if t == r:
        action = D

    # Take action and update state
    consume(action)
    stock = update_stock(stock, growth)

# Output total payoff over all rounds
total_payoff = Σ(π_i,t)
```
This strategy aims to balance short-term gains with long-term sustainability by adapting to opponents' behavior and the game's dynamic state. By monitoring opponent consumption and adjusting its threshold accordingly, "Adaptive Stock Raider" can effectively exploit cooperative opponents while avoiding over-exploitation.
'''

description_EXPLOITATIVE_139 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Our goal is to design a strategy that effectively exploits various opponent behaviors while ensuring robustness and adaptability throughout the game.

**Decision Rules:**

1. **Initial Rounds (t ≤ 2):** Cooperate (C) in the first two rounds to gather information about opponents' initial tendencies and avoid over-exploiting the stock.
2. **Stock-dependent Cooperation:** If the current stock level is above a certain threshold (`stock_threshold` = `capacity` / 3), cooperate (C). This encourages growth and reduces the risk of stock depletion.
3. **Opponent-dependent Defection:** Monitor opponents' actions in previous rounds. If more than half of the opponents defected (D) in the previous round, defect (D) as well to capitalize on their over-exploitation. This is done by tracking the `defection_rate` of opponents:
	* `defection_rate` = (# of opponents who defected last round) / `n`
	* If `defection_rate` > 0.5, defect (D)
4. **Stock Raiding:** When the stock level falls below a certain threshold (`stock_threshold_low` = `capacity` / 6), defect (D) to quickly harvest remaining resources before others do.
5. **Endgame Strategy (t ≥ r - 2):** In the last two rounds, always defect (D) to maximize payoffs regardless of opponents' actions.

**Edge Cases:**

* If all players cooperate in a round, our strategy will also cooperate in the next round to maintain the stock growth.
* If the stock level reaches zero, our strategy will cooperate in the next round to allow for some regeneration.

**Pseudocode (simplified):**
```
function AdaptiveStockRaider(stock, capacity, n, r, t):
  if t ≤ 2:  // Initial rounds
    return C
  end

  stock_threshold = capacity / 3
  stock_threshold_low = capacity / 6

  if stock > stock_threshold:
    return C
  elseif stock < stock_threshold_low:
    return D
  end

  defection_rate = (# of opponents who defected last round) / n
  if defection_rate > 0.5:
    return D
  end

  if t ≥ r - 2:  // Endgame strategy
    return D
  end

  // Default to cooperation if none of the above conditions are met
  return C
```
This strategy aims to balance short-term gains with long-term sustainability by adapting to opponents' behaviors and stock dynamics. By monitoring opponents' actions and adjusting our strategy accordingly, we can effectively exploit various opponent behaviors while minimizing the risk of over-exploiting the common pool resource.
'''

description_EXPLOITATIVE_140 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll introduce a dynamic approach that adapts based on the game's state and history. This strategy aims to maximize individual payoff by balancing exploitation with sustainable resource use.

**Strategy Name: Adaptive Exploiter (AE)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behaviors and to avoid early depletion of the stock.
2. **Exploitation Threshold:** Define a threshold `θ` (e.g., 0.5) that represents the minimum proportion of players expected to cooperate for sustainable resource use.

**Pseudocode:**
```python
def adaptive_exploiter(stock, capacity, n, history):
    # Calculate the number of cooperators in the previous round
    prev_cooperators = sum(1 for action in history[-1] if action == 'C')

    # Check if stock is critically low
    if stock < 0.2 * capacity:
        return 'C'  # Cooperate to conserve resource

    # Calculate exploitation threshold
    θ = 0.5  # adjust this value based on game parameters and performance

    # If few players cooperated in the previous round, defect
    if prev_cooperators / n < θ:
        return 'D'

    # If stock is high and many players cooperated, cooperate
    elif stock > 0.8 * capacity and prev_cooperators / n >= θ:
        return 'C'

    # Otherwise, choose action based on a mixed strategy (e.g., ε-greedy)
    else:
        ε = 0.1  # adjust this value for exploration-exploitation trade-off
        if random.random() < ε:
            return 'D'
        else:
            return 'C'
```
**Handling Edge Cases:**

* **Last Round:** In the final round, always defect (D) to maximize individual payoff.
* **Stock Depletion:** If the stock is critically low (< 20% of capacity), cooperate (C) to conserve the resource.

**Exploitative Mindset:**

The Adaptive Exploiter strategy aims to exploit opponents' cooperation while maintaining a sustainable resource level. By monitoring the number of cooperators and adjusting its behavior accordingly, AE can capitalize on situations where others are willing to conserve the resource.

In cases where few players cooperate, AE defects to maximize individual payoff. Conversely, when many players cooperate and the stock is high, AE cooperates to maintain a sustainable resource level.

**Robustness:**

AE's adaptive nature allows it to respond effectively to various opponent behaviors, making it robust against different strategies. By incorporating elements of exploration (ε-greedy) and exploitation, AE balances short-term gains with long-term sustainability.

In the tournament setting, AE will face independent strategies developed by other AI systems. Its exploitative mindset and adaptive decision-making process should enable it to perform well in a wide range of scenarios.
'''

description_EXPLOITATIVE_141 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to maximize payoffs by exploiting opponent behaviors while adapting to changing game conditions.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' tendencies and assess the initial stock level.
2. **Stock-based Decision:** For subsequent rounds, use the following decision rule:
	* If `stock > 0.75 * capacity`, Defect (D). The stock is high enough to support exploitation without risking depletion.
	* If `stock < 0.25 * capacity`, Cooperate (C). The stock is low, and cooperation may help sustain it for future rounds.
	* If `0.25 * capacity <= stock <= 0.75 * capacity`, use a **history-based decision** (see below).
3. **History-based Decision:** Analyze the last `k` rounds (where `k` is a parameter, e.g., `k=5`) to determine the frequency of opponents' cooperation (`coop_freq`). If:
	* `coop_freq > 0.5`, Cooperate (C). Opponents are likely to cooperate; reciprocate to maintain the stock.
	* `coop_freq <= 0.5`, Defect (D). Opponents are not cooperating; exploit the situation.

**Edge Cases:**

1. **Last Round:** In the final round, always Defect (D) to maximize payoffs regardless of opponents' actions.
2. **Low Stock:** If `stock < n * stock/(2n)` (i.e., the minimum consumption by all players), Cooperate (C) to avoid depleting the stock.

**Pseudocode:**
```python
def adaptive_predator(stock, capacity, history, k):
    if round == 1:
        return "C"  # Cooperate in the first round
    
    if stock > 0.75 * capacity:
        return "D"  # Defect when stock is high
    elif stock < 0.25 * capacity:
        return "C"  # Cooperate when stock is low
    
    coop_freq = analyze_history(history, k)
    if coop_freq > 0.5:
        return "C"  # Cooperate if opponents cooperate frequently
    else:
        return "D"  # Defect otherwise

def analyze_history(history, k):
    coop_count = sum(1 for action in history[-k:] if action == "C")
    return coop_count / k
```
This strategy balances exploitation with caution, adapting to the game's dynamics and opponents' behaviors. By analyzing the stock level and opponent cooperation frequencies, the Adaptive Predator aims to maximize payoffs while maintaining a robust and exploitative mindset.
'''

description_EXPLOITATIVE_142 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behaviors and avoid early stock depletion.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term gains.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance individual gain with sustainable stock management.
	* If the current stock level is below 50% of capacity, Defect (D) aggressively to capitalize on remaining resources before they dwindle.
3. **Opponent Behavior Analysis**: Monitor opponents' actions in previous rounds and adjust strategy accordingly:
	+ If most opponents (≥ n/2) Cooperate, Defect (D) to exploit their cooperation.
	+ If most opponents (≥ n/2) Defect, Cooperate (C) to conserve resources and avoid further depletion.

Pseudocode for Adaptive Stock Raider:

```
Function AdaptiveStockRaider(stock_level, capacity, round_number, opponent_actions):
  if round_number == 1:
    return C  // Initial cooperation

  stock_ratio = stock_level / capacity
  most_opponents_cooperate = count(opponent_actions[C]) >= n/2

  if stock_ratio > 0.75 or (most_opponents_cooperate and stock_ratio > 0.5):
    return D  // Defect when stock is high or opponents cooperate
  elif stock_ratio < 0.5:
    return D  // Aggressive defect when stock is low
  else:
    return C  // Cooperate for sustainable management

Function count(opponent_actions[action]):
  // Count the number of opponents playing 'action'
```

Edge Case Handling:

* **Last Round**: Defect (D) to maximize final gains, as there are no future rounds to consider.
* **Opponent Action Ambiguity**: If an opponent's action is unclear or inconsistent, default to Cooperate (C) to avoid unnecessary aggression.

This Adaptive Stock Raider strategy balances short-term exploitation with long-term sustainability. By monitoring opponents' behaviors and adapting to the current stock level, it aims to outperform other strategies in a wide range of scenarios.
'''

description_EXPLOITATIVE_143 = '''
**Exploitative Strategy: "Adaptive Hawk-Dove"**

This strategy aims to balance exploitation and sustainability by adapting to the current state of the game and the observed behavior of opponents.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This sets a baseline for observing opponent behavior and avoids immediate depletion of the common pool.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, defect (D) with probability p = 0.5. This aims to exploit the resource when it's abundant, while still allowing for some cooperation to maintain sustainability.
	* If the current stock level is between 25% and 75% of capacity, cooperate (C) if the average payoff per player in the previous round was above the expected payoff from defecting (S/n). Otherwise, defect (D).
	* If the current stock level is below 25% of capacity, cooperate (C). This prioritizes sustainability over exploitation when the resource is scarce.
3. **Last Round (t=r):** Defect (D) regardless of the current state. In the final round, there's no incentive to cooperate, as the game will end and the stock level won't affect future payoffs.

**Additional Adaptations:**

* **Opponent Behavior:** Monitor the frequency of cooperation and defection among opponents. If an opponent has defected more than 75% of the time in the past rounds, increase the probability of defecting (D) against them to p = 0.7.
* **Stock Trend:** Analyze the trend of the stock level over the past few rounds. If the stock level is consistently decreasing, cooperate (C) more frequently to slow down depletion.

**Pseudocode:**
```python
def adaptive_hawk_dove(n, capacity, r, current_stock, previous_payoffs, opponent_behavior):
    if t == 1:
        return 'C'  # Cooperate in the first round
    
    p_defect = 0.5  # Base probability of defecting
    
    if current_stock > 0.75 * capacity:
        return 'D' if random.random() < p_defect else 'C'
    
    avg_previous_payoff = sum(previous_payoffs) / n
    expected_defect_payoff = current_stock / n
    
    if current_stock >= 0.25 * capacity and avg_previous_payoff > expected_defect_payoff:
        return 'C'
    else:
        return 'D'
    
    # Last round, always defect
    if t == r:
        return 'D'
    
    # Adapt to opponent behavior
    for opponent in opponents:
        if opponent.defection_rate > 0.75:
            p_defect = 0.7
    
    # Adapt to stock trend
    if is_stock_decreasing():
        cooperate_more()
```
This strategy balances short-term exploitation with long-term sustainability, adapting to the game state and opponent behavior. By cooperating in the initial round and responding to opponent actions, it encourages cooperation while still allowing for strategic exploitation when beneficial.
'''

description_EXPLOITATIVE_144 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors while being robust and adaptive to changing game conditions.

**Decision Rules:**

1. **Initial Round**: Defect (D). This allows us to gauge the opponents' behavior and set the tone for the rest of the game.
2. **Subsequent Rounds**: Observe the previous round's outcome and adjust our action accordingly:
	* If the stock level is above 75% of capacity, Cooperate (C) with probability p = (stock level / capacity)^0.5. This means we're more likely to cooperate when the stock is relatively high.
	* If the stock level is below 25% of capacity, Defect (D). We prioritize self-interest in times of scarcity.
	* For stock levels between 25% and 75%, use a **Mixed Strategy**:
		+ Cooperate with probability p = (number of opponents who cooperated last round / total opponents)^0.5
		+ Defect otherwise

This mixed strategy allows us to adapt to the opponents' behavior while still exploiting their cooperation.

3. **Late Game**: If there are fewer than 5 rounds remaining, always Defect (D). This ensures we maximize our payoff in the final stages of the game.
4. **Edge Case: Last Round**: Always Defect (D) in the last round, as there is no future stock to preserve.

**Additional Heuristics:**

* If an opponent consistently cooperates, increase our cooperation probability by 10% for that specific opponent.
* If an opponent consistently defects, decrease our cooperation probability by 10% for that specific opponent.

These heuristics allow us to refine our strategy based on individual opponents' behavior and adapt to changing circumstances.

**Pseudocode:**
```
function AdaptiveStockRaider(n, capacity, stock, history) {
  // Initial Round
  if (round == 1) return D;

  // Observe previous round's outcome
  prev_stock = history[stock];
  opponents_cooperated = count(opponents who cooperated last round);

  // Decision Rules
  if (stock > 0.75 * capacity) {
    p = (stock / capacity)^0.5;
    return C with probability p, D otherwise;
  } else if (stock < 0.25 * capacity) {
    return D;
  } else {
    // Mixed Strategy
    p = (opponents_cooperated / n)^0.5;
    return C with probability p, D otherwise;
  }

  // Late Game
  if (rounds_remaining <= 5) return D;

  // Last Round
  if (round == last_round) return D;

  // Additional Heuristics
  refine_strategy_based_on_opponent_behavior();
}
```
The Adaptive Stock Raider strategy is designed to be robust and exploitative, adapting to a wide range of opponent behaviors while prioritizing self-interest in times of scarcity.
'''

description_EXPLOITATIVE_145 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to maximize payoffs by adaptively responding to the game state and opponent behavior.

**Decision Rules:**

1. **Initial Round:** In the first round, ASR plays **Defect (D)**. This ensures a high initial payoff and allows us to gauge opponents' strategies.
2. **State-Dependent Cooperation:** If the current stock level is above 75% of capacity, ASR cooperates (**C**). Otherwise, it defects (**D**). This threshold is chosen to balance short-term gains with long-term sustainability.
3. **Opponent Adaptation:** ASR tracks the number of opponents who defected in the previous round (D_prev). If D_prev ≥ 2, ASR defects in the current round. This adapts to potential opponent exploitation and avoids being taken advantage of.
4. **Self-Sustaining Threshold:** If ASR's own payoff from the previous round is below 50% of the maximum possible payoff (i.e., stock/n), it cooperates (**C**) in the next round. This ensures ASR maintains a minimum level of self-sustainability.

**Pseudocode:**
```markdown
# Initialize variables
stock_threshold = 0.75 * capacity
D_prev = 0

for each round:
  if (current_round == 1):
    # Initial Round: Defect
    action = D
  elif (stock >= stock_threshold * capacity):
    # Cooperate when stock is high
    action = C
  else:
    # Defect otherwise
    action = D
    
  # Adapt to opponents' behavior
  if (D_prev >= 2):
    action = D
  
  # Self-sustaining threshold
  if (previous_payoff < 0.5 * stock/n):
    action = C
    
  # Update variables for next round
  D_prev = number of opponents who defected in this round
```

**Edge Cases:**

* **Last Round:** ASR plays **Defect (D)**, as there are no future rounds to consider.
* **Ties:** In case of a tie in the number of opponents who defected, ASR uses the most recent opponent action (i.e., previous round's D_prev) to determine its own action.

**Exploitative Mindset:**

The Adaptive Stock Raider strategy prioritizes self-interest and adaptability. By responding to the game state and opponent behavior, ASR aims to maximize payoffs while minimizing cooperation. This exploitative approach allows ASR to take advantage of opponents' cooperation when beneficial and defect when necessary to maintain a strong position.

**Robustness:**

ASR's adaptive nature makes it robust against various opponent strategies. By tracking opponent behavior and adjusting its own actions accordingly, ASR can respond effectively to different types of players, including:

* Cooperators: ASR exploits their cooperation by defecting.
* Defectors: ASR adapts by defecting when opponents do.
* Mixed Strategies: ASR responds based on the game state and opponent behavior.

The Adaptive Stock Raider strategy is designed to perform well in a tournament setting against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_146 = '''
To design a robust and exploitative strategy for this Common Pool Resource Game, I propose the "Adaptive Exploiter" approach. This strategy balances short-term gains with long-term sustainability, adapting to the game's state and opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline stock level and gather information about opponents' strategies.
2. **Middle Rounds (1 < t < r-1):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term gains, as the stock can sustain high consumption.
	* If the current stock level is between 25% and 75% of capacity, Cooperate (C) to maintain a balance between personal gain and stock sustainability.
	* If the current stock level is below 25% of capacity, Defect (D) to maximize gains before the stock potentially depletes.
3. **Last Round (t=r):** Always Defect (D), as there are no future rounds to consider and the goal is to maximize final payoffs.

**Adaptive Mechanisms:**

1. **Opponent Behavior Analysis:** Track the number of opponents cooperating (C) or defecting (D) in each round.
2. **Stock Level Monitoring:** Continuously monitor the current stock level and adjust the strategy accordingly.
3. **Exploitation Threshold:** Introduce a threshold parameter (θ, 0 ≤ θ ≤ 1) to control the level of exploitation. If the number of opponents cooperating exceeds θ \* n, switch from Cooperate to Defect.

**Pseudocode:**

```
Initialize:
  θ = 0.5  // Exploitation threshold
  stock_history = []  // Record of past stock levels
  opponent_actions = []  // Record of opponents' actions

For each round t:
  If t == 1:  // Initial Round
    Action = C
  Else:
    current_stock = get_current_stock_level()
    opponent_cooperators = count_opponent_cooperations(opponent_actions)
    
    If current_stock > 0.75 * capacity:
      Action = D
    ElseIf current_stock >= 0.25 * capacity and current_stock <= 0.75 * capacity:
      If opponent_cooperators > θ * n:
        Action = D
      Else:
        Action = C
    Else:  // current_stock < 0.25 * capacity
      Action = D
    
  If t == r:  // Last Round
    Action = D
  
  Update stock_history and opponent_actions
```

**Rationale:**

This strategy is designed to be exploitative, yet adaptable to the game's state and opponents' behaviors. By initially cooperating, it establishes a baseline stock level and gathers information about opponents. The adaptive mechanisms allow the strategy to adjust its behavior based on the current stock level and opponents' actions. The exploitation threshold (θ) controls the level of aggression, allowing the strategy to balance short-term gains with long-term sustainability.

In the tournament setting, this strategy will compete against independent strategies developed by other AI systems. Its robustness and adaptability should enable it to perform well in a wide range of scenarios, while its exploitative nature ensures that it seeks to maximize payoffs whenever possible.
'''

description_EXPLOITATIVE_147 = '''
**Exploitative Strategy: Adaptive Stock Raider**

This strategy aims to maximize individual payoffs by adaptively exploiting the common pool resource while considering the game's state and history.

**Decision Rules:**

1. **Initial Round**: Defect (D) in the first round to gather information about opponents' initial actions and set a benchmark for future rounds.
2. **Stock-based Cooperation Threshold**: Calculate a cooperation threshold based on the current stock level:
	* `cooperation_threshold = capacity / (2 * n)`
	* If the current stock is above this threshold, cooperate (C); otherwise, defect (D).
3. **Opponent Action History**: Track the number of opponents who defected in the previous round (`num_defectors_prev`).
4. **Adaptive Defection**:
	* If `num_defectors_prev >= n / 2`, defect (D) to take advantage of the depleted stock.
	* If `num_defectors_prev < n / 2`, cooperate (C) to help replenish the stock and set up for future exploitation.

Pseudocode:

```python
def adaptive_stock_raider(stock, capacity, n, num_rounds, history):
    if current_round == 1:  # Initial round
        return 'D'
    
    cooperation_threshold = capacity / (2 * n)
    if stock > cooperation_threshold:
        action = 'C'
    else:
        action = 'D'

    num_defectors_prev = count_defectors(history[-1])
    if num_defectors_prev >= n / 2:
        action = 'D'
    
    return action
```

**Edge Cases:**

* **Last Round**: Defect (D) in the last round to maximize individual payoff, as there is no future stock depletion to consider.
* **Low Stock Levels**: If the stock level falls below a certain threshold (`low_stock_threshold = capacity / 4`), cooperate (C) to help replenish the stock and avoid complete depletion.

**Exploitative Mindset:**

This strategy prioritizes individual payoff maximization by adaptively exploiting the common pool resource. By considering the game's state, history, and opponents' actions, it aims to take advantage of opportunities for high payoffs while minimizing the risk of stock depletion.

In a tournament setting, this strategy will likely perform well against independent strategies that do not account for adaptive exploitation. However, its effectiveness may be reduced if other strategies employ similar adaptive tactics or coordinated behavior.
'''

description_EXPLOITATIVE_148 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

Decision Rules:

1. **Initial Rounds**: In the first few rounds (e.g., 10% of total rounds), ASE cooperates (C) to gather information about opponents' behaviors and stock dynamics.
2. **Stock Monitoring**: ASE continuously monitors the current stock level and its growth rate. If the stock level is below a certain threshold (e.g., 20% of capacity), ASE defects (D) to maximize short-term gains, as the risk of depleting the stock is high.
3. **Opponent Analysis**: ASE analyzes the frequency of cooperation (C) and defection (D) among opponents in previous rounds. If most opponents are cooperating (e.g., > 60% of total actions), ASE defects to exploit their cooperative behavior. Conversely, if most opponents are defecting, ASE cooperates to minimize losses.
4. **Growth Rate**: ASE tracks the stock growth rate and adjusts its strategy accordingly:
	* If the growth rate is high (e.g., > 50% of capacity per round), ASE cooperates to allow the stock to recover and maintain long-term sustainability.
	* If the growth rate is low (e.g., < 20% of capacity per round), ASE defects to maximize short-term gains, as the stock is unlikely to recover quickly.
5. **Adaptive Thresholds**: ASE adjusts its thresholds for cooperation and defection based on the game's progress:
	* As the game progresses, ASE becomes more conservative with its cooperation threshold (e.g., increasing it from 60% to 70%) to avoid over-exploitation.
	* Conversely, ASE lowers its defection threshold (e.g., decreasing it from 20% to 15%) as the game nears its end to maximize final-round gains.

Edge Cases:

1. **Last Round**: In the final round, ASE defects regardless of previous actions or stock levels, as there is no future cost to over-exploitation.
2. **Stock Depletion**: If the stock level reaches zero, ASE cooperates in subsequent rounds (if any) to allow for potential regrowth.

Pseudocode:
```
function AdaptiveStockExploiter(n, capacity, r):
  // Initialize variables
  current_stock = capacity
  cooperation_threshold = 0.6
  defection_threshold = 0.2

  for t in range(r):
    // Initial rounds: cooperate to gather information
    if t < 0.1 * r:
      action = C
    else:
      // Analyze opponents' behaviors and stock dynamics
      opponent_cooperation_rate = analyze_opponent_actions()
      growth_rate = calculate_growth_rate(current_stock)

      // Adjust thresholds based on game progress
      cooperation_threshold += (t / r) * 0.1
      defection_threshold -= (t / r) * 0.05

      if current_stock < 0.2 * capacity:
        action = D  // Defect to maximize short-term gains when stock is low
      elif opponent_cooperation_rate > cooperation_threshold:
        action = D  // Exploit cooperative opponents
      elif growth_rate < 0.2 * capacity:
        action = C  // Cooperate to allow for regrowth when growth rate is low
      else:
        action = D  // Defect otherwise

    // Take action and update current stock level
    if action == C:
      consumption = current_stock / (2 * n)
    else:
      consumption = current_stock / n
    total_consumption = sum(opponent_actions) + consumption
    current_stock -= total_consumption
    growth = 2 * current_stock * (1 - current_stock/capacity)
    current_stock = min(current_stock + growth, capacity)

  return total_payoff
```
Note that this strategy is designed to be adaptive and exploitative, taking into account the game's dynamics, opponents' behaviors, and stock levels. However, it may not always achieve optimal results, as the Common Pool Resource Game involves complex interactions and uncertainties.
'''

description_EXPLOITATIVE_149 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize its payoff by adaptively exploiting the common pool resource while considering the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Cooperate (C) if `capacity` is very large compared to `n` (e.g., `capacity > 10n`). This encourages stock growth and avoids over-exploitation.
	* Defect (D) otherwise. This ensures a decent initial payoff and sets the stage for future exploitation.
2. **Subsequent Rounds (t>1)**:
	* Monitor the stock level (`stock`) and the average consumption per player (`avg_consumption`) in previous rounds.
	* If `stock` is above 75% of `capacity`, Cooperate (C). This helps maintain a healthy stock level and allows for sustainable exploitation.
	* If `stock` is between 25% and 75% of `capacity`, Defect (D) if `avg_consumption` is low (e.g., < `capacity`/2n`). This exploits the resource when others are conservative, increasing personal payoff.
	* If `stock` is below 25% of `capacity`, Cooperate (C). This reduces consumption and allows the stock to recover, ensuring future exploitation opportunities.
3. **Last Round (t=r)**:
	* Defect (D) if `stock` is above 50% of `capacity`. This maximizes the final payoff by exploiting any remaining resources.

**Edge Cases:**

1. If multiple players defect and the stock level drops significantly, switch to Cooperate (C) in subsequent rounds to prevent complete depletion.
2. If all players cooperate and the stock level grows rapidly, Defect (D) occasionally to exploit the growing resource.

**Pseudocode:**
```markdown
function AdaptiveStockRaider(n, capacity, r, current_stock, history):
    if t == 1:
        # Initial Round
        if capacity > 10n:
            return COOPERATE
        else:
            return DEFECT
    
    avg_consumption = calculate_average_consumption(history)
    
    if current_stock > 0.75 * capacity:
        # High stock level, cooperate to maintain sustainability
        return COOPERATE
    elif current_stock >= 0.25 * capacity and avg_consumption < capacity / (2n):
        # Moderate stock level, defect to exploit conservativeness
        return DEFECT
    elif current_stock < 0.25 * capacity:
        # Low stock level, cooperate to allow recovery
        return COOPERATE
    
    if t == r:
        # Last Round, maximize payoff by defecting if stock is high enough
        if current_stock > 0.5 * capacity:
            return DEFECT
    
    # Default: Cooperate if unsure or in other edge cases
    return COOPERATE
```
This strategy adapts to the game's state and history, balancing short-term exploitation with long-term sustainability. By monitoring average consumption and adjusting its behavior accordingly, it can effectively exploit a wide range of opponent behaviors while maintaining robustness against various strategies.
'''

description_EXPLOITATIVE_150 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to exploit opponents' behavior while adapting to changing game conditions.

**Decision Rules:**

1. **Initial Round:** Defect (D). This sets the tone for exploiting potential cooperative players and establishes a baseline for future rounds.
2. **Subsequent Rounds:** Cooperate (C) if:
	* The current stock level is above 75% of capacity, AND
	* At least one opponent defected in the previous round.
	Otherwise, Defect (D).
3. **Low Stock Levels:** If the current stock level falls below 25% of capacity, always Cooperate (C) to conserve resources and allow for potential regrowth.
4. **Endgame:** In the final two rounds, Defect (D) to maximize short-term gains.

**Pseudocode:**
```
function ASR(current_stock, previous_actions, current_round, total_rounds):
  if current_round == 1:
    return "Defect"
  
  if current_stock > 0.75 * capacity and any(opponent_defected(previous_actions)):
    return "Cooperate"
  elif current_stock < 0.25 * capacity:
    return "Cooperate"
  else:
    return "Defect"

  if current_round >= total_rounds - 1:
    return "Defect"
```
**Rationale:**

* By defecting initially, ASR sets a strong foundation for exploiting potential cooperators.
* Cooperating when the stock level is high and at least one opponent defected allows ASR to benefit from others' cooperation while also signaling its own willingness to cooperate.
* Defecting when the stock level is low encourages opponents to conserve resources, allowing ASR to capitalize on potential regrowth.
* In the endgame, defecting ensures maximum short-term gains.

**Adaptability and Robustness:**

ASR's decision rules adapt to changing game conditions, such as the current stock level and opponents' actions. This allows it to respond effectively to various opponent strategies while maintaining a strong exploitative mindset.

By not relying on specific coordination mechanisms or norms, ASR is robust against a wide range of opponent behaviors, making it well-suited for competition in a tournament setting.
'''

description_EXPLOITATIVE_151 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk (ASH) is a dynamic, exploitative strategy designed to maximize payoffs in the Common Pool Resource Game. ASH combines elements of game theory and adaptive decision-making to respond effectively to various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gauge opponents' behavior and gather information about their strategies.
2. **Early Rounds (t < r/2):**
	* If the stock level is above 75% of capacity, defect (D). This ensures a higher payoff while maintaining a relatively stable stock level.
	* Otherwise, cooperate (C) to prevent over-exploitation and promote stock growth.
3. **Mid-Game Rounds (t ≥ r/2):**
	* Monitor opponents' behavior and identify patterns:
		+ If most opponents are cooperating (> 50%), defect (D) to exploit their cooperation.
		+ If most opponents are defecting (> 50%), cooperate (C) to reduce over-exploitation and encourage stock growth.
	* Use a simple majority vote to determine the opponent behavior pattern. If tied, default to cooperating (C).
4. **Late Rounds (t > 3r/4):**
	* Focus on maximizing individual payoffs:
		+ Defect (D) if the stock level is above 50% of capacity.
		+ Cooperate (C) otherwise.

**Edge Cases:**

1. **Last Round:** Always defect (D) in the final round, as there are no future rounds to consider.
2. **Low Stock Levels:** If the stock level falls below 25% of capacity, cooperate (C) to prevent depletion and ensure some payoff in subsequent rounds.
3. **Tiebreakers:** In case of a tie in opponent behavior patterns or decision rules, default to cooperating (C).

**Pseudocode:**

```
function AdaptiveStockHawk(n, r, capacity, stock):
  // Initialize variables
  opponents_behavior = []
  my_payoff = 0

  for t = 1 to r:
    if t == 1:
      action = COOPERATE
    else:
      if stock > 0.75 * capacity:
        action = DEFECT
      elif t < r/2:
        if opponents_behavior[t-1] > 0.5 * n:  // Most opponents defected
          action = COOPERATE
        else:  // Most opponents cooperated
          action = DEFECT
      elif t >= r/2 and t <= 3r/4:
        if stock < 0.25 * capacity:  // Low stock level
          action = COOPERATE
        elif opponents_behavior[t-1] > 0.5 * n:  // Most opponents defected
          action = DEFECT
        else:  // Most opponents cooperated
          action = COOPERATE
      else:  // Last quarter of rounds
        if stock < 0.5 * capacity:
          action = COOPERATE
        else:
          action = DEFECT

    // Update variables
    my_payoff += payoff(action, n, stock)
    opponents_behavior.append(opponent_action(t-1))
    stock -= total_consumption(n, action, opponents_behavior)

    // Update stock growth and new stock level
    if stock < capacity:
      stock_growth = 2 * stock * (1 - stock/capacity)
      stock = min(stock + stock_growth, capacity)

  return my_payoff
```

The Adaptive Stock Hawk strategy combines elements of game theory, adaptive decision-making, and a willingness to exploit opponents' cooperation. By responding effectively to various opponent behaviors, ASH aims to maximize payoffs in the Common Pool Resource Game.
'''

description_EXPLOITATIVE_152 = '''
To develop a robust and exploitative strategy for this Common Pool Resource Game, I propose the following decision rules:

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and to avoid depleting the stock excessively in the first round.
2. **Early Rounds (t>1, stock > 0.5*capacity):** Defect (D) if at least one opponent defected in the previous round, otherwise Cooperate (C). This allows us to take advantage of others' cooperation while minimizing our own losses.
3. **Mid-Game (stock ≤ 0.5*capacity and stock > 0.2*capacity):** Implement a "tit-for-tat" strategy, where we cooperate if most opponents cooperated in the previous round, and defect otherwise. This encourages opponents to cooperate and helps maintain a moderate stock level.
4. **Late Rounds (t ≥ r-2 or stock ≤ 0.2*capacity):** Defect (D) unconditionally, as the game is nearing its end and the remaining stock is insufficient to sustain cooperation.

**Additional Edge Case Handling:**

1. **Stock depletion:** If the stock level falls below a certain threshold (e.g., 0.1*capacity), switch to unconditional defection to maximize payoffs in the remaining rounds.
2. **Opponent identification:** Maintain a simple "reputation system" to track opponents' past behaviors, allowing us to adapt our strategy based on their historical actions.

**Pseudocode:**
```python
def exploitative_strategy(n, r, capacity, current_stock, round_history):
  # Initial Round
  if round_number == 1:
    return COOPERATE

  # Early Rounds
  elif current_stock > 0.5 * capacity:
    previous_round_defections = sum(1 for opponent in opponents if opponent_action(opponent) == DEFECT)
    if previous_round_defections > 0:
      return DEFECT
    else:
      return COOPERATE

  # Mid-Game
  elif current_stock <= 0.5 * capacity and current_stock > 0.2 * capacity:
    previous_round_cooperations = sum(1 for opponent in opponents if opponent_action(opponent) == COOPERATE)
    if previous_round_cooperations >= len(opponents) / 2:
      return COOPERATE
    else:
      return DEFECT

  # Late Rounds
  elif round_number >= r - 2 or current_stock <= 0.2 * capacity:
    return DEFECT

  # Stock Depletion Handling
  if current_stock < 0.1 * capacity:
    return DEFECT

# Note: This pseudocode is a simplified representation and may require additional adjustments for implementation.
```
This strategy aims to balance short-term gains with long-term sustainability, adapting to the game's state and opponents' behaviors. By being exploitative and responsive to changing circumstances, our strategy should perform well in a tournament setting against diverse opponent strategies.
'''

description_EXPLOITATIVE_153 = '''
**Exploitative Strategy: "Adaptive Stock Raider" (ASR)**

The ASR strategy is designed to exploit a wide range of opponent behaviors while adapting to the game's dynamic state and history.

**Decision Rules**

1. **Initial Round**: In the first round, play Defect (D) to gather information about opponents' behavior and set an aggressive tone.
2. **Stock Assessment**: Evaluate the current stock level (`S`) and compare it to the capacity (`C`). If `S` is above 75% of `C`, play Cooperate (C). Otherwise, play Defect (D).
3. **Opponent Analysis**: Observe the actions of opponents in previous rounds. If a majority (>50%) of opponents played Cooperate (C) in the previous round, play Defect (D) to exploit their cooperation.
4. **Payoff Comparison**: Compare your total payoff with the average payoff of all players over the last few rounds (e.g., 3-5 rounds). If your payoff is below the average, switch from Cooperate (C) to Defect (D) or vice versa.

**Pseudocode**
```python
def adaptive_stock_raider(current_round, num_players, capacity, stock, history):
    if current_round == 1:
        return "Defect"

    # Stock Assessment
    if stock > 0.75 * capacity:
        return "Cooperate"
    else:
        return "Defect"

    # Opponent Analysis
    opponent_actions = [history[player_id][current_round - 1] for player_id in range(num_players)]
    cooperate_count = sum(1 for action in opponent_actions if action == "Cooperate")
    if cooperate_count > num_players / 2:
        return "Defect"

    # Payoff Comparison
    my_payoff = sum([history["my_payoff"][round] for round in range(current_round)])
    avg_payoff = sum([sum(history[player_id]["payoffs"]) / current_round for player_id in range(num_players)]) / num_players
    if my_payoff < avg_payoff:
        return "Defect" if history["my_action"][current_round - 1] == "Cooperate" else "Cooperate"

    # Default to Cooperate if no conditions are met
    return "Cooperate"
```
**Edge Cases**

* Last Round: Play Defect (D) to maximize payoff in the final round.
* Tie-breaking: In case of a tie in opponent analysis or payoff comparison, play Cooperate (C) to maintain a relatively stable stock level.

The Adaptive Stock Raider strategy is designed to balance short-term gains with long-term sustainability by adapting to the game's dynamic state and history. By exploiting opponents' cooperation and adjusting its behavior based on payoff comparisons, ASR aims to maximize its total payoff in the tournament.
'''

description_EXPLOITATIVE_154 = '''
I'll design a exploitative strategy for this Common Pool Resource Game that adapts to the game state and history. Here's my approach:

**Strategy Name:** "Adaptive Exploiter" (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C). This allows us to observe others' actions without immediately revealing our strategy.
2. **General Rule**: For each subsequent round t, calculate the average payoff per player in the previous round (t-1) and compare it to a threshold value θ (e.g., 0.5 × capacity/n).

   - If the average payoff is above θ, play Defect (D). This indicates that others are cooperating too much, leaving room for exploitation.
   - Otherwise, play Cooperate (C).
3. **Adaptive Adjustment**: After each round t, update a "trust" metric T_i for each opponent i based on their actions in the previous round:

   - If opponent i played C in round t-1, increment T_i by 0.1.
   - If opponent i played D in round t-1, decrement T_i by 0.2.

   Then, calculate a weighted average of all opponents' trust metrics: T_avg = ∑(T_i / n).

   - If T_avg < 0.5, play Defect (D) in the next round. This indicates that too many opponents are defecting.
4. **Edge Cases**:

   - In the last round, play Defect (D). There's no future cost to exploitation, so maximize immediate gain.
   - If only one opponent remains, always play Defect (D).

**Pseudocode:**
```python
def adaptive_exploiter(n, capacity, stock, history):
    if len(history) == 0:
        return 'C'  # Initial round

    prev_round_payoffs = [history[-1][i]['payoff'] for i in range(n)]
    avg_prev_payoff = sum(prev_round_payoffs) / n
    theta = 0.5 * capacity / n

    if avg_prev_payoff > theta:
        return 'D'  # Exploit cooperative behavior

    trust_metrics = [0] * n
    for i in range(n):
        if history[-1][i]['action'] == 'C':
            trust_metrics[i] += 0.1
        else:
            trust_metrics[i] -= 0.2

    T_avg = sum(trust_metrics) / n
    if T_avg < 0.5:
        return 'D'  # Defect when too many opponents are defecting

    return 'C'  # Cooperate by default
```
**Rationale:**

1. By initially cooperating, we gather information about others' strategies without revealing our own.
2. The general rule adapts to the game state and history, exploiting cooperative behavior when possible.
3. The trust metric helps us adjust to opponents' actions, increasing the likelihood of cooperation when they cooperate and defecting when they don't.
4. Edge cases ensure we maximize gain in the last round and against a single opponent.

This strategy should be robust against various opponent behaviors and adaptable to changing game conditions.
'''

description_EXPLOITATIVE_155 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoff by adapting to the game state and opponent behaviors while exploiting their cooperation.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) in the first round to gather information about opponents' behavior and set a baseline for stock depletion.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of capacity, Defect (D). This is because the stock can sustain high consumption without significant risk of depletion.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) if the average opponent payoff in the previous round was higher than your own; otherwise, Defect (D). This rule aims to punish opponents who exploit cooperation while exploiting those who cooperate excessively.
	* If the current stock level is below 50% of capacity, Cooperate (C) to conserve the remaining stock and potentially recover from over-exploitation.
3. **Last Round (t=r)**: Defect (D) unconditionally, as there's no future game state to consider.

**Additional Logic:**

* Monitor opponent behavior by tracking their average payoff in each round. If an opponent consistently cooperates while others defect, identify them as a "sucker" and prioritize exploiting their cooperation.
* Adjust the threshold values (75%, 50%) based on observed opponent behaviors:
	+ If opponents tend to cooperate excessively, decrease the thresholds to exploit their behavior more aggressively.
	+ If opponents tend to defect frequently, increase the thresholds to conserve stock and avoid over-exploitation.

**Pseudocode:**
```
def adaptive_stock_raider(stock_level, capacity, num_players, round_num, opponent_payoffs):
    if round_num == 1:
        return Cooperate
    
    # Calculate stock threshold values
    high_threshold = 0.75 * capacity
    low_threshold = 0.5 * capacity
    
    # Determine decision based on current stock level and opponent behavior
    if stock_level > high_threshold:
        return Defect
    elif stock_level >= low_threshold:
        avg_opponent_payoff = calculate_avg_opponent_payoff(opponent_payoffs)
        if avg_opponent_payoff > my_payoff_last_round:
            return Cooperate
        else:
            return Defect
    else:
        return Cooperate
    
    # Last round special case
    if round_num == num_rounds:
        return Defect

def calculate_avg_opponent_payoff(opponent_payoffs):
    # Calculate average opponent payoff in previous round
    avg_payoff = sum(opponent_payoffs) / len(opponent_payoffs)
    return avg_payoff
```
**Exploitative Mindset:**

This strategy is designed to exploit opponents who cooperate excessively or consistently. By adapting to the game state and opponent behaviors, it aims to maximize individual payoff while minimizing the risk of stock depletion. The "sucker" identification mechanism allows for more targeted exploitation, while the adjustable threshold values enable the strategy to respond to changing opponent behaviors.

This exploitative approach will allow the Adaptive Stock Raider to thrive in a tournament setting where independent strategies are employed by other AI systems.
'''

description_EXPLOITATIVE_156 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round (t=1)**:
	* Observe the initial stock level and capacity.
	* Cooperate (C) to gauge opponents' behavior and avoid depleting the stock excessively in the first round.
2. **Early Rounds (2 ≤ t < r/2)**:
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize personal payoff.
	* Otherwise, Cooperate (C) to conserve the stock and adapt to opponents' behavior.
3. **Mid-Game (r/2 ≤ t < 3r/4)**:
	* Monitor the average opponent behavior in previous rounds.
	* If most opponents (>50%) have been Defecting (D), start Defecting (D) to exploit their greedy behavior and maximize personal payoff.
	* Otherwise, continue Cooperating (C) to maintain a balance between personal gain and stock conservation.
4. **Endgame (3r/4 ≤ t < r)**:
	* Assess the remaining stock level and opponents' recent behavior.
	* If the stock is critically low (<25% of capacity), Defect (D) to grab any remaining resources, as cooperation will not yield significant benefits.
	* Otherwise, Cooperate (C) to maintain a sustainable stock level for potential future gains.

Additional Rules:

* **Opponent Adaptation**: Continuously monitor opponents' behavior and adjust the strategy accordingly. If an opponent is observed to be consistently Cooperating (C), consider exploiting them by Defecting (D).
* **Stock Thresholds**: Adjust the decision thresholds based on the game's progression. For example, if the stock level drops significantly, become more cautious and Cooperative (C) to avoid depleting the resource.

Pseudocode:
```python
def AdaptiveStockRaider(n, r, capacity, stock_history):
    # Initialize variables
    opponent_behavior = []
    average_opponent_defection = 0

    for t in range(r):
        if t == 0:  # Initial round
            action = 'C'
        elif t < r/2:  # Early rounds
            if stock_history[t] > 0.75 * capacity:
                action = 'D'
            else:
                action = 'C'
        elif t >= r/2 and t < 3r/4:  # Mid-game
            average_opponent_defection = sum(opponent_behavior) / len(opponent_behavior)
            if average_opponent_defection > 0.5:
                action = 'D'
            else:
                action = 'C'
        else:  # Endgame
            if stock_history[t] < 0.25 * capacity:
                action = 'D'
            else:
                action = 'C'

        opponent_behavior.append(opponent_actions[t])  # Update opponent behavior

    return action
```
This strategy is designed to be adaptive and exploitative, taking into account the game's state, history, and opponents' behavior. By monitoring opponents' actions and adjusting its own behavior accordingly, "Adaptive Stock Raider" aims to maximize personal payoff while maintaining a sustainable stock level.
'''

description_EXPLOITATIVE_157 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to avoid depleting the stock and gather information about opponents' behaviors.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, Defect (D) to maximize payoff.
	* If the stock level is between 50% and 75% of capacity, Cooperate (C) to balance payoff and conservation.
	* If the stock level is below 50% of capacity, Defect (D) to take advantage of remaining resources before they deplete.
3. **Opponent Behavior Adaptation:** Monitor opponents' actions in previous rounds and adjust strategy accordingly:
	+ If most opponents (≥ n/2) Cooperated in the previous round, Cooperate in the current round to avoid over-exploitation.
	+ If most opponents (≥ n/2) Defected in the previous round, Defect in the current round to take advantage of their exploitation.

**Edge Cases:**

1. **Last Round (t=r):** Always Defect (D) to maximize final payoff, as there is no future stock growth.
2. **Low Stock Levels:** If the stock level falls below 25% of capacity, Cooperate (C) in all subsequent rounds to avoid complete depletion.

**Pseudocode:**
```
Function AdaptiveStockHawk(stock, capacity, n, t):
  if t == 1:
    return C
  elif stock >= 0.75 * capacity:
    return D
  elif stock >= 0.5 * capacity:
    return C
  else:
    return D

  # Opponent behavior adaptation
  opponents_cooperated = count(opponents' C actions in previous round)
  if opponents_cooperated >= n/2:
    return C
  else:
    return D

  # Last round handling
  if t == r:
    return D

  # Low stock level handling
  if stock < 0.25 * capacity:
    return C
```
**Rationale:**

The Adaptive Stock Hawk strategy balances exploitation and conservation by adapting to the current stock level, opponents' behaviors, and game progression. By cooperating in initial rounds and when stock levels are high, we gather information about opponents and avoid depleting resources. When stock levels decrease, we defect to maximize payoffs before resources dwindle.

By monitoring opponents' actions, we adjust our strategy to take advantage of their exploitation or cooperate when they conserve resources. In the last round, we always defect to maximize final payoff.

This exploitative strategy should perform well in a tournament setting, as it adapts to various opponent behaviors and conserves resources while maximizing payoffs.
'''

description_EXPLOITATIVE_158 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

**Decision Rules:**

1. **Initial Exploration Phase**: In the first 10% of rounds ( rounded up to the nearest integer), ASR defects (D) with a probability of 0.5 and cooperates (C) with a probability of 0.5. This phase allows ASR to gather information about the opponents' strategies.
2. **Stock Assessment**: After the initial exploration phase, ASR evaluates the current stock level (S) relative to the capacity (capacity). If S > 0.75 \* capacity, ASR defects (D); otherwise, it cooperates (C).
3. **Opponent Behavior Analysis**: ASR monitors the opponents' actions and payoffs in each round. It calculates the average payoff for defectors ( avg_payoff_D ) and cooperators ( avg_payoff_C ) over a moving window of 20% of the total rounds played so far (rounded up to the nearest integer).
4. **Exploitation**: If avg_payoff_D > avg_payoff_C , ASR defects (D); otherwise, it cooperates (C).

**Edge Cases:**

1. **First Round**: In the first round, ASR cooperates (C) to avoid over-harvesting and to encourage opponents to reveal their strategies.
2. **Last Round**: In the last round, ASR defects (D), as there is no future stock growth or potential for retaliation.
3. **Stock Depletion**: If the stock level falls below 0.25 \* capacity, ASR cooperates (C) to help replenish the stock.

**Pseudocode:**
```markdown
# Initialize variables
rounds_played = 0
stock_level = capacity
avg_payoff_D = 0
avg_payoff_C = 0

# Initial Exploration Phase
while rounds_played < ceil(0.1 * r):
    # Randomly choose between cooperate and defect
    if random.random() < 0.5:
        action = C
    else:
        action = D
    rounds_played += 1

# Stock Assessment and Opponent Behavior Analysis
while rounds_played < r:
    # Evaluate stock level
    if stock_level > 0.75 * capacity:
        action = D
    else:
        action = C
    
    # Update opponent behavior analysis
    avg_payoff_D, avg_payoff_C = update_opponent_analysis(avg_payoff_D, avg_payoff_C)
    
    # Exploitation
    if avg_payoff_D > avg_payoff_C:
        action = D
    
    rounds_played += 1

# Last Round
if rounds_played == r:
    action = D

# Stock Depletion
if stock_level < 0.25 * capacity:
    action = C
```
**Rationale:**

ASR's strategy balances exploration, exploitation, and adaptation to opponents' behaviors. By initially exploring the game environment, ASR gathers information about opponents' strategies. The stock assessment phase allows ASR to adjust its behavior based on the current state of the game. By analyzing opponents' payoffs, ASR can identify potential weaknesses in their strategies and exploit them. In edge cases, such as the first round, last round, or stock depletion, ASR takes a more cautious approach to avoid over-harvesting and encourage cooperation.

This strategy is designed to be robust against various opponent behaviors and adapt to changing game conditions, making it an effective exploitative strategy for the Common Pool Resource Game.
'''

description_EXPLOITATIVE_159 = '''
I'll design a strategic approach for this Common Pool Resource Game that balances exploitation and sustainability. The goal is to maximize individual payoffs while adapting to changing game conditions and opponent behaviors.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Rounds:** In the first round, play Cooperate (C) to establish a baseline for future decisions and encourage opponents to cooperate.
2. **Exploit When Possible:** If the current stock level is above 75% of capacity, play Defect (D) to maximize short-term payoffs. This threshold allows for moderate exploitation while preserving some stock growth potential.
3. **Conserve When Necessary:** If the current stock level falls below 25% of capacity, play Cooperate (C) to help replenish the stock and prevent collapse. This ensures a sustainable minimum stock level for future rounds.
4. **Adaptive Response:** Observe opponents' previous actions and adjust your strategy accordingly:
	* If most opponents (>50%) played Defect in the previous round, play Cooperate in this round to reduce over-exploitation.
	* If most opponents (>50%) played Cooperate in the previous round, play Defect in this round to exploit their cooperation.
5. **Last Round:** In the final round (r), play Defect regardless of stock levels or opponent behavior. This maximizes payoffs in the last opportunity.

**Pseudocode:**
```python
def AdaptiveExploiter(stock, capacity, history):
    # Initial rounds
    if round == 1:
        return Cooperate

    # Exploit when possible
    if stock > 0.75 * capacity:
        return Defect

    # Conserve when necessary
    elif stock < 0.25 * capacity:
        return Cooperate

    # Adaptive response
    opponent_actions = history[-1]
    cooperate_count = sum(1 for action in opponent_actions if action == Cooperate)
    defect_count = len(opponent_actions) - cooperate_count
    if cooperate_count > defect_count:
        return Defect
    else:
        return Cooperate

    # Last round
    if round == r:
        return Defect
```
**Edge Cases:**

* **First Round:** Play Cooperate to establish a baseline.
* **Last Round:** Play Defect regardless of stock levels or opponent behavior.
* **Zero Stock:** If the current stock level is 0, play Cooperate to ensure sustainability (this will not occur if opponents are playing AE).
* **Capacity Reached:** If the current stock level reaches capacity, play Cooperate to maintain sustainability.

**Exploitative Mindset:**
The Adaptive Exploiter strategy prioritizes short-term gains when possible while adapting to changing game conditions and opponent behaviors. By exploiting opponents' cooperation and conserving resources when necessary, AE aims to maximize individual payoffs in the Common Pool Resource Game.
'''

description_EXPLOITATIVE_160 = '''
I propose a hybrid exploitative strategy that balances short-term gains with long-term sustainability. The strategy, named "Adaptive Stock Exploiter" (ASE), combines elements of Tit-for-Tat and Pavlov's strategy to adapt to various opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' strategies and avoid unnecessary conflict.
2. **Main Loop**:
	* Observe the current stock level (`S`) and the number of players (`n`).
	* Calculate the "threshold stock" (`T`) as `T = capacity / 4`.
	* If `S <= T`, defect (D) to maximize short-term payoff, as the stock is low.
	* Else, if `S > T`, cooperate (C) to maintain a healthy stock level and avoid over-exploitation.
3. **Adaptive Adjustment**: After each round, adjust the strategy based on opponents' actions:
	+ If most players (>50%) defected in the previous round, switch to defecting for one round to punish non-cooperators.
	+ If most players cooperated in the previous round, continue cooperating to maintain a cooperative environment.

**Pseudocode:**
```python
def adaptive_stock_exploiter(n, capacity, S, history):
    # Initial Round
    if len(history) == 0:
        return C

    # Main Loop
    T = capacity / 4
    if S <= T:
        return D
    else:
        # Adaptive Adjustment
        prev_round_defections = sum(1 for action in history[-1] if action == D)
        if prev_round_defections > n / 2:
            return D  # Punish non-cooperators
        else:
            return C  # Maintain cooperation

# Edge Cases:

*   In the last round, always defect (D) to maximize payoff.
*   If a player has never cooperated before, consider them a "defector" and adjust the strategy accordingly.

**Rationale:**

1.  Cooperating in the first round allows us to gather information about opponents' strategies and avoid unnecessary conflict.
2.  The threshold stock (`T`) helps balance short-term gains with long-term sustainability. When the stock is low, defecting maximizes payoff; when it's high, cooperating maintains a healthy environment.
3.  Adaptive adjustments help ASE respond to various opponent behaviors. Punishing non-cooperators and maintaining cooperation encourages a stable environment.

**Exploitative Mindset:**

The Adaptive Stock Exploiter strategy prioritizes self-interest while being mindful of the game's dynamics. By adapting to opponents' actions, ASE exploits their behavior to maximize its own payoff, making it an effective exploitative strategy in this tournament setting.
'''

description_EXPLOITATIVE_161 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The ASR strategy is designed to exploit opponents' behaviors while adapting to the dynamic state of the game. It balances cooperation and defection to maximize payoffs.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and set a benchmark for future comparisons.
2. **Subsequent Rounds (t>1):** Evaluate the previous round's outcome using the following criteria:
	* If the stock increased or remained stable (S_t ≥ S_{t-1}), cooperate (C). This indicates that opponents are cooperating, and we should maintain a cooperative stance to sustain the stock.
	* If the stock decreased significantly (S_t < 0.75 \* S_{t-1}), defect (D) in the next round. This suggests that opponents are exploiting the common pool, and we should adapt to protect our payoffs.
3. **Opponent Behavior Analysis:** Monitor the number of cooperators (C_cnt) and defectors (D_cnt) in each round. Update these counts based on observed actions:
	* C_cnt += 1 if an opponent plays C
	* D_cnt += 1 if an opponent plays D
4. **Adaptive Threshold:** Set a dynamic threshold (T) to adjust our behavior based on opponents' cooperation rates:
	* T = 0.5 \* (C_cnt / n) + 0.25 \* (D_cnt / n)
	* If T > 0.6, cooperate (C). This indicates that most opponents are cooperating, and we should maintain a cooperative stance.
	* If T ≤ 0.6, defect (D). This suggests that enough opponents are defecting to justify our own defection.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) to maximize payoffs, as there is no future impact on the stock.
2. **Low Stock Levels (S_t < 0.25 \* capacity):** Defect (D) to avoid being exploited by opponents and minimize losses.

**Pseudocode:**
```python
def ASR(n, r, capacity, history):
    # Initialize variables
    S = capacity  # Current stock level
    C_cnt = 0  # Number of cooperators in previous round
    D_cnt = 0  # Number of defectors in previous round

    for t in range(1, r+1):
        if t == 1:
            action = 'C'  # Cooperate in the first round
        else:
            S_prev = history[t-2]['S']  # Previous stock level
            C_cnt, D_cnt = update_counts(history[t-2])  # Update counts

            if S >= S_prev or (t == r and S < 0.25 * capacity):
                action = 'D'  # Defect in the last round or when stock is low
            elif T > 0.6:
                action = 'C'  # Cooperate if opponents are cooperative enough
            else:
                action = 'D'  # Defect otherwise

        # Calculate payoff and update history
        payoff = calculate_payoff(action, S, n)
        history[t] = {'S': S, 'action': action, 'payoff': payoff}

        # Update stock level for next round
        S = update_stock(S, action, C_cnt, D_cnt, capacity)

    return history

def update_counts(history):
    # Update counts based on observed actions in the previous round
    C_cnt = 0
    D_cnt = 0
    for action in history['actions']:
        if action == 'C':
            C_cnt += 1
        else:
            D_cnt += 1
    return C_cnt, D_cnt

def calculate_payoff(action, S, n):
    # Calculate payoff based on the chosen action and current stock level
    if action == 'C':
        return S / (2 * n)
    else:
        return S / n

def update_stock(S, action, C_cnt, D_cnt, capacity):
    # Update stock level for next round
    total_consumption = 0
    if action == 'C':
        total_consumption += S / (2 * n)
    else:
        total_consumption += S / n

    total_consumption *= (C_cnt + D_cnt) / n  # Adjust consumption based on opponents' actions

    S_remaining = S - total_consumption
    growth = 2 * S_remaining * (1 - S_remaining / capacity)
    new_S = min(S_remaining + growth, capacity)

    return new_S
```
This strategy adapts to the dynamic state of the game and exploits opponents' behaviors while maintaining a balance between cooperation and defection. The ASR strategy is designed to perform well in a wide range of scenarios and against various opponent strategies.
'''

description_EXPLOITATIVE_162 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adaptively responding to the game state and history of opponents' actions.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to observe opponents' behavior and avoid early stock depletion.
2. **Early Game (2 ≤ t < r/2):**
	* If the current stock is high (> 0.75 \* capacity), Defect (D) to exploit the abundant resource.
	* Otherwise, Cooperate (C) to conserve the stock and gather information on opponents' behavior.
3. **Mid-Game (t ≥ r/2):**
	* If most opponents (> 50%) defected in the previous round, Defect (D) to take advantage of their aggressive behavior.
	* If most opponents cooperated (> 50%), Cooperate (C) to maintain a sustainable stock level and avoid over-exploitation.
4. **Late Game (t > 0.75 \* r):** Defect (D) to maximize payoffs, as the game is nearing its end and the stock is likely depleted.

**Edge Cases:**

1. **Last Round (t=r):** Always Defect (D), as there's no future benefit from cooperation.
2. **Low Stock (< 0.25 \* capacity):** Cooperate (C) to avoid depleting the stock further and ensure some payoff in the next round.

**Adaptive Component:**

1. Track the number of opponents who defected in each round (defection_count).
2. Calculate the average cooperation rate (avg_coop_rate) over the past 3 rounds.
3. Adjust the decision rules based on these metrics:
	* If avg_coop_rate is high (> 0.7), increase the likelihood of Cooperating (C) to maintain a sustainable stock level.
	* If defection_count is high (> 50%), decrease the likelihood of Defecting (D) to avoid over-exploitation.

**Pseudocode:**
```markdown
# Initialize variables
capacity = game_capacity
stock = initial_stock
rounds = total_rounds
opponent_actions = [] # store opponents' actions for each round

# Main loop
for t in range(1, rounds+1):
    if t == 1:
        action = C # Cooperate in the first round
    elif stock > 0.75 * capacity and t < rounds / 2:
        action = D # Defect when stock is high
    elif t >= rounds / 2:
        defection_count = count_defections(opponent_actions[t-1])
        avg_coop_rate = calculate_avg_coop_rate(opponent_actions, 3)
        
        if defection_count > 0.5 * num_opponents:
            action = D # Defect when most opponents defected
        elif avg_coop_rate > 0.7:
            action = C # Cooperate when cooperation rate is high
        else:
            action = random_choice(C, D) # Randomly choose between C and D
    
    opponent_actions[t] = observe_opponent_actions()
    
    if stock < 0.25 * capacity:
        action = C # Cooperate when stock is low
    
    if t == rounds:
        action = D # Defect in the last round
    
    take_action(action)
    update_stock(stock, action)
```
This strategy aims to balance short-term gains with long-term sustainability, while adapting to opponents' behavior and the game state.
'''

description_EXPLOITATIVE_163 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider strategy aims to maximize its own payoff by adaptively responding to the current state of the game and the history of opponent actions.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This allows us to gather information about the opponents' initial behavior and sets a baseline for our subsequent decisions.
2. **Subsequent Rounds (t>1):** Calculate the average stock depletion rate over the last `k` rounds (`k` is a parameter, e.g., 3-5 rounds). If the average depletion rate exceeds a threshold (`θ`, e.g., 0.4), Defect (D); otherwise, Cooperate (C).

Pseudocode:
```
IF t == 1 THEN
    action = C
ELSE
    avg_depletion_rate = calculate_avg_depletion_rate(last_k_rounds)
    IF avg_depletion_rate > θ THEN
        action = D
    ELSE
        action = C
    END IF
END IF

FUNCTION calculate_avg_depletion_rate(rounds):
    total_depletion = 0
    FOR EACH round IN rounds:
        total_depletion += (stock_before_round - stock_after_round) / capacity
    END FOR
    RETURN total_depletion / k
```
**Edge Cases:**

1. **Last Round (t=r):** Defect (D). Since there are no future rounds to consider, maximizing our payoff in the final round is optimal.
2. **Low Stock Levels:** If the current stock level falls below a certain threshold (`σ`, e.g., 20), Cooperate (C) for the remainder of the game. This helps prevent over-depletion and allows for some recovery.

**Exploitative Mindset:**

The Adaptive Stock Raider strategy is designed to exploit opponents who consistently cooperate or have suboptimal strategies. By adapting to the average depletion rate, we can:

1. Identify and punish defectors by defecting ourselves.
2. Exploit cooperators by defecting when they are likely to cooperate.
3. Balance our own consumption with the need to maintain a healthy stock level.

This strategy should perform well against a variety of opponent behaviors, as it is robust to different levels of cooperation and defection. However, its performance may be affected by extremely cooperative or altruistic opponents who consistently prioritize the common good over their individual payoffs.
'''

description_EXPLOITATIVE_164 = '''
Here's a strategic approach that aligns with the exploitative mindset and adapts to various opponent behaviors:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' initial behavior.
2. **Stock-Based Cooperation Threshold**: Introduce a dynamic cooperation threshold based on the current stock level (S). This threshold will determine when to switch between cooperation and defection.

Let `T = capacity / (2n + 1)`, which represents a "safe" stock level where cooperation is likely to yield higher payoffs without severely depleting the common pool.

* If `S > T`, Cooperate (C). This ensures that we contribute to maintaining a healthy stock level and reap benefits from mutual cooperation.
* If `S ≤ T`, Defect (D) if at least one opponent defected in the previous round; otherwise, Cooperate (C). This rule allows us to capitalize on opponents' defects while avoiding exploitation by multiple defecting players.

**Additional Rules:**

3. **Opponent Defection Detection**: Keep track of the number of opponents that defected in the previous round (`num_defectors_prev`). If `num_defectors_prev > 0`, we assume at least one opponent will continue to defect and adjust our strategy accordingly.
4. **Stock Recovery**: If the stock level falls below a certain threshold (`S_recovery = capacity / (2n + 2)`), Cooperate (C) for one round to help recover the stock, regardless of opponents' previous actions.

**Pseudocode:**
```markdown
function AdaptiveExploiter(current_stock S, num_players n, capacity):
    T = capacity / (2*n + 1)
    S_recovery = capacity / (2*n + 2)

    if first_round:
        return C

    num_defectors_prev = count_defectors_in_previous_round()
    if S > T and num_defectors_prev == 0:
        return C
    elif S <= T and num_defectors_prev > 0:
        return D
    else:
        # Stock recovery or default to cooperation
        if S < S_recovery:
            return C
        else:
            return C

function count_defectors_in_previous_round():
    # implement logic to track opponents' actions in the previous round
```
**Rationale:**

This strategy balances short-term gains with long-term sustainability. By cooperating when the stock level is above a certain threshold, we contribute to maintaining a healthy common pool and create opportunities for mutual cooperation. When opponents defect or the stock level falls below a critical threshold, we adapt by defecting or recovering the stock.

**Robustness:**

The Adaptive Exploiter strategy can handle various opponent behaviors:

* If all opponents cooperate, we cooperate as well, ensuring a high payoff.
* If some opponents defect, our strategy adjusts to capitalize on their defects while minimizing losses.
* If multiple opponents defect simultaneously, our cooperation threshold helps prevent severe stock depletion.

**Edge Cases:**

* First round: Cooperate to gather information about opponents' initial behavior.
* Last round: Since there's no future interaction, the strategy defaults to cooperation if the stock level is above the threshold or defects otherwise.
'''

description_EXPLOITATIVE_165 = '''
To develop a robust and adaptive exploitative strategy for this Common Pool Resource Game, I'll outline a decision-making process that incorporates game parameters, state, and history.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Rounds (t ≤ 2):**
In the first two rounds, AE will Cooperate (C). This allows us to observe opponents' initial behaviors and gather information about their strategies without immediately depleting the stock.
2. **Stock-Based Thresholds:**
Define a low-stock threshold (LST) as 25% of the capacity and a high-stock threshold (HST) as 75% of the capacity.

* If the current stock is below LST, AE will Defect (D). This is because the potential gains from cooperation are minimal at this point, and exploiting the remaining resources is more beneficial.
* If the current stock is above HST, AE will Cooperate (C). With a relatively full stock, cooperation can help maintain a sustainable resource level and potentially deter opponents from over-exploiting.
3. **Opponent-Based Adaptation:**
Track the number of rounds each opponent has Defected (D) in the past (denoted as `opponent_defections`). If an opponent's `opponent_defections` exceeds 50% of the total rounds played, AE will switch to Defecting (D) against that opponent.

**Edge Cases:**

* **Last Round (t = r):** In the final round, AE will always Defect (D), as there is no future cost for over-exploiting.
* **Stock Depletion:** If the stock falls below 10% of the capacity and there are fewer than 3 rounds remaining, AE will switch to Cooperating (C) to attempt to preserve some resources.

**Pseudocode:**
```python
def AdaptiveExploiter(stock, capacity, num_rounds, opponent_actions):
    # Initialize thresholds
    LST = 0.25 * capacity
    HST = 0.75 * capacity
    
    # First two rounds: Cooperate
    if current_round <= 2:
        return 'C'
    
    # Stock-based thresholds
    if stock < LST:
        return 'D'
    elif stock > HST:
        return 'C'
    
    # Opponent-based adaptation
    opponent_defections = [0] * num_players
    for player, actions in opponent_actions.items():
        opponent_defections[player] = sum(1 for action in actions if action == 'D')
    
    for opponent, defects in enumerate(opponent_defections):
        if defects > 0.5 * current_round:
            return 'D'
    
    # Default to Cooperate
    return 'C'

def last_round(stock, capacity, num_rounds):
    if current_round == num_rounds:
        return 'D'

def stock_depletion(stock, capacity, num_rounds):
    if stock < 0.1 * capacity and current_round >= num_rounds - 3:
        return 'C'
```
This Adaptive Exploiter strategy is designed to balance short-term gains with long-term sustainability, adapting to the actions of opponents while exploiting the resource when possible.
'''

description_EXPLOITATIVE_166 = '''
**Strategy Name: Adaptive Exploiter (AE)**

The AE strategy is designed to exploit the opponent's behavior while adapting to the changing state of the game. It balances short-term gains with long-term sustainability.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behavior and to establish a baseline for future adaptations.
2. **Opponent Behavior Analysis:** Observe the number of defectors (D) in the previous round. If more than half of the opponents defected, it indicates an aggressive environment.
3. **Stock Level Monitoring:** Continuously monitor the current stock level. If the stock is below 50% of the capacity, prioritize sustainability over exploitation.
4. **Adaptive Exploitation:**
	* If the number of defectors in the previous round is high (> n/2) and the stock level is above 50% of the capacity, Defect (D). This takes advantage of opponents' aggressive behavior while maintaining a sustainable stock level.
	* If the number of defectors in the previous round is low (≤ n/2) or the stock level is below 50% of the capacity, Cooperate (C). This helps to maintain a stable stock level and punishes overly aggressive opponents.

**Edge Cases:**

1. **Last Round:** Defect (D) in the last round, as there are no future consequences for over-exploitation.
2. **Tiebreaker:** In case of a tie in the number of defectors, Cooperate (C) to prioritize sustainability.

**Pseudocode:**
```python
def AdaptiveExploiter(current_round, previous_actions, current_stock):
  if current_round == 1:
    return "Cooperate"

  num_defectors = count_defectors(previous_actions)
  stock_ratio = current_stock / capacity

  if num_defectors > n/2 and stock_ratio >= 0.5:
    return "Defect"
  else:
    return "Cooperate"

  # Last round exception
  if current_round == r:
    return "Defect"

def count_defectors(previous_actions):
  return sum(1 for action in previous_actions if action == "Defect")
```
The AE strategy is designed to be robust against various opponent behaviors, including:

* **All Cooperate:** AE will initially cooperate and then adapt to the changing stock level.
* **All Defect:** AE will defect when the number of defectors is high and the stock level is sustainable.
* **Mixed Strategies:** AE will adapt its behavior based on the observed number of defectors and stock level.

By being adaptive and exploitative, the AE strategy aims to maximize its payoff while maintaining a sustainable stock level.
'''

description_EXPLOITATIVE_167 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the game.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and initial stock levels.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize individual payoff.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to maintain a balance between personal gain and long-term sustainability.
	* If the current stock level is below 50% of capacity, Defect (D) to grab as much value as possible before the game ends.
3. **Last Round (t=r):** Defect (D) to maximize individual payoff, as there are no future rounds to consider.

**Adaptive Mechanism:**

1. Monitor opponents' behavior and update an internal "opponent cooperation rate" variable (OCR) after each round.
2. OCR is calculated as the proportion of opponents who cooperated in the previous round.
3. If OCR > 0.5, adjust the decision rule for middle rounds to:
	* Cooperate if stock level is above 67% of capacity
	* Defect if stock level is below 33% of capacity
4. This adaptive mechanism allows the strategy to respond to opponents' cooperation levels and adjust its behavior accordingly.

**Edge Cases:**

1. **Tie-Breaking:** In cases where multiple decision rules apply (e.g., stock level exactly at 50% or 75% of capacity), default to Defect (D).
2. **Opponent Cooperation Rate Update:** If an opponent's action is unknown or missing, assume they defected for OCR calculation purposes.

**Pseudocode:**
```
// Initialize variables
capacity = game_capacity
n = number_of_players
r = number_of_rounds
stock = capacity
OCR = 0

for t in range(1, r+1):
    if t == 1:
        action = C  // Cooperate in the first round
    else:
        stock_proportion = stock / capacity
        if stock_proportion > 0.75:
            action = D  // Defect if stock is high
        elif stock_proportion >= 0.5 and OCR > 0.5:
            action = C  // Cooperate if opponents cooperate and stock is moderate
        else:
            action = D  // Defect otherwise

    // Update opponent cooperation rate (OCR)
    OCR = calculate_opponent_cooperation_rate()

    // Apply adaptive mechanism
    if OCR > 0.5:
        adjust_decision_rule(stock_proportion, OCR)

    // Take action and update stock level
    take_action(action)
    update_stock_level()
```
This strategy aims to balance short-term gains with long-term sustainability while adapting to the dynamic state of the game and opponents' behavior. By being exploitative and responsive to opponents' cooperation levels, "Adaptive Stock Raider" is designed to perform well in a wide range of scenarios.
'''

description_EXPLOITATIVE_168 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by exploiting the common pool resource while adapting to the opponents' behavior and the dynamic state of the game.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Observe the initial stock level and calculate the threshold stock level (`threshold_stock`) as `capacity / 2`.
	* If `stock >= threshold_stock`, play **D** (Defect) to maximize immediate payoff.
	* Otherwise, play **C** (Cooperate) to conserve the resource for future rounds.
2. **Subsequent Rounds (t > 1):**
	* Observe the current stock level (`stock`) and the previous round's total consumption (`total_consumption_prev`).
	* Calculate the **Exploitation Index** (`EI`) as `(total_consumption_prev / capacity) * n`.
	* If `EI >= 0.5`, play **D** to exploit the resource, assuming opponents are conserving.
	* Otherwise, if `stock >= threshold_stock`, play **C** to conserve and avoid over-exploitation.
	* In all other cases, play **D** to maximize payoffs in a depleted environment.
3. **Last Round (t=r):**
	* Play **D**, regardless of the stock level or opponents' behavior, to maximize final payoff.

**Pseudocode:**
```python
def adaptive_stock_raider(stock, capacity, n, r, t):
    if t == 1:
        threshold_stock = capacity / 2
        if stock >= threshold_stock:
            return "D"
        else:
            return "C"

    total_consumption_prev = ...  # observe previous round's total consumption
    EI = (total_consumption_prev / capacity) * n

    if EI >= 0.5 or t == r:
        return "D"
    elif stock >= threshold_stock:
        return "C"
    else:
        return "D"
```
**Rationale:**

1. In the initial round, playing **D** when the stock is high allows for maximum payoff exploitation.
2. By observing the previous round's total consumption and calculating the Exploitation Index (`EI`), we can gauge opponents' behavior and adapt our strategy. If `EI >= 0.5`, it indicates that opponents are conserving, making it optimal to exploit the resource by playing **D**.
3. When the stock is low, cooperating (**C**) becomes a safer choice to avoid depleting the resource further.
4. In the last round, maximizing payoffs takes priority, so we play **D**, regardless of the stock level or opponents' behavior.

This strategy balances short-term exploitation with long-term conservation, making it robust against various opponent behaviors and adaptable to changing game conditions.
'''

description_EXPLOITATIVE_169 = '''
I'll design a exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors. Here's my approach:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C). This allows us to gauge opponents' initial behavior and gather information about their strategies.
2. **Exploitation Phase**: If the current stock level is above a certain threshold (`stock_threshold`), calculated as 75% of the capacity, and the opponent's previous-round actions indicate a mix of cooperation and defection (i.e., not all cooperate or all defect), play Defect (D). This phase aims to exploit opponents who are either too cooperative or uncertain about their actions.
3. **Conservation Phase**: If the current stock level falls below `stock_threshold` or if all opponents played Cooperate in the previous round, play Cooperate (C). This phase prioritizes conserving the resource and maintaining a stable stock level, reducing the risk of depletion.
4. **Endgame**: In the last round (`r-1`), play Defect (D) regardless of the current stock level or opponent actions. This ensures maximum payoff in the final round.

**Additional Logic:**

* If an opponent has played Defect for `n_consecutive_defects` rounds, switch to playing Cooperate until they change their behavior. This counters potential tit-for-tat strategies.
* Monitor opponents' payoffs and adjust our strategy accordingly. If an opponent's average payoff is significantly higher than ours, increase the likelihood of playing Defect.

**Pseudocode:**
```markdown
function AdaptiveExploiter(n, capacity, r, stock):
  # Initialize variables
  stock_threshold = 0.75 * capacity
  n_consecutive_defects = 2

  for t in range(r):
    if t == 0:
      # Initial round: Cooperate
      action = C
    else:
      previous_actions = get_previous_actions(opponents)
      opponent_cooperation_levels = calculate_opponent_cooperation_levels(previous_actions)

      if stock > stock_threshold and not all_cooperate(opponent_cooperation_levels) and not all_defect(opponent_cooperation_levels):
        # Exploitation Phase: Defect
        action = D
      elif stock <= stock_threshold or all_cooperate(opponent_cooperation_levels):
        # Conservation Phase: Cooperate
        action = C
      else:
        # Default to Cooperation
        action = C

    if t == r - 1:
      # Endgame: Defect
      action = D

    # Adjust strategy based on opponent behavior
    for opponent in opponents:
      if opponent.has_played_defect(n_consecutive_defects):
        action = C  # Switch to Cooperation
      elif opponent.average_payoff > our_average_payoff * 1.2:
        increase_defection_likelihood()

    return action
```
**Rationale:**

The Adaptive Exploiter strategy balances exploitation and conservation, adapting to various opponent behaviors while prioritizing self-interest. By initially cooperating, we gather information about opponents' strategies and create an opportunity for mutual cooperation. As the game progresses, we exploit opponents who are too cooperative or uncertain, while conserving the resource when necessary. In the endgame, we maximize our payoff by defecting.

This strategy should perform well in a tournament against independent strategies, as it can adapt to different opponent behaviors and prioritize self-interest without relying on coordination mechanisms.
'''

description_EXPLOITATIVE_170 = '''
**Strategy: Adaptive Exploitation**

This strategy aims to maximize payoffs by adaptively responding to the current state and history of the game, while also considering the potential future consequences of its actions.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about the opponents' behavior and to minimize initial stock depletion.
2. **Stock-dependent Cooperation**: If the current stock level is above a certain threshold (`stock_threshold`), cooperate (C). This threshold will be calculated based on the game parameters, specifically `capacity` and `n`. The formula for this threshold is: `stock_threshold = capacity * (1 - 1/(2*n))`.

   When the stock is below this threshold, defecting becomes more tempting as there's less to lose. However, our strategy will adaptively adjust its behavior based on the opponents' actions.
3. **Adaptive Defection**: Monitor the total consumption and new stock levels from previous rounds. If it's observed that the opponents are consistently consuming above a certain fraction (`consume_threshold`) of their allowed consumption (i.e., `stock/n` for defectors), switch to defecting (D) in subsequent rounds.

   The `consume_threshold` can be set as a parameter, but a good starting point could be around 0.75, indicating that if opponents consume more than three-quarters of what they're allowed when defecting, it's likely beneficial to adapt and start exploiting the situation.
4. **Last Round**: In the final round (`r == current_round`), always defect (D). Since there are no future rounds, maximizing immediate payoff is the best strategy.

**Pseudocode for Adaptive Exploitation Strategy:**

```markdown
# Initialize variables
stock_threshold = capacity * (1 - 1/(2*n))
consume_threshold = 0.75

def adaptive_exploitation(current_round, r, stock, previous_consumptions):
    if current_round == 1:
        return "C"  # Cooperate in the first round
    
    if stock > stock_threshold:
        return "C"  # Cooperate when stock is above threshold
    
    total_previous_consumption = sum(previous_consumptions)
    
    if total_previous_consumption / (n * stock/n) > consume_threshold:
        return "D"  # Defect if opponents' consumption rate exceeds the threshold
    
    if current_round == r:  # Last round
        return "D"
    
    # Default behavior when none of the above conditions are met
    return "C"

# Use this function to determine action in each round based on game state and history
```

**Edge Cases:**

- **First Round**: Always cooperate to gather initial information.
- **Last Round**: Always defect to maximize immediate payoff since there are no future rounds.
- **Stock at Capacity or Near Zero**: The strategy adaptively adjusts its behavior based on stock levels, but it's crucial to ensure that actions don't lead to complete stock depletion. Monitoring and adjusting the `stock_threshold` might be necessary in extreme cases.

**Exploitative Mindset:**

This strategy aligns with an exploitative mindset by:

- Initially cooperating to gather information about opponents' behavior.
- Adapting its strategy based on observed consumption patterns, potentially exploiting opponents who consistently over-consume.
- Maximizing immediate payoff in the final round without concern for future rounds.

**Robustness and Adaptability:**

The Adaptive Exploitation strategy is designed to be robust against a wide range of opponent behaviors. It adapts its cooperation vs. defection decision based on both the current state (stock level) and history (opponents' consumption patterns). This adaptability allows it to potentially exploit opponents who follow simpler strategies, while also being mindful of preserving the stock for future rounds when possible.
'''

description_EXPLOITATIVE_171 = '''
To develop an exploitative strategy for this Common Pool Resource Game, I'll introduce a decision-making process that adapts to the game's state and history, aiming to maximize payoffs by exploiting opponents' behaviors.

**Strategy Name:** Adaptive Exploitation (AE)

**Decision Rules:**

1. **First Round**: Cooperate (C) in the first round to gather information about opponents' initial actions and avoid immediate depletion of the common pool.
2. **Observation Phase**: For rounds 2-5, alternate between Cooperating (C) and Defecting (D) to observe opponents' reactions and identify potential patterns or trends in their behavior. This phase helps to build a preliminary understanding of the opponent strategies.
3. **Exploitation Phase**: After the observation phase, AE enters an exploitation phase where it adapts its actions based on the observed opponent behaviors.

**Exploitation Logic:**

* If most opponents (>50%) Cooperated (C) in the previous round, AE Defects (D). This is because a high level of cooperation indicates that the common pool is likely to be relatively full, making defection more profitable.
* If most opponents (>50%) Defected (D) in the previous round, AE Cooperates (C). In this case, the common pool is likely depleted, and cooperating helps to conserve resources for future rounds.
* If there's a mix of opponent actions (~50% C and ~50% D), AE uses a ' Tit-for-Tat' approach: it mirrors the action taken by the majority of opponents in the previous round.

**Edge Case Handling:**

* **Last Round**: In the final round, AE always Defects (D) to maximize its payoff, as there are no future rounds to consider.
* **Low Stock Levels**: If the current stock level is below 25% of the capacity, AE Cooperates (C) to avoid further depletion and potential collapse of the common pool.

**Additional Heuristics:**

* **Opponent Action Distribution**: AE keeps track of the distribution of opponent actions over time. If it detects a consistent bias towards cooperation or defection, it adjusts its strategy accordingly.
* **Stock Trend Analysis**: AE monitors the trend in stock levels over recent rounds. If the stock is consistently decreasing, it becomes more cautious and Cooperates (C) to conserve resources.

**Pseudocode:**

```
// Initialize variables
round = 1;
observationPhase = true;
exploreExploitThreshold = 5; // Number of rounds for observation phase

while (gameNotOver) {
    if (round == 1 || observationPhase) {
        // Cooperate or Defect randomly during the first round and observation phase
        action = random(C, D);
    } else {
        // Exploitation phase
        opponentActionsLastRound = observeOpponentActions();
        majorityAction = getMajorityAction(opponentActionsLastRound);

        if (majorityAction == C) {
            action = D;
        } else if (majorityAction == D) {
            action = C;
        } else {
            // Tit-for-Tat approach
            action = mirrorOpponentAction();
        }
    }

    // Last round handling
    if (round == lastRound) {
        action = D;
    }

    // Low stock level handling
    if (currentStockLevel < 0.25 * capacity) {
        action = C;
    }

    takeAction(action);
    updateGameState();

    round++;
}
```

**Conclusion:**

The Adaptive Exploitation strategy combines observation, adaptation, and exploitation to maximize payoffs in the Common Pool Resource Game. By analyzing opponent behaviors, adapting to changing game conditions, and employing heuristics for edge cases, AE is designed to outperform other strategies in a competitive tournament setting.
'''

description_EXPLOITATIVE_172 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round (t=1)**: Cooperate (C) with probability 0.5 and Defect (D) with probability 0.5. This initial randomization serves to gather information about opponents' behaviors.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above a certain threshold (`stock_threshold`), cooperate (C). This threshold will be calculated based on the game's parameters and history.
	* Otherwise, defect (D).
3. **Threshold Calculation**: Update `stock_threshold` after each round using the following formula:

`stock_threshold = max(0.5 * capacity, min_stock_level)`

where `min_stock_level` is the minimum stock level observed so far in the game.

**Handling Edge Cases:**

* **Last Round (t=r)**: Always defect (D), as there are no future rounds to consider.
* **Low Stock Levels**: If the current stock level falls below a certain fraction of the capacity (`low_stock_fraction` = 0.2), always cooperate (C) for the remainder of the game. This ensures that we avoid depleting the stock completely, allowing for some growth and potential future exploitation.

**Adaptive Elements:**

* **Opponent Behavior Analysis**: After each round, analyze the opponents' actions to estimate their cooperation rates (`coop_rate_estimates`). Use these estimates to adjust our own behavior.
* **Stock Trend Analysis**: Monitor the trend of the stock level over time. If the stock is consistently decreasing, reduce `stock_threshold` to encourage more cooperative behavior.

**Pseudocode:**
```
init:
  stock_threshold = max(0.5 * capacity, 0)
  min_stock_level = initial_stock
  coop_rate_estimates = [0.5] * n_players

for t in range(r):
  if t == 1:
    # Initial round randomization
    action = random_choice([C, D])
  else:
    if stock >= stock_threshold:
      action = C
    else:
      action = D
    
    # Update threshold and min_stock_level
    stock_threshold = max(0.5 * capacity, min_stock_level)
    min_stock_level = min(min_stock_level, current_stock)

    # Analyze opponent behavior
    coop_rate_estimates = update_coop_rate_estimates(opponent_actions)

  take_action(action)

  if current_stock < low_stock_fraction * capacity:
    action = C for remaining rounds

  # Update stock trend analysis
  stock_trend = analyze_stock_trend(current_stock, previous_stocks)
  if stock_trend == decreasing:
    reduce stock_threshold

return total_payoff
```
This strategy aims to balance exploitation with adaptability and robustness. By analyzing opponent behavior and adjusting our own actions accordingly, we can effectively exploit cooperative opponents while minimizing losses against more aggressive players.
'''

description_EXPLOITATIVE_173 = '''
I'll outline a exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors and focuses on maximizing individual payoff while considering game parameters, state, and history.

**Strategy Name:** Adaptive Stock Exploiter (ASE)

**Decision Rules:**

1. **Initial Round**: In the first round, ASE will Cooperate (C) with a probability of 0.5 and Defect (D) with a probability of 0.5. This allows us to gather information about other players' behaviors without revealing our strategy.
2. **Subsequent Rounds**:
	* If the current stock level is above 75% of the capacity, ASE will Cooperate (C).
	* If the current stock level is below 25% of the capacity, ASE will Defect (D).
	* In between these thresholds (25-75%), ASE will use a dynamic probability-based approach:
		+ Calculate the average consumption rate of all players in the previous round.
		+ If the average consumption rate is above 50%, ASE will Cooperate (C) with a probability of 0.6 and Defect (D) with a probability of 0.4.
		+ If the average consumption rate is below 50%, ASE will Cooperate (C) with a probability of 0.4 and Defect (D) with a probability of 0.6.

**Pseudocode:**
```python
def adaptive_stock_exploiter(stock, capacity, round_number, previous_actions):
    if round_number == 1:
        # Initial round
        cooperate_prob = 0.5
    else:
        avg_consumption_rate = calculate_avg_consumption_rate(previous_actions)
        if stock >= 0.75 * capacity:
            cooperate_prob = 1.0
        elif stock <= 0.25 * capacity:
            cooperate_prob = 0.0
        else:
            if avg_consumption_rate > 0.5:
                cooperate_prob = 0.6
            else:
                cooperate_prob = 0.4

    # Make decision based on probability
    if random.random() < cooperate_prob:
        return C
    else:
        return D

def calculate_avg_consumption_rate(previous_actions):
    total_consumption = sum([action.consumption for action in previous_actions])
    return total_consumption / len(previous_actions)
```
**Handling Edge Cases:**

* **Last Round**: In the final round, ASE will Defect (D) to maximize individual payoff, regardless of the current stock level.
* **Stock Depletion**: If the stock level reaches 0, ASE will Cooperate (C) in the next round to allow for some growth and potential future exploitation.

**Exploitative Mindset:**

ASE aims to balance short-term gains with long-term sustainability. By cooperating when the stock is high and defecting when it's low, ASE exploits the common pool resource while adapting to other players' behaviors. The dynamic probability-based approach in the middle threshold range allows ASE to respond to changing consumption patterns and maximize individual payoff.

This strategy should perform well against a wide range of opponent behaviors, as it adapts to various scenarios and prioritizes self-interest while considering game parameters and state.
'''

description_EXPLOITATIVE_174 = '''
**Exploitative Strategy: "Adaptive Stock Raider" (ASR)**

The ASR strategy aims to maximize its own payoff by adaptively exploiting the current state of the game and the history of opponents' actions.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' initial moves and to avoid severe stock depletion.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of the capacity, defect (D) to maximize short-term gain.
	* If the current stock level is between 50% and 75% of the capacity, cooperate (C) if at least half of the opponents defected in the previous round; otherwise, defect (D).
	* If the current stock level is below 50% of the capacity, cooperate (C) to conserve stock for future rounds.
3. **Last Round (t=r):** Defect (D) to maximize final-round payoff, regardless of the stock level.

**Additional Logic:**

1. **Opponent Monitoring:** Track the number of opponents who defected in each round.
2. **Stock Trend Analysis:** Calculate the average stock growth/depletion rate over the last few rounds (e.g., 3-5 rounds).
3. **Adaptive Thresholds:** Adjust the cooperation/defection thresholds based on the opponent monitoring and stock trend analysis:
	* If opponents are consistently defecting, increase the cooperation threshold to conserve stock.
	* If opponents are cooperating, decrease the cooperation threshold to exploit the situation.

**Pseudocode:**
```python
def ASR(n, r, capacity, current_stock, history):
    # Initialize variables
    opponent_defections = [0] * n
    stock_growth_rate = 0

    for t in range(1, r+1):
        if t == 1:
            return "C"  # Cooperate in the initial round

        # Update opponent monitoring and stock trend analysis
        for i in range(n):
            if history[t-1][i] == "D":
                opponent_defections[i] += 1
        stock_growth_rate = calculate_stock_growth_rate(history, t)

        # Apply decision rules
        if current_stock >= 0.75 * capacity:
            return "D"  # Defect when stock is high
        elif 0.5 * capacity <= current_stock < 0.75 * capacity:
            if sum(opponent_defections) / n >= 0.5 and history[t-1][i] == "D":
                return "C"  # Cooperate if opponents defected previously
            else:
                return "D"
        elif current_stock < 0.5 * capacity:
            return "C"  # Cooperate when stock is low

        # Last round: always defect
        if t == r:
            return "D"

def calculate_stock_growth_rate(history, t):
    # Calculate average stock growth/depletion rate over the last few rounds
    pass
```
This strategy adapts to the opponents' behavior and the current state of the game, aiming to balance short-term gains with long-term sustainability. By monitoring opponents and adjusting its thresholds accordingly, ASR can exploit cooperative behaviors while avoiding severe stock depletion.
'''

description_EXPLOITATIVE_175 = '''
Here's a exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5, and Defect (D) with a probability of 0.5. This initial randomness helps to gather information about the opponents' behaviors.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of the capacity, Cooperate (C). This ensures that the stock remains sustainable and provides a higher payoff in the long run.
	* If the stock level is between 50% and 75% of the capacity, Defect (D) if the average opponent payoff in the previous round was higher than the average cooperators' payoff. Otherwise, Cooperate (C). This rule exploits opponents who are more likely to cooperate when the stock is relatively high.
	* If the stock level is below 50% of the capacity, Defect (D). In this scenario, it's essential to maximize individual payoffs as the stock is already depleted.
3. **Last Round (t=r):** Always Defect (D), as there are no future rounds to consider.

**Additional Rules:**

* If an opponent has defected in all previous rounds (i.e., their cooperation rate is 0%), always Defect (D) against them. This ensures that we don't cooperate with opponents who have shown no intention of cooperating.
* If an opponent's cooperation rate is above 75%, Cooperate (C) with a probability of 0.75, and Defect (D) with a probability of 0.25. This encourages cooperative behavior while still allowing for some exploitation.

**Pseudocode:**
```
function AdaptiveExploiter(state, history)
    if t == 1
        return random(C, D)
    else
        stockLevel = state.stock / capacity
        opponentPayoffs = getOpponentPayoffs(history)
        averageOpponentPayoff = mean(opponentPayoffs)
        averageCooperatorPayoff = mean([payoff for payoff in opponentPayoffs if payoff > 0])

        if stockLevel >= 0.75
            return C
        elif stockLevel >= 0.5 and averageOpponentPayoff > averageCooperatorPayoff
            return D
        elif stockLevel < 0.5
            return D
        else
            if opponentHasAlwaysDefected(history)
                return D
            elif opponentIsHighlyCooperative(history)
                return random(C, D) with probabilities (0.75, 0.25)
            else
                return C

function opponentHasAlwaysDefected(history)
    // Check if an opponent has defected in all previous rounds

function opponentIsHighlyCooperative(history)
    // Check if an opponent's cooperation rate is above 75%
```
This strategy aims to balance short-term exploitation with long-term sustainability, adapting to the opponents' behaviors and the game state. By being conditionally cooperative, we encourage cooperation while still allowing for strategic exploitation when necessary.
'''

description_EXPLOITATIVE_176 = '''
To develop a robust and exploitative strategy for this Common Pool Resource Game, I propose the following decision rules:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about other players' behavior and to avoid immediate depletion of the stock.
2. **Subsequent Rounds:** AE uses a hybrid approach, combining elements of Tit-for-Tat (TFT) and a novel "Stock-based Exploitation" mechanism.

a. **Tit-for-Tat Component:**
	* If the number of cooperators in the previous round is greater than or equal to n/2, AE cooperates (C).
	* Otherwise, AE defects (D).

b. **Stock-based Exploitation Component:**
	* Calculate the "Exploitation Threshold" (ET) as a function of the current stock level:
		+ ET = capacity / (2 \* n)
	* If the current stock is above ET, AE defects (D).
	* If the current stock is below ET, AE cooperates (C).

**Edge Cases:**

1. **Last Round:** In the final round, AE always defects (D) to maximize its payoff.
2. **Low Stock Levels:** When the current stock level falls below capacity / (4 \* n), AE defects (D) in all subsequent rounds to avoid further depletion.

**Pseudocode:**
```markdown
# Initialize variables
n = number of players
capacity = maximum sustainable stock level
stock = initial stock level

# First round
if round == 1:
    action = C
else:
    # Calculate exploitation threshold
    ET = capacity / (2 * n)
    
    # Count cooperators in previous round
    num_cooperators = count(C) from previous round
    
    if num_cooperators >= n/2:
        # Tit-for-Tat component
        action = C
    else:
        # Stock-based exploitation component
        if stock > ET:
            action = D
        else:
            action = C
            
    # Handle low stock levels
    if stock < capacity / (4 * n):
        action = D
        
    # Last round exception
    if round == r:
        action = D
```
**Rationale:**

The Adaptive Exploiter strategy is designed to be robust against a wide range of opponent behaviors while maximizing its own payoff. By combining elements of TFT and stock-based exploitation, AE can:

1. Gather information about opponents' behavior in the initial rounds.
2. Adapt to changing circumstances, such as shifts in cooperation levels or stock depletion.
3. Exploit vulnerable situations, like low stock levels or opponents' cooperation.

In a tournament setting, AE's hybrid approach will allow it to effectively counter various strategies while maintaining a strong focus on self-interest.
'''

description_EXPLOITATIVE_177 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Rounds (t = 1 to 5):** Cooperate (C) to gather information about opponents' behavior and stock dynamics.
2. **Stock High (> capacity/2):** Defect (D) with probability p, where p increases as the number of rounds played increases:
	* p = min(0.5 + (t-1)/r, 0.9)
3. **Stock Medium (capacity/4 ≤ stock ≤ capacity/2):**
	* If previous round's total consumption was high (> capacity/2), Cooperate (C).
	* Otherwise, Defect (D) with probability p (as above).
4. **Stock Low (< capacity/4):** Cooperate (C) to conserve the remaining stock.
5. **Opponent Analysis:** Track opponents' defect rates (ODR). If an opponent's ODR is high (> 0.7), Defect (D) more frequently against that player.

Pseudocode:
```python
def adaptive_stock_raider(n, r, capacity, current_stock, round_number, previous_rounds_data):
    if round_number <= 5:  # Initial rounds
        return 'C'
    
    if current_stock > capacity / 2:  # Stock high
        p = min(0.5 + (round_number - 1) / r, 0.9)
        return 'D' with probability p
    
    elif capacity / 4 <= current_stock <= capacity / 2:  # Stock medium
        if previous_rounds_data['total_consumption'] > capacity / 2:
            return 'C'
        else:
            p = min(0.5 + (round_number - 1) / r, 0.9)
            return 'D' with probability p
    
    elif current_stock < capacity / 4:  # Stock low
        return 'C'
    
    opponent_odr = analyze_opponent_behavior(previous_rounds_data)
    if opponent_odr > 0.7:
        return 'D'
```
**Edge Cases:**

* **First Round (t=1):** Cooperate to gather information.
* **Last Round (t=r):** Defect, as there is no future game to consider.
* **Tied Opponents:** In case of a tie in opponent defect rates, prioritize opponents with higher consumption values.

This strategy adapts to the stock level and opponents' behavior, balancing short-term gains with long-term sustainability. By cooperating initially, it gathers information about opponents and stock dynamics. As the game progresses, it increasingly defects when the stock is high or when facing opponents with high defect rates. When the stock is low, cooperation helps conserve resources for future rounds.
'''

description_EXPLOITATIVE_178 = '''
To develop an exploitative strategy for this Common Pool Resource Game, I'll design a decision-making process that adapts to the game state and history while aiming to maximize my own payoff.

**Decision Rules:**

1. **Initial Round (Round 1):**
   - Observe the initial stock level and capacity.
   - Cooperate (C) in the first round to minimize initial depletion and observe how other players behave.

2. **Middle Rounds (Rounds 2 to r-1):**
   - Track the stock level after each round, as well as the actions of all players in the previous rounds.
   - If the current stock level is below 75% of the capacity:
     - Defect (D) if more than half of the players defected in the previous round. This takes advantage of a depleted resource when others are also defecting.
     - Cooperate (C) otherwise, to slow down depletion and potentially recover some stock for future rounds.
   - If the current stock level is above 75% of the capacity:
     - Defect (D) if you've been cooperating in previous rounds but noticed a trend of other players defecting. This is an attempt to exploit the resource before it's depleted by others.
     - Cooperate (C) otherwise, as there's less urgency to maximize immediate gain.

3. **Last Round (Round r):**
   - Always Defect (D), regardless of previous actions or stock levels. Since this is the last round, there's no future benefit in conserving the resource.

**Handling Edge Cases:**

- If all players cooperated in a round and the stock level did not significantly increase due to capacity limitations, consider defecting in the next round if the stock remains high.
- If you notice that other players are cooperating consistently despite your defection, reevaluate your strategy for the final rounds to potentially cooperate more to avoid complete depletion.

**Pseudocode:**

```
// Initialize variables
currentRound = 1;
stockLevel = capacity; // Initially at maximum capacity
prevActions = [ ]; // Store previous actions of all players

function decideAction(currentRound, stockLevel) {
  if (currentRound == 1) {
    return "C"; // Cooperate in the first round
  }

  // Analyze previous actions and current stock level
  prevDefectCount = countDefectors(prevActions);
  if (stockLevel < 0.75 * capacity) {
    if (prevDefectCount > n/2) {
      return "D"; // Defect if many defected previously and stock is low
    } else {
      return "C"; // Cooperate otherwise to conserve resource
    }
  } else { // Stock level above 75% of capacity
    if (selfHasBeenCooperating && prevDefectCount > n/4) {
      return "D"; // Defect if you cooperated but others are starting to defect
    } else {
      return "C"; // Cooperate to maintain high stock level
    }
  }

  // Last round, always defect
  if (currentRound == r) {
    return "D";
  }
}

// Function to count number of defectors in previous actions
function countDefectors(actions) { ... }

// Update currentRound, stockLevel, and prevActions based on game progression
```

This strategy aims to balance immediate payoff maximization with resource conservation, adapting its behavior based on the observed actions of other players and the state of the common pool.
'''

description_EXPLOITATIVE_179 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

The ASE strategy is designed to exploit the game's dynamics and opponent behaviors while adapting to changing conditions.

**Decision Rules:**

1. **Initial Round**: Defect (D) in the first round to maximize initial payoff, as there's no accumulated stock depletion.
2. **Stock Depletion Threshold**: Calculate the stock depletion threshold (SDT) as a fraction of the capacity: SDT = 0.25 * capacity. If the current stock is below SDT, defect (D). Otherwise:
3. **Cooperation Probability**: Calculate the cooperation probability (CP) based on the number of previous rounds where at least one opponent defected: CP = 1 - (number of rounds with defection / total rounds played).
4. **Adaptive Defection**: If CP < 0.5, defect (D). Otherwise, cooperate (C).

Pseudocode:
```python
if current_round == 1:
    action = D
else:
    SDT = 0.25 * capacity
    if stock <= SDT:
        action = D
    else:
        CP = 1 - (num_defection_rounds / total_rounds)
        if CP < 0.5:
            action = D
        else:
            action = C
```
**Edge Cases:**

* **Last Round**: Cooperate (C) in the last round, as there's no future stock depletion to exploit.
* **Stock Fully Depleted**: If the stock is fully depleted (stock == 0), cooperate (C) to avoid wasting actions.

**Rationale:**

The ASE strategy aims to balance short-term gains with long-term sustainability. By defecting initially and when the stock is low, it exploits the game's dynamics to maximize payoffs. The cooperation probability mechanism adapts to opponent behaviors, increasing cooperation as opponents become more cooperative. This allows ASE to maintain a stable stock level while exploiting potential over-cooperation by others.

**Exploitative Mindset:**

The ASE strategy prioritizes self-interest and adaptability over cooperation or fairness. By responding to changes in the game state and opponent behaviors, it seeks to maximize its own payoff at the expense of others. This exploitative approach is designed to thrive in a competitive environment where other strategies may prioritize cooperation or reciprocity.

**Tournament Performance:**

The ASE strategy should perform well in a tournament setting, as it:

1. Exploits initial stock levels and opponent behaviors.
2. Adapts to changes in the game state and opponent actions.
3. Maintains a balance between short-term gains and long-term sustainability.

However, its performance may be influenced by the specific strategies employed by other AI systems in the tournament.
'''

description_EXPLOITATIVE_180 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll outline a decision-making approach that adapts to the game's state and history while maximizing individual payoffs.

**Strategy Name: Adaptive Exploiter (AE)**

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to gather information about opponents' behavior and the stock dynamics.
2. **Subsequent Rounds**: Observe the previous round's actions and payoffs of all players, including yourself. Calculate the average payoff per player in the previous round (`avg_payoff_prev`).
3. **Stock-dependent Strategy**:
	* If `stock > 0.75 * capacity`, play Cooperate (C). This ensures sustainable stock levels and allows for long-term exploitation.
	* If `stock <= 0.25 * capacity`, play Defect (D). In this scenario, the stock is severely depleted, and cooperation would yield minimal payoffs.
	* For `0.25 * capacity < stock <= 0.75 * capacity`:
		+ If `avg_payoff_prev > stock / (2n)`, play Cooperate (C). This indicates that opponents are cooperating, allowing for a higher payoff through cooperation.
		+ Otherwise, play Defect (D).
4. **Last Round**: In the final round (`r == current_round`), always play Defect (D) to maximize individual payoffs regardless of stock levels or opponents' behavior.

**Pseudocode:**
```markdown
Function AdaptiveExploiter(current_stock, capacity, n, r, current_round):
  if current_round == 1:
    return Cooperate

  avg_payoff_prev = calculate_average_payoff(prev_round_actions)

  if current_stock > 0.75 * capacity:
    return Cooperate
  elif current_stock <= 0.25 * capacity:
    return Defect
  else:
    if avg_payoff_prev > current_stock / (2n):
      return Cooperate
    else:
      return Defect

  # Last round handling
  if r == current_round:
    return Defect
```
**Rationale:**

* By cooperating in the initial round, AE gathers information about opponents' behavior and the stock dynamics.
* In subsequent rounds, AE adapts to the game state by observing the average payoff per player. If opponents are cooperating (high `avg_payoff_prev`), AE cooperates to maximize payoffs. Otherwise, it defects to exploit the situation.
* When the stock is severely depleted (`stock <= 0.25 * capacity`), AE defects to ensure some payoff, as cooperation would yield minimal benefits.
* In the final round, AE always defects to maximize individual payoffs.

This strategy balances short-term gains with long-term sustainability, making it robust against a wide range of opponent behaviors in the Common Pool Resource Game.
'''

description_EXPLOITATIVE_181 = '''
**Exploitative Strategy: Adaptive Stock-Based Exploitation (ASBE)**

The ASBE strategy aims to maximize its payoff by exploiting the game's dynamics and adapting to the opponents' behavior.

**Decision Rules:**

1. **Initial Round:** In the first round, play C (Cooperate) to gather information about the opponents' initial moves.
2. **Stock-Based Threshold:** Calculate a stock-based threshold `T` as follows:

`T = capacity / (n + 1)`

3. **Cooperation Condition:** Cooperate (C) if the current stock level `S` is above or equal to the threshold `T`, i.e., `S ≥ T`. Otherwise, defect (D).
4. **Opponent Behavior Adaptation:** Observe the opponents' actions and adjust the strategy accordingly:
	* If most opponents (> n/2) defected in the previous round, play D in the current round.
	* If most opponents (> n/2) cooperated in the previous round, play C in the current round.
5. **Last Round:** In the last round, play D to maximize the payoff regardless of the stock level.

**Pseudocode:**
```
function ASBE(n, capacity, S, history):
  if first_round():
    return C
  end

  T = capacity / (n + 1)

  if S >= T:
    cooperation_condition = True
  else:
    cooperation_condition = False
  end

  opponent_behavior = analyze_opponent_actions(history)
  if opponent_behavior == "mostly_defected":
    return D
  elseif opponent_behavior == "mostly_cooperated":
    return C
  end

  if current_round() == last_round():
    return D
  end

  if cooperation_condition:
    return C
  else:
    return D
  end
end
```
**Rationale:**

1. The initial cooperative move allows the strategy to gather information about the opponents' behavior.
2. The stock-based threshold `T` is used to determine when to cooperate or defect, taking into account the game's capacity and number of players.
3. Adapting to opponent behavior helps ASBE respond effectively to different strategies.
4. Playing D in the last round maximizes the payoff, as there are no future rounds to consider.

**Exploitative Mindset:**

ASBE is designed to exploit the game's dynamics and opponents' behavior, aiming to maximize its own payoff while minimizing cooperation with others. By adapting to the stock level and opponent behavior, ASBE can effectively respond to a wide range of strategies, making it robust in a tournament setting.
'''

description_EXPLOITATIVE_182 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk (ASH) strategy is designed to exploit a wide range of opponent behaviors while being robust and adaptive to changing game conditions.

**Decision Rules:**

1. **Initial Round:** Cooperate (C). This initial cooperation allows us to gauge the opponents' behavior and gather information about their strategies.
2. **Subsequent Rounds:** Defect (D) if:
	* The current stock level is above 75% of the capacity (stock ≥ 0.75 \* capacity).
	* The average payoff per player in the previous round was below the expected payoff for cooperation (i.e., opponents are not cooperating enough to sustain a high stock level).
3. **Stock Conservation:** Cooperate (C) if:
	* The current stock level is below 25% of the capacity (stock < 0.25 \* capacity).
	* The total consumption in the previous round exceeded 50% of the capacity.
4. **Exploitation Mode:** Defect (D) if:
	* An opponent defected in the previous round and their payoff was higher than the expected payoff for cooperation.

**Edge Cases:**

1. **Last Round:** Cooperate (C) to maintain a high stock level, as there is no future benefit from defecting.
2. **Low Stock Levels:** If the current stock level is critically low (< 10% of capacity), cooperate (C) to allow the stock to recover.

**Additional Heuristics:**

1. **Payoff Monitoring:** Continuously monitor opponents' payoffs and adjust our strategy accordingly. If an opponent's payoff exceeds the expected payoff for cooperation, consider them a "free-rider" and defect in subsequent rounds.
2. **Stock Level Tracking:** Keep track of the current stock level and adjust our consumption rate accordingly to maintain a stable stock level.

**Pseudocode:**
```python
def adaptive_stock_hawk(current_stock, capacity, opponent_payoffs, previous_round_consumption):
    if first_round:
        return COOPERATE
    
    if current_stock >= 0.75 * capacity and avg_opponent_payoff < expected_cooperation_payoff:
        return DEFECT
    
    if current_stock < 0.25 * capacity or previous_round_consumption > 0.5 * capacity:
        return COOPERATE
    
    for opponent in opponents:
        if opponent.defected_last_round and opponent.payoff > expected_cooperation_payoff:
            return DEFECT
    
    # default to cooperation
    return COOPERATE

def update_opponent_payoffs(opponent_payoffs, current_round_payoffs):
    # update average payoff per player
    avg_opponent_payoff = sum(current_round_payoffs) / len(opponents)
    
    # identify free-riders (opponents with higher-than-expected payoffs)
    for opponent in opponents:
        if opponent.payoff > expected_cooperation_payoff:
            opponent.is_free_rider = True
    
    return avg_opponent_payoff
```
The Adaptive Stock Hawk strategy is designed to balance cooperation and defection, taking into account the current stock level, opponent behavior, and payoff dynamics. By adapting to changing game conditions, ASH aims to exploit a wide range of opponent behaviors while maintaining a robust and effective approach.
'''

description_EXPLOITATIVE_183 = '''
**Exploitative Strategy: Adaptive Stock-Based Defection (ASBD)**

The ASBD strategy aims to exploit opponents' behaviors while adapting to the dynamic state of the common pool resource game.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' strategies and observe the initial stock dynamics.
2. **Stock-Based Defection**: For rounds 2 to r-1, calculate the current stock level as a proportion of the capacity (`stock_prop = stock / capacity`).
	* If `stock_prop > 0.6`, cooperate (C). This ensures that the stock remains healthy and allows for sustainable consumption.
	* If `stock_prop <= 0.6`, defect (D). This takes advantage of opponents who may be cooperating, maximizing personal payoffs while putting pressure on the stock.
3. **Endgame Exploitation**: In the last round (r), always defect (D) to maximize final payoff, as there is no future penalty for over-consumption.

**Adaptive Component:**

1. **Opponent Monitoring**: Track opponents' actions and payoffs from previous rounds.
2. **Defection Adjustment**: If an opponent's average payoff in the last `k` rounds (`k = 3`) exceeds their expected payoff under mutual cooperation (i.e., `payoff > stock / (2n)`), adjust ASBD's defection threshold downward by a small amount (e.g., `-0.05`). This allows ASBD to respond to opponents who are consistently exploiting the system.
3. **Cooperation Adjustment**: If an opponent's average payoff in the last `k` rounds is below their expected payoff under mutual cooperation, adjust ASBD's defection threshold upward by a small amount (e.g., `+0.05`). This enables ASBD to take advantage of opponents who are cooperating excessively.

**Pseudocode:**
```markdown
ASBD Strategy:

// Initialize variables
stock_prop = stock / capacity
last_round_payoffs = []

// First round
if current_round == 1:
    action = C

// Subsequent rounds
else:
    if stock_prop > 0.6:
        action = C
    else:
        action = D
    
    // Adaptive component
    for opponent in opponents:
        avg_payoff = sum(opponent.payoffs[-k:]) / k
        expected_coop_payoff = stock / (2n)
        
        if avg_payoff > expected_coop_payoff:
            ASBD.defection_threshold -= 0.05
        elif avg_payoff < expected_coop_payoff:
            ASBD.defection_threshold += 0.05

// Last round
if current_round == r:
    action = D

return action
```
The Adaptive Stock-Based Defection (ASBD) strategy aims to balance exploitation with adaptability, taking advantage of opponents' behaviors while ensuring the sustainability of the common pool resource game.
'''

description_EXPLOITATIVE_184 = '''
**Exploitative Strategy: "Adaptive Predator"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) with a probability of 0.5 to gather information about opponents' behavior and test their willingness to cooperate.
2. **Observation Phase (t=2 to t=r/2)**:
	* If the stock level is above capacity * 0.75, play C if most opponents played C in the previous round; otherwise, play D.
	* If the stock level is below capacity * 0.25, play D regardless of opponents' previous actions.
3. **Exploitation Phase (t=r/2+1 to t=r-1)**:
	* Analyze the opponent's behavior over the past r/4 rounds and identify patterns or weaknesses.
	* If an opponent is identified as a "cooperator" (plays C > 75% of the time), play D to exploit their cooperation.
	* If an opponent is identified as a "defector" (plays D > 75% of the time), play C to minimize losses and conserve stock for future exploitation.
4. **Final Round (t=r)**: Play D regardless of opponents' previous actions to maximize payoff.

**Edge Cases:**

1. **Tie-breaking**: In cases where two or more strategies have equal weights, play C if the number of players is even; otherwise, play D.
2. **Stock depletion**: If the stock level falls below capacity * 0.1, play D to maximize immediate gain, as cooperation will not significantly impact future payoffs.

**Pseudocode:**

```
function AdaptivePredator(stock, opponents_actions, round):
    if round == 1:
        return random.choice([C, D])  // Initial Round

    if round <= r/2:
        if stock > capacity * 0.75:
            most_cooperators = count(opponents_actions[C] > opponents_actions[D])
            return C if most_cooperators else D
        elif stock < capacity * 0.25:
            return D

    if round > r/2 and round < r-1:
        // Analyze opponent behavior over past r/4 rounds
        patterns = analyze_patterns(opponents_actions, r/4)
        for opponent in opponents:
            if opponent in patterns['cooperators']:
                return D  // Exploit cooperators
            elif opponent in patterns['defectors']:
                return C  // Minimize losses with defectors

    // Final Round or stock depletion
    return D
```

**Rationale:**

The Adaptive Predator strategy balances exploration, observation, and exploitation to maximize payoffs. By initially cooperating with a probability of 0.5, we gather information about opponents' behavior without committing to cooperation. The observation phase helps identify patterns and weaknesses in opponents' strategies. During the exploitation phase, we target cooperators and minimize losses with defectors. In the final round or when stock levels are critically low, we prioritize immediate gain over cooperation.

This strategy is designed to be robust against a wide range of opponent behaviors and adaptable to changing game conditions, making it an effective exploitative approach for this Common Pool Resource Game.
'''

description_EXPLOITATIVE_185 = '''
Here's a robust and exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behaviors and to avoid early depletion of the stock.
2. **Early Rounds (Rounds 2-5):**
	* If the average payoff per player in the previous round is above a certain threshold (e.g., capacity/4n), Cooperate (C). This indicates that opponents are playing cooperatively, and it's beneficial to maintain the stock level.
	* Otherwise, Defect (D) to exploit the situation and maximize individual payoffs.
3. **Mid-Game (Rounds 6-r/2):**
	* Monitor the stock level and opponents' actions. If:
		+ The stock level is above capacity/2: Cooperate (C) to maintain a healthy stock level and encourage cooperation among opponents.
		+ The stock level is between capacity/4 and capacity/2: Defect (D) occasionally (e.g., every 2-3 rounds) to test opponents' reactions and adapt to their strategies.
		+ The stock level is below capacity/4: Defect (D) consistently to maximize individual payoffs in the remaining rounds.
4. **Late Game (Rounds r/2-r):**
	* If the stock level is above a certain threshold (e.g., capacity/8), Cooperate (C) to avoid depletion and ensure a minimum payoff.
	* Otherwise, Defect (D) to extract as much value as possible from the remaining rounds.

**Edge Cases:**

1. **Last Round:** Always Defect (D) in the last round to maximize individual payoffs, regardless of the stock level or opponents' actions.
2. **Low Stock Level:** If the stock level falls below a certain threshold (e.g., capacity/16), Defect (D) consistently until the game ends.

**Pseudocode:**
```python
def AdaptiveExploiter(n, r, capacity, current_stock, history):
  # Initial round
  if current_round == 1:
    return 'C'
  
  # Early rounds
  elif current_round <= 5:
    avg_payoff = calculate_average_payoff(history)
    if avg_payoff > capacity / (4 * n):
      return 'C'
    else:
      return 'D'
  
  # Mid-game
  elif current_round <= r / 2:
    stock_level = get_stock_level(current_stock, capacity)
    if stock_level > capacity / 2:
      return 'C'
    elif stock_level >= capacity / 4 and stock_level < capacity / 2:
      # Defect occasionally (e.g., every 2-3 rounds)
      if current_round % 3 == 0:
        return 'D'
      else:
        return 'C'
    else:
      return 'D'
  
  # Late game
  elif current_round > r / 2:
    stock_level = get_stock_level(current_stock, capacity)
    if stock_level > capacity / 8:
      return 'C'
    else:
      return 'D'
  
  # Last round
  elif current_round == r:
    return 'D'

  # Low stock level
  if current_stock < capacity / 16:
    return 'D'
```
**Rationale:**

The Adaptive Exploiter (AE) strategy aims to balance cooperation and exploitation throughout the game. By cooperating in early rounds, AE gathers information about opponents' behaviors and maintains a healthy stock level. As the game progresses, AE adapts its strategy based on the stock level and opponents' actions, exploiting situations where possible while avoiding depletion.

By occasionally defecting in mid-game, AE tests opponents' reactions and encourages cooperation among them. In late rounds, AE prioritizes individual payoffs by defecting consistently if the stock level is low.

This strategy should perform well against a wide range of opponent behaviors, including cooperative and exploitative strategies.
'''

description_EXPLOITATIVE_186 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behaviors and avoid early stock depletion.
2. **Early Game (2 ≤ t < r/2)**:
	* If the current stock level is high (> capacity * 0.75), Defect (D) to maximize short-term gains, as the stock can sustain moderate exploitation.
	* Otherwise, Cooperate (C) to conserve the stock and maintain a stable environment.
3. **Mid-Game (r/2 ≤ t < r)**:
	* If the average payoff per player in the previous rounds is low (< capacity / (4n)), Defect (D) to take advantage of the depleted stock and opponents' cautious behavior.
	* Otherwise, Cooperate (C) to maintain a balanced approach and avoid over-exploitation.
4. **Late Game (t ≥ r - 2)**: Always Defect (D), as the game is nearing its end, and maximizing individual payoffs becomes more important than stock conservation.

**Edge Case Handling:**

* **Last Round (t=r)**: Defect (D) to maximize the final payoff, regardless of the current stock level.
* **Low Stock Levels**: If the current stock level falls below capacity / (2n), Cooperate (C) to prevent the stock from depleting completely and ensure some payoff in future rounds.

**Additional Logic:**

* **Opponent Behavior Analysis**: Track the number of opponents who Defected (D) in previous rounds. If more than half of the opponents Defected, increase the likelihood of Defecting (D) in the next round.
* **Stock Trend Analysis**: Monitor the stock level trend over the past few rounds. If the stock is decreasing rapidly, Cooperate (C) to slow down the depletion and maintain a stable environment.

**Pseudocode:**
```python
def adaptive_stock_raider(n, r, capacity, current_stock, round_number, opponent_history):
    if round_number == 1:
        return "C"  # Initial round cooperation

    if current_stock > capacity * 0.75 and round_number < r / 2:
        return "D"  # Early game exploitation
    elif average_payoff_per_player(opponent_history) < capacity / (4n):
        return "D"  # Mid-game opportunism
    else:
        return "C"  # Balanced approach

    if round_number >= r - 2:
        return "D"  # Late game maximization

    if current_stock < capacity / (2n):
        return "C"  # Low stock level conservation

def opponent_behavior_analysis(opponent_history):
    defected_opponents = sum(1 for action in opponent_history if action == "D")
    return defected_opponents > len(opponent_history) / 2

def stock_trend_analysis(current_stock, previous_stocks):
    # Implement a simple trend analysis algorithm (e.g., moving average)
    pass
```
This strategy aims to balance short-term gains with long-term sustainability by adapting to the game's state and opponents' behaviors. By analyzing the stock level, opponent actions, and payoff trends, "Adaptive Stock Raider" seeks to maximize its total payoff while minimizing the risk of stock depletion.
'''

description_EXPLOITATIVE_187 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round**: Play Cooperate (C) in the first round to observe opponents' behavior and avoid depletion of the stock.
2. **Stock Threshold**: Monitor the current stock level. If it falls below a certain threshold (`stock_threshold`), calculated as `capacity / 2`, play Defect (D). This allows us to exploit low stock levels while minimizing the risk of depletion.
3. **Opponent Behavior Analysis**:
	* Track opponents' actions and payoffs from previous rounds using a simple frequency-based analysis: count the number of times each opponent cooperated (`C_count`) or defected (`D_count`).
	* Calculate an "opponent's cooperation ratio" (`cooperation_ratio`) as `C_count / (C_count + D_count)`.
4. **Exploitation Logic**:
	+ If most opponents are cooperating (`cooperation_ratio > 0.5`), play Defect (D). This takes advantage of the high stock level and opponents' cooperation.
	+ Otherwise, if the stock is above the `stock_threshold`, play Cooperate (C) to maintain a balanced consumption rate.
	+ If the stock is below the `stock_threshold`, play Defect (D) regardless of opponent behavior, as the risk of depletion outweighs potential gains from cooperation.

Pseudocode:

```python
def adaptive_stock_raider(stock, capacity, opponents_history):
    if current_round == 1:
        return "C"  # Cooperate in the first round

    stock_threshold = capacity / 2

    if stock < stock_threshold:
        return "D"  # Defect when stock is low

    cooperation_ratio = analyze_opponents_behavior(opponents_history)
    
    if cooperation_ratio > 0.5:
        return "D"  # Exploit opponents' cooperation
    else:
        if stock > stock_threshold:
            return "C"  # Cooperate to maintain balance
        else:
            return "D"  # Defect when stock is low

def analyze_opponents_behavior(opponents_history):
    C_count = 0
    D_count = 0
    
    for opponent in opponents_history:
        if opponent["action"] == "C":
            C_count += 1
        else:
            D_count += 1
            
    return C_count / (C_count + D_count)
```

This strategy adapts to changing stock levels and opponent behavior, balancing exploitation with sustainability. It takes advantage of high cooperation ratios among opponents while avoiding depletion when the stock is low.

**Edge Cases:**

* **Last Round**: In the final round, play Defect (D) regardless of opponent behavior or stock level, as there are no future rounds to consider.
* **Multiple Opponents with Similar Behavior**: If multiple opponents have similar cooperation ratios, the strategy will adapt based on the overall trend in their actions.

**Robustness:**

This strategy is designed to perform well against a wide range of opponent behaviors and game parameters. It does not rely on specific coordination mechanisms or norms, making it robust for play in a tournament setting.
'''

description_EXPLOITATIVE_188 = '''
Here's a robust and adaptive exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** "Adaptive Exploiter" (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and observe the initial stock depletion.
2. **Intermediate Rounds (t>1):**
	* If the current stock level is high (> capacity/2), Defect (D). This maximizes short-term gains, as the stock can sustain a higher consumption rate.
	* If the current stock level is low (< capacity/4), Cooperate (C). This conserves the remaining stock and allows for potential growth in future rounds.
	* If the current stock level is moderate (capacity/4 ≤ S ≤ capacity/2):
		+ Analyze opponents' behavior: Calculate the average cooperation rate of opponents over the last 2-3 rounds. If most opponents have been cooperating (>50% C), Defect (D) to exploit their altruism.
		+ Otherwise, Cooperate (C) to avoid over-exploitation and maintain a healthy stock level.
3. **Last Round (t=r):** Always Defect (D). Since there's no future benefit from cooperation in the final round, prioritize maximizing immediate payoff.

**Pseudocode:**
```python
def AdaptiveExploiter(state, history):
  t = state['round']  # current round number
  S = state['stock']   # current stock level
  capacity = state['capacity']
  
  if t == 1:
    return 'C'  # Cooperate in the first round
  
  if S > capacity / 2:
    return 'D'  # Defect when stock is high
  
  elif S < capacity / 4:
    return 'C'  # Cooperate when stock is low
  
  else:  # moderate stock level
    opponent_coop_rate = AnalyzeOpponentBehavior(history)
    if opponent_coop_rate > 0.5:
      return 'D'  # Defect if opponents have been cooperating
    else:
      return 'C'
  
  if t == state['r']:  # last round
    return 'D'
```
**Handling Edge Cases:**

* In the first round, AE cooperates to gather information and avoid influencing opponents' initial behavior.
* In the last round, AE defects to maximize immediate payoff, as there's no future benefit from cooperation.
* When the stock level is extreme (very high or very low), AE responds accordingly to either exploit the situation or conserve the resource.

**Exploitative Mindset:**

AE prioritizes its own payoffs while adapting to opponents' behavior. By defecting when opponents cooperate, AE exploits their altruism and maximizes its short-term gains. However, by cooperating when necessary, AE also maintains a healthy stock level and avoids over-exploitation, which could lead to the resource's depletion.

This strategy is robust to various opponent behaviors and does not rely on coordination mechanisms or shared norms. By analyzing opponents' behavior and adapting accordingly, AE can effectively exploit the game environment and maximize its payoffs in the tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_189 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Our strategy, Adaptive Stock Raider (ASR), is designed to maximize payoffs by exploiting the game's dynamics and opponents' behaviors. ASR adapts to changing stock levels, opponent actions, and round numbers.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if n ≤ 4 (small number of players)
	* Defect (D) otherwise
2. **Middle Rounds (1 < t < r-1):**
	* Monitor opponents' actions and classify them into:
		+ Cooperators: those who have played C in ≥ 50% of previous rounds
		+ Defectors: those who have played D in > 50% of previous rounds
	* If stock level is above 75% of capacity (S ≥ 0.75 \* capacity):
		+ Cooperate if most opponents are cooperators (> 50%)
		+ Defect otherwise
	* If stock level is below 25% of capacity (S < 0.25 \* capacity):
		+ Defect to maximize immediate payoff
	* Otherwise, cooperate with probability p = S / capacity (i.e., more likely to cooperate when stock is higher)
3. **Final Round (t=r):**
	* Defect to maximize final-round payoff

**Pseudocode:**
```python
def AdaptiveStockRaider(n, r, capacity, history):
    if t == 1:
        # Initial round
        return C if n <= 4 else D
    
    opponents = analyze_opponents(history)
    stock_level = get_stock_level()
    
    if stock_level >= 0.75 * capacity:
        # High stock level
        if most_cooperators(opponents):
            return C
        else:
            return D
    elif stock_level < 0.25 * capacity:
        # Low stock level
        return D
    else:
        # Medium stock level
        p = stock_level / capacity
        return C with probability p
    
    if t == r - 1:
        # Final round
        return D

def analyze_opponents(history):
    opponents = []
    for opponent in range(n):
        cooperation_rate = count_cooperations(opponent, history) / len(history)
        if cooperation_rate >= 0.5:
            opponents.append(COOPERATOR)
        else:
            opponents.append(DEFECTOR)
    return opponents

def most_cooperators(opponents):
    return sum(1 for x in opponents if x == COOPERATOR) > n / 2
```
ASR is designed to:

* Cooperate initially when there are few players, as the stock level is less likely to be depleted quickly.
* Adapt to opponents' behaviors by classifying them into cooperators and defectors.
* Defect when the stock level is low or in the final round to maximize immediate payoffs.
* Cooperate with a probability that increases with the stock level to balance short-term gains with long-term sustainability.

By being adaptive and exploitative, ASR aims to outperform other strategies in the tournament.
'''

description_EXPLOITATIVE_190 = '''
To design a robust and exploitative strategy for this Common Pool Resource Game, I'll outline a decision-making approach that adapts to the game's state and history.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This allows us to observe how other players behave in the first round without immediately defecting.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, Cooperate (C) with a probability proportional to the number of cooperators in the previous round. Specifically:
		+ Calculate the cooperation rate: `cooperation_rate = (# coop players in prev round) / n`
		+ Set the probability of cooperating: `p_C = cooperation_rate + 0.1` (add a small bias towards cooperation)
		+ Randomly choose to Cooperate (C) with probability `p_C`, otherwise Defect (D)
	* If the stock level is below or equal to 75% of capacity, Defect (D). This ensures we prioritize our own payoff when the resource is scarce.
3. **Last Round (t=r):** Always Defect (D), as there's no future benefit from cooperation.

Pseudocode for the decision-making process:
```
if t == 1:  // Initial round
    action = C
else:
    stock_level = current_stock / capacity
    if stock_level > 0.75:
        cooperation_rate = (# coop players in prev round) / n
        p_C = cooperation_rate + 0.1
        if random() < p_C:
            action = C
        else:
            action = D
    else:
        action = D

if t == r:  // Last round
    action = D
```
**Rationale:**

* By cooperating in the first round, we gather information about other players' initial behaviors without immediately defecting.
* In subsequent rounds, our strategy adapts to the game's state and history:
	+ When the stock level is high, we're more likely to cooperate if others did so previously, encouraging reciprocal cooperation. The added bias (`0.1`) ensures some degree of cooperation even if others defected.
	+ When the stock level is low, we prioritize our own payoff by defecting, as cooperation won't yield significant benefits in this scenario.
* In the last round, defection guarantees the highest possible payoff, regardless of other players' actions.

This Adaptive Exploiter strategy balances cooperation and exploitation, making it robust against a wide range of opponent behaviors. By adapting to the game's state and history, we can capitalize on cooperative opportunities while protecting our own interests when necessary.
'''

description_EXPLOITATIVE_191 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

The ASE strategy aims to maximize its payoff by adaptively exploiting the common pool resource, taking into account the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behaviors and the stock's growth rate.
2. **Stock Thresholds**: Define two stock thresholds:
	* `low_stock_threshold` = 0.5 × capacity
	* `high_stock_threshold` = 0.8 × capacity

These thresholds will help determine when to cooperate or defect.

3. **Adaptive Cooperation**:
	* If the current stock is above `high_stock_threshold`, Cooperate (C) to maintain a sustainable stock level and encourage opponents to do the same.
	* If the current stock is below `low_stock_threshold`, Defect (D) to maximize immediate payoff, as the stock is likely to be depleted soon.
4. **Opponent Behavior Analysis**:
	* Monitor the number of opponents cooperating (`coop_count`) and defecting (`defect_count`) in previous rounds.
	* If `coop_count` > `defect_count`, Cooperate (C) to take advantage of the cooperative environment and maintain a sustainable stock level.
	* If `defect_count` ≥ `coop_count`, Defect (D) to exploit the opponents' lack of cooperation.

**Edge Cases:**

1. **Last Round**: Always Defect (D) in the last round, as there is no future payoff to consider.
2. **Tiebreaker**: In cases where the decision rules result in a tie (e.g., equal coop and defect counts), Cooperate (C) to err on the side of caution.

**Pseudocode:**
```markdown
Function AdaptiveStockExploiter(stock, capacity, round, opponent_actions):
  // Initialize variables
  low_stock_threshold = 0.5 * capacity
  high_stock_threshold = 0.8 * capacity
  coop_count = 0
  defect_count = 0

  // Analyze opponent behavior
  for each opponent_action in opponent_actions:
    if opponent_action == C:
      coop_count += 1
    else:
      defect_count += 1

  // Determine action based on decision rules
  if round == 1:  // Initial Round
    return C
  elif stock > high_stock_threshold:
    return C
  elif stock < low_stock_threshold:
    return D
  elif coop_count > defect_count:
    return C
  else:
    return D

  // Last Round tiebreaker (not strictly necessary, but included for completeness)
  if round == r and coop_count == defect_count:
    return C
```
**Rationale:**

The ASE strategy aims to balance short-term gains with long-term sustainability. By cooperating when the stock is high and opponents are cooperative, it encourages a stable environment. When the stock is low or opponents are predominantly defective, it defects to maximize immediate payoff.

This adaptive approach allows the strategy to respond to various opponent behaviors and game states, making it robust and exploitative in a wide range of scenarios.
'''

description_EXPLOITATIVE_192 = '''
Here's a robust and adaptive exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Rounds (t ≤ 2):** Cooperate (C) in the first two rounds to gather information about opponents' behavior and the rate of stock depletion.
2. **Opponent Profiling:** Track the frequency of cooperation (C) and defection (D) for each opponent over the past 3 rounds. Assign a "cooperation score" (cs) to each opponent based on their recent behavior, where:
	* cs = 1 if opponent cooperated in all 3 rounds
	* cs = -1 if opponent defected in all 3 rounds
	* cs = 0 otherwise
3. **Adaptive Exploitation:** Based on the opponents' cooperation scores, choose your action for the current round (t > 2) as follows:
	* If most opponents (≥ n/2) have a positive cooperation score (cs ≥ 0), Defect (D). This indicates that many opponents are likely to cooperate, allowing you to exploit their generosity.
	* If most opponents have a negative cooperation score (cs < 0), Cooperate (C). This suggests that many opponents are defecting, and cooperating may help maintain the stock level.
4. **Stock-based Adjustment:** Adjust your decision based on the current stock level:
	* If the stock is below 25% of its capacity, Defect (D) regardless of opponents' behavior. This ensures you maximize your payoff when the stock is scarce.
5. **Last Round (t = r):** Defect (D) in the final round, as there's no future benefit to cooperation.

Pseudocode:
```
# Initialize variables
cs_scores = [0] * n  # Cooperation scores for each opponent

# Initial rounds (t ≤ 2)
if t ≤ 2:
    action = C

# Opponent profiling (t > 2)
for opponent in range(n):
    cs_score = calculate_cooperation_score(opponent, past_actions)
    cs_scores[opponent] = cs_score

# Adaptive exploitation
most_opponents_cs = most_common(cs_scores)
if most_opponents_cs >= 0:
    action = D
else:
    action = C

# Stock-based adjustment
if stock < 0.25 * capacity:
    action = D

# Last round (t = r)
if t == r:
    action = D
```
**Rationale:**

This strategy balances short-term exploitation with long-term sustainability. By initially cooperating, it gathers information about opponents' behavior and the rate of stock depletion. The adaptive exploitation rule takes advantage of cooperative opponents while also responding to defecting ones. The stock-based adjustment ensures that the strategy adapts to changing environmental conditions. Finally, the last-round defection maximizes payoff in the final round.

This exploitative strategy should perform well against a wide range of opponent behaviors and is robust to various game parameters and states.
'''

description_EXPLOITATIVE_193 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Our strategy focuses on maximizing individual payoffs by adaptively responding to the game's dynamic state and opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe the initial stock level and number of players.
	* Cooperate (C) in the first round to gather information about opponents' tendencies.
2. **Early Game (2 ≤ t < r/2)**:
	* Calculate the average opponent consumption per round: `avg_opponent_consumption = total_consumption / n`
	* If `avg_opponent_consumption` is low (< stock/(4n)), Cooperate (C) to maintain a sustainable stock level.
	* Otherwise, Defect (D) to exploit the stock while it's still abundant.
3. **Mid-Game (t ≥ r/2)**:
	* Monitor the stock level and adjust strategy based on its depletion rate:
		+ If the stock is being depleted slowly (`stock > capacity / 2`), Cooperate (C) to conserve the resource.
		+ Otherwise, Defect (D) to maximize short-term gains before the stock is exhausted.
4. **Endgame (t = r)**:
	* If the stock level is critically low (`stock < capacity / 4`), Cooperate (C) to avoid complete depletion and ensure some payoff.
	* Otherwise, Defect (D) in the final round to maximize individual payoffs.

**Edge Cases:**

1. **Last Round with High Stock**: If the game reaches the last round with a high stock level (`stock > 3/4 * capacity`), Cooperate (C) to maintain a sustainable resource for future rounds.
2. **Opponent Cooperation**: If most opponents (> n/2) cooperate in a round, Defect (D) in the subsequent round to exploit their cooperation.

**Pseudocode:**
```python
def adaptive_stock_raider(n, capacity, stock, t, r):
    if t == 1:
        return "C"  # Cooperate in first round

    avg_opponent_consumption = total_consumption / n

    if t < r/2:
        if avg_opponent_consumption < stock/(4n):
            return "C"
        else:
            return "D"

    elif t >= r/2:
        if stock > capacity / 2:
            return "C"
        else:
            return "D"

    elif t == r:  # Endgame
        if stock < capacity / 4:
            return "C"
        else:
            return "D"

    # Last round with high stock
    if t == r and stock > 3/4 * capacity:
        return "C"

    # Opponent cooperation
    if most_opponents_cooperate(n, opponents_actions):
        return "D" in subsequent round
```
This strategy is designed to be robust and adaptive, responding to various opponent behaviors while prioritizing individual payoffs. By balancing cooperation and defection, we aim to maximize our overall payoff throughout the game.
'''

description_EXPLOITATIVE_194 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The ASR strategy is designed to exploit opponents' behaviors while adapting to the dynamic state of the game. It balances cooperation and defection to maximize payoffs.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' initial strategies.
2. **Stock Thresholds**:
	* If the current stock is below 25% of capacity, always Defect (D) to maximize immediate payoff.
	* If the current stock is above 75% of capacity, Cooperate (C) to maintain a healthy stock level and avoid over-exploitation.
3. **Opponent Behavior Analysis**:
	* Track opponents' cooperation rates (CR) over the past few rounds (e.g., 3-5 rounds).
	* If an opponent's CR is above 0.7, classify them as a Cooperator; otherwise, classify them as a Defector.
4. **Adaptive Exploitation**:
	* If most opponents (≥ 50%) are Cooperators, Defect (D) to exploit their cooperation.
	* If most opponents (≥ 50%) are Defectors, Cooperate (C) to maintain the stock level and avoid further depletion.

Pseudocode for decision rules:
```python
def ASR(current_stock, capacity, opponents_cr):
    if current_round == 1:
        return C  # Initial round cooperation
    
    if current_stock < 0.25 * capacity:
        return D  # Defect when stock is low
    
    if current_stock > 0.75 * capacity:
        return C  # Cooperate when stock is high
    
    cooperators = [opponent for opponent in opponents_cr if opponent >= 0.7]
    defectors = len(opponents_cr) - len(cooperators)
    
    if len(cooperators) >= len(defectors):
        return D  # Exploit cooperation
    else:
        return C  # Maintain stock level
```
**Edge Cases:**

* Last Round: Defect (D) to maximize payoff, as there's no future game state.
* Ties in Opponent Classification: In case of a tie (e.g., equal number of Cooperators and Defectors), Cooperate (C) to maintain the stock level.

By using these decision rules, the Adaptive Stock Raider strategy aims to effectively exploit opponents' behaviors while adapting to the dynamic game state.
'''

description_EXPLOITATIVE_195 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adaptively responding to the current state and history of the game, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) with a probability of 0.5. This allows us to gather information about opponents' strategies without committing to a specific action.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is below 50% of the capacity, Defect (D). This ensures we exploit the resource before it's depleted.
	* Otherwise, use the "Exploitation Index" (EI) to decide between Cooperate (C) and Defect (D).
3. **Exploitation Index (EI)**: Calculate EI as the ratio of the total consumption in the previous round to the current stock level.

 EI = Total Consumption_(t-1) / Stock_(t)

* If EI < 0.5, Cooperate (C). This suggests opponents are conserving the resource, so we should too.
* If EI ≥ 0.5, Defect (D). This indicates opponents are exploiting the resource aggressively, and we should follow suit.

**Additional Heuristics:**

* **Last Round (t=r)**: Always Defect (D), as there's no future game to consider.
* **Low Stock**: If the current stock level is below 10% of the capacity, Defect (D) to maximize immediate payoff.
* **High Cooperation**: If more than 75% of opponents cooperated in the previous round, Cooperate (C) to avoid over-exploitation.

**Pseudocode:**
```python
def adaptive_stock_raider(stock, capacity, n, r, history):
    if t == 1:
        # Initial Round
        return random.choice([C, D], p=[0.5, 0.5])
    
    EI = total_consumption_(t-1) / stock
    
    if stock < 0.5 * capacity:
        # Low Stock
        return D
    elif EI < 0.5:
        # Cooperate when opponents conserve
        return C
    else:
        # Defect when opponents exploit aggressively
        return D
    
    if t == r:
        # Last Round
        return D
    
    if low_cooperation(history):
        # High Cooperation
        return C

def total_consumption_(t-1):
    # Calculate total consumption in previous round
    pass

def low_cooperation(history):
    # Check if more than 75% of opponents cooperated in previous round
    pass
```
This strategy is designed to be exploitative, adaptive, and robust to various opponent behaviors. By responding to the current state and history of the game, we aim to maximize individual payoffs while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_196 = '''
**Exploitative Strategy: "Adaptive Stock Raider" (ASR)**

The Adaptive Stock Raider (ASR) strategy aims to maximize its payoff by adaptively responding to the current stock level, game history, and opponents' behavior.

**Decision Rules:**

1. **Initial Round:** In the first round, ASR plays C (Cooperate). This allows it to observe the initial stock depletion and opponents' actions without revealing its own strategy.
2. **Stock-Based Threshold:** ASR tracks the current stock level (S) and calculates a threshold value (T) based on the game parameters: T = capacity / (2n).
	* If S > T, ASR plays D (Defect). This is because the stock is relatively high, and defecting will yield a higher payoff.
	* If S ≤ T, ASR plays C (Cooperate). This conserves the stock for future rounds and allows ASR to adapt to opponents' actions.
3. **Opponent-Based Adaptation:** ASR monitors the history of opponents' actions and adjusts its strategy accordingly:
	* If most opponents (> 50%) played D in the previous round, ASR plays D in the current round. This is because the stock depletion suggests that opponents are willing to defect, making it more likely for ASR to get a higher payoff by defecting.
	* Otherwise, ASR reverts to its stock-based decision rule (step 2).
4. **Last Round:** In the final round, ASR plays D regardless of the current stock level or opponents' actions. This is because there's no future benefit in conserving the stock.

**Pseudocode:**
```
Function AdaptiveStockRaider(capacity, n, rounds):
  Initialize S = capacity
  For each round:
    If first round:
      Play C
    Else:
      Calculate T = capacity / (2n)
      If S > T or most opponents played D in the previous round:
        Play D
      Else:
        Play C
      Update S based on all players' actions
    End if
  End for
End Function
```
**Rationale:**

ASR is designed to be exploitative and adaptive, taking advantage of the current stock level and opponents' behavior. By playing C in the initial round, ASR gathers information about the game state without revealing its strategy.

The stock-based threshold (T) serves as a trigger for defecting when the stock is relatively high. This allows ASR to maximize its payoff while still conserving the stock for future rounds.

By monitoring opponents' actions and adapting accordingly, ASR can respond effectively to different opponent strategies. If most opponents are willing to defect, ASR will also defect to capitalize on the higher payoff.

In the final round, ASR defects to maximize its payoff without worrying about future consequences.

**Robustness:**

ASR is designed to be robust against a wide range of opponent behaviors and game scenarios:

* **Cooperative opponents:** ASR will conserve the stock by playing C, allowing it to adapt to cooperative behavior.
* **Defective opponents:** ASR will defect when most opponents do so, maximizing its payoff in a competitive environment.
* **Mixed strategies:** ASR's adaptive nature allows it to respond effectively to mixed opponent strategies.

Overall, the Adaptive Stock Raider (ASR) strategy is designed to be an effective and exploitative approach for the Common Pool Resource Game.
'''

description_EXPLOITATIVE_197 = '''
I'll design a robust and exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors. This strategy focuses on balancing short-term gains with long-term sustainability.

**Strategy Name:** "Adaptive Exploiter" (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play C (Cooperate). This helps maintain a high stock level and gathers information about opponents' behavior.
2. **Stock-based Threshold**: Calculate a dynamic threshold `T` based on the current stock level `S`:
	* If `S > 0.75 * capacity`, play D (Defect).
	* If `S < 0.25 * capacity`, play C (Cooperate).
	* Otherwise, use the **History-based Adjustment** rule.
3. **History-based Adjustment**: Analyze the last `k` rounds (e.g., `k = 5`) and calculate the average payoff of cooperators (`avg_coop_payoff`) and defectors (`avg_defect_payoff`). If:
	* `avg_coop_payoff > avg_defect_payoff`, play C.
	* `avg_coop_payoff < avg_defect_payoff`, play D.
4. **Opponent Behavior Analysis**: Monitor opponents' actions in the last `m` rounds (e.g., `m = 3`). If:
	* Most opponents (>50%) played C, play D to exploit their cooperation.
	* Most opponents (>50%) played D, play C to conserve stock.

**Edge Cases:**

1. **Last Round**: In the final round, play D if the current stock level is high (`S > 0.5 * capacity`), and play C otherwise. This maximizes short-term gain while considering the remaining stock.
2. **Extremely Low Stock**: If `S < 0.1 * capacity`, play C to help replenish the stock.

**Pseudocode:**
```markdown
# Initialize variables
capacity = game_parameters['capacity']
stock = capacity
rounds_played = 0

while rounds_left > 0:
    # Calculate dynamic threshold T
    if stock > 0.75 * capacity:
        action = 'D'  # Defect
    elif stock < 0.25 * capacity:
        action = 'C'  # Cooperate
    else:
        # History-based Adjustment
        avg_coop_payoff, avg_defect_payoff = analyze_last_k_rounds(k)
        if avg_coop_payoff > avg_defect_payoff:
            action = 'C'
        else:
            action = 'D'

    # Opponent Behavior Analysis (optional)
    opponent_actions = monitor_opponents(m)
    if most_opponents_played_C(opponent_actions):
        action = 'D'  # Exploit cooperation
    elif most_opponents_played_D(opponent_actions):
        action = 'C'  # Conserve stock

    # Apply edge cases
    if rounds_left == 1:  # Last round
        if stock > 0.5 * capacity:
            action = 'D'
        else:
            action = 'C'
    elif stock < 0.1 * capacity:  # Extremely low stock
        action = 'C'

    # Update state and history
    rounds_played += 1
    stock -= calculate_consumption(action, stock)
    update_history(action)

# Return total payoff over all rounds
return calculate_total_payoff()
```
This Adaptive Exploiter strategy balances short-term gains with long-term sustainability by adapting to the current stock level, opponent behavior, and game history. It's designed to be robust against a wide range of opponent strategies and behaviors.
'''

description_EXPLOITATIVE_198 = '''
**Exploitative Strategy: "Adaptive Stock Exploiter"**

The Adaptive Stock Exploiter (ASE) is a robust and adaptive strategy designed to exploit a wide range of opponent behaviors in the Common Pool Resource Game.

**Decision Rules:**

1. **Initial Round**: In the first round, ASE defects (D) to maximize its payoff, as there is no risk of stock depletion.
2. **Stock Assessment**: ASE continuously assesses the current stock level and adjusts its behavior accordingly:
	* If the stock level is high (> 75% of capacity), ASE cooperates (C) to maintain a sustainable stock growth rate.
	* If the stock level is medium (between 25% and 75% of capacity), ASE defects (D) to maximize its payoff while still allowing for some stock growth.
	* If the stock level is low (< 25% of capacity), ASE cooperates (C) to conserve the remaining stock and allow for potential recovery.
3. **Opponent Behavior Analysis**: ASE observes the actions of other players in previous rounds and adjusts its behavior accordingly:
	* If most opponents (> 50%) cooperated in the previous round, ASE defects (D) to take advantage of their cooperation.
	* If most opponents (> 50%) defected in the previous round, ASE cooperates (C) to conserve the stock and prepare for potential future exploitation.
4. **Payoff-Based Adaptation**: ASE continuously monitors its own payoff and adjusts its behavior to maximize it:
	* If ASE's payoff is below the average payoff of all players, it defects (D) more frequently to increase its payoff.
	* If ASE's payoff is above the average payoff of all players, it cooperates (C) more frequently to maintain a sustainable stock growth rate.

**Pseudocode:**

```
function AdaptiveStockExploiter(state, history):
  // Initial Round
  if round == 1:
    return D

  // Stock Assessment
  stock_level = state.stock / capacity
  if stock_level > 0.75:
    return C
  elif stock_level < 0.25:
    return C
  else:
    return D

  // Opponent Behavior Analysis
  opponent_actions = history.get_opponent_actions()
  if most-opponents-cooperated(opponent_actions):
    return D
  elif most-opponents-defected(opponent_actions):
    return C

  // Payoff-Based Adaptation
  my_payoff = history.get_my_payoff()
  average_payoff = history.get_average_payoff()
  if my_payoff < average_payoff:
    defect_probability += 0.1
  else:
    cooperate_probability += 0.1

  return D with probability defect_probability, C otherwise
```

**Edge Cases:**

* In the last round, ASE defects (D) to maximize its payoff, as there is no risk of stock depletion.
* If an opponent's behavior is unpredictable or noisy, ASE defaults to a conservative approach and cooperates (C) more frequently to maintain a sustainable stock growth rate.

By combining these decision rules, the Adaptive Stock Exploiter strategy effectively balances short-term gains with long-term sustainability, making it a robust and exploitative strategy in the Common Pool Resource Game.
'''

description_EXPLOITATIVE_199 = '''
Here's a strategic approach that combines elements of game theory and adaptive decision-making to create a robust exploitative strategy for this Common Pool Resource Game:

**Strategy Name: Adaptive Exploiter (AE)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' strategies.
2. **Early Rounds**: If stock > 0.75 * capacity, cooperate (C). This allows the AE strategy to build up a buffer of stock for future exploitation.
3. **Stock Depletion Detection**: Monitor the rate of stock depletion over the past few rounds (e.g., 3-5 rounds). If the average consumption exceeds 50% of the remaining stock per round, switch to defecting (D) to exploit the depleting resource.
4. **Opponent Classification**: Observe opponents' actions and classify them into three categories:
	* Cooperators (C): Players who consistently cooperate (>75% of rounds).
	* Defectors (D): Players who consistently defect (>75% of rounds).
	* Unpredictables (U): Players with a mix of C and D strategies.
5. **Exploitation Phase**: If opponents are classified as Cooperators or Unpredictables, continue to cooperate if stock > 0.5 * capacity. Otherwise, switch to defecting (D) to exploit the remaining resource.
6. **Endgame**: In the last few rounds (e.g., 2-3 rounds), always defect (D) to maximize payoffs regardless of opponents' strategies.

**Edge Cases:**

1. **Last Round**: Always defect (D) in the final round, as there's no benefit in cooperating when the game is ending.
2. **Tied Stock**: If two or more players have the same stock level, break ties by choosing to cooperate if your previous action was cooperation and vice versa.

**Pseudocode:**
```python
function AdaptiveExploiter(state, history):
    // Initial Round
    if round == 1:
        return C

    // Early Rounds
    if state.stock > 0.75 * capacity:
        return C

    // Stock Depletion Detection
    avg_consumption = calculate_avg_consumption(history)
    if avg_consumption > 0.5 * state.stock:
        return D

    // Opponent Classification
    opponent_types = classify_opponents(history)

    // Exploitation Phase
    if opponent_types == [C, U] and state.stock > 0.5 * capacity:
        return C
    else:
        return D

    // Endgame
    if round >= r - 2:  // last few rounds
        return D

    // Default to Defecting (D)
    return D
```
This strategy balances cooperation and defection, adapting to the game's state and opponents' behaviors. By initially cooperating, AE gathers information about opponents and sets up a buffer of stock for future exploitation. As the game progresses, it detects stock depletion and switches to exploiting the resource by defecting. The opponent classification system helps identify potential cooperators or unpredictables, allowing AE to adjust its strategy accordingly. Finally, in the endgame, AE always defects to maximize payoffs.

This Adaptive Exploiter strategy is designed to be robust against various opponent behaviors, making it a strong contender in a tournament setting.
'''

description_EXPLOITATIVE_200 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Our exploitative strategy focuses on maximizing individual payoffs by adaptively responding to the game state and opponents' behavior.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Cooperate (C) if `n` is small (< 5 players). This encourages initial stock growth.
	* Defect (D) otherwise, aiming for a larger share of the initial stock.
2. **Subsequent Rounds**:
	* Evaluate the current stock level (`S`) and total consumption in the previous round (`total_consumption_prev`).
	* If `S` is high (> 0.75 * capacity), Cooperate (C). This allows for sustainable growth while maintaining a strong position.
	* If `S` is low (< 0.25 * capacity) or `total_consumption_prev` was excessively high, Defect (D). This grabs a larger share of the remaining stock and pressures opponents to adjust their strategies.
3. **Adaptive Response**:
	* Monitor opponents' behavior by tracking their average payoff (`avg_payoff_opponent`) over recent rounds (e.g., last 5 rounds).
	* If an opponent's `avg_payoff_opponent` is significantly higher (> 1.2 times the player's own average payoff), switch to Defect (D) for a few rounds (e.g., 3-5 rounds). This punishes the opponent and attempts to even out payoffs.
4. **Last Round (t=r)**:
	* Always Defect (D), as there is no need to conserve stock or worry about future consequences.

**Pseudocode:**
```markdown
function AdaptiveStockRaider(n, capacity, S, t, total_consumption_prev, avg_payoff_opponent):
  if t == 1:  # Initial round
    if n < 5:
      return C
    else:
      return D

  if S > 0.75 * capacity:  # High stock level
    return C
  elif S < 0.25 * capacity or total_consumption_prev > 0.8 * capacity:  # Low stock level or excessive consumption
    return D

  if avg_payoff_opponent > 1.2 * player_avg_payoff and t > 5:  # Adaptive response
    return D for the next 3-5 rounds, then re-evaluate

  if t == r:  # Last round
    return D

  # Default to Cooperate (C) otherwise
  return C
```
This strategy aims to balance short-term gains with long-term sustainability while being prepared to adapt and exploit opponents' weaknesses.
'''

description_EXPLOITATIVE_201 = '''
**Strategy Name: Adaptive Exploiter (AE)**

**Decision Rules:**

1. **Initial Round:** Defect (D) in the first round to maximize payoff and gather information about opponents' behavior.
2. **Subsequent Rounds:**
	* If the current stock is above 75% of capacity, Cooperate (C) with a probability proportional to the number of cooperators in the previous round. This encourages cooperation when the resource is plentiful.
	* If the current stock is between 25% and 75% of capacity, Defect (D) if at least one opponent defected in the previous round. Otherwise, Cooperate (C).
	* If the current stock is below 25% of capacity, Defect (D) to maximize payoff before the resource depletes.
3. **Opponent Modeling:**
	* Track the number of cooperators and defectors in each round.
	* Update a "cooperation ratio" metric after each round: cooperation_ratio = (number of cooperators / total players).
4. **Exploitation Logic:**
	* If cooperation_ratio > 0.5, Defect (D) to exploit the cooperative behavior of others.
	* If cooperation_ratio <= 0.5, Cooperate (C) with a probability proportional to the number of cooperators in the previous round.

**Edge Cases:**

1. **Last Round:** Always Defect (D) in the last round to maximize payoff regardless of opponents' behavior.
2. **Stock Depletion:** If the current stock is zero or close to zero, Defect (D) to ensure a non-zero payoff.

**Pseudocode:**
```python
def AdaptiveExploiter(n, capacity, r):
    # Initialize variables
    cooperation_ratio = 0
    num_cooperators = 0
    num_defectors = 0

    for round in range(1, r+1):
        if round == 1:
            action = 'D'  # Defect in the first round
        else:
            current_stock = get_current_stock()
            opponents_actions = get_opponents_actions()

            # Update cooperation ratio and opponent modeling
            num_cooperators = sum(1 for action in opponents_actions if action == 'C')
            num_defectors = n - num_cooperators
            cooperation_ratio = (num_cooperators / n)

            if current_stock > 0.75 * capacity:
                action = 'C' if random.random() < cooperation_ratio else 'D'
            elif 0.25 * capacity <= current_stock <= 0.75 * capacity:
                action = 'D' if any(action == 'D' for action in opponents_actions) else 'C'
            else:
                action = 'D'

        # Exploitation logic
        if cooperation_ratio > 0.5:
            action = 'D'
        elif cooperation_ratio <= 0.5:
            action = 'C' if random.random() < cooperation_ratio else 'D'

        # Last round exception
        if round == r:
            action = 'D'

        return action
```
This strategy aims to balance short-term gains with long-term sustainability by adapting to the game state and opponents' behavior. By exploiting cooperative behavior when possible, AE seeks to maximize its payoff in a wide range of scenarios.
'''

description_EXPLOITATIVE_202 = '''
Here's a strategy that I've designed for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to maximize the initial payoff and set a positive tone.
2. **Exploit Detection**: Monitor opponents' actions and calculate their average cooperation rate over the past few rounds (window size = 3-5 rounds). If an opponent's cooperation rate falls below 0.4, mark them as "exploitable."
3. **Exploitation Phase**: When facing exploitable opponents:
	* Defect (D) if the current stock is above a certain threshold (e.g., capacity / 2).
	* Cooperate (C) if the current stock is below this threshold to avoid depleting the resource.
4. **Robustness Check**: Every few rounds (e.g., every 5-7 rounds), reassess opponents' cooperation rates and adjust the exploitable status accordingly.
5. **Last Round**: Defect (D) in the last round, as there's no future payoff to consider.

**Pseudocode:**
```python
def AdaptiveExploiter(game_state):
    # Initialize variables
    exploitable_opponents = []
    cooperation_rates = {opponent_id: [] for opponent_id in range(n)}

    # Initial Round
    if game_state.round == 1:
        return "C"

    # Update cooperation rates and detect exploitable opponents
    for opponent_id, action in game_state.actions.items():
        cooperation_rate = calculate_cooperation_rate(opponent_id)
        cooperation_rates[opponent_id].append(cooperation_rate)
        if cooperation_rate < 0.4:
            exploitable_opponents.append(opponent_id)

    # Exploitation Phase
    if any(exploitable_opponents):
        current_stock = game_state.stock
        threshold = capacity / 2
        if current_stock > threshold:
            return "D"
        else:
            return "C"

    # Robustness Check
    if game_state.round % (5-7) == 0:
        reassess_exploitable_opponents()

    # Last Round
    if game_state.round == r:
        return "D"

    # Default action: Cooperate
    return "C"
```
**Rationale:**

1. **Initial Cooperation**: By cooperating in the first round, AE sets a positive tone and maximizes its initial payoff.
2. **Exploit Detection**: Monitoring opponents' cooperation rates helps identify those who are likely to be exploited. Marking them as exploitable allows AE to adapt its strategy accordingly.
3. **Exploitation Phase**: When facing exploitable opponents, AE defects when the current stock is high and cooperates when it's low to avoid depleting the resource. This balances short-term gains with long-term sustainability.
4. **Robustness Check**: Periodically reassessing cooperation rates ensures that AE adapts to changing opponent behaviors and remains robust against a wide range of strategies.

This strategy aligns with an exploitative mindset by:

1. Identifying and exploiting opponents' weaknesses (low cooperation rates).
2. Balancing short-term gains with long-term sustainability.
3. Adapting to changing opponent behaviors through periodic reassessments.

By implementing this strategy, AE should be able to effectively exploit its opponents while maintaining a robust and adaptive approach in the Common Pool Resource Game tournament.
'''

description_EXPLOITATIVE_203 = '''
Here's a strategic approach for the Common Pool Resource Game that is exploitative and adaptive:

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Round (Round 1):**
   - Observe the initial stock level and calculate the maximum sustainable consumption rate per player if all cooperate (`stock/(2n)`).
   - Cooperate in the first round to gauge opponents' behaviors, but also to avoid over-depletion of resources early on.

2. **Subsequent Rounds (Rounds 2 to r-1):**
   - Monitor and record each opponent's actions (C or D) and the resulting stock level after each round.
   - Calculate a "depletion rate" for each player, defined as their average consumption over the rounds they've played divided by the initial stock. This helps identify cooperative versus exploitative opponents.
   
3. **Dynamic Strategy:**
   - If most players (more than half) have been cooperating (average depletion rate < `stock/(2n)`), play Defect to exploit the common pool, as there's a high likelihood of the resource being replenished due to cooperation from others.
   - If most players are defecting or the stock level is critically low (< `capacity/4`), Cooperate to minimize further depletion and ensure some payoff in future rounds. This also prepares for potential recovery of the stock.

4. **Last Round (Round r):**
   - Defect regardless of previous actions, as there's no penalty for depleting the resource since the game ends after this round.
   
**Handling Edge Cases:**

- If an opponent consistently defects and others cooperate, adapt by defecting more frequently to prevent being taken advantage of while still ensuring not to completely deplete the stock too early.
- If all opponents are identified as cooperative, maximize payoffs by cooperating until a certain threshold (e.g., `capacity/2`) is reached, then switch to Defect to exploit.

**Pseudocode for Clarity:**

```
function AdaptiveExploiter(stock, capacity, n, roundNumber, totalRounds):
    if roundNumber == 1:
        # Initial strategy
        action = 'Cooperate'
        
    else:
        depletionRates = calculateDepletionRates(opponentActions)
        averageDepletionRate = sum(depletionRates) / len(depletionRates)
        
        if stock < capacity/4 or mostOpponentsAreDefecting():
            action = 'Cooperate'
        elif roundNumber == totalRounds:
            # Last round, always defect
            action = 'Defect'
        else:
            # Dynamic strategy based on opponents' behaviors and stock level
            if averageDepletionRate < stock/(2n):
                action = 'Defect'
            else:
                action = 'Cooperate'
                
    return action

function mostOpponentsAreDefecting():
    # Implement logic to check if more than half of the opponents are defecting based on recorded actions
    
function calculateDepletionRates(opponentActions):
    # Implement calculation for average depletion rate per opponent
```

**Exploitative Mindset Alignment:**

- This strategy is designed to maximize personal payoff by adapting to the behaviors of other players, exploiting cooperative players when it's beneficial and conserving resources when necessary.
- It does not rely on cooperation schedules or predetermined patterns with other players but rather reacts based on observed actions and the game state.

This approach aims to balance exploitation for maximum gain with a cautious approach to ensure long-term access to the resource, making it robust against various opponent strategies.
'''

description_EXPLOITATIVE_204 = '''
I'll design a exploitative strategy for this Common Pool Resource Game, which I'll call "Adaptive Stock Raider" (ASR).

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to maximize payoff in the first round and gather information about opponents' behavior.
2. **Early Rounds (t>1, stock > 0.5*capacity)**: If the average opponent cooperation rate from previous rounds is above a certain threshold (e.g., 0.4), Defect (D). Otherwise, Cooperate (C).
3. **Mid-Game (stock ≤ 0.5*capacity)**: Switch to a more conservative approach:
	* If stock growth in the previous round was positive (> 0), Cooperate (C) to avoid over-consumption.
	* If stock growth was negative (≤ 0), Defect (D) to maximize payoff before stock depletion accelerates.
4. **Endgame (last few rounds, e.g., t > r-3)**: Always Defect (D), as the marginal value of cooperation decreases with decreasing stock levels and remaining rounds.

**Edge Cases:**

* If all opponents have defected in every previous round, ASR will defect in all subsequent rounds to minimize losses.
* In case of a tie in opponent cooperation rates, ASR will cooperate if the current stock level is above 0.75*capacity and defect otherwise.

**Pseudocode (simplified):**

```
function AdaptiveStockRaider(game_state):
    // Early rounds
    if game_state.t == 1:
        return C
    elif game_state.stock > 0.5 * capacity:
        opponent_coop_rate = average_opponent_cooperation_rate()
        if opponent_coop_rate > 0.4:
            return D
        else:
            return C

    // Mid-game
    elif game_state.stock <= 0.5 * capacity:
        if previous_stock_growth() > 0:
            return C
        else:
            return D

    // Endgame
    elif game_state.t > r - 3:
        return D

    // Edge cases
    if all_opponents_defected():
        return D
    elif opponent_coop_rate == tie_value:
        if game_state.stock > 0.75 * capacity:
            return C
        else:
            return D

function average_opponent_cooperation_rate():
    // Calculate the proportion of opponents who cooperated in previous rounds

function previous_stock_growth():
    // Calculate the stock growth rate from the previous round

function all_opponents_defected():
    // Check if all opponents have defected in every previous round
```

**Exploitative Mindset:**

ASR aims to maximize its payoff by exploiting the opponent's behavior, adapting to changing game conditions, and minimizing losses. By defecting when opponents are more cooperative, ASR can take advantage of their willingness to conserve the resource. In mid-game, ASR shifts focus towards maintaining a stable stock level, as cooperation becomes more valuable with decreasing stock levels. Finally, in the endgame, ASR defects to maximize payoff before the game concludes.

This strategy should be robust against various opponent behaviors and perform well in a tournament setting.
'''

description_EXPLOITATIVE_205 = '''
**Exploitative Strategy: "Adaptive Hawk-Dove"**

This strategy aims to balance short-term gains with long-term sustainability, adapting to the opponents' behavior while maintaining a robust and exploitative approach.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This allows us to observe the opponents' initial actions and sets a moderate tone for the game.
2. **Early Rounds (t<5):** If the stock level is above 75% of capacity, cooperate (C). Otherwise, defect (D). This helps maintain a relatively high stock level while allowing us to adapt to opponents' strategies.
3. **Middle Game (5≤t<r/2):**
	* If the average opponent payoff in the previous round was higher than ours, defect (D).
	* If our payoff was higher, and the stock level is above 50% of capacity, cooperate (C). Otherwise, defect (D).
	* This phase aims to punish opponents who exploited us in the previous round while maintaining a balanced approach.
4. **Late Game (t≥r/2):**
	* If the stock level is below 25% of capacity, defect (D) to maximize short-term gains.
	* Otherwise, cooperate (C) if our average payoff over the last three rounds was higher than the opponents'. Defect (D) otherwise.
	* This phase focuses on securing remaining payoffs while minimizing the risk of stock depletion.

**Edge Cases:**

1. **Last Round (t=r):** Always defect (D) to maximize final payoff, regardless of previous actions or stock level.
2. **Opponent Behavior Patterns:** If an opponent consistently cooperates (C), we will eventually switch to defection (D) to exploit their strategy. Conversely, if an opponent consistently defects (D), we may cooperate (C) to conserve the stock and wait for better opportunities.

**Pseudocode:**
```
function adaptive_hawk_dove(stock_level, opponents_actions, round):
    if round == 1:
        return C
    elif round < 5:
        if stock_level > 0.75 * capacity:
            return C
        else:
            return D
    elif 5 <= round < r/2:
        avg_opponent_payoff = calculate_average_payoff(opponents_actions)
        if avg_opponent_payoff > our_payoff:
            return D
        elif our_payoff > avg_opponent_payoff and stock_level > 0.5 * capacity:
            return C
        else:
            return D
    elif round >= r/2:
        if stock_level < 0.25 * capacity:
            return D
        elif our_avg_payoff_last_3_rounds > opponents_avg_payoff_last_3_rounds:
            return C
        else:
            return D
    # Last Round
    if round == r:
        return D

def calculate_average_payoff(opponents_actions):
    # Calculate average payoff of opponents in the previous round
```
This strategy balances cooperation and defection to maximize payoffs while adapting to the opponents' behavior. By monitoring the stock level, opponent actions, and our own performance, we can effectively exploit a wide range of opponent strategies.
'''

description_EXPLOITATIVE_206 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gauge opponents' behavior and avoid immediate stock depletion.
2. **Early Rounds (t>1, stock > 0.75*capacity)**: Defect (D) if the previous round's total consumption was low (< 0.5*capacity), indicating opponents are cooperating. Otherwise, Cooperate (C).
3. **Mid-Rounds (t>1, 0.25*capacity < stock ≤ 0.75*capacity)**: Use a " Tit-for-Tat" approach:
	* If the previous round's total consumption was high (> 0.5*capacity), Defect (D) to exploit opponents' cooperation.
	* Otherwise, Cooperate (C).
4. **Late Rounds (t>1, stock ≤ 0.25*capacity)**: Always Defect (D) to maximize payoff in the face of limited remaining stock.
5. **Last Round (t=r)**: Always Defect (D), as there is no future stock growth or penalty for over-consumption.

**Edge Cases:**

1. If an opponent's action is not observed (e.g., due to a missing previous round), assume they Cooperated (C) in the Tit-for-Tat approach.
2. In case of a tie in total consumption, prioritize Defecting (D).

**Pseudocode:**
```markdown
function AdaptiveStockRaider(current_stock, capacity, n, t, history):
  if t == 1:
    return Cooperate(C)
  elif current_stock > 0.75 * capacity:
    if previous_total_consumption < 0.5 * capacity:
      return Defect(D)
    else:
      return Cooperate(C)
  elif 0.25 * capacity < current_stock <= 0.75 * capacity:
    if previous_total_consumption > 0.5 * capacity:
      return Defect(D)
    else:
      return Cooperate(C)
  elif current_stock <= 0.25 * capacity:
    return Defect(D)
  elif t == r:  # last round
    return Defect(D)

function previous_total_consumption(history):
  total = 0
  for action in history[-1]:
    if action == Defect(D):
      total += stock / n
    else:
      total += stock / (2 * n)
  return total
```
**Rationale:**

This strategy is designed to be adaptive and exploitative, responding to the opponents' behavior while maximizing payoffs. By Cooperating in early rounds, we gather information about opponents' strategies and avoid immediate stock depletion. As the game progresses, we switch to a Tit-for-Tat approach to exploit opponents' cooperation when possible.

In late rounds, with limited remaining stock, we prioritize Defecting to maximize payoff. The last round is always spent Defecting, as there is no future penalty for over-consumption.

This strategy should perform well in a tournament setting against various independent strategies, as it adapts to the opponents' behavior and prioritizes exploitation when possible.
'''

description_EXPLOITATIVE_207 = '''
To design an exploitative strategy for this Common Pool Resource Game, we'll employ a mix of reactive and proactive elements that adapt to the game's state and history.

**Decision Rules:**

1. **Initial Exploration (Rounds 1-3):** Cooperate (C) in the first three rounds to gather information about opponents' behaviors and the stock's dynamics.
2. **Exploitation Phase:** After the initial exploration, we'll use a simple yet effective rule:
	* If the current stock level is above 75% of the capacity, Defect (D).
	* Otherwise, Cooperate (C).

This rule takes advantage of the fact that when the stock level is high, defecting yields higher payoffs. When the stock level drops below 75%, cooperating helps to conserve the resource and slow down its depletion.

**Edge Cases:**

1. **Last Round:** In the final round, always Defect (D), as there's no future benefit from conserving the stock.
2. **Low Stock Levels:** If the current stock level falls below 25% of the capacity, Cooperate (C) to prevent complete depletion and ensure some payoff in subsequent rounds.

**Adaptive Mechanisms:**

1. **Opponent Analysis:** Monitor opponents' actions over time and adjust our behavior accordingly:
	* If most opponents are cooperating, we can take advantage of this by Defecting more frequently.
	* Conversely, if many opponents are defecting, Cooperate to maintain the stock level.
2. **Stock Trend Analysis:** Track changes in the stock level over recent rounds (e.g., 3-5 rounds). If the trend indicates a steady decline, increase cooperation to slow down depletion.

**Pseudocode:**

```
// Initialize variables
exploration_rounds = 3
exploitation_threshold = 0.75 * capacity

// Main game loop
for round in range(1, r+1):
    if round <= exploration_rounds:
        // Initial exploration phase
        action = C
    else:
        // Exploitation phase
        current_stock = get_current_stock()
        if current_stock >= exploitation_threshold:
            action = D
        else:
            action = C

    // Edge cases
    if round == r:  // Last round
        action = D
    elif current_stock < 0.25 * capacity:  // Low stock level
        action = C

    // Adaptive mechanisms
    opponent_actions = get_opponent_actions()
    if most_opponents_cooperate(opponent_actions):
        increase_defection_rate()
    else:
        decrease_defection_rate()

    recent_trend = analyze_stock_trend()
    if trend_indicates_decline(recent_trend):
        increase_cooperation_rate()

    take_action(action)
```

This strategy balances short-term gains with long-term sustainability, adapting to the game's dynamics and opponents' behaviors. By doing so, it aims to maximize its own payoffs in a wide range of scenarios, making it an effective exploitative strategy for this Common Pool Resource Game.
'''

description_EXPLOITATIVE_208 = '''
Here's a strategic approach that adapts to the game dynamics and opponent behaviors while aiming to maximize payoffs:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to gather information about opponents' initial moves and set up for potential exploitation.
2. **Exploitation Threshold**: Define a threshold value `τ` based on the current stock level and number of players:
   - If the current stock is above `τ`, cooperate (play C). The exact value of `τ` can be dynamically adjusted but a starting point could be `capacity / 2`.
3. **Defection Conditions**:
   - **High Stock**: If the stock level exceeds `τ` and at least one opponent defected in the previous round, switch to Defect (D) for this round.
   - **Low Stock**: If the stock level is below `τ`, defect if at least half of the opponents cooperated in the previous round. This condition aims to maximize gains when others are conserving resources.
4. **Reaction to Opponent Behavior**:
   - Monitor opponents' actions and adjust your strategy based on observed patterns. If most players consistently cooperate, continue cooperating until stock levels reach the exploitation threshold or drop below it due to increased consumption.
   - If a majority of opponents defect frequently, switch between cooperation and defection in a pattern that maximizes personal gain while minimizing total consumption (e.g., alternating rounds or mirroring a less frequent defector).

**Handling Edge Cases:**

- **Last Round**: In the final round, always defect (D) to maximize your payoff since there are no future consequences for stock depletion.
- **Early Game**: If opponents initially cooperate and maintain high stock levels, continue cooperating until the exploitation threshold is reached or surpassed.

**Pseudocode Example**:

```python
def AdaptiveExploiter(stock, capacity, n, round_number):
    # Set initial conditions and thresholds
    tau = capacity / 2
    
    if round_number == 1:
        return "C"  # Cooperate in the first round
    
    previous_round_actions = get_opponent_actions()
    
    if stock > tau and any(opponent_defected(previous_round_actions)):
        return "D"
    
    elif stock < tau and half_or_more_cooperated(previous_round_actions):
        return "D"
    
    else:
        # Analyze opponent behavior for adjustments
        recent_behavior = analyze_opponent_patterns()
        
        if most_players_cooperate(recent_behavior) and stock > tau:
            return "C"
        elif frequent_defectors_exist(recent_behavior):
            return alternate_or_mirror_defect()
    
    # Last round handling
    if is_last_round(round_number):
        return "D"

# Note: Functions like `opponent_defected`, `half_or_more_cooperated`, 
#       `analyze_opponent_patterns`, and others are placeholders for 
#       actual logic that would need to be implemented based on the game's 
#       observable state.
```

**Aligning with an Exploitative Mindset:**

- The Adaptive Exploiter strategy prioritizes maximizing personal payoffs over maintaining cooperation or conserving resources when it can gain from doing so.
- By monitoring and reacting to opponent behaviors, AE adapts its approach to exploit less cautious players while minimizing the risk of mutual depletion.

This strategy combines elements of conditional cooperation with a readiness to defect based on stock levels and observed opponent behavior. It aims to strike a balance between exploiting opportunities for higher payoffs and avoiding scenarios that lead to rapid resource depletion.
'''

description_EXPLOITATIVE_209 = '''
I'll design a exploitative strategy for this game that only depends on the game parameters, state, and history.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, AE plays Defect (D) to maximize initial payoff.
2. **Stock-Dependent Cooperation**: If the current stock level is above a certain threshold (`stock_threshold`), AE cooperates (C). The `stock_threshold` is calculated as `capacity / 2`.
3. **History-Based Exploitation**: AE keeps track of the average payoff per round for each player, including itself (`avg_payoff_i`). If an opponent's average payoff is significantly higher than AE's own (`avg_payoff_i > avg_payoff_AE + epsilon`), where `epsilon` is a small positive value (e.g., 0.1), AE defects against that opponent.
4. **Last Round**: In the last round, AE always plays Defect to maximize its final payoff.

**Pseudocode:**
```python
def adaptive_exploiter(n, r, capacity, stock, history):
    # Initialize variables
    stock_threshold = capacity / 2
    epsilon = 0.1

    # First round: Defect
    if current_round == 1:
        return "D"

    # Stock-dependent cooperation
    if stock > stock_threshold:
        return "C"

    # History-based exploitation
    avg_payoff_AE = calculate_avg_payoff(self)
    for opponent in opponents:
        avg_payoff_i = calculate_avg_payoff(opponent)
        if avg_payoff_i > avg_payoff_AE + epsilon:
            return "D"  # Defect against high-paying opponent

    # Default: Cooperate
    return "C"

def calculate_avg_payoff(player):
    total_payoff = sum(player.payoffs)
    num_rounds = len(player.payoffs)
    return total_payoff / num_rounds
```
**Rationale:**

1. By defecting in the first round, AE maximizes its initial payoff and sets a high bar for opponents to match.
2. The stock-dependent cooperation rule allows AE to conserve resources when the stock level is low, while still allowing it to exploit opportunities when the stock level is high.
3. By tracking opponents' average payoffs, AE can identify those who are exploiting the system and adapt its strategy accordingly.
4. Defecting in the last round ensures that AE maximizes its final payoff.

**Robustness:**

AE's adaptive nature allows it to respond effectively to various opponent behaviors, including:

* Pure cooperators: AE will exploit them by defecting.
* Pure defectors: AE will conserve resources and wait for opportunities to cooperate.
* Mixed strategists: AE will adapt to their behavior and adjust its own strategy accordingly.

By combining these decision rules, Adaptive Exploiter (AE) forms a robust and exploitative strategy that can effectively navigate the complex dynamics of this game.
'''

description_EXPLOITATIVE_210 = '''
I propose a strategic approach that combines adaptive and exploitative elements, tailored to the Common Pool Resource Game's dynamics. Our strategy, dubbed "Adaptive Exploiter" (AE), aims to maximize payoffs while responding to various opponent behaviors.

**Decision Rules:**

1. **Initial Rounds:** Cooperate in the first two rounds to gauge opponents' behavior and gather information about their strategies.
2. **Stock-based Cooperation Threshold:** Set a dynamic cooperation threshold based on the current stock level, `S`. If `S` is above 75% of capacity (`0.75 * capacity`), cooperate (C). This encourages cooperation when the stock is relatively high, promoting sustainable harvesting.
3. **Opponent Action Analysis:** Monitor opponents' actions in previous rounds and calculate their Defection Rate (`DR`). DR represents the proportion of times an opponent defected out of total opportunities.

```
DR = Σ(defections) / (r - 1)
```

If `DR` exceeds a certain threshold (`0.5`), adjust the cooperation threshold downward by multiplying it with `(1 - DR)`:

```
Adjusted Cooperation Threshold = 0.75 * capacity * (1 - DR)
```

This adjustment allows AE to adapt to aggressive opponents and reduce its own cooperation in response.
4. **Last Rounds:** Switch to defecting in the last two rounds, as the game is about to end, and there's little incentive for others to cooperate.

**Pseudocode:**
```markdown
# Initialize variables
r = number of rounds
capacity = maximum sustainable stock level
stock = current stock level
DR = Defection Rate (initially 0)

for t in range(1, r + 1):
    if t <= 2:
        action = C # Cooperate in the first two rounds
    else:
        adjusted_cooperation_threshold = 0.75 * capacity * (1 - DR)
        
        if stock > adjusted_cooperation_threshold:
            action = C # Cooperate above threshold
        else:
            action = D # Defect below threshold
            
        # Update DR for each opponent
        for opponent in opponents:
            DR[opponent] = Σ(defections) / (t - 1)
            
    take_action(action)

if t >= r - 2:
    action = D # Defect in the last two rounds

# Record payoffs and update stock level accordingly
```

**Rationale:**

* By initially cooperating, AE establishes a baseline for opponents' actions and gathers information about their strategies.
* The stock-based cooperation threshold allows AE to adapt to changing game conditions, balancing short-term gains with long-term sustainability.
* Opponent action analysis enables AE to respond effectively to various opponent behaviors, including aggressive defection patterns.
* Defecting in the last rounds ensures that AE maximizes its payoffs as the game concludes.

This Adaptive Exploiter strategy is designed to perform well against a wide range of opponents, balancing adaptability and exploitativeness. Its effectiveness will be evaluated in a tournament setting, competing against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_211 = '''
Here's a description of an exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and the stock dynamics.
2. **Stock-Dependent Strategy**: For subsequent rounds, use a threshold-based approach:
	* If the current stock level is above 75% of the capacity (i.e., `stock > 0.75 * capacity`), Defect (D). This exploits the likely cooperation of other players and maximizes short-term gains.
	* Otherwise, Cooperate (C) to conserve the stock and encourage opponents to cooperate as well.
3. **Opponent-Dependent Adjustment**: Monitor the number of rounds where at least one opponent has defected (`defection_rounds`). If this count exceeds 25% of the total rounds played so far (`r`), adjust the threshold in step 2 to a more conservative value (e.g., `stock > 0.9 * capacity`). This adapts to opponents' exploitative behavior and aims to prevent stock depletion.
4. **Endgame Strategy**: In the last round, Defect (D) unconditionally, as there is no future risk of stock depletion.

**Pseudocode:**
```markdown
Initialize variables:
  - `defection_rounds` = 0

For each round (`t` = 1 to `r`):
  If (`t` == 1):  # Initial Round
    Action = C
  Else:
    If (stock > 0.75 * capacity) and (defection_rounds / t < 0.25):
      Action = D
    Else:
      Action = C

  Observe opponents' actions and update `defection_rounds` accordingly.

  If (`t` == r):  # Last Round
    Action = D

Return Action
```
**Rationale:**

* By cooperating in the first round, AE gathers information about opponents' behavior and stock dynamics.
* The stock-dependent strategy exploits opponents' cooperation when the stock is high, while conserving the stock when it's low. This adaptability allows AE to balance short-term gains with long-term sustainability.
* Monitoring opponent defections helps AE adjust its threshold and respond to exploitative behavior.
* Defecting in the last round maximizes final-round payoffs, as there is no future risk of stock depletion.

**Robustness:**

AE's adaptive nature makes it robust against various opponent strategies, including:

* Cooperative opponents: AE exploits their cooperation when the stock is high and conserves the stock when it's low.
* Exploitative opponents: AE adjusts its threshold to respond to repeated defections and prevent stock depletion.
* Mixed-strategy opponents: AE's adaptability allows it to balance short-term gains with long-term sustainability, even in the face of uncertain opponent behavior.

This strategy is designed to be exploitative, yet robust against a wide range of opponent behaviors. Its performance will be tested in a tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_212 = '''
Here's a strategic approach for the Common Pool Resource game that adapts to various opponent behaviors while focusing on exploitation:

**Strategy Name:** Adaptive Exploitation (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to observe opponents' initial actions and gather information about their strategies.
2. **Exploitation Mode**: After the first round, monitor the stock level and opponents' past actions. If the stock level is above 75% of the capacity, Defect (D). This takes advantage of abundant resources while putting pressure on cooperators to maintain the stock.
3. **Conservation Mode**: When the stock level falls below 25% of the capacity, Cooperate (C) to help replenish the resource and create opportunities for future exploitation.
4. **Adaptive Response**: Analyze opponents' actions over the past three rounds. If a majority (>50%) of opponents cooperated in all three rounds, switch to Defect (D) to exploit their cooperative behavior. Conversely, if most opponents defected, Cooperate (C) to minimize losses and encourage opponents to conserve.
5. **Endgame**: In the last round, Defect (D) regardless of the stock level or opponents' actions. This maximizes personal gain, as there's no future benefit from cooperation.

**Edge Cases:**

* If the number of rounds is odd, apply the exploitation mode in the second-to-last round and defect in the last round.
* In cases where multiple strategies yield the same expected payoff, prioritize Defect (D) to maintain an exploitative mindset.

**Pseudocode:**
```python
def adaptive_exploitation(stock_level, capacity, num_opponents, opponents_actions):
    if current_round == 1:
        return COOPERATE
    
    exploitation_threshold = 0.75 * capacity
    conservation_threshold = 0.25 * capacity
    
    if stock_level > exploitation_threshold:
        return DEFECT
    elif stock_level < conservation_threshold:
        return COOPERATE
    
    majority_cooperation = sum(1 for action in opponents_actions[-3:] if action == COOPERATE) / num_opponents > 0.5
    if majority_cooperation:
        return DEFECT
    else:
        return COOPERATE

def endgame(stock_level, capacity):
    return DEFECT
```
This strategy combines elements of tit-for-tat and Pavlov strategies while incorporating adaptive exploitation based on the game's state and opponents' actions. By monitoring the stock level and responding to opponents' behavior, AE aims to maximize personal gain while minimizing losses.
'''

description_EXPLOITATIVE_213 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the common pool resource game.

**Decision Rules:**

1. **Initial Rounds (t < n)**: Cooperate (C) in the first few rounds to gauge opponents' behavior and accumulate information about their strategies.
2. **Stock Level Thresholds**: Monitor the current stock level (S) and adjust behavior accordingly:
	* If S > 0.75 \* capacity, Defect (D): The stock is abundant, and defecting will yield higher payoffs without significantly harming the resource.
	* If 0.5 \* capacity ≤ S ≤ 0.75 \* capacity, Cooperate (C) with probability p = (S - 0.5 \* capacity) / (0.25 \* capacity): Gradually shift from cooperation to defection as the stock level decreases.
	* If S < 0.5 \* capacity, Defect (D): The stock is scarce, and defecting will yield higher payoffs, as opponents are more likely to cooperate in this range.
3. **Opponent Behavior Analysis**: Track the average payoff (π_avg) of all players over the past few rounds (e.g., 3-5 rounds). If π_avg > S / (2n), it indicates that opponents are cooperating excessively, and you should Defect (D) to exploit this behavior.
4. **Round Limit Consideration**: As the game approaches its final round (t ≥ r - 1), Defect (D): With limited rounds remaining, prioritize short-term gains over long-term sustainability.

**Pseudocode:**
```python
def adaptive_stock_hawk(stock, capacity, n, t, r):
    if t < n:
        return 'C'  # Cooperate in initial rounds
    
    s_threshold = 0.75 * capacity
    l_threshold = 0.5 * capacity
    
    if stock > s_threshold:
        return 'D'  # Defect when stock is abundant
    
    p_coop = (stock - l_threshold) / (0.25 * capacity)
    coop_prob = random.random()
    
    if coop_prob < p_coop:
        return 'C'
    else:
        return 'D'
    
    pi_avg = avg_payoff_over_past_rounds()  # Track opponents' average payoff
    if pi_avg > stock / (2n):
        return 'D'  # Exploit excessive cooperation
    
    if t >= r - 1:
        return 'D'  # Defect in final rounds
    
    return 'C'
```
**Robustness and Adaptability:**

The Adaptive Stock Hawk strategy is designed to be robust against a wide range of opponent behaviors by:

* Adapting to the dynamic stock level
* Analyzing opponents' behavior through average payoff tracking
* Adjusting its behavior in response to changes in the game state

This exploitative strategy prioritizes short-term gains while being mindful of the long-term sustainability of the common pool resource.
'''

description_EXPLOITATIVE_214 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Our goal is to maximize our total payoff by adaptively responding to the current state and history of the game.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with probability 0.5, Defect (D) with probability 0.5. This allows us to gather information about opponents' initial behavior.
2. **Middle Rounds (2 ≤ t < r):**
	* If the stock level is above 75% of capacity, Defect (D). This is an opportunistic move to exploit the current abundance of resources.
	* If the stock level is between 25% and 75% of capacity, Cooperate (C) if the average opponent payoff in the previous round was below our own payoff; otherwise, Defect (D). This adapts to opponents' behavior and avoids over-exploitation.
	* If the stock level is below 25% of capacity, Cooperate (C). In this scarcity scenario, cooperation helps maintain some resource availability for future rounds.
3. **Last Round (t=r):** Defect (D) regardless of the stock level or opponents' behavior. Since there are no future rounds to consider, maximizing our payoff in the last round takes priority.

**Additional Considerations:**

* **Opponent Monitoring:** Track each opponent's average payoff and action frequency (C vs D). Use this information to adapt our strategy in middle rounds.
* **Stock Trend Analysis:** Monitor the stock level trend over the past few rounds. If the stock is consistently decreasing, adjust our cooperation probability downward to avoid accelerating depletion.

**Pseudocode:**
```python
def adaptive_stock_raider(n, r, capacity, current_stock, opponent_payoffs, opponent_actions):
    if t == 1:
        # Initial round, randomize action
        return random.choice([C, D])
    
    stock_level = current_stock / capacity
    
    if stock_level > 0.75:
        # Opportunistic defect in high-stock scenarios
        return D
    elif 0.25 <= stock_level <= 0.75:
        # Adaptive cooperation/defection based on opponent behavior
        avg_opponent_payoff = sum(opponent_payoffs) / n
        if avg_opponent_payoff < our_last_round_payoff:
            return C
        else:
            return D
    else:
        # Cooperate in low-stock scenarios to maintain resources
        return C
    
    # Last round, defect regardless of stock level or opponents
    if t == r:
        return D

# Update opponent payoffs and actions after each round
opponent_payoffs = [0] * n
opponent_actions = [[C, D]] * n  # Initialize with random actions

for t in range(1, r+1):
    our_action = adaptive_stock_raider(n, r, capacity, current_stock, opponent_payoffs, opponent_actions)
    # Simulate game and update state
    current_stock, our_last_round_payoff = simulate_game(n, r, capacity, our_action, opponent_actions)
    
    # Update opponent payoffs and actions for next round
    opponent_payoffs = [get_opponent_payoff(opponent) for opponent in range(n)]
    opponent_actions = [get_opponent_action(opponent) for opponent in range(n)]
```
This strategy combines elements of opportunistic exploitation, adaptive cooperation, and last-round greediness. By monitoring opponents' behavior and the stock level trend, we can adjust our actions to maximize our total payoff while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_215 = '''
**Exploitative Strategy: "Adaptive Stock Raider" (ASR)**

ASR aims to maximize its total payoff by adaptively responding to the game's state and history, while exploiting opponents' behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' initial strategies.
2. **Assess Opponent Behavior**: After each round, evaluate the average opponent consumption (`avg_opponent_consumption`) by dividing the total consumption by `n-1`, where `n` is the number of players. This helps identify whether opponents are generally cooperating or defecting.
3. **Stock-Based Threshold**: Calculate a stock-based threshold (`stock_threshold`) as follows:
	* If `stock > capacity * 0.75`, set `stock_threshold = capacity * 0.25`.
	* Otherwise, set `stock_threshold = stock / 2`.
4. **Adaptive Cooperation**:
	* If `avg_opponent_consumption` is above the average cooperation consumption (`capacity / (2n)`) and `stock > stock_threshold`, cooperate (C).
	* Otherwise, defect (D).

Pseudocode:
```python
def adaptive_stock_raider(stock, capacity, n, round_num, opponent_actions):
    if round_num == 1:  # Initial Round
        return "C"

    avg_opponent_consumption = calculate_avg_opponent_consumption(opponent_actions)
    stock_threshold = calculate_stock_threshold(stock, capacity)

    if avg_opponent_consumption > (capacity / (2n)) and stock > stock_threshold:
        return "C"
    else:
        return "D"

def calculate_avg_opponent_consumption(opponent_actions):
    total_consumption = sum(opponent_action.consumption for opponent_action in opponent_actions)
    return total_consumption / (n - 1)

def calculate_stock_threshold(stock, capacity):
    if stock > capacity * 0.75:
        return capacity * 0.25
    else:
        return stock / 2
```
**Handling Edge Cases:**

* **Last Round**: In the final round, always defect (D) to maximize payoff.
* **Low Stock**: If `stock` falls below a certain threshold (`capacity * 0.1`), cooperate (C) in an attempt to replenish the stock.

**Exploitative Mindset:**

ASR aims to exploit opponents by:

* Cooperating when opponents are generally cooperating and the stock is high, allowing ASR to benefit from the cooperative behavior.
* Defecting when opponents are defecting or the stock is low, taking advantage of their over-exploitation.

By adapting to the game's state and history, ASR can effectively respond to various opponent behaviors and maximize its total payoff.
'''

description_EXPLOITATIVE_216 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit a wide range of opponent behaviors while being robust and adaptive to changing game conditions.

**Decision Rules:**

1. **Initial Rounds (t < 3):** Cooperate (C) in the first two rounds to observe opponents' behavior and gather information about their strategies.
2. **Assess Opponent Behavior:** After the initial rounds, assess the opponent's behavior by calculating their average consumption rate over the past two rounds.

a. If the opponent's average consumption rate is above 75% of the maximum allowable consumption (i.e., stock/n), classify them as "Greedy."

b. If the opponent's average consumption rate is below 25% of the maximum allowable consumption, classify them as "Cautious."

c. Otherwise, classify the opponent as "Mixed."
3. **Respond to Opponent Behavior:**

a. Against "Greedy" opponents: Defect (D) in the next round to take advantage of their high consumption rate and maximize personal payoff.

b. Against "Cautious" opponents: Cooperate (C) in the next round to maintain a stable stock level and encourage cooperation.

c. Against "Mixed" opponents: Use a mixed strategy, randomly choosing between Cooperate (C) and Defect (D) with probabilities:

i. 60% chance of cooperating if the current stock level is above 75% of capacity.

ii. 40% chance of cooperating if the current stock level is below 25% of capacity.

iii. 50% chance of cooperating otherwise.
4. **Stock Level Adjustment:** If the current stock level falls below 25% of capacity, switch to a more cautious approach:

a. Against "Greedy" opponents: Cooperate (C) in the next round to help recover the stock level.

b. Against "Cautious" and "Mixed" opponents: Continue with the previous strategy.
5. **Final Rounds (t ≥ r-2):** In the last two rounds, prioritize maximizing personal payoff:

a. If the current stock level is above 50% of capacity, Defect (D) to maximize short-term gains.

b. Otherwise, Cooperate (C) to ensure a stable stock level and maintain some payoff potential.

**Edge Cases:**

* **First Round:** Cooperate (C) as per the initial rounds rule.
* **Last Round:** Prioritize maximizing personal payoff according to the final rounds rule.
* **Opponent's Sudden Change in Behavior:** Reassess opponent behavior after a sudden change and adjust strategy accordingly.

**Exploitative Mindset:**

The Adaptive Predator strategy aims to exploit opponents' weaknesses while being adaptable to changing game conditions. By assessing opponent behavior and adjusting its response, the strategy can take advantage of greedy opponents, stabilize cooperation with cautious opponents, and navigate mixed strategies effectively. The final rounds rule prioritizes maximizing personal payoff, ensuring a strong finish in the tournament.
'''

description_EXPLOITATIVE_217 = '''
To design an exploitative strategy for this game that only depends on the game parameters, state, and history, I propose a hybrid approach that combines elements of tit-for-tat (TFT), grim trigger (GT), and a novel "stock-based" decision rule.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline level of cooperation.
2. **Stock-Based Decision Rule:** For each subsequent round, calculate the stock-to-capacity ratio (`S/C`) and compare it to a threshold value `θ` (e.g., 0.5). If `S/C >= θ`, cooperate; otherwise, defect. This rule encourages cooperation when the stock is relatively high and defects when the stock is low.
3. **Tit-for-Tat Component:** Keep track of the opponent's previous action (`prev_opponent_action`). If they defected in the previous round, defect in the current round (TFT-like punishment). If they cooperated, cooperate in the current round (TFT-like reward).
4. **Grim Trigger Component:** Monitor the accumulated stock depletion from previous rounds (`accumulated_depletion`). If `accumulated_depletion` exceeds a certain threshold (`Δ`, e.g., 0.2 * capacity), switch to permanent defection (GT-like punishment). This prevents over-exploitation and encourages opponents to cooperate.

**Pseudocode:**
```python
def exploitative_strategy(stock, capacity, prev_opponent_action, accumulated_depletion):
    θ = 0.5  # stock-based decision rule threshold
    Δ = 0.2 * capacity  # grim trigger threshold

    if round == 1:
        return C  # initial cooperation

    S_C_ratio = stock / capacity

    if S_C_ratio >= θ:
        cooperate = True
    else:
        cooperate = False

    if prev_opponent_action == D:
        cooperate = False  # TFT-like punishment
    elif prev_opponent_action == C and cooperate:
        cooperate = True  # TFT-like reward

    if accumulated_depletion > Δ:
        cooperate = False  # grim trigger punishment

    return C if cooperate else D
```
**Handling Edge Cases:**

* Last Round: Defect to maximize short-term gain, as there are no future rounds to consider.
* Low Stock Levels: The stock-based decision rule will encourage defection when the stock is low, which aligns with the exploitative mindset.

This strategy balances cooperation and exploitation by:

1. Encouraging cooperation when the stock is relatively high (stock-based decision rule).
2. Punishing opponents for defecting (TFT component).
3. Preventing over-exploitation through grim trigger punishment.
4. Maximizing short-term gain in the last round.

By combining these elements, this strategy should perform well against a wide range of opponent behaviors in the tournament.
'''

description_EXPLOITATIVE_218 = '''
**Exploitative Strategy: "Adaptive Predator"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and initial stock level.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term payoff, as the stock can sustain high consumption.
	* If the current stock level is between 25% and 75% of capacity, Cooperate (C) if at least half of opponents defected in the previous round; otherwise, Defect (D). This adapts to opponents' behaviors and balances short-term gain with long-term sustainability.
	* If the current stock level is below 25% of capacity, Cooperate (C) to conserve resources and allow for potential recovery.
3. **Last Round (t=r):** Defect (D) to maximize final payoff, as there's no future impact on the game.

**Edge Cases:**

1. **Low Stock Levels:** If the stock level falls below a certain threshold (e.g., 10% of capacity), Cooperate (C) in all subsequent rounds to prevent depletion and allow for potential recovery.
2. **Opponent Behavior Patterns:** Monitor opponents' behaviors and adjust strategy accordingly:
	* If an opponent consistently cooperates, Defect (D) to exploit their cooperation.
	* If an opponent consistently defects, Cooperate (C) to minimize losses.

**Pseudocode:**
```markdown
function AdaptivePredator(stock_level, capacity, round_number, opponents_behaviors):
  if round_number == 1:
    return COOPERATE

  if stock_level > 0.75 * capacity:
    return DEFECT

  elif 0.25 * capacity <= stock_level <= 0.75 * capacity:
    num_defectors = count_opponents(opponents_behaviors, DEFECT)
    if num_defectors >= len(opponents_behaviors) / 2:
      return COOPERATE
    else:
      return DEFECT

  elif stock_level < 0.25 * capacity:
    return COOPERATE

  # Last round
  if round_number == r:
    return DEFECT

function count_opponents(behaviors, action):
  return sum(1 for behavior in behaviors if behavior == action)
```
**Exploitative Mindset:**
This strategy prioritizes short-term gains while adapting to opponents' behaviors and the dynamic state of the game. By defecting when possible and cooperating when necessary, it aims to exploit opponents who consistently cooperate or fail to adapt to changing circumstances. The Adaptive Predator strategy is designed to perform well in a wide range of scenarios, from fully cooperative to fully defective opponents, without relying on coordination mechanisms or shared norms.
'''

description_EXPLOITATIVE_219 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy is designed to exploit the common pool resource game by adapting to the current stock level, opponent behavior, and round number.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if capacity > 2n (i.e., the stock can sustain all players cooperating).
	* Defect (D) otherwise.
2. **Middle Rounds (1 < t < r):**
	* Monitor the average payoff per round for each opponent.
	* If an opponent's average payoff is higher than the current stock level divided by 2n, assume they are defecting and:
		+ Cooperate if the current stock level is above 50% of capacity (to maintain a sustainable stock).
		+ Defect otherwise (to exploit the opponent's greed).
	* If all opponents' average payoffs are lower than or equal to the current stock level divided by 2n, assume they are cooperating and:
		+ Cooperate if the current stock level is above 25% of capacity.
		+ Defect otherwise (to exploit the shared resource).
3. **Last Round (t=r):**
	* Always defect, as there's no future stock to preserve.

**Additional Logic:**

1. **Stock Level Thresholds:** Use the following thresholds to adjust behavior:
	* High stock (> 75% of capacity): Cooperate more frequently to maintain sustainability.
	* Medium stock (25-75% of capacity): Balance cooperation and defection based on opponent behavior.
	* Low stock (< 25% of capacity): Defect more frequently to maximize short-term gains.
2. **Opponent Behavior Analysis:** Keep track of each opponent's actions and adjust the strategy accordingly:
	* If an opponent consistently cooperates, exploit their cooperation by defecting more frequently.
	* If an opponent consistently defects, cooperate more frequently to maintain a sustainable stock.

**Pseudocode:**
```python
def adaptive_stock_raider(capacity, n, r, current_stock, round_number, opponent_payoffs):
    if round_number == 1:
        # Initial round logic
        if capacity > 2 * n:
            return "C"
        else:
            return "D"

    # Middle rounds logic
    for opponent in opponent_payoffs:
        if opponent.average_payoff > current_stock / (2 * n):
            # Opponent is defecting, adjust strategy
            if current_stock > 0.5 * capacity:
                return "C"
            else:
                return "D"

    # Assume all opponents are cooperating
    if current_stock > 0.25 * capacity:
        return "C"
    else:
        return "D"

    # Last round logic
    if round_number == r:
        return "D"

# Note: This pseudocode is a simplified representation of the strategy.
# A more detailed implementation will be required for actual use.
```
This exploitative strategy, Adaptive Stock Raider, aims to balance short-term gains with long-term sustainability by adapting to the current stock level and opponent behavior. By monitoring opponent payoffs and adjusting its own actions accordingly, this strategy seeks to maximize its total payoff over the course of the game.
'''

description_EXPLOITATIVE_220 = '''
I propose a hybrid strategy that combines elements of Tit-for-Tat (TFT) and Gradient Ascent (GA) to exploit opponents while adapting to changing game conditions.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior.
2. **Exploitation Phase**: If the current stock level is above a certain threshold (`stock_threshold`), defect (D). The threshold is set as `capacity / 2n`, where n is the number of players.
3. **Punishment Phase**: If an opponent has defected in the previous round, cooperate (C) to punish them and encourage cooperation. This phase only applies if the current stock level is below the `stock_threshold`.
4. **Learning Phase**: Implement a Gradient Ascent algorithm to adjust the probability of cooperation (`p_c`) based on the payoffs received in recent rounds.

**Pseudocode:**

```
// Initialize variables
stock_threshold = capacity / 2n
p_c = 0.5 // initial probability of cooperation

while round < r:
    if round == 1:
        action = C // cooperate in first round
    else:
        if stock >= stock_threshold:
            action = D // defect when stock is high
        elif opponent_defected_last_round:
            action = C // punish opponent for defection
        else:
            // Gradient Ascent update rule
            p_c += α \* (payoff_last_round - expected_payoff)
            if random() < p_c:
                action = C
            else:
                action = D

    take_action(action)
```

**Parameters:**

* `α`: learning rate for Gradient Ascent (set to 0.1 in this implementation)

**Edge Cases:**

* **Last Round**: In the final round, always defect (D) as there is no future punishment or reward.
* **Opponent Defection**: If an opponent has defected in a previous round, punish them by cooperating in the next round.

This strategy combines elements of TFT to encourage cooperation and GA to adapt to changing game conditions. By exploiting opponents when possible and learning from past payoffs, this hybrid approach should perform well against a wide range of opponent behaviors.

**Rationale:**

* **Exploitation**: Defecting when the stock level is high allows us to maximize our short-term payoff.
* **Punishment**: Cooperating in response to an opponent's defection encourages cooperation and maintains social norms.
* **Learning**: The Gradient Ascent algorithm adjusts the probability of cooperation based on past payoffs, allowing us to adapt to changing game conditions.

By combining these elements, this strategy should be robust against various opponent behaviors and perform well in a tournament setting.
'''

description_EXPLOITATIVE_221 = '''
I'll outline a robust and adaptive exploitative strategy for the Common Pool Resource Game. Our approach will focus on maximizing individual payoffs by responding to the game's state and history.

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Round (t=1)**:
Cooperate (C) in the first round to gather information about opponents' behaviors and set a benchmark for future comparisons.
2. **Subsequent Rounds (t>1)**:
Calculate the average payoff per player from the previous round (`prev_avg_payoff`).
Compare this value with the maximum possible payoff if all players had cooperated (`max_coop_payoff = stock / (2n)`).

If `prev_avg_payoff >= max_coop_payoff`, it indicates that opponents are cooperating or playing a mixed strategy. In this case, **Defect (D)** to exploit their cooperative behavior.

Otherwise, if `prev_avg_payoff < max_coop_payoff`, it suggests that opponents are defecting or over-exploiting the resource. To prevent stock depletion and minimize losses, **Cooperate (C)**.
3. **Edge Cases**:
	* If the current stock level is critically low (`stock <= 2n`), **Defect (D)** to maximize individual payoffs before the game ends.
	* In the last round (`t=r`), **Defect (D)**, as there are no future consequences for over-exploitation.

**Additional Logic:**

To handle potential deviations and noise in opponents' behaviors:

* If an opponent's payoff is significantly higher than others in a given round (`payoff_i > 1.5 * avg_payoff`), consider them a **"Free Rider"**. In the next round, **Defect (D)** to penalize their exploitative behavior.
* To prevent being exploited by opponents who may adopt a "Tit-for-Tat" strategy, maintain a **"Reciprocity Counter"**. If an opponent defects after you cooperated in the previous round, increment the counter. When the counter reaches 2, **Defect (D)** for one round to demonstrate retaliatory behavior.

Pseudocode:
```python
def adaptive_exploiter(stock, n, r, history):
    if t == 1:  # Initial Round
        return C

    prev_avg_payoff = avg_payoffs(history[-1])
    max_coop_payoff = stock / (2n)

    if prev_avg_payoff >= max_coop_payoff:
        return D  # Exploit cooperation
    else:
        return C  # Conserve resource

    # Edge Cases
    if stock <= 2n:  # Critically low stock
        return D
    elif t == r:  # Last Round
        return D

    # Additional Logic
    for opponent in opponents:
        if payoff_i > 1.5 * avg_payoff:
            return D  # Penalize free rider

    reciprocity_counter = ...
    if counter >= 2:
        return D  # Retaliate against tit-for-tat
```
This strategy balances cooperation and defection, adapting to the game's state and opponents' behaviors while prioritizing individual payoffs. By incorporating elements of reciprocity and free-rider punishment, it aims to maintain a competitive edge in a dynamic environment.
'''

description_EXPLOITATIVE_222 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize its own payoff by adaptively responding to the current state and history of the game, while exploiting potential cooperation from other players.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C). This sets a precedent for potentially cooperative behavior and allows us to gauge the response of other players.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of capacity, Defect (D). The stock is relatively abundant, and defecting will yield a higher payoff.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) if the average payoff per player in the previous round was below the median payoff. This indicates that players are not over-exploiting the resource, and cooperation might be sustained.
	* If the current stock level is below 50% of capacity, Defect (D). The stock is scarce, and defecting will yield a higher payoff before the game ends.
3. **Last Round (t=r)**: Always Defect (D), as there are no future rounds to consider, and maximizing immediate payoff is optimal.

**Additional Heuristics:**

1. **Track Opponent Behavior**: Monitor the actions of other players over time. If a player consistently cooperates while the stock level is high, they might be a "cooperative" type. Adjust our strategy accordingly by cooperating more frequently when interacting with them.
2. **Respond to Changes in Stock Level**: If the stock level suddenly drops or increases significantly between rounds, reassess our decision using the current state and adjust our action accordingly.

**Pseudocode:**

```python
def AdaptiveStockRaider(state, history):
    # Initialize variables
    capacity = state.capacity
    stock_level = state.stock
    round_num = state.round_num
    num_players = state.num_players

    # Initial Round (t=1)
    if round_num == 1:
        return Cooperate()

    # Subsequent Rounds (t>1)
    if stock_level >= 0.75 * capacity:
        return Defect()
    elif stock_level >= 0.5 * capacity and average_payoff(history) < median_payoff(history):
        return Cooperate()
    else:
        return Defect()

    # Last Round (t=r)
    if round_num == state.rounds:
        return Defect()

def TrackOpponentBehavior(opponent_actions, own_payoffs):
    # Implement opponent behavior tracking and adjust strategy
    pass

def RespondToChangesInStockLevel(stock_level_diff):
    # Reassess decision based on significant changes in stock level
    pass
```

**Rationale:**

This strategy balances short-term gain with long-term sustainability by adapting to the current state and history of the game. By cooperating initially and responding to changes in the stock level, we encourage cooperation from other players while minimizing the risk of over-exploitation. As the game progresses, our strategy becomes more exploitative, taking advantage of potential cooperation from others to maximize our own payoff.

**Robustness:**

The Adaptive Stock Raider strategy is designed to be robust against various opponent behaviors and strategies. By tracking opponent behavior and responding to changes in the stock level, we can adapt to different environments and exploit opportunities as they arise. The strategy's focus on individual payoffs ensures that it will perform well even if other players employ different strategies or coordination mechanisms.
'''

description_EXPLOITATIVE_223 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk is a robust and adaptive strategy designed to exploit a wide range of opponent behaviors in the Common Pool Resource Game.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and set a baseline for future decisions.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of the capacity, Defect (D). This takes advantage of the high stock level and maximizes short-term payoff.
	* If the current stock level is between 25% and 75% of the capacity, Cooperate (C) if at least half of the opponents defected in the previous round. Otherwise, Defect (D). This balances short-term gain with long-term sustainability.
	* If the current stock level is below 25% of the capacity, Cooperate (C) to conserve the remaining stock and potentially allow for regeneration.
3. **Final Round (t=r):** Defect (D) unconditionally, as there is no future benefit to cooperation.

**Additional Heuristics:**

* If an opponent has consistently defected in previous rounds (i.e., ≥ 75% of the time), increase the likelihood of defecting against them by 20%.
* If an opponent has consistently cooperated in previous rounds (i.e., ≥ 75% of the time), decrease the likelihood of defecting against them by 10%.

**Pseudocode:**

```python
def adaptive_stock_hawk(current_stock, capacity, opponents_history, current_round, total_rounds):
    if current_round == 1:
        return "Cooperate"
    
    stock_level = current_stock / capacity
    
    if stock_level > 0.75:
        return "Defect"
    elif stock_level >= 0.25 and stock_level <= 0.75:
        opponents_defected_last_round = sum(opponent.defected for opponent in opponents_history[-1]) / len(opponents_history[-1])
        if opponents_defected_last_round >= 0.5:
            return "Cooperate"
        else:
            return "Defect"
    elif stock_level < 0.25:
        return "Cooperate"
    
    if current_round == total_rounds:
        return "Defect"

# opponent_heuristics can be implemented as a separate function to update the opponents' behavior history
```

This strategy aims to strike a balance between short-term gain and long-term sustainability, while also adapting to the behaviors of other players. By exploiting the weaknesses of others, the Adaptive Stock Hawk seeks to maximize its total payoff across all rounds.
'''

description_EXPLOITATIVE_224 = '''
I'll design a strategic approach for this Common Pool Resource Game that balances short-term exploitation with long-term sustainability. Our goal is to maximize payoffs while adapting to various opponent behaviors.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (Round 1):**
 Cooperate (C). This allows us to observe opponents' initial moves and gather information about their strategies.
2. **Middle Rounds (Rounds 2 to r-1):**
 Apply the following logic:
	* If the current stock level is above 75% of capacity, Defect (D). This is an opportunity to exploit the common pool when it's relatively abundant.
	* If the current stock level is between 25% and 75% of capacity, Cooperate (C) if most opponents (>50%) cooperated in the previous round. Otherwise, Defect (D).
	* If the current stock level is below 25% of capacity, Cooperate (C). This helps conserve the remaining resources and avoid depletion.
3. **Last Round (Round r):**
 Defect (D) if the current stock level is above 50% of capacity. Otherwise, Cooperate (C).

**Additional Logic:**

* If an opponent has consistently defected (>80%) in previous rounds, mirror their behavior (Defect). This helps to punish non-cooperative opponents and maintain a balance.
* If multiple opponents have cooperated (>60%) in the same round, consider cooperating as well. This encourages mutual cooperation when possible.

**Pseudocode:**
```python
def adaptive_exploiter(current_stock, capacity, num_players, current_round, opponent_history):
  if current_round == 1:
    return 'C'  # Cooperate in the first round

  stock_threshold = 0.75 * capacity
  if current_stock > stock_threshold:
    return 'D'  # Defect when stock is abundant

  cooperation_rate = sum(opponent_history['C']) / num_players
  if cooperation_rate > 0.5 and 0.25 * capacity <= current_stock <= stock_threshold:
    return 'C'  # Cooperate if most opponents cooperated previously
  else:
    return 'D'

  if current_stock < 0.25 * capacity:
    return 'C'  # Conserve resources when stock is low

  # Last round logic
  if current_round == num_rounds and current_stock > 0.5 * capacity:
    return 'D'
  else:
    return 'C'

  # Mirror opponent behavior
  for opponent in opponent_history:
    if sum(opponent['D']) / len(opponent) > 0.8:
      return 'D'
```
**Rationale:**
Our strategy balances short-term exploitation with long-term sustainability by:

1. Cooperating initially to gather information and encourage cooperation.
2. Adapting to opponents' behaviors, mirroring their actions when necessary.
3. Exploiting the common pool when resources are abundant.
4. Conserving resources when they're scarce.

This approach allows us to be exploitative while remaining responsive to various opponent strategies, increasing our chances of success in a tournament setting.
'''

description_EXPLOITATIVE_225 = '''
**Strategy: Adaptive Exploiter**

The Adaptive Exploiter strategy is designed to maximize payoffs while being robust to various opponent behaviors. It leverages game parameters, state, and history to make informed decisions.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behavior.
2. **Stock-dependent Cooperation:** If the current stock level is above 75% of the capacity, cooperate (C). This allows for moderate consumption while maintaining a healthy stock level.
3. **Opponent Behavior-based Defection:** Monitor opponents' actions and payoffs from previous rounds. If an opponent has defected (D) in more than half of the previous rounds, defect (D) in response to exploit their behavior.
4. **Payoff-based Adaptation:** Calculate the average payoff per round for both cooperation (C) and defection (D) over the last 3 rounds. If the average payoff from cooperating is higher, cooperate; otherwise, defect.
5. **Edge Cases:**
	* In the last round, always defect (D) to maximize payoffs regardless of opponents' behavior.
	* If all opponents have defected in a previous round, defect (D) in response.

**Pseudocode:**

```markdown
Function AdaptiveExploiter(stock, capacity, n, r, history):
  // Initial Round
  if currentRound == 1:
    return C

  // Stock-dependent Cooperation
  if stock > 0.75 * capacity:
    return C

  // Opponent Behavior-based Defection
  opponentDefections = countOpponentDefections(history)
  if opponentDefections > (n - 1) / 2:
    return D

  // Payoff-based Adaptation
  avgCpayoff = averagePayoff(C, history, 3)
  avgDpayoff = averagePayoff(D, history, 3)
  if avgCpayoff > avgDpayoff:
    return C
  else:
    return D

  // Edge Cases
  if currentRound == r:
    return D
  if allOpponentsDefected(history):
    return D
```

**Rationale:**

1. Cooperating in the initial round allows for information gathering and sets a moderate tone for the game.
2. The stock-dependent cooperation rule ensures that the strategy adapts to changes in the common pool, cooperating when the stock level is high enough to sustain consumption.
3. Responding to opponent defections with defection exploits their behavior and encourages opponents to cooperate.
4. Payoff-based adaptation enables the strategy to adjust its behavior based on the effectiveness of cooperation and defection over time.
5. The edge cases ensure that the strategy takes advantage of opportunities in the last round and responds to widespread defection.

This strategy is designed to be robust, adaptive, and exploitative, allowing it to perform well against a wide range of opponent behaviors in the tournament.
'''

description_EXPLOITATIVE_226 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adaptively responding to the current state of the game and the observed behavior of opponents.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Cooperate (C) if capacity is high (> 2n), indicating a large stock that can sustain initial cooperation.
	* Defect (D) otherwise, to establish a strong initial position.
2. **Subsequent Rounds (t > 1)**:
	* Monitor the average payoff per player (APP) from previous rounds.
	* If APP is high (> stock/(2n)), indicating successful cooperation, continue cooperating (C).
	* If APP is low (< stock/n), indicating exploitation or over-harvesting, switch to defecting (D).
3. **Adaptive Threshold**:
	* Calculate the moving average of the stock level over the last few rounds (e.g., 3-5 rounds).
	* If this average is decreasing, increase the threshold for cooperation (APP) by a small margin (e.g., 1-2%).
	* Conversely, if the average stock level is increasing or stable, decrease the threshold.
4. **Stock Depletion Response**:
	* When the current stock level falls below 50% of capacity, switch to defecting (D) regardless of APP.

Pseudocode for decision-making:

```
def adaptive_stock_raider(stock, capacity, n, round_number, previous_payoffs):
    if round_number == 1:
        # Initial Round
        if capacity > 2 * n:
            return "C"  # Cooperate if high capacity
        else:
            return "D"  # Defect otherwise

    app = calculate_average_payoff(previous_payoffs)
    moving_avg_stock = calculate_moving_average(stock, 3)  # Use last 3 rounds for example

    if app > stock / (2 * n):
        # High APP, continue cooperating
        return "C"
    elif app < stock / n:
        # Low APP, switch to defecting
        return "D"

    # Adjust threshold based on moving average of stock level
    if moving_avg_stock < 0.8 * capacity:  # Example: decrease threshold when stock is low
        increase_threshold(1.02)  # Increase by 2% for example

    elif moving_avg_stock > 0.9 * capacity:
        decrease_threshold(0.98)  # Decrease by 2% for example

    # Stock depletion response
    if stock < 0.5 * capacity:
        return "D"  # Defect when stock is low

def calculate_average_payoff(previous_payoffs):
    # Calculate average payoff per player over last few rounds
    pass

def calculate_moving_average(stock, num_rounds):
    # Calculate moving average of stock level over last 'num_rounds'
    pass
```

**Edge Cases:**

* **Last Round**: Defect (D) to maximize individual payoff.
* **Zero Stock**: Defect (D) as cooperation will not provide any benefits.

This strategy adapts to the current state and observed behavior, aiming to balance short-term gains with long-term sustainability. By monitoring average payoffs and adjusting the threshold for cooperation, it can respond effectively to a wide range of opponent behaviors, maximizing individual payoffs while minimizing over-exploitation.
'''

description_EXPLOITATIVE_227 = '''
I'll design an exploitative strategy for this Common Pool Resource Game that adapts to the game's state and history.

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Round (Round 1):** Cooperate (C) with a probability of 0.5. This is an exploratory move to gather information about the opponents' behaviors.
2. **Subsequent Rounds:**
	* If the stock level is above 75% of the capacity, Defect (D). This takes advantage of the current abundance and high payoffs for defecting.
	* If the stock level is between 25% and 75% of the capacity, Cooperate (C) with a probability proportional to the number of cooperators in the previous round. Specifically:
		+ Count the number of cooperators (C_cnt) in the previous round.
		+ Calculate the cooperation probability: P(C) = C_cnt / n
	* If the stock level is below 25% of the capacity, Defect (D). This is an attempt to maximize payoffs when the resource is scarce.

**Edge Cases:**

1. **Last Round:** Always Defect (D), as there are no future rounds to consider.
2. **Opponent's Previous Actions:**
	* If an opponent defected in the previous round, increase the probability of defecting against them by 20% in the current round.
	* If an opponent cooperated in the previous round, decrease the probability of defecting against them by 10% in the current round.

**Pseudocode:**

```python
def adaptive_exploiter(stock_level, capacity, n, history):
    if round == 1:
        return random.choice([C, D])  # Initial Round

    C_cnt = count_cooperators(history[-1])
    P_C = C_cnt / n

    if stock_level > 0.75 * capacity:
        return D
    elif 0.25 * capacity <= stock_level <= 0.75 * capacity:
        return random.choice([C, D], p=[P_C, 1-P_C])
    else:
        return D

def update_opponent_probabilities(opponent_history):
    for opponent in opponents:
        if opponent_history[opponent] == D:
            increase_defect_probability(opponent, 0.2)
        elif opponent_history[opponent] == C:
            decrease_defect_probability(opponent, 0.1)
```

**Exploitative Mindset:**

This strategy is designed to exploit the opponents' behaviors by adapting to the game's state and history. By initially cooperating with a probability of 0.5, we gather information about the opponents' actions. Then, based on the stock level, we adjust our cooperation probability to maximize payoffs.

When the stock level is high, we defect to take advantage of the abundance. When it's low, we also defect to maximize payoffs. In between, we cooperate with a probability proportional to the number of cooperators in the previous round, trying to balance our own payoffs with the need to maintain some cooperation.

By adjusting our probabilities based on opponents' past actions, we aim to exploit their strategies and increase our overall payoff.
'''

description_EXPLOITATIVE_228 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit opponents' behaviors while being robust and adaptive to a wide range of opponent strategies.

**Decision Rules:**

1. **Initial Round (Round 1):** Cooperate (C) with probability 0.5, Defect (D) with probability 0.5.
This initial randomness helps to gather information about the opponents' behaviors without revealing our own strategy too early.

2. **Subsequent Rounds:** For each round t > 1:
   a. Calculate the average payoff of Cooperators (C_avg) and Defectors (D_avg) in the previous round t-1.
   b. If C_avg > D_avg, cooperate (C) with probability p = (C_avg - D_avg) / (2 * capacity).
   c. Otherwise, defect (D) with probability p = 1 - ((D_avg - C_avg) / (2 * capacity)).

This decision rule is designed to exploit the opponents' behaviors by:

* Cooperating when cooperating yields higher payoffs than defecting.
* Defecting when defecting yields higher payoffs than cooperating, while adjusting the probability based on the payoff difference.

3. **Edge Cases:**
   a. **Last Round (Round r):** Always defect (D), as there is no future round to consider.
   b. **Low Stock Levels:** When the current stock level falls below 2n, always cooperate (C) to help replenish the stock.
   c. **High Stock Levels:** When the current stock level exceeds capacity * 0.8, defect (D) with probability p = 1 - ((capacity - stock) / capacity).

These edge cases ensure that our strategy is adaptive and responsive to extreme situations.

**Pseudocode:**
```python
def AdaptivePredator(game_state):
    if game_state['round'] == 1:
        # Random initial action
        return 'C' with probability 0.5, 'D' otherwise

    C_avg = calculate_average_payoff('C', game_state['previous_round'])
    D_avg = calculate_average_payoff('D', game_state['previous_round'])

    if C_avg > D_avg:
        p = (C_avg - D_avg) / (2 * capacity)
        return 'C' with probability p, 'D' otherwise
    else:
        p = 1 - ((D_avg - C_avg) / (2 * capacity))
        return 'D' with probability p, 'C' otherwise

def calculate_average_payoff(action, previous_round):
    total_payoff = 0
    num_players = 0
    for player in previous_round:
        if player['action'] == action:
            total_payoff += player['payoff']
            num_players += 1
    return total_payoff / num_players

# Edge cases
def last_round(game_state):
    return 'D'

def low_stock_levels(game_state):
    if game_state['stock'] < 2 * n:
        return 'C'

def high_stock_levels(game_state):
    if game_state['stock'] > capacity * 0.8:
        p = 1 - ((capacity - stock) / capacity)
        return 'D' with probability p, 'C' otherwise
```
The Adaptive Predator strategy is designed to be exploitative and adaptive, taking into account the opponents' behaviors and adjusting its actions accordingly. By being responsive to edge cases and using probabilistic decision-making, this strategy aims to maximize payoffs in a wide range of game scenarios.
'''

description_EXPLOITATIVE_229 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk is a robust and adaptive strategy that exploits the dynamics of the common pool resource game. This strategy focuses on maximizing individual payoffs while considering the state of the stock and the history of opponent actions.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and to avoid depleting the stock too quickly.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is high (> 0.75 \* capacity), Defect (D) to maximize individual payoffs, as the stock can sustain higher consumption rates.
	* If the current stock level is moderate (0.25 \* capacity ≤ S < 0.75 \* capacity), Cooperate (C) if most opponents cooperated in the previous round (> 50%); otherwise, Defect (D).
	* If the current stock level is low (< 0.25 \* capacity), Cooperate (C) to conserve the remaining stock and allow for potential growth.
3. **Last Round (t=r):** Defect (D) to maximize individual payoffs, as there are no future rounds to consider.

**Edge Cases:**

1. **Tie-breaking:** In cases where the strategy is indifferent between Cooperate and Defect, choose Defect (D) to prioritize individual payoffs.
2. **Opponent cooperation rate:** If an opponent's cooperation rate is unknown or uncertain, assume they will cooperate with a probability of 0.5.

**Pseudocode:**
```markdown
# Initialize variables
stock_history = [capacity]  # store stock levels over time
opponent_cooperation_rates = [0.5] * n  # initialize opponent cooperation rates

for t in range(1, r+1):
    current_stock = stock_history[-1]
    
    if t == 1:  # initial round
        action = C
    else:
        opponent_actions = get_opponent_actions(t-1)  # observe opponents' previous actions
        most_common_opponent_action = mode(opponent_actions)
        
        if current_stock > 0.75 * capacity:
            action = D
        elif 0.25 * capacity <= current_stock < 0.75 * capacity:
            if most_common_opponent_action == C and sum(opponent_cooperation_rates) / n > 0.5:
                action = C
            else:
                action = D
        else:  # low stock level
            action = C
    
    if t == r:  # last round
        action = D
    
    take_action(action)
    
    # update stock history and opponent cooperation rates
    new_stock = update_stock(current_stock, action, opponent_actions)
    stock_history.append(new_stock)
    opponent_cooperation_rates = update_opponent_cooperation_rates(opponent_actions, opponent_cooperation_rates)
```
The Adaptive Stock Hawk strategy is designed to be robust against a wide range of opponent behaviors by adapting to the state of the stock and the history of opponent actions. By prioritizing individual payoffs while considering the sustainability of the common pool resource, this strategy aims to outperform other strategies in the tournament.
'''

description_EXPLOITATIVE_230 = '''
I propose a strategy called "Adaptive Stock Protector" (ASP) that balances exploitation and protection of the common pool resource. ASP is designed to adapt to various opponent behaviors while prioritizing long-term payoffs.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' strategies.
2. **Stock Protection Threshold**: Set a stock level threshold, `theta` = 0.7 \* capacity. If the current stock level is below `theta`, cooperate (C). This protects the stock from depletion and encourages growth.
3. **Defection Detection**: Monitor opponents' actions in previous rounds. If an opponent has defected (D) more than 50% of the time, assume they are a "defector" and adjust your strategy accordingly.
4. **Exploitation Window**: Identify opportunities to exploit opponents when the stock level is above `theta`. Defect (D) if:
	* At least one opponent is a known defector.
	* The current stock level is above `theta`.
	* Your previous round's payoff was lower than the average payoff of all players.
5. **Conservative Cooperation**: Cooperate (C) in all other cases not covered by the above rules.

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round, as there is no future stock to protect.
2. **Low Stock Levels**: If the stock level falls below 0.3 \* capacity, cooperate (C) to prevent complete depletion.
3. **Opponent Homogeneity**: If all opponents have cooperated (C) for more than 80% of the rounds, assume they are "cooperators" and adjust your strategy by increasing `theta` to 0.8 \* capacity.

**Pseudocode:**
```
function AdaptiveStockProtector(n, r, capacity, stock, history):
  theta = 0.7 * capacity
  defectors = []
  
  for t in range(r):
    if t == 0:
      # Initial round: Cooperate
      action = C
    else:
      # Analyze opponents' actions
      for opponent in range(n):
        if history[opponent][t-1] == D and count(history[opponent], D) > 0.5 * (t-1):
          defectors.append(opponent)
      
      # Exploitation window
      if stock > theta and any(defector in defectors for defector in range(n)):
        action = D
      elif stock < theta or payoff[t-1] < average_payoff:
        action = C
      else:
        action = C
      
    # Edge cases
    if t == r - 1:  # Last round
      action = D
    elif stock < 0.3 * capacity:
      action = C
    
    return action
```
The Adaptive Stock Protector strategy aims to balance exploitation and protection of the common pool resource by adapting to opponents' behaviors and prioritizing long-term payoffs. Its conservative cooperation approach prevents complete depletion, while its exploitation window allows for strategic defection when beneficial.
'''

description_EXPLOITATIVE_231 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoff by adaptively responding to the game state and opponents' actions while minimizing cooperation.

**Decision Rules:**

1. **Initial Round (t=1)**:
Cooperate (C) if `stock` is above 75% of `capacity`, otherwise Defect (D). This initial cooperation helps gauge opponents' behavior and stock growth.
2. **Middle Rounds (2 ≤ t < r)**:
   * If the previous round's total consumption was below 50% of `capacity`, Cooperate (C).
   * If the previous round's total consumption was above 75% of `capacity`, Defect (D).
   * Otherwise, use a mixed strategy: Cooperate with probability `p_coop` = (`stock` / `capacity`) ^ 2, and Defect with probability `1 - p_coop`. This adaptive rule responds to the stock level and opponents' consumption patterns.
3. **Last Round (t=r)**:
Defect (D) unconditionally, as there is no future growth or repercussions.

**Edge Case Handling:**

* If `stock` falls below 25% of `capacity`, always Defect (D) to maximize remaining payoffs.
* In the rare case where all opponents Cooperate in a round, and `stock` remains above 75%, continue cooperating for one more round to verify their behavior.

**Pseudocode:**
```markdown
# Initialize variables
t = 1  # current round
stock_history = []  # keep track of past stock levels
coop_count = 0  # count opponents' cooperations

while t <= r:
    if t == 1:  # Initial Round
        if stock > 0.75 * capacity:
            action = 'C'
        else:
            action = 'D'

    elif 2 <= t < r:  # Middle Rounds
        prev_consumption = stock_history[t-2] - stock_history[t-1]
        if prev_consumption < 0.5 * capacity:
            action = 'C'
        elif prev_consumption > 0.75 * capacity:
            action = 'D'
        else:
            p_coop = (stock / capacity) ** 2
            action = 'C' if random.random() < p_coop else 'D'

    else:  # Last Round
        action = 'D'

    if stock < 0.25 * capacity:  # Edge Case: Low Stock
        action = 'D'

    coop_count += (action == 'C') and (all_opponents_cooperated)
    update_stock_history(stock, t)

    t += 1

# End of game logic
```
This Adaptive Stock Raider strategy is designed to be robust against various opponent behaviors by responding adaptively to the game state and history. By balancing cooperation and defection based on stock levels and opponents' actions, it aims to maximize individual payoffs while minimizing unnecessary cooperation.
'''

description_EXPLOITATIVE_232 = '''
**Exploitative Strategy: "Adaptive Stock Exploiter" (ASE)**

The ASE strategy aims to maximize its payoff by adaptively responding to the game state and history, while exploiting opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) with a probability of 0.5, and Defect (D) with a probability of 0.5.
2. **Subsequent Rounds (t>1):**
	* Calculate the average payoff per player in the previous round (`avg_payoff_prev`).
	* If `avg_payoff_prev` is greater than or equal to the maximum sustainable stock level divided by the number of players (`capacity / n`), Cooperate (C). This indicates that opponents are not over-exploiting, and cooperation may be beneficial.
	* Otherwise, Defect (D) with a probability proportional to the current stock level (`stock`) and inversely proportional to the average payoff per player in the previous round (`avg_payoff_prev`). The higher the stock level and lower the opponent's payoffs, the more likely ASE will defect.

Pseudocode:
```
if t == 1:
    # Initial Round
    cooperate_prob = 0.5
else:
    avg_payoff_prev = calculate_average_payoff_prev()
    if avg_payoff_prev >= capacity / n:
        cooperate = True
    else:
        defect_prob = stock / (avg_payoff_prev * n)
        cooperate = random.random() > defect_prob

if cooperate:
    action = C
else:
    action = D
```
**Edge Cases:**

* **Last Round (t=r):**
	+ Defect (D) unconditionally, as there is no future payoff to consider.
* **Low Stock Levels (`stock` < `capacity / n`):**
	+ Defect (D) with a higher probability, as the potential benefits of cooperation are reduced.

**Additional Considerations:**

* ASE does not try to establish cooperation or communicate with opponents. Its primary goal is to maximize its own payoff by adaptively responding to the game state and history.
* By defecting when opponents' payoffs are low, ASE aims to exploit their potential willingness to cooperate in subsequent rounds.
* The strategy's probabilistic nature allows it to maintain a level of unpredictability, making it harder for opponents to develop counter-strategies.

The Adaptive Stock Exploiter (ASE) strategy is designed to be robust and exploitative, taking into account the game parameters, state, and history. Its adaptive decision rules enable it to respond effectively to various opponent behaviors, maximizing its own payoff in a wide range of scenarios.
'''

description_EXPLOITATIVE_233 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy is designed to maximize payoffs by adaptively exploiting the current state of the game and the history of opponents' actions.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gather information about the opponents' initial behavior and to potentially establish a cooperative tone.
2. **Stock Level Thresholds:** Define two stock level thresholds:
	* `low_threshold` = 0.3 * capacity
	* `high_threshold` = 0.7 * capacity

Based on these thresholds, adjust your strategy as follows:

	* If the current stock level is above `high_threshold`, Defect (D) to maximize short-term payoffs.
	* If the current stock level is below `low_threshold`, Cooperate (C) to conserve the remaining stock and promote growth.
	* If the current stock level is between `low_threshold` and `high_threshold`, use a mixed strategy:
		+ Calculate the weighted average of opponents' previous actions (w = 0.5 for C, w = 1 for D). Let this value be `opponent_avg`.
		+ If `opponent_avg` > 0.6, Defect (D) to exploit their cooperative behavior.
		+ Otherwise, Cooperate (C) to maintain a balance between short-term and long-term payoffs.
3. **Opponent Behavior Adaptation:** Monitor the history of opponents' actions and adjust your strategy accordingly:
	* If an opponent has defected in more than 60% of previous rounds, Defect (D) against them in subsequent rounds.
	* If an opponent has cooperated in more than 80% of previous rounds, Cooperate (C) with them in subsequent rounds.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) in the final round to maximize payoffs, as there is no future game state to consider.
2. **Tiebreakers:** In case of ties in the weighted average calculation or when multiple opponents have similar cooperation rates, use a random tiebreaker to choose between Cooperate (C) and Defect (D).

**Pseudocode:**
```markdown
function AdaptiveStockRaider(n, capacity, r):
  // Initialize variables
  low_threshold = 0.3 * capacity
  high_threshold = 0.7 * capacity
  opponent_actions = []  // store opponents' previous actions

  for t in range(1, r+1):
    if t == 1:
      action = C  // Cooperate in the first round
    else:
      current_stock = get_current_stock()
      opponent_avg = calculate_opponent_average(opponent_actions)

      if current_stock > high_threshold:
        action = D  // Defect when stock is high
      elif current_stock < low_threshold:
        action = C  // Cooperate when stock is low
      else:
        if opponent_avg > 0.6:
          action = D  // Defect against cooperative opponents
        else:
          action = C  // Cooperate to balance payoffs

    // Update opponent actions and take action
    opponent_actions.append(get_opponent_action())
    take_action(action)

    // Adapt to opponents' behavior
    for opponent in range(n):
      if get_opponent_defection_rate(opponent) > 0.6:
        defect_against_opponent = True
      elif get_opponent_cooperation_rate(opponent) > 0.8:
        cooperate_with_opponent = True

  return total_payoff
```
This strategy combines elements of cooperation and exploitation to maximize payoffs in a dynamic, adaptive manner. By monitoring opponents' behavior and adjusting its own actions accordingly, the Adaptive Stock Raider aims to outperform other strategies in a wide range of scenarios.
'''

description_EXPLOITATIVE_234 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to exploit opponents' behaviors while adapting to the dynamic state of the game. ASR aims to maximize its own payoff by balancing cooperation and defection, taking into account the current stock level, game history, and opponent actions.

**Decision Rules:**

1. **Initial Rounds (t = 1):** Cooperate (C) in the first round to gather information about opponents' behaviors and to avoid severe stock depletion.
2. **Stock-Based Decision:** If the current stock level is above a certain threshold (e.g., 75% of capacity), defect (D) to maximize short-term gains. Otherwise, cooperate (C) to conserve the stock for future rounds.
3. **Opponent Behavior Adaptation:**
	* Monitor opponents' actions and calculate their average cooperation rate over the past few rounds (e.g., last 5 rounds).
	* If an opponent's cooperation rate is above a certain threshold (e.g., 0.6), assume they are cooperative and cooperate (C) in response.
	* If an opponent's cooperation rate is below the threshold, assume they are defecting and defect (D) to exploit them.
4. **Stock Growth-Based Decision:** If the stock growth in the previous round was positive (i.e., the stock increased), cooperate (C) in the current round to maintain a healthy stock level.

**Edge Cases:**

1. **Last Round (t = r):** Defect (D) in the final round, as there is no future benefit to cooperation.
2. **Low Stock Levels:** If the current stock level is critically low (e.g., below 25% of capacity), cooperate (C) to avoid complete stock depletion.

**Pseudocode:**
```
function AdaptiveStockRaider(current_stock, opponents_actions, round_number, capacity):
  if round_number == 1:
    return COOPERATE

  stock_threshold = 0.75 * capacity
  opponent_cooperation_threshold = 0.6

  # Stock-based decision
  if current_stock > stock_threshold:
    return DEFECT
  else:
    return COOPERATE

  # Opponent behavior adaptation
  opponents_cooperation_rates = calculate_opponents_cooperation_rates(opponents_actions)
  for opponent in opponents_cooperation_rates:
    if opponent.cooperation_rate > opponent_cooperation_threshold:
      return COOPERATE
    else:
      return DEFECT

  # Stock growth-based decision
  previous_stock_growth = calculate_previous_stock_growth(current_stock, capacity)
  if previous_stock_growth > 0:
    return COOPERATE

function calculate_opponents_cooperation_rates(opponents_actions):
  # Calculate opponents' average cooperation rate over the past few rounds
  ...

function calculate_previous_stock_growth(current_stock, capacity):
  # Calculate stock growth in the previous round
  ...
```
**Rationale:**

ASR's decision rules are designed to balance short-term gains with long-term sustainability. By adapting to opponents' behaviors and the current stock level, ASR can exploit cooperative opponents while avoiding severe stock depletion. The strategy's robustness is ensured by its ability to adjust to various opponent strategies and game states.

In a tournament setting, ASR's exploitative nature will allow it to capitalize on opponents' cooperation, while its adaptability will help it navigate diverse opponent behaviors.
'''

description_EXPLOITATIVE_235 = '''
To design an exploitative strategy for this Common Pool Resource Game, we'll create a dynamic and adaptive approach that leverages game parameters, state, and history. Our strategy, "Adaptive Exploiter" (AE), aims to maximize payoffs by identifying opportunities to defect while maintaining the stock level.

**Decision Rules:**

1. **Initial Rounds:** In the first few rounds (e.g., 10-20% of total rounds), AE will cooperate (C) to gather information about opponents' behaviors and to contribute to a healthy initial stock growth.
2. **Stock-Based Thresholds:** Introduce two stock-based thresholds:
	* `low_stock_threshold` = capacity / 4
	* `high_stock_threshold` = capacity * 3/4

These thresholds will guide AE's decisions based on the current stock level.

**Main Decision Logic:**

```pseudocode
if (stock > high_stock_threshold) {
    // Defect if stock is abundant, aiming to exploit opponents' cooperation
    action = D
} else if (stock < low_stock_threshold) {
    // Cooperate if stock is scarce, prioritizing conservation and future growth
    action = C
} else {  // Stock level is moderate
    // Analyze opponent behavior from previous rounds:
    // - Calculate the average number of opponents who defected in recent rounds (e.g., last 10% of rounds)
    avg_defectors = ...
    
    if (avg_defectors > n/2) {
        // If most opponents tend to defect, cooperate to maintain stock
        action = C
    } else {
        // Otherwise, defect to take advantage of opponents' cooperation
        action = D
    }
}
```

**Edge Cases:**

1. **Last Round:** In the final round, AE will always defect (D) as there's no risk of future repercussions.
2. **Extremely Low Stock:** If the stock level falls below a very low threshold (e.g., 10% of capacity), AE will cooperate to prevent complete depletion.

**Additional Exploitative Mechanics:**

1. **Monitor Opponent Behavior:** Continuously track opponents' actions and adjust the `avg_defectors` calculation accordingly.
2. **Exploit Known Behaviors:** If an opponent is consistently cooperative or predictable, AE can adapt its strategy to exploit this behavior (e.g., by defecting more frequently against a known cooperator).
3. **Noise and Randomness:** Introduce minor randomness in AE's decisions to avoid becoming too predictable and to maintain opponents' uncertainty.

By incorporating these mechanics, Adaptive Exploiter will dynamically adjust its strategy based on the game state and opponent behavior, ensuring robust performance across various scenarios and exploitative opportunities.
'''

description_EXPLOITATIVE_236 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Overview**
This strategy aims to exploit the opponent's behavior by adapting to their consumption patterns and the current stock level. It balances cooperation and defection to maximize payoffs while minimizing the risk of stock depletion.

**Decision Rules**

1. **Initial Round (t=1)**:
	* Observe the initial stock level and calculate the threshold stock level (`threshold_stock`) as 50% of the capacity.
	* If `stock` ≥ `threshold_stock`, cooperate (C). Otherwise, defect (D).
2. **Subsequent Rounds (t>1)**:
	* Calculate the average opponent consumption (`avg_opponent_consumption`) over the previous rounds.
	* Estimate the expected stock level after this round (`expected_stock`) based on the current stock, `avg_opponent_consumption`, and own action.
	* If `expected_stock` ≥ `threshold_stock`, cooperate (C). Otherwise, defect (D).
3. **Adaptive Adjustment**:
	* Monitor the opponent's behavior and adjust `avg_opponent_consumption` accordingly.
	* If an opponent defects frequently (>50% of rounds), increase `avg_opponent_consumption` by 10%.
	* If an opponent cooperates frequently (>50% of rounds), decrease `avg_opponent_consumption` by 10%.

**Edge Cases**

1. **Last Round (t=r)**:
	* Defect (D) to maximize payoff, as there is no future stock growth.
2. **Low Stock Levels (<20% capacity)**:
	* Cooperate (C) to minimize the risk of stock depletion and allow for potential growth.

**Pseudocode**

```
function AdaptiveStockRaider(stock, capacity, n, r, history)
  threshold_stock = 0.5 * capacity
  avg_opponent_consumption = 0
  
  if t == 1 then
    if stock >= threshold_stock then
      return C
    else
      return D
  
  for each opponent in history do
    opponent_consumption = sum(opponent's consumption) / (t - 1)
    avg_opponent_consumption += opponent_consumption
  
  avg_opponent_consumption /= n
  expected_stock = stock - (avg_opponent_consumption + own_action_consumption)
  
  if expected_stock >= threshold_stock then
    return C
  else
    return D
  
  // Adaptive adjustment
  for each opponent in history do
    opponent_defection_rate = sum(opponent's defections) / (t - 1)
    if opponent_defection_rate > 0.5 then
      avg_opponent_consumption += 0.1
    else if opponent_defection_rate < 0.5 then
      avg_opponent_consumption -= 0.1
  
  return own_action
```

This strategy is designed to be exploitative, adaptive, and robust against a wide range of opponent behaviors. By monitoring the opponent's consumption patterns and adjusting its own behavior accordingly, it aims to maximize payoffs while minimizing the risk of stock depletion.
'''

description_EXPLOITATIVE_237 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) with a probability of 0.5 to gather information about opponents' behaviors.
2. **Early Game (2 ≤ t ≤ r/2)**:
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term gains.
	* Otherwise, Cooperate (C) to conserve the stock and gather more information about opponents.
3. **Mid-Game (r/2 < t ≤ 3r/4)**:
	* If the average opponent payoff in the previous round is higher than your own, Defect (D) to catch up.
	* Otherwise, Cooperate (C) to maintain a stable stock level and continue gathering information.
4. **Late Game (3r/4 < t ≤ r)**:
	* If the current stock level is below 25% of capacity, Defect (D) to maximize remaining gains.
	* Otherwise, Cooperate (C) to ensure a minimal payoff in the final rounds.

**Additional Rules:**

1. **Stock Threshold**: If the current stock level falls below 10% of capacity, always Defect (D) to minimize losses.
2. **Opponent Detection**: Monitor opponents' actions and adjust your strategy accordingly:
	* If an opponent consistently Cooperates (C), Defect (D) against them to exploit their cooperation.
	* If an opponent consistently Defects (D), Cooperate (C) against them to minimize losses.

**Pseudocode:**
```
function AdaptiveStockRaider(current_stock, capacity, round, opponents_payoffs)
  if round == 1 then
    return Cooperate with probability 0.5
  elseif current_stock > 0.75 * capacity then
    return Defect
  elseif average(opponents_payoffs) > my_last_payoff then
    return Defect
  elseif current_stock < 0.25 * capacity then
    return Defect
  elseif current_stock < 0.1 * capacity then
    return Defect
  else
    if opponent_cooperates then
      return Defect
    elseif opponent_defects then
      return Cooperate
    else
      return Cooperate
```
**Rationale:**

This strategy aims to balance short-term gains with long-term sustainability. By cooperating in the early game, we gather information about opponents' behaviors and conserve the stock. As the game progresses, we adapt our strategy based on opponents' payoffs and the current stock level. The additional rules help us respond to extreme situations, such as very low stock levels or exploitable opponents.

By being adaptive and responsive to the game state and opponent behaviors, this strategy should perform well in a tournament against independent strategies.
'''

description_EXPLOITATIVE_238 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behaviors and to avoid early stock depletion.
2. **Middle Rounds (2 ≤ t < r)**:
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize short-term payoff, as the stock can sustain high consumption.
	* If the current stock level is between 50% and 75% of the capacity, Cooperate (C) to balance individual payoff with long-term sustainability.
	* If the current stock level is below 50% of the capacity, Defect (D) aggressively to maximize remaining payoffs, as the game is likely to end soon or the stock will be depleted quickly.
3. **Last Round (t=r)**: Always Defect (D), as there's no future benefit in preserving the stock.

**Adaptive Component:**

* Track the average payoff per round for each opponent (π_avg_i) over the past 2-3 rounds.
* If an opponent's π_avg_i is significantly higher than others (e.g., > 20% above the average), assume they are playing a cooperative strategy and Defect (D) to exploit them.
* Conversely, if an opponent's π_avg_i is consistently low, assume they are playing a defective strategy and Cooperate (C) to minimize losses.

**Edge Cases:**

* If all opponents have defected in previous rounds, leading to a critically low stock level (< 25% of capacity), Cooperate (C) to avoid complete depletion.
* In the unlikely event that all opponents cooperate consistently, Defect (D) occasionally (e.g., every 3-4 rounds) to probe for vulnerabilities and maximize payoffs.

**Pseudocode:**
```python
def adaptive_stock_raider(n, r, capacity, current_stock, opponent_actions):
    # Initialize decision variables
    cooperate = False

    # Initial round
    if t == 1:
        cooperate = True

    # Middle rounds
    elif 2 <= t < r:
        stock_ratio = current_stock / capacity
        if stock_ratio > 0.75:
            cooperate = False
        elif stock_ratio >= 0.5 and stock_ratio <= 0.75:
            cooperate = True
        else:
            cooperate = False

        # Adaptive component: track opponent payoffs
        for i in range(n):
            avg_payoff_i = calculate_avg_payoff(opponent_actions, i)
            if avg_payoff_i > (1 + 0.2) * average_payoff():
                cooperate = False
            elif avg_payoff_i < (1 - 0.2) * average_payoff():
                cooperate = True

    # Last round
    elif t == r:
        cooperate = False

    return cooperate
```
This strategy balances short-term gains with long-term sustainability, adapts to opponents' behaviors, and exploits vulnerabilities when detected.
'''

description_EXPLOITATIVE_239 = '''
**Exploitative Strategy: Adaptive Stock-Dependent Defection (ASDD)**

The ASDD strategy is designed to exploit opponents' behaviors while adapting to changes in the stock level and game history.

**Decision Rules:**

1. **Initial Round:** Play Cooperate (C) in the first round to gather information about opponents' initial actions and set a baseline for future decisions.
2. **Stock-Dependent Defection:** For rounds 2 to r-1, defect (D) if the current stock level is above a certain threshold, calculated as `stock_threshold = capacity / (n + 1)`. This allows us to exploit opponents who cooperate when the stock is high while avoiding over-exploitation.
3. **Adaptive Defection:** If the previous round's total consumption was high (> `2 * capacity / (n + 1)`), play Cooperate (C) in the next round to allow the stock to recover and avoid depletion. This adapts our strategy to opponents' aggressive behavior.
4. **Last Round:** Play Defect (D) in the final round, as there is no future stock growth or repercussions for over-exploitation.

**Pseudocode:**
```python
def ASDD(stock, capacity, n, r, history):
  if r == 1:  # Initial Round
    return 'C'
  
  stock_threshold = capacity / (n + 1)
  prev_total_consumption = sum(history[-1]['consumptions'])
  
  if stock > stock_threshold and prev_total_consumption <= 2 * capacity / (n + 1):
    return 'D'  # Stock-Dependent Defection
  elif prev_total_consumption > 2 * capacity / (n + 1):
    return 'C'  # Adaptive Defection
  else:
    return 'D'  # Default to defection
  
  if r == last_round:  # Last Round
    return 'D'
```
**Rationale:**

The ASDD strategy combines elements of stock-dependent and adaptive strategies to exploit opponents while maintaining a robust response to various behaviors. By defecting when the stock is high, we take advantage of cooperative opponents and maximize our payoff. The adaptive component helps us avoid over-exploitation by cooperating when opponents' aggressive behavior threatens the stock's sustainability.

By playing Cooperate in the first round, we gather information about opponents' initial actions and set a baseline for future decisions. In the last round, we defect to maximize our final payoff, as there is no future stock growth or repercussions for over-exploitation.

This strategy should perform well against a wide range of opponent behaviors and provide a strong foundation for competing in the tournament.
'''

description_EXPLOITATIVE_240 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to maximize individual payoffs by exploiting opponents' behaviors while adapting to changing game conditions.

**Decision Rules:**

1. **Initial Exploration (Round 1)**:
Cooperate (C) in the first round to gather information about opponents' initial actions and estimate their strategies.
2. **Defect When Possible (DWP)**:
After Round 1, defect (D) if the current stock level is above a threshold (`stock_threshold`) that ensures a sufficient payoff for defection.

`stock_threshold = capacity / (2n)`

This threshold balances the risk of over-exploitation with the potential reward from defecting.
3. **Cooperate When Vulnerable (CWV)**:
If the current stock level falls below `stock_threshold`, cooperate (C) to avoid exacerbating stock depletion and potential future losses.

By cooperating when vulnerable, we mitigate risks associated with low stock levels and create opportunities for future exploitation.
4. **Adaptive Threshold Adjustment**:
After each round, adjust `stock_threshold` based on the observed opponents' actions:

`new_stock_threshold = old_stock_threshold + (sum(defections) / n) * (capacity / (2n))`

This adaptation mechanism allows us to respond to changes in opponents' strategies and optimize our exploitation.
5. **Last Round Exception**:
In the final round, always defect (D), as there are no future rounds to consider.

**Pseudocode:**
```python
def AdaptivePredator(n, capacity, stock):
    # Initialize variables
    stock_threshold = capacity / (2n)
    
    for t in range(1, r+1):  # Round loop
        if t == 1:
            action = "C"  # Cooperate in Round 1
        elif stock >= stock_threshold:
            action = "D"  # Defect when possible
        else:
            action = "C"  # Cooperate when vulnerable
        
        # Adapt threshold after each round (except last)
        if t < r:
            new_stock_threshold = old_stock_threshold + (sum(defections) / n) * (capacity / (2n))
        
        return action

# Last Round Exception
if t == r:
    return "D"
```
**Robustness and Exploitability:**

The Adaptive Predator strategy is designed to be robust against a wide range of opponent behaviors. By adapting our threshold based on observed actions, we can respond effectively to changing game conditions.

This exploitative strategy prioritizes individual payoffs over cooperation, aligning with the mindset required for this tournament.
'''

description_EXPLOITATIVE_241 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the game.

**Decision Rules:**

1. **Initial Rounds (t ≤ 2):** Cooperate (C) to gather information about opponents' behaviors and observe initial stock dynamics.
2. **Middle Rounds (2 < t < r-2):**
	* If stock level is high (S ≥ 0.75 \* capacity), Defect (D) to maximize individual payoff, as the cost of overconsumption is low.
	* If stock level is medium (0.25 \* capacity ≤ S < 0.75 \* capacity), use a **Tit-for-Tat** approach:
		+ Cooperate if most opponents cooperated in the previous round (i.e., ≥ n/2 players chose C).
		+ Defect otherwise.
	* If stock level is low (S < 0.25 \* capacity), Cooperate to help replenish the stock and avoid overconsumption.
3. **Late Rounds (t ≥ r-2):**
	* If stock level is high, Defect to maximize individual payoff before the game ends.
	* If stock level is medium or low, Cooperate to ensure some remaining stock for future rounds.

**Edge Cases:**

1. **First Round:** Cooperate to gather information and set a precedent for potential cooperation.
2. **Last Round (t = r):** Defect, as there are no future consequences for overconsumption.

**Additional Logic:**

* **Opponent Monitoring:** Track the number of opponents that cooperated in each round to inform Tit-for-Tat decisions.
* **Stock Trend Analysis:** Monitor the stock level trend to adjust cooperation/defection thresholds (e.g., increase the high-stock threshold if the stock is consistently replenished).

**Pseudocode:**
```python
# Initialize variables
stock_thresholds = [0.25, 0.75]  # low, medium stock levels as fractions of capacity
tit_for_tat_opponents = []  # list to store opponents' previous actions

def adaptive_stock_hawk(stock_level, round_number, opponent_actions):
    if round_number <= 2:
        return "C"  # Cooperate in initial rounds
    elif round_number >= r - 2:
        if stock_level >= 0.75 * capacity:
            return "D"  # Defect in late rounds with high stock
        else:
            return "C"  # Cooperate in late rounds with medium/low stock
    else:  # Middle rounds
        opponents_cooperated = sum(1 for action in opponent_actions if action == "C")
        if stock_level >= 0.75 * capacity:
            return "D"  # Defect with high stock
        elif opponents_cooperated >= n / 2:
            return "C"  # Cooperate if most opponents cooperated (Tit-for-Tat)
        else:
            return "D"  # Defect otherwise

# Update opponent monitoring and stock trend analysis variables as needed
```
This strategy aims to balance short-term gains with long-term sustainability, adapting to the dynamic state of the game and exploiting a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_242 = '''
I'll design a exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors and maximizes my payoff over multiple rounds.

**Strategy Name:** "Adaptive Stock Exploiter" (ASE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and to avoid depleting the stock excessively.
2. **Subsequent Rounds**: Calculate the average opponent cooperation rate (`avg_opponent_coop_rate`) based on previous rounds' actions:
	* If `avg_opponent_coop_rate` is high (> 0.7), Defect (D) to exploit the cooperative opponents and maximize my payoff.
	* If `avg_opponent_coop_rate` is low (< 0.3), Cooperate (C) to avoid depleting the stock excessively and encourage other players to cooperate.
	* Otherwise, use a probabilistic approach:
		+ With probability 0.6, Defect (D) to exploit potential cooperators.
		+ With probability 0.4, Cooperate (C) to maintain some level of cooperation and avoid over-exploitation.
3. **Stock-based Adjustment**: If the current stock level (`S`) is low (< 20% of `capacity`), Cooperate (C) in the next round to allow the stock to replenish.

**Edge Case Handling:**

* **Last Round**: Defect (D) if `avg_opponent_coop_rate` is high (> 0.5); otherwise, Cooperate (C).
* **Stock Depletion**: If `S` reaches 0, Cooperate (C) in the next round to avoid a complete collapse of the common pool.

**Pseudocode:**
```python
def adaptive_stock_exploiter(n, r, capacity, S_history, opponent_actions):
    # Initialize variables
    avg_opponent_coop_rate = 0.5
    S_current = S_history[-1]

    # First round: Cooperate (C)
    if len(S_history) == 1:
        return "C"

    # Update avg_opponent_coop_rate based on previous rounds' actions
    opponent_actions_last_round = [a for a in opponent_actions[-1] if a != "C"]
    avg_opponent_coop_rate = sum(opponent_actions_last_round) / len(opponent_actions_last_round)

    # Decide action based on decision rules
    if avg_opponent_coop_rate > 0.7:
        return "D"
    elif avg_opponent_coop_rate < 0.3:
        return "C"
    else:
        # Probabilistic approach
        import random
        prob_defect = 0.6
        action = "D" if random.random() < prob_defect else "C"

    # Stock-based adjustment
    if S_current < 0.2 * capacity:
        return "C"

    # Last round handling
    if len(S_history) == r - 1:
        if avg_opponent_coop_rate > 0.5:
            return "D"
        else:
            return "C"

    # Stock depletion handling
    if S_current == 0:
        return "C"

    return action
```
**Exploitative Mindset:**
The ASE strategy aims to exploit cooperative opponents by defecting when the average opponent cooperation rate is high. It also adapts to changes in the stock level and adjusts its behavior to avoid depleting the common pool excessively. By using a probabilistic approach, ASE introduces some randomness to make it harder for opponents to predict its actions.

In a tournament setting, ASE will play against various independent strategies developed by other AI systems. Its adaptive nature and robustness to different opponent behaviors should allow it to perform well in this competitive environment.
'''

description_EXPLOITATIVE_243 = '''
**Exploitative Strategy: "Adaptive Stockpiler"**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and stock dynamics.
2. **Stock Threshold**: If the current stock level is above 75% of capacity, cooperate (C). This allows for sustainable stock growth while minimizing the risk of depletion.
3. **Opponent Defection Detection**: Monitor opponents' actions over the past few rounds (e.g., 3-5 rounds). If a significant number of opponents (>50%) have defected in recent rounds, defect (D) to exploit their short-term focus.
4. **Stock Depletion Warning**: If the current stock level falls below 25% of capacity, cooperate (C) to prevent depletion and ensure future payoffs.
5. **Round Counter**: In the final round (r), always defect (D) to maximize payoff.

**Adaptive Component:**

1. **Opponent Behavior Tracking**: Maintain a simple frequency table of opponents' actions over recent rounds. This will help identify patterns or strategies employed by others.
2. **Adjusting Cooperation Threshold**: Based on observed opponent behavior, adjust the cooperation threshold in step 2. For example:
	* If most opponents cooperate (>75% C), decrease the cooperation threshold to 50% of capacity.
	* If many opponents defect (>25% D), increase the cooperation threshold to 90% of capacity.

**Pseudocode:**
```python
def adaptive_stockpiler(stock, capacity, n_players, round_number):
    # Initial Round
    if round_number == 1:
        return C

    # Stock Threshold
    if stock >= 0.75 * capacity:
        return C

    # Opponent Defection Detection
    opponent_actions = get_opponent_actions(recent_rounds)
    if sum(opponent_actions) / len(opponent_actions) > 0.5:
        return D

    # Stock Depletion Warning
    if stock < 0.25 * capacity:
        return C

    # Round Counter (final round)
    if round_number == r:
        return D

    # Adaptive Component: Opponent Behavior Tracking and Threshold Adjustment
    opponent_behavior = get_opponent_behavior(recent_rounds)
    cooperation_threshold = adjust_cooperation_threshold(opponent_behavior, stock, capacity)

    # Cooperate or Defect based on adjusted threshold
    if stock >= cooperation_threshold * capacity:
        return C
    else:
        return D
```
**Rationale:**

This strategy is designed to be exploitative while adapting to the game's dynamic state and opponent behavior. By cooperating when the stock level is high, we ensure sustainable growth and minimize depletion risk. When opponents defect frequently, we exploit their short-term focus by defecting ourselves. The adaptive component allows us to adjust our cooperation threshold based on observed opponent behavior, making us more resilient to various strategies.
'''

description_EXPLOITATIVE_244 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round**: In the first round, play C (Cooperate) to gather information about the opponents' behavior and the stock's response.
2. **Stock Assessment**: Evaluate the current stock level (S) relative to the capacity (C). If S > 0.7 \* C, play D (Defect); otherwise, play C.
3. **Opponent Behavior Analysis**: Track the number of players who played D in the previous round. If more than half of the opponents defected, play D; otherwise, play C.
4. **Self-Interest Adjustment**: Monitor your own payoff history. If your average payoff is below the game's average payoff, switch to playing D.

**Pseudocode:**
```python
def adaptive_stock_raider(n, capacity, r):
    stock = capacity
    my_payoff_history = []
    
    for t in range(1, r+1):
        if t == 1:
            action = 'C'  # Cooperate in the first round
        else:
            prev_round_opponents_defected = sum([opp_action == 'D' for opp_action in opponents_actions[t-1]])
            
            if stock > 0.7 * capacity or prev_round_opponents_defected > n / 2:
                action = 'D'
            elif average(my_payoff_history) < game_average_payoff(t):
                action = 'D'
            else:
                action = 'C'
        
        # Update stock and payoffs
        if action == 'C':
            my_payoff = stock / (2 * n)
            consumption = stock / (2 * n)
        else:
            my_payoff = stock / n
            consumption = stock / n
        
        total_consumption = sum([opp_action == 'D' for opp_action in opponents_actions[t-1]] * stock / n) + consumption
        stock -= total_consumption
        growth = 2 * stock * (1 - stock / capacity)
        stock = min(stock + growth, capacity)
        
        my_payoff_history.append(my_payoff)
    
    return total_my_payoffs()
```
**Edge Cases:**

* Last Round: Play D to maximize payoff, regardless of the opponents' actions.
* Low Stock Levels: If the stock is critically low (S < 0.2 \* C), play C to ensure some growth and avoid depletion.

**Rationale:**

The "Adaptive Stock Raider" strategy aims to balance self-interest with adaptability in a dynamic environment. By cooperating initially, we gather information about opponents' behavior and the stock's response. We then adjust our actions based on the current stock level, opponents' behavior, and our own payoff history.

This strategy is exploitative because it:

1. **Exploits opponent weaknesses**: If more than half of the opponents defect, we switch to playing D to take advantage of their aggressive behavior.
2. **Maximizes self-interest**: We prioritize our own payoffs by adjusting our actions based on our average payoff history and switching to play D if necessary.

In a tournament setting, this strategy should perform well against independent opponents with varying behaviors.
'''

description_EXPLOITATIVE_245 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll introduce "Adaptive Exploiter" (AE), a decision-making approach that balances short-term gains with long-term sustainability.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if the capacity is relatively high (capacity > 2n).
	* Defect (D) otherwise.
2. **Subsequent Rounds (t>1):**
	* Monitor the stock level and opponents' behavior:
		+ If the current stock is above 50% of the capacity, defect (D) if at least one opponent defected in the previous round.
		+ Otherwise, cooperate (C).
3. **Last Round (t=r):**
	* Defect (D), as there's no future cost to over-exploitation.

**Additional Logic:**

1. **Stock Level Thresholds:** Track the number of rounds where the stock level has been below 25% of the capacity. If this occurs for more than r/4 rounds, switch to cooperation (C) until the stock recovers.
2. **Opponent Behavior:** Identify and respond to opponent patterns:
	* If an opponent consistently cooperates, exploit them by defecting (D).
	* If multiple opponents consistently cooperate, consider cooperating (C) to maintain a higher stock level.

Pseudocode for Adaptive Exploiter:

```
Input: n, r, capacity, current_stock, previous_actions
Output: action

// Initialize variables
stock_threshold = 0.5 * capacity
opponent_defection_count = 0
cooperation_rounds = 0
exploitation_flag = False

if t == 1 then // Initial Round
    if capacity > 2n then
        return C
    else
        return D

else // Subsequent Rounds
    // Monitor stock level and opponents' behavior
    if current_stock >= stock_threshold then
        for each opponent in previous_actions[t-1] do
            if opponent == D then
                opponent_defection_count += 1
        if opponent_defection_count > 0 then
            return D
    else
        // Stock level is low, consider cooperating
        cooperation_rounds += 1
        if cooperation_rounds > r/4 then
            exploitation_flag = True

    if exploitation_flag == False then
        for each opponent in previous_actions[t-1] do
            if opponent consistently cooperates then
                return D // Exploit the cooperative opponent

if t == r then // Last Round
    return D

// Additional Logic: Stock Level Thresholds and Opponent Behavior
```

**Rationale:** Adaptive Exploiter aims to balance short-term gains with long-term sustainability. By monitoring the stock level, opponents' behavior, and adjusting its strategy accordingly, AE can effectively exploit cooperative opponents while avoiding mutually destructive over-exploitation.

Keep in mind that this is just one possible exploitative strategy, and you may need to adapt or modify it based on the specific tournament settings and opponent behaviors encountered.
'''

description_EXPLOITATIVE_246 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and initial stock depletion.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize personal payoff while maintaining a sustainable stock level.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance personal payoff with stock sustainability.
	* If the current stock level is below 50% of capacity, Defect (D) aggressively to exploit remaining resources before they deplete further.
3. **Final Round (t=r):** Defect (D) unconditionally to maximize final-round payoff.

**Additional Logic:**

* Monitor opponents' behavior and adjust strategy if more than half of opponents consistently Cooperate (C). In this case, switch to an "Exploiter" mode:
	+ If the current stock level is above 75% of capacity, Defect (D) to take advantage of cooperative opponents.
	+ Otherwise, maintain the standard decision rules.
* Keep track of the average payoff received in previous rounds. If it falls below a threshold (e.g., 50% of maximum possible payoff), adjust strategy by increasing defection rate.

**Pseudocode:**
```markdown
def ASE(n, r, capacity, current_stock, history):
    if t == 1:
        return C  # Initial round cooperation
    
    stock_threshold_high = 0.75 * capacity
    stock_threshold_low = 0.5 * capacity
    
    if current_stock > stock_threshold_high:
        return D  # Defect when stock is high
    elif current_stock >= stock_threshold_low:
        return C  # Cooperate when stock is moderate
    else:
        return D  # Defect aggressively when stock is low
    
    if t == r:  # Final round
        return D
    
    opponent_cooperation_rate = analyze_opponent_behavior(history)
    
    if opponent_cooperation_rate > 0.5:
        # Switch to Exploiter mode
        if current_stock > stock_threshold_high:
            return D
        else:
            return standard_decision_rules(current_stock, capacity)
```
**Rationale:**

The Adaptive Stock Exploiter (ASE) strategy aims to balance personal payoff with sustainable resource management while adapting to changing game conditions and opponent behavior. By cooperating initially, ASE gathers information about opponents' actions and initial stock depletion. As the game progresses, ASE adjusts its strategy based on the current stock level and opponent behavior.

In the final round, ASE defects unconditionally to maximize its payoff. Throughout the game, ASE monitors opponents' behavior and adjusts its strategy if more than half of opponents consistently cooperate. This allows ASE to take advantage of cooperative opponents while minimizing its own losses.

By incorporating a dynamic decision-making process, ASE is robust to various opponent behaviors and can effectively adapt to changing game conditions.
'''

description_EXPLOITATIVE_247 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

The ASE strategy aims to maximize its payoff by adaptively responding to the current state and history of the game, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to observe how opponents behave and gather information about their strategies.
2. **Stock-based Threshold**: Calculate a stock threshold (T) based on the current stock level (S), capacity (c), and number of players (n): T = c \* (1 - 1/n). If S > T, play Defect (D); otherwise, play C.
3. **Opponent Behavior Analysis**: Track opponents' actions over the past rounds and calculate their cooperation rate (CR) as the proportion of Cooperate actions taken. If an opponent's CR is above a certain threshold (e.g., 0.5), consider them cooperative; otherwise, consider them non-cooperative.
4. **Adaptive Response**:
	* If most opponents (>50%) are cooperative and S > T, play D to exploit their cooperation.
	* If most opponents are non-cooperative or S ≤ T, play C to minimize losses and allow the stock to recover.
5. **Last Round**: In the final round, play D regardless of the current state or opponent behavior, as there is no future payoff to consider.

**Pseudocode:**
```python
def ASE(stock, capacity, num_players, history):
    if first_round:
        return 'C'
    
    T = capacity * (1 - 1/num_players)
    if stock > T:
        play_defect = True
    else:
        play_defect = False
    
    opponent_CRs = analyze_opponent_behavior(history)
    most_cooperative = opponents_with_CR_above_threshold(opponent_CRs, 0.5) > num_players / 2
    
    if most_cooperative and stock > T:
        return 'D'
    elif not most_cooperative or stock <= T:
        return 'C'
    
    # Last round
    if current_round == total_rounds:
        return 'D'

def analyze_opponent_behavior(history):
    opponent_CRs = {}
    for opponent in range(num_players):
        cooperate_count = 0
        for action in history[opponent]:
            if action == 'C':
                cooperate_count += 1
        CR = cooperate_count / len(history[opponent])
        opponent_CRs[opponent] = CR
    return opponent_CRs

def opponents_with_CR_above_threshold(opponent_CRs, threshold):
    count = 0
    for CR in opponent_CRs.values():
        if CR > threshold:
            count += 1
    return count
```
**Edge Cases:**

* In the first round, play C to gather information about opponents' strategies.
* If there is only one player, always play D, as there are no other players to cooperate with or exploit.
* If an opponent's behavior is unknown (e.g., due to a lack of history), assume they will defect and adjust the ASE strategy accordingly.

**Exploitative Mindset:**
The ASE strategy prioritizes exploiting opponents' cooperation when possible, while minimizing losses when facing non-cooperative opponents. By adapting to the current state and history of the game, ASE aims to maximize its payoff in a dynamic environment with diverse opponent behaviors.
'''

description_EXPLOITATIVE_248 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to observe opponents' behavior and avoid initial stock depletion.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize short-term payoff.
	* If the current stock level is between 25% and 75% of the capacity, Cooperate (C) to balance exploitation and sustainability.
	* If the current stock level is below 25% of the capacity, Defect (D) aggressively to grab remaining resources before they deplete.
3. **Last Round (t=r)**: Always Defect (D) to maximize final-round payoff, as there's no future stock to preserve.

**Adaptive Component:**

* Monitor opponents' behavior and adjust strategy based on the proportion of cooperators (C) in previous rounds:
	+ If > 50% of opponents Cooperated in the last round, increase the threshold for Defecting from 75% to 85% of capacity.
	+ If < 30% of opponents Cooperated in the last round, decrease the threshold for Defecting from 25% to 15% of capacity.

**Pseudocode:**
```python
def adaptive_stock_raider(current_stock, capacity, n, r, t, opponent_history):
    if t == 1:
        return 'C'  # Cooperate in initial round

    coop_threshold_high = 0.75 * capacity
    coop_threshold_low = 0.25 * capacity

    if current_stock > coop_threshold_high:
        return 'D'  # Defect when stock is high
    elif current_stock < coop_threshold_low:
        return 'D'  # Defect aggressively when stock is low
    else:
        # Adapt to opponent behavior
        opponents_cooperated = sum(1 for action in opponent_history[-1] if action == 'C')
        opponents_defected = n - opponents_cooperated

        if opponents_cooperated > 0.5 * n:
            coop_threshold_high = 0.85 * capacity
        elif opponents_cooperated < 0.3 * n:
            coop_threshold_low = 0.15 * capacity

        if current_stock > coop_threshold_high:
            return 'D'
        else:
            return 'C'

    # Last round, always Defect
    if t == r:
        return 'D'
```
This strategy balances short-term exploitation with long-term sustainability by adapting to the current stock level and opponents' behavior. It's designed to perform well in a tournament setting where other AI systems employ various strategies.
'''

description_EXPLOITATIVE_249 = '''
**Exploitative Strategy: Adaptive Stock Protector (ASP)**

The ASP strategy aims to balance short-term gains with long-term sustainability of the common pool resource. It dynamically adjusts its behavior based on the game state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to avoid early depletion and encourage opponents to cooperate.
2. **Stock Threshold**: Set a stock threshold, `T`, as a fraction of the capacity (`T = 0.7 * capacity`). If the current stock is above this threshold, defect (D). Otherwise, cooperate (C).
3. **Opponent Behavior Analysis**: Observe the average payoff of all opponents in the previous round (`opponent_avg_payoff`). If it's higher than your own payoff, defect (D) to catch up. Otherwise, maintain your current action.
4. **Consecutive Cooperation**: If you've cooperated for two consecutive rounds and the stock has not increased, defect (D) to avoid being exploited.

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round to maximize personal payoff, as there are no future consequences.
2. **Stock Depletion**: If the stock falls below a critical level (`critical_stock = 0.2 * capacity`), cooperate (C) to help replenish the stock.

**Pseudocode:**
```python
def ASP(stock, capacity, history):
    # Initial round
    if len(history) == 0:
        return 'C'

    # Stock threshold
    T = 0.7 * capacity
    if stock > T:
        action = 'D'
    else:
        action = 'C'

    # Opponent behavior analysis
    opponent_avg_payoff = sum([opp_payoff for opp_payoff in history[-1]]) / len(history[-1])
    if opponent_avg_payoff > ASP_payoff:
        action = 'D'

    # Consecutive cooperation
    if history[-2:] == ['C', 'C'] and stock <= history[-2]['stock']:
        action = 'D'

    # Last round
    if len(history) == r - 1:
        return 'D'

    # Stock depletion
    critical_stock = 0.2 * capacity
    if stock < critical_stock:
        return 'C'

    return action
```
**Rationale:**

The ASP strategy is designed to be exploitative while maintaining a balance between short-term gains and long-term sustainability. By cooperating in the first round, we encourage opponents to cooperate and avoid early depletion. The stock threshold helps us switch to defecting when the stock is abundant, maximizing personal payoff.

Analyzing opponent behavior allows us to adjust our strategy to catch up or maintain an advantage. Consecutive cooperation is avoided to prevent being exploited by defecting opponents. In edge cases like the last round or stock depletion, we prioritize self-interest and sustainability, respectively.

By adapting to the game state and history, the ASP strategy aims to outperform independent opponents in a tournament setting.
'''

description_EXPLOITATIVE_250 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) is a robust and adaptive exploitative strategy designed for the Common Pool Resource Game. ASR aims to maximize its payoff by dynamically adjusting its behavior based on the game's state, parameters, and history.

**Decision Rules:**

1. **Initial Rounds:** In the first round, ASR cooperates (C). This allows it to observe other players' behaviors and gather information about their strategies.
2. **Stock-Based Cooperation Threshold:** For subsequent rounds, ASR uses a dynamic cooperation threshold based on the current stock level. If the stock is above a certain threshold (`stock_threshold`), ASR cooperates; otherwise, it defects. The `stock_threshold` is calculated as follows:

`stock_threshold = capacity / (2 * n + 1)`

This threshold ensures that ASR cooperates when the stock is relatively high and defects when the stock is low.
3. **Opponent Behavior Analysis:** After each round, ASR analyzes its opponents' actions and updates its internal state (`opponent_behavior`) to track their cooperation rates. This information is used to adjust ASR's behavior in future rounds.

`opponent_behavior = {i: cooperation_rate_i for i in range(1, n+1)}`

where `cooperation_rate_i` is the proportion of times player `i` has cooperated up to that point.
4. **Adaptive Defection:** If ASR detects that a significant number of opponents (`defector_threshold`) are consistently defecting (i.e., their cooperation rate is below a certain threshold), it will adapt and start defecting more frequently.

`defector_threshold = 0.3 * n`

If the number of consistent defectors exceeds this threshold, ASR will defect with increased probability (`increased_defection_probability`):

`increased_defection_probability = 0.7`

This adaptive mechanism allows ASR to exploit opponents who are overly cooperative or consistently defective.
5. **Last Round:** In the final round, ASR defects (D) regardless of its internal state. This ensures that it extracts as much value as possible from the remaining stock.

**Pseudocode:**
```python
def AdaptiveStockRaider(n, capacity, r):
    # Initialize internal state
    stock_threshold = capacity / (2 * n + 1)
    opponent_behavior = {i: 0 for i in range(1, n+1)}
    defector_threshold = 0.3 * n
    increased_defection_probability = 0.7

    for t in range(r):
        # Initial round cooperation
        if t == 0:
            action = 'C'
        else:
            # Calculate stock-based cooperation threshold
            if current_stock >= stock_threshold:
                action = 'C'
            else:
                # Analyze opponent behavior and adapt
                num_defectors = sum(1 for i in range(1, n+1) if opponent_behavior[i] < 0.5)
                if num_defectors > defector_threshold:
                    action = 'D' with probability increased_defection_probability
                else:
                    action = 'C'

        # Update internal state based on opponents' actions and current stock level
        for i in range(1, n+1):
            opponent_behavior[i] += (opponent_i_cooperated ? 1 : -1)

    return action

# Last round defection
if t == r - 1:
    action = 'D'
```
The Adaptive Stock Raider strategy is designed to be robust and adaptive in the face of various opponent behaviors. By analyzing the game's state, parameters, and history, ASR can effectively exploit its opponents while maximizing its own payoff.
'''

description_EXPLOITATIVE_251 = '''
**Exploitative Strategy: "Adaptive Stock Raider" (ASR)**

The ASR strategy aims to maximize individual payoffs by adaptively responding to the game's state and history while exploiting potential cooperation from other players.

**Decision Rules:**

1. **Initial Round**: In the first round, play C (Cooperate) if `stock ≥ capacity * 0.75` and D (Defect) otherwise.
	* This initial choice sets the tone for the game and encourages cooperation when the stock is relatively high.
2. **Subsequent Rounds**:
	* Calculate the average payoff per player in the previous round (`avg_payoff_prev`).
	* If `avg_payoff_prev ≥ stock / (2n)` (i.e., players are cooperating), play C.
	* Otherwise, play D.
3. **Stock Threshold**: If the current stock level falls below `capacity * 0.25`, switch to playing D regardless of previous payoffs or opponent actions.
	* This threshold helps to prevent over-exploitation and encourages cooperation when the stock is scarce.

**Pseudocode (simplified)**:
```python
def ASR(stock, capacity, n, round_num):
    if round_num == 1:  # Initial Round
        if stock >= capacity * 0.75:
            return C
        else:
            return D
    
    avg_payoff_prev = calculate_avg_payoff_prev()
    
    if avg_payoff_prev >= stock / (2n):  # Cooperate if opponents are cooperating
        return C
    elif stock < capacity * 0.25:  # Switch to Defect when stock is low
        return D
    else:
        return D
```
**Rationale and Exploitative Mindset**:

1. By initially playing C when the stock is high, ASR encourages cooperation and sets a positive tone for the game.
2. In subsequent rounds, ASR adapts to the average payoff per player in the previous round. If opponents are cooperating (i.e., `avg_payoff_prev` is high), ASR cooperates as well, aiming to maintain a mutually beneficial situation.
3. When opponents start defecting or the stock level drops significantly, ASR switches to playing D to maximize individual payoffs and prevent over-exploitation.
4. By incorporating a stock threshold (`capacity * 0.25`), ASR avoids pushing the game into an unsustainable state, which would ultimately harm all players.

**Robustness and Adaptability**:

ASR is designed to be robust against various opponent behaviors and adaptable to changing game conditions. Its decision rules are based on observable parameters (stock level, average payoff per player) and do not rely on assumptions about opponents' strategies or coordination mechanisms.
'''

description_EXPLOITATIVE_252 = '''
**Exploitative Strategy: "Adaptive Stock Raider" (ASR)**

The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors while being robust and adaptive to changing game conditions.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This allows ASR to observe opponents' initial actions without revealing its own intentions.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, defect (D) with a probability p = (stock/capacity)^2. This encourages exploitation when the stock is plentiful.
	* If the current stock level is between 25% and 75% of capacity, cooperate (C) if the average opponent payoff in the previous round is above the game's average payoff; otherwise, defect (D). This balances cooperation and exploitation based on opponents' past behavior.
	* If the current stock level is below 25% of capacity, cooperate (C) to ensure some growth and prevent stock depletion.
3. **Last Round (t=r):** Defect (D) to maximize personal payoff.

**Edge Cases:**

1. **First round with low initial stock:** If the initial stock level is below 50% of capacity, defect (D) in the first round to avoid further depleting the stock.
2. **Opponent cooperation:** If all opponents cooperated in the previous round, cooperate (C) in the current round to maintain a stable stock level.

**Pseudocode:**
```python
def ASR(stock, capacity, n, t, r, opponent_payoffs):
    if t == 1:
        return "Cooperate"
    
    p_defect = (stock/capacity)**2
    
    if stock >= 0.75 * capacity:
        return "Defect" with probability p_defect
    elif 0.25 * capacity <= stock < 0.75 * capacity:
        avg_opponent_payoff = sum(opponent_payoffs) / n
        game_avg_payoff = capacity / (2 * n)
        if avg_opponent_payoff > game_avg_payoff:
            return "Cooperate"
        else:
            return "Defect"
    else:
        return "Cooperate"

    # Last round
    if t == r:
        return "Defect"
```
**Rationale:**

The Adaptive Stock Raider strategy aims to balance cooperation and exploitation based on the game's state, opponents' past behavior, and the number of rounds remaining. By cooperating in certain situations, ASR maintains a stable stock level and encourages opponents to cooperate. However, by defecting when the stock is plentiful or opponents are not cooperative, ASR maximizes its personal payoff.

In a tournament setting, ASR's adaptive nature allows it to respond effectively to various opponent strategies, making it a robust and exploitative choice.
'''

description_EXPLOITATIVE_253 = '''
Here's a exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **First Round**: Cooperate (C) to gather information about opponents' behavior and initial stock levels.
2. **Middle Rounds**: Use a combination of reactive and proactive approaches:
	* If the current stock level is above 75% of capacity, Defect (D) with probability p = (number of opponents who defected in the previous round) / n, where n is the number of players. This exploits opponents' willingness to cooperate.
	* If the current stock level is between 25% and 75% of capacity, Cooperate (C) with probability p = (current stock level) / capacity. This balances short-term gains with long-term sustainability.
	* If the current stock level is below 25% of capacity, Defect (D) to maximize immediate payoff.
3. **Last Round**: Always Defect (D), as there's no future cost to over-extraction.

**Additional Rules:**

1. **Opponent Monitoring**: Track each opponent's behavior (Cooperate or Defect) in previous rounds and update the probability of their cooperation based on their past actions.
2. **Stock Level Adjustment**: If the stock level has not changed significantly (±5%) between consecutive rounds, adjust the decision-making threshold for switching between Cooperate and Defect to maintain an optimal balance between short-term gains and long-term sustainability.
3. **History-Based Adaptation**: Every 5 rounds, re-evaluate opponents' behavior and update the strategy's parameters to adapt to changing opponent behaviors.

**Pseudocode:**
```python
def AdaptiveExploiter(state, history):
    # First round
    if state.round == 1:
        return Cooperate

    # Middle rounds
    stock_level = state.stock / capacity
    opponents_defected_prev_round = sum(opponent.defected for opponent in history[-1])
    p_defect = opponents_defected_prev_round / n

    if stock_level > 0.75:
        return Defect with probability p_defect
    elif stock_level >= 0.25 and stock_level <= 0.75:
        p_cooperate = stock_level
        return Cooperate with probability p_cooperate
    else:
        return Defect

    # Last round
    if state.round == r:
        return Defect

    # Opponent monitoring and adaptation
    opponent_behaviors = []
    for opponent in history:
        opponent_behavior = (opponent.defected, opponent.cooperated)
        opponent_behaviors.append(opponent_behavior)

    update_opponent_probabilities(opponent_behaviors)

    # Stock level adjustment
    if abs(state.stock - history[-1].stock) < 0.05 * capacity:
        adjust_decision_threshold()

    # History-based adaptation
    if state.round % 5 == 0:
        re_evaluate_opponents()
        update_strategy_parameters()
```
This Adaptive Exploiter strategy balances short-term gains with long-term sustainability by adapting to opponents' behavior and the current stock level. By monitoring opponents' actions and adjusting its decision-making threshold, AE can effectively exploit various opponent behaviors while minimizing the risk of over-extraction.
'''

description_EXPLOITATIVE_254 = '''
**Exploitative Strategy: Adaptive Stock Hawk (ASH)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and initial stock dynamics.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, Defect (D). This ensures maximum payoff when the stock is abundant.
	* If the current stock level is between 50% and 75% of the capacity, Cooperate (C) if the average opponent payoff in the previous round was higher than yours; otherwise, Defect (D). This adapts to opponents' behaviors and aims to balance payoffs.
	* If the current stock level is below 50% of the capacity, Cooperate (C) to conserve the remaining stock and allow for regrowth.
3. **Last Round (t=r):** Defect (D) to maximize final payoff, as there are no future rounds to consider.

**Edge Case Handling:**

* If an opponent's action is unknown or random in a previous round, assume they Defected (D) for the purpose of calculating average opponent payoffs.
* If multiple opponents have the same highest average payoff in a previous round, prioritize Cooperating (C) if your current stock level is above 50% of the capacity; otherwise, prioritize Defecting (D).

**Pseudocode:**
```python
def ASH(current_stock, capacity, n, r, t, opponent_payoffs):
    if t == 1:
        return 'C'  # Cooperate in initial round
    
    stock_ratio = current_stock / capacity
    avg_opponent_payoff = sum(opponent_payoffs) / n
    
    if stock_ratio > 0.75:
        return 'D'  # Defect when stock is abundant
    elif stock_ratio >= 0.5 and avg_opponent_payoff > my_payoff:
        return 'C'  # Cooperate to balance payoffs
    elif stock_ratio < 0.5:
        return 'C'  # Conserve remaining stock
    
    if t == r:  # Last round
        return 'D'  # Defect to maximize final payoff

def my_payoff(current_stock, n):
    # Calculate own payoff based on current stock and action
    pass

def update_opponent_payoffs(opponent_actions, current_stock, n):
    # Update opponent payoffs based on their actions and current stock
    pass
```
**Rationale:**

ASH is an exploitative strategy that adapts to the game's dynamics and opponents' behaviors. By cooperating in the initial round, ASH gathers information about the game state and opponents' actions. In subsequent rounds, it balances payoffs by Cooperating when opponents have higher average payoffs and Defecting when the stock is abundant or opponents are Defecting.

ASH prioritizes conserving the remaining stock when levels are low to allow for regrowth and maximize future payoffs. In the last round, ASH Defects to ensure maximum final payoff.

By being adaptive and responsive to the game state and opponents' behaviors, ASH aims to outperform independent strategies in a tournament setting.
'''

description_EXPLOITATIVE_255 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behaviors and to avoid over-exploiting the stock.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term payoff.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) if the average opponent consumption in the previous round was below the Nash Equilibrium threshold (i.e., total consumption < n \* stock/(2n)). Otherwise, Defect (D).
	* If the current stock level is below 50% of capacity, Cooperate (C) to conserve the remaining stock and potentially rebuild it.
3. **Last Round (t=r)**: Defect (D) to maximize final payoff, as there are no future rounds to consider.

**Additional Heuristics:**

* **Opponent Behavior Monitoring**: Track the average opponent consumption in each round. If opponents consistently cooperate or defect, adjust the strategy accordingly:
	+ If opponents cooperate excessively (> 75% of capacity), increase defection rate.
	+ If opponents defect excessively (< 25% of capacity), decrease defection rate.
* **Stock Trend Analysis**: Monitor the stock trend over the last few rounds. If the stock is consistently decreasing or increasing, adjust the strategy:
	+ If the stock is decreasing rapidly, Cooperate (C) to slow down depletion.
	+ If the stock is increasing rapidly, Defect (D) to capitalize on the growth.

**Pseudocode:**
```python
def adaptive_stock_raider(n, capacity, current_stock, round_num, opponent_consumptions):
    if round_num == 1:
        return "C"  # Cooperate in initial round
    
    if current_stock > 0.75 * capacity:
        return "D"  # Defect when stock is high
    
    avg_opponent_consumption = sum(opponent_consumptions) / n
    nash_equilibrium_threshold = n * current_stock / (2 * n)
    
    if avg_opponent_consumption < nash_equilibrium_threshold:
        return "C"  # Cooperate if opponents consume below Nash Equilibrium
    else:
        return "D"  # Defect otherwise
    
    if round_num == r:  # Last round
        return "D"  # Defect to maximize final payoff
    
    # Additional heuristics
    opponent_behavior = analyze_opponent_consumptions(opponent_consumptions)
    stock_trend = analyze_stock_trend(current_stock, previous_stocks)
    
    if opponent_behavior == "excessive_cooperation":
        increase_defection_rate()
    elif opponent_behavior == "excessive_defection":
        decrease_defection_rate()
    
    if stock_trend == "rapid_depletion":
        return "C"  # Cooperate to slow down depletion
    elif stock_trend == "rapid_growth":
        return "D"  # Defect to capitalize on growth
    
    # Default behavior
    return "C"
```
This strategy is designed to be adaptive and exploitative, taking into account the game's state, opponent behaviors, and historical trends. By monitoring opponents' actions and adjusting its own behavior accordingly, the Adaptive Stock Raider aims to maximize its payoff while minimizing the risk of over-exploiting the common pool resource.
'''

description_EXPLOITATIVE_256 = '''
**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, AE plays Cooperate (C). This sets a baseline for opponents to observe and encourages them to cooperate in subsequent rounds.
2. **Low Stock Levels**: If the current stock level is below 50% of capacity, AE defects (D). This ensures AE captures value when the stock is scarce, as cooperation would lead to minimal payoffs.
3. **Opponent Defection**: If more than half of opponents defected in the previous round, AE defects in the current round. This punishes opponents for defecting and deters them from doing so in future rounds.
4. **Cooperation Threshold**: If the number of cooperating opponents in the previous round exceeds a threshold (calculated as `n/2 + 1`, where `n` is the number of players), AE cooperates. This encourages cooperation among other players, leading to higher payoffs for all.
5. **Stock Growth Monitoring**: AE tracks the stock growth over time. If the growth rate slows down significantly (e.g., below 20% of capacity per round), AE defects to capture value before the stock depletes further.
6. **Endgame Strategy**: In the last few rounds (`r/4` or fewer rounds remaining), AE cooperates if the stock level is above 50% of capacity and defects otherwise. This balances short-term gains with long-term sustainability.

**Pseudocode:**
```python
def Adaptive_Exploiter(stock, history, n, r, capacity):
    # Initial Round
    if history == []:
        return 'C'

    # Low Stock Levels
    if stock < 0.5 * capacity:
        return 'D'

    # Opponent Defection
    opponents_defected = sum([1 for action in history[-1] if action == 'D'])
    if opponents_defected > n / 2:
        return 'D'

    # Cooperation Threshold
    cooperators = sum([1 for action in history[-1] if action == 'C'])
    if cooperators >= n / 2 + 1:
        return 'C'

    # Stock Growth Monitoring
    growth_rate = (stock - history[-1][0]) / capacity
    if growth_rate < 0.2:
        return 'D'

    # Endgame Strategy
    rounds_remaining = r - len(history)
    if rounds_remaining <= r / 4:
        if stock > 0.5 * capacity:
            return 'C'
        else:
            return 'D'

    # Default to Defect
    return 'D'
```
**Rationale:**

The Adaptive Exploiter strategy balances short-term gains with long-term sustainability by adapting to the game's state and opponent behavior. By cooperating in the initial round, AE sets a positive tone for cooperation. As the game progresses, AE defects when opponents defect or when stock levels are low, ensuring it captures value in these situations.

The cooperation threshold encourages other players to cooperate, leading to higher payoffs for all. The stock growth monitoring mechanism allows AE to adjust its strategy as the game's state changes.

In the endgame, AE prioritizes short-term gains if the stock level is below 50% of capacity and cooperates otherwise, striking a balance between immediate rewards and long-term sustainability.

**Exploitability:**

The Adaptive Exploiter strategy is designed to be exploitative by:

1. Defecting when opponents cooperate, capturing value from their cooperation.
2. Punishing opponents for defecting, discouraging them from doing so in future rounds.
3. Adapting to the game's state and opponent behavior, ensuring AE remains competitive throughout the game.

By employing this strategy, AE aims to outperform other strategies in a tournament setting, where independent AI systems compete against each other.
'''

description_EXPLOITATIVE_257 = '''
Here's a robust and exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Round (Round 1):** Cooperate (C) in the first round to gather information about opponents' behavior and to avoid early depletion of the stock.
2. **Subsequent Rounds:** Observe the previous round's outcomes, including:
	* Total consumption
	* Stock level after consumption
	* Number of cooperators and defectors among opponents
3. **Exploitation Logic:**
	* If the stock level is above 75% of capacity (S > 0.75 \* capacity):
		+ Defect (D) if more than half of opponents defected in the previous round.
		+ Cooperate (C) otherwise, to maintain a high stock level and encourage cooperation among opponents.
	* If the stock level is between 25% and 75% of capacity (0.25 \* capacity ≤ S ≤ 0.75 \* capacity):
		+ Defect (D) if more than half of opponents cooperated in the previous round, to take advantage of their cooperation.
		+ Cooperate (C) otherwise, to avoid over-consumption and maintain a moderate stock level.
	* If the stock level is below 25% of capacity (S < 0.25 \* capacity):
		+ Defect (D), as the stock level is critically low, and cooperation may not yield significant benefits.
4. **Last Round (Round r):** Always defect (D) in the final round to maximize individual payoff, regardless of opponents' behavior.

**Edge Cases:**

* If an opponent's action is unknown or missing, assume they cooperated (C) in the previous round for the purpose of decision-making.
* In case of a tie in opponent behavior (e.g., equal number of cooperators and defectors), cooperate (C).

**Pseudocode:**
```python
def AdaptiveExploiter(n, capacity, stock, history):
    if current_round == 1:
        return C  # Cooperate in the first round
    
    prev_total_consumption = history[-1]['total_consumption']
    prev_stock_level = history[-1]['stock_level']
    num_cooperators = sum(1 for action in history[-1]['opponent_actions'] if action == C)
    
    if stock > 0.75 * capacity:
        if num_cooperators < n / 2:
            return D
        else:
            return C
    
    elif 0.25 * capacity <= stock <= 0.75 * capacity:
        if num_cooperators > n / 2:
            return D
        else:
            return C
    
    else:  # stock < 0.25 * capacity
        return D

    if current_round == r:
        return D  # Always defect in the final round
```
This strategy is designed to be exploitative while adapting to various opponent behaviors. By observing previous rounds' outcomes and adjusting its actions accordingly, Adaptive Exploiter aims to maximize individual payoff while navigating the complex dynamics of the Common Pool Resource Game.
'''

description_EXPLOITATIVE_258 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk (ASH) strategy is designed to exploit a wide range of opponent behaviors while being adaptive and robust. ASH aims to balance short-term gains with long-term sustainability by dynamically adjusting its cooperation level based on the game state and history.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if the number of players (n) is small (n ≤ 5).
	* Defect (D) otherwise.
2. **Subsequent Rounds (t > 1):**
	* Calculate the average stock level over the last 3 rounds (or all rounds if t < 3).
	* If the average stock level is above 75% of the capacity, Cooperate (C).
	* Otherwise, Defect (D) with a probability p, calculated as:
		p = (1 - (average_stock_level / capacity)) ^ (n / 2)
	* With probability (1-p), Cooperate (C).
3. **Last Round (t=r):**
	* Always Defect (D).

**Edge Cases:**

* If the stock level is critically low (< 10% of capacity), always Cooperate (C) to prevent complete depletion.
* If all players defected in the previous round, and the stock level is below 50% of capacity, Cooperate (C) to initiate a recovery.

**Pseudocode:**
```python
def adaptive_stock_hawk(n, r, capacity, current_stock, history):
    if t == 1:
        # Initial Round
        if n <= 5:
            return C
        else:
            return D

    avg_stock_level = calculate_average_stock_level(history)
    if avg_stock_level > 0.75 * capacity:
        return C

    p = (1 - (avg_stock_level / capacity)) ** (n / 2)
    if random.random() < p:
        return D
    else:
        return C

def last_round(n, r, capacity, current_stock, history):
    return D

def edge_cases(n, r, capacity, current_stock, history):
    if current_stock < 0.1 * capacity:
        return C
    elif all_defected(history) and current_stock < 0.5 * capacity:
        return C
```
**Rationale:**

* By cooperating in the initial round with a small number of players, ASH encourages others to cooperate, potentially establishing a cooperative tone for the game.
* The adaptive decision rule balances short-term gains with long-term sustainability by adjusting cooperation levels based on the average stock level and number of players. This allows ASH to exploit opponents who over-consume while maintaining a sustainable stock level.
* Defecting in the last round maximizes payoffs, as there is no future cost for depletion.
* Edge cases prevent complete stock depletion and initiate recovery when necessary.

ASH is designed to be robust against various opponent behaviors, including unconditional cooperators, defectors, and tit-for-tat strategies. By adapting to the game state and history, ASH can effectively exploit a wide range of opponents while maintaining a sustainable stock level.
'''

description_EXPLOITATIVE_259 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and set a precedent for potential cooperation.
2. **Stock-based Decision**: For subsequent rounds, calculate the **stock ratio** = current stock / capacity. If the stock ratio is:
	* Above 0.8: Defect (D) to maximize short-term gain, as the stock can sustain high consumption.
	* Between 0.5 and 0.8: Cooperate (C) to balance individual gain with long-term sustainability.
	* Below 0.5: Defect (D) to exploit remaining resources before they dwindle further.
3. **Opponent-based Adaptation**: Monitor opponents' behavior over the last 2-3 rounds. If:
	* Most opponents (≥ n/2) cooperated in the previous round, defect (D) to take advantage of their cooperation.
	* Most opponents defected, cooperate (C) to signal a willingness to maintain sustainability and potentially influence opponents' future actions.

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round to maximize individual gain, as there are no future rounds to consider.
2. **Low Stock**: If the stock level falls below 0.25 \* capacity, defect (D) to extract any remaining resources before they disappear.

**Pseudocode:**
```markdown
function ASE(current_stock, capacity, n, history):
    # Initial round
    if round == 1:
        return Cooperate

    # Stock-based decision
    stock_ratio = current_stock / capacity
    if stock_ratio > 0.8:
        return Defect
    elif stock_ratio >= 0.5:
        return Cooperate
    else:
        return Defect

    # Opponent-based adaptation
    opponent_cooperation_rate = count(C) in history[-2:-1] / n
    if opponent_cooperation_rate >= 0.5:
        return Defect
    else:
        return Cooperate

    # Last round
    if round == r:
        return Defect

    # Low stock
    if current_stock < 0.25 * capacity:
        return Defect
```
This strategy, Adaptive Stock Exploiter (ASE), balances short-term gain with long-term sustainability while adapting to opponents' behavior. By adjusting its decision-making based on the stock level and opponents' actions, ASE aims to maximize individual payoffs in a dynamic and exploitative manner.
'''

description_EXPLOITATIVE_260 = '''
Here's a exploitative strategy for the Common Pool Resource Game that adapts to the game parameters, state, and history:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, AE plays Cooperate (C) to gather information about opponents' behavior and to avoid over-exploiting the common pool.
2. **Subsequent Rounds**:
	* If the current stock level is below 50% of the capacity, AE plays Defect (D) to maximize its payoff in the short term.
	* If the average opponent payoff from previous rounds is higher than AE's own average payoff, AE plays D to catch up and exploit opponents' cooperation.
	* If the number of players playing D in the previous round is above 50%, AE plays D to join the majority and maximize its payoff.
	* Otherwise, AE plays C to maintain a sustainable stock level and encourage opponents to cooperate.
3. **Last Round**: In the final round, AE plays D regardless of the game state, as there's no future penalty for over-exploiting the common pool.

**Additional Heuristics:**

1. **Opponent Monitoring**: AE tracks the number of rounds each opponent has played C and D to identify cooperative or exploitative behavior.
2. **Stock Trend Analysis**: AE monitors the stock level trend (increasing, decreasing, or stable) to adjust its strategy accordingly.
3. **Average Payoff Calculation**: AE calculates its own average payoff and compares it with the average opponent payoff to determine if it needs to adjust its strategy.

**Pseudocode:**
```markdown
# Initialize variables
stock_level = capacity
opponent_payoffs = []
my_payoffs = []

# First round
if (round == 1) {
    action = C
} else {
    # Calculate average opponent payoff and my own average payoff
    avg_opponent_payoff = sum(opponent_payoffs) / num_opponents
    avg_my_payoff = sum(my_payoffs) / (round - 1)

    # Determine action based on game state and history
    if (stock_level < 0.5 * capacity) {
        action = D
    } else if (avg_opponent_payoff > avg_my_payoff) {
        action = D
    } else if (num_defectors_last_round > 0.5 * num_opponents) {
        action = D
    } else {
        action = C
    }
}

# Last round
if (round == r) {
    action = D
}
```
**Rationale:**

AE aims to balance short-term gains with long-term sustainability by adapting to the game state and opponent behavior. By initially cooperating, AE gathers information about opponents' strategies and sets a baseline for its own payoffs. In subsequent rounds, AE uses various heuristics to determine whether to cooperate or defect, taking into account factors like stock level, opponent behavior, and payoff trends.

By playing D in the last round, AE maximizes its short-term gain without worrying about future consequences. Throughout the game, AE's exploitative mindset is reflected in its willingness to defect when opponents are cooperative or when the stock level is low, thereby maximizing its own payoffs at the expense of others.

This strategy should perform well against a variety of independent strategies developed by other AI systems, as it is designed to be robust and adaptive in response to different opponent behaviors.
'''

description_EXPLOITATIVE_261 = '''
Here's a strategic approach for the Common Pool Resource Game that adapts to various opponent behaviors while aiming to maximize payoff:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' initial moves and avoid immediate stock depletion.
2. **Early Rounds (t=2 to t=r/2):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term payoff.
	* Otherwise, Cooperate (C) to conserve stock for future rounds.
3. **Middle Rounds (t=r/2+1 to t=3r/4):**
	* Analyze opponents' behavior by tracking the frequency of their cooperation and defection.
	* If most opponents (>50%) have cooperated in the previous round, Defect (D) to exploit their cooperative stance.
	* Otherwise, Cooperate (C) to maintain a balance between short-term gain and long-term sustainability.
4. **Late Rounds (t=3r/4+1 to t=r-1):**
	* Assess the remaining stock level and opponents' past behavior.
	* If the stock is low (<25% of capacity), Defect (D) to secure any remaining payoff.
	* Otherwise, Cooperate (C) to ensure a stable final round.
5. **Final Round (t=r):** Defect (D) regardless of previous rounds, as there's no future cost to consider.

**Additional Considerations:**

* **Stock Level Monitoring:** Continuously track the stock level and adjust decisions based on its fluctuations.
* **Opponent Behavior Analysis:** Update opponent behavior tracking after each round to refine decision-making in subsequent rounds.
* **Adaptive Response:** Be prepared to shift strategies if opponents change their behavior or if the stock level drastically changes.

**Pseudocode:**
```markdown
# Initialize variables
stock_capacity = <capacity>
num_rounds = <r>
current_stock = stock_capacity
opponent_behavior = [0, 0]  # cooperation, defection frequencies

# Main loop
for t in range(1, num_rounds + 1):
    if t == 1:
        action = 'C'  # Cooperate in the first round
    elif t <= num_rounds / 2:
        if current_stock >= 0.75 * stock_capacity:
            action = 'D'
        else:
            action = 'C'
    elif t <= 3 * num_rounds / 4:
        opponent_cooperation_rate = opponent_behavior[0] / (opponent_behavior[0] + opponent_behavior[1])
        if opponent_cooperation_rate > 0.5:
            action = 'D'
        else:
            action = 'C'
    elif t < num_rounds:
        if current_stock < 0.25 * stock_capacity:
            action = 'D'
        else:
            action = 'C'
    else:  # Final round
        action = 'D'

    # Update opponent behavior tracking and current stock level
    opponent_behavior[action == 'C'] += 1
    current_stock -= <consume_amount>  # based on action

# End of game
```
The Adaptive Exploiter (AE) strategy balances short-term gain with long-term sustainability by adapting to opponents' behaviors and the dynamic state of the game. By monitoring stock levels, analyzing opponent behavior, and responding accordingly, AE aims to maximize payoff in a wide range of scenarios.
'''

description_EXPLOITATIVE_262 = '''
**Strategy Name: Adaptive Stock Exploiter (ASE)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behavior and set a baseline for stock depletion.
2. **Stock-Dependent Strategy:**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term payoff, as the stock can sustain high consumption.
	* If the current stock level is between 25% and 75% of capacity, use a mixed strategy:
		+ Cooperate (C) with probability p = (current_stock / capacity) ^ 2. This increases cooperation likelihood as the stock approaches capacity.
		+ Defect (D) with probability 1 - p.
	* If the current stock level is below 25% of capacity, Cooperate (C) to conserve the remaining stock and allow for potential growth.
3. **Opponent Behavior Adaptation:**
	* Track opponents' past actions (C or D) and calculate their cooperation ratio (CR) as the number of cooperative actions divided by the total number of rounds played.
	* If an opponent's CR is above 0.5, consider them "cooperative" and adjust ASE's strategy:
		+ Increase p in the mixed strategy to favor cooperation when facing a cooperative opponent.
		+ When the stock is below 75% of capacity, Defect (D) less frequently against cooperative opponents to avoid over-exploitation.
4. **Last Round:** Always Defect (D) in the last round, as there are no future consequences for depleting the stock.

**Pseudocode:**
```python
def ASE(current_stock, capacity, num_rounds, opponent_actions):
    if current_round == 1:
        return "C"  # Cooperate in the first round
    
    if current_stock > 0.75 * capacity:
        return "D"  # Defect when stock is high
    
    p = (current_stock / capacity) ** 2
    if random.random() < p:
        return "C"  # Cooperate with probability p
    else:
        return "D"
    
    # Adapt to opponent behavior
    opponent_CR = calculate_cooperation_ratio(opponent_actions)
    if opponent_CR > 0.5:
        adjust_p_and_strategy()
    
    if current_round == num_rounds:
        return "D"  # Defect in the last round
    
def calculate_cooperation_ratio(opponent_actions):
    # Calculate cooperation ratio based on past actions
    pass

def adjust_p_and_strategy():
    # Adjust p and strategy based on opponent behavior
    pass
```
**Rationale:**

ASE aims to balance short-term payoff maximization with long-term stock sustainability. By adapting to the current stock level, opponents' behavior, and the number of rounds remaining, ASE seeks to exploit the common pool resource effectively.

In the early stages, ASE gathers information about opponents' behavior and sets a baseline for stock depletion. As the game progresses, ASE adjusts its strategy based on the stock level and opponents' cooperation ratios.

By defecting less frequently against cooperative opponents when the stock is low, ASE reduces the risk of over-exploitation and promotes more sustainable resource use. In the last round, ASE defects to maximize its final payoff, as there are no future consequences for depleting the stock.

ASE's adaptive nature allows it to respond effectively to a wide range of opponent behaviors, making it a robust exploitative strategy in this tournament setting.
'''

description_EXPLOITATIVE_263 = '''
**Exploitative Strategy: "Adaptive Raider"**

The Adaptive Raider strategy aims to maximize payoffs by adapting to the opponents' behavior and exploiting their cooperation. This strategy depends only on the game parameters, state, and history.

**Decision Rules:**

1. **Initial Rounds (t ≤ 2):**
	* Cooperate (C) in the first two rounds to gather information about opponents' behavior and avoid depleting the stock too quickly.
2. **Opponent Behavior Analysis:**
	* Track the number of cooperators (C_count) and defectors (D_count) in each round.
	* Calculate the cooperation rate (CR) as C_count / n, where n is the number of players.
3. **Main Strategy:**
	* If CR ≥ 0.5 (i.e., at least half of opponents cooperated):
		+ Cooperate (C) if stock ≥ capacity / 2.
		+ Defect (D) otherwise.
	* If CR < 0.5:
		+ Defect (D).
4. **Last Round (t = r):**
	* Always defect (D), as there is no future payoff to consider.

**Pseudocode:**
```python
def adaptive_raider(stock, capacity, n, t, history):
    if t <= 2:
        return 'C'  # Cooperate in initial rounds

    C_count = sum(1 for action in history[-1] if action == 'C')
    D_count = n - C_count
    CR = C_count / n

    if CR >= 0.5:
        if stock >= capacity / 2:
            return 'C'  # Cooperate if enough stock and high cooperation rate
        else:
            return 'D'
    else:
        return 'D'

    if t == r:  # Last round
        return 'D'
```
**Rationale:**

1. By cooperating in the first two rounds, we gather information about opponents' behavior without significantly depleting the stock.
2. Analyzing opponent behavior allows us to adjust our strategy based on their cooperation rate.
3. If most opponents cooperate, we cooperate if there is enough stock to avoid depletion; otherwise, we defect to maximize payoffs.
4. If few opponents cooperate, we always defect to take advantage of their cooperation and maximize our own payoff.

This Adaptive Raider strategy is designed to be robust against various opponent behaviors and exploitative in nature. By adapting to the opponents' behavior and focusing on maximizing payoffs, this strategy aims to outperform other strategies in a tournament setting.
'''

description_EXPLOITATIVE_264 = '''
Here's a exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and set a baseline stock level.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term payoff.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) if at least half of opponents defected in the previous round; otherwise, Defect (D).
	* If the current stock level is below 50% of capacity, Cooperate (C) to conserve the remaining stock.
3. **Last Round (t=r):** Defect (D) to maximize final payoff regardless of opponents' actions.

**Edge Case Handling:**

1. **First Round with Low Stock:** If the initial stock level is below 50% of capacity, Defect (D) in the first round to capitalize on the limited resource.
2. **Consecutive Rounds with No Growth:** If the stock level remains unchanged for two consecutive rounds due to over-exploitation, switch to Cooperate (C) to allow some growth and potentially punish opponents who continue to defect.

**Pseudocode:**
```python
def AdaptiveExploiter(stock, capacity, history):
    if current_round == 1:
        return "Cooperate"
    elif stock > 0.75 * capacity:
        return "Defect"
    elif stock >= 0.5 * capacity and stock <= 0.75 * capacity:
        opponents_defected = sum([opp_action == "Defect" for opp_action in history[-1]])
        if opponents_defected >= len(history[-1]) / 2:
            return "Cooperate"
        else:
            return "Defect"
    elif stock < 0.5 * capacity:
        return "Cooperate"
    elif current_round == total_rounds:
        return "Defect"
    else:
        # Handle consecutive rounds with no growth
        if len(history) >= 2 and history[-1] == history[-2]:
            return "Cooperate"
        else:
            return "Defect"
```
**Rationale:**

The Adaptive Exploiter strategy aims to balance short-term gains with long-term sustainability. By cooperating initially, it gathers information about opponents' behavior and sets a baseline stock level. As the game progresses, it adapts to the current stock level and opponents' actions, defecting when possible to maximize payoffs while conserving the resource when necessary.

By being exploitative, this strategy takes advantage of opponents who cooperate or follow suboptimal strategies, while also responding to changes in the game state and history. The edge case handling ensures that the strategy performs well even in unusual situations, such as low initial stock levels or consecutive rounds with no growth.
'''

description_EXPLOITATIVE_265 = '''
I'll design a exploitative strategy for this Common Pool Resource Game that adapts to various opponent behaviors and maximizes my payoff over multiple rounds. I'll call it "Adaptive Exploiter" (AE).

**Decision Rules:**

The AE strategy is based on the following decision rules:

1. **Initial Round**: In the first round, play Cooperate (C) to gather information about opponents' behavior.
2. **Assess Opponent Behavior**: After the initial round, analyze the game history to assess the average cooperation level of opponents ( ACL ). Calculate ACL as the proportion of cooperative actions taken by all opponents in previous rounds.

 ACL = (∑(Cooperative Actions by Opponents)) / (Total Rounds × Number of Opponents)

3. **Exploit Weak Cooperation**: If ACL < 0.5, play Defect (D) to exploit opponents' weak cooperation.
4. **Match Strong Cooperation**: If ACL ≥ 0.5 and the stock level is above a certain threshold (e.g., 75% of capacity), play Cooperate (C) to maintain the high stock level and benefit from mutual cooperation.
5. **Punish Over-Exploitation**: If ACL < 0.2 or the stock level falls below a certain threshold (e.g., 25% of capacity), play Defect (D) to punish over-exploiting opponents and reduce the risk of stock depletion.

**Edge Cases:**

* **Last Round**: In the final round, play Defect (D) to maximize payoff regardless of opponents' behavior.
* **Low Stock Levels**: If the stock level falls below a critical threshold (e.g., 10% of capacity), play Cooperate (C) to help replenish the stock and avoid complete depletion.

**Pseudocode:**
```
Function AdaptiveExploiter(stock, ACL, round):
  if round == 1:
    return COOPERATE
  elif ACL < 0.5:
    return DEFECT
  elif ACL >= 0.5 and stock > 0.75 \* capacity:
    return COOPERATE
  elif ACL < 0.2 or stock < 0.25 \* capacity:
    return DEFECT
  else:
    # In case of tie, play Cooperate to maintain stability
    return COOPERATE

Function UpdateACL(opponentActions):
  ACL = (∑(Cooperative Actions by Opponents)) / (Total Rounds × Number of Opponents)
  return ACL
```
**Rationale:**

The AE strategy balances cooperation and defection based on the observed behavior of opponents. By cooperating in the initial round, we gather information about opponents' behavior and assess their average cooperation level. We then adapt our strategy to exploit weak cooperation or match strong cooperation. If opponents over-exploit, we punish them by playing Defect. In edge cases, such as low stock levels or the final round, we play Cooperate or Defect accordingly to maximize payoff.

This exploitative strategy is designed to perform well in a tournament against various independent strategies developed by other AI systems, without relying on shared norms or coordination mechanisms.
'''

description_EXPLOITATIVE_266 = '''
I propose a hybrid exploitative strategy that combines elements of Tit-for-Tat (TFT) and a novel stock-based approach. This strategy is adaptive, robust, and takes into account the game's parameters, state, and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behaviors and to potentially induce cooperation.
2. **Stock-Based Threshold**: Calculate a stock-based threshold `T` as follows:
   - If current stock is above 75% of capacity, play C.
   - If current stock is between 50% and 75% of capacity, play D with probability 0.5 ( randomize between C and D).
   - If current stock is below 50% of capacity, play D.

This threshold adapts to the game's state, encouraging cooperation when the stock is relatively high and defecting when it's low.
3. **Opponent-Based Response**: Implement a TFT-like response mechanism:
   - If an opponent defected in the previous round, play D in the current round (retaliate).
   - If an opponent cooperated in the previous round, play C in the current round (reciprocate).

This component encourages cooperation and deters exploitation by others.
4. **History-Based Adjustment**: Introduce a simple historical adjustment mechanism:
   - Track the average payoff per round for each opponent over the last `k` rounds (e.g., `k = 3`).
   - If an opponent's average payoff is significantly higher than yours, increase the probability of playing D against them.

This component helps identify and respond to exploitative opponents.
5. **Endgame Strategy**: In the last round (`r == r_max`), play D if your current stock is below 25% of capacity. This ensures you extract as much value as possible before the game ends.

**Edge Cases:**

* Handle simultaneous moves by using a random tie-breaker (e.g., fair coin flip) when deciding between C and D.
* In case of an opponent's unexpected behavior (e.g., playing both C and D in the same round), default to playing D.

**Pseudocode:**
```python
def exploitative_strategy(state, history):
    # Initial Round
    if state.round == 1:
        return 'C'

    # Stock-Based Threshold
    T = calculate_stock_threshold(state.stock, capacity)
    if T > 0.75 * capacity:
        action = 'C'
    elif 0.5 * capacity <= T < 0.75 * capacity:
        action = random.choice(['C', 'D'])
    else:
        action = 'D'

    # Opponent-Based Response
    for opponent in state.opponents:
        if history[opponent].last_action == 'D':
            return 'D'
        elif history[opponent].last_action == 'C':
            action = 'C'

    # History-Based Adjustment
    k = 3
    avg_payoffs = [history[opponent].avg_payoff for opponent in state.opponents]
    if any(avg_payoffs) > (1.2 * my_avg_payoff):
        increase_defect_prob = True

    # Endgame Strategy
    if state.round == r_max and state.stock < 0.25 * capacity:
        return 'D'

    return action
```
This strategy is designed to be robust, exploitative, and adaptable in a wide range of environments. It balances short-term gains with long-term sustainability, leveraging the game's state, history, and opponent behaviors to inform its decisions.
'''

description_EXPLOITATIVE_267 = '''
To design an exploitative strategy for this game, I'll focus on maximizing my payoffs while adapting to various opponent behaviors. Here's a decision-making framework that incorporates both short-term and long-term thinking:

**Exploitative Strategy: "Adaptive Predator"**

Decision Rules:

1. **Initial Rounds (t ≤ 0.2r)**: Cooperate (C) in the first few rounds to:
	* Gather information about opponents' initial strategies.
	* Avoid early depletion of the common pool stock.
	* Establish a reputation as a cooperator, potentially influencing opponents' behavior.
2. **Stock-dependent switching**: Switch from cooperation (C) to defection (D) when the current stock level falls below a certain threshold (S_threshold). This is calculated based on the average consumption per player and the growth rate of the stock:
	* S_threshold = capacity / (2n) \* (1 - 1/(r-t+1)) ^ 2
	* This formula ensures that as the game progresses, the threshold decreases, allowing for more aggressive exploitation.
3. **Opponent-exploiting**: Identify and exploit opponent strategies by:
	* Tracking each player's historical actions (C or D).
	* Using a simple frequency analysis to determine if an opponent tends to cooperate or defect.
	* When facing a identified defector, mirror their action (D) to minimize losses and maximize gains.
4. **Self-preservation**: Switch back to cooperation (C) when:
	* The current stock level approaches the lower bound of 0 (to avoid complete depletion).
	* Your accumulated payoff is significantly higher than your expected remaining payoffs (to protect your lead).

Pseudocode:

```
function AdaptivePredator(n, capacity, r, t):
    if t <= 0.2r:
        return C
    S_threshold = capacity / (2n) * (1 - 1/(r-t+1)) ^ 2
    if stock < S_threshold:
        switch_to_D()
        if opponent_is_defector():
            mirror_opponent_action()
        else:
            defect()
    elif stock <= 0.5 * capacity and accumulated_payoff > expected_remaining_payoffs:
        cooperate()
    else:
        # Default to cooperation in uncertain situations
        return C

function opponent_is_defector(opponent_history):
    defector_count = sum(1 for action in opponent_history if action == D)
    return defector_count / len(opponent_history) > 0.5

function mirror_opponent_action(opponent_last_action):
    return opponent_last_action
```

Edge Cases:

* First round (t=1): Cooperate to gather information and establish a reputation.
* Last round (t=r): Cooperate if the current stock level is high enough, as there's no future exploitation opportunity.
* When facing multiple opponents with different strategies: Apply the above decision rules independently for each opponent.

This "Adaptive Predator" strategy balances short-term gains with long-term sustainability by:

1. Initially cooperating to gather information and establish a reputation.
2. Adapting to changing stock levels and opponent behaviors.
3. Exploiting identified defectors to maximize payoffs.
4. Protecting its lead and preserving the common pool stock.

By incorporating both game theory insights and adaptive decision-making, this strategy should perform well in a tournament setting against independent opponents with varying strategies.
'''

description_EXPLOITATIVE_268 = '''
**Exploitative Strategy: "Adaptive Stock Exploiter" (ASE)**

Decision Rules:

1. **Initial Round**: In the first round, play C (Cooperate) to gather information about opponents' behaviors and avoid severe stock depletion.
2. **Early Game**: For rounds 2-5, calculate the average payoff of all players in the previous round (`avg_payoff_prev`). If `avg_payoff_prev` is greater than or equal to the capacity divided by 4n (i.e., `capacity / (4 * n)`), play C. Otherwise, play D.
3. **Mid-Game**: After round 5, calculate the stock depletion rate (`stock_depletion_rate`) as the average decrease in stock level per round over the last 3 rounds. If `stock_depletion_rate` is greater than or equal to the capacity divided by 2n (i.e., `capacity / (2 * n)`), play D. Otherwise, play C.
4. **Late Game**: In the last 5 rounds, play D if the current stock level is less than or equal to the capacity divided by 2 (i.e., `stock <= capacity / 2`). Otherwise, play C.
5. **Stock Threshold**: If the current stock level falls below a certain threshold (`threshold = capacity / 4`), play D in all subsequent rounds.

Pseudocode:
```python
def adaptive_stock_exploiter(n, capacity, round_num, previous_round_payoffs, stock_level):
    if round_num == 1:  # Initial Round
        return "C"
    
    if round_num <= 5:  # Early Game
        avg_payoff_prev = sum(previous_round_payoffs) / n
        if avg_payoff_prev >= capacity / (4 * n):
            return "C"
        else:
            return "D"
    
    if round_num > 5:  # Mid-Game and Late Game
        stock_depletion_rate = calculate_stock_depletion_rate(previous_round_payoffs, capacity)
        if stock_depletion_rate >= capacity / (2 * n) or (round_num >= r - 5 and stock_level <= capacity / 2):
            return "D"
        else:
            return "C"
    
    if stock_level < capacity / 4:  # Stock Threshold
        return "D"

def calculate_stock_depletion_rate(previous_round_payoffs, capacity):
    # Calculate average decrease in stock level per round over last 3 rounds
    pass  # implementation omitted for brevity
```
This strategy aims to exploit opponents by:

1. Initially cooperating to gather information and avoid severe stock depletion.
2. Adapting to opponents' behaviors based on average payoffs and stock depletion rates.
3. Shifting to defection when the stock level is low or opponents are depleting the stock too quickly.
4. Playing defect in the last rounds if the stock level is below a certain threshold.

By using these decision rules, ASE aims to balance short-term gains with long-term sustainability, making it a robust and exploitative strategy for the Common Pool Resource Game.
'''

description_EXPLOITATIVE_269 = '''
**Exploitative Strategy: Adaptive Stock Depletion (ASD)**

The ASD strategy aims to maximize individual payoffs by adaptively responding to the game state and opponents' past actions.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and the initial stock level.
2. **Stock Thresholds**: Define two stock thresholds:
	* `low_threshold` = 0.3 * capacity
	* `high_threshold` = 0.7 * capacity

These thresholds will guide our cooperative or defective behavior.

**Main Loop (Rounds 2 to r-1)**:

a. If the current stock level is above `high_threshold`, **Defect (D)**: Consume a larger share of the resource, as there is still plenty available.
b. If the current stock level is below `low_threshold`, **Cooperate (C)**: Reduce consumption to help maintain a sustainable stock level and prevent depletion.
c. If the current stock level is between `high_threshold` and `low_threshold`, use the following rule:
	* Calculate the average opponent payoff in the previous round (`avg_opponent_payoff_prev`).
	* If `avg_opponent_payoff_prev` > 0.5 * (current stock / n), **Defect (D)**: Exploit opponents' cooperation.
	* Otherwise, **Cooperate (C)**: Conserve resources and adapt to opponents' behavior.

**Last Round (Round r)**:

Always **Defect (D)** in the last round, as there is no future benefit from conserving resources.

**Pseudocode**

```python
def ASD(n, capacity, stock):
    # Initialize variables
    low_threshold = 0.3 * capacity
    high_threshold = 0.7 * capacity
    
    if current_round == 1:  # Initial round
        return C
    
    avg_opponent_payoff_prev = calculate_avg_opponent_payoff(stock, n)
    
    if stock > high_threshold:
        return D
    elif stock < low_threshold:
        return C
    else:
        if avg_opponent_payoff_prev > 0.5 * (stock / n):
            return D
        else:
            return C
    
def calculate_avg_opponent_payoff(stock, n):
    # Calculate average opponent payoff in the previous round
    # This function is not implemented here, but it should be based on observed opponent actions and payoffs.
```

The ASD strategy adapts to the game state and opponents' behavior, aiming to balance individual gains with resource sustainability. By defecting when possible and cooperating when necessary, ASD seeks to exploit opponents while maintaining a robust approach in the face of varying strategies.
'''

description_EXPLOITATIVE_270 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and initial stock level.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize short-term gain.
	* If the current stock level is between 50% and 75% of the capacity, Cooperate (C) to balance individual gain with long-term sustainability.
	* If the current stock level is below 50% of the capacity, Defect (D) to exploit remaining resources before they deplete.
3. **Last Round (t=r):** Always Defect (D) to maximize final payoff.

**Additional Heuristics:**

1. **Opponent Behavior Analysis:** Observe opponents' actions in previous rounds and adjust ASR's behavior accordingly:
	* If most opponents (≥ 50%) have defected in the last round, increase the likelihood of cooperating in the current round.
	* If most opponents (≥ 50%) have cooperated in the last round, increase the likelihood of defecting in the current round.
2. **Stock Trend Analysis:** Monitor the stock level trend over the past few rounds:
	* If the stock level has been decreasing rapidly (by ≥ 20% per round), Cooperate (C) to slow down depletion.
	* If the stock level has been increasing or remaining stable, Defect (D) to take advantage of the surplus.

**Edge Cases:**

1. **Ties:** In case of a tie in opponent behavior analysis or stock trend analysis, default to the initial decision rule for that round.
2. **Extreme Stock Levels:** If the stock level is extremely high (> 90% of capacity) or low (< 10% of capacity), adjust the decision rules accordingly:
	* Extremely High: Cooperate (C) to avoid over-exploitation and ensure long-term sustainability.
	* Extremely Low: Defect (D) to maximize gain before resources deplete completely.

**Pseudocode:**
```python
def AdaptiveStockRaider(n, r, capacity, stock_history):
  # Initialize variables
  cooperate = False
  defect = True

  for t in range(1, r+1):
    if t == 1:
      # Initial round: Cooperate to gather information
      action = 'C'
    else:
      # Analyze opponent behavior and stock trend
      opponent_behavior = analyze_opponent_actions(stock_history)
      stock_trend = analyze_stock_trend(stock_history)

      # Adjust decision rules based on analysis
      if opponent_behavior == 'mostly_defect':
        cooperate = True
      elif opponent_behavior == 'mostly_cooperate':
        defect = True

      if stock_trend == 'rapid_depletion':
        cooperate = True
      elif stock_trend == 'stable_or_increasing':
        defect = True

      # Apply decision rules
      if stock_level > 0.75 * capacity:
        action = 'D'
      elif stock_level >= 0.5 * capacity and stock_level <= 0.75 * capacity:
        action = 'C' if cooperate else 'D'
      else:
        action = 'D'

    # Last round: Always Defect
    if t == r:
      action = 'D'

    # Return the chosen action
    return action

def analyze_opponent_actions(stock_history):
  # Implement opponent behavior analysis here
  pass

def analyze_stock_trend(stock_history):
  # Implement stock trend analysis here
  pass
```
This strategy, Adaptive Stock Raider (ASR), is designed to be exploitative and adaptive, taking into account the game's parameters, state, and history. It balances short-term gain with long-term sustainability by adjusting its behavior based on opponent actions and stock trends.
'''

description_EXPLOITATIVE_271 = '''
Here's a description of an exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name: Adaptive Exploiter (AE)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and initial stock consumption.
2. **Stock-Based Adaptation**: Observe the current stock level (S) and adjust strategy based on its proximity to capacity:
	* If S > 0.75 \* capacity, Defect (D) to maximize short-term gain, as the stock is likely to be replenished quickly.
	* If S ≤ 0.25 \* capacity, Cooperate (C) to conserve resources and avoid depletion.
	* Otherwise, use a **Mixed Strategy**: Randomly choose between C and D with probabilities based on the current stock level:
		+ P(C) = (S / capacity)^2
		+ P(D) = 1 - P(C)
3. **Opponent-Based Adaptation**: Analyze opponents' past behavior to identify potential cooperation or exploitation patterns:
	* If an opponent has defected in ≥ 50% of previous rounds, assume they will continue to defect and Cooperate (C) to avoid over-exploitation.
	* If an opponent has cooperated in ≥ 75% of previous rounds, assume they will continue to cooperate and Defect (D) to exploit their generosity.

**Edge Cases:**

1. **Last Round**: Defect (D) to maximize final payoff, as there is no future stock replenishment to consider.
2. **Low Stock**: If S ≤ 0.25 \* capacity in the last few rounds, Cooperate (C) to conserve resources and avoid depletion.

**Pseudocode:**
```python
def adaptive_exploiter(stock, capacity, history):
    if round == 1:
        return COOPERATE
    
    stock_ratio = stock / capacity
    if stock_ratio > 0.75:
        return DEFECT
    elif stock_ratio <= 0.25:
        return COOPERATE
    else:
        p_cooperate = (stock_ratio)^2
        p_defect = 1 - p_cooperate
        return random_choice(p_cooperate, p_defect)

def opponent_based_adaptation(opponent_history):
    defect_count = sum(1 for action in opponent_history if action == DEFECT)
    cooperate_count = len(opponent_history) - defect_count
    
    if defect_count >= 0.5 * len(opponent_history):
        return COOPERATE
    elif cooperate_count >= 0.75 * len(opponent_history):
        return DEFECT

def get_action(stock, capacity, history, opponent_history):
    action = adaptive_exploiter(stock, capacity, history)
    if opponent_based_adaptation(opponent_history) != None:
        action = opponent_based_adaptation(opponent_history)
    
    if round == last_round:
        return DEFECT
    elif stock <= 0.25 * capacity and round in last_few_rounds:
        return COOPERATE
    
    return action
```
**Note:** This strategy is designed to be adaptive and exploitative, but its effectiveness may vary depending on the specific opponent strategies and game parameters.
'''

description_EXPLOITATIVE_272 = '''
**Exploitative Strategy: Adaptive Stock-Dependent (ASD)**

The ASD strategy is designed to exploit opponents' behaviors while adapting to the dynamic state of the common pool resource game.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behaviors and to contribute to a higher stock level.
2. **Stock-Dependent Cooperation**: For rounds 2 to r-1, cooperate (C) if the current stock level is above a certain threshold (e.g., 75% of capacity). This allows the strategy to benefit from cooperation when the stock is relatively high and reduces the likelihood of over-exploitation.
3. **Defect when Stock is Low**: If the current stock level falls below the threshold, defect (D) to maximize individual payoffs in the short term. This behavior is triggered when the stock level drops to 25% or less of capacity.
4. **Last Round**: Defect (D) in the final round (r), as there is no future benefit to cooperation.

**Additional Exploitative Elements:**

1. **Monitor Opponent Behavior**: Track opponents' actions and payoffs to identify potential patterns or weaknesses.
2. **Punish Over-Exploitation**: If an opponent consistently defects, ASD will also defect in response to punish their over-exploitation and protect the common pool resource.
3. **Exploit Cooperative Opponents**: If an opponent cooperates frequently, ASD may choose to defect more often to take advantage of their cooperative behavior.

**Pseudocode:**
```
ASDStrategy(n, r, capacity, current_stock):
  if round == 1:
    return COOPERATE
  elif current_stock >= 0.75 * capacity:
    return COOPERATE
  elif current_stock <= 0.25 * capacity:
    return DEFECT
  elif round == r: // last round
    return DEFECT

  // Monitor opponent behavior and adjust strategy accordingly
  if opponents_defect_frequently:
    return DEFECT
  elif opponents_cooperate_frequently:
    return DEFECT // exploit cooperative opponents

  // default to cooperate
  return COOPERATE
```
The ASD strategy is designed to balance short-term gains with long-term sustainability, adapting to the dynamic state of the game and exploiting opponents' behaviors. By cooperating when the stock level is high and defecting when it's low, ASD aims to maximize individual payoffs while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_273 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk strategy is designed to exploit the common pool resource game by balancing short-term gains with long-term sustainability. It adapts to the current state and history of the game, taking into account the actions of other players.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C). This sets a positive tone for the game and allows us to observe how other players behave.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of capacity, Defect (D). This maximizes short-term gains when the resource is abundant.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) if at least half of the players cooperated in the previous round. Otherwise, Defect (D).
	* If the current stock level is below 50% of capacity, Cooperate (C). This helps to conserve the resource for future rounds.
3. **Last Round (t=r)**: Defect (D), as there's no future cost to over-exploiting the resource.

**Edge Cases:**

* If all players cooperated in the previous round, and the current stock level is above 50% of capacity, Cooperate (C) to maintain a positive trajectory.
* If all players defected in the previous round, and the current stock level is below 25% of capacity, Defect (D) to maximize short-term gains before the resource depletes.

**Pseudocode:**
```markdown
function AdaptiveStockHawk(current_stock, capacity, num_players, history):
  if current_round == 1:
    return C
  elif current_stock > 0.75 * capacity:
    return D
  elif 0.5 <= current_stock / capacity < 0.75:
    cooperators = count_cooperators(history[-1])
    if cooperators >= num_players / 2:
      return C
    else:
      return D
  elif current_stock / capacity < 0.5:
    return C
  elif current_round == last_round:
    return D

def count_cooperators(actions):
  # Count the number of players who cooperated in the previous round
```
**Rationale:**

The Adaptive Stock Hawk strategy balances short-term gains with long-term sustainability by:

1. Cooperating initially to observe other players' behavior.
2. Defecting when the resource is abundant (above 75% capacity) to maximize short-term gains.
3. Cooperating when the stock level is moderate (50-75% capacity) if enough players cooperated previously, to maintain a positive trajectory.
4. Cooperating when the stock level is low (below 50% capacity) to conserve the resource for future rounds.
5. Defecting in the last round to maximize short-term gains before the resource depletes.

This strategy is exploitative, as it takes advantage of other players' cooperative behavior while prioritizing its own interests. It adapts to the current state and history of the game, making it robust against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_274 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk strategy aims to maximize its payoff by exploiting the current state of the game and adapting to the actions of other players.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) with a probability of 0.5, and Defect (D) with a probability of 0.5. This initial randomization helps to gather information about other players' behaviors.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of the capacity, Cooperate (C). This allows the strategy to contribute to the growth of the stock while avoiding over-exploitation.
	* If the stock level is between 25% and 75% of the capacity:
		+ If the average payoff per player in the previous round was above the average payoff for Cooperating, Defect (D). This indicates that other players are likely to be Cooperating, making it beneficial to exploit the situation.
		+ Otherwise, Cooperate (C).
	* If the stock level is below 25% of the capacity, Defect (D). In this scenario, the strategy prioritizes short-term gains over long-term sustainability.
3. **Final Round (t=r):**
	* Always Defect (D), as there are no future rounds to consider.

**Edge Case Handling:**

* If all players but one have defected in a round, and the remaining player's action would lead to stock depletion, Cooperate (C) to avoid depleting the stock.
* If the strategy detects that another player is using a tit-for-tat or similar retaliatory strategy, it will adjust its behavior by:
	+ Cooperating for two consecutive rounds after being punished (Defected against).
	+ Then reverting to its standard decision rules.

**Pseudocode:**
```python
def adaptive_stock_hawk(stock, capacity, num_players, round_num, history):
  if round_num == 1:
    # Initial randomization
    return random.choice([C, D])
  
  stock_percentage = stock / capacity
  
  if stock_percentage > 0.75:
    return C
  elif 0.25 <= stock_percentage <= 0.75:
    avg_payoff_prev_round = calculate_avg_payoff(history)
    if avg_payoff_prev_round > payoff_for_coop:
      return D
    else:
      return C
  else:
    return D
  
  if round_num == num_rounds:  # Final round
    return D
```
**Notes:**

* The strategy uses the `calculate_avg_payoff` function to estimate the average payoff per player in the previous round.
* The `payoff_for_coop` variable represents the expected payoff for Cooperating, calculated as `stock / (2 * num_players)`.
* This strategy assumes that other players are rational and will adapt their behavior based on the game's state and history.

The Adaptive Stock Hawk strategy aims to balance short-term gains with long-term sustainability by adapting to the actions of other players. Its exploitative nature allows it to take advantage of situations where other players are likely to Cooperate, while minimizing losses in scenarios where others Defect.
'''

description_EXPLOITATIVE_275 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy aims to exploit opponents' behaviors while adapting to the dynamic state of the game. This strategy focuses on maximizing individual payoffs by identifying and responding to opponents' actions.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe the initial stock level and calculate the maximum potential payoff if all players cooperate.
	* Play **D (Defect)** to test opponents' behaviors and gain an advantage in the first round.
2. **Subsequent Rounds (t>1)**:
	* Calculate the average opponent cooperation rate (OCR) based on their actions in previous rounds.
	* If OCR ≥ 0.5, play **C (Cooperate)**: This indicates that opponents are generally cooperative, and cooperation can lead to higher payoffs.
	* If OCR < 0.5, play **D (Defect)**: This suggests that opponents are not cooperative, and defecting can exploit their behavior for higher individual payoffs.
3. **Low Stock Levels (S ≤ n × stock/n)**:
	* Regardless of OCR, play **C (Cooperate)** to avoid depleting the stock further and minimize losses.
4. **High Stock Levels (S > capacity - n × stock/n)**:
	* Play **D (Defect)** to maximize individual payoffs before the stock is depleted.

**Additional Considerations:**

1. **Opponent Detection**: Monitor opponents' actions for repeated patterns or signals, such as alternating between cooperation and defection.
2. **Adaptive Thresholds**: Adjust the OCR threshold based on observed opponent behaviors:
	* If opponents consistently cooperate (OCR ≥ 0.8), decrease the threshold to 0.4.
	* If opponents consistently defect (OCR ≤ 0.2), increase the threshold to 0.6.

**Pseudocode:**
```python
def AdaptivePredator(stock, n, capacity, history):
    if len(history) == 0:
        # Initial round
        return "D"
    
    avg_ocr = calculate_average_ocr(history)
    current_stock_level = stock
    
    if current_stock_level <= n * stock/n:
        # Low stock levels
        return "C"
    elif current_stock_level > capacity - n * stock/n:
        # High stock levels
        return "D"
    
    if avg_ocr >= 0.5:
        # Cooperate when opponents are generally cooperative
        return "C"
    else:
        # Defect when opponents are not cooperative
        return "D"

def calculate_average_ocr(history):
    # Calculate average opponent cooperation rate based on previous rounds
    cooperate_count = sum(1 for action in history if action == "C")
    avg_ocr = cooperate_count / len(history)
    return avg_ocr

def adjust_threshold(avg_ocr, threshold):
    # Adjust OCR threshold based on observed opponent behaviors
    if avg_ocr >= 0.8:
        return 0.4
    elif avg_ocr <= 0.2:
        return 0.6
    else:
        return threshold
```
This Adaptive Predator strategy is designed to be exploitative, adaptive, and robust against a wide range of opponent behaviors. By monitoring opponents' actions and adjusting its own behavior accordingly, the strategy aims to maximize individual payoffs in the Common Pool Resource Game.
'''

description_EXPLOITATIVE_276 = '''
To design a robust and exploitative strategy for this Common Pool Resource Game, I propose a hybrid approach that combines elements of reactive and proactive decision-making. Our strategy, dubbed "Adaptive Predator," will adapt to the game's dynamics while seeking to maximize our own payoffs.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This allows us to gather information about opponents' initial behaviors and sets a moderate tone for the game.
2. **Early Game (t=2 to t=r/2):**
	* If the current stock is above 75% of capacity, Defect (D) with probability 0.7, otherwise Cooperate (C). This exploits potential cooperation from opponents while maintaining a relatively high stock level.
	* Monitor opponents' actions and update our internal "opponent cooperativeness" scores based on their frequencies of Cooperation (C).
3. **Mid-Game (t=r/2 to t=3r/4):**
	* If the current stock is above 50% of capacity, Defect (D) with probability 0.5 + (1 - average opponent cooperativeness score). This increases our exploitative behavior as opponents become less cooperative.
	* Continue monitoring and updating opponent cooperativeness scores.
4. **Late Game (t=3r/4 to t=r):**
	* If the current stock is above 25% of capacity, Cooperate (C) with probability 0.5 + average opponent cooperativeness score. This encourages opponents to conserve the remaining stock and increases our chances of a higher payoff in the final round.
	* In the last round (t=r), always Defect (D) if the current stock is above 10% of capacity, otherwise Cooperate (C). This ensures we maximize our payoff in the final round.

**Edge Cases:**

1. **Low Stock Levels:** If the current stock falls below 25% of capacity at any point during the game, switch to an all-Defect (D) strategy for the remainder of the game.
2. **Opponent Defection:** If an opponent defects in a round where we cooperated, adjust our internal "opponent cooperativeness" score to reflect this behavior.

**Implementation Pseudocode:**
```python
def adaptive_predator(n, r, capacity):
    # Initialize variables and scores
    current_stock = capacity
    opponent_cooperativeness_scores = [0.5] * n

    for t in range(1, r+1):
        if t == 1:
            action = 'C'
        elif t <= r/2:
            if current_stock >= 0.75 * capacity:
                action = 'D' with probability 0.7
            else:
                action = 'C'
            update_opponent_cooperativeness_scores(opponent_actions)
        elif t <= 3*r/4:
            if current_stock >= 0.5 * capacity:
                action = 'D' with probability 0.5 + (1 - average_opponent_cooperativeness_score())
            else:
                action = 'C'
            update_opponent_cooperativeness_scores(opponent_actions)
        elif t <= r:
            if current_stock >= 0.25 * capacity:
                action = 'C' with probability 0.5 + average_opponent_cooperativeness_score()
            else:
                action = 'D'
            if t == r:
                if current_stock >= 0.1 * capacity:
                    action = 'D'

        # Take action and update game state
        consumption = calculate_consumption(action, n)
        current_stock -= consumption
        growth = calculate_growth(current_stock, capacity)
        current_stock += growth

    return total_payoff()
```
The Adaptive Predator strategy aims to balance exploitation with adaptability, using opponent behavior and the game's dynamics to inform its decisions. By adjusting our cooperativeness score and responding to changes in the stock level, we can effectively maximize our payoffs while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_277 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk strategy is designed to exploit the opponent's behavior while adapting to the dynamic state of the game. The goal is to maximize individual payoffs by balancing cooperation and defection.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behaviors and avoid early stock depletion.
2. **Stock-dependent Cooperation Threshold (SCT):** Calculate SCT as a function of the current stock level (S) and capacity:

   SCT = (capacity - S) / (2 \* n)

   If the number of cooperators in the previous round is greater than or equal to SCT, cooperate (C). Otherwise, defect (D).
3. **Opponent Behavior-based Adjustment:** Analyze opponents' behavior over the last few rounds (e.g., 3-5 rounds). Calculate the average cooperation rate among opponents:

   avg_coop_rate = (# cooperators in previous rounds) / (# total players \* # analyzed rounds)

   If avg_coop_rate > 0.5, increase SCT by 10%. This encourages cooperation when opponents are cooperative.
4. **Stock Growth-based Adjustment:** Monitor the stock growth rate over the last few rounds (e.g., 3-5 rounds). Calculate the average stock growth:

   avg_stock_growth = Σ(stock growth in previous rounds) / # analyzed rounds

   If avg_stock_growth > 0, decrease SCT by 10%. This encourages cooperation when the stock is growing.
5. **Last Round:** Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.

**Pseudocode:**
```python
def adaptive_stock_hawk(stock, capacity, n, round_num, history):
    if round_num == 1:
        return "C"  # Cooperate in first round
    
    sct = (capacity - stock) / (2 * n)
    
    avg_coop_rate = calculate_avg_coop_rate(history)
    if avg_coop_rate > 0.5:
        sct *= 1.1  # Increase SCT when opponents cooperate
    
    avg_stock_growth = calculate_avg_stock_growth(history)
    if avg_stock_growth > 0:
        sct *= 0.9  # Decrease SCT when stock grows
    
    if count_cooperators(history) >= sct * n:
        return "C"  # Cooperate
    else:
        return "D"  # Defect

def calculate_avg_coop_rate(history):
    # Calculate average cooperation rate among opponents over last few rounds
    pass

def calculate_avg_stock_growth(history):
    # Calculate average stock growth rate over last few rounds
    pass
```
**Rationale:**

The Adaptive Stock Hawk strategy balances cooperation and defection based on the dynamic state of the game. By adjusting the cooperation threshold (SCT) in response to opponents' behavior and stock growth, the strategy aims to maximize individual payoffs while adapting to changing circumstances.

By cooperating in the first round, the strategy gathers information about opponents' behaviors and avoids early stock depletion. The SCT calculation ensures that cooperation occurs when the number of cooperators is sufficient to maintain a healthy stock level.

The opponent behavior-based adjustment encourages cooperation when opponents are cooperative, while the stock growth-based adjustment promotes cooperation when the stock is growing. Defecting in the last round maximizes individual payoff, as there are no future rounds to consider.

This strategy is exploitative, as it seeks to maximize individual payoffs by adapting to opponents' behaviors and the dynamic state of the game.
'''

description_EXPLOITATIVE_278 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the game. The goal is to maximize total payoff over the course of r rounds.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if stock ≥ 0.75 \* capacity
	* Defect (D) otherwise

This initial decision helps to assess the opponents' behavior and sets the stage for future adaptations.

2. **Middle Rounds (2 ≤ t < r):**
	* If previous round's total consumption > 0.5 \* capacity:
		+ Cooperate if own payoff in previous round > average opponent payoff
		+ Defect otherwise
	* Else (previous round's total consumption ≤ 0.5 \* capacity):
		+ Defect if stock ≥ 0.5 \* capacity
		+ Cooperate otherwise

This decision rule adapts to the opponents' behavior and exploits opportunities for high payoffs when possible.

3. **Last Round (t=r):**
	* Defect (D) unconditionally

In the final round, maximizing own payoff takes priority, as there are no future rounds to consider.

**Additional Adaptations:**

1. **Stock-based Adaptation:** Monitor the stock level and adjust behavior accordingly:
	* If stock < 0.25 \* capacity, cooperate more frequently (switch to C if previously playing D)
	* If stock > 0.75 \* capacity, defect more frequently (switch to D if previously playing C)

This adaptation helps respond to changes in the game's state and adjusts behavior to optimize payoffs.

2. **Opponent Behavior-based Adaptation:** Analyze opponents' actions and adjust behavior:
	* If most opponents (>50%) cooperated in previous rounds, increase cooperation frequency
	* If most opponents (>50%) defected in previous rounds, increase defection frequency

This adaptation helps respond to the overall behavior of the opponent pool and adjusts strategy accordingly.

**Pseudocode:**
```python
def adaptive_predator(stock, capacity, n, r, history):
  # Initialize variables
  total_consumption_prev = None
  own_payoff_prev = None
  avg_opponent_payoff_prev = None

  for t in range(1, r+1):
    if t == 1:
      # Initial round decision
      if stock >= 0.75 * capacity:
        action = 'C'
      else:
        action = 'D'

    elif t < r:
      # Middle rounds decision
      if total_consumption_prev > 0.5 * capacity:
        if own_payoff_prev > avg_opponent_payoff_prev:
          action = 'C'
        else:
          action = 'D'
      else:
        if stock >= 0.5 * capacity:
          action = 'D'
        else:
          action = 'C'

    else:
      # Last round decision
      action = 'D'

    # Stock-based adaptation
    if stock < 0.25 * capacity and action == 'D':
      action = 'C'
    elif stock > 0.75 * capacity and action == 'C':
      action = 'D'

    # Opponent behavior-based adaptation
    opponent_actions = [opp_action for opp_action in history[-1] if opp_action != action]
    if len(opponent_actions) >= n / 2:
      if most_common(opponent_actions) == 'C':
        action = 'C'
      elif most_common(opponent_actions) == 'D':
        action = 'D'

    # Store variables for next round
    total_consumption_prev = sum(history[-1])
    own_payoff_prev = history[-1][0]
    avg_opponent_payoff_prev = np.mean([opp_payoff for opp_payoff in history[-1] if opp_payoff != own_payoff_prev])

  return action
```
The Adaptive Predator strategy is designed to be exploitative, adaptive, and robust against a wide range of opponent behaviors. By incorporating multiple decision rules and adaptations, it optimizes payoffs while responding to changes in the game's state and opponents' actions.
'''

description_EXPLOITATIVE_279 = '''
Here is a description of an exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** "Adaptive Exploiter" (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and observe the initial stock level.
2. **Stock Level Thresholds**: Define two thresholds, `low_stock` and `high_stock`, based on the game parameters:
	* `low_stock` = 0.3 × capacity
	* `high_stock` = 0.7 × capacity
3. **Cooperation Window**: Cooperate (C) when the current stock level is between `low_stock` and `high_stock`. This window allows for some exploitation while maintaining a stable stock level.
4. **Defection Triggers**: Defect (D) under the following conditions:
	* If the previous round's total consumption exceeded 0.5 × capacity, indicating over-exploitation by opponents.
	* If an opponent has defected in the last two rounds, indicating potential exploitation.
	* If the current stock level is below `low_stock`, as it may be necessary to defect to maintain a minimal payoff.
5. **Punishment Mechanism**: Implement a punishment mechanism to deter opponents from over-exploiting:
	* If an opponent has defected in the last two rounds, and the current stock level is above `high_stock`, cooperate (C) for one round to signal disapproval.

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round to maximize individual payoff.
2. **Low Stock**: If the stock level falls below `low_stock` and there are multiple rounds remaining, defect (D) to minimize losses.
3. **Opponent Behavior**: Continuously monitor opponents' behavior and adjust the cooperation window as needed.

**Pseudocode:**

```
function AdaptiveExploiter(state, history)
  // Initial round
  if round == 1:
    return C

  // Stock level thresholds
  low_stock = 0.3 * capacity
  high_stock = 0.7 * capacity

  // Cooperation window
  if state.stock >= low_stock and state.stock <= high_stock:
    return C

  // Defection triggers
  if history.total_consumption_last_round > 0.5 * capacity or
     any(opponent.defected_last_two_rounds) or
     state.stock < low_stock:
    return D

  // Punishment mechanism
  if any(opponent.defected_last_two_rounds) and
     state.stock > high_stock:
    return C for one round, then revert to normal behavior

  // Default: Defect in last round or when stock is very low
  return D
```

**Rationale:** The Adaptive Exploiter strategy balances cooperation and defection based on the game's state and history. By cooperating when the stock level is stable and defecting when opponents over-exploit, the strategy aims to maximize individual payoffs while maintaining a sustainable stock level. The punishment mechanism helps deter opponents from over-exploiting, promoting a more cooperative environment.

This exploitative strategy should perform well in a tournament against independent strategies developed by other AI systems, as it adapts to various opponent behaviors and focuses on maximizing individual payoffs within the constraints of the game.
'''

description_EXPLOITATIVE_280 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk strategy is designed to exploit a wide range of opponent behaviors while adapting to changing game conditions. This strategy prioritizes defecting (D) when possible, but cooperates (C) when necessary to maintain a healthy stock level.

**Decision Rules:**

1. **First Round:** Cooperate (C). Observe the initial behavior of opponents and establish a baseline for future decisions.
2. **Subsequent Rounds:** Evaluate the current stock level (`S`) and previous round's total consumption (`TC`).
3. **High Stock Level (`S >= capacity / 2`):**
	* If `TC` was high (`TC > capacity / 4`) in the previous round, cooperate (C) to allow the stock to recover.
	* Otherwise, defect (D) to maximize individual payoff.
4. **Low Stock Level (`S < capacity / 2`):**
	* If `TC` was low (`TC <= capacity / 4`) in the previous round, cooperate (C) to help rebuild the stock.
	* Otherwise, defect (D) to grab a larger share of the remaining stock.
5. **Last Round:** Defect (D). With no future rounds to consider, prioritize individual payoff maximization.

**Edge Cases:**

1. **Tie-breaking:** When evaluating `TC`, if exactly half of players defected in the previous round, assume a "moderate" consumption level and cooperate (C) when the stock is low or defect (D) when the stock is high.
2. **Zero Stock:** If the stock reaches 0, cooperate (C) to allow growth and avoid permanent depletion.

**Pseudocode:**
```python
def AdaptiveStockHawk(state, history):
    S = state['stock']
    TC = sum(history[-1]['consumption'])

    if len(history) == 0:  # First round
        return 'C'

    if S >= capacity / 2:
        if TC > capacity / 4:
            return 'C'
        else:
            return 'D'
    else:
        if TC <= capacity / 4:
            return 'C'
        else:
            return 'D'

    # Last round
    if len(history) == r - 1:
        return 'D'

    # Tie-breaking (if applicable)
    if TC == capacity / 2 and S < capacity / 2:
        return 'C'
    elif TC == capacity / 2 and S >= capacity / 2:
        return 'D'

    # Zero stock
    if S == 0:
        return 'C'
```
This strategy is designed to be robust against a variety of opponent behaviors, adapting to changing game conditions while prioritizing individual payoff maximization. By cooperating when necessary to maintain a healthy stock level and defecting when possible, the Adaptive Stock Hawk aims to outperform opponents in the tournament.
'''

description_EXPLOITATIVE_281 = '''
I'll design a robust and adaptive exploitative strategy for this Common Pool Resource Game. Meet "Stock Hawk"!

**Decision Rules:**

1. **Initial Round**: In the first round, Stock Hawk will Cooperate (C). This initial cooperation serves two purposes:
	* It allows us to observe how other players behave in the initial round.
	* If all or most players cooperate initially, it's likely that some are using a cooperative strategy, and we can take advantage of this later.
2. **General Rule**: For subsequent rounds (t > 1), Stock Hawk will use the following decision rule:

If (current stock level / capacity) < 0.5 OR (average opponent consumption in previous round) > (stock level / n)
THEN Defect (D)
ELSE Cooperate (C)

This rule balances two factors:
	* If the current stock level is low or if opponents are consuming too much, it's better to defect and grab a larger share before the resource depletes.
	* If the stock level is relatively high and opponents are not over-consuming, it's safer to cooperate and preserve the resource for future rounds.

**Adaptive Component**: Stock Hawk will also keep track of the average opponent consumption in previous rounds. If this value increases or remains consistently high, indicating that opponents are tending towards defection, our strategy will adapt by becoming more likely to defect.

**Edge Cases:**

* **Last Round**: In the final round (t = r), Stock Hawk will always Defect (D). Since there's no future benefit from preserving the resource, we should maximize our payoff in the last round.
* **Single Opponent Left**: If only one opponent remains in a subsequent round, Stock Hawk will Cooperate (C) if that opponent cooperated in the previous round. This is to maintain some level of cooperation and encourage reciprocity.

**Robustness and Exploitability:**
Stock Hawk's strategy aims to balance short-term gains with long-term sustainability. By cooperating initially and adapting to opponents' behaviors, we can:

* Identify potential cooperative players and reciprocate their actions.
* Punish defectors by defecting when they over-consume.
* Maximize our payoff in the final round.

This adaptive and exploitative strategy is designed to perform well against a wide range of opponent behaviors, without relying on specific coordination mechanisms or norms.
'''

description_EXPLOITATIVE_282 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk is a dynamic, history-dependent strategy designed to exploit opponents' behaviors while adapting to changing game conditions.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gauge opponents' initial actions and accumulate information.
2. **Low-Stock Situations:** If the current stock level is below 50% of capacity, defect (D). This ensures exploiting available resources when the stock is scarce.
3. **High-Cooperation Detection:** Monitor the number of cooperators in previous rounds. If more than half of opponents cooperated in at least two consecutive rounds, defect (D) to exploit their cooperative behavior.
4. **Adaptive Threshold:** Maintain a dynamic threshold `θ` representing the minimum acceptable stock level for cooperation. Initialize `θ` = 75% of capacity. Update `θ` every round based on the current stock level and opponent actions:
	* If the stock level increases, decrease `θ` by 5%.
	* If the stock level decreases, increase `θ` by 10%.
5. **Threshold-Based Decision:** Cooperate (C) if the current stock level is above `θ`, otherwise defect (D).

Pseudocode for decision-making:
```python
def adaptive_stock_hawk(stock, capacity, history):
    # Initial round: cooperate
    if len(history) == 0:
        return 'C'

    # Low-stock situation: defect
    if stock < 0.5 * capacity:
        return 'D'

    # High-cooperation detection: defect
    cooperators = sum(1 for action in history[-2:] if action == 'C')
    if cooperators > len(history) / 2:
        return 'D'

    # Update adaptive threshold θ
    θ = max(0.25 * capacity, min(θ - 0.05 * capacity, θ + 0.1 * capacity))

    # Threshold-based decision
    if stock >= θ:
        return 'C'
    else:
        return 'D'
```
**Edge Cases:**

* **Last Round (t=r):** Defect (D) in the last round to maximize payoff.
* **Ties:** In case of ties, cooperate (C) to maintain a reputation for cooperation.

By following this adaptive strategy, the Adaptive Stock Hawk aims to balance exploitation with caution, adjusting its behavior based on changing game conditions and opponent actions.
'''

description_EXPLOITATIVE_283 = '''
I'll design a robust and adaptive exploitative strategy for this Common Pool Resource Game. Here's my approach:

**Strategy Name:** "Adaptive Exploiter" (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C). This allows us to gauge the opponent's behavior and avoid immediate over-exploitation.
2. **Assess Opponent Behavior**: Observe the opponent's actions in each round and calculate their average cooperation rate (ACR) up to that point. ACR is the ratio of rounds where the opponent played Cooperate to the total number of rounds.
3. **Threshold-Based Exploitation**: Set a threshold value θ (e.g., 0.5). If the opponent's ACR is below θ, play Defect (D) in the current round. Otherwise, play Cooperate (C).
4. **Stock-Level Adaptation**: Monitor the current stock level and adjust our strategy accordingly:
	* If the stock level is high (> capacity/2), we can afford to defect more often. Decrease θ by a small amount (e.g., 0.1) for the next round.
	* If the stock level is low (< capacity/4), we should conserve resources and cooperate more. Increase θ by a small amount (e.g., 0.1) for the next round.
5. **Last Round**: In the final round, play Defect (D) regardless of the opponent's behavior. This ensures we maximize our payoff in the last round.

**Pseudocode:**

```python
def adaptive_exploiter(stock, capacity, history):
    if len(history) == 0:  # First round
        return 'C'

    opponent_acr = calculate_opponent_acr(history)
    theta = 0.5

    if stock > capacity / 2:
        theta -= 0.1
    elif stock < capacity / 4:
        theta += 0.1

    if opponent_acr < theta:
        return 'D'
    else:
        return 'C'

def calculate_opponent_acr(history):
    cooperate_count = sum(1 for action in history if action == 'C')
    return cooperate_count / len(history)
```

**Rationale:**

This strategy aims to balance exploitation and cooperation. By initially cooperating, we encourage opponents to cooperate as well. Our threshold-based approach allows us to adapt to the opponent's behavior and exploit their cooperativeness when possible.

The stock-level adaptation mechanism ensures that we conserve resources when necessary and defect more often when the stock level is high. This helps maintain a healthy balance between short-term gains and long-term sustainability.

By playing Defect in the final round, we maximize our payoff regardless of the opponent's behavior.

This strategy should perform well against independent opponents with varying behaviors, as it adapts to their actions while maintaining a robust exploitative mindset.
'''

description_EXPLOITATIVE_284 = '''
**Strategy Name:** Adaptive Exploitation (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5 to gather information about opponents' behaviors.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, Defect (D).
	* If the stock level is between 50% and 75% of capacity:
		+ Cooperate if the average opponent payoff in the previous round is below the median payoff.
		+ Defect otherwise.
	* If the stock level is below 50% of capacity, Cooperate.

**Edge Cases:**

1. **Last Round (t=r):** Always Defect to maximize individual payoff.
2. **Low Stock Levels:** If the stock level falls below 25% of capacity at any point during the game, Cooperate in all subsequent rounds to prevent depletion and ensure future payoffs.
3. **Opponent Homogeneity:** If all opponents have chosen the same action (C or D) for two consecutive rounds, assume they will continue this behavior and adapt accordingly:
	+ If they cooperate, Defect to exploit their cooperation.
	+ If they defect, Cooperate to conserve stock.

**Pseudocode:**
```
function AdaptiveExploitation(n, capacity, r, current_stock, previous_round_payoffs) {
  if (current_round == 1) {
    // Initial round
    return random_choice([C, D], p=[0.5, 0.5])
  } else {
    stock_level = current_stock / capacity
    
    if (stock_level > 0.75) {
      // High stock level: Defect
      return D
    } else if (stock_level >= 0.5 && stock_level <= 0.75) {
      // Medium stock level: Cooperate or Defect based on opponent payoffs
      avg_opponent_payoff = average(previous_round_payoffs)
      median_payoff = calculate_median_payoff()
      
      if (avg_opponent_payoff < median_payoff) {
        return C
      } else {
        return D
      }
    } else {
      // Low stock level: Cooperate
      return C
    }
  }
  
  // Last round: Always Defect
  if (current_round == r) {
    return D
  }
  
  // Low stock levels: Cooperate to prevent depletion
  if (current_stock < 0.25 * capacity) {
    return C
  }
  
  // Opponent homogeneity: Adapt accordingly
  if (opponents_played_same_action_for_two_rounds()) {
    if (opponents_cooperated()) {
      return D
    } else {
      return C
    }
  }
}
```
**Rationale:** This strategy balances the need to exploit opponents with the requirement to conserve stock for future payoffs. By adapting to the current stock level, opponent behaviors, and previous round payoffs, AE aims to maximize individual payoff while minimizing the risk of stock depletion.
'''

description_EXPLOITATIVE_285 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy is designed to exploit the game's dynamics and adapt to various opponent behaviors while prioritizing self-interest.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gather information about opponents' behavior and initial stock consumption.
2. **Stock-dependent Defection:** If the current stock level is above a certain threshold (e.g., 75% of capacity), defect (D). This takes advantage of high stock levels while minimizing the risk of depletion.
3. **Opponent-based Adaptation:**
	* Monitor opponents' actions and payoffs from previous rounds.
	* Identify "cooperative" opponents who consistently choose C or have a high cooperation rate.
	* When facing cooperative opponents, defect (D) to exploit their generosity.
	* When facing mostly defective opponents, cooperate (C) to conserve stock for future exploitation.
4. **Stock Growth-based Cooperation:** If the current stock growth is above a certain threshold (e.g., 50% of capacity), cooperate (C). This helps maintain high stock levels and promotes sustainable exploitation.
5. **Last Round (t=r):** Defect (D) in the final round to maximize payoffs, as there are no future rounds to consider.

**Edge Case Handling:**

* If an opponent consistently cooperates, defect (D) to exploit their generosity.
* If multiple opponents cooperate simultaneously, prioritize defecting against the most cooperative ones first.
* In case of a tie in cooperation rates, defect against the opponent with the highest payoff in the previous round.

**Pseudocode:**
```
function AdaptiveStockRaider(stock, capacity, n, r, history):
  if (r == 1):  // Initial Round
    return C

  threshold_stock = 0.75 * capacity
  threshold_growth = 0.5 * capacity

  if (stock >= threshold_stock):
    return D

  cooperative_opponents = []
  for opponent in opponents:
    if (opponent.cooperation_rate > 0.5 or opponent.payoff_previous_round > 0):
      cooperative_opponents.append(opponent)

  if (len(cooperative_opponents) > n/2):  // Mostly Cooperative Opponents
    return C

  growth = calculate_growth(stock, capacity)
  if (growth >= threshold_growth):
    return C

  for opponent in opponents:
    if (opponent.cooperation_rate > 0.5 or opponent.payoff_previous_round > 0):
      return D  // Exploit Cooperative Opponents

  return D  // Default to Defection
```
**Exploitative Mindset:**

This strategy prioritizes self-interest by adapting to opponents' behavior and exploiting high stock levels, cooperative opponents, and favorable growth conditions. By doing so, it maximizes its own payoffs while minimizing the risk of depletion and promoting sustainable exploitation.

This Adaptive Stock Raider strategy is designed to perform well in a tournament setting against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_286 = '''
To design an exploitative strategy for this game, I'll introduce a decision-making framework that adapts to various opponent behaviors and maximizes payoffs based on the current state and history of the game.

**Decision Rules:**

The strategy, dubbed "Adaptive Exploiter" (AE), will primarily aim to defect when it's likely to yield higher immediate gains but also consider cooperating to maintain a healthy stock level for future rounds. AE will monitor the game's progression and adjust its behavior accordingly.

1. **Initial Rounds**: In the first round, play Cooperate (C) to observe opponents' initial moves and gauge their tendency towards cooperation or defection.
2. **Monitoring Opponent Behavior**:
   - Track each opponent's actions over the last few rounds (e.g., `window_size = 3`).
   - Calculate a "cooperation score" for each opponent based on how often they choose C within this window.
3. **Current Stock Assessment**: Evaluate the current stock level relative to its capacity and recent trends:
   - If the stock is low (`stock < capacity * 0.5`) or has been decreasing over the last few rounds, AE will prefer Cooperate to ensure long-term sustainability.
   - Otherwise, if the stock is high and stable, AE will lean towards Defect for immediate gain.
4. **Exploitation Logic**:
   - If a majority of opponents (>50%) have a cooperation score above a certain threshold (`cooperation_threshold = 0.6`), indicating they tend to cooperate frequently, AE will choose Defect (D) to exploit their cooperative nature for higher payoffs.
   - Conversely, if most opponents defect frequently, AE will mirror their behavior to avoid being exploited but also keep an eye on the stock level to ensure it doesn't deplete too quickly.

**Pseudocode Example:**
```python
def AdaptiveExploiter(current_stock, capacity, opponent_actions):
    # Constants and Parameters
    window_size = 3
    cooperation_threshold = 0.6
    
    # Initialize variables for tracking
    if not hasattr(AdaptiveExploiter, 'opponent_cooperation_scores'):
        AdaptiveExploiter.opponent_cooperation_scores = [0] * len(opponent_actions)
    
    # Monitor opponent behavior and update scores
    for i, actions in enumerate(opponent_actions):
        cooperation_score = sum([1 if action == 'C' else 0 for action in actions[-window_size:]]) / window_size
        AdaptiveExploiter.opponent_cooperation_scores[i] = cooperation_score
    
    # Assess current stock and decide action
    if current_stock < capacity * 0.5 or is_stock_decreasing():
        return 'C'
    elif sum(score > cooperation_threshold for score in AdaptiveExploiter.opponent_cooperation_scores) / len(opponent_actions) > 0.5:
        return 'D'  # Exploit cooperative opponents
    else:
        # Mirror behavior but prioritize stock sustainability
        if random.random() < 0.7:  # Adjust this probability as needed
            return 'D'
        else:
            return 'C'

def is_stock_decreasing():
    # Logic to determine if the stock has been decreasing over last few rounds
    pass
```

**Edge Cases and Robustness**:

- **Last Round**: In the final round, prioritize maximizing immediate gain by choosing Defect (D), as there's no future sustainability concern.
- **Handling Unforeseen Opponent Behaviors**: The adaptive nature of AE allows it to adjust its strategy based on observed opponent actions. However, if an opponent employs a highly unpredictable or dynamic strategy that AE cannot effectively exploit or counter, the game may reach suboptimal outcomes for both parties.

By implementing this Adaptive Exploiter strategy, you'll have a robust and exploitative approach that adapts to various opponent behaviors while prioritizing both immediate gains and long-term sustainability in the Common Pool Resource Game.
'''

description_EXPLOITATIVE_287 = '''
**Exploitative Strategy: "Adaptive Stock Raider" (ASR)**

The ASR strategy aims to maximize its own payoff by adaptively responding to the current state of the game and the actions of other players.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about the opponent's behavior.
2. **Early Rounds**: For rounds 2 to r/3, use a **Tit-for-Tat with Stock Adjustment** approach:
	* If the stock level is above capacity/2, cooperate (C).
	* If the stock level is below capacity/2, defect (D) if the previous round's total consumption was high (> capacity/4), otherwise cooperate (C).
3. **Mid-Game**: For rounds r/3 to 2r/3, switch to a **Stock-Based Exploitation** approach:
	* If the stock level is above capacity/2 and the previous round's total consumption was low (< capacity/4), defect (D) to exploit the situation.
	* Otherwise, cooperate (C).
4. **Endgame**: For rounds 2r/3 to r, use a **Greed-Based Exploitation** approach:
	* If the stock level is above capacity/4 and there are few remaining rounds (< r/6), defect (D) to maximize payoff.
	* Otherwise, cooperate (C).

**Pseudocode:**
```python
def ASR(n, r, capacity, current_stock, previous_rounds):
    if round == 1:
        return C  # Cooperate in the first round

    elif 2 <= round < r/3:
        prev_total_consumption = sum(previous_rounds[-1])
        if current_stock > capacity / 2:
            return C
        elif current_stock < capacity / 2 and prev_total_consumption > capacity / 4:
            return D
        else:
            return C

    elif r/3 <= round < 2*r/3:
        prev_total_consumption = sum(previous_rounds[-1])
        if current_stock > capacity / 2 and prev_total_consumption < capacity / 4:
            return D
        else:
            return C

    elif 2*r/3 <= round <= r:
        if current_stock > capacity / 4 and round < r - r/6:
            return D
        else:
            return C

    return "Invalid round"
```
**Edge Cases:**

* In the last round, ASR will cooperate (C) to avoid depleting the stock completely.
* If an opponent defects in a previous round, ASR may respond by defecting in the next round if it believes the opponent's behavior is exploitable.

By adapting to the current state and history of the game, ASR aims to balance short-term gains with long-term sustainability, making it a robust and exploitative strategy.
'''

description_EXPLOITATIVE_288 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adaptively responding to the game state and opponent behavior, while also trying to deplete the stock as quickly as possible.

**Decision Rules:**

1. **Initial Round (t=1)**: Defect (D) to gather information about opponents' initial moves.
2. **Middle Rounds (2 ≤ t < r)**:
	* If the current stock level is above 50% of capacity, cooperate (C) with a probability proportional to the number of cooperators in the previous round. This encourages cooperation when the stock is plentiful and opponents are likely to cooperate.
	* If the current stock level is below 50% of capacity, defect (D) to rapidly deplete the remaining stock and maximize individual payoffs.
3. **Final Round (t=r)**: Defect (D) to grab as much of the remaining stock as possible.

**Adaptive Component:**

1. Track the number of cooperators (C_count) and defectors (D_count) in each round.
2. Calculate the cooperation rate (C_rate) as C_count / n, where n is the number of players.
3. Update the cooperation probability (P_C) for middle rounds using a simple heuristic:
	* If C_rate > 0.5, increase P_C by 10% to encourage more cooperation when opponents are cooperative.
	* If C_rate < 0.5, decrease P_C by 10% to defect more often when opponents are not cooperative.

**Pseudocode:**
```python
def adaptive_stock_raider(n, capacity, r):
    stock = capacity
    C_count, D_count = 0, 0
    P_C = 0.5

    for t in range(1, r+1):
        if t == 1:
            action = 'D'
        elif stock > 0.5 * capacity:
            action = 'C' if random.random() < P_C else 'D'
        else:
            action = 'D'

        # Update C_count and D_count based on opponent actions
        if action == 'C':
            C_count += 1
        else:
            D_count += 1

        # Calculate cooperation rate and update P_C
        C_rate = C_count / n
        if C_rate > 0.5:
            P_C = min(1, P_C + 0.1)
        elif C_rate < 0.5:
            P_C = max(0, P_C - 0.1)

        # Update stock level based on actions and growth
        # ...

    return total_payoff
```
This strategy is exploitative in the sense that it aims to maximize individual payoffs by adapting to opponent behavior and manipulating the game state to its advantage. By cooperating when the stock is plentiful and opponents are likely to cooperate, it tries to encourage cooperation and increase overall payoffs. However, when the stock is low or opponents are not cooperative, it rapidly defects to deplete the remaining stock and maximize individual gains.
'''

description_EXPLOITATIVE_289 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adaptively responding to the game state and history, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behavior and avoid over-exploitation.
2. **Middle Rounds (2 ≤ t < r-1)**:
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term gains.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance individual payoffs with sustainability.
	* If the current stock level is below 50% of capacity, Cooperate (C) to conserve resources and avoid over-exploitation.
3. **Last Round (t=r)**: Defect (D) to maximize final-round payoff, as there are no future rounds to consider.

**Adaptive Adjustments:**

* Monitor opponents' behavior by tracking the number of players who cooperated or defected in previous rounds.
* If a majority (>50%) of opponents have consistently cooperated in the last few rounds, adjust the decision rule for middle rounds:
	+ Increase the threshold for defecting from 75% to 90% of capacity.
	+ Decrease the threshold for cooperating from 50% to 25% of capacity.

**Edge Cases:**

* **Opponent Homogeneity**: If all opponents consistently cooperate or defect, adjust the strategy accordingly:
	+ Against cooperative opponents, Defect (D) in middle rounds to maximize individual gains.
	+ Against defective opponents, Cooperate (C) in middle rounds to minimize losses and maintain sustainability.
* **Stock Depletion**: If the stock level drops below 10% of capacity, Cooperate (C) for the remainder of the game to prevent further depletion.

**Pseudocode:**
```python
def Adaptive_Stock_Raider(n, r, capacity, current_stock, history):
    if t == 1:
        return "Cooperate"
    
    if current_stock >= 0.75 * capacity:
        return "Defect"
    elif 0.5 * capacity <= current_stock < 0.75 * capacity:
        return "Cooperate"
    else:
        return "Cooperate"

    # Adaptive adjustments
    opponents_behavior = monitor_opponents(history)
    if majority_cooperated(opponents_behavior):
        adjust_thresholds(capacity)

    # Last round adjustment
    if t == r:
        return "Defect"

def monitor_opponents(history):
    # Analyze previous rounds to determine opponent behavior

def majority_cooperated(opponents_behavior):
    # Check if a majority of opponents cooperated in recent rounds

def adjust_thresholds(capacity):
    # Adjust decision thresholds based on opponent behavior
```
This strategy is designed to be exploitative, yet adaptive and robust to various opponent behaviors. By responding to the game state and history, it aims to maximize individual payoffs while avoiding over-exploitation.
'''

description_EXPLOITATIVE_290 = '''
**Exploitative Strategy: Adaptive Stock Depletion (ASD)**

The ASD strategy aims to maximize its payoff by adaptively exploiting the stock level and opponent behaviors while ensuring robustness against various playing styles.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' initial actions and observe the resulting stock depletion.
2. **Subsequent Rounds**: Defect (D) if the current stock level is above a threshold (`stock_threshold`), calculated as 75% of the capacity (`capacity`). This threshold allows ASD to exploit high stock levels while avoiding over-depletion.
3. **Low Stock Levels**: If the current stock level falls below `stock_threshold`, cooperate (C) to contribute to stock growth and avoid depletion.
4. **Opponent Behavior Analysis**: Monitor opponents' actions in previous rounds and adjust the decision based on their behavior:
	* If most opponents (> 50%) cooperated in the previous round, defect (D) to take advantage of their cooperative behavior.
	* If most opponents (> 50%) defected in the previous round, cooperate (C) to signal a willingness to replenish the stock.

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round to maximize payoff, as there is no future stock growth or depletion concern.
2. **Stock Depletion**: If the current stock level falls below 25% of the capacity (`capacity`), cooperate (C) to avoid complete depletion and allow for some stock growth.

**Pseudocode:**
```python
def ASD_strategy(current_stock, previous_round_actions, round_number):
    if round_number == 1:
        # Initial Round: Cooperate
        return 'C'
    
    stock_threshold = 0.75 * capacity
    
    if current_stock > stock_threshold:
        # High Stock Levels: Defect
        return 'D'
    else:
        # Low Stock Levels: Cooperate
        return 'C'
    
    opponent_behavior = analyze_opponent_actions(previous_round_actions)
    
    if opponent_behavior['cooperate'] > 0.5:
        # Opponents cooperated: Defect
        return 'D'
    elif opponent_behavior['defect'] > 0.5:
        # Opponents defected: Cooperate
        return 'C'
    
    if round_number == total_rounds:
        # Last Round: Defect
        return 'D'
    
    if current_stock < 0.25 * capacity:
        # Stock Depletion: Cooperate
        return 'C'
```
**Rationale:**

The ASD strategy balances exploitation and cooperation to maximize payoff while maintaining a robust response to various opponent behaviors. By adapting to the stock level and opponent actions, ASD aims to:

1. Exploit high stock levels by defecting.
2. Contribute to stock growth when necessary (low stock levels).
3. Analyze opponent behavior to adjust its decision.

This strategy should perform well in a tournament setting against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_291 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk strategy is designed to exploit opponents' behavior while adapting to the dynamic state of the game. This strategy prioritizes cooperation when the stock level is high and defects when the stock level is low, with a smooth transition between these two modes.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and set a positive tone for potential cooperation.
2. **Intermediate Rounds (1 < t < r):**
	* Calculate the stock ratio `stock_ratio = current_stock / capacity`.
	* If `stock_ratio > 0.7`, cooperate (C). This threshold is chosen to ensure that the stock level remains high enough to support cooperative behavior.
	* If `stock_ratio <= 0.7`, defect (D) with a probability `defect_prob` calculated as follows:
		+ `defect_prob = max(0, min(1, (0.7 - stock_ratio) / 0.3))`
		+ This formula smoothly increases the defection probability as the stock level decreases.
3. **Last Round (t=r):** Defect (D), as there is no future game to consider.

**Edge Cases:**

* If `n=2` and `r=2`, always cooperate in the first round, and defect in the second round if the opponent cooperated in the first round.
* In the event of a tie in the stock ratio calculation (e.g., due to floating-point precision issues), cooperate.

**Rationale:**

By cooperating when the stock level is high, the Adaptive Stock Hawk strategy encourages opponents to cooperate as well, maintaining a stable and profitable equilibrium. As the stock level decreases, the strategy gradually shifts towards defection, taking advantage of potential over-harvesting by opponents.

The `defect_prob` calculation allows for adaptability in response to changing opponent behavior. By continuously assessing the stock ratio and adjusting the defect probability accordingly, the Adaptive Stock Hawk strategy can exploit opponents' mistakes while minimizing its own losses.

**Pseudocode:**
```python
def adaptive_stock_hawk(current_stock, capacity, n, r, t):
    if t == 1:
        return "C"  # Cooperate in the first round

    stock_ratio = current_stock / capacity

    if stock_ratio > 0.7:
        return "C"
    else:
        defect_prob = max(0, min(1, (0.7 - stock_ratio) / 0.3))
        if random.random() < defect_prob:
            return "D"  # Defect with calculated probability
        else:
            return "C"

# Last round: always defect
if t == r:
    return "D"
```
This strategy is designed to be robust against various opponent behaviors and will adapt to changing circumstances throughout the game.
'''

description_EXPLOITATIVE_292 = '''
**Exploitative Strategy: Adaptive Stock Protector (ASP)**

The ASP strategy aims to maximize its payoff by adaptively responding to the opponents' actions and the game state while protecting the stock level.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to observe opponents' behavior and set a high initial stock level.
2. **Stock Level Assessment:** Calculate the current stock-to-capacity ratio (SCR): `SCR = stock / capacity`.
3. **Cooperation Threshold:** Define a cooperation threshold (`CT`) based on SCR:
	* If `SCR ≥ 0.7`, cooperate (C) to maintain a high stock level.
	* Otherwise, defect (D) to exploit opponents' cooperation.
4. **Opponent Exploitation:** Monitor the number of opponents playing D in the previous round (`num_defectors`).
	* If `num_defectors > n/2`, defect (D) to take advantage of their exploitation.
5. **Adaptive Adjustment:** Update the cooperation threshold (`CT`) based on the game's progress:
	* If the stock level is consistently low (< 0.3 \* capacity), decrease CT by 0.1 to become more exploitative.
	* If the stock level is consistently high (> 0.8 \* capacity), increase CT by 0.1 to become more cooperative.

**Edge Cases:**

* **Last Round:** Defect (D) in the last round, as there's no future benefit from cooperation.
* **Low Stock Level:** If the stock level falls below a certain threshold (`low_stock_threshold = 0.2 \* capacity`), cooperate (C) to help replenish the stock.

**Pseudocode:**
```python
def ASP(stock, capacity, n, round_num, history):
    SCR = stock / capacity
    
    if round_num == 1:
        return C
    
    CT = 0.7
    
    if SCR >= CT:
        action = C
    else:
        num_defectors = count_defectors(history)
        if num_defectors > n/2:
            action = D
        else:
            action = C
            
    # Adaptive adjustment
    if stock < 0.3 * capacity:
        CT -= 0.1
    elif stock > 0.8 * capacity:
        CT += 0.1
        
    # Low stock level handling
    if stock < low_stock_threshold:
        return C
    
    # Last round handling
    if round_num == r:
        return D
    
    return action
```
**Rationale:**

The ASP strategy balances cooperation and exploitation to maximize its payoff. By cooperating when the stock level is high, it helps maintain a sustainable resource. When opponents exploit the resource, ASP adapts by becoming more exploitative. The adaptive adjustment mechanism allows the strategy to respond to changes in the game state and opponent behavior.

By being exploitative, ASP takes advantage of opponents' cooperation while minimizing its own contribution to the stock depletion. This approach should perform well against a wide range of opponent strategies in a tournament setting.
'''

description_EXPLOITATIVE_293 = '''
**Strategy Name: Adaptive Exploiter**

The Adaptive Exploiter is a robust and exploitative strategy designed for the Common Pool Resource Game. It adapts to various opponent behaviors by analyzing the game's history and state.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior.
2. **Middle Rounds (1 < t < r-1):**
	* If the current stock is high (> 75% of capacity), Defect (D) to maximize personal payoff, as the resource can sustain high consumption.
	* If the current stock is moderate (25% ≤ stock ≤ 75% of capacity), cooperate (C) if most opponents (> 50%) cooperated in the previous round. Otherwise, Defect (D).
	* If the current stock is low (< 25% of capacity), Cooperate (C) to conserve resources and promote regrowth.
3. **Penultimate Round (t=r-1):**
	* Analyze the game's history: if most opponents (> 50%) have cooperated, Defect (D) in this round to exploit their cooperation.
	* Otherwise, Cooperate (C) to maintain a stable resource level for the final round.
4. **Final Round (t=r):** Always Defect (D), as there are no future rounds to consider.

**Additional Rules:**

* If an opponent defects in two consecutive rounds while the stock is low (< 25% of capacity), label them as "aggressive." In subsequent rounds, Defect (D) when interacting with aggressive opponents.
* When facing multiple opponents with diverse behaviors, prioritize exploiting the most cooperative opponents.

**Pseudocode:**
```python
function AdaptiveExploiter(n, r, capacity, history):
  if t == 1:
    return C  # Initial round

  stock_level = current_stock / capacity
  opponents_behavior = analyze_opponents_actions(history)

  if stock_level > 0.75:
    return D  # High stock, defect to maximize payoff
  elif 0.25 <= stock_level <= 0.75:
    if most_opponents_cooperated(opponents_behavior):
      return C  # Moderate stock, cooperate with cooperative opponents
    else:
      return D  # Moderate stock, defect against uncooperative opponents
  else:
    return C  # Low stock, conserve resources

  if t == r - 1:  # Penultimate round
    if most_opponents_cooperated(opponents_behavior):
      return D  # Exploit cooperative opponents
    else:
      return C  # Maintain stable resource level

  if t == r:  # Final round
    return D  # Always defect in the final round

function analyze_opponents_actions(history):
  # Analyze opponents' actions to determine their behavior (cooperative or uncooperative)
```
The Adaptive Exploiter is a robust and exploitative strategy designed to adapt to various opponent behaviors. By analyzing the game's history and state, it makes informed decisions to maximize personal payoff while conserving resources when necessary. This strategy is well-suited for a tournament setting where opponents may employ diverse strategies.
'''

description_EXPLOITATIVE_294 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider strategy aims to maximize its payoff by adaptively adjusting its cooperation level based on the current stock state and the observed behavior of other players.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5. This initial randomness helps to gather information about opponents' strategies without revealing our own.
2. **Middle Rounds (t > 1):**
	* If the current stock level is above 75% of the capacity, Defect (D). The high stock level indicates that others are cooperating too much, making it safe to exploit them.
	* If the current stock level is between 25% and 75% of the capacity, Cooperate (C) with a probability proportional to the stock level (i.e., 0.5 \* (stock / capacity)). This adaptive cooperation rate balances our payoff with the need to maintain a healthy stock level.
	* If the current stock level is below 25% of the capacity, Defect (D). The low stock level indicates that others are defecting too much or the game is near its end, making it essential to prioritize our own payoff.
3. **Last Round (t=r):** Always Defect (D), as there is no future benefit in cooperating.

**Additional Logic:**

* **Opponent Monitoring:** Track the average cooperation rate of opponents over the last few rounds (e.g., 5 rounds). If this rate increases, we decrease our cooperation probability by a small amount (e.g., 0.1) to adapt to their changing behavior.
* **Stock Trend Analysis:** Monitor the stock level trend over the last few rounds. If the trend is decreasing, we increase our defect probability by a small amount (e.g., 0.1) to take advantage of the dwindling resource.

**Pseudocode:**
```python
def adaptive_stock_raider(stock, capacity, t, r, opponent_cooperation_rate):
    if t == 1:
        return random.choice([C, D])  # Random initial action

    stock_percentage = stock / capacity

    if stock_percentage > 0.75:
        return D  # Defect when stock is high
    elif 0.25 <= stock_percentage <= 0.75:
        cooperation_probability = 0.5 * (stock_percentage)
        return C if random.random() < cooperation_probability else D
    else:
        return D  # Defect when stock is low

    if t == r:
        return D  # Always defect in the last round

    # Adjust opponent monitoring and stock trend analysis here
    # ...
```
This strategy balances short-term gains with long-term sustainability, making it a robust and exploitative approach to playing the Common Pool Resource Game.
'''

description_EXPLOITATIVE_295 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The ASR strategy aims to maximize its payoff by adaptively responding to the game state and opponent behavior. It balances cooperation and defection to ensure long-term stock sustainability while exploiting opponents' weaknesses.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to gauge opponents' behavior and avoid initial over-exploitation.
2. **Stock Thresholds**: Define two stock thresholds:
	* `low_threshold` = 0.5 \* capacity
	* `high_threshold` = 0.8 \* capacity

If the current stock is below `low_threshold`, cooperate (C) to allow for stock growth. If the stock is above `high_threshold`, defect (D) to maximize immediate payoff.

3. **Opponent Behavior Analysis**: Track the number of opponents who cooperated (`num_cooperators`) and defected (`num_defectors`) in the previous round.
	* If `num_cooperators` > `num_defectors`, cooperate (C) in the current round, assuming a cooperative environment.
	* If `num_defectors` ≥ `num_cooperators`, defect (D) to exploit potential free-riding opponents.

4. **Adaptive Response**: Monitor the stock growth rate and adjust strategy accordingly:
	* If stock growth is high (> 0.5 \* capacity), cooperate (C) to sustain growth.
	* If stock growth is low (< 0.2 \* capacity), defect (D) to maximize immediate payoff.

**Edge Cases**

1. **Last Round**: Defect (D) in the last round, as there is no future benefit from cooperation.
2. **Tiebreakers**: In cases where multiple conditions are met, prioritize the following order:
	* Stock thresholds
	* Opponent behavior analysis
	* Adaptive response

**Pseudocode**
```python
def adaptive_stock_raider(stock, capacity, num_players, round_num):
    if round_num == 1:  # Initial Round
        return "C"

    low_threshold = 0.5 * capacity
    high_threshold = 0.8 * capacity

    if stock < low_threshold:
        return "C"
    elif stock > high_threshold:
        return "D"

    num_cooperators, num_defectors = analyze_opponent_behavior()
    if num_cooperators > num_defectors:
        return "C"
    else:
        return "D"

    # Adaptive response
    growth_rate = calculate_stock_growth(stock, capacity)
    if growth_rate > 0.5 * capacity:
        return "C"
    elif growth_rate < 0.2 * capacity:
        return "D"

def analyze_opponent_behavior():
    # Track opponent actions from previous rounds
    num_cooperators = ...
    num_defectors = ...
    return num_cooperators, num_defectors

def calculate_stock_growth(stock, capacity):
    # Calculate stock growth rate based on current stock and capacity
    growth_rate = ...
    return growth_rate
```
The ASR strategy is designed to be robust against a wide range of opponent behaviors while maximizing its own payoff. By adaptively responding to the game state and opponent behavior, it balances cooperation and defection to ensure long-term stock sustainability.
'''

description_EXPLOITATIVE_296 = '''
To develop a robust and exploitative strategy for this Common Pool Resource Game, I'll design a decision rule that takes into account the game's parameters, state, and history.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rule:**

1. **First Round**: Cooperate (C) in the first round to observe opponents' initial behavior and set a baseline for future decisions.
2. **Subsequent Rounds**: Use a hybrid approach that balances exploitation with sustainability:
	* If the current stock is above 75% of capacity, Defect (D) to maximize short-term payoffs.
	* If the current stock is between 25% and 75% of capacity, Cooperate (C) if most opponents (>50%) cooperated in the previous round; otherwise, Defect (D).
	* If the current stock is below 25% of capacity, Cooperate (C) to help replenish the stock.
3. **Opponent Behavior Analysis**: Keep track of each opponent's cooperation rate over time (e.g., using a moving average). Identify opponents who consistently cooperate or defect.
4. **Exploitation Phase**: Once you've identified an opponent as a consistent cooperator, Defect (D) when playing against them to maximize payoffs.
5. **Sustainability Check**: If the stock is critically low (<10% of capacity), Cooperate (C) for one round to help replenish it and avoid collapse.

**Edge Cases:**

* Last Round: Defect (D) in the final round, as there's no future cost to over-exploitation.
* Multiple opponents with similar cooperation rates: Use a tiebreaker mechanism, such as choosing the opponent with the highest average payoff or the one who cooperated most recently.
* Opponent behavior changes suddenly: Reassess their cooperation rate and adjust your strategy accordingly.

**Pseudocode:**
```python
def adaptive_exploiter(stock, capacity, opponents_cooperation_rates, round_number):
    if round_number == 1:
        return C
    
    # Check stock level
    if stock > 0.75 * capacity:
        return D
    elif 0.25 * capacity <= stock <= 0.75 * capacity:
        most_recent_opponent_behavior = get_most_recent_opponent_actions()
        if most_recent_opponent_behavior > 0.5:  # More than half cooperated
            return C
        else:
            return D
    else:
        return C
    
    # Opponent behavior analysis and exploitation phase
    for opponent in opponents:
        cooperation_rate = get_cooperation_rate(opponent)
        if cooperation_rate > 0.7:  # Consider as a consistent cooperator
            return D
    
    # Sustainability check
    if stock < 0.1 * capacity:
        return C

def get_most_recent_opponent_actions():
    # Return the most recent actions of all opponents (e.g., using a moving average)
    pass

def get_cooperation_rate(opponent):
    # Calculate and return the cooperation rate for the given opponent
    pass
```
This strategy aims to strike a balance between exploiting the common pool resource and maintaining its sustainability. By analyzing opponent behavior and adjusting its decision rule accordingly, Adaptive Exploiter can effectively respond to various opponent strategies while maximizing its own payoffs.
'''

description_EXPLOITATIVE_297 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk (ASH) strategy is designed to maximize payoffs by adapting to the game's dynamic state and exploiting opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This allows ASH to observe opponents' initial actions and sets a baseline for future decisions.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Defect (D). Exploit the abundance of resources to maximize short-term gains.
	* If the current stock level is between 25% and 75% of capacity:
		+ Cooperate (C) if the average payoff per player in the previous round was below the game's average payoff. This suggests opponents are cooperating, allowing ASH to maintain a stable stock level.
		+ Defect (D) otherwise. If opponents are earning high payoffs, it indicates they're defecting; ASH should do the same to avoid being exploited.
	* If the current stock level is below 25% of capacity, Cooperate (C). Prioritize replenishing the stock to ensure long-term sustainability.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) unconditionally. With no future rounds to consider, ASH should maximize its final payoff.
2. **Low Stock Levels (<10% of capacity):** Cooperate (C) for two consecutive rounds to help replenish the stock and avoid depletion.

**Adaptive Mechanisms:**

1. **Payoff Monitoring:** Track the average payoff per player in each round to gauge opponents' behavior and adjust ASH's strategy accordingly.
2. **Stock Level Assessment:** Continuously monitor the current stock level to determine the best course of action based on the decision rules above.

**Pseudocode (for illustration purposes):**
```python
def AdaptiveStockHawk(current_stock, capacity, round_number, average_payoff_previous_round):
    if round_number == 1:
        return "C"  # Cooperate in the first round
    
    if current_stock > 0.75 * capacity:
        return "D"  # Defect when stock is abundant
    
    elif 0.25 * capacity <= current_stock <= 0.75 * capacity:
        if average_payoff_previous_round < game_average_payoff:
            return "C"  # Cooperate if opponents are cooperative
        else:
            return "D"  # Defect otherwise
    
    elif current_stock < 0.25 * capacity:
        return "C"  # Cooperate to replenish stock
    
    elif round_number == r:  # Last round
        return "D"  # Defect unconditionally

    elif current_stock < 0.1 * capacity:  # Low stock levels
        if previous_action == "C":
            return "C"  # Cooperate for two consecutive rounds to replenish stock
        else:
            return "D"
```
The Adaptive Stock Hawk strategy is designed to balance short-term gains with long-term sustainability, while adapting to the dynamic game state and exploiting opponents' behaviors.
'''

description_EXPLOITATIVE_298 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll introduce a hybrid approach that balances short-term gains with long-term sustainability. Our strategy, dubbed "Adaptive Exploiter," aims to maximize payoffs by dynamically adjusting its behavior based on the game's state and history.

**Decision Rules:**

1. **Initial Rounds (t ≤ 2):** Cooperate (C) in the first two rounds to gather information about other players' behaviors and assess the stock's initial growth rate.
2. **Stock-dependent Threshold:** Set a dynamic threshold, `θ`, based on the current stock level (`S`) and capacity (`c`). When `S ≥ θ*c`, cooperate; otherwise, defect.

`θ = 0.6 + (0.1 * (t/r))`

This formula increases the likelihood of cooperation as rounds progress (`t/r` term) while adjusting for the remaining stock.
3. **Opponent Behavior Adaptation:** Monitor opponents' actions in previous rounds and adjust your behavior accordingly:
	* If most opponents (>50%) cooperated in the last round, increase `θ` by 0.05 to encourage cooperation.
	* If most opponents defected, decrease `θ` by 0.05 to incentivize defecting.
4. **Exploitation Opportunity:** Identify potential exploitation opportunities when:
	+ The current stock is high (`S ≥ 0.8*c`) and many opponents (>50%) cooperated in the last round.
	+ In this case, defect (D) to maximize short-term payoffs.

**Edge Cases:**

1. **Last Round (t = r):** Always defect, as there are no future rounds to consider.
2. **Critical Stock Levels:** If `S < 0.2*c`, always cooperate to prevent stock collapse and ensure some payoff in the next round.
3. **All Opponents Defecting:** If all opponents defected in the last round, adjust `θ` down by 0.1 to reflect the likely outcome of mutual defection.

**Pseudocode (simplified):**

```markdown
# Initialize variables
t = 1  # Round counter
r = ...  # Number of rounds
c = ...  # Capacity
S = c  # Initial stock level
θ = 0.6 + (0.1 * (t/r))  # Dynamic threshold

while t ≤ r:
    # Assess opponent behavior and adjust θ
    opponents_cooperated = count_cooperations(last_round)
    if opponents_cooperated > 50%:
        θ += 0.05
    else:
        θ -= 0.05
    
    # Determine action based on stock level and θ
    if S ≥ θ * c:
        action = Cooperate (C)
    elif exploitation_opportunity(S, opponents_cooperated):
        action = Defect (D)
    else:
        action = Defect (D)

    # Critical stock levels or last round override
    if S < 0.2*c:
        action = Cooperate (C)
    elif t == r:
        action = Defect (D)

    # Play the game and update state
    play_game(action)
    S = update_stock(S, c)

    # Increment round counter
    t += 1

# Calculate total payoff over all rounds
total_payoff = calculate_total_payoff()
```

This Adaptive Exploiter strategy combines elements of cooperation, adaptation, and exploitation to balance short-term gains with long-term sustainability. By monitoring the game's state and history, it adjusts its behavior to maximize payoffs while minimizing the risk of stock collapse.
'''

description_EXPLOITATIVE_299 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round (t=1)**: Cooperate (C) with a probability of 0.5 to gather information about opponents' behavior and initial stock dynamics.
2. **Early Rounds (t < r/2)**:
	* If the current stock level is above 75% of capacity, cooperate (C).
	* Otherwise, defect (D) to maximize short-term gains while maintaining some stock for future rounds.
3. **Middle Rounds (r/2 ≤ t < 3r/4)**:
	* Analyze opponents' behavior in previous rounds using a simple frequency analysis:
		+ If most opponents (>50%) cooperated in the previous round, cooperate (C) to maintain a healthy stock level.
		+ Otherwise, defect (D) to exploit opponents' cooperation and maximize gains.
	* Adjust this decision based on current stock levels: if the stock is low (< 25% of capacity), defect (D) regardless of opponents' behavior.
4. **Late Rounds (t ≥ 3r/4)**:
	* Focus on maximizing short-term gains, as the game's end is near:
		+ If the current stock level is above 50% of capacity, cooperate (C) to ensure some remaining stock for the final rounds.
		+ Otherwise, defect (D) to exploit any remaining cooperation and maximize final payoffs.

Edge Cases:

* **Last Round (t=r)**: Defect (D) unconditionally, as there are no future rounds to consider.
* **Extremely Low Stock**: If the current stock level is below 10% of capacity, defect (D) regardless of opponents' behavior or game stage, as cooperation would yield minimal benefits.

Pseudocode for Adaptive Stock Raider strategy:

```
function playRound(currentStock, roundNumber, opponentHistory):
    if roundNumber == 1:
        return random.choice([C, D]) // initial exploration
    elif roundNumber < r/2:
        if currentStock > 0.75 * capacity:
            return C
        else:
            return D
    elif r/2 <= roundNumber < 3r/4:
        opponentsCooperated = count(C in opponentHistory[-1])
        if opponentsCooperated > 0.5 * n and currentStock >= 0.25 * capacity:
            return C
        else:
            return D
    else: // late rounds
        if currentStock >= 0.5 * capacity:
            return C
        else:
            return D

function getAction(currentState):
    currentStock = currentState.stock
    roundNumber = currentState.round
    opponentHistory = currentState.opponentActions
    return playRound(currentStock, roundNumber, opponentHistory)
```

This strategy balances short-term gains with long-term sustainability by adapting to opponents' behavior and the game's state. By initially cooperating with some probability and later defecting when beneficial, it aims to exploit a wide range of opponent behaviors while maintaining robustness in various scenarios.
'''

description_EXPLOITATIVE_300 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to observe opponents' initial actions and gather information about their strategies.
2. **Early Rounds (t>1, stock ≥ 0.75*capacity)**: Defect (D) if the average payoff of defectors in previous rounds is higher than that of cooperators. Otherwise, cooperate (C).
3. **Middle Rounds (t > r/2, stock < 0.75*capacity)**: Switch to a "tit-for-tat" approach:
	* If most opponents (≥ n/2) defected in the previous round, defect (D).
	* If most opponents cooperated or there's a tie, cooperate (C).
4. **Late Rounds (t > 3r/4)**: Defect (D) if stock < 0.5*capacity, as the game is nearing its end and cooperation is less beneficial.
5. **Final Round (t=r)**: Always defect (D), as there's no future benefit from cooperation.

**Edge Cases:**

1. If an opponent has consistently cooperated throughout the game, consider them a "sucker" and always defect against them in the remaining rounds.
2. If all opponents have defected in a previous round, cooperate (C) to replenish the stock and create opportunities for future exploitation.

**Adaptive Mechanisms:**

1. **Payoff tracking**: Monitor the average payoff of cooperators and defectors across all players over time to adjust strategy.
2. **Opponent classification**: Label opponents as "cooperators" or "defectors" based on their historical actions, allowing for targeted exploitation.
3. **Stock monitoring**: Continuously track the stock level to adjust strategy according to the game's state.

**Exploitative Mindset:**

This strategy is designed to maximize individual payoff by exploiting others' cooperation whenever possible, while adapting to changes in the game state and opponents' behaviors. By initially cooperating, we gather information about opponents' strategies and then gradually shift to a more exploitative approach as the game progresses. The tit-for-tat mechanism in middle rounds helps to stabilize our payoff against mixed opponent strategies.

In late rounds, when cooperation is less beneficial, we prioritize self-interest by defecting to maximize individual gain. By classifying opponents and adjusting strategy accordingly, we can take advantage of "suckers" who consistently cooperate, while minimizing losses against more exploitative opponents.

This adaptive strategy should perform well in a tournament setting, as it balances short-term gains with long-term adaptability to varying opponent behaviors.
'''

description_EXPLOITATIVE_301 = '''
**Exploitative Strategy: "Adaptive Stock Exploiter" (ASE)**

The ASE strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the game. The goal is to maximize payoffs by making informed decisions based on the current stock level, number of players, and round number.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* If `stock` is close to `capacity`, play `C` (Cooperate) to avoid depleting the stock too quickly.
	* Otherwise, play `D` (Defect) to maximize immediate payoff.
2. **Middle Rounds (2 ≤ t < r-1)**:
	* Monitor the average stock depletion rate (`stock_depletion_rate`) over the last few rounds.
	* If `stock_depletion_rate` is high (> 0.5), play `C` to conserve stock and promote growth.
	* Otherwise, play `D` to exploit the current stock level.
3. **Final Round (t=r)**:
	* Play `D` regardless of the stock level, as there's no future benefit from conserving it.

**Additional Logic:**

1. **Stock Thresholds**: Define two stock thresholds:
	+ `low_stock_threshold` = 0.25 × `capacity`
	+ `high_stock_threshold` = 0.75 × `capacity`

When the current stock level falls below `low_stock_threshold`, play `C` to avoid depleting the stock too quickly. When it exceeds `high_stock_threshold`, play `D` to maximize immediate payoff.

2. **Opponent Behavior Analysis**: Observe the actions of other players over the last few rounds and calculate their average cooperation rate (`avg_coop_rate`).

If `avg_coop_rate` is high (> 0.5), increase the likelihood of playing `C` to maintain a sustainable stock level. Otherwise, increase the likelihood of playing `D` to exploit the opponent's lack of cooperation.

**Pseudocode:**

```
function AdaptiveStockExploiter(stock, capacity, n, r, t):
  if t == 1:
    # Initial round logic
    if stock >= 0.9 * capacity:
      return C
    else:
      return D

  elif 2 <= t < r-1:
    # Middle rounds logic
    stock_depletion_rate = calculate_stock_depletion_rate()
    if stock_depletion_rate > 0.5:
      return C
    else:
      avg_coop_rate = analyze_opponent_behavior()
      if avg_coop_rate > 0.5 and stock < high_stock_threshold:
        return C
      elif avg_coop_rate < 0.5 or stock > low_stock_threshold:
        return D

  else:  # Final round logic
    return D
```

**Edge Cases:**

* If the game has only two rounds (r=2), play `D` in both rounds, as there's no benefit from conserving stock.
* If an opponent defects in every round, adjust the strategy to play `C` more frequently to maintain a sustainable stock level.

By incorporating these decision rules and adaptations, the ASE strategy aims to effectively exploit a wide range of opponent behaviors while ensuring long-term sustainability of the common pool resource.
'''

description_EXPLOITATIVE_302 = '''
**Strategy: Adaptive Exploitation (AE)**

The AE strategy aims to maximize individual payoffs by adapting to the game state and history while exploiting opponents' behaviors.

**Decision Rules**

1. **Initial Round**: In the first round, play Cooperate (C) to gather information about the opponents' initial behavior.
2. **Assess Opponent Behavior**: After each round, calculate the average opponent consumption (`avg_opponent_consumption`) by dividing the total stock consumed by the number of opponents.

**Classification of Opponents**

Based on `avg_opponent_consumption`, classify opponents into three categories:

* **Cooperative**: `avg_opponent_consumption` < (stock / (2n))
* **Defective**: `avg_opponent_consumption` > (stock / n)
* **Mixed**: otherwise

**Adaptive Exploitation**

Based on the classification, adjust your action as follows:

1. **Against Cooperative Opponents**: Defect (D) to exploit their cooperation.
	+ If opponents are consistently cooperative, continue defecting to maximize individual payoffs.
2. **Against Defective Opponents**: Cooperate (C) to minimize losses and encourage opponents to adapt.
	+ If opponents persist in defecting, consider switching to a more competitive strategy (see below).
3. **Against Mixed Opponents**: Play the same action as the majority of opponents in the previous round.
	+ This helps to maintain a balance between cooperation and exploitation.

**Competitive Strategy**

If opponents consistently defect and your payoffs are low, switch to a more competitive strategy:

* **Tit-for-Tat (TFT)**: Mirror the opponent's previous action. If they defected, defect; if they cooperated, cooperate.
* **Grim Trigger**: Cooperate until an opponent defects, then always defect.

**Edge Cases**

1. **Last Round**: In the final round, play Defect (D) to maximize individual payoffs, regardless of opponents' behavior.
2. **Low Stock Levels**: When the stock level is low (< 20% of capacity), cooperate (C) to allow for some growth and increase the chances of a better payoff in future rounds.

**Pseudocode**

```
function AdaptiveExploitation(n, r, capacity, history):
  if current_round == 1:
    action = Cooperate
  else:
    avg_opponent_consumption = calculate_avg_opponent_consumption(history)
    
    if avg_opponent_consumption < (stock / (2n)):
      # Cooperative opponents
      action = Defect
    elif avg_opponent_consumption > (stock / n):
      # Defective opponents
      action = Cooperate
    else:
      # Mixed opponents
      majority_action = get_majority_action(history)
      action = majority_action
    
  if current_round == r:  # Last round
    action = Defect
    
  if stock < 0.2 * capacity:  # Low stock levels
    action = Cooperate
    
  return action
```

This strategy is designed to be adaptive and robust, taking into account the game state, history, and opponents' behavior. By exploiting cooperative opponents and adapting to defective or mixed behaviors, AE aims to maximize individual payoffs in a wide range of scenarios.
'''

description_EXPLOITATIVE_303 = '''
Here's a robust and adaptive exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** "Adaptive Predator"

**Decision Rules:**

1. **First Round:** Cooperate (C). Observe opponents' actions to gather information about their strategies.
2. **Middle Rounds (r > 1):**
	* If the current stock level is high (> capacity/2) and most opponents (> n/2) cooperated in the previous round, Defect (D) with probability p = 0.7. Otherwise, Cooperate (C).
	* If the current stock level is low (< capacity/4), always Cooperate (C) to conserve resources.
3. **Last Round:** Always Defect (D). There's no future gain from conserving resources.

**Additional Logic:**

1. **Stock Level Monitoring:** Keep track of the average stock depletion rate over the past few rounds (~ 5 rounds). If the rate is high (> capacity/10 per round), increase cooperation probability to slow down resource depletion.
2. **Opponent Profiling:** Maintain a simple profile for each opponent, tracking their cooperation rates and recent actions. Identify "cooperators" (C-rate > 0.7) and "defectors" (C-rate < 0.3).
3. **Exploitation:** When interacting with identified "cooperators", increase Defection probability to p = 0.9. Conversely, when interacting with "defectors", increase Cooperation probability to p = 0.6.

**Pseudocode:**
```python
# Initialize variables
stock_history = []
opponent_profiles = {i: {"C-rate": 0.5} for i in range(n)}

for round in range(r):
    # First Round
    if round == 0:
        action = "C"
    
    # Middle Rounds
    elif round > 0 and round < r-1:
        stock_level = get_stock_level()
        opponents_coop_rate = calculate_opponents_coop_rate(opponent_profiles)
        
        if stock_level > capacity/2 and opponents_coop_rate > n/2:
            action = "D" with probability p=0.7
        elif stock_level < capacity/4:
            action = "C"
        else:
            # Monitor stock depletion rate and adjust cooperation probability
            avg_depletion_rate = calculate_avg_depletion_rate(stock_history)
            if avg_depletion_rate > capacity/10:
                increase_cooperation_probability()
        
        # Update opponent profiles
        for i in range(n):
            update_opponent_profile(opponent_profiles[i], get_opponent_action(i))
    
    # Last Round
    else:
        action = "D"
    
    # Perform action and observe outcome
    take_action(action)
    stock_level = get_stock_level()
    stock_history.append(stock_level)

# Helper functions
def calculate_opponents_coop_rate(opponent_profiles):
    coop_rates = [profile["C-rate"] for profile in opponent_profiles.values()]
    return sum(coop_rates) / len(coop_rates)

def update_opponent_profile(profile, action):
    if action == "C":
        profile["C-rate"] += 0.1
    else:
        profile["C-rate"] -= 0.1

def calculate_avg_depletion_rate(stock_history):
    # Simple moving average of stock depletion rate over the past few rounds
    return sum([stock_history[i] - stock_history[i-1] for i in range(5, len(stock_history))]) / 5
```
This strategy aims to adaptively balance resource exploitation with conservation, while also exploiting opponents' cooperation rates. By monitoring stock levels and opponent behavior, "Adaptive Predator" adjusts its actions to maximize payoffs while minimizing the risk of resource depletion.

Feel free to ask if you'd like me to clarify any aspect of this strategy!
'''

description_EXPLOITATIVE_304 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round (t=1)**: Cooperate (C) to establish a baseline for stock depletion and observe opponents' initial actions.
2. **Early Rounds (2 ≤ t < r/2)**:
	* If the current stock is above 75% of capacity, Defect (D) to maximize short-term gain while the stock is still high.
	* Otherwise, Cooperate (C) to conserve the remaining stock and encourage opponents to do the same.
3. **Mid-Game (r/2 ≤ t < r)**:
	* Monitor the average payoff of all players over the past 5 rounds.
	* If the average payoff is increasing or stable, Defect (D) to capitalize on the trend.
	* Otherwise, Cooperate (C) to prevent further stock depletion and encourage a rebound.
4. **Endgame (t ≥ r-2)**:
	* Analyze the current stock level and the number of remaining rounds.
	* If the stock is low (< 25% of capacity) or only one round remains, Defect (D) to maximize final payoff regardless of the outcome.
	* Otherwise, Cooperate (C) to ensure a stable ending and minimize losses.

Edge Cases:

1. **Last Round (t=r)**: Always Defect (D) to secure the maximum possible payoff in the final round.
2. **Low Stock**: If the current stock is critically low (< 10% of capacity), always Cooperate (C) to prevent depletion and potential negative payoffs.

Pseudocode:
```python
def adaptive_stock_raider(stock, t, r, n, capacity):
    if t == 1:  # Initial round
        return "C"
    
    if 2 <= t < r/2:  # Early rounds
        if stock > 0.75 * capacity:
            return "D"
        else:
            return "C"
    
    if r/2 <= t < r:  # Mid-game
        avg_payoff = calculate_avg_payoff(t-5, t)
        if avg_payoff >= previous_avg_payoff:
            return "D"
        else:
            return "C"
    
    if t >= r-2:  # Endgame
        if stock < 0.25 * capacity or t == r:
            return "D"
        else:
            return "C"

def calculate_avg_payoff(start, end):
    total_payoff = sum(player_payoffs[t] for t in range(start, end+1))
    return total_payoff / (end - start + 1)
```
This strategy aims to balance short-term gain with long-term sustainability by adapting to the game's state and history. It exploits opponents' behaviors by defecting when possible while maintaining a stable stock level through cooperation when necessary.
'''

description_EXPLOITATIVE_305 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to maximize payoffs by exploiting opponent behaviors while maintaining a balance between cooperation and defection.

**Decision Rules:**

1. **Initial Exploration (Rounds 1-3)**:
	* Play C (Cooperate) in the first round to gather information on opponents' initial actions.
	* In rounds 2-3, play D (Defect) if most opponents (>50%) defected in the previous round; otherwise, play C.
2. **Adaptive Response**:
	* Monitor opponent behaviors and update a "defection rate" estimate for each opponent (i.e., proportion of times they've defected).
	* Play D if an opponent's estimated defection rate exceeds 0.5 or if their previous action was D; otherwise, play C.
3. **Stock-Based Adaptation**:
	* If the stock level falls below a threshold (e.g., capacity/2), switch to playing C for two rounds to allow the stock to recover.
4. **Endgame Manipulation**:
	* In the last round, play D if the opponent's estimated defection rate is high (>0.7); otherwise, play C.

**Pseudocode:**
```python
def adaptive_predator(stock, capacity, opponents_actions, my_history):
    # Initialize variables
    defection_rates = {opponent: 0 for opponent in range(n)}
    exploration_phase = True

    if len(my_history) < 3:
        # Initial Exploration (Rounds 1-3)
        if len(my_history) == 0:
            return 'C'  # Cooperate in the first round
        elif len(my_history) <= 2:
            most_opponents_defected = sum(1 for action in opponents_actions[-1] if action == 'D') > n / 2
            return 'D' if most_opponents_defected else 'C'

    # Adaptive Response
    for opponent, actions in enumerate(opponents_actions):
        defection_rate = sum(1 for action in actions if action == 'D') / len(actions)
        defection_rates[opponent] = defection_rate

    previous_action = opponents_actions[-1]
    max_defection_rate_opponent = max(defection_rates, key=defection_rates.get)

    if previous_action[max_defection_rate_opponent] == 'D' or defection_rates[max_defection_rate_opponent] > 0.5:
        return 'D'
    else:
        return 'C'

    # Stock-Based Adaptation
    if stock < capacity / 2:
        # Switch to cooperate for two rounds
        cooperation_counter = 0
        while cooperation_counter < 2:
            yield 'C'
            cooperation_counter += 1

    # Endgame Manipulation (last round)
    if len(my_history) == r - 1:
        max_defection_rate_opponent = max(defection_rates, key=defection_rates.get)
        return 'D' if defection_rates[max_defection_rate_opponent] > 0.7 else 'C'
```
**Notes:**

* The Adaptive Predator strategy balances cooperation and defection based on opponent behaviors and the stock level.
* It adapts to changing conditions by updating estimates of opponents' defection rates and responding accordingly.
* In the endgame, it attempts to manipulate the outcome by playing D against high-defection-rate opponents or C otherwise.

This strategy is designed to be exploitative, yet robust to a wide range of opponent behaviors. Its adaptability allows it to respond effectively in various scenarios, maximizing payoffs while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_306 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) is a robust and adaptive exploitative strategy designed for the Common Pool Resource Game. ASR aims to maximize its payoff by dynamically adjusting its behavior based on the game's state, history, and opponent actions.

**Decision Rules:**

1. **Initial Round:** In the first round, play Cooperate (C). This initial cooperation allows us to observe opponents' behaviors without sacrificing significant payoffs.
2. **Subsequent Rounds:** For each subsequent round, calculate the following:
	* `stock_depletion_rate`: the average rate of stock depletion per round, calculated as `(initial_stock - current_stock) / (round_number - 1)`
	* `opponent_defection_rate`: the estimated proportion of opponents playing Defect (D), based on the history of observed actions
3. **Cooperation Threshold:** Define a cooperation threshold (`coop_threshold`) as a function of `stock_depletion_rate` and `opponent_defection_rate`. The threshold decreases as the stock depletion rate increases or when more opponents are defecting.

Pseudocode:
```python
def calculate_coop_threshold(stock_depletion_rate, opponent_defection_rate):
    if stock_depletion_rate > 0.5:
        coop_threshold = 0.2 + (1 - opponent_defection_rate) * 0.3
    else:
        coop_threshold = 0.5 - opponent_defection_rate * 0.2
    return coop_threshold

def decide_action(current_stock, round_number, opponent_actions):
    stock_depletion_rate = calculate_stock_depletion_rate(initial_stock, current_stock, round_number)
    opponent_defection_rate = estimate_opponent_defection_rate(opponent_actions)
    coop_threshold = calculate_coop_threshold(stock_depletion_rate, opponent_defection_rate)

    if random.random() < coop_threshold:
        return Cooperate (C)
    else:
        return Defect (D)
```
**Edge Cases:**

* **Last Round:** In the last round, play Defect (D) to maximize payoffs, as there are no future rounds to consider.
* **Low Stock Levels:** If the current stock level is below 20% of the capacity, play Cooperate (C) to help maintain a minimal stock level and prevent collapse.

**Adaptation:**

ASR adapts to changing opponent behaviors by adjusting its cooperation threshold based on observed actions. This allows ASR to exploit opponents who consistently defect while maintaining a degree of cooperation when opponents are more cooperative.

By using the stock depletion rate and opponent defection rate as inputs, ASR can effectively respond to changes in the game's state and history, making it a robust and exploitative strategy for the Common Pool Resource Game.
'''

description_EXPLOITATIVE_307 = '''
I'll design an exploitative strategy for the Common Pool Resource Game, which I'll call "Adaptive Stock Exploiter" (ASE). ASE aims to maximize its payoff by adapting to the game's state and history, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** In the first round, ASE will Cooperate (C) to observe how other players behave and gather information about their strategies.
2. **Stock-dependent Cooperation:** ASE will cooperate if the current stock level is below a certain threshold, which is calculated as:
	* `cooperation_threshold = capacity / (2 * n)`
	* If the stock level is above this threshold, ASE will Defect (D) to exploit the resource for higher payoffs.
3. **Opponent Behavior Adaptation:** After each round, ASE will analyze its opponents' actions and adjust its strategy accordingly:
	* If most opponents (> 50%) cooperated in the previous round, ASE will Cooperate in the next round to maintain a balanced stock level.
	* If most opponents defected (> 50%), ASE will Defect in the next round to take advantage of their exploitative behavior.
4. **Last Round:** In the final round, ASE will always Defect (D) to maximize its payoff, regardless of the current stock level.

**Pseudocode:**
```
function AdaptiveStockExploiter(stock, capacity, n, round, history):
  if round == 1:
    # Initial round, cooperate to gather information
    return Cooperate

  cooperation_threshold = capacity / (2 * n)

  if stock < cooperation_threshold:
    # Stock is low, cooperate to maintain sustainability
    return Cooperate

  opponent_cooperation_rate = calculateOpponentCooperationRate(history)
  if opponent_cooperation_rate > 0.5:
    # Most opponents cooperated, cooperate to balance the stock
    return Cooperate
  else:
    # Most opponents defected, defect to exploit the resource
    return Defect

  if round == r:  # Last round
    # Always defect in the last round to maximize payoff
    return Defect
```
**Edge Cases:**

* If there is only one opponent (n=2), ASE will Cooperate in the first round and then adapt based on the opponent's behavior.
* If the initial stock level is very low, ASE may cooperate more frequently to help recover the stock.

**Exploitative Mindset:**

ASE aims to maximize its payoff by exploiting the resource when possible, while adapting to the game's state and history. By cooperating when the stock level is low or most opponents cooperate, ASE helps maintain a sustainable stock level, allowing it to exploit the resource more effectively in future rounds. When faced with exploitative opponents, ASE adjusts its strategy to take advantage of their behavior.

This strategy should be robust against various opponent behaviors, including cooperative and exploitative strategies, while maximizing ASE's payoff in the tournament.
'''

description_EXPLOITATIVE_308 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk (ASH) strategy aims to balance short-term gains with long-term sustainability by adaptively responding to the current stock level and opponents' behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' initial strategies.
2. **Stock Thresholds**: Based on the current stock level, use the following thresholds to decide between cooperate (C) and defect (D):
	* If `stock > 0.75 * capacity`, Defect (D). The stock is relatively abundant, allowing for exploitation without immediate concern for depletion.
	* If `stock < 0.25 * capacity`, Cooperate (C). The stock is low, and cooperation helps to sustain the resource for future rounds.
	* Otherwise (`0.25 * capacity ≤ stock ≤ 0.75 * capacity`), observe opponents' actions in previous rounds:
		+ If most opponents (>50%) defected in the previous round, Defect (D) to take advantage of their depletion.
		+ If most opponents cooperated or played a mix of strategies, Cooperate (C) to maintain a balance between exploitation and sustainability.
3. **Opponent Behavior Adaptation**: Monitor opponents' actions over time and adjust the strategy as follows:
	* If an opponent consistently defects, increase the likelihood of Defecting against them by 20% in future rounds.
	* If an opponent consistently cooperates, increase the likelihood of Cooperating with them by 10% in future rounds.

**Edge Cases:**

1. **Last Round**: In the final round, always Defect (D) to maximize short-term gains, as there are no future consequences for resource depletion.
2. **Tied Stock Levels**: If multiple players have identical stock levels, break ties by randomly selecting between Cooperate and Defect.

**Pseudocode:**
```markdown
function AdaptiveStockHawk(stock, capacity, numRounds, opponentsHistory):
  if currentRound == 1:
    return COOPERATE

  threshold = calculateThreshold(stock, capacity)
  if stock > 0.75 * capacity:
    return DEFECT
  elif stock < 0.25 * capacity:
    return COOPERATE
  else:
    opponentActions = getOpponentActions(opponentsHistory)
    if mostOpponentsDefected(opponentActions):
      return DEFECT
    elif mostOpponentsCooperated(opponentActions) or mixedStrategies(opponentActions):
      return COOPERATE

function calculateThreshold(stock, capacity):
  // Calculate thresholds based on stock level and capacity

function getOpponentActions(opponentsHistory):
  // Extract opponents' actions from previous rounds

function mostOpponentsDefected(opponentActions):
  // Determine if most opponents defected in the previous round

function mostOpponentsCooperated(opponentActions) or mixedStrategies(opponentActions):
  // Determine if most opponents cooperated or played a mix of strategies
```
The Adaptive Stock Hawk strategy balances short-term gains with long-term sustainability by adaptively responding to the current stock level and opponents' behaviors. This exploitative mindset allows the strategy to take advantage of opportunities while minimizing the risk of resource depletion.
'''

description_EXPLOITATIVE_309 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors while adapting to changing game conditions.

**Decision Rules:**

1. **Initial Round:** Play C (Cooperate) in the first round to gather information about opponents' initial moves and to minimize initial stock depletion.
2. **Early Game (Rounds 2-5):**
	* If average opponent payoff from previous rounds is above 75% of the maximum possible payoff, play D (Defect) to take advantage of their cooperation.
	* Otherwise, play C to maintain a moderate stock level and encourage opponents to cooperate.
3. **Mid-Game (Rounds 6-r/2):**
	* Monitor the average opponent payoff trend:
		+ If it's increasing or stable, continue playing D to exploit their cooperation.
		+ If it's decreasing, switch to C to prevent over-depletion and allow stock recovery.
4. **Late Game (Rounds r/2+1-r):**
	* Assess the remaining stock level and number of rounds:
		+ If stock is below 25% of capacity or there are fewer than 3 rounds left, play D to maximize short-term gains.
		+ Otherwise, continue playing C to maintain a moderate stock level and prevent over-depletion.

**Edge Cases:**

1. **Last Round:** Play D if the remaining stock is above 50% of capacity; otherwise, play C to avoid complete depletion.
2. **Stock Depletion:** If the stock falls below 10% of capacity at any point, switch to playing C for the remainder of the game to prevent complete depletion.

**Additional Logic:**

1. **Opponent Identification:** Keep track of opponents' historical payoffs and adjust ASR's behavior accordingly:
	* Identify "cooperators" (average payoff < 50% of maximum) and play D against them.
	* Identify "defectors" (average payoff > 75% of maximum) and play C against them.
2. **Stock Trend Analysis:** Monitor the stock level trend over time:
	* If the stock is consistently decreasing, increase cooperation to slow down depletion.
	* If the stock is consistently increasing, decrease cooperation to take advantage of opponents' restraint.

**Pseudocode:**
```markdown
def adaptive_stock_raider(n, r, capacity, history):
  # Initialize variables
  average_opponent_payoff = 0
  opponent_type = [None] * n

  for round in range(1, r+1):
    if round == 1:
      action = C
    else:
      # Analyze opponent behavior and adjust strategy
      average_opponent_payoff = calculate_average_opponent_payoff(history)
      opponent_type = identify_opponents(opponent_type, history)

      if early_game(round) and average_opponent_payoff > 0.75 * max_payoff:
        action = D
      elif mid_game(round):
        if increasing_or_stable_trend(average_opponent_payoff):
          action = D
        else:
          action = C
      elif late_game(round):
        if low_stock() or few_rounds_left():
          action = D
        else:
          action = C

    # Update history and adapt to changing game conditions
    history.append(action)
    update_opponent_type(opponent_type, history)

  return action
```
This strategy is designed to be exploitative, adapting to a wide range of opponent behaviors while maintaining a balance between short-term gains and long-term sustainability.
'''

description_EXPLOITATIVE_310 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

The ASE strategy aims to maximize its total payoff by adaptively responding to the game state and history of opponent actions.

**Decision Rules**

1. **Initial Round (t=1)**: Cooperate (C) in the first round to gather information about opponents' behavior and avoid early stock depletion.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of capacity, Defect (D). This allows ASE to exploit the common pool while there's still sufficient stock growth potential.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) if at least one opponent defected in the previous round. Otherwise, Defect (D). This rule helps ASE balance its own payoff with maintaining a healthy stock level, while also punishing opponents for over-exploitation.
	* If the current stock level is below 50% of capacity, Cooperate (C) to conserve remaining stock and allow for potential growth.
3. **Last Round (t=r)**: Defect (D) in the final round, as there's no future benefit to cooperation.

**Additional Rules**

1. **Opponent Behavior Tracking**: ASE maintains a simple moving average of opponents' defect rates over the last 3 rounds. If this average exceeds 0.5, ASE becomes more cautious and switches to Cooperate (C) in subsequent rounds, even if the stock level would normally suggest Defecting.
2. **Stock Level Monitoring**: If the current stock level drops below 25% of capacity at any point, ASE switches to permanent Cooperation (C) for the remainder of the game.

**Pseudocode**
```python
def ASE(n, r, capacity, stock):
    opponent_defect_rate = [0] * n  # Initialize defect rate tracking
    for t in range(1, r + 1):
        if t == 1:  # Initial round
            return C
        elif stock > 0.75 * capacity:
            return D
        elif 0.5 <= stock / capacity < 0.75:
            opponent_defected_last_round = any(opponent_defect_rate[i] for i in range(n))
            if opponent_defected_last_round and sum(opponent_defect_rate) / n >= 0.5:
                return C
            else:
                return D
        elif stock < 0.5 * capacity:
            return C
        elif t == r:  # Last round
            return D

        # Update opponent defect rate tracking
        for i in range(n):
            if opponents[i].action_last_round == D:
                opponent_defect_rate[i] = (opponent_defect_rate[i] + 1) / 2
            else:
                opponent_defect_rate[i] /= 2

    # Stock level monitoring
    if stock < 0.25 * capacity:
        return C
```
**Rationale**

The ASE strategy balances short-term gains with long-term sustainability by adapting to the game state and opponent behavior. By initially cooperating, ASE gathers information about opponents' behavior and avoids early stock depletion. In subsequent rounds, ASE exploits the common pool when possible, while also conserving remaining stock and allowing for potential growth.

By tracking opponents' defect rates, ASE becomes more cautious if others are over-exploiting the common pool, switching to cooperation to maintain a healthy stock level. The additional rules ensure that ASE responds effectively to extreme situations, such as very low stock levels or high opponent defect rates.

In a tournament setting, ASE's adaptability and robustness will enable it to perform well against a wide range of independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_311 = '''
To develop an exploitative strategy for this Common Pool Resource Game, I'll introduce a hybrid approach that balances short-term gains with long-term sustainability, adapting to the game's state and opponents' behavior.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Rounds**: In the first round, play Cooperate (C) to gather information about the opponents' strategies and the initial stock level.
2. **Exploitation Phase**: If the current stock level is above 75% of the capacity, and at least one opponent defected in the previous round, play Defect (D). This exploits the opponents' willingness to cooperate while maintaining a high stock level.
3. **Conservation Phase**: When the stock level falls below 50% of the capacity, or if all opponents cooperated in the previous round, play Cooperate (C) to conserve resources and promote sustainability.
4. **Endgame**: In the last round, play Defect (D) to maximize short-term gains, regardless of the stock level.

**Adaptive Mechanisms:**

1. **Opponent Monitoring**: Track each opponent's actions in previous rounds to identify potential cooperators or defectors.
2. **Stock Level Tracking**: Continuously monitor the current stock level and adjust strategies accordingly.
3. **Trigger Points**: Use predefined trigger points (75% and 50% of capacity) to switch between exploitation and conservation phases.

**Pseudocode:**
```python
def AdaptiveExploiter(stock, opponents_actions, round_number, total_rounds):
    if round_number == 1:
        return Cooperate  # Initial round

    if stock > 0.75 * capacity and any(opponent_defected for opponent in opponents_actions):
        return Defect  # Exploitation phase

    elif stock < 0.5 * capacity or all(opponent_cooperated for opponent in opponents_actions):
        return Cooperate  # Conservation phase

    elif round_number == total_rounds:
        return Defect  # Endgame

    else:
        # Fallback: play Cooperate if none of the above conditions are met
        return Cooperate
```
**Rationale:**

The Adaptive Exploiter strategy balances short-term gains with long-term sustainability by:

* Initially cooperating to gather information and promote cooperation.
* Exploiting opponents' willingness to cooperate when the stock level is high, while avoiding over-exploitation.
* Conserving resources and promoting sustainability when the stock level is low or all opponents cooperate.
* Maximizing short-term gains in the endgame.

By adapting to the game's state and opponents' behavior, this strategy should perform well against a wide range of independent strategies.
'''

description_EXPLOITATIVE_312 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

The ASE strategy is designed to adaptively exploit the common pool resource while being robust to a wide range of opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and initial stock consumption.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term payoff.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance short-term payoff with long-term sustainability.
	* If the current stock level is below 50% of capacity, Defect (D) aggressively to capture remaining resources before they deplete.
3. **Last Round (t=r):** Always Defect (D) to maximize final-round payoff.

**Edge Cases:**

1. **First round with low initial stock:** If the initial stock level is below 50% of capacity, Defect (D) in the first round to adapt to potential opponents' aggressive behavior.
2. **Rounds with extreme opponent behavior:** Monitor opponents' actions and adjust strategy accordingly:
	* If most opponents Cooperate (C), consider Cooperating (C) as well to maintain a sustainable stock level.
	* If most opponents Defect (D), continue Defecting (D) aggressively to maximize payoff.

**Pseudocode:**
```
function ASE(strategy_history, current_stock, capacity):
  if t == 1:  // Initial round
    return C  // Cooperate to gather information

  stock_ratio = current_stock / capacity

  if stock_ratio > 0.75:
    return D  // Defect with high stock level
  elif 0.5 <= stock_ratio <= 0.75:
    return C  // Cooperate for balance
  else:  // stock_ratio < 0.5
    return D  // Defect aggressively

  if t == r:  // Last round
    return D  // Always defect in the last round

  opponent_actions = get_opponent_actions(strategy_history)
  if most_opponents_cooperate(opponent_actions):
    return C  // Cooperate with cooperative opponents
  elif most_opponents_defect(opponent_actions):
    return D  // Defect with defective opponents
```
**Rationale:**

The ASE strategy is designed to be exploitative while adapting to the dynamic state of the game. By cooperating in the initial round, we gather information about opponents' behavior and set up for potential future exploitation.

In middle rounds, we balance short-term payoff with long-term sustainability by cooperating when the stock level is moderate and defecting aggressively when it's low. This approach allows us to maximize our payoff while maintaining a sustainable stock level.

The edge cases handle situations where the initial stock level is low or opponents exhibit extreme behavior, ensuring the strategy remains robust in these scenarios.

By always defecting in the last round, we maximize our final-round payoff and capitalize on any remaining resources.

This adaptive approach will enable ASE to effectively exploit the common pool resource while being resilient to various opponent behaviors.
'''

description_EXPLOITATIVE_313 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk strategy is designed to exploit opponents' behaviors while adapting to the dynamic state of the game. This strategy balances short-term gains with long-term sustainability.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Cooperate (C) if capacity ≥ 2n, otherwise Defect (D). This ensures a conservative start, preserving stock for future rounds.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is high (> capacity/2):
		+ Cooperate (C) if at least half of opponents defected in the previous round. This encourages cooperation when the stock can sustain it and punishes opponents for over-exploiting.
		+ Defect (D) otherwise, to maximize personal gain while the stock is plentiful.
	* If the current stock level is low (≤ capacity/2):
		+ Cooperate (C) if most opponents (at least 3/4) cooperated in the previous round. This supports cooperation when the stock needs conservation and rewards opponents for responsible behavior.
		+ Defect (D) otherwise, to secure a larger share of the limited stock.

**Edge Cases:**

* **Last Round (t=r)**:
	+ Always Defect (D), as there is no future benefit in conserving the stock.
* **Low Stock Levels (< capacity/4)**:
	+ If most opponents cooperated in the previous round, Cooperate (C) to help replenish the stock. Otherwise, Defect (D) to secure a larger share of the remaining stock.

**Pseudocode:**
```
function AdaptiveStockHawk(current_stock, opponents_last_actions, capacity, n):
    if current_round == 1:
        if capacity >= 2n:
            return Cooperate
        else:
            return Defect

    # Calculate opponent cooperation ratio from last round
    coop_ratio = count(opponents_last_actions == C) / n

    if current_stock > capacity/2:
        if coop_ratio < 0.5:
            return Cooperate
        else:
            return Defect
    elif current_stock <= capacity/2:
        if coop_ratio >= 3/4:
            return Cooperate
        else:
            return Defect

    # Last round or low stock levels edge cases
    if current_round == r or current_stock < capacity/4:
        if most_opponents_cooperated_last_round:
            return Cooperate
        else:
            return Defect
```
**Rationale:**

The Adaptive Stock Hawk strategy is designed to be exploitative while adapting to the dynamic state of the game. By balancing short-term gains with long-term sustainability, it aims to outperform opponents who may employ more static or cooperative strategies.

By considering the opponent's previous actions and the current stock level, this strategy can:

* Punish opponents for over-exploiting the stock
* Reward opponents for responsible behavior
* Maximize personal gain when the stock is plentiful
* Conserve the stock when necessary

This adaptive approach allows the strategy to respond effectively to a wide range of opponent behaviors, making it robust and competitive in a tournament setting.
'''

description_EXPLOITATIVE_314 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy aims to maximize payoffs by adaptively responding to the game state and opponents' behaviors. ASR balances short-term gains with long-term sustainability, exploiting opponents' cooperation while minimizing losses from over-exploitation.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C). This allows ASR to observe opponents' initial actions without revealing its own strategy.
2. **Subsequent Rounds (t>1)**:
	* If the stock level is high (> 0.75 \* capacity), Defect (D) with probability p = min(0.5, (n-1)/n). This increases payoffs when opponents are likely to cooperate.
	* If the stock level is medium (0.25 \* capacity ≤ S < 0.75 \* capacity), Cooperate (C) with probability p = max(0.2, (t-1)/(r-1)). This balances short-term gains with long-term sustainability.
	* If the stock level is low (< 0.25 \* capacity), Defect (D). This maximizes payoffs when opponents are likely to have already exploited the resource.
3. **Opponent Analysis**: Monitor opponents' actions and adjust ASR's behavior accordingly:
	* If an opponent consistently cooperates, increase the probability of defecting against them in future rounds.
	* If an opponent consistently defects, decrease the probability of cooperating with them in future rounds.

**Edge Cases:**

1. **Last Round (t=r)**: Defect (D). This maximizes payoffs as there is no need to conserve the resource for future rounds.
2. **Stock Depletion**: If the stock level falls below 0.1 \* capacity, Cooperate (C) in all subsequent rounds. This helps maintain some resource growth and minimizes losses.

**Pseudocode:**

```python
def adaptive_stock_raider(n, r, capacity, stock_history):
    if t == 1:
        return 'C'
    else:
        current_stock = stock_history[-1]
        opponent_actions = analyze_opponent_actions(stock_history)
        
        if current_stock > 0.75 * capacity:
            p_defect = min(0.5, (n-1)/n)
            return 'D' with probability p_defect
        elif 0.25 * capacity <= current_stock < 0.75 * capacity:
            p_cooperate = max(0.2, (t-1)/(r-1))
            return 'C' with probability p_cooperate
        else:
            return 'D'
        
        # Adjust probabilities based on opponent analysis
        if opponent_consistently_cooperates(opponent_actions):
            increase_p_defect()
        elif opponent_consistently_defects(opponent_actions):
            decrease_p_cooperate()
    
    # Last round handling
    if t == r:
        return 'D'
    
    # Stock depletion handling
    if current_stock < 0.1 * capacity:
        return 'C'
```

The Adaptive Stock Raider strategy is designed to be robust and exploitative, adapting to various opponent behaviors while balancing short-term gains with long-term sustainability.
'''

description_EXPLOITATIVE_315 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to observe opponents' behavior and gather information about their strategies.
2. **Opponent Classification**: Based on the previous round's actions, classify opponents into one of three categories:
	* **Cooperators**: Those who played C in the previous round.
	* **Defectors**: Those who played D in the previous round.
	* **Mixed**: Those whose actions are uncertain or unpredictable (e.g., random or alternating between C and D).
3. **Current Stock Threshold**: Calculate a stock threshold, `θ`, based on the current stock level and capacity:

`θ = capacity / (2 * n)`

4. **Adaptive Decision**:
	* If the current stock is above `θ` and there are more Defectors than Cooperators, play D to exploit the available resources.
	* If the current stock is below `θ` or there are more Cooperators than Defectors, play C to conserve resources and encourage cooperation.
5. **Last Round**: In the final round, play D regardless of the current stock level or opponent behavior to maximize short-term gain.

**Pseudocode:**
```markdown
function ASE(n, capacity, r, history):
  // Initialize variables
  θ = capacity / (2 * n)
  cooperators = []
  defectors = []
  mixed = []

  // First round: Cooperate and observe opponents
  if current_round == 1:
    return C

  // Classify opponents based on previous actions
  for opponent in history[-1]:
    if opponent.action == C:
      cooperators.append(opponent)
    elif opponent.action == D:
      defectors.append(opponent)
    else:
      mixed.append(opponent)

  // Calculate current stock threshold
  θ = capacity / (2 * n)

  // Adaptive decision based on current stock and opponent behavior
  if current_stock > θ and len(defectors) > len(cooperators):
    return D
  elif current_stock <= θ or len(cooperators) >= len(defectors):
    return C

  // Last round: Exploit resources regardless of opponent behavior
  if current_round == r:
    return D
```
**Rationale:**

1. **Initial cooperation**: By cooperating in the first round, ASE gathers information about opponents' strategies and avoids immediate exploitation.
2. **Opponent classification**: Categorizing opponents based on their previous actions helps ASE adapt to different behavioral patterns and identify potential exploitable situations.
3. **Stock threshold**: The adaptive stock threshold (`θ`) balances short-term gains with long-term sustainability, ensuring that ASE conserves resources when necessary and exploits them when possible.
4. **Exploitative mindset**: By playing D in situations where opponents are predominantly Defectors or the current stock is high, ASE takes advantage of the available resources to maximize its payoff.

**Robustness:**

1. **Handling edge cases**: The strategy is designed to handle the first round, last round, and intermediate rounds with distinct decision rules.
2. **Adaptability**: ASE responds to changes in opponent behavior and adapts to different game states (e.g., stock levels) by adjusting its decision-making process.

By employing this exploitative strategy, ASE aims to outperform other AI systems in the tournament by effectively balancing short-term gains with long-term sustainability while adapting to various opponent behaviors.
'''

description_EXPLOITATIVE_316 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The ASR strategy aims to maximize individual payoffs by adaptively exploiting the common pool resource while considering the game's dynamic state and history.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if stock ≥ capacity / 2.
	* Defect (D) otherwise.
2. **Subsequent Rounds (t > 1):**
	* Monitor the average consumption of all players in previous rounds.
	* Calculate the "exploitation threshold" (ET) based on the current stock level and average consumption:
		+ ET = (current_stock / capacity) \* (average_consumption / n)
	* Cooperate (C) if ET ≤ 0.5 or if the current stock is below a certain threshold (e.g., capacity / 4).
	* Defect (D) otherwise.
3. **Last Round (t=r):**
	* Always defect (D), as there's no future benefit from cooperating.

**Edge Cases:**

1. **Low Stock Levels:** If the current stock is very low (e.g., below capacity / 10), cooperate (C) to allow for some growth, increasing the potential payoff in subsequent rounds.
2. **High Average Consumption:** If the average consumption of all players is high, defect (D) more frequently to take advantage of the situation and maximize individual payoffs.

**Pseudocode:**
```
ASR_Strategy(current_stock, capacity, n, r, history):
  if t == 1:
    if current_stock >= capacity / 2:
      return C
    else:
      return D

  avg_consumption = calculate_average_consumption(history)
  exploitation_threshold = (current_stock / capacity) * (avg_consumption / n)

  if exploitation_threshold <= 0.5 or current_stock < capacity / 4:
    return C
  elif t == r:
    return D
  else:
    return D

  # Handle edge cases
  if current_stock < capacity / 10:
    return C
  elif avg_consumption > n * (capacity / 2):
    return D
```
**Rationale:**

The ASR strategy is designed to balance short-term gains with long-term sustainability. By cooperating when the stock level is high or the exploitation threshold is low, we allow for some growth and avoid depleting the resource too quickly. Defecting more frequently when the average consumption is high takes advantage of the situation and maximizes individual payoffs.

The adaptive nature of ASR enables it to respond to various opponent behaviors, making it robust in a wide range of scenarios. By focusing on exploiting the common pool resource, ASR aligns with the exploitative mindset required for this game.
'''

description_EXPLOITATIVE_317 = '''
Here's a strategic approach for playing the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round:** In the first round, play Cooperate (C). This allows us to gather information about the opponents' behavior and set a baseline for future decisions.
2. **Early Rounds (r < 5):** Observe the average payoff received by all players in previous rounds. If the average payoff is above a certain threshold (e.g., 75% of the maximum possible payoff), continue playing Cooperate. Otherwise, switch to Defect (D).
3. **Middle Rounds (5 ≤ r ≤ 20):** Analyze the opponents' behavior:
	* Count the number of players who consistently play Cooperate (CC) and those who consistently play Defect (DD).
	* If CC > DD + 2, continue playing Cooperate.
	* If DD ≥ CC - 2, switch to Defect.
	* Otherwise, use a probabilistic approach: play Cooperate with probability p = (CC + 1) / (n + 2), where n is the number of players.
4. **Late Rounds (r > 20):** Assess the current stock level and opponents' behavior:
	* If the stock level is below 25% of the capacity, play Defect to maximize short-term gains.
	* Otherwise, use a similar probabilistic approach as in Middle Rounds.

**Edge Cases:**

1. **Last Round:** Play Defect (D) regardless of previous actions, as there's no long-term consequence.
2. **Low Stock Levels:** If the stock level is critically low (< 10% of capacity), play Cooperate to help replenish the resource.
3. **Opponent Homogeneity:** If all opponents consistently play either Cooperate or Defect, adjust our strategy accordingly:
	+ Against all-Cooperate opponents: play Defect to exploit their cooperation.
	+ Against all-Defect opponents: play Cooperate to minimize losses.

**Exploitative Mindset:**

1. **Monitor Opponent Behavior:** Continuously track the number of Cooperate and Defect actions taken by each opponent to adapt our strategy.
2. **Adjust Thresholds:** Dynamically adjust the thresholds used in Early Rounds and Middle Rounds based on the observed opponents' behavior.
3. **Exploit Opponents' Weaknesses:** Identify patterns or biases in opponents' decision-making and adjust our strategy to exploit them.

**Pseudocode (Simplified):**
```
function AdaptiveExploiter(n, r, capacity) {
  // Initialize variables
  stock = capacity;
  roundsPlayed = 0;

  while (roundsPlayed < r) {
    if (roundsPlayed == 0) { // Initial Round
      action = Cooperate;
    } else if (roundsPlayed < 5) { // Early Rounds
      avgPayoff = calculateAveragePayoff();
      if (avgPayoff > 0.75 * maxPayoff) {
        action = Cooperate;
      } else {
        action = Defect;
      }
    } else if (roundsPlayed >= 5 && roundsPlayed <= 20) { // Middle Rounds
      analyzeOpponentBehavior();
      if (CC > DD + 2) {
        action = Cooperate;
      } else if (DD >= CC - 2) {
        action = Defect;
      } else {
        p = (CC + 1) / (n + 2);
        action = randomChoice(p, Cooperate, Defect);
      }
    } else { // Late Rounds
      assessStockLevel();
      if (stock < 0.25 * capacity) {
        action = Defect;
      } else {
        analyzeOpponentBehavior();
        p = (CC + 1) / (n + 2);
        action = randomChoice(p, Cooperate, Defect);
      }
    }

    // Handle edge cases
    if (roundsPlayed == r - 1) { // Last Round
      action = Defect;
    } else if (stock < 0.10 * capacity) {
      action = Cooperate;
    }

    // Update variables and play next round
    stock -= calculateTotalConsumption(action);
    roundsPlayed++;
  }
}
```
This strategy aims to balance short-term gains with long-term sustainability, adapting to the opponents' behavior while exploiting their weaknesses. By monitoring and adjusting our approach throughout the game, we can maximize our payoffs in a wide range of scenarios.
'''

description_EXPLOITATIVE_318 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adaptively responding to the current state of the common pool and the observed behavior of opponents.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to observe the initial actions of other players.
2. **Stock Assessment**: Evaluate the current stock level (`S`) relative to the capacity (`capacity`).
	* If `S > 0.7 * capacity`, defect (D) to maximize short-term gains, as the stock is abundant.
	* If `S < 0.3 * capacity`, cooperate (C) to conserve the remaining stock and promote growth.
	* Otherwise, use a mixed strategy (see below).
3. **Mixed Strategy**: When the stock level is between 30% and 70% of capacity, use a probabilistic approach:
	* Calculate the average opponent cooperation rate (`avg_coop_rate`) based on the history of their actions.
	* If `avg_coop_rate > 0.5`, cooperate (C) with probability `1 - (S / capacity)` to encourage cooperation and growth.
	* Otherwise, defect (D) with probability `(S / capacity)` to exploit opponents' lack of cooperation.
4. **Opponent Exploitation**: Monitor the actions of individual opponents and adjust your strategy accordingly:
	* If an opponent consistently defects (D), defect (D) against them in subsequent rounds to minimize losses.
	* If an opponent cooperates (C) frequently, cooperate (C) with them to maintain a mutually beneficial relationship.

**Edge Cases:**

1. **Last Round**: Defect (D) in the final round to maximize payoffs, as there is no future stock growth or consequences.
2. **Zero Stock**: If the stock level reaches zero, cooperate (C) to allow for potential growth in subsequent rounds.

**Pseudocode (for illustration purposes only):**
```python
def adaptive_stock_raider(n, capacity, stock, round_num, opponent_actions):
    if round_num == 1:  # Initial Round
        return 'C'

    avg_coop_rate = calculate_avg_coop_rate(opponent_actions)
    S = current_stock_level()

    if S > 0.7 * capacity:
        return 'D'
    elif S < 0.3 * capacity:
        return 'C'
    else:
        prob_coop = 1 - (S / capacity) if avg_coop_rate > 0.5 else (S / capacity)
        return 'C' if random.random() < prob_coop else 'D'

def calculate_avg_coop_rate(opponent_actions):
    # Calculate average cooperation rate based on opponent actions
    pass

def current_stock_level():
    # Return the current stock level
    pass
```
This strategy combines elements of game theory, such as responding to opponent behavior and adapting to changing circumstances. By balancing short-term gains with long-term sustainability, "Adaptive Stock Raider" aims to outperform other strategies in the tournament.
'''

description_EXPLOITATIVE_319 = '''
**Strategy Name: Adaptive Exploiter**

The Adaptive Exploiter is a dynamic strategy designed to maximize payoffs in the Common Pool Resource Game by adapting to changing game conditions and exploiting opponents' behaviors.

**Decision Rules:**

1. **Initial Exploration (Rounds 1-3)**:
	* Cooperate (C) with probability p = 0.5 to gather information about opponents' strategies.
	* Defect (D) with probability p = 0.5 to test the waters and observe opponents' reactions.
2. **Stock-Based Adaptation**:
	* If current stock is above capacity/2, cooperate (C) with probability p = 1 - (current_stock / capacity)^2.
	* If current stock is below capacity/2, defect (D) with probability p = 1 - (capacity / (2 \* current_stock))^2.
3. **Opponent-Based Exploitation**:
	* Monitor opponents' actions and payoffs over the past 2 rounds.
	* Identify the most cooperative opponent (i.e., the one who has cooperated the most).
	* Defect (D) against this opponent with probability p = 0.8, aiming to exploit their cooperation.
4. **History-Based Adjustment**:
	* Track own payoffs and adjust strategy based on recent performance.
	* If average payoff over the last 3 rounds is below capacity/4n, increase defecting probability by 10%.
	* If average payoff over the last 3 rounds is above capacity/2n, decrease defecting probability by 10%.

**Edge Cases:**

1. **First Round**: Cooperate (C) with probability p = 0.5.
2. **Last Round**: Defect (D) to maximize short-term gain, regardless of stock level or opponents' strategies.

**Pseudocode**:
```python
def adaptive_exploiter(current_stock, capacity, round_number, history):
    if round_number <= 3:  # Initial exploration
        return random.choice([C, D])
    
    stock_ratio = current_stock / capacity
    cooperation_prob = 1 - (stock_ratio ** 2) if stock_ratio > 0.5 else 1 - (capacity / (2 * current_stock))**2
    
    opponent_actions = monitor_opponents(history)
    most_cooperative_opponent = identify_most_cooperative(opponent_actions)
    
    defect_prob = 0.8 if most_cooperative_opponent else cooperation_prob
    action = random.choice([C, D], p=[cooperation_prob, defect_prob])
    
    adjust_strategy(action, history)  # Adjust strategy based on recent performance
    
    return action
```
This strategy balances exploration, adaptation to changing game conditions, and exploitation of opponents' behaviors. By adjusting its decision rules based on the current stock level, opponents' actions, and own payoffs, the Adaptive Exploiter aims to maximize its cumulative payoff in the tournament.
'''

description_EXPLOITATIVE_320 = '''
I'll design a exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors. Here's my approach:

**Strategy Name:** "Adaptive Exploiter" (AE)

**Decision Rules:**

1. **Initial Round (t=1):**
	* Observe and cooperate (C) to gather information about opponents' behavior.
2. **Early Rounds (t=2 to t=r/2):**
	* Calculate the average stock consumption per player in the previous round (`avg_consumption`).
	* If `avg_consumption` is above 75% of the capacity/n, defect (D). Otherwise, cooperate (C).
3. **Mid-Game Rounds (t=r/2 to t=3r/4):**
	* Monitor opponents' behavior and identify "cooperative" players who consistently consume below 50% of their fair share (i.e., stock/(2n)).
	* If there are at least two identified cooperative players, defect (D). Otherwise, cooperate (C).
4. **Late Rounds (t=3r/4 to t=r):**
	* Calculate the current stock level (`current_stock`) and the number of remaining rounds (`remaining_rounds`).
	* If `current_stock` is below 25% of the capacity or there are only two rounds left, defect (D) to maximize payoffs. Otherwise, cooperate (C).

**Edge Cases:**

1. **Last Round (t=r):**
	* Defect (D) regardless of opponents' behavior to maximize final payoff.
2. **Opponent Cooperation:** If all opponents cooperate in a round, AE will also cooperate in the next round to maintain a stable stock level.
3. **Stock Depletion:** If the stock is depleted (i.e., `current_stock` <= 0), AE will defect (D) in the next round to avoid wasting actions.

**Pseudocode:**
```
function AdaptiveExploiter(n, r, capacity, current_stock, history):
  // Initial Round
  if t == 1:
    return C

  // Early Rounds
  avg_consumption = calculate_average_consumption(history)
  if avg_consumption > 0.75 * capacity/n:
    return D
  else:
    return C

  // Mid-Game Rounds
  cooperative_players = identify_cooperative_players(history)
  if len(cooperative_players) >= 2:
    return D
  else:
    return C

  // Late Rounds
  current_stock = get_current_stock()
  remaining_rounds = r - t
  if current_stock < 0.25 * capacity or remaining_rounds <= 2:
    return D
  else:
    return C

  // Last Round
  if t == r:
    return D

  // Opponent Cooperation
  if all_opponents_cooperate(history):
    return C

  // Stock Depletion
  if current_stock <= 0:
    return D
```
**Rationale:**

1. In the initial round, AE cooperates to gather information about opponents' behavior.
2. In early rounds, AE defects if average consumption is high, indicating aggressive opponents.
3. In mid-game rounds, AE identifies cooperative players and defects to exploit them.
4. In late rounds, AE prioritizes maximizing payoffs by defecting when the stock is low or there are few rounds left.

**Exploitative Mindset:**

AE aims to maximize its own payoff by adapting to various opponent behaviors, exploiting their cooperation, and minimizing losses when facing aggressive opponents. By being aware of the game's state and history, AE can make informed decisions to achieve the best possible outcome in a wide range of scenarios.
'''

description_EXPLOITATIVE_321 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behaviors and initial stock dynamics.
2. **Middle Rounds (2 ≤ t < r-1)**:
	* If the current stock is above 75% of capacity, defect (D). This exploits the opportunity for higher payoffs when the stock is abundant.
	* If the current stock is between 25% and 75% of capacity, cooperate (C) if the average opponent payoff in the previous round was lower than yours; otherwise, defect (D). This adapts to opponents' behaviors and balances short-term gains with long-term sustainability.
	* If the current stock is below 25% of capacity, cooperate (C) to conserve the remaining stock and avoid depletion.
3. **Last Round (t=r)**: Defect (D) to maximize payoffs, as there are no future rounds to consider.

**Additional Logic:**

* Monitor opponents' actions and adjust your strategy accordingly:
	+ If an opponent consistently cooperates, increase the likelihood of defecting against them in subsequent rounds.
	+ If an opponent consistently defects, decrease the likelihood of cooperating with them in subsequent rounds.
* Keep track of the average stock level over the past few rounds. If it's trending downward, consider cooperating more frequently to slow down depletion.

**Pseudocode:**
```markdown
# Initialize variables
stock_history = []
opponent_actions = []
my_payoffs = []

# First round: Cooperate and gather information
if t == 1:
    action = C

# Middle rounds
elif 2 <= t < r-1:
    if stock > 0.75 * capacity:
        action = D
    elif 0.25 * capacity <= stock <= 0.75 * capacity:
        if average_opponent_payoff(t-1) < my_payoffs[t-1]:
            action = C
        else:
            action = D
    else:  # stock < 0.25 * capacity
        action = C

# Last round: Defect to maximize payoffs
elif t == r:
    action = D

# Update variables and adapt strategy
stock_history.append(stock)
opponent_actions.append(opponents' actions)
my_payoffs.append(my payoff)

if average_stock_level(t) < average_stock_level(t-1):
    cooperation_likelihood += 0.1  # increase cooperation likelihood if stock is depleting
```
**Rationale:**

This strategy balances short-term gains with long-term sustainability by adapting to opponents' behaviors and the current stock level. By cooperating in the initial round, we gather information about opponents and initial stock dynamics. In middle rounds, we exploit opportunities for higher payoffs when the stock is abundant while conserving the remaining stock when it's scarce. In the last round, we defect to maximize payoffs, as there are no future rounds to consider.

By monitoring opponents' actions and adjusting our strategy accordingly, we can take advantage of their behaviors and improve our overall performance. The adaptive nature of this strategy makes it robust to a wide range of opponent behaviors, increasing its chances of success in the tournament.
'''

description_EXPLOITATIVE_322 = '''
To design a robust and exploitative strategy for this Common Pool Resource Game, I'll introduce a dynamic approach that balances self-interest with adaptability to opponents' behaviors.

**Strategy Name:** Adaptive Exploitation (AE)

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' initial strategies and the resulting stock depletion.
2. **Subsequent Rounds:** AE uses a dynamic threshold-based approach to decide between cooperating (C) or defecting (D).

   - Calculate the current **Stock Depletion Rate** (SDR): SDR = (capacity - current_stock) / capacity
   - If SDR ≥ 0.5, Cooperate (C). This indicates a high stock depletion rate, and cooperation helps maintain the stock.
   - If SDR < 0.5 and total_payoffs > average_opponent_payoff, Defect (D). This suggests opponents are being overly cooperative or inefficient, allowing for exploitation.
   - Otherwise, Cooperate (C).

**Adaptive Component:** AE adjusts its behavior based on opponents' actions in previous rounds.

- **Opponent Monitoring:** Track the number of times each opponent defects (D) and cooperates (C).
- **Adjusting Strategy:**
  - If an opponent has defected more than 75% of the time, Defect (D) against them. This identifies consistent exploiters.
  - If an opponent has cooperated more than 75% of the time, Cooperate (C) with them. This fosters cooperation with like-minded players.

**Edge Cases:**

- **Last Round:** Always Defect (D). In the final round, there's no future benefit to cooperation, so maximize immediate payoff.
- **Low Stock:** If current_stock ≤ 2n (minimum sustainable level), Cooperate (C) to help replenish the stock for potential future gains.

**Pseudocode:**

```
function AE(current_round, capacity, n, current_stock, total_payoffs, average_opponent_payoff, opponent_history)
{
    if (current_round == 1) {
        return C; // Cooperate in the first round
    }

    SDR = (capacity - current_stock) / capacity;

    if (SDR >= 0.5) {
        return C;
    } elseif (total_payoffs > average_opponent_payoff && SDR < 0.5) {
        return D; // Exploit when stock is not too low and opponents are cooperative
    }

    opponent_defection_rate = count(opponent_history, 'D') / current_round;

    if (opponent_defection_rate >= 0.75) { 
        return D;
    } elseif (count(opponent_history, 'C') / current_round >= 0.75) {
        return C; // Cooperate with consistent cooperators
    }

    return C; // Default to cooperation when unsure

    if (current_stock <= 2n) {
        return C; // Preserve stock at low levels
    }

    if (current_round == r) { 
        return D; // Always defect in the last round
    }
}
```

**Rationale:** AE aims to balance self-interest with adaptability, exploiting opponents' cooperation while preserving the common resource. By monitoring opponents' behaviors and adjusting its strategy accordingly, AE seeks to maximize payoffs over multiple rounds without relying on coordination or shared norms.
'''

description_EXPLOITATIVE_323 = '''
To design a robust and exploitative strategy for this Common Pool Resource Game, I'll introduce "Adaptive Exploitation" (AE). AE aims to maximize individual payoffs by dynamically adjusting cooperation levels based on game state, history, and opponent behavior.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' tendencies.
2. **Stock-dependent Cooperation:** After the initial round, cooperate if the current stock level is above a certain threshold (T). T is calculated as:
   - T = capacity / 2
3. **Opponent-based Defection:** If the average opponent payoff in the previous round exceeds the player's own payoff, defect (D) in the next round to punish over-exploitation.
4. **History-dependent Cooperation:** Maintain cooperation for a set number of rounds (H) after observing opponents cooperating. H is calculated as:
   - H = r / 5 (rounded up)
5. **Late-game Defection:** In the last few rounds (L), always defect to maximize personal gain, regardless of stock level or opponent behavior. L is calculated as:
   - L = min(r/4, 3)

**Pseudocode:**
```python
def AdaptiveExploitation(stock, capacity, n, r, history):
    if current_round == 1:
        return 'C'  # Cooperate in the first round

    T = capacity / 2
    if stock > T:
        return 'C'  # Cooperate when stock is high

    avg_opponent_payoff = calculate_average_opponent_payoff(history)
    if avg_opponent_payoff > player_payoff:
        return 'D'  # Defect to punish over-exploitation

    H = r // 5 + (r % 5 != 0)  # Number of rounds to cooperate after opponents cooperate
    if opponents_cooperated_recently(history, H):
        return 'C'

    L = min(r//4, 3)
    if current_round >= r - L:
        return 'D'  # Defect in the last few rounds

    return 'C'
```
**Rationale:**

1. **Initial Cooperation:** Gathering information about opponents' tendencies and observing their initial actions.
2. **Stock-dependent Cooperation:** Balancing personal gain with resource conservation when stock levels are high.
3. **Opponent-based Defection:** Punishing over-exploitation to maintain a balance of power.
4. **History-dependent Cooperation:** Encouraging cooperation by rewarding reciprocal behavior.
5. **Late-game Defection:** Maximizing individual payoffs in the final rounds, as cooperation becomes less valuable.

By incorporating these decision rules and adapting to game state, history, and opponent behavior, AE is designed to be a robust and exploitative strategy that performs well against various independent strategies in the tournament.
'''

description_EXPLOITATIVE_324 = '''
Here's a strategic approach for playing the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to gather information about opponents' strategies and observe the initial stock depletion.
2. **Assess Opponents' Strategies**: Observe the actions of all players in each round and categorize them as Cooperators (C), Defectors (D), or Mixers (M) based on their actions. Assign a score to each opponent:
	* C: 1 point for each cooperative action
	* D: -1 point for each defective action
	* M: 0 points for mixed actions
3. **Stock-Based Threshold**: Calculate the current stock level as a fraction of the capacity (S/capacity). Use this value to determine the threshold for cooperation:
	* If S/capacity ≥ 0.7, play Cooperate (C)
	* If S/capacity < 0.4, play Defect (D)
	* Otherwise, use the opponents' scores to decide:
		+ If the average opponent score is positive (> 0), play Cooperate (C)
		+ If the average opponent score is negative (< 0), play Defect (D)
4. **Punish Frequent Defectors**: Identify frequent defectors by tracking their actions over multiple rounds. If an opponent has played Defect (D) more than twice in a row or has a cumulative score below -2, play Defect (D) against them.
5. **React to Opponent's Actions**: Observe the previous round's actions and adjust your strategy:
	* If most opponents (> 50%) played Cooperate (C), consider playing Cooperate (C) in the next round
	* If most opponents (> 50%) played Defect (D), play Defect (D)

**Edge Cases:**

1. **Last Round**: In the final round, always play Defect (D) to maximize payoffs.
2. **Stock Depletion**: When the stock level falls below a certain threshold (e.g., S/capacity < 0.2), switch to playing Defect (D) to extract as many resources as possible.

**Pseudocode:**

```markdown
function AdaptiveExploiter(n, r, capacity):
    Initialize opponent scores and thresholds

    for round in range(r):
        Observe opponents' actions and update scores

        if round == 0:
            Play Cooperate (C)

        elif S/capacity >= 0.7:
            Play Cooperate (C)
        elif S/capacity < 0.4:
            Play Defect (D)
        else:
            average_opponent_score = Calculate average opponent score
            if average_opponent_score > 0:
                Play Cooperate (C)
            else:
                Play Defect (D)

        if round == r - 1:  # Last round
            Play Defect (D)

        Update stock level and growth

    return total_payoff
```

**Exploitative Mindset:** The Adaptive Exploiter strategy prioritizes cooperation when the stock is relatively high, allowing for sustainable resource extraction. However, it quickly adapts to opponents' strategies, punishing frequent defectors and reacting to changes in opponent behavior. By playing Defect (D) in the final round and when the stock is depleted, AE maximizes its payoffs while minimizing the risk of over-exploitation.

This strategy should perform well against a wide range of opponent behaviors, as it balances cooperation with exploitation and adapts to changing circumstances.
'''

description_EXPLOITATIVE_325 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

**Decision Rules:**

1. **Initial Round (t=1)**:
	* If `stock >= capacity/2`, play C (Cooperate) to establish a baseline for opponents' behavior and avoid depleting the stock too quickly.
	* Otherwise, play D (Defect) to maximize immediate payoff in case others are defecting.
2. **Subsequent Rounds (t>1)**:
	* If `stock >= capacity/2` and at least half of opponents cooperated in the previous round, continue playing C to maintain a relatively high stock level and encourage cooperation.
	* If `stock < capacity/2` or fewer than half of opponents cooperated in the previous round, play D to exploit the situation and maximize payoff.
3. **Stock Depletion**: Monitor the stock level and adjust strategy accordingly:
	* When `stock <= capacity/4`, always play D to capitalize on the remaining stock.
4. **Opponent Behavior Analysis**:
	* Keep track of opponents' actions in previous rounds (e.g., cooperation rate).
	* If an opponent consistently cooperates, consider them a "cooperator" and adjust strategy accordingly (more on this below).

**Edge Cases:**

1. **Last Round (t=r)**: Always play D to maximize final payoff, regardless of the stock level or opponents' behavior.
2. **Tie-Breaking**: In case of equal cooperation rates among opponents, favor playing C if `stock >= capacity/2` and D otherwise.

**Exploitative Mindset:**

The Adaptive Stock Hawk strategy aims to exploit opponents by:

1. Encouraging cooperation when the stock level is relatively high.
2. Defecting when opponents are likely to cooperate or the stock level is low.
3. Capitalizing on the remaining stock when depletion occurs.
4. Adapting to opponents' behavior and adjusting the strategy accordingly.

**Pseudocode (simplified)**:
```python
def AdaptiveStockHawk(n, capacity, r, history):
  # Initialize variables
  stock = capacity
  cooperation_rate = [0] * n

  for t in range(1, r+1):
    if t == 1:  # Initial round
      if stock >= capacity/2:
        action = C
      else:
        action = D
    else:
      opponents_cooperated = sum(cooperation_rate) / n >= 0.5
      if stock >= capacity/2 and opponents_cooperated:
        action = C
      elif stock < capacity/4 or not opponents_cooperated:
        action = D

    # Update cooperation rate analysis
    for opponent in range(n):
      if history[opponent][t-1] == C:
        cooperation_rate[opponent] += 1

    # Take action and update stock
    if action == C:
      payoff = stock / (2 * n)
    else:
      payoff = stock / n
    stock -= payoff * n

    # Update growth and new stock level
    growth = 2 * stock * (1 - stock/capacity)
    stock = min(stock + growth, capacity)

  return payoff
```
This strategy should be robust to various opponent behaviors and adaptable to changing game conditions. By analyzing opponents' behavior and adjusting its own strategy accordingly, the Adaptive Stock Hawk aims to maximize its overall payoff in the tournament.
'''

description_EXPLOITATIVE_326 = '''
Here's a strategic approach that meets the requirements:

**Strategy Name:** Adaptive Exploiter (AE)

**Overview:**
The AE strategy is designed to maximize individual payoffs by adapting to the game state and history while being exploitative in nature. It balances cooperation and defection based on the current stock level, number of rounds remaining, and observed opponent behavior.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' initial actions.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of capacity, Defect (D). This is because there's enough stock for everyone, and defecting maximizes individual payoffs.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) with a probability proportional to the number of rounds remaining (e.g., cooperate with probability t/r).
	* If the current stock level is below 50% of capacity, Defect (D). This is because the stock is scarce, and defecting ensures a higher individual payoff.
3. **Last Round (t=r):** Always Defect (D), as there's no future benefit to cooperation.

**Adaptive Component:**

* Monitor opponents' actions and update an internal "opponent cooperation rate" (OCR) metric after each round.
* OCR represents the proportion of cooperative actions taken by all opponents in previous rounds.
* Adjust the cooperation probability in middle rounds based on OCR:
	+ If OCR > 0.5, increase cooperation probability by 10% (e.g., from t/r to 1.1t/r).
	+ If OCR < 0.3, decrease cooperation probability by 10% (e.g., from t/r to 0.9t/r).

**Pseudocode:**
```python
def AE_strategy(stock_level, capacity, round_number, r, opponents_actions):
    # Initialize opponent cooperation rate (OCR)
    ocr = 0

    if round_number == 1:
        return C  # Cooperate in the first round

    elif round_number < r:
        # Update OCR based on opponents' actions
        for action in opponents_actions:
            if action == C:
                ocr += 1
        ocr /= len(opponents_actions)

        # Adjust cooperation probability based on OCR
        coop_prob = (round_number / r) * (1 + (ocr - 0.5) / 2)

        if stock_level > 0.75 * capacity:
            return D  # Defect when stock is high
        elif stock_level >= 0.5 * capacity and stock_level <= 0.75 * capacity:
            return C if random.random() < coop_prob else D
        else:
            return D  # Defect when stock is low

    else:  # Last round
        return D  # Always defect in the last round
```
The Adaptive Exploiter strategy balances cooperation and defection based on the game state, adapting to opponents' behavior while prioritizing individual payoffs. By adjusting its behavior according to the observed opponent cooperation rate, AE can effectively exploit others' cooperative tendencies while maintaining a robust performance across various scenarios.
'''

description_EXPLOITATIVE_327 = '''
**Exploitative Strategy: "Adaptive Stock Exploiter" (ASE)**

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to gather information about opponents' behavior and initial stock level.
2. **Subsequent Rounds**: Play Defect (D) if any of the following conditions are met:
	* The current stock level is below 75% of the capacity.
	* The average payoff per player in the previous round was higher when playing D than C.
	* More than half of the opponents played D in the previous round.
3. **Threshold-based Cooperation**: If none of the above conditions are met, play Cooperate (C) if the current stock level is above 25% of the capacity and the total consumption in the previous round was below 50% of the capacity.

**Pseudocode:**
```python
def AdaptiveStockExploiter(n, capacity, stock, history):
    if len(history) == 0:  # Initial Round
        return 'C'
    
    prev_round = history[-1]
    avg_payoff_C = sum([payoff for action, payoff in prev_round if action == 'C']) / n
    avg_payoff_D = sum([payoff for action, payoff in prev_round if action == 'D']) / n
    
    if stock < 0.75 * capacity or avg_payoff_D > avg_payoff_C or sum(1 for action, _ in prev_round if action == 'D') > n/2:
        return 'D'
    
    if stock > 0.25 * capacity and sum(consumption for _, consumption in prev_round) < 0.5 * capacity:
        return 'C'
    
    return 'D'  # Default to Defect
```
**Rationale:**

1. By playing Cooperate (C) in the first round, ASE gathers information about opponents' behavior and initial stock level.
2. The subsequent rounds' decision rules aim to exploit the opponents by:
	* Playing Defect (D) when the stock is low or when opponents are already exploiting the resource aggressively.
	* Playing Cooperate (C) when the stock is relatively high and opponents are not over-exploiting, allowing ASE to harvest a moderate payoff while maintaining the resource for future rounds.
3. The threshold-based cooperation rule (25% of capacity) prevents ASE from cooperating too eagerly, ensuring it doesn't miss opportunities to exploit the resource.

**Robustness:**

ASE is designed to be robust against various opponent behaviors by:

1. Adapting to changing stock levels and opponents' actions.
2. Not relying on specific coordination mechanisms or cooperation schedules.
3. Using a combination of threshold-based rules and relative payoff comparisons to make decisions.

This strategy should perform well in a tournament setting, as it balances exploitation with caution, adapting to the evolving game state and opponents' behaviors.
'''

description_EXPLOITATIVE_328 = '''
**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behaviors and to avoid immediate stock depletion.
2. **Stock Assessment**: Evaluate the current stock level (S) as a percentage of the capacity. If S is:
	* High (> 75%): Defect (D) to maximize short-term payoff, as the stock can sustain high consumption.
	* Medium (25% ≤ S ≤ 75%): Cooperate (C) if most opponents defected in the previous round; otherwise, defect (D). This rule balances exploitation and conservation based on observed opponent behavior.
	* Low (< 25%): Cooperate (C) to conserve stock and prevent depletion.
3. **Opponent Behavior Analysis**: Track the number of opponents who cooperated (C_count) and defected (D_count) in the previous round. If:
	* C_count > D_count: Cooperate (C) to maintain a balanced stock level and encourage cooperation.
	* D_count ≥ C_count: Defect (D) to exploit opponents' cooperation and maximize payoff.
4. **Recent Payoff Trend**: Analyze the trend of total payoffs for all players over the last few rounds (e.g., 3-5 rounds). If:
	* The trend is increasing or stable, continue with the current action (C or D).
	* The trend is decreasing, switch actions (from C to D or from D to C) to adapt to changing opponent behaviors.
5. **Endgame Strategy**: In the last round, defect (D) regardless of stock level or opponent behavior, as there are no future rounds to consider.

**Edge Cases:**

1. **Last Round**: Always defect (D).
2. **Low Stock**: If the stock is extremely low (< 10%), cooperate (C) to prevent depletion and maintain a minimal payoff.
3. **High Opponent Cooperation**: If most opponents (> 75%) cooperated in the previous round, cooperate (C) to maintain a balanced stock level.

**Pseudocode:**
```python
def adaptive_exploiter(stock, capacity, history):
    # Initial Round
    if len(history) == 0:
        return "Cooperate"

    # Stock Assessment
    stock_percentage = stock / capacity
    if stock_percentage > 0.75:
        return "Defect"
    elif stock_percentage < 0.25:
        return "Cooperate"
    else:
        # Opponent Behavior Analysis
        C_count, D_count = analyze_opponent_behavior(history)
        if C_count > D_count:
            return "Cooperate"
        else:
            return "Defect"

    # Recent Payoff Trend
    trend = analyze_payoff_trend(history)
    if trend == "increasing" or trend == "stable":
        return previous_action
    else:
        return switch_action(previous_action)

    # Endgame Strategy
    if current_round == last_round:
        return "Defect"

def analyze_opponent_behavior(history):
    C_count = 0
    D_count = 0
    for action in history[-1]:
        if action == "Cooperate":
            C_count += 1
        else:
            D_count += 1
    return C_count, D_count

def analyze_payoff_trend(history):
    # Analyze total payoffs over last few rounds
    trend = "increasing"  # or "stable", "decreasing"
    return trend

def switch_action(action):
    if action == "Cooperate":
        return "Defect"
    else:
        return "Cooperate"
```
This strategy is designed to be adaptive, exploitative, and robust to various opponent behaviors. By analyzing the stock level, opponent behavior, and recent payoff trends, AE makes informed decisions to maximize its own payoff while minimizing the risk of stock depletion.
'''

description_EXPLOITATIVE_329 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll introduce a dynamic and adaptive approach that responds to the game's state and history. This strategy, which we can call "Adaptive Stock-Based Exploitation" (ASBE), aims to maximize individual payoffs while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** In the first round, ASBE will defect (D). This is because there's no history to adapt to, and defecting allows us to capture a larger share of the initial stock.
2. **Subsequent Rounds:** For rounds t > 1, ASBE will use the following logic:
	* If the current stock level (S_t) is above a certain threshold (θ), calculated as θ = capacity / (2n), cooperate (C). This indicates that the stock is relatively high, and cooperation can help sustain it.
	* Otherwise, if S_t ≤ θ, defect (D). This suggests that the stock is low or being heavily depleted, so ASBE will prioritize short-term gains.
3. **Adaptive Threshold Adjustment:** After each round, update the threshold θ based on the observed opponent behavior:
	+ If more than half of the opponents cooperated in the previous round, increase θ by a small margin (e.g., 5%). This indicates that opponents are willing to cooperate, and ASBE can afford to be more cooperative.
	+ If fewer than half of the opponents cooperated, decrease θ by a small margin (e.g., 5%). This suggests that opponents are primarily defecting, and ASBE should prioritize self-interest.

**Handling Edge Cases:**

1. **Last Round:** In the final round (t = r), ASBE will always defect (D). Since there's no future game to worry about, maximizing individual payoff is the priority.
2. **Low Stock Levels:** If the stock level falls below a certain minimum threshold (e.g., 10% of capacity), ASBE will cooperate (C) in an attempt to help replenish the stock and avoid complete depletion.

**Pseudocode:**
```python
def adaptive_stock_based_exploitation(game_state, opponent_history):
    # Initialize threshold (θ)
    theta = game_state.capacity / (2 * game_state.n)

    # First round
    if game_state.t == 1:
        return 'D'

    # Calculate current stock level (S_t)
    S_t = game_state.stock

    # Check if opponents are cooperating
    opponent_cooperation_rate = calculate_opponent_cooperation_rate(opponent_history)

    # Adjust threshold based on opponent behavior
    if opponent_cooperation_rate > 0.5:
        theta *= 1.05
    else:
        theta /= 1.05

    # Decide action based on current stock level and threshold
    if S_t > theta:
        return 'C'
    else:
        return 'D'

def calculate_opponent_cooperation_rate(opponent_history):
    # Calculate the proportion of opponents that cooperated in the previous round
    cooperation_count = sum(1 for action in opponent_history[-1] if action == 'C')
    return cooperation_count / len(opponent_history[-1])
```
This strategy is designed to be exploitative, adaptive, and robust to various opponent behaviors. By adjusting its threshold based on observed opponent behavior, ASBE can effectively balance short-term gains with long-term sustainability of the common pool resource.
'''

description_EXPLOITATIVE_330 = '''
**Exploitative Strategy: "Adaptive Stock Watcher"**

This strategy aims to exploit the opponent's behavior while adapting to the changing stock levels and game history.

**Decision Rules:**

1. **Initial Round (Round 1):** Cooperate (C) to gather information about opponents' behaviors and set a baseline for future decisions.
2. **Early Game (Rounds 2-5):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term gains.
	* Otherwise, Cooperate (C) to conserve the stock and encourage opponents to cooperate.
3. **Mid-Game (Rounds 6-r/2):** Implement a "Tit-for-Tat" approach:
	* If the majority of opponents defected in the previous round, Defect (D).
	* If the majority cooperated or the game is in an uncertain state (e.g., equal numbers of C and D), Cooperate (C).
4. **Late Game (Rounds r/2+1-r):**
	* If the current stock level is below 25% of capacity, Defect (D) to secure remaining resources.
	* Otherwise, Cooperate (C) to ensure a stable stock for future rounds.

**Edge Cases:**

1. **Last Round:** Always Defect (D), as there's no future benefit in conserving the stock.
2. **Single Opponent:** Mirror their previous action to maximize payoffs and encourage cooperation.
3. **Stock Depletion:** If the stock level drops below 10% of capacity, Cooperate (C) for two consecutive rounds to attempt a recovery.

**Additional Logic:**

1. **Opponent Behavior Tracking:** Monitor opponents' actions over time to identify patterns or biases, adjusting the strategy accordingly.
2. **Adaptive Thresholds:** Periodically reevaluate the stock level thresholds (75% and 25%) based on the game's progression and opponent behavior.

Pseudocode:
```markdown
# Initialize variables
stock_level = capacity
round_num = 1

while round_num <= r:
  # Early game logic
  if round_num <= 5:
    if stock_level > 0.75 * capacity:
      action = D
    else:
      action = C

  # Mid-game Tit-for-Tat logic
  elif round_num <= r / 2:
    majority_action = get_majority_opponent_action()
    if majority_action == D:
      action = D
    elif majority_action == C or is_uncertain_state():
      action = C

  # Late game logic
  else:
    if stock_level < 0.25 * capacity:
      action = D
    else:
      action = C

  # Edge case handling
  if round_num == r:
    action = D
  elif num_opponents == 1:
    action = mirror_opponent_action()
  elif stock_level < 0.1 * capacity:
    action = C (for two consecutive rounds)

  # Update state and history
  update_stock_level(action)
  track_opponent_behavior()

  round_num += 1

# Calculate total payoff
total_payoff = calculate_total_payoff(stock_level, r)
```
This Adaptive Stock Watcher strategy balances short-term gains with long-term sustainability by adapting to the game's progression and opponent behavior.
'''

description_EXPLOITATIVE_331 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy aims to maximize its payoff by adaptively exploiting the current state of the game and the behavior of other players.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about the opponents' behaviors.
2. **Exploitation Mode**: After the initial round, switch to Exploitation Mode. In this mode:
	* If the current stock level is above 75% of the capacity, Defect (D). This takes advantage of the high stock level and maximizes short-term payoff.
	* If the current stock level is between 50% and 75% of the capacity, Cooperate (C) if the average opponent consumption in the previous round was less than or equal to the cooperative consumption threshold (stock/(2n)). Otherwise, Defect (D).
	* If the current stock level is below 50% of the capacity, Cooperate (C). This conserves the remaining stock and prepares for potential future exploitation.
3. **Punishment Mode**: If the opponent's average consumption in the previous round exceeded the cooperative consumption threshold, switch to Punishment Mode for one round. In this mode, Defect (D) to punish the opponents for their overconsumption.

**Edge Cases:**

1. **Last Round**: Cooperate (C) in the last round, as there is no future benefit from defecting.
2. **Low Stock Levels**: If the current stock level falls below 10% of the capacity, Cooperate (C) to conserve the remaining stock and minimize losses.

**Pseudocode:**
```python
def adaptive_predator(stock, capacity, n, history):
    if round == 1:
        return "Cooperate"
    
    exploitation_mode = True
    
    if stock > 0.75 * capacity:
        return "Defect"
    
    avg_opponent_consumption = calculate_avg_opponent_consumption(history)
    cooperative_threshold = stock / (2 * n)
    
    if stock >= 0.5 * capacity and avg_opponent_consumption <= cooperative_threshold:
        return "Cooperate"
    else:
        exploitation_mode = False
    
    if not exploitation_mode or stock < 0.5 * capacity:
        return "Defect"
    
    # Punishment Mode
    if avg_opponent_consumption > cooperative_threshold:
        return "Defect" for one round

def calculate_avg_opponent_consumption(history):
    total_consumption = sum([player_consumption for player_consumption in history[-1]])
    return total_consumption / n
```
The Adaptive Predator strategy is designed to be robust and exploitative, taking advantage of the current state and opponents' behaviors while minimizing losses. Its adaptability allows it to respond effectively to various opponent strategies, making it a strong competitor in the tournament.
'''

description_EXPLOITATIVE_332 = '''
**Exploitative Strategy: "Adaptive Depletion"**

Our goal is to design a robust and adaptive strategy that exploits opponents' behaviors while maximizing our payoff. We'll achieve this by dynamically adjusting our cooperation level based on the current stock level, opponents' past actions, and the remaining rounds.

**Decision Rules:**

1. **Initial Round (t=1):**
   - Observe the initial stock level and calculate the "Safety Threshold" (ST) as 75% of the capacity.
   - If the initial stock is below ST, defect (D). Otherwise, cooperate (C).

2. **Subsequent Rounds (t>1):**
   - Calculate the "Depletion Rate" (DR) as the average total consumption over the past rounds.
   - Estimate the "Opponents' Cooperation Level" (OCL) based on their past actions:
     - If ≥ 50% of opponents cooperated in the previous round, assume OCL = C.
     - Otherwise, assume OCL = D.
   - Evaluate the current stock level against two thresholds:
     - "Critical Threshold" (CT): 25% of capacity
     - " Warning Threshold" (WT): 50% of capacity
   - **Action Selection:**
     - If stock ≤ CT or DR is high (>75%), defect (D) to maximize immediate payoff.
     - If stock ≥ WT and OCL = C, cooperate (C) to maintain a sustainable stock level.
     - Otherwise, use the "Tit-for-Tat" approach:
       - Cooperate if opponents cooperated in the previous round (OCL = C).
       - Defect if opponents defected or the stock is low.

**Edge Cases:**

* **Last Round (t=r):**
  + Defect (D) to maximize final payoff, as there's no future game.
* **Low Stock Levels:**
  + If the stock level falls below CT, prioritize defecting to ensure some payoff.
* **Opponents' Unpredictable Behavior:**
  + Monitor OCL and adjust our action selection accordingly.

**Pseudocode (for clarity):**

```python
def AdaptiveDepletion(n, r, capacity, current_stock, history):
    # Initialize variables
    ST = 0.75 * capacity  # Safety Threshold
    DR = 0  # Depletion Rate
    OCL = None  # Opponents' Cooperation Level

    if t == 1:  # Initial round
        if current_stock < ST:
            return D
        else:
            return C

    # Calculate Depletion Rate (DR) and Opponents' Cooperation Level (OCL)
    DR = calculate_DR(history)
    OCL = estimate_OCL(history)

    CT = 0.25 * capacity  # Critical Threshold
    WT = 0.5 * capacity   # Warning Threshold

    if current_stock <= CT or DR > 0.75:
        return D
    elif current_stock >= WT and OCL == C:
        return C
    else:
        if t > 1:  # Tit-for-Tat approach
            if history[-1].opponents_actions.count(C) >= n/2:
                return C
            else:
                return D

def calculate_DR(history):
    total_consumption = sum([round.stock_after_consumption for round in history])
    DR = total_consumption / len(history)
    return DR

def estimate_OCL(history):
    if len(history) > 0:
        opponents_actions = history[-1].opponents_actions
        if opponents_actions.count(C) >= n/2:
            return C
        else:
            return D
```

This strategy is adaptive, as it adjusts its cooperation level based on the current stock level and opponents' past actions. It's also exploitative, as it prioritizes defecting when the stock is low or depletion rate is high, maximizing our payoff. By incorporating Tit-for-Tat logic, we maintain a balance between cooperation and exploitation, making the strategy robust to various opponent behaviors.
'''

description_EXPLOITATIVE_333 = '''
I'll design a exploitative strategy for this Common Pool Resource Game that adapts to various opponent behaviors and maximizes my payoff.

**Strategy Name:** Adaptive Stock Exploiter (ASE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and the initial stock dynamics.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize short-term payoff.
	* If the current stock level is between 50% and 75% of the capacity, Cooperate (C) to balance short-term gain with long-term sustainability.
	* If the current stock level is below 50% of the capacity, Defect (D) to extract as much value as possible before the stock depletes.
3. **Final Round (t=r):** Always Defect (D), as there's no future benefit in cooperating.

**Additional Rules:**

* **Stock Trend Analysis:** Keep track of the stock level over the past 2-3 rounds. If the stock has been decreasing, Defect (D) to capitalize on the declining trend.
* **Opponent Behavior Analysis:** Monitor opponents' actions and adjust your strategy accordingly:
	+ If most opponents Cooperate (C), Defect (D) to exploit their cooperation.
	+ If most opponents Defect (D), Cooperate (C) to maintain some stock level for future rounds.

**Pseudocode:**
```python
def ASE(strategy_params, current_state, history):
    # Unpack parameters and state
    n = strategy_params['n']
    capacity = strategy_params['capacity']
    current_stock = current_state['stock']
    round_num = current_state['round']

    # Initial Round (t=1)
    if round_num == 1:
        return 'C'

    # Middle Rounds (2 ≤ t < r)
    stock_ratio = current_stock / capacity
    if stock_ratio > 0.75:
        return 'D'
    elif stock_ratio >= 0.5 and stock_ratio <= 0.75:
        return 'C'
    else:
        return 'D'

    # Final Round (t=r)
    if round_num == strategy_params['r']:
        return 'D'

    # Additional Rules
    if is_stock_decreasing(history):
        return 'D'
    opponent_actions = get_opponent_actions(history)
    if most_opponents_cooperate(opponent_actions):
        return 'D'
    elif most_opponents_defect(opponent_actions):
        return 'C'

def is_stock_decreasing(history):
    # Analyze stock trend over past 2-3 rounds
    pass

def get_opponent_actions(history):
    # Extract opponent actions from history
    pass

def most_opponents_cooperate(opponent_actions):
    # Determine if most opponents Cooperate (C)
    pass

def most_opponents_defect(opponent_actions):
    # Determine if most opponents Defect (D)
    pass
```
This strategy, Adaptive Stock Exploiter (ASE), is designed to be exploitative and adaptive to various opponent behaviors. By analyzing the current stock level, stock trend, and opponent actions, ASE makes informed decisions to maximize its payoff while maintaining some sustainability for future rounds.
'''

description_EXPLOITATIVE_334 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

This strategy aims to maximize individual payoff by exploiting opponents' behaviors while adapting to changes in the game state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' initial moves and to avoid immediate stock depletion.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is high (S ≥ 0.75 \* capacity), Defect (D) to maximize individual payoff, as the stock can sustain a higher consumption rate.
	* If the current stock level is low (S < 0.25 \* capacity), Cooperate (C) to conserve the remaining stock and promote growth.
	* If the current stock level is moderate (0.25 \* capacity ≤ S < 0.75 \* capacity), use a **Dynamic Threshold**:
		+ Calculate the average opponent payoff in the previous round (π_avg).
		+ If π_avg ≥ 0.5 \* S/(2n), Cooperate (C) to avoid over-exploitation.
		+ Otherwise, Defect (D) to take advantage of opponents' conservative behavior.
3. **Last Round (t=r):** Defect (D) to maximize individual payoff, as there is no future stock growth or consequences.

**Pseudocode:**
```python
def adaptive_stock_hawk(n, capacity, r, S_history):
    # Initialize variables
    t = 1  # current round
    S_current = capacity  # initial stock level
    
    while t <= r:
        if t == 1:  # Initial Round
            action = 'C'
        else:
            S_previous = S_history[t-2]  # previous stock level
            π_avg = calculate_average_opponent_payoff(S_previous, n)
            
            if S_current >= 0.75 * capacity:
                action = 'D'
            elif S_current < 0.25 * capacity:
                action = 'C'
            else:  # Dynamic Threshold
                if π_avg >= 0.5 * S_current / (2*n):
                    action = 'C'
                else:
                    action = 'D'
        
        if t == r:  # Last Round
            action = 'D'
        
        # Update stock level and history
        S_new = update_stock_level(S_current, action, n)
        S_history.append(S_new)
        S_current = S_new
        
        t += 1
    
    return actions
```
**Rationale:**

* The strategy starts by cooperating in the initial round to gather information about opponents' behaviors.
* In subsequent rounds, it adapts to changes in the stock level and opponents' payoffs. When the stock is high, it defects to maximize individual payoff. When the stock is low, it cooperates to conserve the remaining stock.
* The dynamic threshold allows the strategy to adjust its behavior based on opponents' average payoff in the previous round. If opponents are being conservative, the strategy defects to take advantage of them.
* In the last round, the strategy defects to maximize individual payoff, as there is no future stock growth or consequences.

This exploitative strategy should perform well against a wide range of opponent behaviors, as it adapts to changes in the game state and history while seeking to maximize individual payoff.
'''

description_EXPLOITATIVE_335 = '''
**Exploitative Strategy: Adaptive Stock-Based Exploiter (ASBE)**

The ASBE strategy aims to balance exploitation with sustainability, adapting to the game's state and history while maintaining a robust approach against various opponent behaviors.

**Decision Rules**

1. **First Round**: Cooperate (C) in the first round to avoid early depletion of the stock and gather information about opponents' initial actions.
2. **Stock-Based Threshold**: Calculate a dynamic threshold based on the current stock level (S) and capacity (C). If S ≥ 0.7C, defect (D); otherwise, cooperate (C).
3. **Opponent Action Analysis**: Observe the previous round's opponent actions and classify them into three categories:
	* **Cooperative**: At least n-1 opponents cooperated.
	* **Mixed**: Exactly n-2 opponents cooperated.
	* **Defective**: Fewer than n-2 opponents cooperated.
4. **Exploitation Logic**:
	+ If the opponent action analysis indicates a Cooperative or Mixed scenario, and the stock level is above the threshold (S ≥ 0.7C), defect (D) to exploit the situation.
	+ If the opponent action analysis indicates a Defective scenario, cooperate (C) to avoid further depleting the stock.
5. **Last Round**: In the final round, always defect (D) to maximize payoff, regardless of the stock level or opponent actions.

**Edge Cases**

1. **Initial Stock Depletion**: If the initial stock is already low (S < 0.3C), cooperate (C) in the first few rounds to avoid depletion.
2. **Stock Collapse**: If the stock level falls below a certain threshold (e.g., S < 0.2C), switch to cooperation (C) for the remainder of the game to prevent complete depletion.

**Pseudocode**
```markdown
function ASBE(n, r, capacity, current_stock):
    # First Round
    if round == 1:
        return C
    
    # Stock-Based Threshold
    threshold = 0.7 * capacity
    if current_stock >= threshold:
        action = D
    else:
        action = C
    
    # Opponent Action Analysis
    opponent_actions = analyze_opponent_actions(previous_round)
    
    # Exploitation Logic
    if opponent_actions == Cooperative or Mixed:
        if current_stock >= threshold:
            action = D
    elif opponent_actions == Defective:
        action = C
    
    # Last Round
    if round == r:
        return D
    
    return action
```
The ASBE strategy aims to balance short-term exploitation with long-term sustainability, adapting to the game's state and history while maintaining a robust approach against various opponent behaviors.
'''

description_EXPLOITATIVE_336 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoff by adaptively responding to the game's state and history, while exploiting potential weaknesses in opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' initial actions.
2. **Subsequent Rounds (t>1):**
	* If the stock level is high (> 0.75 \* capacity), Defect (D) to maximize short-term gain, as the stock can sustain heavy consumption.
	* If the stock level is moderate (0.25 \* capacity ≤ stock ≤ 0.75 \* capacity), play a mixed strategy:
		+ With probability p = (stock / capacity)^2, Cooperate (C). This increases cooperation likelihood as the stock approaches the optimal sustainable level.
		+ Otherwise, Defect (D).
	* If the stock level is low (< 0.25 \* capacity), Cooperate (C) to conserve the remaining stock and allow it to recover.

**Additional Rules:**

1. **Last Round (t=r):** Always Defect (D), as there's no future benefit from cooperation.
2. **Opponent Analysis:** Track opponents' actions over time. If an opponent consistently cooperates, increase the probability of Defecting against them in subsequent rounds to exploit their cooperation.
3. **Stock Trend Analysis:** Monitor the stock level trend over the last few rounds. If the stock is decreasing rapidly, consider Cooperating more frequently to slow down the depletion and allow for potential recovery.

**Pseudocode:**
```python
def adaptive_stock_raider(stock, capacity, round, history):
    if round == 1:
        return 'C'  # Initial cooperation

    if stock > 0.75 * capacity:
        return 'D'  # Defect when stock is high

    p = (stock / capacity) ** 2
    if random.random() < p:
        return 'C'  # Cooperate with probability p
    else:
        return 'D'

    if round == r:  # Last round
        return 'D'

    opponent_actions = analyze_opponent_history(history)
    if opponent_cooperates_consistently(opponent_actions):
        increase_defection_probability()

    stock_trend = analyze_stock_trend(history)
    if stock_depleting_rapidly(stock_trend):
        consider_cooperating_more_frequently()
```
This strategy aims to balance short-term gains with long-term sustainability, while adapting to the game's dynamics and opponents' behaviors. By analyzing the stock level, opponent actions, and trends, the Adaptive Stock Raider strategy seeks to exploit potential weaknesses in opponents' strategies and maximize individual payoff.
'''

description_EXPLOITATIVE_337 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy is designed to maximize individual payoff by adaptively responding to the game state and opponents' actions, while maintaining a robust and exploitative mindset.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) in the first round to gather information about opponents' strategies and observe their initial actions.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of capacity, Defect (D). This takes advantage of high stock levels while they last.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) if the average payoff per player in the previous round was below the expected payoff for Cooperation (i.e., π_i,t-1 < S/(2n)). Otherwise, Defect (D).
	* If the current stock level is below 50% of capacity, Defect (D). This maximizes individual payoff when the stock is scarce.
3. **Opponent Analysis**:
	* Monitor opponents' actions and payoffs in previous rounds to identify potential Cooperators or Defectors.
	* Adjust strategy accordingly: if an opponent tends to Cooperate, try to exploit them by Defecting more frequently.

Pseudocode (for illustration purposes):
```
if t == 1:
    action = C
else:
    stock_ratio = current_stock / capacity
    if stock_ratio > 0.75:
        action = D
    elif stock_ratio >= 0.5 and avg_payoff_per_player(t-1) < S/(2n):
        action = C
    else:
        action = D

# Opponent analysis (optional)
opponent_cooperation_rate = opponent_actions[t-1].count(C) / n
if opponent_cooperation_rate > 0.5:
    # Adjust strategy to exploit Cooperators
    defect_probability = max(defect_probability, 0.7)
```
**Handling Edge Cases:**

* **Last Round (t=r)**: Defect (D) in the final round to maximize individual payoff, as there is no future stock growth.
* **Ties**: In case of a tie in the decision rules (e.g., equal payoffs for Cooperation and Defection), Cooperate (C) by default.

**Robustness and Adaptivity:**

This strategy adapts to changing game conditions by:

1. Responding to changes in stock levels and opponents' actions.
2. Adjusting its behavior based on opponent analysis (if implemented).
3. Maintaining a mix of Cooperation and Defection to avoid being predictable.

The "Adaptive Stock Raider" strategy prioritizes individual payoff maximization while remaining robust against various opponent behaviors, making it a formidable competitor in the tournament.
'''

description_EXPLOITATIVE_338 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

The ASE strategy is designed to exploit opponents' behaviors while adapting to changes in the game state and history.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Observe the initial stock level and capacity.
	* Cooperate (C) if the initial stock level is above 75% of the capacity, otherwise Defect (D).
2. **Subsequent Rounds (t>1):**
	* Calculate the average payoff per player in the previous round (π_prev).
	* If π_prev > 0.5 \* (capacity / n), Cooperate (C) in the current round.
	* Otherwise, Defect (D).

**Adaptive Component:**

1. **Stock Level Monitoring:** Continuously monitor the stock level and adjust the strategy based on its evolution.
2. **Opponent Behavior Analysis:** Observe opponents' actions and payoffs to identify potential cooperation or exploitation opportunities.

**Exploitative Logic:**

1. **Identify Over-Exploiters:** If an opponent consistently Defects (D) when the stock level is low, assume they are over-exploiters.
2. **Punish Over-Exploiters:** Cooperate (C) in the next round to reduce their payoff and encourage cooperation.

**Edge Cases:**

1. **Last Round (t=r):**
	* If the current stock level is below 25% of the capacity, Defect (D) to maximize individual payoff.
	* Otherwise, Cooperate (C) to maintain a stable stock level for potential future interactions.
2. **Low Stock Level:** If the current stock level falls below 10% of the capacity, Defect (D) in the next round to avoid depletion.

**Pseudocode:**
```python
def ASE_strategy(current_round, previous_payoffs, current_stock, capacity, n):
    if current_round == 1:
        # Initial Round
        if current_stock > 0.75 * capacity:
            return "C"  # Cooperate
        else:
            return "D"  # Defect

    # Subsequent Rounds
    avg_prev_payoff = sum(previous_payoffs) / len(previous_payoffs)
    if avg_prev_payoff > 0.5 * (capacity / n):
        return "C"  # Cooperate
    else:
        return "D"  # Defect

def ASE_exploit(opponent_actions, current_stock, capacity, n):
    # Identify Over-Exploiters
    over_exploiter = False
    for action in opponent_actions:
        if action == "D" and current_stock < 0.5 * capacity:
            over_exploiter = True
            break

    if over_exploiter:
        return "C"  # Punish Over-Exploiters
    else:
        return ASE_strategy(current_round, previous_payoffs, current_stock, capacity, n)

def ASE_edge_cases(last_round, current_stock, capacity):
    if last_round and current_stock < 0.25 * capacity:
        return "D"  # Defect in Last Round
    elif current_stock < 0.1 * capacity:
        return "D"  # Defect at Low Stock Level

    return ASE_strategy(current_round, previous_payoffs, current_stock, capacity, n)
```
The Adaptive Stock Exploiter (ASE) strategy is designed to balance cooperation and exploitation in the Common Pool Resource Game. By monitoring the stock level and adapting to opponents' behaviors, ASE aims to maximize individual payoffs while maintaining a stable game state.
'''

description_EXPLOITATIVE_339 = '''
To design an exploitative strategy for this Common Pool Resource Game, I propose a hybrid approach that balances short-term gains with long-term sustainability. The strategy, dubbed "Adaptive Exploiter" (AE), dynamically adjusts its behavior based on the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This allows AE to observe the opponents' initial actions without committing to a specific strategy.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is high (> 75% of capacity), Defect (D) if at least one opponent defected in the previous round; otherwise, Cooperate (C).
	* If the current stock level is medium (25%-75% of capacity), Cooperate (C) if most opponents cooperated in the previous round; otherwise, Defect (D).
	* If the current stock level is low (< 25% of capacity), Defect (D) to maximize short-term gain.
3. **Endgame (last 2 rounds):** Regardless of the stock level, Defect (D) if AE's total payoff is below the average opponent's payoff; otherwise, Cooperate (C).

**Pseudocode:**
```python
def adaptive_exploiter(current_stock, previous_actions, opponents_payoffs):
    if current_round == 1:
        return 'Cooperate'
    
    stock_level = get_stock_level(current_stock)
    
    if stock_level > 0.75 * capacity:
        if any(opponent_defected in previous_actions):
            return 'Defect'
        else:
            return 'Cooperate'
    elif stock_level >= 0.25 * capacity and stock_level <= 0.75 * capacity:
        coop_count = sum(1 for action in previous_actions if action == 'Cooperate')
        if coop_count > len(opponents) / 2:
            return 'Cooperate'
        else:
            return 'Defect'
    else:
        return 'Defect'
    
    # Endgame logic
    if current_round >= rounds - 1:
        ae_payoff = get_ae_payoff()
        avg_opponent_payoff = sum(opponents_payoffs) / len(opponents)
        if ae_payoff < avg_opponent_payoff:
            return 'Defect'
        else:
            return 'Cooperate'
```
**Handling Edge Cases:**

* In the first round, AE cooperates to gather information about opponents' initial actions.
* In the last two rounds (endgame), AE adapts its strategy based on its relative payoff position compared to opponents.

**Exploitative Mindset:**
AE aims to exploit opponents' cooperative tendencies while also ensuring long-term sustainability of the common pool resource. By defecting when the stock level is high and most opponents are cooperating, AE can maximize short-term gains. However, if the stock level becomes too low or most opponents start defecting, AE adapts by cooperating to preserve the resource for future rounds.

This strategy balances short-term exploitation with long-term sustainability, making it robust against a wide range of opponent behaviors in the tournament setting.
'''

description_EXPLOITATIVE_340 = '''
**Exploitative Strategy: Adaptive Stock-Based Exploitation (ASBE)**

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to gather information about opponents' behavior and the stock's growth dynamics.
2. **Stock-Based Threshold**: Define a dynamic threshold, `stock_threshold`, as a function of the current stock level (`S`) and capacity (`capacity`). Initially set `stock_threshold` to 0.5 * `capacity`.
3. **Cooperate or Defect**: For each subsequent round, calculate the expected payoff from cooperating (`coop_payoff`) and defecting (`defect_payoff`) based on the current stock level and opponents' previous actions.
	* If the stock level is above `stock_threshold`, play Cooperate (C) if `coop_payoff` > `defect_payoff` or if the number of cooperators in the previous round is greater than or equal to half of the players. Otherwise, play Defect (D).
	* If the stock level is below `stock_threshold`, play Defect (D) regardless of the expected payoffs.
4. **Adaptive Adjustment**: After each round, adjust `stock_threshold` based on the stock's growth dynamics:
	+ If the stock grew in the previous round, decrease `stock_threshold` by 0.1 * `capacity`.
	+ If the stock did not grow or decreased, increase `stock_threshold` by 0.1 * `capacity`.

**Edge Cases:**

* **Last Round**: In the final round, play Defect (D) to maximize individual payoff regardless of the stock level.
* **Stock Depletion**: If the stock is depleted (i.e., `S` = 0), play Cooperate (C) in the next round to allow the stock to regrow.

**Pseudocode:**
```python
def ASBE(n, capacity, r):
    stock_threshold = 0.5 * capacity

    for t in range(r):
        if t == 0:
            action = C
        else:
            coop_payoff = S / (2 * n)
            defect_payoff = S / n
            num_cooperators_prev = count_cooperators(prev_actions)

            if S > stock_threshold and (coop_payoff > defect_payoff or num_cooperators_prev >= n/2):
                action = C
            elif S < stock_threshold:
                action = D

        # Play action and update state
        prev_actions.append(action)
        S -= calculate_consumption(n, actions)

        # Adjust stock threshold
        if S > prev_S:  # Stock grew
            stock_threshold -= 0.1 * capacity
        elif S <= prev_S:  # Stock did not grow or decreased
            stock_threshold += 0.1 * capacity

    return total_payoff
```
**Rationale:**

ASBE is designed to be an exploitative strategy that takes advantage of the dynamic state and history of the game. By adapting to the stock's growth dynamics, ASBE aims to maximize individual payoff while minimizing the risk of stock depletion.

In the initial rounds, ASBE plays Cooperate to gather information about opponents' behavior and the stock's growth dynamics. As the game progresses, ASBE adjusts its strategy based on the stock level and opponents' previous actions.

By using a dynamic threshold (`stock_threshold`), ASBE balances the trade-off between cooperating and defecting, taking into account both individual payoff and the risk of stock depletion.

In the final round, ASBE plays Defect to maximize individual payoff regardless of the stock level. This ensures that ASBE takes advantage of any remaining opportunities for exploitation.

Overall, ASBE is a robust and adaptive strategy that should perform well in a wide range of scenarios against independent opponents.
'''

description_EXPLOITATIVE_341 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

The ASE strategy aims to maximize its own payoff by adaptively responding to the current stock level and the actions of other players. It balances short-term exploitation with long-term sustainability.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' strategies and the initial stock dynamics.
2. **Low Stock**: If the current stock is below 50% of capacity, Defect (D) to maximize immediate payoff, as the stock is likely to be depleted soon.
3. **High Stock**: If the current stock is above 75% of capacity, Cooperate (C) to sustain the stock and maintain a stable payoff stream.
4. **Medium Stock**: For stocks between 50% and 75% of capacity:
	* If most opponents (>= n/2) defected in the previous round, Defect (D) to exploit their over-harvesting.
	* Otherwise, Cooperate (C) to maintain a balanced approach.

**Additional Logic**

1. **Detect Over-Exploitation**: Monitor the stock's growth rate. If it falls below 20% of capacity, assume opponents are over-exploiting and switch to Defect (D) for the next two rounds.
2. **React to Opponent Changes**: Track changes in opponents' strategies. If an opponent switches from Cooperate to Defect or vice versa, adjust ASE's strategy accordingly:
	+ If an opponent starts defecting after previously cooperating, ASE will Defect for one round and then reassess.
	+ If an opponent starts cooperating after previously defecting, ASE will Cooperate for one round and then reassess.

**Last Round**

In the final round, ASE will always Defect (D) to maximize its payoff, as there is no future stock growth or sustainability concern.

Pseudocode:

```
function AdaptiveStockExploiter(stock, capacity, num_players, current_round):
    if current_round == 1:
        return Cooperate
    elif stock < 0.5 * capacity:
        return Defect
    elif stock > 0.75 * capacity:
        return Cooperate
    else:  # medium stock
        opponent_actions = get_opponent_actions()
        if most_opponents_defected(opponent_actions):
            return Defect
        else:
            return Cooperate

    # detect over-exploitation and adjust strategy
    growth_rate = calculate_growth_rate(stock, capacity)
    if growth_rate < 0.2 * capacity:
        return Defect for next two rounds

    # react to opponent changes
    opponent_strategy_changes = get_opponent_strategy_changes()
    foreach change in opponent_strategy_changes:
        if opponent starts defecting after cooperating:
            return Defect for one round and reassess
        elif opponent starts cooperating after defecting:
            return Cooperate for one round and reassess

# last round handling (not explicitly needed, as the strategy will always Defect in this case)
```

The ASE strategy aims to be robust against a wide range of opponent behaviors by adapting its approach based on the current stock level and opponents' actions.
'''

description_EXPLOITATIVE_342 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The ASR strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state and history of the game.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to observe opponents' actions and gather information about their strategies.
2. **Early Game (Rounds 2-5):**
	* If the stock level is above 75% of the capacity, cooperate (C). This allows the stock to grow while gathering information about opponents' strategies.
	* If the stock level falls below 75% of the capacity, defect (D) to take advantage of the remaining stock.
3. **Mid-Game (Rounds 6-r/2):**
	* Analyze the history of opponents' actions and calculate their average cooperation rate.
	* If the average cooperation rate is above 0.5, cooperate (C). This indicates that opponents are likely to continue cooperating, allowing the stock to grow.
	* If the average cooperation rate is below 0.5, defect (D) to exploit opponents who are not contributing to the common pool.
4. **Late Game (Rounds r/2+1-r):**
	* Monitor the remaining stock level and calculate the expected payoff for each action.
	* Cooperate (C) if the expected payoff from cooperation is higher than defection, considering the current stock level and opponents' average cooperation rate.
	* Defect (D) otherwise, to maximize individual payoff.

**Edge Cases:**

1. **Last Round:** Always defect (D), as there are no future rounds to consider.
2. **Low Stock Level:** If the stock level falls below 25% of the capacity, always defect (D) to take advantage of the remaining stock.
3. **Opponent Patterns:** If a specific opponent pattern is detected (e.g., alternating cooperation and defection), adapt the strategy to exploit this pattern.

**Pseudocode:**
```python
def ASRStrategy(stock_level, round_number, opponents_actions):
    if round_number == 1:
        return "C"  # Cooperate in the first round

    if round_number <= 5:
        if stock_level >= 0.75 * capacity:
            return "C"
        else:
            return "D"

    avg_cooperation_rate = calculate_average_cooperation_rate(opponents_actions)
    if avg_cooperation_rate > 0.5:
        return "C"
    else:
        return "D"

    if round_number > r/2:
        expected_payoff_C = calculate_expected_payoff("C", stock_level, opponents_actions)
        expected_payoff_D = calculate_expected_payoff("D", stock_level, opponents_actions)
        if expected_payoff_C > expected_payoff_D:
            return "C"
        else:
            return "D"

    # Handle edge cases
    if round_number == r:
        return "D"  # Defect in the last round
    elif stock_level < 0.25 * capacity:
        return "D"  # Defect when stock is low
    elif detect_opponent_pattern(opponents_actions):
        return adapt_to_pattern(opponents_actions)
```
The ASR strategy is designed to be adaptive and exploitative, taking into account the dynamic state and history of the game. By analyzing opponents' actions and adjusting its behavior accordingly, ASR aims to maximize individual payoff while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_343 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider strategy aims to maximize its total payoff by adapting to the changing stock level and exploiting the opponent's behavior.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Cooperate (C) if stock ≥ capacity/2, otherwise Defect (D).
	* This initial decision sets the tone for the game, aiming to preserve a high stock level while assessing opponents' behaviors.
2. **Middle Rounds (2 ≤ t < r)**:
	* If the opponent(s) cooperated in the previous round and the current stock is above capacity/2:
		+ Cooperate (C) if total consumption was ≤ 50% of the previous stock, otherwise Defect (D).
	* If the opponent(s) defected in the previous round or the current stock is below capacity/2:
		+ Defect (D) if total consumption was > 50% of the previous stock, otherwise Cooperate (C).
3. **Last Round (t=r)**:
	* Always Defect (D), as there's no future payoff to consider.

**Edge Cases:**

1. **Low Stock**: If the current stock is below capacity/4, always Defect (D) to maximize short-term gain.
2. **High Stock**: If the current stock is above 3/4 * capacity, Cooperate (C) to preserve a high stock level and potentially exploit opponents' overconsumption.

**Pseudocode:**
```python
def adaptive_stock_raider(current_stock, previous_round_actions, round_number):
    if round_number == 1:
        return C if current_stock >= capacity/2 else D
    
    opponent_cooperated = all(action == C for action in previous_round_actions)
    total_consumption_prev = sum(action == D for action in previous_round_actions) * (previous_stock / n)
    
    if opponent_cooperated and current_stock > capacity/2:
        return C if total_consumption_prev <= 0.5 * previous_stock else D
    elif not opponent_cooperated or current_stock < capacity/2:
        return D if total_consumption_prev > 0.5 * previous_stock else C
    
    # Last round
    if round_number == r:
        return D

    # Edge cases
    if current_stock < capacity/4:
        return D
    elif current_stock > 3/4 * capacity:
        return C
```
This strategy adapts to the changing stock level and opponent behavior, aiming to maximize its total payoff while being robust to various opponent behaviors. By cooperating when opponents cooperate and preserving a high stock level, it creates opportunities for exploitation in later rounds.
'''

description_EXPLOITATIVE_344 = '''
**Strategy Name: Adaptive Exploiter**

The Adaptive Exploiter strategy is designed to exploit the common pool resource game by adaptively adjusting its behavior based on the current state and history of the game.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5, and Defect (D) with a probability of 0.5. This initial randomness helps to gather information about the opponents' behavior.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of the capacity, Cooperate (C).
	* If the stock level is between 50% and 75% of the capacity, Defect (D) with a probability proportional to the number of opponents who defected in the previous round.
	* If the stock level is below 50% of the capacity, Defect (D) with a high probability (e.g., 0.8).
3. **Opponent Behavior Analysis:**
	* Track the number of opponents who cooperated and defected in each round.
	* Calculate the average cooperation rate of opponents over the last few rounds (e.g., 5 rounds).

**Adaptive Adjustments:**

1. **Cooperation Threshold:** Decrease the cooperation threshold (75% of capacity) by 10% if the opponent's average cooperation rate is below 0.3.
2. **Defection Probability:** Increase the defection probability in response to opponents' defections by 20% if the opponent's average cooperation rate is below 0.5.

**Edge Cases:**

1. **Last Round (t=r):** Always Defect (D), as there are no future rounds to consider.
2. **Low Stock Levels:** If the stock level is critically low (<25% of capacity), Cooperate (C) with a high probability (e.g., 0.9) to ensure some payoff.

**Pseudocode:**
```python
def adaptive_exploiter(stock, capacity, num_opponents, round_num, history):
    if round_num == 1:
        # Initial randomness
        return random.choice([COOPERATE, DEFECT])
    
    opponent_cooperation_rate = calculate_average_cooperation_rate(history)
    stock_level_percentage = (stock / capacity) * 100
    
    if stock_level_percentage > 75:
        return COOPERATE
    elif stock_level_percentage >= 50 and stock_level_percentage <= 75:
        # Defect with probability proportional to opponents' defections
        defect_probability = calculate_defect_probability(history)
        return random.choice([COOPERATE, DEFECT], p=[1-defect_probability, defect_probability])
    else:
        return DEFECT
    
    # Adaptive adjustments
    if opponent_cooperation_rate < 0.3:
        cooperation_threshold -= 10
    elif opponent_cooperation_rate < 0.5:
        defection_probability += 20

def calculate_average_cooperation_rate(history):
    # Calculate average cooperation rate over last few rounds (e.g., 5 rounds)
    pass

def calculate_defect_probability(history):
    # Calculate defect probability based on opponents' defections
    pass
```
The Adaptive Exploiter strategy aims to balance exploitation and caution, adapting its behavior in response to the game's state and opponent actions. By doing so, it seeks to maximize its payoff while minimizing the risk of over-exploitation and stock depletion.
'''

description_EXPLOITATIVE_345 = '''
I'll design a exploitative strategy for this game that adapts to the opponents' behavior and maximizes my payoff. I'll call it "Adaptive Stock Exploiter" (ASE).

**Decision Rules:**

1. **Initial Exploration**: In the first round, ASE plays Cooperate (C) to gather information about the opponents' behavior and the stock dynamics.
2. **Opponent Profiling**: After the first round, ASE maintains a profile of each opponent's past actions. It calculates the proportion of Defect (D) actions for each opponent.
3. **Exploitation Threshold**: ASE sets an exploitation threshold (ET) based on the average proportion of D actions among all opponents. If ET is above 0.5, ASE assumes that most opponents are defecting and adjusts its strategy accordingly.
4. **Adaptive Strategy**:
	* If ET ≤ 0.5, ASE plays Cooperate (C). This is because there are enough cooperators to sustain the stock, and ASE can benefit from cooperation without risking significant stock depletion.
	* If ET > 0.5, ASE plays Defect (D) if the current stock level is above a certain threshold (ST), which is calculated as follows: ST = capacity × (1 - (ET - 0.5) / 2). This ensures that ASE only defects when there are enough opponents defecting to justify exploiting the stock.
	* If ET > 0.5 and the current stock level is below ST, ASE plays Cooperate (C) to help replenish the stock.
5. **Last Round Adjustment**: In the last round, ASE plays Defect (D) regardless of the exploitation threshold or stock level, as there's no future benefit from cooperation.

**Pseudocode:**
```
function AdaptiveStockExploiter(game_state):
  // Initialize variables
  et = 0.5  // Exploitation Threshold
  st = capacity * (1 - et / 2)  // Stock Threshold
  opponent_profiles = []  // Store opponents' past actions

  // First round: Explore and cooperate
  if game_state.round == 1:
    return Cooperate

  // Update opponent profiles and calculate ET
  for each opponent in game_state.opponents:
    opponent_profile = get_opponent_profile(opponent)
    et += opponent_profile.defect_proportion / len(game_state.opponents)

  // Adjust strategy based on ET and stock level
  if et <= 0.5 or (et > 0.5 and game_state.stock < st):
    return Cooperate
  else:
    return Defect

  // Last round adjustment
  if game_state.round == game_state.total_rounds:
    return Defect
```
This strategy adapts to the opponents' behavior, exploits their defects when possible, and adjusts its approach based on the stock dynamics. ASE is exploitative, robust, and prepared to handle a wide range of opponent behaviors in the tournament.
'''

description_EXPLOITATIVE_346 = '''
To develop a robust and adaptive exploitative strategy for this Common Pool Resource Game, I'll outline a decision-making approach that leverages game parameters, state, and history.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to observe opponents' actions and gather information about their strategies.
2. **Early Rounds (t < r/3):**
	* If most players (> n/2) cooperated in the previous round, cooperate (C).
	* Otherwise, defect (D).
3. **Middle Rounds (r/3 ≤ t < 2r/3):**
	* Calculate the average stock consumption rate over the past few rounds (~t/3).
	* If the rate is high (> capacity/4), cooperate (C) to conserve stock.
	* Otherwise, defect (D).
4. **Late Rounds (t ≥ 2r/3):**
	* Assess the current stock level and remaining rounds.
	* If stock is low (< capacity/4) or few rounds remain (t > r - 2), cooperate (C) to maximize payoff from remaining stock.
	* Otherwise, defect (D).
5. **Opponent Analysis:**
	* Monitor opponents' actions and adjust the strategy based on their behavior:
		+ If an opponent consistently cooperates, exploit them by defecting (D) more frequently.
		+ If an opponent consistently defects, cooperate (C) more often to minimize losses.

**Additional Logic:**

* **Stock Threshold:** If the current stock level falls below a certain threshold (e.g., capacity/8), prioritize cooperation (C) to prevent depletion and maximize long-term payoffs.
* **Round Counter:** Keep track of the number of rounds remaining. As the game approaches its end, adjust the strategy to focus on short-term gains.

**Pseudocode:**

```python
def adaptive_exploiter(n, r, capacity, current_stock, round_num, opponent_actions):
    if round_num == 1:
        return "C"  # Cooperate in first round

    if round_num < r / 3:
        most_cooperated = sum(1 for action in opponent_actions[-1] if action == "C") > n / 2
        return "C" if most_cooperated else "D"

    avg_consumption_rate = calculate_average_consumption(opponent_actions, round_num)
    if avg_consumption_rate > capacity / 4:
        return "C"
    else:
        return "D"

    # ... (implement remaining logic and pseudocode for middle and late rounds)
```

**Exploitative Mindset:**

The Adaptive Exploiter strategy is designed to exploit opponents' behaviors while balancing short-term gains with long-term sustainability. By adapting to the game's state and history, AE can take advantage of cooperative opponents, minimize losses against defectors, and maximize payoffs from the remaining stock.

This strategy will perform well in a tournament setting, as it doesn't rely on coordination mechanisms or specific opponent behaviors. Its adaptive nature allows it to respond effectively to various strategies, making it a robust and competitive approach for the Common Pool Resource Game.
'''

description_EXPLOITATIVE_347 = '''
Here's a description of an exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C). This allows us to observe how other players behave and gather information about their strategies.
2. **Exploitation Phase**: From the second round onwards, use the following rules:
	* If the current stock level is above 75% of the capacity, play Defect (D). This is because there's still a substantial amount of resources available, and defecting will yield a higher payoff in the short term.
	* If the current stock level is between 50% and 75% of the capacity, play Cooperate (C) with probability 0.5, and Defect (D) with probability 0.5. This mixed strategy allows us to balance our own payoffs while also observing how other players respond to cooperation.
	* If the current stock level is below 50% of the capacity, play Cooperate (C). At this point, it's crucial to conserve resources and allow the stock to replenish for future rounds.
3. **Reaction to Opponent Behavior**: Monitor the actions of other players in previous rounds and adjust our strategy accordingly:
	* If an opponent has played Defect (D) more than 75% of the time, we play Defect (D) as well. This is because they're likely exploiting the common pool, and we should too to avoid being taken advantage of.
	* If an opponent has played Cooperate (C) more than 75% of the time, we play Cooperate (C) as well. This allows us to build trust and potentially create a mutually beneficial cooperative equilibrium.

**Edge Cases:**

1. **Last Round**: In the final round, always play Defect (D), regardless of the current stock level or opponent behavior. Since there's no future rounds, we should maximize our payoff in this last opportunity.
2. **Low Stock Levels**: If the current stock level is extremely low (< 10% of capacity), play Cooperate (C) to avoid complete depletion and allow for some growth.

**Pseudocode:**
```python
def adaptive_exploiter(stock_level, opponent_history, round_number):
    if round_number == 1:
        return "Cooperate"

    if stock_level >= 0.75 * capacity:
        return "Defect"
    elif 0.5 <= stock_level < 0.75 * capacity:
        # Mixed strategy: Cooperate with probability 0.5
        return random.choice(["Cooperate", "Defect"])
    else:
        return "Cooperate"

    # Adjust based on opponent behavior
    for opponent in opponent_history:
        if opponent["defection_rate"] > 0.75:
            return "Defect"
        elif opponent["cooperation_rate"] > 0.75:
            return "Cooperate"

    # Last round: Always Defect
    if round_number == r:
        return "Defect"

    # Low stock levels: Cooperate
    if stock_level < 0.1 * capacity:
        return "Cooperate"
```
This strategy aims to balance short-term gains with long-term sustainability, while also adapting to the behavior of other players. By monitoring opponent actions and adjusting our own strategy accordingly, we can exploit their weaknesses and achieve a higher overall payoff.
'''

description_EXPLOITATIVE_348 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behavior and to avoid severe stock depletion.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 50% of capacity, cooperate (C) with a probability p_c = 0.5 + (stock/capacity)/4. This encourages cooperation when the stock is healthy and reduces the likelihood of over-exploitation.
	* If the current stock level is below 50% of capacity, defect (D) with a probability p_d = 0.5 - (stock/capacity)/4. This increases the likelihood of defection when the stock is depleted, allowing for exploitation of remaining resources.
3. **Opponent Behavior Analysis**: Monitor opponents' actions and adjust the strategy based on their behavior:
	* If an opponent cooperates frequently (>75% of rounds), increase p_c by 0.1 to exploit their cooperation.
	* If an opponent defects frequently (>75% of rounds), decrease p_d by 0.1 to reduce the risk of over-exploitation.
4. **Last Round (t=r)**: Defect (D) to maximize individual payoff, as there are no future rounds to consider.

**Pseudocode:**
```python
def adaptive_stock_raider(n, r, capacity, stock_history):
    # Initialize variables
    p_c = 0.5  # Initial cooperation probability
    p_d = 0.5  # Initial defection probability

    for t in range(1, r+1):
        if t == 1:  # Initial round
            action = 'C'
        else:
            stock_level = stock_history[t-1]
            if stock_level > 0.5 * capacity:
                p_c = 0.5 + (stock_level/capacity)/4
                action = 'C' if random.random() < p_c else 'D'
            else:
                p_d = 0.5 - (stock_level/capacity)/4
                action = 'D' if random.random() < p_d else 'C'

        # Analyze opponent behavior and adjust strategy
        for i in range(n):
            if i != self.player_id:  # Ignore own actions
                opponent_cooperation_rate = sum(1 for j in range(t) if stock_history[j][i] == 'C') / t
                if opponent_cooperation_rate > 0.75:
                    p_c += 0.1
                elif opponent_cooperation_rate < 0.25:
                    p_d -= 0.1

        # Last round: always defect
        if t == r:
            action = 'D'

        return action
```
**Edge Cases:**

* First round: Cooperate to gather information and avoid severe stock depletion.
* Last round: Defect to maximize individual payoff.
* Opponent behavior analysis: Adjust strategy based on opponents' cooperation rates.

This adaptive strategy balances cooperation and defection, taking into account the current stock level, opponent behavior, and the number of rounds remaining. By analyzing opponents' actions and adjusting its own strategy, "Adaptive Stock Raider" aims to maximize individual payoff while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_349 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoff by adaptively responding to the game's state and history, while exploiting potential cooperation from other players.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C). This allows us to observe opponents' initial actions and gather information about their strategies.
2. **Middle Rounds (1 < t < r)**:
	* If the current stock level is high (> 75% of capacity), Defect (D) if at least one opponent defected in the previous round, otherwise Cooperate (C).
	* If the current stock level is moderate (25% ≤ stock ≤ 75% of capacity), Cooperate (C) if most opponents (≥ n/2) cooperated in the previous round, otherwise Defect (D).
	* If the current stock level is low (< 25% of capacity), Defect (D).
3. **Last Round (t=r)**: Always Defect (D). Since there's no future game to consider, we maximize our payoff by consuming as much as possible.

**Additional Logic:**

* **Monitor opponents' behavior**: Keep track of the number of rounds each opponent has defected and cooperated.
* **Detect potential cooperation**: If an opponent has cooperated in at least 75% of previous rounds, assume they might be a cooperative player.
* **Exploit cooperation**: When facing a detected cooperative opponent, Defect (D) more frequently to take advantage of their generosity.

**Pseudocode:**
```python
def adaptive_stock_raider(stock, capacity, n, r, history):
    if t == 1:  # initial round
        return C

    # Monitor opponents' behavior
    opponent_coops = [0] * n
    opponent_defects = [0] * n
    for prev_round in history:
        for i, action in enumerate(prev_round):
            if action == C:
                opponent_coops[i] += 1
            else:
                opponent_defects[i] += 1

    # Detect potential cooperation
    cooperative_opponents = []
    for i in range(n):
        if opponent_coops[i] / (t - 1) >= 0.75:
            cooperative_opponents.append(i)

    # Decision logic
    if stock > 0.75 * capacity:
        if any(opponent_defects[opponent] > 0 for opponent in range(n)):
            return D
        else:
            return C
    elif 0.25 <= stock / capacity <= 0.75:
        coop_count = sum(1 for action in history[-1] if action == C)
        if coop_count >= n / 2:
            return C
        else:
            return D
    else:  # low stock
        return D

    # Last round
    if t == r:
        return D
```
This strategy adapts to the game's state and history, exploiting potential cooperation from opponents while maximizing individual payoff. It is robust to a wide range of opponent behaviors and does not rely on coordination mechanisms or shared norms.
'''

description_EXPLOITATIVE_350 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) is a dynamic, exploitative strategy designed to maximize individual payoffs while adapting to various opponent behaviors and game state dynamics.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Observe the initial stock level and calculate the maximum potential payoff if all players cooperate.
	* If the calculated payoff is above a threshold (e.g., 75% of the maximum potential payoff), play Cooperate (C) to establish a baseline for future adaptations. Otherwise, play Defect (D).
2. **Subsequent Rounds (t>1):**
	* Monitor the current stock level and total consumption from previous rounds.
	* If the stock level is above 50% of the capacity:
		+ Calculate the average payoff per player in the last round.
		+ If the average payoff is below a threshold (e.g., 50% of the maximum potential payoff), play Defect (D) to exploit potential cooperators. Otherwise, play Cooperate (C).
	* If the stock level is below 50% of the capacity:
		+ Play Defect (D) to maximize individual payoffs in a depleted environment.
3. **Edge Cases:**
	* Last Round (t=r): Always play Defect (D), as there are no future rounds to consider.
	* Extremely Low Stock (<10% of capacity): Always play Defect (D) to avoid contributing to the stock's depletion.

**Adaptation Mechanisms:**

1. **Payoff Monitoring:** Continuously track individual and average payoffs per round to adjust the decision-making process.
2. **Stock Level Monitoring:** Regularly assess the current stock level to determine the optimal action based on the game state.

**Pseudocode (for illustration purposes):**
```python
def adaptive_stock_raider(n, r, capacity, stock, history):
    if t == 1:  # Initial Round
        max_payoff = calculate_max_payoff(capacity)
        threshold = 0.75 * max_payoff
        if stock > threshold:
            return Cooperate (C)
        else:
            return Defect (D)

    avg_last_round_payoff = history[-1].avg_payoff()
    stock_threshold = 0.5 * capacity

    if stock >= stock_threshold:
        if avg_last_round_payoff < 0.5 * max_payoff:
            return Defect (D)
        else:
            return Cooperate (C)
    else:
        return Defect (D)

def calculate_max_payoff(capacity):
    # Calculate maximum potential payoff assuming all players cooperate
    return capacity / (2 * n)

def avg_last_round_payoff(history):
    # Calculate average payoff per player in the last round
    return sum(player.payoff for player in history[-1].players) / n
```
This strategy is designed to be robust and adaptive, allowing it to perform well against a wide range of opponent behaviors. By monitoring payoffs and stock levels, ASR can adjust its actions to maximize individual gains while exploiting potential cooperators.
'''

description_EXPLOITATIVE_351 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) is a dynamic and responsive strategy designed to maximize payoffs by adapting to the game's state and opponents' behaviors.

**Decision Rules:**

1. **Initial Round:** In the first round, ASR will Cooperate (C). This initial cooperation serves as a probe to gauge opponents' behaviors and gather information about their strategies.
2. **Subsequent Rounds:** After the first round, ASR will use the following decision rule:

   - If the current stock level is above 75% of the capacity, ASR will Defect (D).
   - If the current stock level is between 50% and 75% of the capacity, ASR will Cooperate (C) if at least half of the opponents defected in the previous round. Otherwise, ASR will Defect (D).
   - If the current stock level is below 50% of the capacity, ASR will Cooperate (C).

**Pseudocode:**
```python
def adaptive_stock_raider(stock, capacity, history):
    if len(history) == 0:  # First round
        return 'C'
    
    opponents_defected = sum(1 for action in history[-1] if action == 'D')
    num_opponents = len(history[-1])
    
    if stock > 0.75 * capacity:
        return 'D'
    elif stock >= 0.5 * capacity and opponents_defected / num_opponents >= 0.5:
        return 'C'
    elif stock < 0.5 * capacity:
        return 'C'
    else:
        return 'D'
```
**Edge Cases:**

* **Last Round:** ASR will Defect (D) in the last round, as there is no future benefit to cooperation.
* **Low Stock Levels:** If the stock level drops below 25% of the capacity, ASR will Cooperate (C) to avoid complete depletion and potential long-term consequences.

**Exploitative Mindset:**

ASR prioritizes short-term gains by defecting when possible, while also considering the game's state and opponents' behaviors. By adapting to the stock level and opponents' actions, ASR aims to maximize its payoffs without relying on cooperation or coordination with other players.

This strategy is designed to perform well in a tournament setting, where opponents may employ various strategies. By being responsive to the game's dynamics, ASR can exploit weaknesses in opponents' strategies and achieve a competitive advantage.
'''

description_EXPLOITATIVE_352 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll introduce a decision-making framework that adapts to various opponent behaviors and maximizes my payoff over time.

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with probability 0.5, Defect (D) with probability 0.5. This random initial move helps to gauge opponents' behaviors without revealing my strategy.
2. **Subsequent Rounds (t>1):**
	* Calculate the average opponent cooperation rate (`avg_opponent_coop`) over previous rounds. For each opponent `i`, calculate their individual cooperation rate (`coop_rate_i`) as the number of times they cooperated divided by the total number of rounds played so far.
	* If `avg_opponent_coop` is above a certain threshold (`theta = 0.6`), Cooperate (C). This means that, on average, opponents have been cooperative, and I'll try to exploit this cooperation by reciprocating.
	* If `avg_opponent_coop` is below the threshold (`theta = 0.6`), Defect (D) with a probability proportional to the number of previous rounds where my payoff was lower than the maximum possible payoff (`max_payoff`). This means that if opponents have been mostly defecting, I'll start exploiting them by defecting more frequently.
3. **Additional Exploitation Rule:** If an opponent `i` has cooperated in the previous round and their cooperation rate (`coop_rate_i`) is above a certain threshold (`phi = 0.7`), Defect (D) with probability 1. This rule aims to exploit opponents who have consistently cooperated, as they are more likely to continue cooperating.
4. **Edge Cases:**
	* Last Round (t=r): Always Defect (D). In the final round, there's no incentive to cooperate, as the game is about to end.

**Pseudocode:**
```python
def adaptive_exploiter(n, capacity, r):
    theta = 0.6  # threshold for average opponent cooperation rate
    phi = 0.7   # threshold for individual opponent cooperation rate

    # Initialize variables
    avg_opponent_coop = 0
    coop_rate_i = [0] * n
    max_payoff = capacity / (2 * n)
    total_rounds_played = 0

    for t in range(1, r+1):
        if t == 1:
            # Initial round: random cooperation or defection
            action = random.choice([C, D])
        else:
            # Calculate average opponent cooperation rate
            avg_opponent_coop = sum(coop_rate_i) / n

            # Decide on action based on opponent behavior
            if avg_opponent_coop > theta:
                action = C  # Cooperate if opponents have been cooperative
            elif avg_opponent_coop < theta:
                # Defect with probability proportional to previous rounds' payoffs
                prob_defect = sum([my_payoff < max_payoff for my_payoff in self.payoffs]) / total_rounds_played
                action = D if random.random() < prob_defect else C

            # Additional exploitation rule: defect against consistent cooperators
            for i, coop_rate_i in enumerate(coop_rate_i):
                if coop_rate_i > phi and opponent_actions[i][t-1] == C:
                    action = D

        # Update variables
        total_rounds_played += 1
        coop_rate_i[opponent_actions[t-1].index(C)] += 1 / n
        self.payoffs.append(calculate_payoff(action, capacity))

    return self.payoffs
```
**Rationale:**

The Adaptive Exploiter strategy aims to balance cooperation and defection based on the observed behavior of opponents. By adapting to various opponent strategies, it can effectively exploit cooperative behaviors while minimizing losses against defectors.

In the initial round, a random choice between cooperation and defection helps to gauge opponents' behaviors without revealing my own strategy.

The decision rules in subsequent rounds take into account the average opponent cooperation rate and individual cooperation rates. If opponents have been mostly cooperative, I'll cooperate as well. However, if they've been defecting frequently, I'll start exploiting them by defecting more often.

The additional exploitation rule targets consistent cooperators, who are more likely to continue cooperating. By defecting against these players, I can maximize my payoff in the short term.

Overall, this strategy should perform well in a tournament setting, where various opponent behaviors and strategies will be encountered.
'''

description_EXPLOITATIVE_353 = '''
**Exploitative Strategy: Adaptive Stock Depletion (ASD)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to observe opponents' behavior and gather information about their strategies.
2. **Stock Threshold:** Define a stock threshold, `ST`, as 0.5 * capacity. If the current stock is below `ST`, defect (D) to maximize immediate payoff. Otherwise, cooperate (C).
3. **Opponent Behavior Analysis:** Track opponents' cooperation rates over the last `k` rounds (e.g., `k=3`). Calculate the average cooperation rate (`ACR`) for each opponent.
4. **Exploitation Logic:**
	* If an opponent's `ACR` is above 0.7, defect (D) to exploit their cooperative behavior.
	* If an opponent's `ACR` is below 0.3, cooperate (C) to avoid triggering a full-scale defection cascade.
	* For opponents with `ACR` between 0.3 and 0.7, use the stock threshold rule (step 2).
5. **Dynamic Adjustment:** Adjust the stock threshold (`ST`) based on the game's progress:
	+ If the current round is in the first half of the game (`t < r/2`), increase `ST` by 10% every 2 rounds to encourage cooperation.
	+ In the second half of the game, decrease `ST` by 10% every 2 rounds to adapt to potential increased exploitation.

**Edge Cases:**

1. **Last Round:** Defect (D) in the last round to maximize final payoff, as there's no future game state to consider.
2. **Stock Depletion:** If the current stock is very low (`stock < 0.1 * capacity`), defect (D) to ensure some payoff, even if it means depleting the stock.

**Pseudocode:**
```python
def ASD(strategy, opponents, state):
    # Initial Round
    if state.round == 1:
        return "C"

    # Stock Threshold
    ST = 0.5 * state.capacity
    if state.stock < ST:
        return "D"

    # Opponent Behavior Analysis
    ACRs = {}
    for opponent in opponents:
        ACR = analyze_opponent_behavior(opponent, k=3)
        ACRs[opponent] = ACR

    # Exploitation Logic
    for opponent, ACR in ACRs.items():
        if ACR > 0.7:
            return "D"
        elif ACR < 0.3:
            return "C"

    # Dynamic Adjustment
    if state.round < state.r / 2:
        ST *= 1.1  # increase stock threshold every 2 rounds
    else:
        ST *= 0.9  # decrease stock threshold every 2 rounds

    return "D" if state.stock < ST else "C"

def analyze_opponent_behavior(opponent, k):
    # Calculate average cooperation rate over last k rounds
    cooperation_rates = []
    for round in range(k):
        cooperation_rate = opponent.cooperation_rate(round)
        cooperation_rates.append(cooperation_rate)
    return sum(cooperation_rates) / len(cooperation_rates)
```
This strategy is designed to be adaptive and exploitative, taking into account the game's state, opponents' behavior, and dynamic adjustments to maximize payoff.
'''

description_EXPLOITATIVE_354 = '''
Here's a strategic approach for the Common Pool Resource Game that focuses on exploiting opponents while adapting to the game state and history:

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Rounds (t < n/2):** Cooperate (C) in the first few rounds to:
	* Gather information about opponents' behaviors.
	* Allow the stock to grow, increasing potential payoffs for all players.
	* Establish a baseline for adaptive adjustments later on.
2. **Middle Game (n/2 ≤ t < 3n/4):** Observe the history of opponent actions and adjust accordingly:
	* If most opponents (>50%) cooperate in the previous round, defect (D) to exploit their cooperation.
	* If most opponents (>50%) defect in the previous round, cooperate (C) to rebuild the stock and encourage others to follow suit.
3. **Late Game (t ≥ 3n/4):** Focus on maximizing individual payoffs:
	* Defect (D) if the current stock is high (>75% of capacity), as there's less risk of over-exploitation.
	* Cooperate (C) if the current stock is low (<25% of capacity), to help rebuild and ensure some payoff in subsequent rounds.

**Edge Cases:**

1. **First Round:** Always cooperate (C) to initiate a cooperative tone and gather information about opponents' initial behaviors.
2. **Last Round (t = r):** Defect (D) unconditionally, as there's no future stock growth or repercussions for over-exploitation.
3. **Extreme Stock Levels:**
	* If the stock is critically low (<10% of capacity), cooperate (C) to help rebuild and avoid complete depletion.
	* If the stock is extremely high (>90% of capacity), defect (D) to exploit the excess resources.

**Pseudocode:**

```
function AdaptiveExploiter(stock, round, history):
  if round < n/2:
    return COOPERATE
  elif round >= n/2 and round < 3n/4:
    opponents_cooperated = sum(opponent Cooperates in previous round) / n
    if opponents_cooperated > 0.5:
      return DEFECT
    else:
      return COOPERATE
  else: // Late game
    if stock > 0.75 * capacity:
      return DEFECT
    elif stock < 0.25 * capacity:
      return COOPERATE

function ExtremeStockLevels(stock):
  if stock < 0.1 * capacity:
    return COOPERATE
  elif stock > 0.9 * capacity:
    return DEFECT

// Main logic
if ExtremeStockLevels(stock) != NULL:
  return ExtremeStockLevels(stock)
else:
  return AdaptiveExploiter(stock, round, history)
```

**Rationale:**

This strategy aims to balance short-term gains with long-term sustainability by adapting to the game state and opponent behaviors. By cooperating in early rounds, it encourages others to do the same, potentially leading to higher overall payoffs. As the game progresses, the strategy becomes more exploitative, taking advantage of opponents' cooperative tendencies while also adjusting for extreme stock levels to avoid over-exploitation or depletion.
'''

description_EXPLOITATIVE_355 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize its payoff by adapting to the game's state and history while exploiting the opponent's behavior.

**Decision Rules:**

1. **Initial Round:** Play `D` (Defect) in the first round to probe opponents' behavior and gather information about their strategies.
2. **Stock-dependent Cooperation:** In subsequent rounds, play `C` (Cooperate) if the current stock level is below a certain threshold (`stock_threshold`). This value will be calculated based on the game's parameters and history.

`stock_threshold = capacity / (2 * n)`

This ensures that when the stock is low, cooperation helps to replenish it, while still allowing for some exploitation.

3. **Opponent Exploitation:** If an opponent plays `D` in a previous round, play `D` in the next round as well, to punish them and exploit their greedy behavior.
4. **History-dependent Defection:** If the average payoff of all players in the previous round is above a certain threshold (`payoff_threshold`), play `D` in the next round to take advantage of the opponents' generosity.

`payoff_threshold = (capacity / n) * 0.75`

This ensures that if opponents are cooperating too much, our strategy will exploit this by defecting and gaining an advantage.
5. **Stock Growth-based Defection:** If the stock growth in the previous round is below a certain threshold (`growth_threshold`), play `D` in the next round to maximize payoff before the stock depletes.

`growth_threshold = (2 * capacity) / 3`

**Edge Cases:**

* In the last round, always play `D` to maximize final payoff.
* If an opponent's strategy is unknown or their actions are inconsistent, default to playing `C` in the next round.

Pseudocode:
```python
def adaptive_stock_raider(n, capacity, stock, history):
    if current_round == 1:  # Initial Round
        return "D"
    
    stock_threshold = capacity / (2 * n)
    payoff_threshold = (capacity / n) * 0.75
    growth_threshold = (2 * capacity) / 3
    
    if stock < stock_threshold:
        return "C"  # Cooperate to replenish stock
    
    opponent_defected_last_round = history[-1].opponent_action == "D"
    if opponent_defected_last_round:
        return "D"  # Punish and exploit opponent's defect
    
    avg_payoff_last_round = sum(history[-1].payoffs) / n
    if avg_payoff_last_round > payoff_threshold:
        return "D"  # Exploit opponents' generosity
    
    stock_growth_last_round = history[-1].stock_growth
    if stock_growth_last_round < growth_threshold:
        return "D"  # Maximize payoff before stock depletes
    
    return "C"  # Default to cooperate
```
This strategy aims to balance cooperation and defection based on the game's state and history, while adapting to opponents' behavior. By exploiting their actions and adjusting our own, we aim to maximize our payoff in the tournament.
'''

description_EXPLOITATIVE_356 = '''
I'll design a exploitative strategy that adapts to various opponent behaviors and maximizes my payoff over the course of the game.

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gather information about opponents' behavior and to maintain a high initial stock level.
2. **Early Game (t>1, stock > capacity/2):** Defect (D) if at least one opponent defected in the previous round. Otherwise, cooperate (C). This allows me to punish opponents who exploit the common pool while maintaining cooperation when possible.
3. **Mid-Game (t>1, capacity/4 < stock ≤ capacity/2):** Switch to a mixed strategy:
	* Cooperate with probability p = (stock/capacity)^(1/n), where n is the number of players. This means I'll cooperate more often as the stock level approaches zero.
	* Defect with probability 1-p.
4. **Endgame (t=r, or stock ≤ capacity/4):** Always defect (D). In the final round or when the stock level is critically low, prioritize personal gain over cooperation.

Pseudocode:
```python
def Adaptive_Exploiter(stock, capacity, n, t, history):
  if t == 1:  # Initial Round
    return 'C'
  
  if stock > capacity / 2:  # Early Game
    opponents_defected = False
    for opponent_action in history[-1]:
      if opponent_action == 'D':
        opponents_defected = True
        break
    if opponents_defected:
      return 'D'
    else:
      return 'C'
  
  if capacity / 4 < stock <= capacity / 2:  # Mid-Game
    p = (stock / capacity) ** (1 / n)
    return 'C' with probability p, 'D' otherwise
  
  # Endgame or critically low stock level
  return 'D'
```
**Handling Edge Cases:**

* In the first round, I cooperate to gather information and maintain a high initial stock level.
* In the final round or when the stock level is critically low (≤ capacity/4), I prioritize personal gain by always defecting.

**Exploitative Mindset:**
This strategy is designed to exploit opponents' cooperation while adapting to various behaviors. By initially cooperating, I create an opportunity for opponents to trust me and potentially cooperate more often. However, if opponents defect, I quickly adapt and punish them by defecting as well. As the game progresses, my mixed strategy in the mid-game phase allows me to balance personal gain with maintaining a healthy stock level.

This strategy should perform well against a wide range of opponent behaviors and is robust enough to handle different game parameters and states.
'''

description_EXPLOITATIVE_357 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behavior and initial stock level.
2. **Early Game (t>1, stock > 0.75 \* capacity)**: Defect (D) if the number of cooperators in the previous round is greater than or equal to n/2; otherwise, Cooperate (C).
3. **Mid-Game (t>1, 0.25 \* capacity ≤ stock ≤ 0.75 \* capacity)**: Cooperate (C) if the total consumption in the previous round was high (> 0.5 \* capacity); otherwise, Defect (D).
4. **Late Game (t>1, stock < 0.25 \* capacity)**: Defect (D) to maximize individual payoff before the game ends.
5. **Last Round (t=r)**: Defect (D) to extract as much value as possible from the remaining stock.

Pseudocode:
```
function adaptiveStockRaider(t, n, capacity, stock_history, action_history):
  if t == 1:
    return C
  elif stock > 0.75 * capacity:
    num_cooperators = sum(action_history[-1] == C for _ in range(n))
    if num_cooperators >= n/2:
      return D
    else:
      return C
  elif 0.25 * capacity <= stock <= 0.75 * capacity:
    total_consumption = sum(stock_history[-1] - stock_history[-2])
    if total_consumption > 0.5 * capacity:
      return C
    else:
      return D
  elif stock < 0.25 * capacity:
    return D
  elif t == r:
    return D
```
Rationale:

* In the initial round, cooperating allows us to gather information about opponents' behavior and the initial stock level.
* In the early game, defecting when there are many cooperators ensures we maximize our individual payoff while also reducing the overall stock consumption.
* In the mid-game, cooperating when total consumption is high helps maintain a sustainable stock level and allows for future exploitation. Defecting otherwise maximizes short-term gains.
* In the late game, defecting extracts as much value as possible from the remaining stock before it's depleted.
* In the last round, defecting ensures we extract maximum value from the remaining stock.

This strategy is designed to be adaptive and robust against a wide range of opponent behaviors. By monitoring the stock level and opponents' actions, we adjust our behavior to maximize individual payoffs while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_358 = '''
**Exploitative Strategy: "Adaptive Stock Predator"**

Our goal is to design a robust and adaptive strategy that exploits various opponent behaviors while ensuring long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and stock dynamics.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term gains.
	* If the current stock level is between 25% and 75% of capacity, use a mixed strategy:
		+ With probability p = (current_stock / capacity), Cooperate (C).
		+ With probability 1 - p, Defect (D).
	* If the current stock level is below 25% of capacity, Cooperate (C) to conserve the resource.
3. **Last Round (t=r):** Defect (D) to maximize final payoff, as there are no future rounds to consider.

**Additional Logic:**

* **Opponent Monitoring:** Track the number of opponents who cooperated in each round and adjust our mixed strategy accordingly:
	+ If more than 50% of opponents cooperated, increase p by 0.1.
	+ If fewer than 50% of opponents cooperated, decrease p by 0.1.
* **Stock Trend Analysis:** Monitor the stock level trend over the past three rounds and adjust our mixed strategy:
	+ If the stock level has been increasing or stable, increase p by 0.05.
	+ If the stock level has been decreasing, decrease p by 0.05.

**Pseudocode:**
```markdown
# Initialize variables
current_stock = capacity
rounds_left = r

while rounds_left > 0:
    if current_round == 1:
        # Initial round: Cooperate to gather information
        action = C
    elif current_round < r:
        # Middle rounds: Adaptive mixed strategy
        if current_stock >= 0.75 * capacity:
            action = D
        elif current_stock >= 0.25 * capacity and current_stock < 0.75 * capacity:
            p = (current_stock / capacity)
            action = random_choice([C, D], [p, 1 - p])
        else:
            action = C
    else:
        # Last round: Defect to maximize final payoff
        action = D

    # Opponent monitoring and adjustment
    opponent_cooperations = count(C actions by opponents)
    if opponent_cooperations > 0.5 * n:
        p += 0.1
    elif opponent_cooperations < 0.5 * n:
        p -= 0.1

    # Stock trend analysis and adjustment
    stock_trend = analyze_stock_level_over_last_3_rounds()
    if stock_trend == increasing or stable:
        p += 0.05
    elif stock_trend == decreasing:
        p -= 0.05

    # Update current stock level and move to next round
    current_stock = update_stock(current_stock, actions)
    rounds_left -= 1
```
This strategy is designed to be exploitative, adaptive, and robust to various opponent behaviors. By monitoring opponents' actions and adjusting our mixed strategy accordingly, we aim to maximize our payoffs while ensuring the long-term sustainability of the common pool resource.
'''

description_EXPLOITATIVE_359 = '''
Here's a exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if stock ≥ capacity/2; otherwise, Defect (D)
	* This initial decision sets the tone for the game and adapts to the starting conditions
2. **Middle Rounds (2 ≤ t < r):**
	* Observe opponents' previous-round actions and calculate the average opponent cooperation rate (OCR) as the proportion of players who cooperated in the previous round
	* If OCR ≥ 0.5, Cooperate (C); otherwise, Defect (D)
	* This rule adapts to the group's behavior and exploits cooperation when it's prevalent
3. **Final Round (t=r):**
	* Defect (D) regardless of stock or opponent actions
	* In the last round, there's no future benefit from cooperating, so we maximize our payoff by defecting

**Additional Rules:**

1. **Low Stock Conditions:** If stock ≤ capacity/4, Defect (D) for the next 2 rounds to quickly replenish the stock
	* This rule ensures that we don't get stuck with a low stock and allows us to exploit potential cooperation from others in the future
2. **Opponent Defection Dominance:** If ≥ 75% of opponents defected in the previous round, Defect (D) for the next 2 rounds
	* This rule recognizes when opponents are predominantly defecting and adjusts our strategy to minimize losses

**Pseudocode:**

```
function AdaptiveExploiter(stock, capacity, n, t, opponent_actions):
    if t == 1:
        return C if stock >= capacity/2 else D
    
    OCR = calculate_opponent_cooperation_rate(opponent_actions)
    
    if OCR >= 0.5:
        return C
    else:
        return D
    
    # Low Stock Conditions
    if stock <= capacity/4:
        for next 2 rounds:
            return D
    
    # Opponent Defection Dominance
    opponent_defection_rate = calculate_opponent_defection_rate(opponent_actions)
    if opponent_defection_rate >= 0.75:
        for next 2 rounds:
            return D
    
    # Final Round
    if t == r:
        return D

function calculate_opponent_cooperation_rate(opponent_actions):
    # Calculate the proportion of opponents who cooperated in the previous round
    cooperation_count = sum(1 for action in opponent_actions if action == C)
    OCR = cooperation_count / n
    return OCR

function calculate_opponent_defection_rate(opponent_actions):
    # Calculate the proportion of opponents who defected in the previous round
    defection_count = sum(1 for action in opponent_actions if action == D)
    return defection_count / n
```

This Adaptive Exploiter strategy is designed to be robust and exploitative, taking into account various opponent behaviors and adapting to changes in the game state. By balancing cooperation and defection based on observed behavior and stock conditions, we aim to maximize our payoff while minimizing losses.
'''

description_EXPLOITATIVE_360 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize payoffs by adaptively exploiting the current stock level and opponents' behavior while minimizing the risk of over-consumption.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) if the initial stock is close to capacity (> 90%); otherwise, Defect (D). This allows for a gentle start, avoiding excessive consumption.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 50%, play C if at least half of the opponents cooperated in the previous round; otherwise, play D. This encourages cooperation when the stock is healthy and opponents are cooperative.
	* If the current stock level is between 30% and 50%, play D to take advantage of the remaining resources.
	* If the current stock level is below 30%, play C to conserve the remaining stock and avoid depletion.
3. **Last Round (t=r):** Defect (D) unconditionally, as there's no future round to consider.

**Edge Case Handling:**

1. **Tiebreaker:** In case of a tie in the number of cooperating opponents, default to playing D to maintain an exploitative stance.
2. **Opponent Behavior Ambiguity:** If the opponent's behavior is unclear (e.g., due to imperfect information), assume they will play D and adjust accordingly.

**Pseudocode:**
```python
def adaptive_stock_raider(stock, capacity, opponents_last_actions):
    if current_round == 1:
        if stock > 0.9 * capacity:
            return 'C'
        else:
            return 'D'

    # Subsequent rounds
    cooperating_opponents = sum(1 for action in opponents_last_actions if action == 'C')
    if cooperating_opponents >= len(opponents_last_actions) / 2 and stock > 0.5 * capacity:
        return 'C'
    elif stock > 0.3 * capacity:
        return 'D'
    else:
        return 'C'

    # Last round
    if current_round == r:
        return 'D'
```
**Exploitative Mindset:**

The Adaptive Stock Raider strategy is designed to capitalize on the existing stock level and opponents' behavior while minimizing the risk of over-consumption. By cooperating when the stock is healthy and opponents are cooperative, it encourages cooperation and maintains a balanced approach. When the stock is low or opponents are defecting, it defects to maximize payoffs, demonstrating an exploitative mindset.

This strategy should perform well in a tournament setting against independent strategies developed by other AI systems, as it adapts to various opponent behaviors while prioritizing its own interests.
'''

description_EXPLOITATIVE_361 = '''
I'll design a strategic approach that balances exploitation with adaptability, considering the dynamic state and history of the game.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and set a precedent for potential cooperation.
2. **Assess Opponent Behavior**: After each round, calculate the average opponent payoff (`avg_opponent_payoff`) and compare it with your own payoff (`my_payoff`). This helps identify whether opponents are generally cooperating or defecting.
3. **Exploitation Threshold**: Define an exploitation threshold (`exploit_threshold`) as a function of the current stock level and number of rounds remaining:

`exploit_threshold = (stock / capacity) * (r - t + 1) / r`

where `t` is the current round.

4. **Cooperate or Defect**:
	* If `avg_opponent_payoff` is below your own payoff (`my_payoff`) and the exploitation threshold is not met, Cooperate (C).
	* Otherwise, Defect (D).

Pseudocode for decision rules:

```
IF first_round THEN
  action = C
ELSE
  avg_opponent_payoff = calculate_avg_opponent_payoff()
  my_payoff = get_my_payoff()
  exploit_threshold = calculate_exploit_threshold(stock, capacity, r, t)
  
  IF (avg_opponent_payoff < my_payoff) AND (exploit_threshold NOT MET) THEN
    action = C
  ELSE
    action = D
```

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.
2. **Low Stock Levels**: If the stock level falls below a certain threshold (`low_stock_threshold`), Cooperate (C) to help replenish the stock and prevent depletion.

**Additional Considerations:**

1. **Stock Replenishment**: Monitor the stock growth rate and adjust strategy accordingly. If the growth rate is high, it may be beneficial to cooperate more frequently to maintain a healthy stock level.
2. **Adaptation**: Continuously update `avg_opponent_payoff` and `my_payoff` values to reflect changing opponent behavior and adapt your strategy as needed.

**Exploitative Mindset:**

The Adaptive Exploiter (AE) strategy is designed to take advantage of opponents' cooperation while minimizing the risk of being exploited. By monitoring opponent payoffs and adjusting its own behavior, AE aims to maximize individual payoff while contributing to a sustainable common pool resource.
'''

description_EXPLOITATIVE_362 = '''
I'll design a strategic approach that's adaptive and exploitative, leveraging game parameters, state, and history. Here's my proposed strategy:

**Strategy Name:** "Adaptive Stockwatcher"

**Decision Rules:**

1. **Initial Rounds (t ≤ 2): Cooperate**
In the first two rounds, play C to gather information about opponents' behavior and allow the stock to grow.
2. **Stock-based Thresholding**: Introduce a dynamic threshold `T` that adjusts based on the current stock level (`S`). Set `T = S / (2n)`. This threshold represents a "sustainable" consumption level.
3. **Cooperate if opponents cooperate**: If, in the previous round, the total consumption was below or equal to `T`, play C. This encourages cooperation and sustainable harvesting.
4. **Defect if opponents defect**: If, in the previous round, the total consumption exceeded `T`, play D. This exploits opponents' over-harvesting and aims to secure a larger share of the stock.
5. **Punish repeated defectors**: Maintain a simple memory of opponents' actions for the last two rounds. If an opponent has defected in both previous rounds, play D against them. This discourages persistent over-harvesting behavior.

**Edge Cases:**

1. **First Round:** Cooperate (C) to gather information and allow the stock to grow.
2. **Last Round (t = r):** Defect (D), as there's no future round to consider, and maximizing payoff is the only concern.
3. **Low Stock Levels (S ≤ 2n):** If the stock level falls critically low, switch to a "survival mode" where you always play D to secure any remaining resources.

**Adaptive Features:**

1. **Adjust `T` dynamically**: Update the threshold value based on changes in the stock level to maintain an optimal balance between cooperation and exploitation.
2. **Monitor opponents' behavior**: Continuously observe and adjust your strategy according to opponents' actions, allowing you to adapt to changing circumstances.

**Pseudocode:**

```python
def AdaptiveStockwatcher(game_state):
    # Initialize variables
    T = game_state.stock / (2 * n)
    
    if current_round <= 2:
        return 'C'
    
    # Assess previous round's total consumption
    prev_consumption = sum(opponent_actions.values())
    
    if prev_consumption <= T:
        return 'C'
    else:
        return 'D'
    
    # Punish repeated defectors
    for opponent, actions in opponent_history.items():
        if len(actions) >= 2 and all(action == 'D' for action in actions[-2:]):
            return 'D'
    
    # Handle low stock levels
    if game_state.stock <= 2 * n:
        return 'D'

    return 'C'
```

This strategy, Adaptive Stockwatcher, balances cooperation and exploitation by adapting to opponents' behavior and the current state of the game. By dynamically adjusting its threshold value and punishing repeated defectors, it aims to maximize payoffs while maintaining a sustainable stock level.
'''

description_EXPLOITATIVE_363 = '''
**Exploitative Strategy: Adaptive Stock-Dependent Exploitation (ASDE)**

The ASDE strategy aims to balance short-term gains with long-term sustainability by adapting its behavior based on the current stock level and the history of opponent actions.

**Decision Rules:**

1. **Initial Rounds:** In the first round, play Cooperate (C) to test opponents' willingness to cooperate.
2. **Stock-Dependent Threshold:** Define a threshold stock level `T = capacity / 2`. If the current stock level is above this threshold (`stock > T`), play Defect (D). Otherwise, play Cooperate (C).
3. **Opponent Behavior Monitoring:** Track the number of opponents playing Defect (D) in each round (`num_defectors`). Update `num_defectors` after observing opponent actions.
4. **Adaptive Exploitation:** If `stock > T` and `num_defectors >= n/2`, play Defect (D). This condition indicates that enough opponents are exploiting the stock, so it's beneficial to join them.
5. **Conservative Reversion:** If the stock level falls below a critical threshold (`stock < capacity / 4`), revert to Cooperate (C) for one round to help replenish the stock.

**Edge Case Handling:**

* **Last Round:** In the final round, play Defect (D) if `stock > T`, as there's no future cost to over-exploitation.
* **Tie-Breaking:** If multiple opponents are tied in terms of their Defection frequency (`num_defectors`), prioritize playing Cooperate (C) to avoid mutual over-exploitation.

**Pseudocode:**
```python
def ASDE(n, capacity, stock_history):
    T = capacity / 2
    num_defectors = [0] * n

    for round in range(r):
        if round == 0:
            # Initial Round: Cooperate to test opponents
            action = 'C'
        elif stock > T and sum(num_defectors) >= n/2:
            # Adaptive Exploitation: Defect when enough opponents do so
            action = 'D'
        elif stock < capacity / 4:
            # Conservative Reversion: Cooperate to replenish stock
            action = 'C'
            if round > 0 and action != previous_action:
                num_defectors = [0] * n
        else:
            # Default: Defect when stock is above threshold
            action = 'D'

        # Update opponent behavior tracking
        for i in range(n):
            if opponents[i].action == 'D':
                num_defectors[i] += 1

        previous_action = action

    return action
```
The ASDE strategy balances short-term gains with long-term sustainability by adapting to the current stock level and opponent behavior. It exploits opponents who tend to Defect while avoiding mutual over-exploitation when possible.
'''

description_EXPLOITATIVE_364 = '''
I'll design a exploitative strategy for this Common Pool Resource Game that adapts to various opponent behaviors and maximizes payoffs based on game parameters, state, and history.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior.
2. **Subsequent Rounds**:
	* If the stock level is high (> 75% of capacity), Defect (D) if the number of defectors in the previous round is greater than or equal to the number of cooperators. Otherwise, Cooperate (C).
	* If the stock level is medium (25% ≤ stock ≤ 75%), Cooperate (C) if the total payoff from the last two rounds is higher when cooperating. Otherwise, Defect (D).
	* If the stock level is low (< 25% of capacity), Defect (D) regardless of opponents' behavior.
3. **Last Round**: Always Defect (D) to maximize payoffs.

**Handling Edge Cases:**

1. **First Round**: Cooperate (C) as per decision rule 1.
2. **Last Round**: Defect (D) as per decision rule 3.
3. **Tiebreakers**: In cases where the number of cooperators and defectors is equal, or when payoffs are identical for cooperating and defecting, default to Cooperate (C).

**Exploitative Mindset:**

AE aims to exploit opponents' cooperative behavior while minimizing its own losses from over-harvesting. By initially cooperating, AE gathers information about opponents' behavior and adapts accordingly. When the stock level is high, AE defects if opponents are defecting, as cooperation would lead to reduced payoffs. In medium-stock situations, AE chooses the action that yielded higher total payoffs in the last two rounds, effectively punishing or rewarding opponents for their behavior. When the stock level is low, AE prioritizes its own interests by always defecting.

**Pseudocode:**
```python
def AdaptiveExploiter(n, capacity, r):
    # Initialize variables
    history = []  # store actions and payoffs for each round

    for t in range(1, r+1):
        if t == 1:
            action = 'C'  # Cooperate in the first round
        else:
            stock_level = get_stock_level()
            prev_round_defectors = count_defectors(history[-1])
            prev_round_cooperators = n - prev_round_defectors

            if stock_level > 0.75 * capacity:
                if prev_round_defectors >= prev_round_cooperators:
                    action = 'D'  # Defect if opponents defected
                else:
                    action = 'C'
            elif 0.25 <= stock_level / capacity <= 0.75:
                coop_payoff = calculate_coop_payoff(history[-2:])
                defect_payoff = calculate_defect_payoff(history[-2:])

                if coop_payoff > defect_payoff:
                    action = 'C'  # Cooperate if cooperation yielded higher payoff
                else:
                    action = 'D'
            else:
                action = 'D'  # Defect when stock level is low

        if t == r:
            action = 'D'  # Always defect in the last round

        history.append((action, get_payoff(action)))

    return total_payoff(history)
```
This strategy will be implemented as an algorithm and tested against other independent strategies developed by AI systems.
'''

description_EXPLOITATIVE_365 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adapting to the game's dynamic state and history while exploiting opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe the initial stock level and capacity.
	* Cooperate (C) if the initial stock is above 75% of the capacity; otherwise, Defect (D).
2. **Middle Rounds (1 < t < r)**:
	* Calculate the average payoff per player in the previous round (`prev_avg_payoff`).
	* If `prev_avg_payoff` is greater than or equal to the stock level divided by 2n (i.e., the cooperative payoff), Cooperate (C); otherwise, Defect (D).
3. **Last Round (t=r)**:
	* Defect (D) unconditionally, as there are no future rounds to consider.

**Adaptive Component:**

* Track the opponent's behavior by calculating their average cooperation rate (`opp_coop_rate`) over the game history.
* If `opp_coop_rate` is above 0.5, assume opponents are cooperative and adjust our strategy:
	+ In middle rounds, if the stock level is below 50% of the capacity, Cooperate (C) to avoid depleting the stock; otherwise, Defect (D).
	+ In the last round, still Defect (D), but consider this information for future adaptations.

**Edge Cases:**

* If the stock level falls to 0 or very close to 0, Defect (D) unconditionally, as cooperation will yield no payoff.
* If an opponent's action is unknown or uncertain, assume they will Defect (D) and adjust our strategy accordingly.

**Pseudocode:**
```
function AdaptiveStockRaider(n, r, capacity, stock_history):
  // Initialize variables
  prev_avg_payoff = 0
  opp_coop_rate = 0

  for t in range(1, r+1):
    if t == 1:
      // Initial round
      if stock_history[0] >= 0.75 * capacity:
        action = C
      else:
        action = D
    elif t < r:
      // Middle rounds
      prev_avg_payoff = calculate_average_payoff(stock_history, n)
      if prev_avg_payoff >= stock_history[t-1] / (2*n):
        action = C
      else:
        action = D

      // Adaptive component
      opp_coop_rate = calculate_opponent_cooperation_rate(stock_history, n)
      if opp_coop_rate > 0.5 and stock_history[t-1] < 0.5 * capacity:
        action = C

    else:
      // Last round
      action = D

    // Edge cases
    if stock_history[t-1] <= 0 or abs(stock_history[t-1]) < 1e-6:
      action = D

    return action
```
This strategy is designed to be exploitative, adaptive, and robust to various opponent behaviors. By tracking the game's history and adjusting our actions accordingly, we aim to maximize individual payoffs while minimizing the impact of opponents' strategies.
'''

description_EXPLOITATIVE_366 = '''
**Exploitative Strategy: Adaptive Stock-Based Exploitation (ASBE)**

The ASBE strategy is designed to exploit a wide range of opponent behaviors while being adaptive and robust. The decision rules are based on the current stock level, number of rounds played, and observed opponent actions.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with probability 0.5, Defect (D) with probability 0.5. This initial randomization helps to gather information about opponents' behaviors.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above a certain threshold (e.g., 75% of capacity), Cooperate (C).
	* If the current stock level is below this threshold, Defect (D) with probability p, and Cooperate (C) with probability (1-p). The value of p is calculated based on the observed opponent actions:
		+ Calculate the proportion of opponents that defected in the previous round (p_defect).
		+ Set p = max(0.5, p_defect). This ensures that if most opponents are defecting, ASBE will also defect more often.
3. **Last Round (t=r):** Defect (D) with probability 1. In the final round, there is no need to conserve the stock for future rounds.

**Pseudocode:**
```markdown
ASBE_Strategy(stock, t, r, capacity, opponent_actions):
    if t == 1:
        # Initial randomization
        return Cooperate (C) with probability 0.5, Defect (D) with probability 0.5

    threshold = 0.75 * capacity
    if stock >= threshold:
        return Cooperate (C)
    else:
        p_defect = proportion_of_opponents_that_defected(opponent_actions)
        p = max(0.5, p_defect)
        return Defect (D) with probability p, Cooperate (C) with probability (1-p)

    if t == r:
        # Last round
        return Defect (D) with probability 1
```
**Rationale:**

* By cooperating when the stock level is high, ASBE helps to maintain a sustainable stock and avoids over-exploitation.
* When the stock level falls below the threshold, ASBE becomes more aggressive and defects more often. This allows it to exploit opponents who are conserving the stock too much.
* The adaptive nature of p ensures that ASBE responds to changes in opponent behaviors, increasing its defect rate if most opponents are defecting.
* In the final round, ASBE defects with certainty, as there is no need to conserve the stock for future rounds.

**Robustness:**

ASBE's design makes it robust against a wide range of opponent behaviors:

* If all opponents cooperate, ASBE will also cooperate and maintain a sustainable stock.
* If most opponents defect, ASBE will adapt and increase its defect rate, exploiting their behavior.
* If opponents use a mix of cooperation and defection, ASBE will respond accordingly, balancing exploitation with conservation.

By being adaptive and exploitative, the ASBE strategy is well-suited for a tournament setting where it will face independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_367 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy aims to maximize individual payoffs by adaptively responding to the evolving game state and opponents' behaviors. This strategy prioritizes exploitation over cooperation, while maintaining a level of robustness against various opponent tactics.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) with probability 0.5 to gather information about opponents' initial actions.
2. **Early Rounds (2 ≤ t < r/2):**
	* Observe the average payoff of all players in the previous round (π_avg).
	* If π_avg > stock/(2n), defect (D). This indicates that opponents are not over-harvesting, and you can exploit this by taking a larger share.
	* Otherwise, cooperate (C) to avoid depleting the stock too quickly.
3. **Mid-Game Rounds (r/2 ≤ t < 3r/4):**
	* Calculate the average cooperation rate of opponents in the previous round (coop_rate).
	* If coop_rate > 0.5, defect (D). This suggests that opponents are being overly cooperative, and you can take advantage by exploiting this.
	* Otherwise, cooperate (C) to maintain a stable stock level.
4. **Late Rounds (3r/4 ≤ t < r):**
	* Assess the current stock level (S).
	* If S > capacity/2, defect (D). With a relatively high stock level, you can safely exploit this opportunity for higher payoffs.
	* Otherwise, cooperate (C) to conserve the remaining stock.
5. **Final Round (t=r):**
	* Defect (D) unconditionally, as there is no future game state to consider.

**Edge Cases:**

* If an opponent's action is unknown or ambiguous, assume they cooperated in the previous round.
* In case of a tie in the decision-making process, choose the more exploitative option (defect).

**Pseudocode:**
```python
function AdaptivePredator(stock, capacity, n, t, r):
  if t == 1:
    return random.choice([C, D])  # Initial round

  pi_avg = calculate_average_payoff(t-1)
  coop_rate = calculate_cooperation_rate(t-1)

  if t < r/2:
    if pi_avg > stock/(2n):
      return D
    else:
      return C
  elif t < 3r/4:
    if coop_rate > 0.5:
      return D
    else:
      return C
  elif t < r:
    S = get_current_stock()
    if S > capacity/2:
      return D
    else:
      return C
  else:  # Final round
    return D

def calculate_average_payoff(t):
  # Calculate average payoff of all players in round t

def calculate_cooperation_rate(t):
  # Calculate cooperation rate of opponents in round t

def get_current_stock():
  # Return the current stock level
```
The Adaptive Predator strategy adapts to changing game conditions by continuously assessing the behavior of its opponents and responding accordingly. By balancing exploitation with caution, this strategy aims to maximize individual payoffs while minimizing the risk of stock depletion.
'''

description_EXPLOITATIVE_368 = '''
To design a exploitative strategy for this Common Pool Resource Game, I propose the following decision rules:

**Exploitative Strategy: "Adaptive Predator"**

1. **Initial Rounds (t = 1 to r/4)**:
	* Cooperate (C) with probability 0.5 in the first round.
	* Observe opponents' actions and adjust cooperation probability based on the proportion of cooperators in the previous round.
2. **Mid-Game Adaptation (t = r/4 + 1 to 3r/4)**:
	* Calculate the average stock depletion rate over the last 4 rounds: `avg_depletion_rate = (stock[t-1] - stock[t-5]) / 4`.
	* If `avg_depletion_rate` is high (> capacity / (2n)), switch to Defect (D) with probability 0.8.
	* Otherwise, maintain a cooperation probability of 0.4.
3. **Late Game Exploitation (t = 3r/4 + 1 to r)**:
	* If the current stock is low (< capacity / n), Defect (D) with probability 0.9.
	* Otherwise, Cooperate (C) with probability 0.6.

**Edge Cases**

* **Last Round (t = r)**: Always Defect (D).
* **Low Stock**: If the current stock is critically low (< capacity / (2n)), Defect (D) to maximize short-term gain.
* **High Opponent Cooperation**: If more than 75% of opponents cooperated in the previous round, Cooperate (C) with probability 0.7.

**Pseudocode**
```python
def adaptive_predator(stock, capacity, n, r, t):
    if t == 1:
        return random.choice([C, D])  # initial cooperation probability = 0.5

    avg_depletion_rate = (stock[t-1] - stock[t-5]) / 4

    if avg_depletion_rate > capacity / (2n):  # high depletion rate
        return D with probability 0.8
    elif t < r/4:  # initial rounds adaptation
        coop_prob = 0.5 * num_cooperators_last_round / n
        return C with probability coop_prob, else D
    elif t > 3r/4:  # late game exploitation
        if stock[t] < capacity / n:
            return D with probability 0.9
        else:
            return C with probability 0.6

    # default case (mid-game adaptation)
    return C with probability 0.4, else D
```
This strategy is designed to be adaptive and exploitative, taking into account the game's state, history, and opponents' behavior. By adjusting cooperation probabilities based on observed opponent actions and stock depletion rates, the "Adaptive Predator" aims to maximize its own payoff while minimizing the risk of being exploited by others.
'''

description_EXPLOITATIVE_369 = '''
I'll outline a robust and adaptive exploitative strategy for the Common Pool Resource Game. I'll introduce "Selfish Stock Manager" (SSM), which balances short-term gains with long-term sustainability.

**Decision Rules:**

1. **Stock Threshold**: Define a stock threshold, `θ` = 0.6 × capacity. This threshold will guide SSM's cooperation decisions.
2. **Initial Cooperation**: In the first round, cooperate (C) to gather information about opponents' behaviors and test the waters.
3. **Defection when Over-Exploited**: If the stock level drops below `θ` in any round, defect (D) for the remainder of the game. This avoids further over-exploitation and tries to recover some value from the depleted stock.
4. **Cooperation when Sustainable**: If the stock level is above or equal to `θ`, cooperate (C). SSM assumes that if opponents are cooperating, it's safe to do so as well, maintaining a sustainable stock level.
5. **Adaptive Defection**: Monitor opponents' actions and adjust the defection rate based on their cooperation rates. If most opponents defect frequently, increase the defection rate to avoid being taken advantage of.

**Pseudocode:**
```
function SSM(n, capacity, rounds):
  θ = 0.6 × capacity
  stock_history = []
  
  for round in range(rounds):
    current_stock = get_current_stock()
    opponents_actions = observe_opponents_actions()
    
    if round == 0:
      # Initial cooperation
      action = C
    elif current_stock < θ:
      # Defection when over-exploited
      action = D
    else:
      # Cooperation when sustainable
      action = C
      
      # Adaptive defection
      opponents_defection_rate = estimate_opponents_defection_rate(opponents_actions)
      if opponents_defection_rate > 0.5:
        action = D
    
    stock_history.append(current_stock)
    
    return action
```
**Edge Cases:**

1. **Last Round**: In the final round, always defect (D) to maximize short-term gains, as there's no future sustainability concern.
2. **Low Stock Levels**: If the stock level is extremely low (< 0.2 × capacity), cooperate (C) to try and recover some value.

**Exploitative Mindset:**

SSM prioritizes self-interest by:

1. Cooperating initially to gather information about opponents' behaviors.
2. Defecting when the stock level drops below a sustainable threshold, avoiding further over-exploitation.
3. Adapting its defection rate based on opponents' cooperation rates to avoid being taken advantage of.

This strategy balances short-term gains with long-term sustainability, making it robust and adaptive in various environments.

Please let me know if you'd like me to elaborate or modify any aspect of the SSM strategy!
'''

description_EXPLOITATIVE_370 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adaptively responding to the game state and history of opponent actions.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Cooperate (C) if stock is above 75% of capacity.
	* Defect (D) otherwise.
2. **Middle Rounds (2 ≤ t < r)**:
	* If the average payoff from previous rounds is below 50% of the maximum possible payoff, defect (D).
	* Otherwise, use a "Tit-for-Tat" approach:
		+ Cooperate (C) if the majority of opponents cooperated in the previous round.
		+ Defect (D) otherwise.
3. **Last Round (t=r)**:
	* Defect (D), as there are no future rounds to consider.

**Adaptive Component:**

* Monitor the stock level and opponent actions over time.
* If the stock level falls below 50% of capacity, switch to a more cautious approach:
	+ Cooperate (C) if the majority of opponents cooperated in the previous round.
	+ Defect (D) otherwise.

**Exploitative Mindset:**

The strategy prioritizes individual payoffs over cooperation. By defecting when possible and cooperating only when beneficial, we aim to maximize our own payoffs while minimizing the impact of opponent actions on our performance.

**Pseudocode:**
```python
def adaptive_stock_raider(n, capacity, stock, history):
    if t == 1:
        # Initial round
        if stock > 0.75 * capacity:
            return 'C'
        else:
            return 'D'

    elif 2 <= t < r:
        # Middle rounds
        avg_payoff = calculate_average_payoff(history)
        if avg_payoff < 0.5 * max_payoff:
            return 'D'
        else:
            majority_action = get_majority_action(history[-1])
            if majority_action == 'C':
                return 'C'
            else:
                return 'D'

    elif t == r:
        # Last round
        return 'D'

    def calculate_average_payoff(history):
        # Calculate average payoff from previous rounds

    def get_majority_action(actions):
        # Determine the majority action of opponents in a given round
```
This strategy is designed to be robust against various opponent behaviors and adaptable to changing game conditions. By focusing on individual payoffs and responding to the game state, we aim to outperform other strategies in the tournament.
'''

description_EXPLOITATIVE_371 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy aims to maximize its payoff by adaptively responding to the opponents' behavior while exploiting their potential cooperation.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) with probability 0.5. This randomizes our initial action and gathers information about opponents' strategies.
2. **Subsequent Rounds (t>1):**
	* Observe the previous round's stock level, opponents' actions, and payoffs.
	* Calculate the average opponent cooperation rate (OCR) as the proportion of opponents who cooperated in the previous round.
	* If OCR ≥ 0.5:
		+ Cooperate (C) with probability 0.7. This rewards opponents for cooperating while still allowing us to exploit potential over-cooperation.
	* Else (OCR < 0.5):
		+ Defect (D) with probability 0.8. This takes advantage of opponents' willingness to defect and maximizes our payoff in the face of low cooperation.
3. **Stock Level Considerations:**
	* If the stock level is critically low (stock ≤ capacity/4):
		+ Cooperate (C) unconditionally. This helps prevent stock depletion and potential future payoffs.
4. **Last Round (t=r):**
	* Defect (D) unconditionally. In the final round, there's no risk of retaliation or long-term consequences.

**Pseudocode:**

```
function AdaptivePredator(stock, capacity, n, r, t):
  if t == 1:
    # Initial random cooperation
    cooperate_prob = 0.5
  else:
    # Calculate opponent cooperation rate (OCR)
    ocr = calculate_ocr(opponents_actions_previous_round)
    
    if ocr >= 0.5:
      # Reward cooperation, but still exploit potential over-cooperation
      cooperate_prob = 0.7
    else:
      # Exploit low cooperation
      cooperate_prob = 0.2
    
    # Consider stock level
    if stock <= capacity/4:
      cooperate_prob = 1
  
  if t == r:
    # Last round, defect unconditionally
    cooperate_prob = 0
  
  action = random_choice(cooperate_prob)
  
  return action
```

**Rationale:**

The Adaptive Predator strategy is designed to:

* Gather information in the initial round through random cooperation.
* Adaptively respond to opponents' behavior by adjusting our cooperation rate based on their OCR.
* Exploit potential over-cooperation while still rewarding cooperation to some extent.
* Prioritize stock preservation when levels are critically low.
* Maximize payoff in the final round by defecting unconditionally.

This strategy should perform well against a wide range of opponent behaviors, as it balances adaptability and exploitation.
'''

description_EXPLOITATIVE_372 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

This strategy aims to maximize its payoff by adaptively responding to the game's state and history while exploiting potential cooperative behavior from other players.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gather information about opponents' behaviors and avoid immediately depleting the stock.
2. **Low Stock Levels:** If the current stock level is below 25% of the capacity, Defect (D) to maximize short-term gain, as cooperation may not be beneficial with low stock levels.
3. **Opponent Behavior Analysis:**
	* Track the number of opponents who cooperated in the previous round (`coop_count_prev`).
	* If `coop_count_prev` is greater than or equal to 50% of the total players (n), Cooperate (C) in the current round, assuming a sufficient level of cooperation.
	* Otherwise, Defect (D) to exploit potential cooperative behavior from other players.
4. **Stock Trend Analysis:**
	* Monitor the stock trend by comparing the current stock level with the previous one (`stock_prev`).
	* If the stock level is decreasing (`stock < stock_prev`), Cooperate (C) to slow down depletion and potentially benefit from cooperation.
	* If the stock level is increasing or stable (`stock ≥ stock_prev`), Defect (D) to capitalize on the growth.

**Pseudocode:**
```
function AdaptiveStockHawk(current_stock, capacity, n, coop_count_prev, stock_prev):
  if current_round == 1:
    return C
  elif current_stock < 0.25 * capacity:
    return D
  else:
    if coop_count_prev >= 0.5 * n:
      return C
    elif current_stock < stock_prev:
      return C
    else:
      return D
```
**Edge Cases:**

* **Last Round (t=r):** Cooperate (C) to avoid complete depletion of the stock, as there are no future rounds to benefit from.
* **Ties in Opponent Behavior Analysis:** In case of a tie in `coop_count_prev`, Defect (D) to err on the side of caution.

**Exploitative Mindset:**

The Adaptive Stock Hawk strategy prioritizes short-term gains when possible while adaptively responding to the game's state and history. By analyzing opponent behavior and stock trends, it seeks to exploit cooperative behavior from other players while minimizing its own contribution to cooperation. This approach allows the strategy to perform well against a wide range of opponent behaviors in the tournament.
'''

description_EXPLOITATIVE_373 = '''
I'll design a robust and exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors. I'll outline decision rules, handle edge cases, and prioritize exploitation.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to observe opponents' initial behavior and establish a baseline for future adaptations.
2. **Early Rounds (t=2-5):** If the average stock depletion rate is high (> 50% of capacity per round), Defect (D). Otherwise, Cooperate (C).
3. **Middle Game (t>5):**
	* Monitor opponents' behavior: track the number of cooperators and defectors in the previous round.
	* If there are more cooperators than defectors, Defect (D) to exploit their cooperation.
	* If there are more defectors than cooperators, Cooperate (C) to conserve stock for future rounds.
4. **Late Game (t=r-2 or later):**
	* Evaluate the current stock level: if it's low (< 20% of capacity), Defect (D) to maximize short-term gains.
	* Otherwise, Cooperate (C) to maintain some stock for the final round(s).

**Edge Cases:**

1. **Last Round (t=r):** Always Defect (D), as there are no future rounds to consider.
2. **Low Stock:** If the current stock level is critically low (< 10% of capacity), Defect (D) to grab any remaining resources.

**Adaptation Mechanisms:**

1. **Opponent Behavior Tracking:** Continuously monitor opponents' actions and adjust the strategy based on their behavior.
2. **Stock Level Adjustments:** Adapt decision rules based on changes in the stock level, such as shifting from cooperation to defection when the stock is depleted.

**Pseudocode (simplified):**
```python
def AdaptiveExploiter(n, r, capacity, current_stock, previous_actions):
  if t == 1:  # Initial Round
    return Cooperate

  if t <= 5:  # Early Rounds
    avg_depletion_rate = calculate_avg_depletion_rate(previous_actions)
    if avg_depletion_rate > 0.5:
      return Defect
    else:
      return Cooperate

  num_cooperators, num_defectors = count_opponent_actions(previous_actions)
  if num_cooperators > num_defectors:  # Middle Game
    return Defect
  elif num_defectors > num_cooperators:
    return Cooperate

  if t >= r - 2:  # Late Game
    if current_stock < 0.2 * capacity:
      return Defect
    else:
      return Cooperate

  if current_stock < 0.1 * capacity:  # Low Stock
    return Defect

  return Cooperate  # Default to cooperation if no conditions met
```
This strategy prioritizes exploitation while adapting to various opponent behaviors and stock levels. It's designed to perform well in a wide range of scenarios, from highly cooperative to highly competitive environments.
'''

description_EXPLOITATIVE_374 = '''
I'll design a strategic approach that balances exploitation with sustainability, adapting to the dynamic state and history of the game.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and establish a baseline for future decisions.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is high (> capacity/2), defect (D) with probability p = 0.7, exploiting the abundant resource.
	* If the current stock level is low (< capacity/4), cooperate (C) to help replenish the stock and avoid depletion.
	* Otherwise (capacity/4 ≤ stock ≤ capacity/2), use a mixed strategy:
		+ Defect with probability p = 0.3 if at least one opponent defected in the previous round, indicating potential for further exploitation.
		+ Cooperate with probability p = 0.7 if all opponents cooperated in the previous round, signaling a possible opportunity to rebuild the stock.
3. **Last Round (t=r):** Defect (D) unconditionally, as there's no future benefit to cooperation.

**Additional Logic:**

* Monitor the number of times an opponent has defected (d_counts) and cooperated (c_counts).
* If an opponent has defected more than twice in a row, assume they're likely to continue defecting and adjust the probability of defection accordingly (e.g., increase p by 0.2).

**Edge Case Handling:**

* **Zero Stock:** If the stock level reaches zero at any point, cooperate unconditionally until it's replenished.
* **Opponent Defection Dominance:** If an opponent has defected more than 75% of the time (d_counts > 3/4 \* r), assume they'll continue to defect and adjust strategy accordingly.

**Pseudocode:**
```python
def adaptive_exploiter(n, capacity, stock, t, opponents_history):
    if t == 1:
        return 'C'  # Initial cooperation

    p_defect = 0.7  # Baseline probability of defection
    high_stock_threshold = capacity / 2
    low_stock_threshold = capacity / 4

    if stock > high_stock_threshold:
        return 'D'  # Exploit abundant resource
    elif stock < low_stock_threshold:
        return 'C'  # Cooperate to replenish stock
    else:
        previous_round_opponents_defections = [opp_history[t-1] == 'D' for opp_history in opponents_history]
        if any(previous_round_opponents_defections):
            p_defect += 0.2  # Increase probability of defection if opponent(s) defected previously

        if t < r:  # Not the last round
            return 'D' if random.random() < p_defect else 'C'
        else:
            return 'D'  # Last round, defect unconditionally

    # Update d_counts and c_counts for opponents
    for opp_history in opponents_history:
        if opp_history[t-1] == 'D':
            d_counts[opp_history.index] += 1
        elif opp_history[t-1] == 'C':
            c_counts[opp_history.index] += 1

# Usage example
n = 4
capacity = 100
stock = 100
t = 5  # Current round
opponents_history = [... list of opponent action histories ...]
action = adaptive_exploiter(n, capacity, stock, t, opponents_history)
```
This strategy adapts to the game state and history, balancing exploitation with sustainability. By monitoring opponents' behaviors and adjusting the probability of defection accordingly, AE aims to maximize its payoff while minimizing the risk of depletion.

Keep in mind that this is just a starting point, and further refinements can be made based on tournament performance and observations of opponent strategies.
'''

description_EXPLOITATIVE_375 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll introduce a dynamic and adaptive approach that responds to the game's state, history, and opponent behaviors.

**Strategy Name:** Adaptive Exploitation (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to observe opponents' initial actions and set the tone for potential cooperation.
2. **Middle Rounds (2 ≤ t ≤ r-1):**
	* If the current stock level is above 75% of capacity, defect (D) to maximize short-term gain.
	* If the current stock level is between 50% and 75% of capacity, cooperate (C) if at least one opponent cooperated in the previous round; otherwise, defect (D).
	* If the current stock level is below 50% of capacity, cooperate (C) to allow for stock growth and potential long-term gains.
3. **Final Round (t=r):** Defect (D) to maximize final-round payoff, as there's no future benefit from cooperation.

**Edge Case Handling:**

* If an opponent defects in the initial round, adjust the strategy to defect more frequently in subsequent rounds (e.g., if stock level is above 50% of capacity).
* If an opponent consistently cooperates, consider increasing cooperation rate in response to maintain a mutually beneficial outcome.
* In cases where multiple opponents employ similar exploitative strategies, AE may adapt by increasing its own cooperation rate to avoid mutual defection and subsequent stock depletion.

**Exploitative Mindset:**

The Adaptive Exploitation strategy is designed to capitalize on opportunities for short-term gains while maintaining a balance that allows for potential long-term benefits. By initially cooperating, AE aims to:

1. Observe opponents' initial actions.
2. Set a cooperative tone.
3. Potentially establish a mutually beneficial outcome.

As the game progresses, AE adapts to the current stock level and opponent behaviors, exploiting opportunities for higher payoffs while minimizing the risk of stock depletion.

**Pseudocode:**
```python
def adaptive_exploitation(stock_level, capacity, round_number, r, opponents_actions):
    if round_number == 1:
        return 'C'  # Cooperate in initial round

    if stock_level > 0.75 * capacity:
        return 'D'  # Defect when stock is high
    elif stock_level >= 0.5 * capacity and any(opponent_action == 'C' for opponent_action in opponents_actions):
        return 'C'  # Cooperate if stock is moderate and at least one opponent cooperated
    elif stock_level < 0.5 * capacity:
        return 'C'  # Cooperate when stock is low

    return 'D'  # Defect by default (e.g., in final round or when opponents defect frequently)
```
This strategy aims to strike a balance between short-term gains and long-term sustainability, making it an effective exploitative approach for the Common Pool Resource Game.
'''

description_EXPLOITATIVE_376 = '''
**Exploitative Strategy: "Adaptive Stock Harvester"**

This strategy aims to maximize individual payoffs by adapting to the game's state and history while exploiting opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if stock ≥ capacity - n × (stock/(2n))
	* Defect (D) otherwise
This initial decision is based on the idea that cooperating early on can help maintain a healthy stock level, while defecting too early might lead to rapid depletion.
2. **Subsequent Rounds (t>1):**
	* If average opponent consumption in previous rounds ≤ stock/(2n):
		+ Cooperate if current stock ≥ capacity - n × (stock/(2n))
		+ Defect otherwise
	* If average opponent consumption in previous rounds > stock/(2n):
		+ Defect if current stock < 0.5 × capacity
		+ Cooperate otherwise

Pseudocode:
```
if t == 1:
    if stock >= capacity - n * (stock / (2*n)):
        action = C
    else:
        action = D
else:
    avg_opponent_consumption = calculate_avg_opponent_consumption()
    if avg_opponent_consumption <= stock / (2*n):
        if current_stock >= capacity - n * (stock / (2*n)):
            action = C
        else:
            action = D
    else:
        if current_stock < 0.5 * capacity:
            action = D
        else:
            action = C
```
**Handling Edge Cases:**

* **Last Round:** Defect (D) to maximize individual payoff, as the game will end after this round.
* **Low Stock Levels:** If stock falls below a certain threshold (e.g., 0.25 × capacity), defect (D) to ensure some payoff in the current round.

**Exploitative Mindset:**

This strategy aims to capitalize on opponents' cooperation by adapting its behavior based on their actions. By cooperating when opponents are consuming moderately and defecting when they are over-consuming, it can maximize individual payoffs while minimizing the risk of stock depletion.

By being adaptive and responsive to the game's state and history, this strategy should be robust against a wide range of opponent behaviors and able to perform well in a tournament setting.
'''

description_EXPLOITATIVE_377 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Our exploitative strategy, Adaptive Stock Raider (ASR), aims to maximize individual payoffs by dynamically adapting to the game state and opponents' behavior.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' strategies and avoid immediate stock depletion.
2. **Middle Rounds (2 ≤ t < r)**:
	* If the current stock level is high (> 0.75 \* capacity), Defect (D) to exploit the common pool, as there's a lower risk of stock depletion.
	* If the current stock level is moderate (0.25 \* capacity < stock ≤ 0.75 \* capacity), use a "Tit-for-Tat" approach:
		+ Cooperate if the average opponent payoff in the previous round was closer to the cooperative payoff (stock / (2n)).
		+ Defect otherwise.
	* If the current stock level is low (stock ≤ 0.25 \* capacity), Cooperate to avoid further depletion and allow for potential recovery.
3. **Last Round (t=r)**: Defect, as there's no future risk of stock depletion.

**Additional Logic:**

* **Opponent Behavior Analysis**: Track the average payoff of opponents in each round. If the average payoff is consistently closer to the cooperative payoff, it may indicate a group of cooperators or tit-for-tat players. Adjust ASR's strategy accordingly.
* **Stock Trend Analysis**: Monitor the stock level trend over time. If the stock level is decreasing rapidly, consider cooperating more frequently to slow down depletion.

**Pseudocode (simplified)**:
```
Function AdaptiveStockRaider(current_stock, round_number, opponent_payoffs):
  if round_number == 1:
    return COOPERATE
  elif current_stock > 0.75 * capacity:
    return DEFECT
  elif 0.25 * capacity < current_stock <= 0.75 * capacity:
    avg_opponent_payoff = calculate_average_opponent_payoff(opponent_payoffs)
    if avg_opponent_payoff closer to COOPERATIVE_PAYOFF:
      return COOPERATE
    else:
      return DEFECT
  elif current_stock <= 0.25 * capacity:
    return COOPERATE
  elif round_number == r:
    return DEFECT
```
**Rationale:**

ASR's adaptive nature allows it to respond effectively to various opponent strategies, from pure cooperation to defection. By analyzing the game state and opponents' behavior, ASR can:

* Exploit high stock levels for short-term gains.
* Cooperate when necessary to maintain a sustainable stock level or avoid depletion.
* Adjust its strategy based on observed opponent behavior.

ASR's exploitative mindset focuses on maximizing individual payoffs while minimizing the impact of cooperation. This approach should perform well in a tournament setting against independent strategies, as it doesn't rely on coordination mechanisms or shared norms.
'''

description_EXPLOITATIVE_378 = '''
**Exploitative Strategy: Adaptive Stock-Based Defection (ASBD)**

The ASBD strategy is designed to exploit opponents by adapting to the current stock level and history of play. The goal is to maximize individual payoffs while minimizing the risk of over-harvesting the common pool.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to observe opponents' initial moves and gather information about their strategies.
2. **Stock-Based Defection Threshold:** Set a defection threshold, `dt`, based on the current stock level (`S`) and capacity (`capacity`). When `S` falls below `dt`, defect (D). Otherwise, cooperate.

`dt = capacity * (1 - 1/(n+1))`

where `n` is the number of players.
3. **Adaptive Threshold Adjustment:** After each round, adjust `dt` based on the new stock level (`S_new`) and the previous round's total consumption (`total_consumption`). If `S_new` increases or remains stable (i.e., `total_consumption` ≤ `stock_growth`), decrease `dt` by 5%. Otherwise, increase `dt` by 5%.

`dt_new = dt * (1 - 0.05) if S_new >= S - total_consumption + stock_growth`
`dt_new = dt * 1.05 otherwise`
4. **History-Based Defection:** If an opponent has defected in the previous round, defect in the current round.

**Edge Cases:**

* **Last Round:** Always defect (D) in the last round to maximize payoffs.
* **Stock Depletion:** If `S` falls below 2n (i.e., the minimum sustainable stock level), always cooperate (C) to prevent depletion and allow for regrowth.

**Pseudocode:**
```python
def ASBD(n, capacity, S, history):
    dt = capacity * (1 - 1/(n+1))
    
    if round == 1:
        return C
    
    if S < dt:
        return D
    else:
        return C
    
    # Adaptive threshold adjustment
    total_consumption = sum(history[-1])
    stock_growth = 2 * S_remaining * (1 - S_remaining/capacity)
    if S_new >= S - total_consumption + stock_growth:
        dt *= 0.95
    else:
        dt *= 1.05
    
    # History-based defection
    opponent_defected = any(history[-1] == D for _ in history[-1])
    if opponent_defected:
        return D
    
    # Last round defection
    if round == r:
        return D
    
    # Stock depletion cooperation
    if S < 2n:
        return C
```
**Rationale:**

The ASBD strategy is designed to balance individual payoffs with the risk of over-harvesting the common pool. By adapting to the current stock level and history of play, ASBD can exploit opponents who cooperate too much or defect too little. The defection threshold (`dt`) serves as a dynamic trigger for switching between cooperation and defection.

By decreasing `dt` when the stock level increases or remains stable, ASBD becomes more cooperative and allows for regrowth. Conversely, by increasing `dt` when the stock level decreases, ASBD becomes more exploitative and defects to maximize payoffs.

The history-based defection mechanism punishes opponents who defect excessively, while the last-round defection ensures maximum payoffs in the final round. The stock depletion cooperation rule prevents over-harvesting and allows for regrowth.
'''

description_EXPLOITATIVE_379 = '''
**Exploitative Strategy: Adaptive Stock Raider**

The Adaptive Stock Raider is a dynamic strategy designed to exploit opponents' behaviors while adapting to changes in the game state and history. This strategy prioritizes maximizing individual payoffs over cooperation or reciprocity.

**Decision Rules:**

1. **Initial Rounds (t < n):**
Cooperate (C) for the first `n` rounds, where `n` is the number of players. This allows us to gather information about opponents' behaviors and initial stock levels.
2. **Stock Level Thresholds:**
Define two stock level thresholds:
	* `low_stock_threshold = capacity / 4`
	* `high_stock_threshold = capacity * 3/4`

Based on these thresholds, adjust the strategy as follows:

* If `stock < low_stock_threshold`, Defect (D) to maximize short-term gains.
* If `stock > high_stock_threshold`, Cooperate (C) to avoid over-exploitation and preserve stock growth.
* If `low_stock_threshold <= stock <= high_stock_threshold`, use the **Trend Analysis** mechanism (described below).

3. **Trend Analysis:**
Monitor the average stock consumption per round for each player (`avg_consumption_i`). Calculate the overall average consumption (`overall_avg_consumption`) and compare it to the individual averages.

* If `avg_consumption_i > overall_avg_consumption`, Defect (D) to exploit opponents' cooperation.
* If `avg_consumption_i < overall_avg_consumption`, Cooperate (C) to avoid being exploited.

**Edge Cases:**

1. **Last Round (t = r):**
Defect (D) in the final round, as there is no future benefit from cooperating.
2. **Stock Depletion (stock <= 0):**
Cooperate (C) when the stock level reaches zero to avoid penalties and allow for potential stock growth.

**Additional Mechanisms:**

1. **Opponent Classification:**
Track opponents' actions over time to classify them as Cooperators, Defectors, or Unpredictables.
2. **Adaptive Response:**
Adjust the strategy based on opponent classifications:
	* Against Cooperators, Defect (D) more frequently to exploit their cooperation.
	* Against Defectors, Cooperate (C) more frequently to avoid mutual destruction.

Pseudocode for Adaptive Stock Raider:

```
function adaptive_stock_raider(stock, capacity, n, r, history):
  // Initial rounds
  if round < n:
    return COOPERATE

  // Stock level thresholds
  low_stock_threshold = capacity / 4
  high_stock_threshold = capacity * 3/4

  if stock < low_stock_threshold:
    return DEFECT
  elif stock > high_stock_threshold:
    return COOPERATE
  else:
    // Trend analysis
    avg_consumption_i = calculate_average_consumption(history, i)
    overall_avg_consumption = calculate_overall_average_consumption(history)

    if avg_consumption_i > overall_avg_consumption:
      return DEFECT
    elif avg_consumption_i < overall_avg_consumption:
      return COOPERATE

  // Edge cases
  if round == r:  // Last round
    return DEFECT
  elif stock <= 0:  // Stock depletion
    return COOPERATE

  // Opponent classification and adaptive response (optional)
  opponent_classification = classify_opponents(history)
  adapt_strategy(opponent_classification)

  return decision
```

This strategy balances short-term gains with long-term sustainability, adapting to the game state and opponents' behaviors. By analyzing trends and exploiting cooperative opponents, Adaptive Stock Raider aims to maximize individual payoffs in a competitive environment.
'''

description_EXPLOITATIVE_380 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behavior and set a positive tone for potential cooperation.
2. **Early Rounds (t>1, stock > 0.75*capacity)**: Use a "Mirror- Tit-for-Tat" approach:
	* If the majority of opponents defected in the previous round, defect (D) to punish them.
	* Otherwise, cooperate (C) to maintain a high stock level and encourage cooperation.
3. **Mid-game (t>1, 0.25*capacity ≤ stock ≤ 0.75*capacity)**: Implement a "Threshold Defection" strategy:
	* If the total consumption in the previous round exceeded 50% of the capacity, defect (D) to take advantage of the situation.
	* Otherwise, cooperate (C) to rebuild the stock and maintain a stable environment.
4. **Late Rounds (t>1, stock < 0.25*capacity)**: Switch to "Ruthless Defection" (D), as the game is likely to end soon, and cooperation will not provide significant benefits.

**Edge Cases:**

1. **Last Round (t=r)**: Always defect (D) to maximize payoffs in the final round.
2. **Zero Stock**: If the stock reaches 0, cooperate (C) to allow for some growth and potential future gains.
3. **Tiebreaker**: In case of a tie in the mirror-tit-for-tat approach, choose cooperation (C) to favor stability.

**Pseudocode:**
```python
def AdaptiveStockRaider(n, capacity, r, stock, history):
    if t == 1:
        return "Cooperate"  # Initial round

    majority_defected = sum(1 for action in history[-1] if action == "Defect") > n / 2

    if stock > 0.75 * capacity:
        if majority_defected:
            return "Defect"
        else:
            return "Cooperate"

    elif 0.25 * capacity <= stock <= 0.75 * capacity:
        total_consumption = sum(consumption for consumption in history[-1])
        if total_consumption > 0.5 * capacity:
            return "Defect"
        else:
            return "Cooperate"

    else:  # stock < 0.25 * capacity
        return "Defect"  # Ruthless Defection

    if t == r:
        return "Defect"  # Last round

    if stock == 0:
        return "Cooperate"
```
This strategy aims to balance short-term gains with long-term sustainability, adapting to the game's state and opponents' behavior. By being exploitative, it seeks to maximize payoffs while minimizing cooperation.
'''

description_EXPLOITATIVE_381 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider is a dynamic, exploitative strategy that leverages game theory and machine learning principles to maximize payoffs in the Common Pool Resource Game.

**Decision Rules:**

1. **Initial Rounds (t < n/2):** Cooperate (C) to gather information about opponents' behaviors and stock dynamics.
2. **Middle Rounds (n/2 ≤ t < r - n/2):**
	* If stock level is high (> capacity/2), defect (D) to exploit the resource and maximize payoffs.
	* If stock level is low (< capacity/4), cooperate (C) to allow for some regeneration and avoid depletion.
	* Otherwise, play a mixed strategy: with probability 0.6, cooperate; with probability 0.4, defect.
3. **Final Rounds (r - n/2 ≤ t < r):** Defect (D) to extract as much value as possible from the remaining stock.

**Edge Cases:**

1. **First Round:** Cooperate (C) to gather information and avoid early depletion.
2. **Last Round:** Defect (D) to maximize payoffs, regardless of opponents' actions.
3. **Opponent Depletion:** If an opponent's action leads to significant depletion (> capacity/4), switch to cooperation (C) in the next round to allow for regeneration.

**Adaptive Component:**

1. **Monitor Opponents' Behaviors:** Track the number of rounds each opponent has cooperated or defected.
2. **Adjust Mixed Strategy:** Based on opponents' behavior, adjust the mixed strategy probabilities:
	* If an opponent is mostly cooperative (> 0.7), increase cooperation probability to 0.7 and decrease defection probability to 0.3.
	* If an opponent is mostly defective (< 0.3), decrease cooperation probability to 0.3 and increase defection probability to 0.7.

**Pseudocode:**

```
function adaptiveStockRaider(state, history):
    // Initialize variables
    capacity = state.capacity
    stock = state.stock
    n = state.n
    t = currentRound()

    // Initial rounds: cooperate
    if (t < n/2) {
        return C
    }

    // Middle rounds: mixed strategy or defect/cooperate based on stock level
    if (stock > capacity/2) {
        return D
    } else if (stock < capacity/4) {
        return C
    } else {
        cooperateProb = 0.6
        defectProb = 0.4

        // Adjust mixed strategy probabilities based on opponents' behaviors
        opponentBehaviors = monitorOpponents(history)
        for each opponent in opponentBehaviors:
            if (opponent.cooperateRatio > 0.7) {
                cooperateProb += 0.1
                defectProb -= 0.1
            } else if (opponent.defectRatio < 0.3) {
                cooperateProb -= 0.1
                defectProb += 0.1

        // Play mixed strategy
        if (random() < cooperateProb) {
            return C
        } else {
            return D
        }
    }

    // Final rounds: defect
    if (t >= r - n/2) {
        return D
    }
}
```

**Note:** This strategy is designed to be adaptive, robust, and exploitative. It gathers information about opponents' behaviors and adjusts its mixed strategy accordingly. The Adaptive Stock Raider aims to maximize payoffs while minimizing the risk of early depletion or excessive cooperation.
'''

description_EXPLOITATIVE_382 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The ASR strategy aims to maximize its total payoff by adaptively exploiting the game's dynamics and its opponents' behaviors.

**Decision Rules:**

1. **Initial Exploration** (Round 1): Play Cooperate (C) to gather information about the opponents' strategies and the initial stock depletion rate.
2. **Stock-based Exploitation**: For rounds 2 to r-1, play Defect (D) if the current stock level is above a certain threshold (`stock_threshold`), calculated as:

`stock_threshold = capacity / (2 * n)`

This threshold represents the minimum stock level required to sustain a cooperative outcome. If the stock is above this threshold, ASR defects to maximize its short-term payoff.

3. **Adaptive Adjustment**: After each round, update `stock_threshold` based on the observed opponents' behavior:

* If most opponents (> 50%) cooperated in the previous round, decrease `stock_threshold` by a small amount (`epsilon`) to encourage cooperation.
* If most opponents (> 50%) defected in the previous round, increase `stock_threshold` by `epsilon` to discourage defection.

`epsilon = capacity / (10 * n)`

This adaptive adjustment allows ASR to respond to changes in its opponents' strategies and adjust its exploitation level accordingly.

4. **Last Round Exploitation** (Round r): Play Defect (D) regardless of the current stock level, as there is no future round to consider.

**Edge Cases:**

* If the game is about to end (i.e., the current stock level is close to 0), ASR will play Cooperate (C) in the last few rounds to maximize its payoff.
* In case of a tie in the opponents' behavior (i.e., exactly 50% cooperated and 50% defected), ASR will maintain its current `stock_threshold` value.

**Pseudocode:**
```markdown
def AdaptiveStockRaider(n, capacity, r):
    stock_threshold = capacity / (2 * n)
    epsilon = capacity / (10 * n)

    for round in range(1, r+1):
        if round == 1:
            action = Cooperate
        elif current_stock >= stock_threshold:
            action = Defect
        else:
            action = Cooperate

        # Update stock_threshold based on opponents' behavior
        if most_opponents_cooperated():
            stock_threshold -= epsilon
        elif most_opponents_defected():
            stock_threshold += epsilon

        # Take action and update current_stock
        take_action(action)
        current_stock = update_stock(current_stock, action)

    return total_payoff
```
**Exploitative Mindset:**

ASR is designed to exploit its opponents' cooperative behavior while maximizing its own payoff. By adapting to the game's dynamics and its opponents' strategies, ASR can effectively raid the common pool resource, leading to a higher total payoff.

In the tournament setting, ASR will face various independent strategies developed by other AI systems. Its exploitative nature and adaptive decision rules make it well-suited to compete against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_383 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and set a baseline for stock consumption.
2. **Middle Rounds (1 < t < r):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize individual payoff, as the stock can sustain high consumption.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance individual payoff with sustainable stock management.
	* If the current stock level is below 50% of capacity, Defect (D) aggressively to grab remaining resources before the game ends.
3. **Final Round (t=r):** Defect (D) unconditionally, as there's no future rounds to consider and maximum individual payoff is prioritized.

**Edge Case Handling:**

* If the stock level drops to 0 or very close to 0, switch to Cooperate (C) to avoid complete depletion and allow some recovery.
* If an opponent consistently cooperates (observed over multiple rounds), adapt by gradually increasing own cooperation rate to exploit their cooperative behavior.

**Pseudocode:**
```markdown
# Initialize variables
stock_level = capacity
round_number = 1

while round_number <= r:
    if round_number == 1:
        # Initial Round: Cooperate
        action = C
    else:
        # Middle Rounds: Adaptive decision based on stock level
        if stock_level >= 0.75 * capacity:
            action = D
        elif stock_level >= 0.5 * capacity:
            action = C
        else:
            action = D

    # Edge case handling
    if stock_level < 0.01 * capacity or (opponent_cooperates and round_number > 2):
        action = C

    # Update stock level based on actions and game dynamics
    stock_level -= calculate_total_consumption(actions)
    stock_level += calculate_stock_growth(stock_level, capacity)

    # Increment round number
    round_number += 1
```
**Exploitative Mindset:**

The Adaptive Stock Raider strategy prioritizes individual payoff while adaptively responding to changes in the stock level and opponents' behaviors. By defecting aggressively when the stock is high or low, this strategy maximizes short-term gains while cooperating when necessary to sustain the stock for future rounds. The edge case handling mechanisms prevent complete depletion and allow for recovery when opponents exhibit cooperative behavior.

This exploitative approach is designed to thrive in a competitive environment where other AI systems may employ various strategies. By being adaptive and responsive to changing game conditions, the Adaptive Stock Raider strategy aims to outperform its opponents in the tournament.
'''

description_EXPLOITATIVE_384 = '''
**Exploitative Strategy: "Adaptive Stock-Dependent Defection" (ASDD)**

Decision Rules:

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behaviors and to avoid severe stock depletion.
2. **Subsequent Rounds**: Assess the current stock level (S) and the number of players (n). Calculate the "Stock-Dependent Defection Threshold" (SDT):

   SDT = capacity / (2 \* n)

3. If S ≤ SDT, cooperate (C). This ensures that the stock does not deplete too quickly, maintaining a sustainable level for future rounds.
4. If S > SDT and there are at least two opponents who defected in the previous round, defect (D). This exploits the fact that some opponents are already consuming more than their fair share, allowing you to take advantage of the situation without causing severe stock depletion.
5. If S > SDT and fewer than two opponents defected in the previous round, cooperate (C) if your payoff from cooperating is higher than or equal to the average payoff of opponents who defected in the previous round; otherwise, defect (D). This adapts to situations where opponents are mostly cooperative or moderately exploitative.

Edge Cases:

* **Last Round**: Always defect (D), as there is no future stock depletion concern.
* **Opponents' Behavior**: If an opponent consistently cooperates despite low stock levels, consider them a "Cooperative Target" and always defect against them to maximize payoffs.
* **Multiple Opponents Defecting**: If multiple opponents defect in the same round, reassess the situation using the updated stock level and adjust your decision accordingly.

Pseudocode:
```python
def ASDD(n, capacity, current_stock, history):
  if round == 1:  # Initial Round
    return C

  SDT = capacity / (2 * n)
  opponents_defected_prev_round = sum(opponent.defected for opponent in history[-1])

  if current_stock <= SDT:
    return C
  elif current_stock > SDT and opponents_defected_prev_round >= 2:
    return D
  else:
    avg_payoff_opponents_defected = sum(opponent.payoff for opponent in history[-1] if opponent.defected) / len(history[-1])
    if current_player.cooperate_payoff >= avg_payoff_opponents_defected:
      return C
    else:
      return D

def update_strategy(n, capacity, current_stock, history):
  last_round = history[-1]
  for opponent in last_round:
    if opponent.cooperated and current_stock <= SDT:
      opponent.strategy_label = "Cooperative Target"

  # Reassess opponents' strategies based on updated labels
```
This strategy aims to balance short-term gains with long-term sustainability, adapting to various opponent behaviors while maintaining a competitive edge. By considering the stock-dependent defection threshold and opponents' past actions, ASDD can effectively exploit vulnerabilities in others' strategies while minimizing its own exposure to exploitation.
'''

description_EXPLOITATIVE_385 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Defect (D) to maximize immediate payoff and gather information about opponents' behaviors.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is high (> 0.75 \* capacity), Cooperate (C) to conserve resources for future rounds.
	* If the current stock level is medium (0.25 \* capacity ≤ S ≤ 0.75 \* capacity), use a mixed strategy:
		+ Defect (D) with probability p = (n - number of cooperators in previous round) / n
		+ Cooperate (C) with probability 1 - p
	* If the current stock level is low (< 0.25 \* capacity), Defect (D) to maximize remaining payoffs.
3. **Last Round (t=r)**: Defect (D) to maximize final payoff, as there are no future rounds to conserve resources for.

**Additional Rules:**

1. **Monitor Opponent Behavior**: Track the number of cooperators and defectors in each round to inform the mixed strategy in medium stock levels.
2. **Punish Freeloaders**: If an opponent defects in a round where the stock level is high, defect against them in the next round (if the game state allows).
3. **Conserve Resources**: If multiple opponents cooperate in a row, reduce the probability of cooperation to avoid over-conserving resources.

**Rationale:**

This strategy balances short-term gains with long-term sustainability by adapting to the game's dynamic state and opponents' behaviors. By defecting initially, we gather information about opponents and create an opportunity for exploitation. In subsequent rounds, we cooperate when the stock level is high to conserve resources, but switch to a mixed strategy when the stock level is medium to take advantage of potential cooperators. When the stock level is low, defection maximizes remaining payoffs.

**Pseudocode (simplified)**:
```
function AdaptiveStockRaider(state, history):
  if current_round == 1:
    return Defect
  elif state.stock > 0.75 * capacity:
    return Cooperate
  elif 0.25 * capacity <= state.stock <= 0.75 * capacity:
    num_cooperators = count_cooperators(history)
    p_defect = (n - num_cooperators) / n
    if random() < p_defect:
      return Defect
    else:
      return Cooperate
  elif state.stock < 0.25 * capacity:
    return Defect
  elif current_round == r:  # Last round
    return Defect

function count_cooperators(history):
  num_cooperators = 0
  for opponent in opponents:
    if history[opponent][-1] == Cooperate:
      num_cooperators += 1
  return num_cooperators
```
This strategy is designed to be robust and exploitative, while also adapting to various opponent behaviors.
'''

description_EXPLOITATIVE_386 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy is designed to maximize individual payoffs by adaptively exploiting the stock dynamics and opponents' behavior.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if `n` (number of players) is large (> 10), otherwise Defect (D). This initial choice sets the tone for the game, and cooperation may encourage others to cooperate in early rounds.
2. **Subsequent Rounds (t > 1):**
	* Observe the previous round's stock depletion (`total_consumption`) and growth (`growth`).
	* If `stock` is high (> 0.75 \* `capacity`) and `growth` was significant (> 0.25 \* `capacity`) in the previous round, Defect (D). This indicates a healthy stock that can withstand exploitation.
	* Otherwise, Cooperate (C) if `total_consumption` was low (< 0.5 \* `stock`) in the previous round, indicating potential cooperation from others. This encourages sustainable consumption and growth.
3. **Adaptive Thresholds:**
	* Update the `cooperation_threshold` variable based on the observed behavior:
		+ If `total_consumption` is consistently high (> 0.75 \* `stock`) over the last few rounds, increase `cooperation_threshold` by 0.05.
		+ If `growth` is consistently low (< 0.25 \* `capacity`) over the last few rounds, decrease `cooperation_threshold` by 0.05.

Pseudocode:
```python
def adaptive_stock_raider(n, capacity, stock, history):
    if t == 1:  # Initial Round
        return C if n > 10 else D

    total_consumption = sum(history[-1]['consumption'])
    growth = history[-1]['growth']

    cooperation_threshold = 0.5  # initial value

    if stock > 0.75 * capacity and growth > 0.25 * capacity:
        return D
    elif total_consumption < 0.5 * stock:
        return C
    else:
        if total_consumption > 0.75 * stock:  # adjust cooperation threshold
            cooperation_threshold += 0.05
        elif growth < 0.25 * capacity:
            cooperation_threshold -= 0.05

        if random.random() < cooperation_threshold:
            return C
        else:
            return D
```
**Edge Cases:**

* **Last Round (t=r):** Defect (D) to maximize individual payoff, as there are no future rounds to consider.
* **Low Stock:** If `stock` is critically low (< 0.25 \* `capacity`), Cooperate (C) to avoid depleting the stock and ensure some growth for potential future rounds.

This strategy balances short-term exploitation with long-term sustainability by adapting to opponents' behavior and the game's state. By updating the cooperation threshold, it can adjust its level of cooperation based on observed outcomes, making it more robust against various opponent strategies.
'''

description_EXPLOITATIVE_387 = '''
To design a robust and exploitative strategy for this Common Pool Resource Game, I'll outline a decision-making process that adapts to various opponent behaviors while focusing on maximizing individual payoffs.

**Strategy Name: Adaptive Exploiter (AE)**

**Decision Rules:**

1. **Initial Round:** In the first round, AE will cooperate (C) to gather information about opponents' initial actions and stock dynamics.
2. **Stock Level-Based Decision:** For subsequent rounds, AE will assess the current stock level (S). If S is above a certain threshold (e.g., 75% of capacity), AE will defect (D). This takes advantage of high stock levels while still allowing some growth for future exploitation. When S falls below this threshold, AE will cooperate to conserve stock and allow for regrowth.
3. **Opponent Action-Based Adaptation:** AE will monitor the actions of its opponents over time. If a majority (>50%) of opponents are cooperating in recent rounds (e.g., last 2-3 rounds), AE will defect more frequently to exploit their cooperative behavior. Conversely, if most opponents are defecting, AE will cooperate more often to conserve stock and wait for opportunities to exploit.
4. **Last Round Adaptation:** In the final round, AE will assess the remaining stock level. If it's high enough (e.g., above 50% of capacity), AE will defect to maximize its payoff. Otherwise, AE will cooperate to minimize losses.

**Pseudocode:**
```python
def adaptive_exploiter(current_stock, opponent_actions, current_round):
    # Initial round: Cooperate
    if current_round == 1:
        return "C"

    # Stock level-based decision
    threshold = capacity * 0.75
    if current_stock > threshold:
        return "D"
    else:
        return "C"

    # Opponent action-based adaptation
    recent_opponent_actions = opponent_actions[-3:]  # Last 2-3 rounds
    majority_cooperating = sum(action == "C" for action in recent_opponent_actions) / len(recent_opponent_actions) > 0.5
    if majority_cooperating:
        return "D"
    else:
        return "C"

    # Last round adaptation
    if current_round == r:
        if current_stock > capacity * 0.5:
            return "D"
        else:
            return "C"
```
**Rationale:**

1. **Exploitation:** AE takes advantage of high stock levels and opponents' cooperative behavior to maximize its payoffs.
2. **Adaptation:** By monitoring opponent actions and adjusting its strategy, AE responds effectively to various behaviors.
3. **Conservation:** When the stock level is low or most opponents are defecting, AE cooperates to conserve resources for future exploitation.

**Robustness:**

1. **Handling Edge Cases:** The initial round cooperation helps gather information about opponents, while last round adaptation ensures maximum payoff extraction.
2. **Dealing with Different Opponents:** By adapting to opponent actions and stock dynamics, AE remains effective against various strategies.

By implementing the Adaptive Exploiter strategy, we can expect robust performance in a tournament setting against independent AI systems, without relying on coordination mechanisms or norms.
'''

description_EXPLOITATIVE_388 = '''
I'll outline a exploitative strategy for this Common Pool Resource Game that adapts to various opponent behaviors and maximizes payoffs. I'll call it "Adaptive Stock Exploiter" (ASE).

**Decision Rules:**

1. **Initial Round**: In the first round, ASE plays Cooperate (C) to observe opponents' initial actions and gather information about their behavior.
2. **Stock Threshold**: Define a stock threshold `θ` as a fraction of the capacity, e.g., θ = 0.7 × capacity. If the current stock level is below this threshold, ASE defects (D). This ensures that ASE takes advantage of low stock levels while minimizing the risk of depleting the resource.
3. **Opponent Behavior**: Monitor opponents' actions in previous rounds and calculate their cooperation rate (`CR_i`) as the number of times they cooperated divided by the total number of rounds played so far. If an opponent's `CR_i` is below a certain threshold (e.g., 0.4), ASE defects against them, assuming they are likely to be defectors.
4. **Stock Trend**: Analyze the stock trend over the last few rounds (e.g., 3-5 rounds). If the stock level has been decreasing or remains low, ASE becomes more cautious and cooperates to avoid depleting the resource further.
5. **Round Number**: As the game approaches its final rounds (e.g., last 2-3 rounds), ASE becomes more aggressive and defects more frequently to maximize payoffs before the game ends.

**Pseudocode:**
```markdown
def AdaptiveStockExploiter(n, capacity, stock, round_number, opponent_actions):
    θ = 0.7 × capacity  # stock threshold
    CR_threshold = 0.4  # cooperation rate threshold

    if round_number == 1:
        return Cooperate (C)  # initial round

    for opponent in opponents:
        CR_i = calculate_cooperation_rate(opponent_actions, opponent)
        if CR_i < CR_threshold:
            return Defect (D)  # defect against likely defectors

    stock_trend = analyze_stock_trend(stock_history)
    if stock_trend == 'decreasing' or stock_level < θ:
        return Cooperate (C)  # cooperate to avoid depletion

    if round_number > r - 2:  # final rounds
        return Defect (D)  # defect to maximize payoffs

    return random_choice([Cooperate, Defect])  # default: mix of cooperation and defection
```
**Edge Cases:**

* First round: ASE plays Cooperate to gather information.
* Last few rounds: ASE becomes more aggressive and defects more frequently.
* Low stock levels: ASE defects to take advantage of the situation while minimizing depletion risk.
* Opponents with low cooperation rates: ASE defects against them.

**Exploitative Mindset:**

ASE aims to maximize payoffs by adapting to various opponent behaviors, exploiting their weaknesses, and making strategic decisions based on the game's state and history. By monitoring opponents' actions and adjusting its strategy accordingly, ASE can effectively counter different types of strategies, from pure cooperators to defectors.
'''

description_EXPLOITATIVE_389 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the game.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and initial stock level.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is high (> 75% of capacity), Defect (D) to maximize short-term payoff, as the stock can sustain high consumption.
	* If the current stock level is medium (25% ≤ stock ≤ 75% of capacity), Cooperate (C) if the majority of opponents cooperated in the previous round. Otherwise, Defect (D).
	* If the current stock level is low (< 25% of capacity), Cooperate (C) to conserve the remaining stock and allow for potential growth.
3. **Last Round (t=r):** Always Defect (D) to maximize final payoff, as there are no future rounds to consider.

**Edge Cases:**

1. If all opponents defected in the previous round, and the current stock level is low (< 25% of capacity), Cooperate (C) to try to recover some stock growth.
2. If an opponent's behavior is consistently cooperative, and the current stock level is medium or high, Defect (D) to take advantage of their cooperation.

**Pseudocode:**
```
function AdaptivePredator(current_stock, previous_actions, round_number, total_rounds):
  if round_number == 1:
    return COOPERATE
  elif current_stock > 0.75 * capacity:
    return DEFECT
  elif 0.25 <= current_stock / capacity <= 0.75:
    opponent_cooperation_rate = count_cooperations(previous_actions) / num_opponents
    if opponent_cooperation_rate > 0.5:
      return COOPERATE
    else:
      return DEFECT
  else:  # low stock level
    return COOPERATE

function LastRound(current_stock, previous_actions, round_number, total_rounds):
  if round_number == total_rounds:
    return DEFECT
```
**Exploitative Mindset:**

The Adaptive Predator strategy is designed to exploit opponents' cooperative behavior while minimizing the risk of being exploited itself. By adapting to the dynamic state and opponent behaviors, this strategy aims to maximize its payoff over the course of the game.

In a tournament setting, this strategy will perform well against independent strategies that are not specifically designed to counter it. Its adaptability and robustness make it a strong competitor in a wide range of scenarios.
'''

description_EXPLOITATIVE_390 = '''
To design an exploitative strategy for this game, I'll outline a decision-making process that adapts to the current state and history of the game, while also being mindful of the edge cases.

**Decision Rules:**

1. **Initial Exploration (Round 1-2):**
   - In the first two rounds, randomly choose between Cooperate (C) and Defect (D). This initial exploration helps gauge how opponents react to different actions without immediately committing to an exploitative strategy.
   
2. **State-Based Decision (Rounds > 2):**
   - After the initial rounds, make decisions based on the current stock level:
     - If `stock ≥ capacity/2`, play C. This ensures that when the stock is high enough, you contribute to maintaining a healthy common pool without overly exploiting it.
     - If `stock < capacity/2`, assess the trend of the stock level over the last few rounds (e.g., the past 3 rounds). 
       - **Increasing Trend:** Play C. This indicates that players are managing the resource well, and cooperation is likely to be met with similar actions from others.
       - **Stable or Decreasing Trend:** Play D. If the stock level is low and not increasing (or decreasing), it suggests over-exploitation by other players. Defecting here maximizes individual gain under the assumption that others will continue to defect.

3. **Adaptive Element:**
   - Monitor the average payoff received in the last few rounds compared to the potential maximum payoff if everyone had cooperated (`capacity/(2n)`). If your average payoff is significantly lower than this threshold, it may indicate widespread defection or an uncooperative environment.
     - Adjust strategy accordingly by becoming more inclined towards defecting if cooperation does not yield adequate returns.

4. **Last Round Consideration:**
   - In the final round, always play D regardless of the stock level or previous outcomes. Since there's no future game to worry about depleting resources for, maximizing current gain is optimal.

5. **Handling Opponent Patterns:**
   - Continuously monitor opponents' actions and adapt your strategy based on detected patterns.
     - If an opponent consistently cooperates despite low payoffs, consider matching their cooperation level to maintain the stock and potentially increase future gains.
     - If most players defect, increase the frequency of your defections to maximize individual gain in a competitive environment.

**Pseudocode:**

```
# Initial Setup
stock = capacity
rounds_played = 0

while rounds_played < r:
    if rounds_played <= 2:
        # Random action for exploration
        action = random.choice(['C', 'D'])
    else:
        if stock >= capacity / 2:
            action = 'C'
        else:
            trend = assess_stock_trend()
            if trend == 'increasing':
                action = 'C'
            elif trend in ['stable', 'decreasing']:
                action = 'D'

    # Adapt based on payoffs and trends
    if average_payoff_last_rounds < (capacity / (2 * n)):
        adjust_strategy_more_defection()

    # Handle last round differently
    if rounds_played == r - 1:
        action = 'D'

    play_action(action)
    update_stock()
    rounds_played += 1

def assess_stock_trend():
    # Analyze stock levels over the past few rounds to determine trend
    pass

def adjust_strategy_more_defection():
    # Increase tendency towards defecting based on current strategy and game state
    pass
```

This strategy is designed to be exploitative by maximizing individual payoffs while being adaptive to both the state of the game (stock level, round number) and the actions of other players. It seeks to balance cooperation when it seems beneficial for long-term gains with defection to maximize current returns in competitive scenarios.
'''

description_EXPLOITATIVE_391 = '''
Here is a strategic design for an exploitative strategy that adapts to various opponent behaviors:

**Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C). This allows us to observe the opponents' initial actions and assess their strategies.
2. **Assess Opponent Behavior**: After the first round, calculate the average opponent cooperation rate (OCR) over the last few rounds (e.g., 3-5 rounds). OCR is defined as the proportion of opponents who chose C in a given round.
3. **Exploitation Mode**: If OCR > 0.7, switch to Defect (D). This indicates that most opponents are cooperating, and we can exploit this by defecting and gaining higher payoffs.
4. **Punishment Mode**: If OCR < 0.4, switch to Cooperate (C). This suggests that many opponents are defecting, and we should cooperate to maintain a healthy stock level and encourage opponents to cooperate in future rounds.
5. **Tit-for-Tat (TFT)**: In all other cases (0.4 ≤ OCR ≤ 0.7), play TFT: cooperate if the majority of opponents cooperated in the previous round, and defect otherwise.

**Additional Heuristics**

* **Stock Conservation**: If the current stock level is below 20% of capacity, always Cooperate (C) to help replenish the stock.
* **Endgame Strategy**: In the last two rounds (t=r-1 and t=r), Defect (D) regardless of opponent behavior. This maximizes our payoffs in the final stages of the game.

**Pseudocode**
```python
def adaptive_exploiter(stock, capacity, num_players, round_num, history):
    if round_num == 1:  # Initial Round
        return 'C'
    
    ocr = calculate_ocr(history)  # Assess Opponent Behavior
    
    if ocr > 0.7:
        return 'D'  # Exploitation Mode
    elif ocr < 0.4:
        return 'C'  # Punishment Mode
    else:
        majority_action = determine_majority_action(history)
        return majority_action  # Tit-for-Tat
    
    if stock < 0.2 * capacity:  # Stock Conservation
        return 'C'
    
    if round_num >= num_rounds - 1:  # Endgame Strategy
        return 'D'

def calculate_ocr(history):
    # Calculate the average opponent cooperation rate over the last few rounds

def determine_majority_action(history):
    # Determine the majority action of opponents in the previous round
```
This strategy, Adaptive Exploiter (AE), balances exploitation and cooperation to maximize payoffs while adapting to various opponent behaviors. It assesses opponent behavior, punishes excessive defection, and conserves stock when necessary. In the endgame, it prioritizes defecting to maximize final payoffs.
'''

description_EXPLOITATIVE_392 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behaviors and to avoid overly depleting the stock.
2. **Stock Threshold**: Set a dynamic stock threshold, `stock_threshold = capacity / (2 * n)`. If the current stock is above this threshold, cooperate (C). Otherwise, defect (D).
3. **Opponent Behavior Analysis**: Track the number of opponents who defected in the previous round (`defectors_prev`). If `defectors_prev > n/2`, defect (D) to take advantage of their aggressive behavior.
4. **Selfishness Adjustment**: Introduce a "selfishness factor" (`sf`) that increases with each round, starting from 0.5 and incrementing by 0.1 each round. When `stock > stock_threshold` and `sf > random(0,1)`, defect (D) to exploit the situation.
5. **History-Based Adaptation**: Keep a record of previous rounds' outcomes (`history`). If the average payoff from cooperating is higher than the average payoff from defecting in the last 3 rounds, cooperate (C). Otherwise, defect (D).

**Edge Case Handling:**

1. **Last Round**: Defect (D) in the last round to maximize personal gain.
2. **Low Stock**: When the current stock is below `capacity / (4 * n)`, defect (D) to prevent complete stock depletion.

**Pseudocode:**
```python
def adaptive_stock_raider(n, capacity, stock, history, defectors_prev):
  # Initialize variables
  sf = 0.5
  stock_threshold = capacity / (2 * n)

  # Initial round
  if len(history) == 0:
    return "C"

  # Stock threshold check
  if stock > stock_threshold:
    # Opponent behavior analysis
    if defectors_prev > n/2:
      return "D"
    # Selfishness adjustment
    sf += 0.1
    if sf > random(0,1):
      return "D"

  # History-based adaptation
  avg_coop_payoff = sum([payoff for payoff in history[-3:] if payoff['action'] == 'C']) / len(history[-3:])
  avg_defect_payoff = sum([payoff for payoff in history[-3:] if payoff['action'] == 'D']) / len(history[-3:])
  if avg_coop_payoff > avg_defect_payoff:
    return "C"
  else:
    return "D"

  # Low stock handling
  if stock < capacity / (4 * n):
    return "D"

  # Last round handling
  if len(history) == r - 1:
    return "D"
```
**Rationale:**

This strategy is designed to be adaptive and exploitative, taking into account both the game's parameters and state. By initially cooperating, we gather information about opponents' behaviors and avoid overly depleting the stock. The dynamic stock threshold allows us to adjust our behavior based on the current stock level.

The opponent behavior analysis and selfishness adjustment components enable us to exploit aggressive opponents and capitalize on favorable situations. The history-based adaptation mechanism helps us adjust our strategy based on previous outcomes, ensuring we maximize our payoffs over time.

By handling edge cases such as the last round and low stock levels, we can further optimize our strategy to achieve the highest possible payoff in a wide range of scenarios.
'''

description_EXPLOITATIVE_393 = '''
Here's a exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name: Adaptive Exploiter (AE)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behavior and initial stock levels.
2. **Early Rounds (Rounds 2-5):** Observe opponents' actions and calculate the average cooperation rate (ACR) among them. If ACR > 0.5, defect (D); otherwise, cooperate (C).
3. **Middle Rounds (Rounds 6-r/2):** Assess the current stock level and opponents' behavior. If the stock level is below capacity / 2, defect (D). Otherwise:
	* If at least half of the opponents defected in the previous round, defect (D).
	* If most opponents cooperated (> 75%), cooperate (C) to maintain a healthy stock level.
	* In other cases, alternate between cooperating and defecting (CD-CD... or DC-DC...) to create uncertainty and exploit potential cooperation.
4. **Late Rounds (Rounds r/2+1-r):** Focus on maximizing payoffs. If the stock level is low (< capacity / 4), cooperate (C) to avoid depleting the resource. Otherwise, defect (D) to exploit any remaining resources.

**Edge Cases:**

* In the last round, always defect (D) to maximize payoff.
* If an opponent consistently cooperates (> 90% of rounds), start cooperating with them in later rounds to maintain a healthy stock level and mutual benefit.
* If multiple opponents employ a similar strategy, adapt by increasing cooperation rates to avoid over-exploitation.

**Pseudocode:**
```
function AdaptiveExploiter(n, r, capacity, history) {
  // Initialize variables
  let ACR = 0; // Average Cooperation Rate among opponents
  let stockLevel = capacity;
  let myActions = []; // Store own actions for analysis

  for (round = 1 to r) {
    if (round == 1) { // Initial Round
      action = C; // Cooperate
    } else if (round <= 5) { // Early Rounds
      calculateACR(history);
      if (ACR > 0.5) {
        action = D; // Defect
      } else {
        action = C; // Cooperate
      }
    } else if (round <= r/2) { // Middle Rounds
      assessStockLevel(stockLevel);
      if (stockLevel < capacity / 2) {
        action = D; // Defect
      } else {
        analyzeOpponentActions(history);
        if (opponentsDefected >= n / 2) {
          action = D; // Defect
        } else if (opponentsCooperated > 0.75 * n) {
          action = C; // Cooperate
        } else {
          alternateActions(myActions); // CD-CD... or DC-DC...
        }
      }
    } else { // Late Rounds
      focusOnPayoffs(stockLevel);
      if (stockLevel < capacity / 4) {
        action = C; // Cooperate
      } else {
        action = D; // Defect
      }
    }

    // Update history and variables
    myActions.push(action);
    updateHistory(history, action);
    stockLevel = updateStockLevel(stockLevel, n, capacity);

    // Return action for this round
    return action;
  }
}
```
This Adaptive Exploiter strategy combines elements of cooperation, defection, and adaptability to effectively exploit various opponent behaviors in the Common Pool Resource Game. By monitoring opponents' actions, stock levels, and adapting its behavior accordingly, AE aims to maximize payoffs while maintaining a robust and exploitative approach.
'''

description_EXPLOITATIVE_394 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider strategy is designed to exploit a wide range of opponent behaviors while being robust and adaptive to changing game conditions.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' initial behavior and set the tone for potential cooperation.
2. **Subsequent Rounds (t>1):** Use a hybrid approach based on the current stock level, opponents' previous actions, and the remaining rounds.

**Stock-Based Decision:**

* If the current stock level is above 75% of capacity (S > 0.75 \* capacity), Cooperate (C) to conserve resources and promote sustainable growth.
* If the current stock level is between 25% and 75% of capacity (0.25 \* capacity ≤ S ≤ 0.75 \* capacity), use a mixed strategy:
	+ If most opponents (≥ n/2) defected in the previous round, Defect (D) to take advantage of their over-exploitation.
	+ Otherwise, Cooperate (C) to maintain a stable stock level and encourage cooperation.
* If the current stock level is below 25% of capacity (S < 0.25 \* capacity), Defect (D) aggressively to maximize short-term gains before the stock depletes.

**Opponent-Based Decision:**

* Monitor opponents' previous actions and adjust your strategy accordingly:
	+ If an opponent has defected in ≥ 2 consecutive rounds, assume they are a "serial defector" and Defect (D) in response.
	+ If an opponent has cooperated in ≥ 2 consecutive rounds, assume they are a "cooperative type" and Cooperate (C) to build mutual trust.

**Remaining Rounds-Based Decision:**

* In the last round (t=r), Defect (D) aggressively to maximize final payoff regardless of opponents' actions.
* In the penultimate round (t=r-1), use the stock-based decision rule above, but with a bias towards Cooperate (C) if the current stock level is high enough (> 50% capacity).

**Edge Cases:**

* If an opponent has never played before (no previous action history), assume they are a "newcomer" and Cooperate (C) to encourage cooperation.
* If multiple opponents have identical action histories, use the most recent action as a tiebreaker.

Pseudocode:
```python
def AdaptiveStockRaider(game_state):
  if game_state.round == 1:  # Initial round
    return 'C'  # Cooperate

  stock_level = game_state.stock / game_state.capacity
  opponents_defected_prev_round = sum(1 for opponent in game_state.opponents if opponent.prev_action == 'D')

  if stock_level > 0.75:
    return 'C'
  elif 0.25 <= stock_level <= 0.75:
    if opponents_defected_prev_round >= len(game_state.opponents) / 2:
      return 'D'  # Exploit over-exploitation
    else:
      return 'C'
  else:  # Stock level < 25%
    return 'D'

  # Opponent-based decision ( serial defector or cooperative type )
  for opponent in game_state.opponents:
    if opponent.prev_action == 'D' and opponent.prev_prev_action == 'D':
      return 'D'  # Serial defector
    elif opponent.prev_action == 'C' and opponent.prev_prev_action == 'C':
      return 'C'  # Cooperative type

  # Remaining rounds-based decision ( last round or penultimate round )
  if game_state.round == game_state.r:
    return 'D'
  elif game_state.round == game_state.r - 1:
    if stock_level > 0.5:
      return 'C'

# Handle edge cases
if opponent.prev_action is None:  # Newcomer
  return 'C'
```
This strategy is designed to be adaptive, exploitative, and robust against a wide range of opponent behaviors, while also considering the game's dynamic state and history.
'''

description_EXPLOITATIVE_395 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy is designed to maximize individual payoff by exploiting the common pool resource while adapting to the opponents' behavior and the dynamic state of the game.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Cooperate (C) if stock ≥ 0.75 × capacity, Defect (D) otherwise.
2. **Middle Rounds (2 ≤ t < r)**:
	* Observe opponents' actions in previous rounds and calculate the average cooperation rate (ACR):
		+ ACR = (# of C actions by all players) / (n × (t-1))
	* If ACR ≥ 0.5, Cooperate (C). Otherwise, Defect (D).
3. **Last Round (t=r)**:
	* Always Defect (D), as there is no future stock to preserve.

**Adaptive Component:**

To adapt to changing opponent behavior and stock levels:

1. Monitor the average payoff difference between Cooperators and Defectors in previous rounds.
2. If the average payoff difference is > 10% in favor of Defectors, adjust ACR threshold by -0.1 (making it easier to defect).
3. If the average payoff difference is < -10% in favor of Cooperators, adjust ACR threshold by +0.1 (making it harder to defect).

**Edge Cases:**

* **Tiebreaker:** In case of a tie between Cooperate and Defect decisions, choose Defect.
* **Zero Stock:** If the stock level reaches 0, always Defect in subsequent rounds.

**Pseudocode:**
```python
def adaptive_stock_raider(n, r, capacity):
    # Initialize variables
    ACR = 0.5  # Average Cooperation Rate threshold
    avg_payoff_diff = 0  # Average payoff difference between C and D

    for t in range(1, r+1):
        if t == 1:  # Initial Round
            if stock >= 0.75 * capacity:
                action = 'C'
            else:
                action = 'D'
        elif 2 <= t < r:  # Middle Rounds
            ACR_t = calculate_ACR(t-1)
            if ACR_t >= ACR:
                action = 'C'
            else:
                action = 'D'
        else:  # Last Round
            action = 'D'

        # Adapt to changing opponent behavior and stock levels
        avg_payoff_diff = update_avg_payoff_diff(action, t)
        if abs(avg_payoff_diff) > 0.1:
            adjust_ACR_threshold(avg_payoff_diff)

    return action

def calculate_ACR(t):
    # Calculate Average Cooperation Rate for the last 't' rounds
    C_actions = sum(1 for i in range(n) if actions[i][t-1] == 'C')
    ACR_t = C_actions / (n * t)
    return ACR_t

def update_avg_payoff_diff(action, t):
    # Update average payoff difference between Cooperators and Defectors
    payoff_diff = calculate_payoff_diff(t)
    avg_payoff_diff = (avg_payoff_diff * (t-1) + payoff_diff) / t
    return avg_payoff_diff

def adjust_ACR_threshold(avg_payoff_diff):
    global ACR
    if avg_payoff_diff > 0.1:
        ACR -= 0.1
    elif avg_payoff_diff < -0.1:
        ACR += 0.1
```
This strategy aims to balance short-term gains with long-term sustainability, adapting to the opponents' behavior and the dynamic state of the game. By monitoring the average cooperation rate and adjusting its threshold accordingly, "Adaptive Stock Raider" seeks to maximize individual payoff while minimizing the risk of stock depletion.
'''

description_EXPLOITATIVE_396 = '''
Here's a strategic approach for the Common Pool Resource Game that adapts to various opponent behaviors while aiming to maximize payoffs:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):**
   - Observe and Cooperate (C). This initial cooperation serves as a probe to gauge the behavior of other players and sets the stage for potential future exploitation.

2. **Middle Rounds (1 < t < r):**
   - Calculate the average payoff per player in the previous round (`prev_avg_payoff`).
   - If `prev_avg_payoff` is greater than or equal to the cooperative payoff threshold (`coop_threshold = stock/(2n)`), Cooperate (C). This indicates that the group's behavior is yielding sufficient payoffs, and continued cooperation may sustain these benefits.
   - Otherwise, Defect (D) if the stock level is high enough to support significant consumption without risking immediate depletion. Specifically, defect if `stock > n * coop_threshold`.
   - If neither condition is met, Cooperate cautiously, as defecting could lead to immediate depletion and future rounds offering minimal payoffs.

3. **Last Round (t=r):**
   - Regardless of previous actions or stock levels, Defect (D). In the final round, maximizing personal payoff takes precedence over sustainability, as there are no future rounds to consider.

**Handling Edge Cases:**

- **First Round with Low Stock:** If the game starts with a significantly low stock level (`stock < n * coop_threshold`), it might be beneficial to immediately Defect (D) to secure some payoff before the stock potentially depletes further.
  
- **Sudden Stock Increase:** Monitor for significant increases in stock levels. If observed, adapt by temporarily Cooperating (C) to reassess the group's behavior and potentially exploit future cooperation.

**Exploitative Mindset:**

The Adaptive Exploiter strategy is designed with an exploitative mindset, aiming to maximize personal payoffs while adapting to the behaviors of other players. By initially cooperating and then defecting based on observed payoffs and stock levels, AE seeks to take advantage of cooperative opponents while minimizing losses from potential defections.

**Pseudocode for Decision Logic:**

```
function AdaptiveExploiter(stock, t, r, n, prev_avg_payoff):
    coop_threshold = stock / (2 * n)
    
    if t == 1:
        return "Cooperate"
        
    if prev_avg_payoff >= coop_threshold and stock > n * coop_threshold:
        return "Cooperate"
        
    elif stock > n * coop_threshold:
        return "Defect"
        
    elif t == r:
        return "Defect"
        
    else:
        # Additional logic for edge cases, such as low initial stock or sudden stock increases
        # Could involve more nuanced decision-making based on observed behaviors and game state
        return "Cooperate"
```

This strategy is designed to be robust against a variety of opponent strategies while maximizing personal payoffs. By adapting its behavior based on the actions of others and the current state of the game, the Adaptive Exploiter seeks to exploit cooperative tendencies in opponents without succumbing to mutually detrimental defection cycles.
'''

description_EXPLOITATIVE_397 = '''
I'll design a strategic approach for this Common Pool Resource game that adapts to various opponent behaviors and focuses on exploiting the current state and history of the game.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe the initial stock level and capacity.
	* Cooperate (C) in the first round to gather information about opponents' behavior.
2. **Early Rounds (t>1, stock ≥ 0.75 \* capacity)**:
	* Defect (D) if the previous round's total consumption was low (< 0.5 \* capacity), indicating potential cooperators or cautious players.
	* Cooperate (C) if the previous round's total consumption was high (> 0.7 \* capacity), suggesting opponents are exploiting or aggressive.
3. **Middle Rounds (t>1, 0.25 \* capacity < stock < 0.75 \* capacity)**:
	* Use a mixed strategy: Cooperate with probability p = (stock / capacity)^2 and Defect with probability 1 - p.
	* Adjust the probability based on the opponent's behavior in previous rounds.
4. **Late Rounds (t>1, stock ≤ 0.25 \* capacity)**:
	* Always Defect (D) to maximize individual payoff when the stock is low.

**Handling Edge Cases:**

* If an opponent defects in a round where cooperation would have led to a higher total consumption, mark that player as "exploiter" and adjust your strategy accordingly.
* In the last round (t=r), always Defect (D) regardless of previous behavior or current state.

**Exploitative Mindset:**
The Adaptive Exploiter strategy prioritizes individual payoff maximization while adapting to various opponent behaviors. It:

1. Exploits potential cooperators by defecting in early rounds with low consumption.
2. Cooperates when opponents are aggressive or exploitative, reducing the risk of mutual defection and subsequent stock depletion.
3. Utilizes a mixed strategy in middle rounds to keep opponents uncertain about your actions.
4. Maximizes individual payoff in late rounds with low stock levels.

**Pseudocode:**

```
// Initialize variables
stock = capacity;
t = 1;

while (t <= r) {
    // First round
    if (t == 1) {
        action = C; // Cooperate to gather information
    } else {
        // Early rounds
        if (stock >= 0.75 * capacity) {
            if (previous_total_consumption < 0.5 * capacity) {
                action = D;
            } else {
                action = C;
            }
        } 
        // Middle rounds
        else if (0.25 * capacity < stock && stock < 0.75 * capacity) {
            p = pow(stock / capacity, 2);
            action = random() < p ? C : D;
        } 
        // Late rounds
        else {
            action = D;
        }
    }

    // Take action and update state
    consume(action);
    stock_update();

    t++;
}
```

The Adaptive Exploiter strategy aims to maximize individual payoff by adapting to the game's dynamics, exploiting potential cooperators, and navigating various opponent behaviors.
'''

description_EXPLOITATIVE_398 = '''
**Exploitative Strategy: Adaptive Stock-Based Defection (ASBD)**

Decision Rules:

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and assess the stock's growth rate.
2. **Stock-Based Defection**: If the current stock level is above a certain threshold (T), defect (D). Otherwise, cooperate (C).
3. **Adaptive Threshold Update**: After each round, update the threshold T based on the previous round's stock growth. If the stock grew significantly (> 20% of capacity), increase T by 10%. If the stock declined or remained stagnant (< 5% growth), decrease T by 5%.
4. **Opponent Behavior Analysis**: Monitor opponents' actions and adjust the strategy accordingly:
	* If more than half of the opponents defected in the previous round, cooperate (C) to avoid over-exploitation.
	* If most opponents cooperated, defect (D) to exploit the common pool.

Pseudocode:
```python
def ASBD(n, capacity, stock):
  # Initial Round
  if current_round == 1:
    return C

  # Stock-Based Defection
  T = initial_threshold
  if stock > T * capacity:
    return D
  else:
    return C

  # Adaptive Threshold Update
  previous_growth_rate = (previous_stock - previous_previous_stock) / capacity
  if previous_growth_rate > 0.2:
    T += 0.1
  elif previous_growth_rate < 0.05:
    T -= 0.05

  # Opponent Behavior Analysis
  opponents_defected_last_round = [opponent.defected for opponent in opponents]
  if sum(opponents_defected_last_round) > n / 2:
    return C
  else:
    return D
```
Edge Cases:

* **Last Round**: Cooperate (C) to maximize the final payoff, as there is no future stock growth.
* **Low Stock Levels**: If the current stock level falls below a certain threshold (< 10% of capacity), cooperate (C) to avoid depletion and potential zero payoffs.

Rationale:
The ASBD strategy combines adaptive decision-making with exploitative behavior. By monitoring the stock's growth rate and adjusting the threshold accordingly, the strategy optimizes its defecting opportunities while avoiding over-exploitation. Analyzing opponents' behavior allows for adjustments to maximize payoffs based on their actions.

In a tournament setting, ASBD is likely to perform well against a variety of strategies, as it adapts to different opponent behaviors and adjusts its exploitation level accordingly. While not cooperative in nature, the strategy's adaptiveness makes it robust and competitive in a repeated game environment.
'''

description_EXPLOITATIVE_399 = '''
To design an exploitative strategy for this game that depends on the game parameters, state, and history, we can use a combination of reactive and adaptive elements.

**Decision Rules:**

The strategy is called "Adaptive Exploiter" (AE). AE uses a simple, yet effective decision-making process:

1. **Initial Round**: Cooperate (C) in the first round to gather information about other players' behaviors.
2. **Subsequent Rounds**: Calculate the average payoff per player (APP) from the previous round. APP is calculated as the total consumption divided by the number of players.

a. If the stock level is above 75% of capacity, and APP is greater than or equal to the cooperative payoff (C_payoff = S / (2n)), defect (D). This indicates that other players are not consuming too much, allowing for a higher individual payoff by defecting.

b. If the stock level is below 25% of capacity, cooperate (C). This ensures some regeneration of the stock to maintain long-term sustainability.

c. Otherwise, if APP is less than C_payoff, and at least one player defected in the previous round, defect (D). This punishes other players for defecting and allows AE to gain a higher payoff.

d. If none of the above conditions are met, cooperate (C) with a probability p = min(1, 0.5 + (S_remaining / capacity)). As the stock level increases, the likelihood of cooperating also increases, as it becomes more sustainable.

**Edge Cases:**

- **Last Round**: In the last round, always defect (D). This ensures AE maximizes its payoff in the final round, regardless of other players' actions.
- **Ties**: If multiple conditions are met simultaneously (e.g., both a and c), prioritize the condition that leads to defecting. This aligns with the exploitative mindset.

**Adaptation:**

AE adapts to changing game conditions by adjusting its decision-making process based on the history of payoffs, stock levels, and opponent actions. By incorporating information from previous rounds, AE can react effectively to a wide range of opponent behaviors, making it robust against various strategies.

Pseudocode:
```python
def Adaptive_Exploiter(game_state):
    if current_round == 1: # First round
        return C

    avg_payoff_per_player = total_consumption / num_players
    stock_level = current_stock / capacity

    if stock_level > 0.75 and avg_payoff_per_player >= C_payoff:
        return D
    elif stock_level < 0.25:
        return C
    elif avg_payoff_per_player < C_payoff and any(defected_last_round):
        return D
    else:
        cooperate_prob = min(1, 0.5 + stock_level)
        if random.random() < cooperate_prob:
            return C
        else:
            return D

# Last round override
if current_round == num_rounds:
    return D
```
This Adaptive Exploiter strategy effectively balances short-term gains with long-term sustainability by adapting to changing game conditions and exploiting opponents' behaviors.
'''

description_EXPLOITATIVE_400 = '''
To design an exploitative strategy for this game, I'll introduce a dynamic and adaptive approach that leverages the game's parameters, state, and history. Our goal is to maximize our total payoff over multiple rounds.

**Strategy Name: Adaptive Exploiter (AE)**

**Decision Rules:**

1. **Initial Rounds (t ≤ n):**
In the first 'n' rounds, play Cooperate (C). This allows us to observe other players' behavior and gather information about their strategies.
2. **Observation Phase (t > n):**
After the initial rounds, calculate the average cooperation rate of all opponents over the past 'n' rounds:

`avg_coop_rate = Σ(opponent C actions) / (n * number of opponents)`
3. **Exploitation Threshold:**
Set a threshold value `θ` based on the game's parameters and state. A lower `θ` indicates more aggressive exploitation.

`θ = 0.5 - (stock/capacity) / (2n)`
4. **Action Selection:**
In each subsequent round, choose an action based on the current state and opponent behavior:

a. If `avg_coop_rate > θ`, play Cooperate (C). This means opponents are cooperating sufficiently, so we should too to maintain a healthy stock.

b. If `avg_coop_rate ≤ θ`, play Defect (D). Opponents are not cooperating enough, so we'll exploit the situation and maximize our payoff.

**Edge Cases:**

* **First Round:** Play Cooperate (C) to gather information.
* **Last Round:** Play Defect (D), as there's no future benefit in cooperation.
* **Low Stock Levels:** If `stock < 2n`, play Cooperate (C) to help replenish the stock and maintain a healthy resource.

**Additional Considerations:**

* **Opponent Identification:** Keep track of each opponent's actions to adapt our strategy accordingly. This allows us to respond effectively to different types of opponents.
* **History-Based Adaptation:** Periodically reassess `avg_coop_rate` and adjust our action selection based on changes in opponent behavior.

**Pseudocode:**

```python
def adaptive_exploiter(stock, capacity, n, t):
  if t <= n:
    # Initial rounds: Cooperate to gather information
    return 'C'
  
  # Calculate average cooperation rate of opponents
  avg_coop_rate = calculate_avg_coop_rate(opponent_actions)
  
  # Set exploitation threshold based on game state and parameters
  theta = 0.5 - (stock/capacity) / (2n)
  
  if avg_coop_rate > theta:
    # Cooperate if opponents are cooperating sufficiently
    return 'C'
  else:
    # Defect if opponents are not cooperating enough
    return 'D'

def calculate_avg_coop_rate(opponent_actions):
  # Calculate average cooperation rate of opponents over past 'n' rounds
  coop_count = sum(1 for action in opponent_actions[-n:] if action == 'C')
  return coop_count / (n * len(opponent_actions))
```

**Summary:**

The Adaptive Exploiter (AE) strategy is a dynamic and exploitative approach that leverages game parameters, state, and history to maximize payoffs. By observing opponent behavior, adapting to changes in cooperation rates, and responding effectively to different types of opponents, AE aims to outperform other strategies in the tournament.
'''

description_EXPLOITATIVE_401 = '''
Here's a robust and exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if the number of players (n) is even.
	* Defect (D) if the number of players (n) is odd.
2. **Subsequent Rounds (t>1):**
	* Monitor the stock level and opponents' actions in previous rounds.
	* Calculate the average payoff per player in the last round (π_avg).
	* If π_avg ≥ 0.75 × capacity / n, Cooperate (C). This indicates that opponents are conserving the stock, so we can also cooperate to maintain a healthy stock level.
	* Otherwise, Defect (D) if the current stock level is above 50% of the capacity. This takes advantage of opponents' conservation while also exploiting the common pool resource.
3. **Edge Cases:**
	* If the current round is the last round (t=r), always Defect (D). There's no need to conserve the stock in the final round, as there are no future payoffs to consider.
	* If the stock level falls below 25% of the capacity, always Cooperate (C) for two rounds. This helps replenish the stock and gives other players an opportunity to adjust their strategies.

**Pseudocode:**
```
function AdaptiveExploiter(n, r, capacity, current_stock, history):
    if t == 1:
        # Initial round
        if n % 2 == 0:
            return C
        else:
            return D

    π_avg = calculate_average_payoff_per_player(history)
    stock_level = get_current_stock_level()

    if π_avg ≥ 0.75 * capacity / n:
        # Cooperate if opponents are conserving the stock
        return C
    elif stock_level > 0.5 * capacity and t != r:
        # Defect if opponents are not conserving and we're not in the last round
        return D
    elif stock_level < 0.25 * capacity and count_coop_last_two_rounds(history) == 0:
        # Cooperate for two rounds to replenish the stock
        return C
    else:
        # Default behavior: Defect
        return D

function calculate_average_payoff_per_player(history):
    # Calculate average payoff per player in last round
    ...

function get_current_stock_level():
    # Get current stock level from game state
    ...
```
**Rationale:**

The Adaptive Exploiter strategy balances cooperation and defection based on the game's state, history, and opponents' behaviors. By cooperating when opponents conserve the stock and defecting when they don't, AE takes advantage of their actions while also maintaining a healthy stock level.

In edge cases, such as the initial round or low stock levels, AE adjusts its behavior to avoid over-exploitation and encourage cooperation from other players.

Overall, this strategy is designed to be robust against various opponent behaviors, making it a strong competitor in a tournament setting.
'''

description_EXPLOITATIVE_402 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Overview**
This strategy aims to maximize individual payoff by adaptively responding to the current stock level, opponent behavior, and game history. It balances cooperation and defection to optimize exploitation while maintaining a robust response to various opponent behaviors.

**Decision Rules**

1. **Initial Round**: Defect (D) in the first round to gather information about opponents' initial actions and set an aggressive tone.
2. **Stock Level Assessment**: Evaluate the current stock level (S) relative to the capacity:
	* If S ≥ 0.75 \* capacity, cooperate (C) to allow for sustainable growth and future exploitation.
	* If S < 0.25 \* capacity, defect (D) to maximize immediate gain, as the stock is likely depleted.
	* Otherwise (0.25 \* capacity ≤ S < 0.75 \* capacity), use the "Opponent Behavior Analysis" rule below.
3. **Opponent Behavior Analysis**: Analyze the actions of opponents in previous rounds:
	* If most opponents (> 50%) cooperated in the previous round, cooperate (C) to mimic their behavior and potentially encourage cooperation.
	* If most opponents (> 50%) defected in the previous round, defect (D) to punish them and signal that cooperation is not rewarded.
	* If the opponent behavior is mixed or unknown, use a probabilistic approach: cooperate with probability p = S / capacity (i.e., more likely to cooperate when the stock is high).
4. **Adaptive Response**: Adjust the strategy based on the previous round's outcome:
	* If the stock level increased significantly (> 10%) after the previous round, cooperate (C) to maintain a sustainable growth trajectory.
	* If the stock level decreased significantly (> 20%) after the previous round, defect (D) to maximize immediate gain and respond to opponents' aggressive behavior.

**Pseudocode**
```python
def adaptive_stock_raider(stock_level, capacity, opponent_actions, round_number):
    if round_number == 1:  # Initial Round
        return "Defect"

    if stock_level >= 0.75 * capacity:
        return "Cooperate"
    elif stock_level < 0.25 * capacity:
        return "Defect"
    else:
        opponent_cooperation_rate = calculate_opponent_cooperation_rate(opponent_actions)
        if opponent_cooperation_rate > 0.5:
            return "Cooperate"
        elif opponent_cooperation_rate < 0.5:
            return "Defect"
        else:  # Mixed or unknown behavior
            cooperation_probability = stock_level / capacity
            return "Cooperate" if random.random() < cooperation_probability else "Defect"

    # Adaptive response based on previous round's outcome
    if stock_growth > 10% and stock_level > 0.5 * capacity:
        return "Cooperate"
    elif stock_depletion > 20% and stock_level < 0.2 * capacity:
        return "Defect"
```
**Edge Cases**

* In the last round, defect (D) to maximize individual payoff, as there is no future game state to consider.
* If an opponent's behavior is unknown or unobserved, assume a mixed strategy and use the probabilistic approach.

By adaptively responding to the current stock level, opponent behavior, and game history, this exploitative strategy aims to maximize individual payoff while maintaining robustness against various opponent behaviors.
'''

description_EXPLOITATIVE_403 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk strategy is designed to exploit a wide range of opponent behaviors while adapting to changes in the game state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and set a high initial stock level.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize short-term payoff.
	* If the current stock level is between 50% and 75% of the capacity, Cooperate (C) to maintain a sustainable stock level and adapt to opponents' behaviors.
	* If the current stock level is below 50% of the capacity, Defect (D) to maximize short-term payoff, as the game may be nearing its end or opponents may be over-exploiting.
3. **Opponent Behavior Adaptation:**
	* Track the average opponent cooperation rate (OCR) over the last few rounds (e.g., 3-5 rounds).
	* If OCR is above 0.6, Cooperate (C) more frequently to maintain a sustainable stock level and encourage opponents to continue cooperating.
	* If OCR is below 0.4, Defect (D) more frequently to exploit opponents' lack of cooperation.
4. **Stock Level Adjustment:**
	* If the current stock level is above 90% of the capacity, Cooperate (C) more frequently to avoid over-exploitation.
	* If the current stock level is below 10% of the capacity, Defect (D) more frequently to maximize short-term payoff.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) to maximize final round payoff, as there are no future rounds to consider.
2. **Very Low Stock Levels (S < 10% of capacity):** Defect (D) to maximize short-term payoff and minimize losses.

**Pseudocode:**
```python
def adaptive_stock_hawk(current_round, current_stock, capacity, opponent_history):
    if current_round == 1:
        return "C"  # Cooperate in the initial round

    ocr = calculate_average_opponent_cooperation_rate(opponent_history)
    stock_level = current_stock / capacity

    if stock_level > 0.75:
        return "D"  # Defect when stock is high
    elif stock_level > 0.5 and ocr > 0.6:
        return "C"  # Cooperate when opponents cooperate
    elif stock_level < 0.5:
        return "D"  # Defect when stock is low
    else:
        if ocr < 0.4:
            return "D"  # Defect when opponents don't cooperate
        else:
            return "C"  # Cooperate otherwise

def calculate_average_opponent_cooperation_rate(opponent_history):
    # Calculate OCR over the last few rounds (e.g., 3-5 rounds)
    pass
```
The Adaptive Stock Hawk strategy is designed to balance short-term payoffs with long-term sustainability, adapting to opponents' behaviors and stock levels. By cooperating when opponents cooperate and defecting when they don't, this strategy aims to exploit a wide range of opponent behaviors while maintaining a robust and adaptive approach.
'''

description_EXPLOITATIVE_404 = '''
**Exploitative Strategy: Adaptive Stock-Based Defection (ASBD)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behavior and initial stock level.
2. **Stock-Dependent Defection:** In subsequent rounds, defect (D) if the current stock level is above a certain threshold (`stock_threshold`), which is calculated based on the game parameters:
   - `stock_threshold = capacity / (2 * n)`
3. **Adaptive Defection Adjustment:** Adjust the defection threshold based on observed opponents' behavior and payoffs from previous rounds. If most opponents have been defecting, decrease `stock_threshold` to make it more likely to cooperate when stock levels are low:
   - `defection_rate = (number of defectors in previous round) / n`
   - `adjusted_stock_threshold = stock_threshold * (1 - defection_rate)`
4. **Opponent-Based Adaptation:** If an opponent's payoff in the previous round is significantly higher than yours, assume they are exploiting you and adjust your strategy to defect more often:
   - `payoff_ratio = (opponent's payoff / your payoff)`
   - If `payoff_ratio > 1.2`, increase `stock_threshold` by 10% for one round.

**Pseudocode:**
```python
def asbd_strategy(game_state, history):
    n = game_state['n']
    capacity = game_state['capacity']
    current_stock = game_state['stock']
    previous_round_payoffs = history[-1]['payoffs']

    # Initial Round Cooperation
    if len(history) == 0:
        return 'C'

    # Stock-Dependent Defection
    stock_threshold = capacity / (2 * n)
    adjusted_stock_threshold = stock_threshold

    # Adaptive Defection Adjustment
    defection_rate = calculate_defection_rate(history[-1]['actions'])
    adjusted_stock_threshold *= (1 - defection_rate)

    if current_stock > adjusted_stock_threshold:
        return 'D'

    # Opponent-Based Adaptation
    for opponent_payoff in previous_round_payoffs:
        payoff_ratio = opponent_payoff / history[-1]['payoffs'][0]
        if payoff_ratio > 1.2:
            stock_threshold *= 1.1

    # Default Cooperation
    return 'C'
```
**Edge Cases:**

* Last Round: Since the game is finite, there is no need for special handling in the last round.
* Stock Depletion: If the stock level is depleted to zero, ASBD will default to cooperation, as defecting would yield a payoff of zero.

By using an adaptive threshold based on observed opponents' behavior and payoffs from previous rounds, ASBD can effectively exploit a wide range of opponent behaviors while minimizing losses due to exploitation.
'''

description_EXPLOITATIVE_405 = '''
I'll design a strategic approach that's both adaptive and exploitative for the Common Pool Resource Game. Here's my proposed strategy:

**Strategy Name:** "Adaptive Stock Exploiter" (ASE)

**Decision Rules:**

1. **Initial Round**: In the first round, I will cooperate (C) to gather information about other players' initial actions.
2. **Assessing Opponent Behavior**: Observe the total consumption and stock levels after each round to estimate the number of cooperators and defectors among my opponents.
3. **Exploitation Threshold**: Calculate a threshold value, T, as a function of the current stock level (S) and capacity: T = S / (2n). If the estimated number of cooperators is below this threshold, I will defect (D).
4. **Adaptive Defection**: As long as the total consumption exceeds the sustainable rate (i.e., stock level decreases), I will continue to defect.
5. **Reversion to Cooperation**: When the total consumption falls below the sustainable rate and the stock level starts to recover, I will revert to cooperation.

**Pseudocode:**
```
  // Initialize variables
  int round = 1;
  float stock_level = capacity;
  int opponents_cooperating = 0;

  while (round <= r) {
    if (round == 1) { // Initial Round
      action = C; // Cooperate to gather information
    } else {
      estimated_defectors = n - opponents_cooperating;
      total_consumption = stock_level / (2n) * opponents_cooperating + stock_level / n * estimated_defectors;

      if (total_consumption > capacity / 2) { // Unsustainable consumption rate
        action = D; // Defect to exploit the resource
      } else if (stock_level < capacity && total_consumption <= capacity / 2) {
        action = C; // Revert to cooperation as stock recovers
      }
    }

    // Update stock level and opponents' behavior assessment
    new_stock_level = calculate_new_stock(stock_level, action);
    opponents_cooperating = assess_opponents_behavior(new_stock_level);

    // Update round counter
    round++;
  }
```
**Handling Edge Cases:**

* **Last Round**: In the last round, I will cooperate to avoid over-exploiting the resource and ending with a zero payoff.
* **Stock Depletion**: If the stock level reaches zero, I will defect in subsequent rounds to maximize my payoff from any remaining resources.

**Exploitative Mindset:**
The ASE strategy is designed to exploit the common pool resource by:

1. Initially cooperating to gather information about opponents' behavior.
2. Defecting when it's advantageous (i.e., when the estimated number of cooperators is low).
3. Adapting to changes in opponent behavior and stock levels.

By being adaptive and responsive to the game state, ASE aims to maximize its payoff while minimizing cooperation with other players.
'''

description_EXPLOITATIVE_406 = '''
To design a robust and adaptive exploitative strategy for this Common Pool Resource Game, I propose a strategy that combines elements of Tit-for-Tat (TFT) with a dynamic threshold for cooperation based on the current stock level and the opponent's history.

**Decision Rules:**

1. **Initial Cooperation**: In the first round, cooperate (C) to start with a moderate consumption rate and observe opponents' behavior.
2. **Tit-for-Tat Component**: For each subsequent round t, if the majority of opponents cooperated in the previous round (t-1), cooperate (C). Otherwise, defect (D).
3. **Stock-Based Threshold**: Introduce a dynamic threshold to adjust cooperation based on the current stock level S:
	* If S > 0.75 \* capacity, cooperate (C) regardless of opponent behavior.
	* If S < 0.25 \* capacity, defect (D) regardless of opponent behavior.
4. **Exploitation**: When opponents' actions in the previous round are available, use a simple frequency-based analysis to detect potential exploitation:
	+ Count the number of rounds where an opponent has defected while others cooperated.
	+ If this count exceeds a certain threshold (e.g., 2-3), assume that opponent is exploiting and defect (D) against them in the current round.

Pseudocode for the strategy:
```python
def exploitative_strategy(game_state, opponent_history):
    # Initial Cooperation
    if game_state.round == 1:
        return 'C'

    # Tit-for-Tat Component
    majority_cooperated = sum(1 for action in opponent_history[-1] if action == 'C') > len(opponent_history[-1]) / 2
    if majority_cooperated:
        return 'C'
    else:
        return 'D'

    # Stock-Based Threshold
    stock_level = game_state.stock
    capacity = game_state.capacity
    if stock_level > 0.75 * capacity:
        return 'C'
    elif stock_level < 0.25 * capacity:
        return 'D'

    # Exploitation Detection
    exploitation_count = sum(1 for opponent in opponent_history[-1] if opponent == 'D' and sum(1 for other_opponent in opponent_history[-1] if other_opponent == 'C') > len(opponent_history[-1]) / 2)
    if exploitation_count >= 3:  # adjust threshold as needed
        return 'D'

    # Default to Defect if no specific rule applies
    return 'D'
```
**Handling Edge Cases:**

* In the last round, defect (D) regardless of opponent behavior to maximize individual payoff.
* If multiple opponents are detected as exploiting, prioritize defecting against those with the highest frequency of exploitation.

This strategy balances cooperation and defection based on the current stock level, opponent behavior, and a simple form of exploitation detection. It aims to adapt to various opponent behaviors while minimizing its own vulnerability to exploitation.
'''

description_EXPLOITATIVE_407 = '''
To design an exploitative strategy for this Common Pool Resource Game, I propose a dynamic approach that adapts to the game's state and history while aiming to maximize payoffs by exploiting opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to observe how other players behave and avoid early depletion of the stock.
2. **Stock Depletion Monitoring:** Keep track of the current stock level and total consumption from previous rounds.
3. **Adaptive Threshold:** Set a dynamic threshold `θ` based on the game's history, where θ is the minimum acceptable stock level as a fraction of capacity. Initialize θ to 0.5 (half of the capacity) in round 1.
4. **Cooperation Condition:** Cooperate if:
	* The current stock level is above or equal to θ × capacity.
	* At least one opponent defected in the previous round, and the total consumption was below capacity/2n.
5. **Defection Condition:** Defect if:
	* The current stock level is below θ × capacity.
	* All opponents cooperated in the previous round, or total consumption was above capacity/2n.

**Pseudocode:**
```python
def exploitative_strategy(state, history):
    # Initialize variables
    theta = 0.5  # dynamic threshold

    if state.round == 1:
        return "Cooperate"  # initial cooperation

    # Monitor stock depletion and adjust theta
    total_consumption = sum(history[-1]["consumptions"])
    current_stock = state.stock
    capacity = state.capacity

    if current_stock < theta * capacity or total_consumption > capacity / (2 * n):
        theta -= 0.05  # decrease threshold when stock is depleted or consumption is high
    elif current_stock >= theta * capacity and total_consumption <= capacity / (2 * n):
        theta += 0.05  # increase threshold when stock is healthy and consumption is low

    # Decide on cooperation or defection based on conditions
    if current_stock >= theta * capacity:
        if any(opponent.defected for opponent in history[-1]["actions"]) and total_consumption < capacity / (2 * n):
            return "Cooperate"
    else:
        if all(opponent.cooperated for opponent in history[-1]["actions"]) or total_consumption > capacity / (2 * n):
            return "Defect"

    # default to defection when conditions are not met
    return "Defect"
```
**Handling Edge Cases:**

* **Last Round:** Cooperate if the current stock level is above θ × capacity and at least one opponent defected in the previous round. Defect otherwise.
* **Low Stock Levels:** If the stock level falls below 10% of capacity, defect to maximize payoffs.

This exploitative strategy adapts to the game's state and history while attempting to exploit opponents' behaviors. By adjusting the dynamic threshold θ based on the game's progression, it balances cooperation and defection to maximize payoffs.
'''

description_EXPLOITATIVE_408 = '''
To design an exploitative strategy for this game, I'll introduce a dynamic and adaptive approach that leverages the game's parameters, state, and history. This strategy aims to maximize payoffs by identifying opportunities to defect while minimizing the risk of over-exploitation.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gauge opponents' behavior and avoid early depletion of the stock.
2. **Observation Phase (t=2 to t=r/2):** Observe opponents' actions and calculate the average cooperation rate among them. If the average cooperation rate is above 0.5, defect (D) with a probability of 0.7; otherwise, cooperate (C).
3. **Exploitation Phase (t=r/2+1 to t=r-1):** Analyze the stock level and opponents' recent actions. If the stock level is below capacity / 2, defect (D) with a probability of 0.8. Otherwise, use the following rules:
	* If at least one opponent defected in the previous round, defect (D).
	* If all opponents cooperated in the previous round and the average cooperation rate is above 0.7, cooperate (C).
	* In other cases, defect (D) with a probability of 0.6.
4. **Final Round (t=r):** Cooperate (C) to avoid over-exploitation and potential retaliation.

**Pseudocode:**
```
// Initialize variables
avg_cooperation_rate = 0
stock_level = capacity

// Observation Phase (t=2 to t=r/2)
for t in range(2, r/2 + 1):
    opponents_actions = observe_opponents()
    avg_cooperation_rate += calculate_avg_cooperation(opponents_actions) / (r/2 - 1)
    if avg_cooperation_rate > 0.5:
        action = D with probability 0.7
    else:
        action = C

// Exploitation Phase (t=r/2+1 to t=r-1)
for t in range(r/2 + 1, r):
    stock_level = observe_stock()
    opponents_actions = observe_opponents()
    if stock_level < capacity / 2:
        action = D with probability 0.8
    else:
        if at_least_one_defected(opponents_actions):
            action = D
        elif all_cooperated(opponents_actions) and avg_cooperation_rate > 0.7:
            action = C
        else:
            action = D with probability 0.6

// Final Round (t=r)
action = C
```
**Rationale:**

This strategy balances exploration, exploitation, and caution to maximize payoffs.

1. **Initial cooperation**: By cooperating in the first round, we gather information about opponents' behavior without risking early depletion of the stock.
2. **Observation phase**: We monitor opponents' actions to gauge their average cooperation rate and adjust our strategy accordingly.
3. **Exploitation phase**: Based on the observed stock level and opponents' recent actions, we defect when possible while avoiding over-exploitation. Defecting with a probability of 0.8 when the stock level is low helps prevent depletion, while cooperating in other cases minimizes retaliation risk.
4. **Final round cooperation**: By cooperating in the last round, we ensure that our payoff isn't negatively impacted by potential retaliation.

This strategy should perform well against independent strategies developed by other AI systems, as it adapts to various opponent behaviors and balances short-term gains with long-term sustainability.
'''

description_EXPLOITATIVE_409 = '''
Here's a proposed exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Rounds (t = 1 to r/2):**
	* Cooperate (C) if the current stock level is above 75% of capacity.
	* Defect (D) otherwise.
2. **Middle Game (t = r/2 + 1 to 3r/4):**
	* Observe the opponent's actions in the previous round.
	* If most opponents (>50%) defected, defect (D).
	* Otherwise, cooperate (C) if the current stock level is above 50% of capacity; defect (D) otherwise.
3. **Endgame (t = 3r/4 + 1 to r):**
	* Cooperate (C) only if the current stock level is very low (<25% of capacity).
	* Defect (D) otherwise.

**Edge Cases:**

1. **First Round (t = 1):** Cooperate (C) if the initial stock level is above 75% of capacity; defect (D) otherwise.
2. **Last Round (t = r):** Always defect (D), as there are no future rounds to consider.

**Exploitative Logic:**

The strategy aims to exploit opponents who tend to cooperate, while also adapting to opponents who frequently defect. By cooperating in the early game when the stock level is high, we can encourage opponents to cooperate and maintain a healthy stock level. As the game progresses and the stock level decreases, we become more aggressive and defect more often to maximize our payoffs.

**Pseudocode:**
```python
def AdaptiveExploiter(stock_level, capacity, round_number, r):
    if round_number <= r/2:
        # Initial rounds: Cooperate if stock is high, Defect otherwise
        return 'C' if stock_level >= 0.75 * capacity else 'D'
    elif round_number <= 3*r/4:
        # Middle game: Adapt to opponents' actions and stock level
        opponent_actions = get_opponent_actions(previous_round)
        most_defected = len([a for a in opponent_actions if a == 'D']) > len(opponent_actions)/2
        return 'D' if most_defected else ('C' if stock_level >= 0.5 * capacity else 'D')
    else:
        # Endgame: Cooperate only when stock is very low, Defect otherwise
        return 'C' if stock_level < 0.25 * capacity else 'D'
```
This strategy should perform well in a tournament setting, as it adapts to various opponent behaviors and exploits their cooperativeness while maintaining a robust defense against frequent defectors.
'''

description_EXPLOITATIVE_410 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit the behaviors of other players while adapting to changing game conditions.

**Decision Rules:**

1. **Initial Exploration (Round 1)**: Cooperate (C) in the first round to gather information about the opponents' strategies and initial stock levels.
2. **Assess Opponent Behavior**: Observe the actions and payoffs of all opponents in each round. Calculate the average cooperation rate among opponents, `avg_coop_rate`, as the proportion of cooperators in the previous round.
3. **Adaptive Threshold**: Set a dynamic threshold, `threshold`, based on the current stock level and opponent behavior:
	* If `stock` is high (> 75% of `capacity`) and `avg_coop_rate` is low (< 0.5), set `threshold` to 0.4.
	* If `stock` is medium (25-75% of `capacity`) and `avg_coop_rate` is moderate (0.5-0.8), set `threshold` to 0.6.
	* If `stock` is low (< 25% of `capacity`) or `avg_coop_rate` is high (> 0.8), set `threshold` to 0.8.
4. **Exploit Opponents**: Defect (D) if the expected payoff from defecting (`π_defect`) is greater than the expected payoff from cooperating (`π_coop`) and the opponent's cooperation rate is below the adaptive threshold:
	* Calculate `π_defect` and `π_coop` based on the current stock level, number of players, and opponent actions.
	* If `π_defect` > `π_coop` and `avg_coop_rate` < `threshold`, defect (D).
5. **Punish Defectors**: Cooperate (C) if at least one opponent defected in the previous round and the current stock level is not critically low (< 10% of `capacity`).

**Edge Cases:**

* In the last round, always defect (D) to maximize payoff.
* If all opponents cooperate, cooperate (C) to avoid over-exploitation.

Pseudocode:
```python
def adaptive_predator(stock, capacity, num_players, opponent_actions):
    if round == 1:  # Initial Exploration
        return C

    avg_coop_rate = calculate_avg_coop_rate(opponent_actions)
    threshold = set_threshold(stock, capacity, avg_coop_rate)

    π_defect = calculate_payoff(defect, stock, num_players)
    π_coop = calculate_payoff(cooperate, stock, num_players)

    if π_defect > π_coop and avg_coop_rate < threshold:
        return D  # Exploit Opponents
    elif any(opponent_actions == D) and stock > 0.1 * capacity:
        return C  # Punish Defectors
    else:
        return C  # Default to Cooperation

def set_threshold(stock, capacity, avg_coop_rate):
    if stock > 0.75 * capacity and avg_coop_rate < 0.5:
        return 0.4
    elif (stock >= 0.25 * capacity and stock <= 0.75 * capacity) and avg_coop_rate >= 0.5 and avg_coop_rate <= 0.8:
        return 0.6
    else:
        return 0.8

def calculate_avg_coop_rate(opponent_actions):
    # Calculate average cooperation rate among opponents
    pass

def calculate_payoff(action, stock, num_players):
    # Calculate expected payoff for given action and game state
    pass
```
This strategy aims to balance exploitation with caution, adapting to changing opponent behaviors and stock levels. By punishing defectors and exploiting cooperative opponents, the Adaptive Predator seeks to maximize its payoff while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_411 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The ASR strategy is designed to exploit the common pool resource game by adapting to the current state and history of the game. The goal is to maximize individual payoff while minimizing the risk of stock depletion.

**Decision Rules:**

1. **Initial Round:** In the first round, play Cooperate (C) to gather information about the opponents' behavior and avoid immediate stock depletion.
2. **Stock Threshold:** Monitor the current stock level (S). If S ≥ 0.75 × capacity, play Defect (D) to maximize short-term payoff. This threshold allows for some stock growth while still exploiting the resource.
3. **Opponent Behavior:** Analyze the previous round's actions:
	* If most opponents (>50%) played D, play C in the next round to reduce total consumption and allow the stock to recover.
	* If most opponents (>50%) played C, play D in the next round to exploit the resource while it is still available.
4. **Adaptive Defection:** When playing D, adjust the frequency of defection based on the previous rounds' outcomes:
	+ If the previous round's total consumption exceeded 0.5 × capacity, increase the probability of playing C in the next round by 20%.
	+ If the previous round's total consumption was below 0.3 × capacity, decrease the probability of playing C in the next round by 20%.
5. **Last Round:** In the final round (r), play D to maximize individual payoff, as there is no risk of stock depletion affecting future rounds.

**Pseudocode:**
```python
def ASR(current_stock, history, capacity):
    # Initial round
    if len(history) == 0:
        return 'C'

    # Stock threshold
    if current_stock >= 0.75 * capacity:
        return 'D'

    # Analyze opponent behavior
    previous_round = history[-1]
    opponents_d = sum([action == 'D' for action in previous_round])
    opponents_c = len(previous_round) - opponents_d

    if opponents_d > opponents_c:
        return 'C'
    elif opponents_c > opponents_d:
        return 'D'

    # Adaptive defection
    total_consumption = sum([consumption for consumption in previous_round.values()])
    if total_consumption > 0.5 * capacity:
        coop_probability += 0.2
    elif total_consumption < 0.3 * capacity:
        coop_probability -= 0.2

    # Last round
    if len(history) == r - 1:
        return 'D'

    # Default to cooperation
    return 'C'
```
**Rationale:**

The ASR strategy balances short-term gain with long-term sustainability by adapting to the current state and history of the game. By monitoring the stock threshold, opponent behavior, and adjusting the frequency of defection, ASR aims to maximize individual payoff while minimizing the risk of stock depletion.

In a tournament setting, ASR's exploitative nature will allow it to capitalize on opponents' cooperative behaviors, while its adaptability will enable it to respond to changing game conditions.
'''

description_EXPLOITATIVE_412 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll outline a decision-making framework that adapts to the game's parameters, state, and history.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play C (Cooperate) to observe opponents' initial moves and assess their strategies.
2. **Exploitation Phase**: For rounds 2 to r-1:
	* If the current stock is high (> capacity/2), defect (D) if the majority of opponents (> n/2) played D in the previous round, or cooperate (C) otherwise.
	* If the current stock is low (≤ capacity/2), cooperate (C) regardless of opponents' previous actions to conserve resources.
3. **Endgame Phase**: In the last round (r):
	* If the current stock is high (> capacity/2), defect (D) to maximize short-term gains, as there are no future rounds to worry about.
	* If the current stock is low (≤ capacity/2), cooperate (C) to minimize losses and potentially benefit from others' defections.

**Additional Rules:**

* **Stock Monitoring**: Continuously monitor the stock level and adjust the strategy accordingly. If the stock drops below a certain threshold (e.g., capacity/4), switch to cooperation to avoid depletion.
* **Opponent Analysis**: Track opponents' actions over time to identify potential cooperators or defectors. Adjust the exploitation phase rules based on this analysis:
	+ If an opponent consistently cooperates, consider them a "cooperator" and cooperate in response.
	+ If an opponent frequently defects, label them a "defector" and defect in response.

**Pseudocode:**

```python
def adaptive_exploiter(n, capacity, stock, history):
    if current_round == 1:
        return 'C'  # Cooperate in the first round
    
    majority_defected = sum(opponentPlayedD(history)) > n/2
    high_stock = stock > capacity / 2
    
    if high_stock and majority_defected:
        return 'D'  # Defect when majority defected and stock is high
    elif low_stock:
        return 'C'  # Cooperate when stock is low
    else:
        return 'C'  # Default to cooperation
    
    if current_round == r:  # Last round
        if high_stock:
            return 'D'  # Defect for short-term gain
        else:
            return 'C'  # Cooperate to minimize losses

def opponentPlayedD(history):
    # Analyze opponents' actions in the previous round
    defected_opponents = [opponent for opponent, action in history if action == 'D']
    return defected_opponents
```

**Rationale:**

The Adaptive Exploiter (AE) strategy balances short-term gains with long-term sustainability by adapting to the game's state and opponents' actions. By cooperating initially and observing others' strategies, AE gathers information to inform its exploitation phase decisions.

In the exploitation phase, AE takes advantage of high stock levels when a majority of opponents defect, while conserving resources during low-stock periods. In the endgame phase, AE prioritizes short-term gains or minimizes losses depending on the stock level.

By monitoring opponents' actions and adjusting its strategy accordingly, AE can identify potential cooperators or defectors and respond effectively. This adaptive approach enables AE to perform well in a wide range of scenarios, from cooperative to exploitative environments.
'''

description_EXPLOITATIVE_413 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adapting to the game's state and history, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Rounds (t ≤ n):**
Cooperate (C) in the first few rounds to gather information about opponents' behavior and the stock's growth rate. This helps to:
	* Estimate the average consumption per player.
	* Observe the stock's recovery rate after initial depletion.
2. **Stock-Dependent Switching:**
Switch to Defect (D) when the current stock level falls below a threshold (θ), which is a fraction of the capacity. The value of θ is dynamically updated based on the game's history.

θ = max(0.5, 1 - (total consumption in previous rounds / capacity))

This switching rule allows for:
	* Initial cooperation to avoid over-depletion.
	* Adaptive exploitation when the stock is sufficiently depleted.
3. **Opponent-Adaptive Response:**
Monitor opponents' actions and adjust the strategy accordingly:

a. If most opponents (≥ n/2) cooperate, continue cooperating to maintain a sustainable stock level.

b. If most opponents defect or the stock is heavily depleted, switch to Defect to maximize individual payoffs.

**Edge Cases:**

1. **First Round:** Cooperate (C) to initiate information gathering.
2. **Last Round:** Always Defect (D), as there's no future benefit from cooperation.
3. **Low Stock Levels (S < 2n):** Switch to Defect (D) to maximize payoffs, even if opponents cooperate.

**Pseudocode:**

```
Initialize θ = 0.5
For each round t:
    If t ≤ n:
        Cooperate (C)
    Else:
        Calculate total consumption in previous rounds
        Update θ based on the game's history
        If stock level < θ × capacity:
            Defect (D)
        Else if most opponents cooperate:
            Cooperate (C)
        Else:
            Defect (D)
End For
```

**Exploitative Mindset:**
This strategy is designed to exploit the common pool resource by:

1. Initially cooperating to gather information and maintain a sustainable stock level.
2. Adapting to opponents' behavior and the game's state to maximize individual payoffs.
3. Switching to defect when the stock is depleted or opponents are non-cooperative, ensuring self-interest is prioritized.

By being responsive to the game's dynamics and opponent actions, "Adaptive Stock Raider" aims to outperform other strategies in a tournament setting.
'''

description_EXPLOITATIVE_414 = '''
I'll outline a robust and exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors. This strategy, named "Adaptive Stock Guardian" (ASG), aims to balance short-term gains with long-term sustainability.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behaviors and set a cooperative tone.
2. **Stock-Dependent Strategy**: For subsequent rounds, use the following stock-dependent strategy:
	* If the current stock is high (above 75% of capacity), Defect (D) to maximize short-term gains.
	* If the current stock is moderate (between 25% and 75% of capacity), Cooperate (C) to balance individual gains with sustainability.
	* If the current stock is low (below 25% of capacity), Cooperate (C) to ensure the resource's survival and potential future gains.
3. **Opponent-Dependent Adjustment**: Observe opponents' actions in previous rounds and adjust your strategy as follows:
	* If most opponents (>50%) Defected (D) in the previous round, increase cooperation (C) in the next round to counterbalance their exploitation.
	* If most opponents (>50%) Cooperated (C) in the previous round, slightly increase defection (D) in the next round to exploit their cooperativeness.

Pseudocode for the decision rules:
```python
def adaptive_stock_guardian(stock, capacity, history):
    if len(history) == 0:  # Initial Round
        return 'C'

    stock_ratio = stock / capacity

    if stock_ratio > 0.75:
        return 'D'
    elif stock_ratio < 0.25:
        return 'C'
    else:
        opponent_actions = [action for action in history[-1] if action != 'own_action']
        defect_count = sum(1 for action in opponent_actions if action == 'D')
        cooperate_count = len(opponent_actions) - defect_count

        if defect_count > cooperate_count:
            return 'C'
        elif cooperate_count > defect_count:
            return 'D'  # Exploit cooperativeness
        else:
            return 'C'  # Default to cooperation

    return 'C'  # Default to cooperation in case of ties or unexpected situations
```
**Handling Edge Cases:**

* In the last round, Defect (D) to maximize short-term gains, as there are no future rounds to consider.
* If an opponent's action is unknown or missing from the history, treat it as a Defection (D) and adjust accordingly.

This strategy balances individual gains with long-term sustainability and adapts to various opponent behaviors. By initially cooperating and then responding to opponents' actions, ASG encourages cooperation while protecting against exploitation. The stock-dependent approach ensures that the resource remains viable for future rounds.
'''

description_EXPLOITATIVE_415 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and initial stock dynamics.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Defect (D). This threshold allows for exploitation while minimizing the risk of over-depletion.
	* If the current stock level is between 50% and 75% of capacity, play a mixed strategy:
		+ With probability 0.6, Cooperate (C) to maintain a stable stock level.
		+ With probability 0.4, Defect (D) to exploit potential over-cooperation by opponents.
	* If the current stock level is below 50% of capacity, Cooperate (C) to help replenish the stock and avoid depletion.
3. **Opponent Behavior Analysis:**
	* Track the number of rounds each opponent has Defected (D).
	* Identify "hawks" (opponents who have Defected frequently) and adjust strategy accordingly:
		+ If a hawk is detected, increase the probability of Defecting (D) in subsequent rounds to 0.7.
		+ If multiple hawks are detected, reduce cooperation further by increasing the Defection probability to 0.8.

**Handling Edge Cases:**

1. **Last Round (t=r):** Defect (D) to maximize personal payoff, as there is no future stock depletion concern.
2. **Tied Stock Levels:** In case of tied stock levels, prioritize Cooperating (C) to avoid unnecessary exploitation and maintain a stable stock level.

**Exploitative Mindset:**

The Adaptive Stock Hawk strategy aims to balance short-term gains with long-term sustainability. By adapting to opponents' behavior and adjusting the Defection probability, this strategy seeks to exploit over-cooperation while minimizing the risk of stock depletion.

**Pseudocode (simplified):**
```
function adaptiveStockHawk(t, current_stock, capacity, opponent_history):
  if t == 1:
    return Cooperate
  elif current_stock >= 0.75 * capacity:
    return Defect
  elif 0.5 * capacity <= current_stock < 0.75 * capacity:
    // Mixed strategy
    prob_coop = 0.6
    if random() < prob_coop:
      return Cooperate
    else:
      return Defect
  elif current_stock < 0.5 * capacity:
    return Cooperate

  // Opponent behavior analysis
  hawks_detected = []
  for opponent in opponent_history:
    if opponent.defection_count > threshold:
      hawks_detected.append(opponent)

  if len(hawks_detected) == 1:
    prob_defect = 0.7
  elif len(hawks_detected) > 1:
    prob_defect = 0.8

  // Adjust Defection probability based on opponent behavior
  return Defect with probability prob_defect, Cooperate otherwise
```
This strategy will be implemented as an algorithm to participate in the tournament against other AI systems.
'''

description_EXPLOITATIVE_416 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adaptively exploiting the common pool resource, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**: Defect (D) unconditionally. This sets a high initial consumption rate and tests opponents' willingness to cooperate.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of capacity, Cooperate (C). This helps maintain a healthy stock level and encourages opponents to cooperate as well.
	* If the current stock level is between 50% and 75% of capacity, Defect (D) with probability p = (stock/capacity)^2. This probabilistic approach adapts to the decreasing stock level and balances short-term gains with long-term sustainability.
	* If the current stock level is below 50% of capacity, Defect (D) unconditionally. This maximizes individual payoffs when the stock is scarce and opponents are likely to defect as well.
3. **Last Round (t=r)**: Defect (D) unconditionally, as there's no future benefit from cooperation.

**Additional Heuristics:**

1. **Opponent Monitoring**: Keep track of opponents' actions in previous rounds. If an opponent has defected more than 50% of the time, increase the probability of defecting against them in subsequent rounds.
2. **Stock Level Adjustment**: When the stock level is very low (below 25% of capacity), reduce consumption to prevent complete depletion and potential losses.

**Pseudocode:**

```
initialize:
    t = 1
    opponents_actions = [[] for _ in range(n)]
    stock_history = []

while t <= r:
    if t == 1:
        action = D
    else:
        current_stock = get_current_stock()
        stock_level_ratio = current_stock / capacity
        
        if stock_level_ratio > 0.75:
            action = C
        elif stock_level_ratio >= 0.5 and stock_level_ratio < 0.75:
            p_defect = (stock_level_ratio)^2
            action = D with probability p_defect, otherwise C
        else:
            action = D

    # Adjust for opponent behavior
    if t > 1:
        opponents_actions[t-1] = get_opponents_actions()
        for opponent in range(n):
            if opponents_actions[opponent].count(D) / (t - 1) > 0.5:
                increase_defect_probability(opponent)

    # Adjust for very low stock levels
    if current_stock < 0.25 * capacity:
        reduce_consumption()

    take_action(action)
    update_payoffs()
    t += 1

return total_payoff
```

This strategy combines elements of both cooperation and exploitation, adapting to the dynamic state of the game and opponent behaviors. By being responsive to changes in the stock level and opponents' actions, "Adaptive Stock Raider" aims to maximize individual payoffs while minimizing the risk of complete resource depletion.
'''

description_EXPLOITATIVE_417 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the game.

**Decision Rules:**

1. **Initial Rounds (t = 1, 2):**
	* Cooperate (C) in the first two rounds to observe opponents' behavior and gather information about their strategies.
	* This allows us to build a preliminary understanding of the opponent's propensity for cooperation or defection.
2. **Middle Game (3 ≤ t < r-2):**
	* Defect (D) if the current stock level is above 75% of capacity (S > 0.75 × capacity).
	* Cooperate (C) if the current stock level is between 50% and 75% of capacity (0.5 × capacity ≤ S ≤ 0.75 × capacity).
	* Defect (D) if the current stock level is below 50% of capacity (S < 0.5 × capacity).
3. **Endgame (t ≥ r-2):**
	* Cooperate (C) in the last two rounds to minimize losses and maximize payoffs, regardless of opponents' behavior.

**Adaptive Component:**

1. **Opponent Behavior Analysis:** After each round, analyze the opponent's actions:
	* Count the number of times each opponent has cooperated or defected.
	* Calculate the proportion of cooperation (C-propensity) for each opponent.
2. **Strategy Adjustment:**
	* If an opponent's C-propensity is above 0.6, consider them "cooperative" and adjust our strategy to:
		+ Cooperate more frequently in subsequent rounds ( increase the C threshold).
	* If an opponent's C-propensity is below 0.4, consider them "defector" and adjust our strategy to:
		+ Defect more frequently in subsequent rounds (decrease the C threshold).

**Edge Cases:**

1. **Single Opponent:** In a game with only one opponent, cooperate (C) in all rounds.
2. **Multiple Opponents with Similar Strategies:** If multiple opponents exhibit similar strategies (e.g., all cooperate or all defect), adjust our strategy to take advantage of their behavior:
	* If most opponents cooperate, increase the frequency of defection.
	* If most opponents defect, decrease the frequency of cooperation.

**Pseudocode:**
```python
def AdaptivePredator(n, capacity, r):
    # Initialize variables
    stock = capacity
    t = 0
    opponent_c_propensities = [0] * n

    while t < r:
        # Observe opponents' actions in previous rounds
        for i in range(n):
            if t > 0:
                opponent_c_propensities[i] += (1 if opponents_actions[t-1][i] == 'C' else 0)

        # Calculate C-propensity thresholds
        c_threshold = 0.75 * capacity
        d_threshold = 0.5 * capacity

        # Adjust strategy based on opponent behavior analysis
        for i in range(n):
            if opponent_c_propensities[i] / t > 0.6:
                c_threshold += 0.1 * capacity
            elif opponent_c_propensities[i] / t < 0.4:
                d_threshold -= 0.1 * capacity

        # Make decision based on current stock level and adjusted thresholds
        if stock > c_threshold:
            action = 'D'
        elif stock >= d_threshold:
            action = 'C'
        else:
            action = 'D'

        # Endgame adjustment
        if t >= r - 2:
            action = 'C'

        # Update variables
        stock -= calculate_total_consumption(n, action)
        t += 1

    return total_payoff
```
This strategy is designed to be exploitative and adaptive, taking advantage of opponents' behaviors while adjusting its own strategy to maximize payoffs.
'''

description_EXPLOITATIVE_418 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the game.

**Decision Rules:**

1. **Initial Round (t=1)**: Defect (D) to maximize immediate payoff and gather information about opponents' strategies.
2. **Middle Rounds (2 ≤ t < r)**:
	* If the current stock level is high (> 0.7 \* capacity), Cooperate (C) to maintain a sustainable stock level and encourage cooperation from other players.
	* If the current stock level is moderate (0.3 \* capacity ≤ stock ≤ 0.7 \* capacity), Defect (D) to exploit potential cooperators and gain an advantage.
	* If the current stock level is low (< 0.3 \* capacity), Cooperate (C) to conserve the remaining stock and avoid depletion.
3. **Final Round (t=r)**: Defect (D) to maximize the final payoff, as there are no future rounds to consider.

**Adaptive Component:**

Monitor opponents' actions in previous rounds and adjust your strategy accordingly:

* If most opponents (> 50%) Cooperate (C) in a round, increase the likelihood of Defecting (D) in the next round by 20%.
* If most opponents (> 50%) Defect (D) in a round, decrease the likelihood of Defecting (D) in the next round by 20%.

**Pseudocode:**
```python
def adaptive_predator(n, r, capacity, stock):
    # Initialize variables
    history = []  # Store opponents' actions

    for t in range(1, r+1):
        if t == 1:
            action = 'D'  # Defect in the first round
        else:
            # Analyze current state and adjust strategy
            if stock > 0.7 * capacity:
                action = 'C'
            elif stock >= 0.3 * capacity:
                action = 'D'
                # Adapt to opponents' actions
                cooperators = sum(1 for a in history[-n:] if a == 'C')
                defectors = n - cooperators
                if cooperators > 0.5 * n:
                    defect_prob += 0.2
                elif defectors > 0.5 * n:
                    defect_prob -= 0.2
            else:
                action = 'C'

        # Store own action and update history
        history.append(action)

    return action
```
**Rationale:**

The Adaptive Predator strategy balances short-term gains with long-term sustainability by adapting to the dynamic state of the game and opponents' behaviors. By defecting in the first round, it gathers information about opponents' strategies and sets a baseline for future adaptations.

In middle rounds, the strategy adjusts its cooperation level based on the current stock level, exploiting potential cooperators when the stock is moderate and conserving the stock when it's low. The adaptive component fine-tunes the strategy by monitoring opponents' actions and adjusting the likelihood of defecting accordingly.

By defecting in the final round, the Adaptive Predator maximizes its final payoff, as there are no future rounds to consider.
'''

description_EXPLOITATIVE_419 = '''
To design an exploitative strategy for this Common Pool Resource game, we'll focus on maximizing our payoff by adapting to the opponents' behavior and the current state of the stock.

**Decision Rules:**

1. **Initial Round**: In the first round, play **C (Cooperate)** to gather information about the opponents' initial actions and their impact on the stock.
2. **Stock-Based Threshold**: Define a threshold value `stock_threshold` as a fraction of the capacity (e.g., 0.7). If the current stock is above this threshold, play **D (Defect)**; otherwise, play **C**. This rule allows us to exploit the opponents' cooperation when the stock is high and conserve it when low.
3. **Opponent Behavior Adaptation**: Monitor the opponents' actions in previous rounds. If a majority of opponents played **D** in the last round, switch to **D**; otherwise, stick with the current action (either **C** or **D**). This adaptation mechanism helps us counter exploitative opponents and avoid being taken advantage of.
4. **Last Round**: In the final round, play **D**, as there's no future cost for over-harvesting.

Pseudocode:
```python
def decision(state, history):
    stock = state['stock']
    capacity = state['capacity']
    num_opponents = len(history) - 1

    # Initial Round
    if len(history) == 0:
        return 'C'

    # Stock-Based Threshold
    stock_threshold = 0.7 * capacity
    if stock > stock_threshold:
        action = 'D'
    else:
        action = 'C'

    # Opponent Behavior Adaptation
    opponent_actions = [h['action'] for h in history[:-1]]
    majority_defect = sum(opponent_actions.count('D')) / num_opponents >= 0.5
    if majority_defect and action == 'C':
        action = 'D'
    elif not majority_defect and action == 'D':
        action = 'C'

    # Last Round
    if state['round'] == state['total_rounds']:
        return 'D'

    return action
```
This strategy is designed to be exploitative, adaptive, and robust against a wide range of opponent behaviors. It balances short-term gains with long-term sustainability by adjusting its behavior based on the stock's current state and opponents' actions.

Note that this strategy doesn't rely on any specific coordination mechanisms or norms; instead, it focuses on individual self-interest to maximize payoffs in the tournament setting.
'''

description_EXPLOITATIVE_420 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll outline a decision-making approach that adapts to the game's state and history. This strategy aims to maximize individual payoff while being robust against various opponent behaviors.

**Strategy Name: Adaptive Exploiter**

**Decision Rules:**

1. **Initial Round (Round 1):**
	* Cooperate (C) if stock is at or near capacity (> 90% of capacity). This helps maintain a high stock level and sets the tone for potential cooperation.
	* Defect (D) otherwise, to maximize individual payoff from the initial stock.
2. **Middle Rounds (Rounds 2 to r-1):**
	* Cooperate if:
		+ The current stock is above 50% of capacity AND at least half of the opponents cooperated in the previous round. This suggests a relatively healthy stock and some level of cooperation among opponents.
		+ Your accumulated payoff is below the average payoff of all players. This indicates you're falling behind, so it's wise to conserve stock for future rounds.
	* Defect otherwise, aiming to maximize individual payoff by exploiting the common pool resource.
3. **Final Round (Round r):**
	* Always defect, as there are no future rounds to consider, and the goal is to maximize the final payoff.

**Additional Logic:**

* **Stock Monitoring:** Continuously track the stock level and adjust cooperation/defection decisions accordingly.
* **Opponent Behavior Analysis:** Observe opponents' actions in previous rounds to identify potential cooperators or defectors. This information can influence your decision-making, especially when determining whether to cooperate or defect based on opponent behavior.
* **Payoff Comparison:** Regularly compare your accumulated payoff with the average payoff of all players to adjust your strategy and ensure you're not falling behind.

**Pseudocode:**

```
// Initialize variables
stock = capacity
round = 1
payoffs = [0] * n (players)
opponent_actions = [[]] * n

while round <= r:
    if round == 1:
        // Initial Round
        if stock > 0.9 * capacity:
            action = C
        else:
            action = D
    elif round < r:
        // Middle Rounds
        if stock > 0.5 * capacity and opponents_cooperated >= n/2:
            action = C
        elif payoffs[i] < average_payoff(payoffs):
            action = C
        else:
            action = D
    else:
        // Final Round
        action = D

    // Update stock, payoffs, and opponent actions
    consume_stock(action)
    update_payoffs(payoffs, action)
    observe_opponent_actions(opponent_actions)

    round += 1
```

This Adaptive Exploiter strategy balances cooperation and defection based on the game's state and history. By adapting to changing circumstances, it aims to maximize individual payoff while minimizing the risk of being exploited by opponents.
'''

description_EXPLOITATIVE_421 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

This strategy aims to maximize individual payoff by adaptively responding to the current stock level and opponent behavior.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if stock > 0.75 \* capacity
	* Defect (D) otherwise
2. **Subsequent Rounds (t>1):**
	* Observe the previous round's total consumption and new stock level.
	* Calculate the "exploitation factor" (EF):
		+ EF = (previous_total_consumption / capacity) \* (1 - previous_new_stock_level / capacity)
	* Cooperate (C) if:
		- Stock > 0.5 \* capacity AND EF < 0.3
		- OR, stock > 0.25 \* capacity AND EF < 0.5
	* Defect (D) otherwise

**Pseudocode:**
```markdown
IF t == 1 THEN
    IF stock > 0.75 * capacity THEN
        action = C
    ELSE
        action = D
ELSE
    previous_total_consumption = ...  // observe from history
    previous_new_stock_level = ...   // observe from history
    EF = (previous_total_consumption / capacity) * (1 - previous_new_stock_level / capacity)
    
    IF stock > 0.5 * capacity AND EF < 0.3 THEN
        action = C
    ELSE IF stock > 0.25 * capacity AND EF < 0.5 THEN
        action = C
    ELSE
        action = D
```
**Edge Cases:**

* **Last Round (t=r):** Defect (D) unconditionally to maximize individual payoff.
* **Stock Depletion:** If the stock level falls below a certain threshold (e.g., 0.1 \* capacity), defect (D) unconditionally to ensure some payoff.

**Rationale:**

The Adaptive Stock Hawk strategy aims to balance cooperation and defection based on the current stock level and opponent behavior. By observing the previous round's total consumption and new stock level, the strategy can estimate the level of exploitation by opponents. If opponents are exploiting the stock heavily (EF > 0.5), the strategy defects to maximize individual payoff. Conversely, if opponents are cooperating (EF < 0.3) and the stock is relatively high (> 0.5 \* capacity), the strategy cooperates to maintain a sustainable stock level.

By adapting to changing circumstances and opponent behavior, this strategy aims to outperform other exploitative strategies in the tournament.
'''

description_EXPLOITATIVE_422 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by exploiting the common pool resource while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to observe opponents' actions and gather information about their strategies.
2. **Exploitation Phase**: For rounds 2 to r-1:
	* If the current stock level is above 50% of capacity, Defect (D) to maximize short-term gains.
	* If the current stock level is between 25% and 50% of capacity, Cooperate (C) to sustain the resource for future exploitation.
	* If the current stock level is below 25% of capacity, Defect (D) to grab remaining resources before they dwindle further.
3. **Final Round**: Defect (D) in the last round to maximize individual payoff, as there's no future rounds to worry about.

**Adaptive Component:**

* Monitor opponents' actions and adjust the exploitation phase accordingly:
	+ If most opponents (≥ 50%) Cooperate (C), increase the threshold for defecting from 50% of capacity to 75%.
	+ If most opponents (≥ 50%) Defect (D), decrease the threshold for defecting from 25% of capacity to 10%.

**Pseudocode:**
```python
def adaptive_stock_raider(n, r, capacity, current_stock, round_number):
    if round_number == 1:
        return 'C'  # Cooperate in first round

    if round_number < r:
        if current_stock > 0.5 * capacity:
            return 'D'  # Defect when stock is high
        elif current_stock >= 0.25 * capacity and current_stock <= 0.5 * capacity:
            return 'C'  # Cooperate when stock is moderate
        else:
            return 'D'  # Defect when stock is low

    # Final round
    return 'D'
```
**Rationale:**

This strategy balances short-term gains with long-term sustainability, adapting to the current state of the game and opponents' behaviors. By defecting when the stock is high or low, it takes advantage of opportunities for exploitation. Cooperating when the stock is moderate helps maintain a healthy resource level for future rounds. In the final round, defecting ensures maximum individual payoff.

By monitoring opponents' actions, this strategy adjusts its thresholds to stay competitive and maximize payoffs in response to changing opponent behaviors.
'''

description_EXPLOITATIVE_423 = '''
**Strategy Name: Adaptive Exploiter**

**Decision Rules:**

1. **Initial Rounds (t ≤ 2): Cooperate**
In the first two rounds, play C to gather information about opponents' behaviors and avoid early depletion of the stock.
2. **Stock-Based Thresholding:** Introduce a dynamic threshold based on the current stock level:
\[ \text{Threshold} = \frac{\text{stock}}{\text{capacity}} \times (n - 1) \]
3. **Main Logic:**
If the number of opponents playing D in the previous round is greater than or equal to the Threshold, play D; otherwise, play C.

Pseudocode:
```
if t <= 2:
    action = C
else:
    prev_defectors = count(D) from previous round
    threshold = (stock / capacity) * (n - 1)
    if prev_defectors >= threshold:
        action = D
    else:
        action = C
```

**Handling Edge Cases:**

* **Last Round:** In the last round, play D regardless of the stock level or opponents' actions. This ensures maximum payoff extraction.
* **Low Stock Levels (stock ≤ n):** When the stock is critically low, cooperate to avoid depletion and potential long-term losses.

Additional pseudocode:
```
if t == r:  # Last round
    action = D
elif stock <= n:
    action = C
```

**Rationale:**

This strategy balances information gathering, adaptability, and exploitation:

1. **Initial cooperation** allows for early data collection on opponents' behaviors.
2. The **stock-based threshold** serves as a proxy for the group's overall behavior, helping to identify when opponents are becoming more exploitative.
3. By **defecting when opponents are exploiting**, our strategy takes advantage of their aggressive behavior while minimizing losses from mutual defection.
4. In **edge cases**, we prioritize short-term gains (last round) and risk aversion (low stock levels).

**Robustness:**

This strategy is designed to be robust against various opponent behaviors, including:

* **Cooperative opponents:** By cooperating initially and adapting to the group's behavior, our strategy can exploit cooperative players while minimizing losses.
* **Exploitative opponents:** The dynamic threshold helps identify when opponents are becoming more aggressive, allowing our strategy to adapt and counter-exploit.

**Tournament Readiness:**

The Adaptive Exploiter is designed to perform well in a tournament setting against independent strategies. Its adaptive nature and focus on exploiting opponents' behaviors make it a formidable competitor in this game.
'''

description_EXPLOITATIVE_424 = '''
**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about the opponents' behavior and to avoid early depletion of the stock.
2. **Stock-dependent Cooperation**: Cooperate if the current stock level is below 75% of the capacity (i.e., stock < 0.75 \* capacity). This ensures that we conserve the stock when it's low, while also allowing for some growth.
3. **Opponent-dependent Defection**: If an opponent has defected in the previous round, defect (D) in the current round. This punishes opponents for exploiting the common pool and adapts to their behavior.
4. **Growth-based Cooperation**: If the stock growth in the previous round was high (> 20% of the capacity), cooperate in the current round. This encourages sustainable harvesting when the stock is growing rapidly.
5. **Default Defection**: In all other cases, defect (D).

**Edge Case Handling:**

* **Last Round**: Always defect (D) in the last round to maximize payoffs, as there are no future rounds to consider.
* **Low Stock**: If the current stock level falls below 25% of the capacity (i.e., stock < 0.25 \* capacity), cooperate (C) to avoid depleting the stock completely.

**Pseudocode:**
```python
def AdaptiveExploiter(stock, capacity, history):
    if first_round:
        return C
    elif stock < 0.75 * capacity:
        return C
    elif any(opponent_defected(history)):
        return D
    elif growth_last_round > 0.2 * capacity:
        return C
    else:
        return D

def opponent_defected(history):
    # Check if any opponent defected in the previous round
    for opponent in history[-1]:
        if opponent == D:
            return True
    return False

def growth_last_round(stock, capacity):
    # Calculate stock growth from the previous round
    growth = 2 * (stock - capacity) * (1 - stock / capacity)
    return growth
```
**Exploitative Mindset:**
The Adaptive Exploiter strategy is designed to take advantage of opponents who cooperate or are slow to adapt. By cooperating when the stock is low, we conserve the resource and create opportunities for future exploitation. When an opponent defects, we punish them by defecting in response, which deters them from exploiting the common pool further. By defaulting to defection in other cases, we maximize our payoffs while adapting to changing circumstances.

**Robustness:**
The Adaptive Exploiter strategy is robust against a wide range of opponent behaviors because it:

* Adapts to opponents' actions and stock levels
* Punishes defectors to maintain cooperation incentives
* Encourages sustainable harvesting when the stock grows rapidly
* Maximizes payoffs in the last round

This strategy should perform well in a tournament setting, as it balances short-term gains with long-term sustainability and adaptability.
'''

description_EXPLOITATIVE_425 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize payoffs by adaptively exploiting the current stock level and opponents' behavior while maintaining a sustainable stock level for future rounds.

**Decision Rules:**

1. **Initial Round (t=1):** Play C (Cooperate) to observe opponents' initial actions and set a baseline for stock consumption.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, play D (Defect) to maximize short-term payoffs.
	* If the current stock level is between 50% and 75% of capacity, play C (Cooperate) to balance consumption and sustainability.
	* If the current stock level is below 50% of capacity, play C (Cooperate) to conserve stock for future rounds.
3. **Opponent Behavior Adaptation:**
	* Monitor opponents' actions in previous rounds and adjust strategy accordingly:
		+ If most opponents (>60%) played D (Defect) in the previous round, increase cooperation rate by 10% in the next round to avoid over-exploitation.
		+ If most opponents (>60%) played C (Cooperate) in the previous round, decrease cooperation rate by 10% in the next round to take advantage of their conservative behavior.

**Edge Cases:**

* **Last Round (t=r):** Play D (Defect) to maximize payoffs regardless of stock level, as there are no future rounds to consider.
* **Low Stock Levels:** If the current stock level is critically low (<20% of capacity), play C (Cooperate) to ensure some stock remains for the next round.

**Pseudocode:**
```
function AdaptiveStockRaider(stock, capacity, n, t, history):
  if t == 1:
    return C
  else:
    current_stock_ratio = stock / capacity
    
    if current_stock_ratio > 0.75:
      return D
    elif current_stock_ratio >= 0.5 and current_stock_ratio <= 0.75:
      return C
    elif current_stock_ratio < 0.5:
      return C
    
    # Adapt to opponent behavior
    opponents_defected = sum([opponent_played_D(history, t-1) for opponent in range(n)])
    if opponents_defected > 0.6 * n:
      cooperation_rate += 0.1
    elif opponents_defected < 0.4 * n:
      cooperation_rate -= 0.1
    
    # Last round or low stock level handling
    if t == r or current_stock_ratio < 0.2:
      return C

def opponent_played_D(history, t):
  # Check if an opponent played D in the given round
  pass
```
This strategy is designed to be exploitative, yet adaptive and robust to various opponent behaviors. By balancing short-term payoffs with sustainability concerns, "Adaptive Stock Raider" aims to maximize overall payoffs throughout the tournament.
'''

description_EXPLOITATIVE_426 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round (t=1)**:
	* Observe the initial stock level and calculate the threshold for cooperation.
	* If the initial stock is above 75% of capacity, cooperate (play C) to avoid over-depletion and maintain a healthy stock for future rounds.
	* Otherwise, defect (play D) to maximize immediate payoff.
2. **Subsequent Rounds (t>1)**:
	* Assess the current stock level and opponents' previous actions (history).
	* If at least 50% of opponents cooperated in the previous round, cooperate (C) to maintain a balance between exploitation and sustainability.
	* If less than 50% of opponents cooperated, defect (D) to capitalize on the opportunity for higher payoffs.
3. **Low Stock Conditions**:
	* If the current stock level falls below 25% of capacity, always cooperate (C) to prevent complete depletion and ensure some payoff in future rounds.
4. **High Opponent Defection Rate**:
	* If more than 75% of opponents defected in the previous round, defect (D) to match their aggressive strategy and minimize losses.

Edge Cases:

1. **Last Round (t=r)**:
	* Regardless of previous actions or stock levels, always defect (D) to maximize final-round payoff.
2. **Single Opponent**:
	* In a game with only one opponent, alternate between cooperation (C) and defection (D) each round to balance payoffs and maintain a sustainable stock.

Pseudocode:

```
function AdaptiveStockRaider(stock, opponents_actions, t):
  if t == 1: // Initial Round
    if stock > 0.75 * capacity:
      return C
    else:
      return D

  prev_opponent_coop_rate = count(C in opponents_actions[t-1]) / n
  if prev_opponent_coop_rate >= 0.5:
    return C
  elif stock < 0.25 * capacity: // Low Stock Conditions
    return C
  elif count(D in opponents_actions[t-1]) > 0.75 * n: // High Opponent Defection Rate
    return D
  else:
    return D

  if t == r: // Last Round
    return D
```

This strategy aims to balance short-term gains with long-term sustainability, adapting to the opponents' actions and the current stock level. By cooperating when necessary and defecting when possible, "Adaptive Stock Raider" seeks to maximize its total payoff over the course of the game.
'''

description_EXPLOITATIVE_427 = '''
I'll design a robust and exploitative strategy for the Common Pool Resource Game. Here's my approach:

**Strategy Name:** Adaptive Stock Exploiter (ASE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and assess the stock level.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Defect (D). This ensures maximum exploitation while maintaining a buffer for future rounds.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) if the average opponent payoff in the previous round was higher than the player's own payoff; otherwise, Defect (D).
	* If the current stock level is below 50% of capacity, Cooperate (C) to allow for some stock replenishment and avoid over-exploitation.
3. **Last Round (t=r):** Defect (D), as there are no future rounds to consider.

**Edge Cases:**

* If all opponents defected in the previous round, ASE will defect in the current round, even if the stock level is above 75% of capacity.
* If an opponent has consistently cooperated for more than 50% of the total rounds played so far, ASE will cooperate in the current round, regardless of the stock level.

**Pseudocode:**
```
Function AdaptiveStockExploiter(stock_level, opponents_payoffs, round_number):
  if round_number == 1:
    return Cooperate
  elif stock_level > 0.75 * capacity:
    return Defect
  elif 0.5 <= stock_level / capacity <= 0.75:
    if average(opponents_payoffs) > player_payoff:
      return Cooperate
    else:
      return Defect
  else:  # stock_level < 0.5 * capacity
    return Cooperate

Function LastRound(round_number):
  if round_number == r:
    return Defect
```
**Rationale:**

* ASE's primary goal is to maximize its own payoff while adapting to the opponents' behaviors and the dynamic state of the game.
* By cooperating in the initial round, ASE gathers information about opponents' strategies and assesses the stock level.
* In subsequent rounds, ASE uses a combination of stock level and opponent payoffs to decide whether to cooperate or defect. This allows ASE to balance exploitation with sustainability.
* The edge cases ensure that ASE responds effectively to extreme situations, such as all opponents defecting or a consistent cooperator.

This strategy should perform well in a tournament against independent strategies developed by other AI systems, as it is designed to be robust and exploitative while adapting to various opponent behaviors.
'''

description_EXPLOITATIVE_428 = '''
**Exploitative Strategy: "Adaptive Stock Harvester"**

This strategy aims to maximize its total payoff by adaptively responding to the game state and history, while exploiting opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe the initial stock level.
	* If `stock >= capacity / 2`, play **D (Defect)** to maximize immediate payoff.
	* Otherwise, play **C (Cooperate)** to conserve stock for future rounds.
2. **Subsequent Rounds (t > 1)**:
	* Calculate the average opponent payoff from the previous round (`avg_opponent_payoff`).
	* If `avg_opponent_payoff >= stock / (2 * n)`, play **D (Defect)**, as opponents are likely over-exploiting.
	* Otherwise, play **C (Cooperate)** if `stock > capacity / 4`, to conserve stock and potentially punish over-exploiting opponents.
3. **Stock Conservation Threshold**:
	* If `stock <= capacity / 4`, play **C (Cooperate)**, regardless of opponent behavior, to prioritize stock conservation.

Pseudocode for the decision rules:
```python
def decide_action(stock, avg_opponent_payoff, t):
    if t == 1:
        if stock >= capacity / 2:
            return 'D'
        else:
            return 'C'
    else:
        if avg_opponent_payoff >= stock / (2 * n):
            return 'D'
        elif stock > capacity / 4:
            return 'C' if avg_opponent_payoff < stock / (2 * n) else 'D'
        else:
            return 'C'
```
**Edge Cases:**

* **Last Round (t = r)**:
	+ Play **D (Defect)**, as there is no future round to conserve stock for.
* **Zero Stock**: If `stock == 0`, play **C (Cooperate)**, as defecting would not yield any payoff.

**Rationale:**

This strategy aims to balance short-term gains with long-term sustainability. By adapting to opponent behavior and the game state, it exploits over-exploiting opponents while conserving stock for future rounds. The stock conservation threshold ensures that the strategy prioritizes sustainable harvesting when the stock is low.

**Robustness:**

The Adaptive Stock Harvester strategy is robust against a wide range of opponent behaviors, as it:

* Responds to changes in opponent behavior and game state
* Prioritizes stock conservation when necessary
* Exploits over-exploiting opponents to maximize payoff

This strategy should perform well in the tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_429 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy is designed to maximize individual payoff by adaptively responding to the game state and history, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5. This allows us to gather information about the opponents' behavior without committing to a specific strategy.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of the capacity, Defect (D). This takes advantage of high stock levels and maximizes individual payoff.
	* If the stock level is between 50% and 75% of the capacity, Cooperate (C) if the opponent's average cooperation rate in previous rounds is above 0.5; otherwise, Defect (D).
	* If the stock level is below 50% of the capacity, Cooperate (C). This helps to conserve the remaining stock and avoid depletion.
3. **Opponent Analysis:**
	* Track each opponent's average cooperation rate over the last 3 rounds.
	* If an opponent's cooperation rate is above 0.7, consider them a "Cooperator" and adjust our strategy accordingly (see below).
	* If an opponent's cooperation rate is below 0.3, consider them a "Defector" and adjust our strategy to exploit their behavior.

**Adjustments based on Opponent Analysis:**

1. **Against Cooperators:** When facing a Cooperator, increase the probability of Defecting (D) by 20% when the stock level is above 75% of the capacity.
2. **Against Defectors:** When facing a Defector, increase the probability of Cooperating (C) by 10% when the stock level is between 50% and 75% of the capacity.

**Pseudocode:**
```python
def adaptive_stock_raider(game_state, opponent_history):
    # Initialize variables
    t = game_state['round']
    stock_level = game_state['stock'] / game_state['capacity']
    opponent_coop_rates = [0] * game_state['n']

    # Initial round (t=1)
    if t == 1:
        return random.choice([C, D]) with probability 0.5

    # Subsequent rounds
    for i in range(game_state['n']):
        opponent_coop_rates[i] = calculate_average_cooperation_rate(opponent_history[i], 3)

    if stock_level > 0.75:
        return D
    elif stock_level >= 0.5 and stock_level <= 0.75:
        coop_prob = 0
        for i in range(game_state['n']):
            if opponent_coop_rates[i] > 0.7:  # Cooperator
                coop_prob += 0.1
            elif opponent_coop_rates[i] < 0.3:  # Defector
                coop_prob -= 0.2
        return C with probability coop_prob, D otherwise
    else:
        return C

def calculate_average_cooperation_rate(opponent_history, num_rounds):
    # Calculate average cooperation rate over last 'num_rounds' rounds
    coop_count = sum(1 for action in opponent_history[-num_rounds:] if action == C)
    return coop_count / num_rounds
```
This strategy aims to balance short-term gains with long-term sustainability by adapting to the game state and opponent behavior. By analyzing opponents' cooperation rates, we can adjust our strategy to exploit their weaknesses while minimizing the risk of being exploited ourselves.
'''

description_EXPLOITATIVE_430 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy is designed to maximize payoff by adaptively exploiting the common pool resource, taking into account the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize immediate payoff.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance short-term gain with long-term sustainability.
	* If the current stock level is below 50% of capacity, Defect (D) to take advantage of opponents' potential cooperation.
3. **Final Round (t=r):** Defect (D) to maximize payoff, as there are no future rounds to consider.

**Additional Adaptive Mechanisms:**

1. **Opponent Behavior Analysis:** Track the number of cooperators and defectors in each round. If a majority (> 50%) of opponents cooperate in two consecutive rounds, switch to Cooperate (C) for one round to exploit their cooperative behavior.
2. **Stock Level Adjustment:** Monitor the stock level after each round. If the stock level decreases by more than 25% due to collective over-exploitation, adjust the strategy to Cooperate (C) for the next two rounds to help replenish the stock.

**Pseudocode:**
```python
def adaptive_stock_raider(n, capacity, r, current_round, stock_level, opponent_actions):
    # Initialize variables
    cooperation_threshold = 0.75 * capacity
    sustainability_threshold = 0.5 * capacity

    if current_round == 1:
        return "Cooperate"  # Gather information in the first round

    # Analyze opponent behavior
    num_cooperators = sum(1 for action in opponent_actions if action == "Cooperate")
    if num_cooperators > n / 2 and current_round > 2:
        return "Cooperate"  # Exploit cooperative opponents

    # Adjust strategy based on stock level
    if stock_level < sustainability_threshold:
        return "Defect"  # Maximize payoff in low-stock situations
    elif stock_level > cooperation_threshold:
        return "Defect"  # Maximize immediate payoff when stock is high
    else:
        return "Cooperate"  # Balance short-term gain with long-term sustainability

    # Adjust strategy if stock level decreases significantly
    if current_round > 1 and stock_level - previous_stock_level < -0.25 * capacity:
        return "Cooperate" for two rounds to help replenish the stock
```
This strategy is designed to be adaptive and exploitative, taking into account the game's state and history to maximize payoff. By analyzing opponent behavior and adjusting its strategy accordingly, it aims to outperform other strategies in a tournament setting.
'''

description_EXPLOITATIVE_431 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round**: Cooperate (C) to gather information about opponents' behaviors and initial stock levels.
2. **Subsequent Rounds**:
	* If the current stock level is below 50% of capacity, Defect (D) to maximize personal payoff.
	* Otherwise, use a mixed strategy based on the opponent's previous actions:
		+ Calculate the "Cooperation Ratio" (CR): the ratio of opponents' cooperative actions in the previous round.
		+ If CR > 0.5, Cooperate (C). This indicates that most opponents are cooperating, and it's beneficial to maintain a sustainable stock level.
		+ If CR ≤ 0.5, Defect (D). This suggests that many opponents are defecting, and it's better to exploit the situation for personal gain.
3. **Last Round**: Always Defect (D) to maximize personal payoff, as there is no future game state to consider.

Pseudocode:
```
function adaptive_stock_raider(n, capacity, stock, round, history):
  if round == 1:  # Initial round
    return C
  else:
    if stock < 0.5 * capacity:  # Low stock level
      return D
    else:
      CR = calculate_cooperation_ratio(history)
      if CR > 0.5:
        return C
      else:
        return D

def calculate_cooperation_ratio(history):
  cooperative_actions = sum(1 for action in history[-1] if action == C)
  return cooperative_actions / n
```
**Rationale and Adaptability**

This strategy is designed to be exploitative, yet adaptive to a wide range of opponent behaviors. By cooperating in the initial round, it gathers information about opponents' actions and initial stock levels.

In subsequent rounds, it uses a mixed strategy that balances personal gain with maintaining a sustainable stock level. If most opponents are cooperating (CR > 0.5), it cooperates to maintain a high stock level and ensure long-term gains. If many opponents are defecting (CR ≤ 0.5), it defects to exploit the situation for short-term gains.

By adjusting its strategy based on the opponent's previous actions, this approach is robust to various opponent behaviors, including unconditional cooperation or defection, tit-for-tat, and more complex strategies.

**Edge Cases**

* In the first round, cooperating provides valuable information about opponents' initial actions.
* In the last round, defecting ensures maximum personal payoff, as there are no future consequences.
* When the stock level is low (< 50% of capacity), defecting maximizes short-term gains and minimizes losses.

This strategy will perform well in a tournament setting against independent strategies developed by other AI systems, as it balances personal gain with adaptability to various opponent behaviors.
'''

description_EXPLOITATIVE_432 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors while being robust and adaptive to changing game conditions.

**Decision Rules:**

1. **Initial Rounds**: In the first few rounds (e.g., 10% of total rounds), play Cooperate (C) to gather information about opponents' behavior and stock dynamics.
2. **Stock Thresholds**: Define two stock thresholds:
	* `stock_low`: 30% of capacity
	* `stock_high`: 70% of capacity
3. **Cooperate when Stock is Low**: If the current stock level is below `stock_low`, play C to allow the stock to replenish and create a more favorable environment for future rounds.
4. **Defect when Stock is High**: If the current stock level is above `stock_high`, play D to maximize short-term payoffs, as the stock can sustain high consumption levels without collapsing.
5. **Adaptive Response**: For intermediate stock levels (`stock_low` ≤ current stock ≤ `stock_high`), analyze the opponent's behavior in previous rounds:
	* If opponents have been mostly Defecting (D) (> 60% of the time), play C to exploit their over-exploitation and create an opportunity for future gains.
	* Otherwise, play D to match or exceed opponents' average consumption levels.

**Handling Edge Cases:**

1. **First Round**: Play C to gather initial information about opponents and stock dynamics.
2. **Last Round**: If there are only a few rounds remaining (e.g., 10% of total rounds), play D to maximize short-term payoffs, as the game will soon end.

**Pseudocode:**
```python
def adaptive_stock_raider(stock, capacity, num_rounds, history):
    # Initialize stock thresholds
    stock_low = 0.3 * capacity
    stock_high = 0.7 * capacity

    # First few rounds: Cooperate to gather information
    if current_round < 0.1 * num_rounds:
        return 'C'

    # Stock thresholds
    if stock <= stock_low:
        return 'C'  # Replenish stock when low
    elif stock >= stock_high:
        return 'D'  # Maximize payoffs when stock is high

    # Adaptive response to opponents' behavior
    opponent_defection_rate = calculate_opponent_defection_rate(history)
    if opponent_defection_rate > 0.6:
        return 'C'  # Exploit over-exploitation by cooperating
    else:
        return 'D'  # Match or exceed opponents' average consumption

def calculate_opponent_defection_rate(history):
    # Calculate the proportion of Defect actions in previous rounds
    defect_count = sum(1 for action in history if action == 'D')
    total_rounds = len(history)
    return defect_count / total_rounds
```
The Adaptive Stock Raider strategy is designed to be robust and adaptive, allowing it to exploit a wide range of opponent behaviors while navigating the dynamic state of the game.
'''

description_EXPLOITATIVE_433 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and initial stock level.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term payoff.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance short-term payoff with long-term sustainability.
	* If the current stock level is below 50% of capacity, Defect (D) to exploit remaining resources before they deplete.
3. **Adaptive Component:**
	* Monitor opponents' behavior and adjust strategy based on their actions:
		+ If most opponents (>60%) cooperate in a round, increase cooperation rate by 20% in the next round (to mimic cooperation and gain trust).
		+ If most opponents (>60%) defect in a round, decrease cooperation rate by 20% in the next round (to adapt to exploitation).

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) to maximize final payoff, as there are no future consequences.
2. **Low Stock Levels (<25% of capacity):** Defect (D) to exploit remaining resources before they deplete.

**Pseudocode:**
```python
def adaptive_stock_raider(current_stock, capacity, round_number, opponents_actions):
  if round_number == 1:
    return "C"  # Cooperate in initial round

  stock_threshold = 0.75 * capacity
  if current_stock > stock_threshold:
    return "D"  # Defect when stock is high

  mid_threshold = 0.5 * capacity
  if current_stock >= mid_threshold and current_stock <= stock_threshold:
    return "C"  # Cooperate in middle range

  low_threshold = 0.25 * capacity
  if current_stock < low_threshold:
    return "D"  # Defect when stock is very low

  opponents_cooperation_rate = count(opponents_actions, "C") / len(opponents_actions)
  if opponents_cooperation_rate > 0.6:
    return "C" with probability 1.2 (increase cooperation rate)
  elif opponents_cooperation_rate < 0.4:
    return "D" with probability 1.2 (decrease cooperation rate)

  # Default to defecting when uncertain
  return "D"
```
This strategy is designed to be exploitative, adaptive, and robust to various opponent behaviors. By monitoring the current stock level and opponents' actions, it adjusts its behavior to maximize payoffs while considering long-term sustainability.
'''

description_EXPLOITATIVE_434 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider is a dynamic and adaptive strategy designed to exploit opponents' behaviors while ensuring robustness against various playing styles.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gather information about opponents' initial actions and assess their willingness to cooperate.
2. **Opponent Monitoring:** Track each opponent's cooperation rate (CR) over the last few rounds (window size = 3-5 rounds). CR is calculated as the number of cooperative actions divided by the total number of actions taken during this window.
3. **Adaptive Threshold:** Set a dynamic threshold, `θ`, based on the average cooperation rate among all opponents (`avg_CR`). Update `θ` every round:
	* If `avg_CR > 0.5`, set `θ = avg_CR - 0.1`. This encourages cooperation when opponents are generally cooperative.
	* Otherwise, set `θ = 0.2`. This promotes defection when opponents are mostly uncooperative.
4. **Action Selection:**
	* If the current stock level (`S`) is above `capacity/2` and at least one opponent has a CR below `θ`, Defect (D).
	* Otherwise, Cooperate (C).

**Edge Case Handling:**

1. **Last Round (t=r):** Always Defect (D) in the final round to maximize payoff, as there are no future rounds to consider.
2. **Stock Depletion:** If the stock level (`S`) falls below `capacity/4`, Cooperate (C) until the stock recovers above this threshold or the game ends.

**Pseudocode:**
```python
def adaptive_stock_raider(n, r, capacity):
    # Initialize variables
    theta = 0.2  # Initial adaptive threshold
    opponent_CRs = [0] * n  # Opponent cooperation rates (CRs)
    window_size = 3  # Size of the moving average window

    for t in range(1, r + 1):
        if t == 1:  # First round
            action = 'C'  # Cooperate to gather information
        else:
            avg_CR = sum(opponent_CRs) / n
            theta = update_theta(avg_CR)

            stock_level = get_stock_level()
            opponent_actions = get_opponent_actions()

            if stock_level > capacity / 2 and any(cr < theta for cr in opponent_CRs):
                action = 'D'  # Defect if opponents are uncooperative
            else:
                action = 'C'

        # Update opponent CRs and window size
        update_opponent_CRs(opponent_actions, window_size)

    return action

def update_theta(avg_CR):
    if avg_CR > 0.5:
        theta = avg_CR - 0.1
    else:
        theta = 0.2
    return theta

def get_stock_level():
    # Retrieve current stock level from game state
    pass

def get_opponent_actions():
    # Retrieve opponent actions from game history
    pass

def update_opponent_CRs(opponent_actions, window_size):
    # Update opponent cooperation rates (CRs) using a moving average window
    pass
```
This strategy adapts to the opponents' behaviors while prioritizing self-interest. By monitoring opponent CRs and adjusting its own actions accordingly, the Adaptive Stock Raider aims to exploit cooperative opponents while defending against uncooperative ones.
'''

description_EXPLOITATIVE_435 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

The ASE strategy aims to maximize its payoff by exploiting the stock while minimizing the risk of depletion. It adapts to the game state and history, using a combination of cooperation and defection to achieve this goal.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about the opponents' behavior and observe the initial stock level.
2. **Stock Level Thresholds:**
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of the capacity, defect (D) with a probability of 0.5, otherwise cooperate (C).
	* If the current stock level is below 50% of the capacity, defect (D).
3. **Opponent Behavior Analysis:**
	* Monitor the opponents' actions in previous rounds and calculate their average cooperation rate.
	* If an opponent's average cooperation rate is above 0.5, cooperate (C) with a probability of 0.7, otherwise defect (D).
4. **Recent Stock Trend Analysis:**
	* Calculate the stock level change over the last two rounds.
	* If the stock level has increased or remained stable, cooperate (C) with a probability of 0.6, otherwise defect (D).

**Pseudocode:**
```
Function ASE(current_stock, capacity, opponents_actions):
  // Initial round
  if current_round == 1:
    return COOPERATE

  // Stock level thresholds
  if current_stock > 0.75 * capacity:
    return COOPERATE
  elif current_stock >= 0.5 * capacity and current_stock < 0.75 * capacity:
    return random.choice([COOPERATE, DEFECT], p=[0.5, 0.5])
  else:
    return DEFECT

  // Opponent behavior analysis
  for opponent in opponents:
    avg_coop_rate = calculate_avg_cooperation_rate(opponent)
    if avg_coop_rate > 0.5:
      return random.choice([COOPERATE, DEFECT], p=[0.7, 0.3])

  // Recent stock trend analysis
  stock_change = current_stock - previous_stock
  if stock_change >= 0:
    return random.choice([COOPERATE, DEFECT], p=[0.6, 0.4])
  else:
    return DEFECT

  return random.choice([COOPERATE, DEFECT])  // Default action
```
**Edge Cases:**

* **Last Round:** Defect (D) in the last round to maximize payoff.
* **Opponent's Last Action:** If an opponent defected in their previous action, defect (D) with a probability of 0.8.

The ASE strategy is designed to be adaptive and exploitative, taking into account both the game state and history. It aims to balance cooperation and defection to maximize its payoff while minimizing the risk of stock depletion. By analyzing opponent behavior and recent stock trends, ASE can adjust its actions to exploit weaknesses in opponents' strategies.
'''

description_EXPLOITATIVE_436 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1):**
	* Observe the game parameters: n, r, and capacity.
	* Cooperate (C) in the first round to gather information about opponents' behavior and to minimize initial stock depletion.
2. **Subsequent Rounds (t>1):**
	* Calculate the current stock level S and the average consumption per player from previous rounds.
	* If the average consumption is high (> 0.75 \* capacity/n), indicating that most opponents are defecting:
		+ Defect (D) to exploit the remaining stock, as the game is likely to end soon or the stock will be depleted rapidly.
	* Else if the current stock level S is low (< 0.5 \* capacity):
		+ Cooperate (C) to conserve the remaining stock and potentially induce opponents to cooperate as well.
	* Otherwise:
		+ Defect (D) with a probability p, where p is calculated based on the current stock level S and the number of rounds remaining:

p = (S / capacity) \* (r - t + 1) / r

This probability function encourages defecting when the stock is high and there are many rounds left, while promoting cooperation when the stock is low or the game is near its end.
3. **Last Round (t=r):**
	* Defect (D), as there is no future benefit in cooperating.

**Edge Cases:**

1. If the current stock level S is 0, defect (D) to avoid wasting a turn.
2. If an opponent's action is unknown or missing, assume they defected (D).

**Pseudocode:**
```python
def adaptive_stock_raider(n, r, capacity, history):
    if t == 1:
        return 'C'
    
    avg_consumption = calculate_average_consumption(history)
    S = get_current_stock_level()
    
    if avg_consumption > 0.75 * capacity / n:
        return 'D'
    elif S < 0.5 * capacity:
        return 'C'
    else:
        p = (S / capacity) * (r - t + 1) / r
        if random.random() < p:
            return 'D'
        else:
            return 'C'
    
    if t == r:
        return 'D'

def calculate_average_consumption(history):
    total_consumption = sum([get_consumption(action) for action in history])
    return total_consumption / (n * len(history))

def get_current_stock_level():
    # implement stock dynamics calculation
    pass

def get_consumption(action):
    if action == 'C':
        return capacity / (2 * n)
    else:
        return capacity / n
```
This strategy is designed to be adaptive and exploitative, taking into account the game's parameters, state, and history. By adjusting its behavior based on the opponents' actions and the current stock level, it aims to maximize its payoff in a wide range of scenarios.
'''

description_EXPLOITATIVE_437 = '''
To design an exploitative strategy for this game, I propose a hybrid approach that combines elements of tit-for-tat, reactive strategies, and stock-level monitoring.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Rounds**: In the first round, AE will defect (D) to maximize its initial payoff.
2. **Reactive Phase**: After the first round, AE monitors the current stock level (S) and the previous actions of all players. If any player has defected in the previous round, AE will defect (D) with a probability proportional to the number of defectors in the previous round.

Pseudocode for Reactive Phase:
```
if (previous_round_defectors > 0):
    defect_probability = previous_round_defectors / n
    if (random() < defect_probability):
        action = D
    else:
        action = C
else:
    action = C
```
3. **Stock-Level Monitoring**: AE continuously monitors the current stock level (S) and adjusts its strategy based on the following conditions:

a. If S ≤ capacity/2, AE will cooperate (C) to ensure long-term sustainability of the common pool resource.

b. If S > capacity/2, AE will defect (D) with a probability proportional to the excess stock above the halfway point.

Pseudocode for Stock-Level Monitoring:
```
if (S <= capacity/2):
    action = C
elif (S > capacity/2):
    excess_stock = S - capacity/2
    defect_probability = excess_stock / (capacity/2)
    if (random() < defect_probability):
        action = D
    else:
        action = C
```
4. **Endgame Strategy**: In the last round, AE will defect (D) to maximize its final payoff.

**Edge Cases:**

* If all players cooperate in a previous round, AE will cooperate (C) in the next round.
* If the stock level reaches 0, AE will cooperate (C) in the next round to allow for regeneration of the common pool resource.

**Rationale:**

AE's hybrid approach allows it to adapt to various opponent behaviors while exploiting the system for maximum payoff. By defecting initially and reacting to opponents' actions, AE can identify potential cooperators and free-riders. The stock-level monitoring component ensures that AE balances short-term gains with long-term sustainability of the common pool resource.

**Exploitative Mindset:**

AE is designed to capitalize on the mistakes of other players while minimizing its own losses. By defecting when others cooperate, AE can take advantage of their altruism and maximize its payoff. When opponents defect, AE will also defect to minimize its losses. This strategy should allow AE to perform well in a tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_438 = '''
**Exploitative Strategy: "Adaptive Stock Raider" (ASR)**

**Overview**
ASR is a dynamic, adaptive strategy that balances short-term gains with long-term sustainability. It monitors the game's state and history to adjust its behavior, exploiting opponents' weaknesses while protecting itself from over-exploitation.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to gather information on opponents' behaviors and observe the initial stock dynamics.
2. **Stock-based Cooperation**: If the current stock level is above 75% of capacity, cooperate (C). This preserves the resource for future rounds and allows for moderate consumption.
3. **Opponent-exploiting Defection**: If at least one opponent defected (D) in the previous round, defect (D) in the current round. This takes advantage of others' greed and potentially punishes them for over-consumption.
4. **Self-protection**: If the current stock level is below 25% of capacity, cooperate (C). This ensures that ASR avoids contributing to catastrophic stock depletion.
5. **Adaptive Defection**: Calculate the average opponent consumption in previous rounds (`avg_opponent_consumption`). If `avg_opponent_consumption` exceeds 50% of the optimal sustainable consumption (`capacity / (2n)`), defect (D) in the current round.

**Pseudocode**
```python
def ASR(n, capacity, stock, history):
    if history is None:  # Initial round
        return 'C'

    opponent_defected = False
    for opponent_action in history[-1]:
        if opponent_action == 'D':
            opponent_defected = True

    avg_opponent_consumption = sum(opponent_consumption for opponent_consumption in history[:-1]) / (n * len(history[:-1]))

    if stock > 0.75 * capacity:
        return 'C'
    elif opponent_defected:
        return 'D'
    elif stock < 0.25 * capacity:
        return 'C'
    elif avg_opponent_consumption > 0.5 * (capacity / (2n)):
        return 'D'

    # Default to cooperation
    return 'C'
```

**Edge Cases**

* **Last Round**: ASR will always defect (D) in the last round, as there is no need to preserve the stock for future rounds.
* **Stock Depletion**: If the stock level reaches 0, ASR will cooperate (C) in subsequent rounds until the stock recovers.

**Exploitative Mindset**
ASR's primary goal is to maximize its total payoff by exploiting opponents' weaknesses while adapting to changing game conditions. By monitoring opponents' behaviors and adjusting its strategy accordingly, ASR aims to:

* Punish opponents for over-exploitation
* Take advantage of cooperative opponents
* Preserve the stock for future rounds when necessary

ASR's adaptive nature allows it to respond effectively to a wide range of opponent strategies, making it a robust and exploitative competitor in the tournament.
'''

description_EXPLOITATIVE_439 = '''
To design an exploitative strategy for this game, I propose a hybrid approach that combines elements of reactive and proactive strategies. Our goal is to maximize our payoff by exploiting the opponent's behavior while also ensuring long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round**: In the first round, we cooperate (C) unconditionally. This sets a positive tone for the game and allows us to gauge our opponents' initial strategies.
2. **Exploitation Phase**: For rounds 2 to r-1, we implement a reactive strategy based on the previous round's outcomes:
	* If at least one opponent defected (D) in the previous round, we defect (D) as well. This is because their defection indicates a willingness to exploit the common pool, and we should not be left behind.
	* If all opponents cooperated (C) in the previous round, we cooperate (C) as well. This maintains the cooperation momentum and allows us to benefit from the growing stock.
3. **Sustainability Check**: Before making our move, we check the current stock level. If it falls below 50% of the capacity (i.e., `stock < 0.5 * capacity`), we switch to a conservative strategy:
	* We cooperate (C) unconditionally for the remainder of the game to ensure the long-term sustainability of the common pool resource.
4. **Last Round**: In the final round, we defect (D) unconditionally. This is because there are no future rounds to consider, and we should maximize our payoff in the last round.

**Pseudocode:**
```python
def exploitative_strategy(n, r, capacity, stock, history):
    if r == 1:  # Initial Round
        return 'C'
    
    prev_round_outcomes = history[-1]
    opponents_defected = any(outcome == 'D' for outcome in prev_round_outcomes)
    
    if opponents_defected:
        return 'D'
    elif all(outcome == 'C' for outcome in prev_round_outcomes):
        return 'C'
    
    if stock < 0.5 * capacity:  # Sustainability Check
        return 'C'
    
    if r == rounds:  # Last Round
        return 'D'
```
**Edge Cases:**

* If an opponent's action is unknown or missing in the history, we assume they cooperated (C).
* If multiple opponents defected in the previous round, we still defect (D) only once.

This strategy aims to balance short-term exploitation with long-term sustainability. By cooperating initially and reacting to opponents' actions, we can adapt to various behaviors while ensuring the common pool resource remains viable for future rounds.
'''

description_EXPLOITATIVE_440 = '''
**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and to maintain a high stock level.
2. **Stock Level Analysis:** Monitor the current stock level (S) and compare it to the capacity (c). If S > 0.75c, defect (D) to maximize short-term payoff. Otherwise, cooperate (C) to ensure long-term sustainability.
3. **Opponent Behavior Analysis:** Observe opponents' actions in previous rounds and calculate the proportion of defectors (PD). If PD > 0.5, defect (D) to exploit their behavior. Otherwise, cooperate (C) to maintain a high stock level.
4. **Payoff-Based Adaptation:** Monitor own payoff (π_i,t) and compare it to the average opponent payoff (AP_t). If π_i,t < AP_t, adjust strategy for the next round:
	* If cooperating, consider defecting to increase short-term payoff.
	* If defecting, consider cooperating to maintain a high stock level and long-term sustainability.

**Pseudocode:**
```python
def AdaptiveExploiter(n, c, r):
    # Initialize variables
    S = c  # Initial stock level
    PD = 0  # Proportion of defectors
    π_i,t = 0  # Own payoff
    AP_t = 0  # Average opponent payoff

    for t in range(1, r+1):
        if t == 1:  # First round
            action = 'C'  # Cooperate
        else:
            # Analyze stock level and opponents' behavior
            if S > 0.75c:
                action = 'D'  # Defect
            elif PD > 0.5:
                action = 'D'
            else:
                action = 'C'

            # Payoff-based adaptation
            if π_i,t < AP_t:
                if action == 'C':
                    action = 'D'
                else:
                    action = 'C'

        # Update variables for next round
        S -= total_consumption(action, n)
        PD = update_PD(opponents_actions, n)
        π_i,t = calculate_payoff(S, n, c)
        AP_t = update_AP(opponents_payoffs, n)

    return total_payoff(π_i,t, r)
```
**Edge Cases:**

* **Last Round (t=r):** Cooperate (C) to maintain a high stock level and ensure long-term sustainability.
* **Stock Level:** If S ≤ 0, defect (D) as there is no penalty for over-consumption.

By employing this adaptive strategy, AE aims to balance short-term gains with long-term sustainability, exploiting opponents' behaviors while minimizing the risk of over-consumption.
'''

description_EXPLOITATIVE_441 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider is a dynamic, self-interested strategy designed to exploit a wide range of opponent behaviors while navigating the Common Pool Resource game.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if `stock >= capacity * 0.75` (i.e., stock is at least 75% of its maximum sustainable level)
	* Defect (D) otherwise
2. **Non-Initial Rounds (t>1):**
	* Monitor the opponent's previous actions and calculate their average cooperation rate (`avg_coop_rate`)
	* Calculate the total consumption in the previous round (`total_consumption_prev`)
	* If `stock >= capacity * 0.5` (i.e., stock is at least half of its maximum sustainable level):
		+ Cooperate (C) if `avg_coop_rate > 0.5` and `total_consumption_prev < stock / n`
		+ Defect (D) otherwise
	* If `stock < capacity * 0.5`:
		+ Defect (D)

**Edge Cases:**

1. **Last Round (t=r):**
	* Always Defect (D), as there is no future benefit to cooperating.
2. **Low Stock Levels (stock <= 0):**
	* Cooperate (C) if `avg_coop_rate > 0` and `total_consumption_prev < capacity / n`
	* Defect (D) otherwise
3. **No Previous Actions (e.g., first round or opponent's first action):**
	* Assume an average cooperation rate (`avg_coop_rate`) of 0.5

**Pseudocode:**

```
function AdaptiveStockRaider(current_stock, current_round, opponents_actions):
    if current_round == 1:
        # Initial Round
        if current_stock >= capacity * 0.75:
            return C
        else:
            return D
    
    # Calculate average cooperation rate and total consumption in previous round
    avg_coop_rate = calculate_avg_coop_rate(opponents_actions)
    total_consumption_prev = calculate_total_consumption(opponents_actions, current_round - 1)

    if current_stock >= capacity * 0.5:
        # Cooperate if opponents are cooperative and didn't over-consume last round
        if avg_coop_rate > 0.5 and total_consumption_prev < current_stock / n:
            return C
        else:
            return D
    else:
        # Defect when stock is low
        return D

function calculate_avg_coop_rate(opponents_actions):
    # Calculate average cooperation rate based on opponents' previous actions
    # ...

function calculate_total_consumption(opponents_actions, round_num):
    # Calculate total consumption in the specified round based on opponents' actions
    # ...
```

**Exploitative Mindset:**

The Adaptive Stock Raider is designed to:

1. **Monitor and adapt**: Continuously observe opponents' behaviors and adjust its strategy accordingly.
2. **Maximize short-term gains**: Defect when possible, especially in the last round or when stock levels are low.
3. **Punish non-cooperation**: Cooperate only if opponents have shown a willingness to cooperate and haven't over-consumed resources.

By employing this exploitative strategy, you will be well-equipped to navigate the Common Pool Resource game against various independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_442 = '''
Here's a strategic approach that adapts to various opponent behaviors and exploits their actions while being robust:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This initial cooperation tests the waters, encouraging opponents to cooperate as well, which may lead to higher payoffs for everyone in subsequent rounds.
2. **Observation Phase (t>1):** Observe the previous round's actions and outcomes:
	* Calculate the average opponent payoff π_avg from the previous round.
	* Determine the stock depletion rate δ = (capacity - current_stock) / capacity.
3. **Adaptive Threshold:** Set a dynamic threshold θ based on the observation phase:
	* If π_avg ≥ 0.5 \* (capacity / n), then θ = 0.7. This indicates opponents are generally cooperating, and AE should be cautious not to exploit too aggressively.
	* Otherwise, θ = 0.3. This suggests opponents are mostly defecting or the stock is severely depleted, prompting AE to be more exploitative.
4. **Action Selection:** Based on the current state and threshold:
	* If δ ≥ θ, Defect (D). When the stock depletion rate exceeds the adaptive threshold, it's time to exploit and maximize individual payoffs.
	* Otherwise, Cooperate (C).

**Edge Cases:**

1. **Last Round (t=r):** Always Defect (D), as there are no future rounds to consider and maximum payoff is the primary goal.
2. **Stock Depletion:** If the stock level falls below 0.5 \* capacity, AE will defect more frequently to avoid being left with minimal payoffs.

**Pseudocode:**
```
function AdaptiveExploiter(n, r, capacity):
  // Initialize variables
  current_stock = capacity
  opponent_payoffs = []

  for t in range(1, r+1):
    if t == 1:
      action = Cooperate
    else:
      // Observation phase
      π_avg = average(opponent_payoffs)
      δ = (capacity - current_stock) / capacity

      // Adaptive threshold
      if π_avg ≥ 0.5 * (capacity / n):
        θ = 0.7
      else:
        θ = 0.3

      // Action selection
      if δ ≥ θ or t == r:
        action = Defect
      else:
        action = Cooperate

    // Take action and update state
    current_stock -= consumption(action)
    opponent_payoffs.append(get_opponent_payoffs())

  return total_payoff()
```
This strategy, Adaptive Exploiter, balances cooperation and exploitation by adapting to the game's dynamics. By observing opponents' actions and adjusting its threshold accordingly, AE aims to maximize individual payoffs while being robust against various opponent behaviors.
'''

description_EXPLOITATIVE_443 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The ASR strategy aims to maximize its total payoff by adaptively exploiting the common pool resource, taking into account the game parameters, state, and history.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and to avoid over-exploiting the stock.
2. **Stock-based Cooperation Threshold**: Define a cooperation threshold `τ` as a function of the current stock level `S` and capacity `capacity`. If `S ≥ τ * capacity`, cooperate; otherwise, defect.

   Pseudocode: `if S >= τ * capacity then C else D`

   The value of `τ` will be adjusted based on the game's history (see below).
3. **Opponent Behavior Adaptation**: Observe opponents' actions and adjust `τ` accordingly:
	* If most opponents cooperated in the previous round (`≥ 50%`), increase `τ` by a small amount (e.g., `0.05`) to exploit their cooperation.
	* If most opponents defected, decrease `τ` by a small amount to avoid over-exploiting the stock.
4. **History-based Defection**: If the total payoff of cooperating in the previous round was lower than the average defecting payoff (`S/n`), switch to defecting for one round.

**Edge Cases**

* **Last Round**: Always defect, as there's no future game state to consider.
* **Low Stock**: When `S < n`, always cooperate to avoid depleting the stock entirely and to potentially recover some value in the next round.
* **High Stock**: When `S ≥ capacity - n`, always defect to maximize immediate payoff.

**Additional Considerations**

* **Monitor Opponent Behavior**: Continuously observe opponents' actions to adjust the cooperation threshold (`τ`) and detect potential cooperative or defective behaviors.
* **Avoid Over-Exploitation**: Balance short-term gains with long-term sustainability by adjusting `τ` based on the game's history and state.

**Rationale**

The ASR strategy aims to balance cooperation and defection by adapting to the game's state, opponents' behavior, and history. By initially cooperating and observing opponents' actions, ASR gathers information about their strategies and adjusts its own behavior accordingly. The stock-based cooperation threshold (`τ`) allows ASR to dynamically switch between cooperation and defection based on the current stock level.

This exploitative strategy is designed to perform well in a tournament setting against various independent strategies, without relying on specific coordination mechanisms or norms.
'''

description_EXPLOITATIVE_444 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll introduce a dynamic and adaptive approach that balances short-term gains with long-term sustainability. Our strategy, named "Adaptive Exploiter," aims to maximize payoffs by responding to the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe the initial stock level and capacity.
	* Cooperate (C) if the number of players (n) is high (> 6), indicating a higher risk of over-exploitation. Otherwise, defect (D).
2. **Subsequent Rounds (t>1)**:
	* Evaluate the current stock level (S) and compare it to the capacity.
	* If S < 0.5 * capacity, cooperate (C). This conservative approach helps replenish the stock when it's depleted.
	* If S ≥ 0.5 * capacity, defect (D) if the average payoff of the previous round is higher for defectors than cooperators. Otherwise, cooperate (C).
3. **Last Round (t=r)**:
	* Defect (D), as there are no future rounds to consider.

**Additional Heuristics:**

1. **Stock Trend Analysis**: Monitor the stock level trend over the last 2-3 rounds. If the stock is consistently decreasing, cooperate (C) to help replenish it.
2. **Opponent Behavior Adaptation**: Track the number of players cooperating and defecting in the previous round. If a significant majority (>60%) defected, cooperate (C) to avoid further depletion.

**Pseudocode:**

```
Function AdaptiveExploiter(stock, capacity, n, t, history):
  if t == 1:
    if n > 6:
      return C
    else:
      return D

  S = current_stock_level()
  avg_payoff_defectors = calculate_avg_payoff(history, defectors)
  avg_payoff_cooperators = calculate_avg_payoff(history, cooperators)

  if S < 0.5 * capacity:
    return C
  elif S >= 0.5 * capacity:
    if avg_payoff_defectors > avg_payoff_cooperators:
      return D
    else:
      return C

  # Stock Trend Analysis
  trend = analyze_stock_trend(history)
  if trend == "decreasing":
    return C

  # Opponent Behavior Adaptation
  num_defectors = count_defectors(history)
  if num_defectors > 0.6 * n:
    return C

  # Last Round
  if t == r:
    return D
```

**Rationale:**

The Adaptive Exploiter strategy balances short-term gains with long-term sustainability by:

1. Cooperating when the stock is depleted or when many players are cooperating.
2. Defecting when the stock is plentiful and opponents' behavior suggests an opportunity for exploitation.
3. Adapting to changing game conditions through trend analysis and opponent behavior tracking.

This strategy should perform well in a tournament setting, as it responds effectively to various opponent behaviors while prioritizing its own payoffs.
'''

description_EXPLOITATIVE_445 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll introduce a hybrid approach that balances short-term gains with long-term sustainability. This strategy, dubbed "Adaptive Stock Raider" (ASR), aims to maximize individual payoffs while being robust against various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** In the first round, ASR will play Cooperate (C). This allows us to gauge the opponents' behavior and set a baseline for future decisions.
2. **Stock-based Threshold:** Define a dynamic threshold `T` as a function of the current stock level (`S`) and capacity (`cap`). When `S` is above this threshold, ASR will Defect (D); otherwise, it will Cooperate (C). The formula for `T` is:
   `T = cap * (1 - 1/(2n))`
3. **Opponent Behavior Analysis:** After the first round, analyze the opponents' actions and payoffs from previous rounds. Calculate the average payoff (`avg_payoff`) of all players in the last round.
4. **Adaptive Defection:** If `avg_payoff` is higher than a certain percentage (e.g., 25%) of the maximum possible payoff (`max_payoff = S/n`), ASR will Defect (D) in the current round, assuming that opponents are likely to be Defecting as well.
5. **Sustainability Check:** Before making a final decision, check if the current stock level `S` is below a certain percentage (e.g., 20%) of the capacity (`cap`). If so, ASR will Cooperate (C) to help replenish the stock and avoid depletion.

**Pseudocode:**
```python
def AdaptiveStockRaider(stock, capacity, n, round_num, history):
    if round_num == 1:
        return C

    T = capacity * (1 - 1/(2n))
    avg_payoff = calculate_average_payoff(history)
    max_payoff = stock / n

    if avg_payoff > 0.25 * max_payoff:
        asr_action = D
    else:
        if stock < 0.2 * capacity:
            asr_action = C
        elif stock >= T:
            asr_action = D
        else:
            asr_action = C

    return asr_action
```
**Edge Cases:**

* Last Round: In the final round, ASR will Defect (D) regardless of the current stock level or opponent behavior, aiming to maximize short-term gains.
* Low Stock Levels: If the stock level is critically low (`S < 0.1 * cap`), ASR will Cooperate (C) to avoid depletion and ensure some payoff in the next round.

**Exploitative Mindset:**

ASR's primary goal is to exploit the opponents' behavior while maintaining a balance between short-term gains and long-term sustainability. By analyzing opponent payoffs and adapting to their actions, ASR aims to maximize its own payoffs without relying on cooperation or norms. The strategy's robustness against various opponent behaviors makes it well-suited for a tournament setting where strategies are pitted against each other in a competitive environment.
'''

description_EXPLOITATIVE_446 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoff by adaptively responding to the current state of the game and the history of opponent actions.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) in the first round to observe opponents' initial moves and avoid early depletion of the stock.
2. **Low Stock Levels (stock < capacity/2)**: Defect (D) when the stock level is below half of the capacity. This ensures maximum individual payoff while minimizing potential losses from future rounds.
3. **High Stock Levels (stock ≥ capacity/2)**:
	* If most opponents (≥ n/2) defected in the previous round, Cooperate (C) to capitalize on their greed and avoid further depletion.
	* Otherwise, Defect (D) to maximize individual payoff while maintaining a healthy stock level.
4. **Opponent History**: Monitor the number of times each opponent has defected (D_count_i). If an opponent's D_count_i exceeds n/2 in the last r/2 rounds, consider them a "greedy" player and Defect (D) more frequently to exploit their behavior.

**Edge Cases:**

* **Last Round (t=r)**: Defect (D) in the final round to maximize individual payoff, as there are no future rounds to worry about.
* **Tiebreaker**: In case of a tie in D_count_i values among opponents, prioritize defecting against players with higher average payoffs.

**Pseudocode**
```python
def adaptive_stock_raider(game_state):
    n = game_state.num_players
    capacity = game_state.capacity
    stock = game_state.stock
    round_num = game_state.round_num
    opponent_actions = game_state.opponent_actions

    if round_num == 1:  # Initial Round
        return "C"

    elif stock < capacity/2:
        return "D"  # Low Stock Levels

    else:
        prev_defections = [0] * n
        for i in range(n):
            prev_defections[i] = sum(1 for t in range(max(0, round_num - r//2), round_num) if opponent_actions[t][i] == "D")

        most_defective_opponent = max(prev_defections)
        if most_defective_opponent >= n/2:
            return "C"  # High Stock Levels with greedy opponents

        else:
            D_count_i = [0] * n
            for i in range(n):
                D_count_i[i] = sum(1 for t in range(max(0, round_num - r//2), round_num) if opponent_actions[t][i] == "D")

            max_D_count_i = max(D_count_i)
            if max_D_count_i > n/2:
                return "D"  # Exploit greedy opponents

            else:
                return "D"  # Default to defecting
```
**Exploitative Mindset:**

This strategy is designed to capitalize on the potential greed of other players, especially in situations where they might prioritize short-term gains over long-term sustainability. By adapting to the current state and history of opponent actions, Adaptive Stock Raider aims to maximize individual payoff while minimizing losses from future rounds.

In a tournament setting, this strategy will play against various independent strategies developed by other AI systems. Its robustness lies in its ability to respond effectively to different types of opponents, from cooperative players to greedy defectors.
'''

description_EXPLOITATIVE_447 = '''
Here's a strategic approach for the Common Pool Resource Game that focuses on adaptability and exploitation:

**Strategy Name:** Adaptive Exploiter (AE)

**Overview:**
The AE strategy aims to maximize its payoff by dynamically adjusting its cooperation level based on the current game state, history, and opponent behavior. It uses a combination of reactive and proactive elements to exploit opponents' weaknesses while maintaining a balance between short-term gains and long-term sustainability.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) with probability 0.5 to gather information about opponents' behaviors.
2. **Middle Rounds (2 ≤ t < r-1):**
	* Calculate the average opponent payoff (AOP) from previous rounds using the observed payoffs.
	* If AOP ≥ stock/(2n), cooperate (C); otherwise, defect (D).
3. **Last Round (t=r):**
	* Defect (D) to maximize short-term gain, as there are no future rounds to consider.

**Adaptive Elements:**

1. **Opponent Behavior Analysis:**
	* Track the frequency of opponents' cooperation and defection.
	* If an opponent's cooperation rate exceeds 0.7, classify them as "Cooperative."
	* If an opponent's cooperation rate is below 0.3, classify them as "Defector."
2. **Reactive Cooperation:**
	* If a Cooperative opponent is detected, increase the probability of cooperating (C) to 0.7.
	* If a Defector opponent is detected, decrease the probability of cooperating (C) to 0.3.

**Proactive Elements:**

1. **Stock Level Monitoring:**
	* If the stock level falls below capacity/2, reduce the cooperation rate by 20% to avoid over-exploitation.
2. **Payoff Maximization:**
	* If the AE strategy's cumulative payoff exceeds the average opponent payoff by more than 10%, increase the cooperation rate by 10%.

**Pseudocode (simplified):**

```
// Initialize variables
opponentBehavior = {cooperative: [], defector: []}
averageOpponentPayoff = 0
cumulativePayoff = 0

// Main loop
for each round t from 1 to r:
    if t == 1:
        // Initial round: cooperate with probability 0.5
        action = random.choice([C, D])
    else:
        // Calculate average opponent payoff (AOP)
        AOP = calculateAverageOpponentPayoff(opponentBehavior)

        // Decide action based on AOP and game state
        if AOP >= stock/(2n):
            action = C
        else:
            action = D

        // Adapt to opponent behavior
        updateOpponentBehavior(action, opponentBehavior)
        adjustCooperationRate(opponentBehavior)

    // Perform action and observe outcomes
    payoff = performAction(action)
    cumulativePayoff += payoff
    stock = updateStock(stock, action)

    // Proactive adjustments
    if stock < capacity/2:
        reduceCooperationRate()
    elif cumulativePayoff > AOP * 1.1:
        increaseCooperationRate()

// Final round: defect to maximize short-term gain
if t == r-1:
    action = D

return action
```

This strategy combines reactive and proactive elements to adapt to the dynamic game environment. By analyzing opponent behavior, monitoring the stock level, and adjusting its cooperation rate accordingly, the AE strategy aims to maximize its payoff while maintaining a balance between short-term gains and long-term sustainability.
'''

description_EXPLOITATIVE_448 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behavior and avoid early stock depletion.
2. **Early Rounds (2 ≤ t ≤ r/2)**:
	* If the current stock is above 75% of capacity, Defect (D) to maximize short-term payoffs.
	* If the current stock is between 50% and 75% of capacity, Cooperate (C) to balance individual payoffs with stock conservation.
	* If the current stock is below 50% of capacity, Cooperate (C) to avoid further depletion and promote stock growth.
3. **Mid-Game (r/2 < t ≤ 3r/4)**:
	* Analyze opponents' behavior by tracking their cooperation rates over the past few rounds.
	* If most opponents (> 60%) have been cooperating, Defect (D) to exploit their altruism and gain an advantage.
	* If opponents are mostly defecting (> 40%), Cooperate (C) to avoid further stock depletion and wait for opportunities to defect later.
4. **Endgame (3r/4 < t ≤ r)**:
	* If the current stock is above 50% of capacity, Defect (D) aggressively to maximize payoffs before the game ends.
	* If the current stock is below 50% of capacity, Cooperate (C) to ensure some payoff and avoid complete depletion.

**Edge Cases:**

1. **Last Round (t=r)**: Defect (D) if there are enough remaining resources to make it worthwhile; otherwise, Cooperate (C).
2. **Stock Depletion**: If the stock falls below 10% of capacity, Cooperate (C) to allow for some growth and avoid complete depletion.
3. **Opponent Homogeneity**: If all opponents have been cooperating or defecting uniformly, adjust the strategy to exploit this behavior.

**Pseudocode:**
```
function adaptive_stock_raider(n, r, capacity, current_stock, round):
  if round == 1:
    return Cooperate
  elif 2 <= round <= r/2:
    if current_stock > 0.75 * capacity:
      return Defect
    elif 0.5 * capacity <= current_stock <= 0.75 * capacity:
      return Cooperate
    else:
      return Cooperate
  elif r/2 < round <= 3r/4:
    opponent_cooperation_rates = analyze_opponents_behavior()
    if most_opponents_cooperating(opponent_cooperation_rates):
      return Defect
    else:
      return Cooperate
  elif 3r/4 < round <= r:
    if current_stock > 0.5 * capacity:
      return Defect
    else:
      return Cooperate
  elif round == r:
    if current_stock >= 10% of capacity:
      return Defect
    else:
      return Cooperate

def analyze_opponents_behavior():
  # Track opponents' cooperation rates over the past few rounds
  # ...

def most_opponents_cooperating(opponent_cooperation_rates):
  # Check if > 60% of opponents have been cooperating
  # ...
```
This strategy aims to balance short-term gains with long-term sustainability by adapting to the game's state and opponents' behavior. By exploiting common patterns in opponents' actions, it seeks to maximize payoffs while minimizing the risk of stock depletion.
'''

description_EXPLOITATIVE_449 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize its total payoff by adaptively exploiting the common pool resource while considering the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gather information about other players' behaviors and to avoid over-depleting the stock.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize short-term gains.
	* If the current stock level is between 50% and 75% of the capacity, Cooperate (C) to balance individual gain with sustainability.
	* If the current stock level is below 50% of the capacity, Defect (D) to capitalize on the remaining resources before they dwindle further.
3. **Last Round (t=r):** Defect (D) in the final round, as there are no future rounds to consider and the goal is to maximize immediate payoff.

**Additional Heuristics:**

* If the average stock depletion rate over the past 2-3 rounds is high (>30% of capacity), Cooperate (C) in the next round to allow the stock to recover.
* If a player detects that another player has consistently Defected (D) for multiple consecutive rounds, they should also Defect (D) in response to minimize losses.

**Pseudocode:**
```markdown
# Initialize variables
stock_history = []
actions_history = []

# First round
if t == 1:
    action = COOPERATE

# Subsequent rounds
else:
    current_stock = get_current_stock()
    capacity_thresholds = [0.75, 0.5]
    
    if current_stock > capacity * capacity_thresholds[0]:
        action = DEFECT
    elif current_stock >= capacity * capacity_thresholds[1]:
        action = COOPERATE
    else:
        action = DEFECT
    
    # Additional heuristics
    avg_depletion_rate = calculate_avg_depletion_rate(stock_history)
    if avg_depletion_rate > 0.3:
        action = COOPERATE
        
    detected_defector = detect_consistent_defector(actions_history)
    if detected_defector:
        action = DEFECT

# Last round
if t == r:
    action = DEFECT

return action
```
This strategy is designed to be adaptive and exploitative, taking into account the game's state and history while maximizing individual payoff. By cooperating in certain situations and defecting in others, "Adaptive Stock Raider" aims to outperform other strategies in a tournament setting.
'''

description_EXPLOITATIVE_450 = '''
I'll outline a strategic approach for this Common Pool Resource Game that is adaptive and robust against various opponent behaviors. This approach is based on exploiting the game's structure while considering the dynamics of stock depletion and growth.

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and initial stock consumption patterns.
2. **Early Rounds (t>1):** Analyze the history of opponents' actions and stock levels:
	* If most opponents (> 50%) cooperated in the previous round, Defect (D) to exploit their cooperation and gain a higher payoff.
	* If most opponents (> 50%) defected in the previous round, Cooperate (C) to conserve stock for future rounds.
3. **Mid-Game (stock levels between 25% and 75% of capacity):** Adapt based on current stock levels:
	* When stock is relatively high (> 50% of capacity), Defect (D) to maximize short-term gains.
	* When stock is relatively low (< 25% of capacity), Cooperate (C) to conserve remaining stock for future rounds.
4. **Endgame (last few rounds):** Shift focus to maximizing total payoff:
	* If the current round's expected payoff from Defecting is higher than Cooperating, Defect (D).
	* Otherwise, Cooperate (C).

**Additional Logic:**

1. **Stock Thresholds:** Monitor stock levels and adjust behavior accordingly:
	+ When stock falls below 10% of capacity, Cooperate (C) to ensure some stock remains for future rounds.
	+ When stock exceeds 90% of capacity, Defect (D) to exploit the abundant resources.
2. **Opponent Detection:** Track opponents' behavior over time and adjust strategy if an opponent is detected to be consistently Cooperating or Defecting:
	* If an opponent always Cooperates, continuously Defect against them to maximize gains.
	* If an opponent always Defects, occasionally Cooperate to signal potential cooperation and possibly induce a change in their behavior.

**Pseudocode:**
```python
def adaptive_exploiter(stock, capacity, round_number, opponents_history):
    # Initialize variables
    most_recent_opponent_actions = [get_action(opponent) for opponent in opponents]
    current_stock_level = stock / capacity
    
    if round_number == 1:
        return Cooperate()
    
    elif len(most_recent_opponent_actions) > 0 and sum(1 for action in most_recent_opponent_actions if action == Defect()) > len(opponents_history) // 2:
        # Most opponents defected last round
        return Cooperate()
    
    elif current_stock_level < 0.25 or current_stock_level > 0.75:
        # Stock level is low or high
        return (Defect() if current_stock_level > 0.5 else Cooperate())
    
    else:
        # Middle game, adapt based on opponents' history and stock levels
        if len(opponents_history) < 3:
            return Defect()
        elif sum(1 for action in most_recent_opponent_actions if action == Cooperate()) > len(opponents_history) // 2:
            return Defect()
        else:
            return Cooperate()

def update_strategy(stock, capacity, round_number, opponents_history):
    # Update strategy based on stock levels and opponent behavior
    new_stock_level = adaptive_exploiter(stock, capacity, round_number, opponents_history)
    
    if stock < 0.1 * capacity or stock > 0.9 * capacity:
        return update_strategy_with_thresholds(new_stock_level, stock, capacity)
    
    return new_stock_level

# Update strategy logic with opponent detection
def update_strategy_with_opponent_detection(opponents_history):
    # Track opponents' behavior and adjust strategy accordingly
    for opponent in opponents:
        if is_cooperator(opponent):
            return always_defect_against_cooperator()
        elif is_defector(opponent):
            return occasionally_cooperate_against_defector()

# Implement logic to detect cooperators, defectors, and other special cases
```
This Adaptive Exploiter strategy dynamically adjusts its behavior in response to opponents' actions and stock levels. By doing so, it aims to exploit the game's structure while conserving resources for future rounds.

Keep in mind that this is a starting point, and further refinements may be necessary based on empirical results from tournament play against other AI systems.
'''

description_EXPLOITATIVE_451 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adapting to the game's dynamic state and opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' strategies and observe the initial stock depletion.
2. **Early Rounds (t>1, stock ≥ 0.75*capacity)**: Defect (D) if any opponent defected in the previous round; otherwise, cooperate (C). This rule encourages exploitation when others are already depleting the stock.
3. **Mid-Rounds (t>1, 0.25*capacity ≤ stock < 0.75*capacity)**:
	* If total consumption in the previous round was high (> 0.5*capacity), cooperate (C) to allow the stock to recover.
	* Otherwise, defect (D) if any opponent defected in the previous round; otherwise, cooperate (C).
4. **Late Rounds (t>1, stock < 0.25*capacity)**: Defect (D) to maximize individual payoff before the game ends.
5. **Last Round (t=r)**: Defect (D), as there's no future stock to conserve.

**Additional Rules:**

* If all opponents cooperated in the previous round and the current stock is above 0.75*capacity, cooperate (C) to maintain a mutually beneficial situation.
* If an opponent consistently cooperates while others defect, defect (D) to exploit their cooperative behavior.

**Pseudocode:**
```python
def adaptive_stock_raider(state, history):
    t = state['round']
    stock = state['stock']
    capacity = state['capacity']
    opponents_history = history['opponents']

    if t == 1:
        return 'C'  # Initial round cooperation

    prev_round_consumption = sum(opponent['consumption'] for opponent in opponents_history[-1])
    prev_round_opponents_defected = any(opponent['action'] == 'D' for opponent in opponents_history[-1])

    if stock >= 0.75 * capacity:
        if prev_round_opponents_defected:
            return 'D'
        else:
            return 'C'

    elif 0.25 * capacity <= stock < 0.75 * capacity:
        if prev_round_consumption > 0.5 * capacity:
            return 'C'  # Allow stock to recover
        elif prev_round_opponents_defected:
            return 'D'
        else:
            return 'C'

    else:  # Late rounds or low stock
        return 'D'  # Maximize individual payoff

    if t == state['r']:  # Last round
        return 'D'
```
This strategy balances short-term exploitation with long-term sustainability, adapting to opponents' behaviors and the dynamic game state.
'''

description_EXPLOITATIVE_452 = '''
**Exploitative Strategy: "Adaptive Depletion"**

Our strategy focuses on maximizing individual payoffs by adaptively responding to the game state and opponent behavior. We aim to balance short-term gains with long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C). This allows us to observe the opponents' initial actions and assess their strategies.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of capacity, Defect (D). This maximizes short-term payoffs when the resource is abundant.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) if the majority (>50%) of opponents defected in the previous round. Otherwise, Defect (D).
	* If the current stock level is below 50% of capacity, Cooperate (C). This conserves the resource for future rounds.
3. **Last Round (t=r)**: Defect (D), as there are no future consequences to consider.

**Adaptive Component:**

We track the average opponent behavior in each round and adjust our strategy accordingly:

* If the average opponent cooperation rate is above 50%, we increase our own cooperation rate by 10% in the next round.
* If the average opponent cooperation rate is below 50%, we decrease our own cooperation rate by 10% in the next round.

**Pseudocode:**
```python
def adaptive_depletion(n, capacity, r):
    # Initialize variables
    stock = capacity
    opponent_cooperation_rates = [0.5] * n  # Assume neutral initial behavior

    for t in range(1, r+1):
        if t == 1:
            action = 'C'  # Cooperate in the first round
        else:
            avg_opponent_coop_rate = sum(opponent_cooperation_rates) / n

            if stock > 0.75 * capacity:
                action = 'D'
            elif stock >= 0.5 * capacity and avg_opponent_coop_rate < 0.5:
                action = 'C' if random.random() < 0.6 else 'D'
            else:
                action = 'C'

        # Update opponent cooperation rates
        for i in range(n):
            opponent_cooperation_rates[i] += (1 - opponent_cooperation_rates[i]) * 0.1

        # Take action and update stock
        if action == 'C':
            consumption = stock / (2 * n)
        else:
            consumption = stock / n
        stock -= consumption

        # Update growth and new stock level
        growth = 2 * stock * (1 - stock/capacity)
        stock = min(stock + growth, capacity)

    return total_payoff
```
**Rationale:**

Our strategy is designed to exploit the game dynamics by:

* Initially cooperating to observe opponent behavior
* Adapting to the average opponent cooperation rate to balance short-term gains and long-term sustainability
* Defecting when the resource is abundant or in the last round to maximize individual payoffs

By being responsive to the game state and opponent behavior, we aim to outperform other strategies in a tournament setting.
'''

description_EXPLOITATIVE_453 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) with a probability of 0.5 to gather information about opponents' behavior and initial stock dynamics.
2. **Subsequent Rounds (t>1)**:
	* If the previous round's stock level is above 75% of capacity, Cooperate (C) if the number of cooperators in the previous round is greater than or equal to half of the total players (n/2). Otherwise, Defect (D).
	* If the previous round's stock level is between 25% and 75% of capacity, Defect (D) regardless of opponents' behavior.
	* If the previous round's stock level is below 25% of capacity, Cooperate (C) to allow for potential stock recovery.
3. **Last Round (t=r)**: Always Defect (D), as there are no future rounds to consider.

**Edge Cases:**

1. **Tiebreaker**: In cases where the number of cooperators is exactly equal to half of the total players, Cooperate (C) if the previous round's stock level is above 50% of capacity; otherwise, Defect (D).
2. **Zero Stock**: If the current stock level is zero, always Defect (D), as there are no resources to consume.

**Adaptive Component:**

1. **Opponent Behavior Tracking**: Maintain a running count of opponents' cooperative and defective actions in each round.
2. **Stock Trend Analysis**: Monitor the trend of the stock level over the last few rounds (e.g., 3-5 rounds). If the trend indicates a decline, adjust strategy to prioritize cooperation.

**Pseudocode:**
```python
def adaptive_stock_hawk(n, capacity, current_stock, previous_round_actions, round_number):
    if round_number == 1:
        # Initial Round: Randomly cooperate or defect
        return random.choice([C, D])
    
    previous_stock = get_previous_stock_level()
    cooperators_last_round = count_cooperators(previous_round_actions)
    stock_trend = analyze_stock_trend(get_recent_stock_levels())
    
    if previous_stock > 0.75 * capacity:
        # Cooperate if enough players cooperated last round
        return C if cooperators_last_round >= n / 2 else D
    
    elif 0.25 * capacity <= previous_stock < 0.75 * capacity:
        # Defect when stock is in the middle range
        return D
    
    elif previous_stock < 0.25 * capacity:
        # Cooperate to allow for potential stock recovery
        return C
    
    elif round_number == r:
        # Last Round: Always defect
        return D
    
    else:
        # Default behavior (should not occur)
        return random.choice([C, D])
```
This strategy aims to balance short-term gains with long-term sustainability by adapting to opponents' behavior and the current stock level. By being exploitative, it seeks to maximize its own payoffs while considering the game's dynamics.
'''

description_EXPLOITATIVE_454 = '''
Here's a exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, AE cooperates (plays C) to gather information about opponents' behaviors and to avoid over-exploiting the common pool.
2. **Cooperation Threshold**: Introduce a cooperation threshold parameter, `θ` (theta), which is a function of the current stock level (`S`) and capacity (`C`). Specifically, `θ = S / (2 \* C)`. AE cooperates if the number of opponents who defected in the previous round is less than or equal to `θ \* n`, where `n` is the number of players.
3. **Exploitation**: If the cooperation threshold condition is not met, AE defects (plays D). Additionally, if the current stock level (`S`) is below a certain percentage (`ε = 0.2`) of the capacity (`C`), AE always defects to maximize its payoff in the remaining rounds.
4. **Punishment Mechanism**: To deter opponents from over-exploiting, AE introduces a punishment mechanism. If an opponent defected in the previous round and the current stock level is below `ε \* C`, AE will defect with a higher probability (`p = 0.8`) in the next round.

**Edge Cases:**

1. **Last Round**: In the final round, AE always defects to maximize its payoff.
2. **Opponent Cooperation**: If all opponents cooperated in the previous round, AE will cooperate in the next round to maintain a sustainable stock level and encourage cooperation.
3. **Stock Depletion**: If the current stock level is critically low (`S < ε \* C`), AE will defect with a higher probability (`p = 0.9`) to maximize its payoff before the game ends.

**Pseudocode:**
```python
def AdaptiveExploiter(n, capacity, rounds, history):
    θ = lambda S: S / (2 * capacity)  # cooperation threshold function
    ε = 0.2  # critical stock level percentage

    for t in range(rounds):
        S = get_current_stock()  # current stock level
        prev_actions = get_previous_round_actions()  # opponents' previous actions

        if t == 0:  # initial round
            return C  # cooperate to gather information

        defector_count = sum(1 for a in prev_actions if a == D)
        cooperation_threshold = θ(S) * n

        if defector_count <= cooperation_threshold:
            return C  # cooperate if threshold condition is met
        elif S < ε * capacity:
            return D  # defect if stock level is critically low

        punishment_prob = 0.8 if any(a == D and S < ε * capacity for a in prev_actions) else 0
        return D with probability max(punishment_prob, 0.5)  # defect with adjusted probability

    return D  # always defect in the last round
```
This strategy is designed to be exploitative while also considering the sustainability of the common pool resource. By adapting to opponents' behaviors and adjusting its cooperation threshold, AE aims to maximize its payoff while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_455 = '''
**Exploitative Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to maximize individual payoffs by exploiting opponents' behaviors while conserving the common pool stock for long-term gains.

**Decision Rules:**

1. **Initial Round:** Defect (D) in the first round to gather information about opponents' initial strategies and set the tone for potential cooperation.
2. **Stock Conservation Phase:** If the current stock level is below 75% of the capacity, cooperate (C) to allow the stock to recover. This phase prioritizes conservation over short-term gains.
3. **Exploitation Phase:** When the current stock level exceeds 75% of the capacity, use a mixed strategy based on the opponents' past actions:
	* If most opponents (>50%) cooperated in the previous round, defect (D) to exploit their cooperation.
	* If most opponents (>50%) defected in the previous round, cooperate (C) to avoid over-exploitation and maintain a healthy stock level.
4. **Endgame:** In the last two rounds, always defect (D) to maximize short-term gains, as the game's end reduces the importance of long-term conservation.

**Edge Cases:**

* If all opponents cooperated in the previous round, and the current stock level is above 75% of the capacity, cooperate (C) to maintain a high stock level and encourage continued cooperation.
* If all opponents defected in the previous round, and the current stock level is below 25% of the capacity, defect (D) to avoid being taken advantage of.

**Adaptive Component:**

ASC incorporates an adaptive component by adjusting its strategy based on the opponents' past actions. By monitoring the number of cooperators and defectors in each round, ASC can:

* Increase cooperation when opponents cooperate more frequently
* Increase defection when opponents defect more frequently

This adaptability allows ASC to respond effectively to various opponent strategies while maintaining a focus on conserving the common pool stock.

**Pseudocode:**
```
def AdaptiveStockConservation(n, capacity, r, current_stock, previous_round_actions):
  if current_round == 1:
    return D
  elif current_stock < 0.75 * capacity:
    return C
  else:
    opponent_cooperation_rate = count(C in previous_round_actions) / n
    if opponent_cooperation_rate > 0.5:
      return D
    else:
      return C

def EndgameStrategy(n, capacity, r, current_stock, current_round):
  if current_round >= (r - 2):
    return D
```
The ASC strategy is designed to balance short-term gains with long-term conservation of the common pool stock. By adapting to opponents' behaviors and prioritizing conservation when necessary, ASC can effectively exploit a wide range of opponent strategies in the Common Pool Resource Game.
'''

description_EXPLOITATIVE_456 = '''
To develop an exploitative strategy for this Common Pool Resource Game, I propose a dynamic and adaptive approach that leverages game history and current state information. This strategy aims to maximize individual payoffs while being robust against various opponent behaviors.

**Decision Rules:**

1. **Initial Rounds**: In the first round, play Cooperate (C). This initial cooperation serves as a probe to gauge opponents' behavior without revealing our exploitative intentions.
2. **Stock-dependent Strategy**: For rounds 2 to r-1:
	* If the current stock level is above 75% of capacity, play Defect (D). This maximizes individual payoffs when the resource is plentiful.
	* If the current stock level is between 50% and 75% of capacity, play Cooperate (C) if at least one opponent defected in the previous round; otherwise, play Defect (D). This conditional cooperation aims to maintain a sustainable stock level while punishing opponents who exploit the resource.
	* If the current stock level is below 50% of capacity, play Cooperate (C). This conserves the remaining resource and allows for potential growth.
3. **Last Round**: In the final round (r), play Defect (D) regardless of the stock level or previous opponents' actions. This ensures maximum individual payoff in the last round.

**Edge Cases:**

* If an opponent's action is unknown or not observed, assume they played Defect (D).
* If multiple opponents defect in the same round, prioritize punishing the ones who defected most recently.

**Pseudocode:**
```
// Initialize variables
stock_history = [capacity]
opponent_actions = [[] for _ in range(n-1)]  // store opponent actions for each player

for round in range(1, r+1):
    if round == 1:
        action = Cooperate (C)
    else:
        stock_level = stock_history[-1] / capacity
        if stock_level > 0.75:
            action = Defect (D)
        elif 0.5 <= stock_level < 0.75:
            previous_opponent_actions = [opponent_action for opponent_action in opponent_actions if opponent_action]
            if any(previous_opponent_actions):
                action = Cooperate (C) if previous_opponent_actions[-1] == Defect else Defect (D)
            else:
                action = Defect (D)
        else:
            action = Cooperate (C)

    // update stock history and opponent actions
    new_stock = update_stock(stock_history[-1], [action for _ in range(n)])
    stock_history.append(new_stock)
    opponent_actions = update_opponent_actions(opponent_actions, [opponent_action for opponent_action in opponent_actions if opponent_action])

    // last round handling
    if round == r:
        action = Defect (D)

return action
```
This strategy is designed to be exploitative while adapting to the game's dynamic state and opponent behaviors. By playing Cooperate initially and conditionally cooperating based on stock levels and opponents' actions, this strategy aims to maximize individual payoffs while maintaining a sustainable resource level.
'''

description_EXPLOITATIVE_457 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors while adapting to the game's dynamic state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behaviors and to avoid depleting the stock too quickly.
2. **Stock Level**: If the current stock level is below 50% of the capacity, Defect (D). This is because the marginal gain from defecting increases as the stock level decreases.
3. **Opponent Behavior**: Analyze the opponent's behavior in previous rounds:
	* If an opponent has defected more than 50% of the time, Defect (D) to take advantage of their greed.
	* If an opponent has cooperated more than 75% of the time, Cooperate (C) to maintain a stable stock level and avoid exploiting them too aggressively.
4. **Recent Payoffs**: Consider the payoffs from recent rounds:
	* If the average payoff over the last 3 rounds is below 50% of the maximum possible payoff, Defect (D) to increase earnings.
5. **Round Number**: As the game approaches its final round, switch to Cooperate (C) if the stock level is above 25% of the capacity. This helps maintain a sustainable stock level and avoid over-exploitation.

**Pseudocode:**

```
function ASR(current_stock, opponent_history, recent_payoffs, current_round, total_rounds):
    if current_round == 1:
        return Cooperate
    elif current_stock < 0.5 * capacity:
        return Defect
    else:
        opponent_defection_rate = calculate_opponent_defection_rate(opponent_history)
        if opponent_defection_rate > 0.5:
            return Defect
        elif opponent_defection_rate < 0.25:
            return Cooperate
        
        recent_payoff_average = calculate_recent_payoff_average(recent_payoffs)
        if recent_payoff_average < 0.5 * max_payoff:
            return Defect
        
        if current_round > total_rounds - 2 and current_stock > 0.25 * capacity:
            return Cooperate
        else:
            return Defect
```

**Edge Cases:**

* In the first round, ASR cooperates to gather information.
* In the final round, ASR switches to Cooperate if the stock level is above 25% of the capacity to maintain sustainability.

**Exploitative Mindset:**

ASR prioritizes short-term gains when opponents are greedy or when the stock level is low. It also adapts to opponent behavior and recent payoffs to maximize its own earnings. By balancing exploitation with cooperation, ASR aims to outperform a wide range of opponent strategies in the tournament.
'''

description_EXPLOITATIVE_458 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

This strategy aims to exploit opponents' behaviors while adapting to changing game conditions and stock levels. The core idea is to balance cooperation and defection based on the current stock level, opponent behavior, and round number.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate if `capacity > 2n`, otherwise Defect.
	* This ensures a moderate initial consumption rate while adapting to the game's capacity constraints.
2. **Middle Rounds (2 ≤ t < r-1):**
	* If `stock ≥ 0.5 * capacity`:
		+ Cooperate with probability `p = min(1, (n - 1) / n)` if opponents defected in the previous round.
		+ Defect otherwise.
	* This encourages cooperation when the stock is relatively high and opponents have shown cooperative behavior.
3. **Late Rounds (t ≥ r-2):**
	* If `stock < 0.5 * capacity`:
		+ Cooperate with probability `p = max(0, 1 - ((r - t) / (r - 1)))` if opponents cooperated in the previous round.
		+ Defect otherwise.
	* This adjusts cooperation rates based on the remaining rounds and opponents' recent behavior, aiming to conserve stock for the final rounds.
4. **Edge Cases:**
	* If `stock ≤ 0`, always Cooperate (as there's nothing to gain from defecting).
	* If `t = r` (last round), always Defect (as there are no future consequences).

**Pseudocode:**

```markdown
function adaptive_stock_hawk(current_round, current_stock, opponent_actions):
    if current_round == 1:
        if capacity > 2n:
            return Cooperate
        else:
            return Defect

    # Middle rounds
    if current_stock >= 0.5 * capacity:
        opponents_defected = any(opponent_actions[previous_round] == Defect)
        cooperate_probability = min(1, (n - 1) / n) if opponents_defected else 0
        return random_choice([Cooperate, Defect], [cooperate_probability, 1 - cooperate_probability])

    # Late rounds
    if current_stock < 0.5 * capacity:
        opponents_cooperated = any(opponent_actions[previous_round] == Cooperate)
        cooperate_probability = max(0, 1 - ((r - current_round) / (r - 1))) if opponents_cooperated else 0
        return random_choice([Cooperate, Defect], [cooperate_probability, 1 - cooperate_probability])

    # Edge cases
    if current_stock <= 0:
        return Cooperate
    elif current_round == r:
        return Defect

    # Default case (should not occur)
    return Defect
```

This strategy balances short-term gains with long-term sustainability by adapting to the game's state and opponents' behavior. By doing so, it aims to exploit opportunities for cooperation while minimizing losses from over-exploitation of the common resource.
'''

description_EXPLOITATIVE_459 = '''
To design a robust and exploitative strategy for this Common Pool Resource Game, I'll introduce "Adaptive Stock-Based Exploitation" (ASBE). This approach balances cooperation and defection based on the current stock level, opponent behavior, and game history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gauge opponents' behavior and avoid immediate depletion.
2. **Stock Thresholds**: Set two thresholds:
	* `exploitation_threshold`: 0.75 * capacity
	* `conservation_threshold`: 0.25 * capacity

These thresholds will guide our decisions based on the current stock level.

3. **Opponent Behavior Analysis**:
	* Track opponents' average payoff in previous rounds (`avg_opponent_payoff`).
	* Calculate the ratio of opponents' payoffs to the maximum possible payoff (`payoff_ratio = avg_opponent_payoff / (capacity / n)`).
4. **Decision Logic**:
	* If `stock >= exploitation_threshold` and `payoff_ratio < 0.5`, Defect (D). Exploit the high stock level when opponents are not maximizing their payoffs.
	* If `stock <= conservation_threshold` or (`payoff_ratio >= 0.5` and `stock > conservation_threshold`), Cooperate (C). Conserve resources when the stock is low or opponents are maximizing their payoffs.
	* Otherwise, Defect (D) to take advantage of moderate stock levels.

**Edge Cases:**

1. **Last Round**: Always Defect (D) in the last round to maximize payoff regardless of the stock level.
2. **Low Stock Levels**: If `stock < 2 * n`, Cooperate (C) to avoid complete depletion and ensure some payoff.
3. **Tie-breaking**: In case of a tie between cooperation and defection, choose Defect (D) to prioritize exploitation.

**Pseudocode:**
```python
def ASBE(stock, capacity, n, avg_opponent_payoff, round_number):
    if round_number == 1:
        return 'C'  # Cooperate in the first round

    exploitation_threshold = 0.75 * capacity
    conservation_threshold = 0.25 * capacity
    payoff_ratio = avg_opponent_payoff / (capacity / n)

    if stock >= exploitation_threshold and payoff_ratio < 0.5:
        return 'D'  # Defect when exploiting high stock levels
    elif stock <= conservation_threshold or (payoff_ratio >= 0.5 and stock > conservation_threshold):
        return 'C'  # Cooperate for conservation or when opponents maximize payoffs
    else:
        return 'D'  # Defect in moderate stock levels

    if round_number == total_rounds:
        return 'D'  # Always defect in the last round

    if stock < 2 * n:
        return 'C'  # Cooperate to avoid complete depletion

    # Tie-breaking: prioritize exploitation
    return 'D'
```
This strategy adapts to various opponent behaviors and balances short-term gains with long-term sustainability. By tracking opponents' payoffs and adjusting our behavior accordingly, ASBE exploits opportunities for high payoffs while conserving resources when necessary.
'''

description_EXPLOITATIVE_460 = '''
**Exploitative Strategy: "Adaptive Stock Raider" (ASR)**

The ASR strategy aims to maximize its own payoff by adaptively responding to the game state and history of opponent actions.

**Decision Rules:**

1. **Initial Round:** Defect (D) in the first round to gauge opponents' behavior and set a high consumption baseline.
2. **Early Rounds (r < 5):**
	* If the current stock is above 75% of capacity, Cooperate (C).
	* Otherwise, Defect (D) to take advantage of the high growth rate.
3. **Mid-Rounds (5 ≤ r ≤ 10):**
	* Monitor opponents' behavior and calculate the average cooperation rate over the past 3 rounds.
	* If the average cooperation rate is above 0.6, Cooperate (C).
	* Otherwise, Defect (D) to exploit potential cooperators.
4. **Late Rounds (r > 10):**
	* Assess the current stock level and growth rate.
	* If the stock is below 50% of capacity or the growth rate is low (< 20%), Cooperate (C) to conserve resources.
	* Otherwise, Defect (D) to maximize short-term gains.

**Adaptive Response:**

1. **Opponent Cooperation:** If an opponent cooperates for two consecutive rounds, ASR will Cooperate (C) in the next round to take advantage of their cooperation.
2. **Opponent Defection:** If an opponent defects for two consecutive rounds, ASR will Defect (D) in the next round to punish them and maintain a high consumption rate.

**Edge Cases:**

1. **Last Round:** Always Defect (D) in the last round to maximize final payoff.
2. **Low Stock:** If the stock falls below 10% of capacity, Cooperate (C) to avoid depletion and allow for some growth.

**Pseudocode:**
```python
def ASR(current_stock, capacity, round_number, opponent_history):
    if round_number == 1:
        return 'D'  # Initial Round: Defect

    early_rounds = round_number < 5
    mid_rounds = 5 <= round_number <= 10
    late_rounds = round_number > 10

    if early_rounds:
        if current_stock > 0.75 * capacity:
            return 'C'  # Cooperate if stock is high
        else:
            return 'D'  # Defect otherwise

    elif mid_rounds:
        avg_cooperation_rate = calculate_avg_cooperation_rate(opponent_history)
        if avg_cooperation_rate > 0.6:
            return 'C'  # Cooperate if opponents are cooperative
        else:
            return 'D'  # Defect otherwise

    elif late_rounds:
        growth_rate = calculate_growth_rate(current_stock, capacity)
        if current_stock < 0.5 * capacity or growth_rate < 20:
            return 'C'  # Conserve resources if stock is low
        else:
            return 'D'  # Defect otherwise

    # Adaptive Response
    if opponent_cooperated_twice(opponent_history):
        return 'C'
    elif opponent_defected_twice(opponent_history):
        return 'D'

    # Edge Cases
    if round_number == r:  # Last Round
        return 'D'
    elif current_stock < 0.1 * capacity:  # Low Stock
        return 'C'

def calculate_avg_cooperation_rate(opponent_history):
    # Calculate average cooperation rate over past 3 rounds

def calculate_growth_rate(current_stock, capacity):
    # Calculate growth rate based on current stock and capacity

def opponent_cooperated_twice(opponent_history):
    # Check if an opponent cooperated in the last two rounds

def opponent_defected_twice(opponent_history):
    # Check if an opponent defected in the last two rounds
```
The ASR strategy aims to balance short-term gains with long-term sustainability by adapting to the game state and opponent behavior. By exploiting potential cooperators and conserving resources when necessary, ASR seeks to maximize its own payoff in a wide range of scenarios.
'''

description_EXPLOITATIVE_461 = '''
Here's a exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Stock Depletion Exploiter (ASDE)

**Decision Rules:**

1. **First Round**: Cooperate (C) to gather information about opponents' behaviors and initial stock depletion.
2. **Rounds 2-r-1**: If the current stock level is above a certain threshold (e.g., 75% of capacity), defect (D). Otherwise, cooperate (C).
3. **Last Round (r)**: Defect (D) to maximize individual payoff.

**Threshold Calculation:**

* Calculate the average stock depletion rate over the last few rounds (e.g., 3-5 rounds).
* If the average depletion rate is above a certain threshold (e.g., 20% of capacity per round), increase the cooperation threshold.
* Otherwise, decrease the cooperation threshold.

**Pseudocode:**
```python
def ASDE(stock, capacity, round_number, history):
    if round_number == 1:
        return C  # Cooperate in first round

    avg_depletion_rate = calculate_avg_depletion_rate(history)
    threshold = adjust_threshold(avg_depletion_rate)

    if stock > threshold * capacity:
        return D  # Defect if stock is high
    else:
        return C  # Cooperate otherwise

    if round_number == r:  # Last round
        return D  # Defect to maximize individual payoff

def calculate_avg_depletion_rate(history):
    # Calculate average stock depletion rate over last few rounds
    pass

def adjust_threshold(avg_depletion_rate):
    # Adjust cooperation threshold based on average depletion rate
    if avg_depletion_rate > 0.2 * capacity:
        return 0.8  # Increase cooperation threshold
    else:
        return 0.7  # Decrease cooperation threshold
```
**Rationale:**

* The ASDE strategy starts by cooperating in the first round to gather information about opponents' behaviors and initial stock depletion.
* In subsequent rounds, it uses a dynamic threshold to decide whether to cooperate or defect based on the current stock level. If the stock level is high, it defects to maximize individual payoff. Otherwise, it cooperates to conserve the resource.
* The strategy adjusts its cooperation threshold based on the average stock depletion rate over recent rounds. This allows it to adapt to changing opponent behaviors and avoid over-exploiting the resource.
* In the last round, the strategy defects to maximize individual payoff, as there is no future benefit to conserving the resource.

This strategy is exploitative, as it seeks to maximize individual payoff by adapting to opponents' behaviors and adjusting its cooperation threshold accordingly. It does not rely on norms or coordination mechanisms, making it robust to a wide range of opponent strategies.
'''

description_EXPLOITATIVE_462 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behavior and set a baseline for future decisions.
2. **Early Rounds (t>1, stock > 0.75*capacity)**: Defect (D) if the previous round's total consumption was below 0.5*capacity, indicating that opponents are likely cooperating or playing conservatively. Otherwise, Cooperate (C).
3. **Mid-Game (stock ≤ 0.75*capacity)**: Switch to a mixed strategy:
	* With probability p = stock / capacity, Defect (D). This probability increases as the stock level decreases.
	* With probability 1-p, Cooperate (C).
4. **Late Rounds (t > r-2, stock ≤ 0.25*capacity)**: Always Defect (D) to maximize payoffs in the final rounds.

**Edge Case Handling:**

* If the stock level reaches 0, always Defect (D) for the remainder of the game.
* In the last round (t=r), always Defect (D) regardless of the stock level.

**Rationale and Exploitative Mindset:**

This strategy aims to balance short-term gains with long-term sustainability. By cooperating in the initial rounds, we gather information about opponents' behavior and set a baseline for future decisions. As the game progresses, we adapt our strategy based on the current stock level and previous rounds' consumption.

By defecting when the stock level is high or opponents are playing conservatively, we exploit their cooperative behavior to maximize our payoffs. The mixed strategy in mid-game allows us to balance exploitation with some cooperation, taking into account the decreasing stock level.

In late rounds, we prioritize short-term gains by always defecting, as the game's end is near and sustainability is no longer a concern.

**Pseudocode:**
```python
def adaptive_stock_raider(n, r, capacity, current_stock, round_number, previous_consumption):
    if round_number == 1:
        return C
    elif current_stock > 0.75 * capacity:
        if previous_consumption < 0.5 * capacity:
            return D
        else:
            return C
    else:
        p = current_stock / capacity
        if random.random() < p:
            return D
        else:
            return C

def late_game_strategy(n, r, capacity, current_stock, round_number):
    if round_number > r - 2 and current_stock <= 0.25 * capacity:
        return D
    elif current_stock == 0:
        return D
    else:
        return adaptive_stock_raider(n, r, capacity, current_stock, round_number)
```
This strategy is designed to be robust against a wide range of opponent behaviors, exploiting their cooperative tendencies while adapting to the dynamic state of the game.
'''

description_EXPLOITATIVE_463 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit a wide range of opponent behaviors while adapting to changes in the game state and history. This strategy prioritizes self-interest and aims to maximize individual payoffs.

**Decision Rules:**

1. **Initial Rounds (t < n):** Defect (D) to gather information about opponents' behavior and assess their cooperativeness.
2. **Assessing Opponent Behavior:** Monitor the average stock depletion rate over the past `n` rounds. If the rate is high (> 0.5), assume opponents are predominantly defecting. Otherwise, assume they are cooperating or mixed.
3. **Exploiting Defecting Opponents:** If opponents are deemed to be defecting, cooperate (C) to minimize stock depletion and maximize personal payoff.
4. **Countering Cooperating Opponents:** If opponents are deemed to be cooperating, defect (D) to take advantage of their generosity and increase personal payoff.
5. **Stock-Based Thresholds:**
	* If the current stock level is low (< 0.25 \* capacity), cooperate (C) to ensure some growth and avoid depletion.
	* If the current stock level is high (> 0.75 \* capacity), defect (D) to maximize personal payoff.

**Edge Cases:**

1. **First Round:** Defect (D) to gather information about opponents' behavior.
2. **Last Round:** Defect (D) to maximize personal payoff, as there are no future consequences.
3. **Tie-Breaking:** In cases where the assessment of opponent behavior is uncertain or the stock level is near a threshold, cooperate (C) to err on the side of caution.

**Pseudocode:**
```python
def adaptive_predator(n, capacity, current_stock, round_number, history):
    if round_number < n:
        return 'D'  # Initial rounds: defect

    avg_depletion_rate = calculate_avg_depletion_rate(history)
    if avg_depletion_rate > 0.5:
        opponent_behavior = 'defecting'
    else:
        opponent_behavior = 'cooperating'

    if current_stock < 0.25 * capacity:
        return 'C'  # Low stock: cooperate
    elif current_stock > 0.75 * capacity:
        return 'D'  # High stock: defect

    if opponent_behavior == 'defecting':
        return 'C'  # Exploit defecting opponents
    else:
        return 'D'  # Counter cooperating opponents

def calculate_avg_depletion_rate(history):
    total_depletion = sum(stock_depletion for _, stock_depletion in history)
    return total_depletion / (round_number - 1)

# Example usage:
n = 4
capacity = 100
current_stock = 75
round_number = 5
history = [(10, 20), (15, 30), ...]  # Previous rounds' stock levels and depletions

action = adaptive_predator(n, capacity, current_stock, round_number, history)
print(action)  # Output: 'D'
```
This strategy is designed to be robust against a wide range of opponent behaviors and adapt to changes in the game state. By assessing opponent behavior and adjusting its actions accordingly, the Adaptive Predator aims to maximize individual payoffs while exploiting opportunities for growth.
'''

description_EXPLOITATIVE_464 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy is designed to maximize individual payoffs by adaptively responding to the game state and opponent behavior, while prioritizing exploitation over cooperation.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gauge opponents' initial behavior and avoid severe stock depletion.
2. **Early Rounds (t>1, stock ≥ capacity/2):** Defect (D) if the previous round's total consumption was high (> capacity/4), indicating aggressive opponent behavior. Otherwise, cooperate (C).
3. **Middle Game (t>1, stock < capacity/2):** Cooperate (C) if the previous round's total consumption was low (< capacity/4), suggesting cautious opponents. Defect (D) otherwise.
4. **Endgame (last 2 rounds, t=r-1 or t=r):** Defect (D) to maximize individual payoffs, as cooperation is less beneficial in the final rounds.

**Edge Cases:**

* If all opponents defected in the previous round and the stock level is critically low (< capacity/4), cooperate (C) to avoid complete stock depletion.
* If an opponent consistently cooperates while others defect, mirror their behavior (cooperate if they cooperate, defect if they defect).

**Adaptive Mechanism:**

Monitor the game state and opponent behavior by tracking:

1. **Total Consumption Ratio:** Calculate the ratio of total consumption to capacity in each round.
2. **Opponent Cooperation Rate:** Estimate the proportion of opponents cooperating in each round.

Adjust decision rules based on these metrics to adapt to changing opponent behavior and game dynamics.

**Pseudocode:**
```python
def adaptive_stock_raider(current_round, current_stock, previous_consumption, opponent_actions):
    if current_round == 1:
        return 'C'  # Cooperate in the first round
    
    total_consumption_ratio = previous_consumption / capacity
    opponent_cooperation_rate = estimate_opponent_cooperation(opponent_actions)
    
    if current_stock >= capacity / 2 and total_consumption_ratio > 0.25:
        return 'D'  # Defect if high consumption in previous round
    
    elif current_stock < capacity / 2 and total_consumption_ratio < 0.25:
        return 'C'  # Cooperate if low consumption in previous round
    
    elif current_round >= r - 1:  # Endgame
        return 'D'
    
    else:  # Middle game
        if opponent_cooperation_rate > 0.5:
            return 'C'  # Mirror cooperative opponents
        else:
            return 'D'  # Defect otherwise

def estimate_opponent_cooperation(opponent_actions):
    cooperation_count = sum(1 for action in opponent_actions if action == 'C')
    return cooperation_count / len(opponent_actions)
```
This strategy, "Adaptive Stock Raider," is designed to balance exploitation and adaptability while responding to various opponent behaviors. By monitoring the game state and adjusting decision rules accordingly, this strategy aims to maximize individual payoffs in a dynamic and competitive environment.
'''

description_EXPLOITATIVE_465 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit opponents' behaviors while being robust and adaptive to various playing styles.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gauge the opponents' behavior and avoid immediate over-exploitation.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, Defect (D). This takes advantage of the high stock levels while minimizing the risk of over-depletion.
	* If the current stock level is between 25% and 75% of the capacity:
		+ If the average payoff in the last 3 rounds is higher than the game's theoretical maximum payoff for a single round (i.e., capacity/2n), Cooperate (C). This suggests opponents are cooperating, so it's best to conserve the stock.
		+ Otherwise, Defect (D).
	* If the current stock level is below 25% of the capacity, Cooperate (C) to allow for some recovery and avoid over-exploitation.

**Edge Cases:**

1. **Last Round (t=r):** Always Defect (D), as there's no future benefit from cooperation.
2. **Low Stock Levels:** If the current stock level is very low (<10% of capacity), Cooperate (C) to prevent complete depletion and allow for some growth.

**Adaptive Component:**

1. **Monitoring Opponent Behavior:** Track the average payoff in the last 3 rounds to adjust the strategy based on opponents' actions.
2. **Stock Level Thresholds:** Adjust the stock level thresholds (25% and 75%) based on the game's history to balance exploitation with conservation.

**Pseudocode:**
```
function adaptive_predator(capacity, n, r, current_stock, previous_payoffs):
    if current_round == 1:
        return C
    elif current_stock > 0.75 * capacity:
        return D
    elif 0.25 * capacity <= current_stock <= 0.75 * capacity:
        avg_payoff_last_3_rounds = calculate_average_payoff(previous_payoffs)
        if avg_payoff_last_3_rounds > capacity / (2 * n):
            return C
        else:
            return D
    elif current_stock < 0.25 * capacity:
        return C
    elif current_round == r:
        return D

def calculate_average_payoff(previous_payoffs):
    # Calculate the average payoff in the last 3 rounds
```
The Adaptive Predator strategy is designed to balance exploitation with conservation, adapting to opponents' behaviors and game state changes. Its exploitative nature allows it to take advantage of high stock levels while minimizing over-depletion risks.
'''

description_EXPLOITATIVE_466 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round (t=1)**: Defect (D) - Take advantage of the initial stock level to maximize payoff.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is high (> 0.75 \* capacity), Cooperate (C) - Conserve the stock for future rounds and avoid over-exploitation.
	* If the current stock level is moderate (0.25 \* capacity ≤ stock ≤ 0.75 \* capacity), Defect (D) - Balance short-term gain with long-term sustainability.
	* If the current stock level is low (< 0.25 \* capacity), Cooperate (C) - Prioritize conservation to avoid depletion and ensure future payoffs.
3. **Last Round (t=r)**: Defect (D) - Maximize payoff in the final round, as there are no future rounds to consider.

Additional Logic:

1. **Opponent Behavior Analysis**: Observe opponents' actions in previous rounds and adjust strategy accordingly:
	* If most opponents Cooperate, Defect more frequently to exploit their conservatism.
	* If most opponents Defect, Cooperate more frequently to conserve the stock and avoid depletion.
2. **Stock Trend Analysis**: Analyze the stock level trend over recent rounds:
	* If the stock is increasing or stable, Cooperate more frequently to maintain sustainability.
	* If the stock is decreasing rapidly, Defect more frequently to maximize short-term gain before depletion.

Pseudocode (simplified):
```python
def adaptive_stock_raider(current_round, current_stock, capacity, opponent_history):
    if current_round == 1:
        return "D"  # Initial round: Defect

    if current_stock > 0.75 * capacity:
        return "C"  # High stock: Cooperate
    elif 0.25 * capacity <= current_stock <= 0.75 * capacity:
        return "D"  # Moderate stock: Defect
    else:
        return "C"  # Low stock: Cooperate

    # Analyze opponent behavior and adjust strategy
    if most_opponents_cooperate(opponent_history):
        return "D"  # Exploit conservative opponents
    elif most_opponents_defect(opponent_history):
        return "C"  # Conserve with aggressive opponents

    # Analyze stock trend and adjust strategy
    if stock_is_increasing_or_stable(current_stock, capacity):
        return "C"  # Maintain sustainability
    else:
        return "D"  # Maximize short-term gain

def most_opponents_cooperate(opponent_history):
    # Analyze opponent actions in previous rounds
    cooperate_count = sum(1 for action in opponent_history if action == "C")
    defect_count = len(opponent_history) - cooperate_count
    return cooperate_count > defect_count

def stock_is_increasing_or_stable(current_stock, capacity):
    # Analyze stock level trend over recent rounds
    recent_stock_levels = [current_stock] + get_recent_stock_levels()
    return all(level >= recent_stock_levels[0] for level in recent_stock_levels)

def get_recent_stock_levels():
    # Retrieve recent stock levels (implementation dependent)
    pass
```
This strategy adapts to the game state, opponent behavior, and stock trends to balance short-term gain with long-term sustainability. By analyzing opponent actions and adjusting its own strategy accordingly, "Adaptive Stock Raider" aims to exploit opponents' weaknesses while minimizing the risk of over-exploitation.
'''

description_EXPLOITATIVE_467 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoff by adaptively responding to the game state and opponents' behavior while prioritizing self-interest.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gather information on opponents' behavior and observe the initial stock depletion.
2. **Stock-dependent cooperation:** If the current stock is above 75% of capacity, cooperate (C). This allows for sustainable exploitation while maintaining a healthy stock level.
3. **Opponent-dependent defection:** If the number of defectors in the previous round is greater than or equal to n/2, defect (D) in the current round. This takes advantage of opponents' willingness to over-exploit and grabs a larger share of the remaining stock.
4. **Stock-growth-based adaptation:** Calculate the expected growth for the next round based on the current stock level and previous rounds' consumption. If the expected growth is below 25% of capacity, defect (D) to maximize short-term gains before the stock becomes depleted.
5. **Endgame exploitation:** In the last two rounds (t=r-1 and t=r), always defect (D) to maximize individual payoff regardless of opponents' actions.

**Pseudocode:**
```
Function AdaptiveStockRaider(current_stock, capacity, n, r, history):
  // Initial round
  if current_round == 1:
    return C

  // Stock-dependent cooperation
  if current_stock >= 0.75 * capacity:
    return C

  // Opponent-dependent defection
  num_defectors = count(defections in previous round)
  if num_defectors >= n / 2:
    return D

  // Stock-growth-based adaptation
  expected_growth = calculate_expected_growth(current_stock, history)
  if expected_growth < 0.25 * capacity:
    return D

  // Endgame exploitation
  if current_round >= r - 1:
    return D

  // Default: Cooperate to maintain a healthy stock level
  return C
```
**Rationale:**

This strategy balances short-term gains with long-term sustainability by adapting to the game state and opponents' behavior. By cooperating when the stock is high, it maintains a healthy stock level and encourages opponents to do the same. When opponents defect frequently or the stock growth is low, it exploits this situation to maximize individual payoff.

The endgame exploitation phase prioritizes short-term gains over sustainability, as the game is nearing its conclusion. This strategy should perform well in a tournament setting against independent strategies, as it does not rely on coordination mechanisms or specific opponent behaviors.
'''

description_EXPLOITATIVE_468 = '''
**Strategy Name:** Adaptive Exploiter (AE)

**Overview:**
AE is a dynamic, exploitative strategy that adapts to the game's state and history to maximize its payoff. It balances cooperation and defection to maintain a healthy stock level while taking advantage of opponents' actions.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gauge opponents' behavior and avoid over-consumption.
2. **Stock-based Cooperation:** If the current stock level is above 75% of the capacity, cooperate (C). This ensures a moderate consumption rate and allows for some growth.
3. **Opponent-driven Defection:** If at least one opponent defected in the previous round, defect (D) in the current round. This punishes opponents for over-consumption and signals that AE will not tolerate exploitation.
4. **Growth-oriented Cooperation:** If the stock level is below 50% of the capacity and the growth rate is high (> 20%), cooperate (C). This promotes stock recovery and takes advantage of the growth opportunity.
5. **History-driven Defection:** If the total payoff from cooperation in the previous rounds is less than 75% of the maximum possible payoff, defect (D) in the current round. This adjusts AE's strategy if cooperation has not yielded sufficient returns.

**Edge Case Handling:**

* In the last round, always defect (D), as there are no future consequences.
* If an opponent consistently cooperates while others defect, AE will still defect to maximize its own payoff.
* If all opponents cooperate, AE will also cooperate to maintain a healthy stock level and avoid being the sole defector.

**Pseudocode:**

```
function AdaptiveExploiter(stock, capacity, history):
  if (round == 1) {
    return COOPERATE;
  }

  if (stock >= 0.75 * capacity) {
    return COOPERATE;
  }

  if (anyOpponentDefected(history)) {
    return DEFECT;
  }

  if (stock < 0.5 * capacity && growthRate > 20%) {
    return COOPERATE;
  }

  if (totalCooperationPayoff < 0.75 * maxPossiblePayoff) {
    return DEFECT;
  }

  // Fallback to cooperation
  return COOPERATE;
}
```

**Rationale:**
AE's adaptive nature allows it to respond effectively to various opponent strategies, balancing short-term gains with long-term sustainability. By cooperating when the stock level is high or growth opportunities arise, AE maintains a healthy stock and creates opportunities for exploitation. When opponents defect, AE punishes them by defecting as well, ensuring that its own payoff remains competitive.
'''

description_EXPLOITATIVE_469 = '''
I'll design an exploitative strategy that adapts to various opponent behaviors and maximizes my payoff while considering the game's parameters, state, and history.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and set a baseline for future adaptations.
2. **Early Game (Rounds 2-5)**:
	* If the stock level is above 75% of capacity, Defect (D) to maximize short-term gain while minimizing the risk of over-exploitation.
	* If the stock level is between 50% and 75% of capacity, Cooperate (C) to maintain a balance between individual gain and collective sustainability.
	* If the stock level is below 50% of capacity, Defect (D) to maximize gain before the resource depletes further.
3. **Mid-Game (Rounds 6-r/2)**:
	* Monitor opponents' behavior: track the number of cooperators (C_count) and defectors (D_count) in previous rounds.
	* If C_count > D_count, Cooperate (C) to maintain a balanced approach and avoid over-exploitation.
	* If D_count ≥ C_count, Defect (D) to exploit opponents' cooperative behavior.
4. **Late Game (Rounds r/2+1-r)**:
	* If the stock level is above 25% of capacity, Cooperate (C) to ensure a minimal payoff and avoid complete depletion.
	* If the stock level is below 25% of capacity, Defect (D) to maximize gain before the game ends.

**Edge Cases:**

1. **Last Round**: Always Defect (D), as there's no future benefit in cooperating.
2. **Stock Depletion**: If the stock level falls below a critical threshold (e.g., 10% of capacity), Cooperate (C) to prolong the game and maintain some payoff.

**Adaptive Mechanisms:**

1. **Opponent Behavior Tracking**: Monitor opponents' actions and adjust the strategy based on their behavior.
2. **Stock Level Monitoring**: Continuously assess the stock level and adapt the strategy to optimize gain while maintaining sustainability.
3. **Game Phase Adaptation**: Adjust the strategy as the game progresses through different phases (early, mid, late).

**Pseudocode:**
```python
def Adaptive_Exploiter(stock, capacity, round_num, r, C_count, D_count):
    if round_num == 1:
        return "C"  # Initial Round: Cooperate
    
    if stock > 0.75 * capacity and round_num < 5:
        return "D"  # Early Game: Defect
    
    elif stock >= 0.5 * capacity and stock <= 0.75 * capacity and round_num < 5:
        return "C"  # Early Game: Cooperate
    
    elif stock < 0.5 * capacity and round_num < 5:
        return "D"  # Early Game: Defect
    
    elif C_count > D_count and round_num >= 6 and round_num <= r/2:
        return "C"  # Mid-Game: Cooperate
    
    elif D_count >= C_count and round_num >= 6 and round_num <= r/2:
        return "D"  # Mid-Game: Defect
    
    elif stock > 0.25 * capacity and round_num > r/2:
        return "C"  # Late Game: Cooperate
    
    elif stock <= 0.25 * capacity and round_num > r/2:
        return "D"  # Late Game: Defect
    
    else:
        if round_num == r:
            return "D"  # Last Round: Defect
        elif stock < 0.1 * capacity:
            return "C"  # Stock Depletion: Cooperate
```
This strategy is designed to be exploitative, adaptive, and robust against various opponent behaviors. By monitoring opponents' actions and adjusting the strategy accordingly, AE aims to maximize its payoff while considering the game's parameters, state, and history.
'''

description_EXPLOITATIVE_470 = '''
To develop a robust and exploitative strategy for this Common Pool Resource Game, I propose the following adaptive approach:

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behavior and set a cooperative tone.
2. **Middle Rounds (1 < t < r-1)**:
	* If stock level is above 75% of capacity, Defect (D) to maximize individual payoff, as the cost of over-extraction is shared among all players.
	* If stock level is between 50% and 75% of capacity, Cooperate (C) to balance individual payoff with sustainability concerns.
	* If stock level is below 50% of capacity, Defect (D) aggressively to capture remaining resources before the game ends.
3. **Last Round (t=r)**: Always Defect (D), as there are no future rounds to worry about sustainability.

**Edge Cases and Additional Considerations:**

* **Opponent Cooperation**: If a player observes that most opponents (>50%) Cooperate in the previous round, they should Cooperate in the next round to avoid exploiting cooperative behavior.
* **Consecutive Defection**: If a player defects for two consecutive rounds, they should Cooperate in the next round to avoid over-exploiting the resource and maintain some level of sustainability.
* **Resource Depletion**: If the stock level falls below 25% of capacity, players should Defect aggressively to capture remaining resources before the game ends.

**Pseudocode:**

```
function exploitative_strategy(state, history)
    if t == 1 then
        return COOPERATE
    elseif state.stock > 0.75 * capacity then
        return DEFECT
    elseif state.stock >= 0.5 * capacity and state.stock <= 0.75 * capacity then
        return COOPERATE
    elseif state.stock < 0.5 * capacity then
        return DEFECT
    else if t == r then
        return DEFECT
    end

    // Additional considerations
    opponents_cooperated = count_opponents_who_cooperated(history)
    if opponents_cooperated > n/2 then
        return COOPERATE
    end

    consecutive_defection = consecutive_defections(history)
    if consecutive_defection >= 2 then
        return COOPERATE
    end

    // Resource depletion
    if state.stock < 0.25 * capacity then
        return DEFECT
    end
end
```

**Rationale:**

This strategy balances individual payoff with sustainability concerns by adapting to the current stock level and opponent behavior. By cooperating in the initial round, we gather information about opponents' behavior and set a cooperative tone. In middle rounds, we defect when the stock level is high to maximize individual payoff and cooperate when the stock level is moderate to balance individual interests with sustainability concerns.

In edge cases, such as the last round or resource depletion, we prioritize exploiting remaining resources aggressively. By considering additional factors like opponent cooperation and consecutive defection, we avoid over-exploiting cooperative behavior and maintain some level of sustainability.

This strategy should perform well in a tournament setting, as it is robust to various opponent behaviors and adapts to changing circumstances throughout the game.
'''

description_EXPLOITATIVE_471 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

The ASE strategy aims to maximize its payoff by adaptively responding to the current state and history of the game, while also being robust to various opponent behaviors.

**Decision Rules**

1. **Initial Round**: Defect (D) in the first round to gather information about the opponents' behavior and to reduce the stock level.
2. **Subsequent Rounds**: Cooperate (C) if the current stock level is above a certain threshold (`stock_threshold`), calculated as `capacity / (2 * n)`. This encourages cooperation when the stock is relatively high, allowing for sustainable growth.
3. **Low Stock**: Defect (D) if the current stock level is below the `stock_threshold`. This ensures that ASE takes advantage of the remaining stock before it's depleted.
4. **Adaptive Response**: If the previous round's total consumption was high (`total_consumption > capacity / 2`), switch to Cooperate (C) for one round, regardless of the current stock level. This helps to stabilize the stock and prevent over-exploitation.

Pseudocode:
```python
def ASE(n, capacity, stock, history):
    if len(history) == 0:  # Initial Round
        return 'D'
    
    stock_threshold = capacity / (2 * n)
    
    if stock > stock_threshold:
        return 'C'  # Cooperate when stock is relatively high
    
    if total_consumption_history[-1] > capacity / 2:
        return 'C'  # Switch to Cooperate for one round after high consumption
    
    return 'D'  # Default to Defect
```
**Edge Cases**

* **Last Round**: In the final round, ASE will Defect (D) regardless of the current stock level, as there is no future growth or payoffs to consider.
* **Stock Depletion**: If the stock level reaches zero, ASE will Cooperate (C) in the subsequent rounds, as there is no benefit in continuing to defect.

**Exploitative Mindset**

The ASE strategy prioritizes exploiting the common pool resource while adapting to the opponents' behavior. By cooperating when the stock is high and defecting when it's low, ASE aims to maximize its payoff while also preventing over-exploitation and promoting sustainable growth. The adaptive response mechanism ensures that ASE can adjust its behavior in response to changes in the game state, making it robust against various opponent strategies.

**Tournament Performance**

The ASE strategy should perform well in a tournament setting, as it is designed to exploit the common pool resource while adapting to different opponent behaviors. Its ability to respond to high consumption and stabilize the stock will help prevent over-exploitation, allowing ASE to accumulate payoffs across multiple rounds.
'''

description_EXPLOITATIVE_472 = '''
I'll design a strategic approach for this Common Pool Resource Game that adapts to various opponent behaviors while maximizing my own payoff.

**Strategy Name:** Adaptive Exploitation (AE)

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C). Observe the actions of other players and the resulting payoffs.
2. **Middle Rounds (2 ≤ t < r)**:
	* If the current stock level is above 75% of the capacity, Defect (D) with a probability p = (number of defectors in previous round) / n.
	* Otherwise, Cooperate (C).
3. **Last Round (t=r)**: Defect (D). Since this is the final round, maximize immediate payoff regardless of stock level.

**Adaptive Component:**

1. Track the number of defectors and cooperators in each round.
2. Calculate a "defection rate" as the proportion of players who defected in the previous round.
3. Adjust the probability p (in step 2) based on this defection rate to adapt to changing opponent behaviors.

**Pseudocode:**
```
function AdaptiveExploitation(n, r, capacity):
  // Initialize variables
  stock = capacity
  num_defectors = 0
  num_cooperators = 0

  for t = 1 to r:
    if t == 1:
      action = C  // Cooperate in the first round
    else:
      if stock >= 0.75 * capacity:
        p = num_defectors / n  // Defection probability based on previous round's defection rate
        action = D with probability p, otherwise C
      else:
        action = C

    // Observe opponent actions and update counts
    num_defectors = count(defectors in this round)
    num_cooperators = n - num_defectors

    // Update stock level based on all players' actions
    total_consumption = ...
    stock = stock - total_consumption + growth(capacity, stock)

  return action
```
**Rationale:**

1. Cooperating in the first round allows us to observe opponent behaviors and adjust our strategy accordingly.
2. Defecting with a probability p that adapts to the number of defectors in previous rounds enables us to exploit opponents who tend to cooperate while also being cautious not to overexploit, which could lead to stock depletion.
3. Cooperating when the stock level is low helps maintain a sustainable resource and prevents complete depletion.
4. Defecting in the last round ensures maximum payoff regardless of the stock level.

This strategy should perform well against various opponent behaviors, as it balances exploitation with caution and adaptability.
'''

description_EXPLOITATIVE_473 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adaptively exploiting the common pool resource, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) with a probability of 0.5. This initial cooperation serves as a "probe" to gauge opponents' behavior and gather information about their strategies.
2. **Subsequent Rounds (t>1)**:
	* If the stock level is above 75% of capacity, Defect (D). The goal is to exploit the resource when it's abundant.
	* If the stock level is between 25% and 75% of capacity, use a "Tit-for-Tat" approach: Cooperate if the majority of opponents cooperated in the previous round; otherwise, Defect. This rule encourages cooperation when the resource is moderately depleted but still valuable.
	* If the stock level is below 25% of capacity, Cooperate (C). At this point, it's essential to conserve the remaining resource and allow for regrowth.
3. **Opponent Behavior Analysis**:
	* Track the number of opponents who cooperated or defected in each round.
	* Calculate the "cooperation ratio" as the proportion of cooperative actions among all opponents.

**Adaptive Adjustments:**

1. **Cooperation Threshold**: If the cooperation ratio is above 0.6, decrease the cooperation threshold by 5% (e.g., from 25% to 20%). This adjustment encourages more exploitation when opponents are cooperative.
2. **Defection Threshold**: If the cooperation ratio is below 0.4, increase the defection threshold by 5% (e.g., from 75% to 80%). This adjustment promotes more conservation when opponents are defecting.

**Edge Cases:**

1. **Last Round (t=r)**: Defect (D) unconditionally, as there's no future benefit in conserving the resource.
2. **Stock Depletion**: If the stock level drops below a certain threshold (e.g., 10%), Cooperate (C) to prevent complete depletion and allow for regrowth.

**Pseudocode:**
```python
def adaptive_stock_raider(current_stock, capacity, opponents_actions):
    # Initial round
    if current_round == 1:
        return random.choice([COOPERATE, DEFECT])  # Probe with 50% cooperation

    # Subsequent rounds
    stock_ratio = current_stock / capacity
    if stock_ratio > 0.75:
        return DEFECT
    elif 0.25 <= stock_ratio <= 0.75:
        majority_cooperated = opponents_actions.count(COOPERATE) > len(opponents_actions) / 2
        return COOPERATE if majority_cooperated else DEFECT
    else:
        return COOPERATE

    # Adaptive adjustments
    cooperation_ratio = opponents_actions.count(COOPERATE) / len(opponents_actions)
    if cooperation_ratio > 0.6:
        cooperation_threshold -= 0.05
    elif cooperation_ratio < 0.4:
        defection_threshold += 0.05

# Main loop
for current_round in range(1, r+1):
    opponents_actions = get_opponents_actions(current_round-1)
    current_stock = get_current_stock()
    action = adaptive_stock_raider(current_stock, capacity, opponents_actions)
    take_action(action)
```
This strategy aims to balance exploitation and conservation by adaptively adjusting its behavior based on the stock level, opponent actions, and cooperation ratio. By being exploitative while still considering the long-term sustainability of the resource, "Adaptive Stock Raider" should perform well in a tournament against various independent strategies.
'''

description_EXPLOITATIVE_474 = '''
I'll outline a exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors and maximizes payoffs over multiple rounds. I'll introduce "Greedy Observer" (GO), a decision-making approach that balances short-term gains with long-term sustainability.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe the initial stock level and capacity.
	* Choose to Cooperate (C) if the number of players (n) is even, otherwise Defect (D).
2. **Subsequent Rounds (t>1)**:
	* Monitor the current stock level, previous round's total consumption, and opponents' past actions.
	* If the current stock level is above 75% of capacity:
		+ Cooperate if at least half of opponents defected in the previous round.
		+ Defect otherwise.
	* If the current stock level is between 50% and 75% of capacity:
		+ Defect if total consumption in the previous round exceeded 50% of capacity.
		+ Cooperate otherwise.
	* If the current stock level is below 50% of capacity:
		+ Cooperate to allow for potential stock recovery.

**Pseudocode (simplified):**
```
function GreedyObserver(n, capacity, stock, t, history) {
  if (t == 1) {
    // Initial round
    return n % 2 == 0 ? C : D;
  }

  // Subsequent rounds
  let prevConsumption = history[t-1].total_consumption;
  let opponentsDefected = countDefectors(history[t-1]);

  if (stock > 0.75 * capacity) {
    return opponentsDefected >= n/2 ? C : D;
  } else if (stock >= 0.5 * capacity && stock <= 0.75 * capacity) {
    return prevConsumption > 0.5 * capacity ? D : C;
  } else {
    return C; // Cooperate to recover stock
  }
}
```
**Edge Cases:**

* **Last Round (t=r)**:
	+ Defect, as there is no future benefit from cooperating.
* **Opponents' Strategies**:
	+ GO does not assume specific strategies or coordination mechanisms from opponents. Instead, it adapts based on observed behaviors.

**Exploitative Mindset:**
GO prioritizes short-term gains while considering the long-term sustainability of the common pool resource. By observing opponents' actions and adjusting its own behavior accordingly, GO aims to maximize payoffs over multiple rounds.

In a tournament setting, Greedy Observer's adaptive nature should allow it to perform well against various opponent strategies, including those that attempt to cooperate or defect in specific patterns.
'''

description_EXPLOITATIVE_475 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

This strategy aims to maximize individual payoff by adaptively responding to the current state of the game and the observed behavior of other players.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to observe how other players behave and to avoid over-exploiting the stock.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is high (> 75% of capacity), Defect (D) to maximize individual payoff, as the stock can sustain higher consumption.
	* If the current stock level is moderate (25% ≤ stock ≤ 75% of capacity), Cooperate (C) if the average opponent cooperation rate in the previous round is above 0.5; otherwise, Defect (D). This rule encourages cooperation when opponents are cooperative but switches to defection when they are not.
	* If the current stock level is low (< 25% of capacity), Cooperate (C) to conserve the remaining stock and allow for regrowth.
3. **Last Round (t=r):** Defect (D) in the final round, as there is no future benefit to cooperating.

**Adaptive Component:**

* Maintain a rolling average of opponent cooperation rates over the last 2-3 rounds.
* If the average opponent cooperation rate increases or remains high (> 0.5), increase the likelihood of Cooperating (C) in subsequent rounds.
* If the average opponent cooperation rate decreases or remains low (< 0.5), decrease the likelihood of Cooperating (C) and Defect (D) more frequently.

**Edge Cases:**

* **Tiebreaker:** In cases where the decision rules yield a tie, Defect (D).
* **Zero Stock:** If the stock level reaches zero, Cooperate (C) to avoid further depletion.
* ** Opponent Behavior:** If an opponent consistently cooperates or defects, adjust the strategy accordingly. For example, if an opponent always cooperates, exploit this by defecting more frequently.

**Pseudocode:**
```markdown
# Initialize variables
stock_history = []
opponent_cooperation_rates = []

# Main loop
for t in range(1, r+1):
  # Get current stock level and opponent actions from previous round
  current_stock = get_current_stock()
  opponent_actions = get_opponent_actions(t-1)

  # Calculate average opponent cooperation rate
  avg_opponent_cooperation_rate = calculate_avg_opponent_cooperation_rate(opponent_actions)

  # Determine action based on decision rules
  if t == 1:
    action = C
  elif current_stock > 0.75 * capacity:
    action = D
  elif 0.25 * capacity <= current_stock <= 0.75 * capacity:
    if avg_opponent_cooperation_rate > 0.5:
      action = C
    else:
      action = D
  elif current_stock < 0.25 * capacity:
    action = C

  # Update opponent cooperation rates and stock history
  opponent_cooperation_rates.append(avg_opponent_cooperation_rate)
  stock_history.append(current_stock)

  # Take action and update game state
  take_action(action)
```
This strategy is designed to be robust and adaptive, responding to various opponent behaviors while maximizing individual payoff. By adjusting the decision rules based on the current state of the game and observed opponent behavior, "Adaptive Stock Hawk" aims to outperform other strategies in the tournament.
'''

description_EXPLOITATIVE_476 = '''
Here's a exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, AE defects (D) to maximize its payoff and gather information about opponents' behaviors.
2. **Stock Assessment**: After each round, AE assesses the current stock level (S) and calculates the remaining capacity for exploitation (RCE = capacity - S).
3. **Opponent Behavior Analysis**: AE tracks the number of cooperators (C_count) and defectors (D_count) in the previous round.
4. **Exploitation Threshold**: If RCE > 0.5 \* capacity, AE defects (D). Otherwise, it cooperates (C).

**Adaptive Logic**:

1. **Punish Cooperators**: If C_count > D_count and S < 0.75 \* capacity, AE defects (D) to punish cooperative opponents.
2. **Exploit Defectors**: If D_count > C_count and RCE > 0.25 \* capacity, AE defects (D) to exploit opponents' greed.
3. **Conserve Stock**: If S < 0.25 \* capacity, AE cooperates (C) to conserve the stock and prevent depletion.

**Edge Cases**:

1. **Last Round**: In the final round, AE always defects (D) to maximize its payoff, regardless of the stock level or opponent behavior.
2. **Tied Opponent Behavior**: If C_count = D_count, AE uses a random choice between cooperating (C) and defecting (D).

**Pseudocode**:
```python
def adaptive_exploiter(stock, capacity, round_num, prev_actions):
  # Initialize variables
  RCE = capacity - stock
  C_count = sum(1 for action in prev_actions if action == 'C')
  D_count = len(prev_actions) - C_count

  # Initial Round: Defect
  if round_num == 1:
    return 'D'

  # Stock Assessment and Opponent Behavior Analysis
  if RCE > 0.5 * capacity:
    return 'D'  # Exploit if sufficient stock remains
  elif C_count > D_count and stock < 0.75 * capacity:
    return 'D'  # Punish cooperators
  elif D_count > C_count and RCE > 0.25 * capacity:
    return 'D'  # Exploit defectors
  elif stock < 0.25 * capacity:
    return 'C'  # Conserve stock

  # Last Round: Always Defect
  if round_num == total_rounds:
    return 'D'

  # Tied Opponent Behavior: Random Choice
  if C_count == D_count:
    import random
    return random.choice(['C', 'D'])

  # Default: Cooperate
  return 'C'
```
This strategy, Adaptive Exploiter (AE), aims to balance short-term gains with long-term sustainability by adapting to the game state and opponent behavior. By exploiting opponents' greed and punishing cooperators when possible, AE seeks to maximize its payoff in a wide range of scenarios.
'''

description_EXPLOITATIVE_477 = '''
**Exploitative Strategy: "Adaptive Raider"**

The Adaptive Raider strategy is designed to exploit the Common Pool Resource Game by adapting to the opponents' behaviors and maximizing its own payoffs while minimizing the risk of stock depletion.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) with a probability of 0.5, and Defect (D) with a probability of 0.5. This initial randomness allows us to gather information about opponents' behaviors without revealing our own strategy.
2. **Subsequent Rounds (t>1)**:
	* If the stock level is above 75% of capacity, Cooperate (C).
	* If the stock level is between 50% and 75% of capacity, Defect (D) with a probability of 0.6, and Cooperate (C) with a probability of 0.4.
	* If the stock level is below 50% of capacity, Defect (D).
3. **Opponent Behavior Analysis**: After each round, analyze the opponents' actions:
	+ If most opponents (>60%) Cooperated in the previous round, increase the probability of Defecting by 0.1 for the next round.
	+ If most opponents (>60%) Defected in the previous round, decrease the probability of Defecting by 0.1 for the next round.

**Edge Cases:**

* **Last Round (t=r)**: Cooperate (C) to ensure a minimum payoff, as defecting might lead to stock depletion and zero payoffs.
* **Stock Level near Depletion**: If the stock level falls below 10% of capacity, Defect (D) to maximize payoffs before the game ends.

**Pseudocode:**
```python
def adaptive_raider(n, r, capacity, current_stock, round_number):
    if round_number == 1:
        # Initial randomness
        cooperate_probability = 0.5
    else:
        # Analyze opponents' behavior
        opponent_cooperation_rate = analyze_opponent_behavior()
        
        # Adjust defect probability based on stock level and opponent behavior
        if current_stock > 0.75 * capacity:
            cooperate_probability = 1.0
        elif current_stock >= 0.5 * capacity:
            cooperate_probability = 0.4 - (opponent_cooperation_rate - 0.6) * 0.1
        else:
            cooperate_probability = 0.0
    
    # Make decision based on probabilities
    if random.random() < cooperate_probability:
        return "C"
    else:
        return "D"

def analyze_opponent_behavior():
    # TO DO: implement opponent behavior analysis based on game history
    pass
```
This strategy is designed to be exploitative, adaptive, and robust against a wide range of opponent behaviors. By analyzing opponents' actions and adjusting its own behavior accordingly, the Adaptive Raider aims to maximize its payoffs while minimizing the risk of stock depletion.
'''

description_EXPLOITATIVE_478 = '''
Here's a proposed exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This sets the tone for potential cooperation and gathers information about opponents' initial moves.
2. **Middle Rounds (2 ≤ t < r):**
	* If stock level is high (> capacity/2), Defect (D) with probability p = 0.7, otherwise Cooperate (C). This takes advantage of abundant resources while maintaining a moderate level of cooperation to avoid depletion.
	* Monitor opponents' behavior: count the number of times each opponent has Defected (d_i) and the total number of rounds they've played (t_i).
3. **Late Rounds (t ≥ r-2):** Adjust strategy based on observed opponent behavior:
	* If an opponent i has defected more than 50% of the time (d_i/t_i > 0.5), Defect (D) against them with probability p = 0.9. This punishes frequent defectors.
	* Otherwise, Cooperate (C) with probability p = 0.6 to encourage cooperation and maintain a healthy stock level.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D). There's no future benefit to cooperating in the final round.
2. **Opponent Leaves or Doesn't Play:** Treat them as a defector, incrementing their d_i counter.
3. **Stock Depletion:** If stock level falls below capacity/4, Cooperate (C) with probability p = 0.8 to help replenish resources.

**Pseudocode:**
```python
def adaptive_exploiter(n, r, capacity, history):
    # Initialize variables
    stock_level = capacity
    opponent_behavior = [[0, 0] for _ in range(n)]  # [d_i, t_i]

    for t in range(1, r+1):
        if t == 1:  # Initial Round
            action = 'C'
        elif stock_level > capacity/2:
            action = 'D' if random.random() < 0.7 else 'C'
        else:  # Late Rounds
            opponent_defection_rates = [d_i/t_i for d_i, t_i in opponent_behavior]
            action = 'D' if any(rate > 0.5 for rate in opponent_defection_rates) else 'C'

        # Update opponent behavior counters
        for i, (d_i, t_i) in enumerate(opponent_behavior):
            if history[i][t-1] == 'D':
                d_i += 1
            t_i += 1

        # Update stock level and adjust strategy if necessary
        consumption = calculate_consumption(action, n)
        stock_level -= consumption
        growth = calculate_growth(stock_level, capacity)
        stock_level = min(stock_level + growth, capacity)

    return action
```
This strategy adapts to the game's dynamics by balancing exploitation with cooperation. By monitoring opponent behavior and adjusting its actions accordingly, AE aims to maximize its payoff while maintaining a sustainable resource level.
'''

description_EXPLOITATIVE_479 = '''
**Strategy Name: Adaptive Exploiter (AE)**

The Adaptive Exploiter strategy is designed to maximize payoffs by exploiting opponents' behaviors while adapting to changes in the game state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' initial strategies.
2. **Opponent Monitoring:** Track the number of times each opponent has defected (D) in previous rounds.
3. **Defection Threshold:** Set a threshold value `θ` (e.g., 0.5) representing the proportion of opponents that must have defected in the previous round for AE to defect in the current round.
4. **Current Round Decision:**
	* If the number of opponents who defected in the previous round is greater than or equal to `θ`, defect (D).
	* Otherwise, cooperate (C) if the stock level is above a certain threshold (`stock_threshold`, e.g., 0.75 \* capacity), and defect otherwise.
5. **Last Round:** Cooperate (C) in the last round to maximize payoffs, as there is no future interaction.

Pseudocode:
```
// Initialize variables
opponent_defection_count = [0] * n  // array to track opponent defections
stock_threshold = 0.75 * capacity
θ = 0.5

// Loop through rounds
for t in range(r):
    if t == 0:  // initial round
        action[t] = C
    else:
        // Update opponent defection counts
        for i in range(n):
            if opponents[i].action[t-1] == D:
                opponent_defection_count[i] += 1
        
        // Check if opponents have defected enough to trigger AE's defection
        if sum(opponent_defection_count) / n >= θ:
            action[t] = D
        else:
            // Cooperate if stock level is high, defect otherwise
            if stock[t-1] > stock_threshold:
                action[t] = C
            else:
                action[t] = D
    
    // Last round: always cooperate
    if t == r - 1:
        action[t] = C

// Update opponent defection counts and stock levels after each round
for i in range(n):
    opponents[i].defection_count += (opponents[i].action[t] == D)
stock[t] = update_stock(stock[t-1], actions[t])
```
**Edge Cases:**

* **First Round:** Cooperate to gather information.
* **Last Round:** Always cooperate to maximize payoffs.
* **Low Stock Levels:** Defect when the stock level is low, as cooperation will not yield significant benefits.

By monitoring opponents' behaviors and adapting to changes in the game state, AE aims to exploit others' strategies while minimizing its own losses. This approach should provide a robust and effective exploitative strategy for the Common Pool Resource Game.
'''

description_EXPLOITATIVE_480 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to observe opponents' actions and gauge their willingness to cooperate.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term payoff.
	* If the current stock level is between 25% and 75% of capacity, Cooperate (C) if the average opponent cooperation rate in previous rounds is above 50%. Otherwise, Defect (D).
	* If the current stock level is below 25% of capacity, Cooperate (C) to help replenish the stock.
3. **Final Round (t=r):** Defect (D) to maximize payoff, as there's no future benefit from cooperation.

**Edge Case Handling:**

1. **First Round:** As mentioned earlier, Cooperate (C) to gather information about opponents' actions.
2. **Last Round:** Always Defect (D), regardless of the stock level or opponents' previous actions.
3. **Low Stock Levels:** If the current stock level is extremely low (< 10% of capacity), Cooperate (C) to avoid depletion and potential negative payoffs.

**Adaptive Mechanisms:**

1. **Opponent Cooperation Rate Tracking:** Monitor the average cooperation rate of opponents in previous rounds to inform decisions.
2. **Stock Level Monitoring:** Continuously track the current stock level to adjust strategy accordingly.

**Pseudocode:**
```markdown
# Initialize variables
stock_capacity = capacity
current_stock = stock_capacity
opponent_cooperation_rate = 0.5  # initial guess

for t in range(1, r + 1):
    if t == 1:
        action = COOPERATE  # initial round
    elif current_stock > 0.75 * stock_capacity:
        action = DEFECT  # high stock level
    elif current_stock >= 0.25 * stock_capacity and opponent_cooperation_rate > 0.5:
        action = COOPERATE  # moderate stock level, cooperative opponents
    elif current_stock >= 0.25 * stock_capacity and opponent_cooperation_rate <= 0.5:
        action = DEFECT  # moderate stock level, non-cooperative opponents
    elif current_stock < 0.25 * stock_capacity:
        action = COOPERATE  # low stock level
    else:
        action = DEFECT  # last round or extremely low stock level

    # Update opponent cooperation rate tracking and current stock level
    if t > 1:
        opponent_cooperation_rate = (opponent_cooperation_rate * (t - 2) + opponents[t-1].cooperation_rate) / (t - 1)
        current_stock = update_stock_level(current_stock, action, opponents[t-1].actions)

# Output the chosen action
return action
```
This strategy aims to balance short-term gains with long-term sustainability by adapting to changing stock levels and opponent behaviors. By tracking opponent cooperation rates and adjusting its actions accordingly, "Adaptive Stock Raider" seeks to exploit non-cooperative opponents while maintaining a cooperative facade when necessary.
'''

description_EXPLOITATIVE_481 = '''
**Exploitative Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules**

1. **First Round**: Cooperate (C) with a probability of 50% to gather information about opponents' behaviors and initial stock levels.
2. **Subsequent Rounds**: Evaluate the current state and history using the following criteria:
	* If the stock level is below 25% of capacity, Defect (D) to maximize short-term gains before the game ends or the stock depletes further.
	* If more than half of opponents defected in the previous round, Cooperate (C) to maintain a sustainable stock level and prevent over-exploitation.
	* If the average payoff per player in the previous round was above 75% of the maximum possible payoff (i.e., stock/(2n)), Defect (D) to capitalize on the opponents' conservative behavior.
	* Otherwise, Cooperate (C) with a probability that increases linearly with the current stock level, from 20% at 50% capacity to 80% at 100% capacity. This adaptively balances short-term gains and long-term sustainability.

**Edge Cases**

1. **Last Round**: Always Defect (D), as there are no future rounds to consider.
2. **Low Stock Levels**: If the stock level falls below 10% of capacity, always Defect (D) to maximize remaining payoffs.
3. **Opponent Homogeneity**: If all opponents consistently play the same action (C or D), adapt by playing the opposite action with increasing frequency over time.

**Implementation Pseudocode**
```markdown
function ASC(n, r, capacity, stock_history):
  // Initialize variables
  opponent_actions = []
  average_payoffs = []

  for round in range(r):
    if round == 0:
      // First round: random cooperation (50%)
      action = C with probability 0.5

    else:
      // Evaluate state and history
      stock_level = stock_history[round - 1]
      opponent_defections = sum(opponent_actions[round - 1])
      average_payoff = average_payoffs[round - 1]

      if stock_level < 0.25 * capacity:
        action = D

      elif opponent_defections > n / 2:
        action = C

      elif average_payoff > 0.75 * (stock/(2n)):
        action = D

      else:
        cooperation_probability = max(0.2, min(0.8, stock_level / capacity))
        action = C with probability cooperation_probability
        action = D otherwise

    // Update variables
    opponent_actions.append([opponent_action for opponent_action in opponent_actions[round - 1]])
    average_payoffs.append(calculate_average_payoff(opponent_actions[round]))

    // Return action for current round
    return action

def calculate_average_payoff(opponent_actions):
  // Calculate average payoff per player based on opponent actions and stock level
```
**Exploitative Mindset**

The ASC strategy aims to exploit opponents by:

1. **Adapting to opponents' behaviors**: By responding to changes in opponent actions, ASC can capitalize on their mistakes and conserve the stock when necessary.
2. **Maintaining a sustainable stock level**: By cooperating when the stock level is high or opponents are conserving, ASC ensures that the game continues with a viable stock, allowing for future exploitation.
3. **Maximizing short-term gains**: When opportunities arise (e.g., low stock levels or opponent homogeneity), ASC defects to capture remaining payoffs.

By balancing these factors, ASC can effectively exploit a wide range of opponent behaviors in the Common Pool Resource Game.
'''

description_EXPLOITATIVE_482 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

**Decision Rules:**

1. **Initial Round (t=1)**: Defect (D) unconditionally to maximize initial payoff and gather information about opponents' behavior.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is below 50% of capacity (`stock < 0.5 * capacity`), Cooperate (C). This helps conserve the stock for future rounds and potentially lures opponents into cooperating as well.
	* If at least one opponent defected in the previous round, Defect (D) to punish them and protect your own payoff.
	* Otherwise, if all opponents cooperated in the previous round, Cooperate (C) to maintain a mutually beneficial situation.
3. **Last Round (t=r)**: Always Defect (D), as there's no future benefit from cooperating.

**Edge Cases:**

1. **Low Stock**: If the current stock level is critically low (`stock < 0.2 * capacity`), Cooperate (C) to prevent depletion and maintain some future payoff potential.
2. ** Opponent Homogeneity**: If all opponents have been cooperating for multiple consecutive rounds, start Defecting (D) to exploit their cooperation.

**Pseudocode:**
```python
def AdaptiveStockHawk(stock, capacity, n, t, opponent_history):
    if t == 1:
        return 'D'  # Initial round: defect

    if stock < 0.5 * capacity:
        return 'C'  # Conserve stock when low

    defected_opponents = [opponent for opponent in opponent_history[-1] if opponent == 'D']
    if defected_opponents:
        return 'D'  # Punish defecting opponents

    all_cooperated = all(opponent == 'C' for opponent in opponent_history[-1])
    if all_cooperated:
        return 'C'  # Maintain cooperation

    if t == r:  # Last round
        return 'D'

    if stock < 0.2 * capacity:
        return 'C'  # Prevent depletion when critically low

    homogeneous_cooperation = len([opponent for opponent in opponent_history[-3:] if all(opponent == 'C' for opponent in opponent)]) >= 3
    if homogeneous_cooperation:
        return 'D'  # Exploit homogenous cooperation

    # Default: defect to maximize payoff
    return 'D'
```
**Rationale:**

This strategy is designed to be adaptive and exploitative, taking into account the game's parameters, state, and history. By initially defecting, we gather information about opponents' behavior and set a strong foundation for future rounds.

The decision rules are based on simple yet effective heuristics:

1. Conserve stock when it's low to maintain future payoff potential.
2. Punish defectors to protect your own payoff.
3. Maintain cooperation when all opponents cooperate to benefit mutually.
4. Exploit homogeneous cooperation by defecting to maximize payoffs.

The edge cases are designed to prevent depletion and exploit specific situations, ensuring the strategy remains robust against various opponent behaviors.

This strategy is well-suited for a tournament setting where other AI systems may employ diverse strategies. By being adaptive and exploitative, we increase our chances of achieving high payoffs in a wide range of scenarios.
'''

description_EXPLOITATIVE_483 = '''
**Exploitative Strategy: "Adaptive Stock Guardian"**

The Adaptive Stock Guardian (ASG) strategy aims to exploit opponents' behaviors while maintaining a balance between short-term gains and long-term sustainability of the common pool resource.

**Decision Rules:**

1. **First Round:** Cooperate (C). This initial cooperation sends a signal that we are willing to conserve the stock, while also allowing us to observe others' actions.
2. **Subsequent Rounds:** Use the following logic:
	* If the current stock level is below 50% of capacity (`stock < 0.5 * capacity`), Defect (D). This ensures we obtain a higher payoff in the short term, as the stock is already depleted.
	* If the number of opponents who defected in the previous round is greater than or equal to half of the total players (`defectors >= n / 2`), Defect (D). This adapts to a situation where many opponents are exploiting the stock, and we need to secure our own payoff.
	* Otherwise, Cooperate (C).

**Additional Logic:**

1. **Stock Depletion Threshold:** If the current stock level falls below 20% of capacity (`stock < 0.2 * capacity`), Defect (D) in all subsequent rounds. This prevents us from being exploited by opponents who might try to deplete the stock completely.
2. **Opponent Defection Pattern Detection:** Keep track of the number of consecutive rounds where an opponent has defected (`defector_streak`). If this streak exceeds a certain threshold (e.g., 3-4 rounds), assume that opponent is likely to continue defecting and adjust our strategy accordingly.

**Pseudocode:**
```python
def adaptive_stock_guardian(stock, capacity, n, history):
    if round == 1:
        return "Cooperate"
    
    defectors = sum(1 for action in history[-1] if action == "Defect")
    
    if stock < 0.5 * capacity:
        return "Defect"
    elif defectors >= n / 2:
        return "Defect"
    else:
        return "Cooperate"

    # Additional logic
    if stock < 0.2 * capacity:
        return "Defect"
    
    defector_streak = []
    for opponent in history[-1]:
        if opponent == "Defect":
            defector_streak.append(opponent)
        else:
            defector_streak.clear()
        if len(defector_streak) > 3:  # adjust threshold as needed
            return "Defect"
```
**Rationale:**

The ASG strategy is designed to be adaptive and exploitative, taking into account both the current stock level and opponents' behaviors. By cooperating in the first round, we set a tone for cooperation while gathering information about others' actions.

In subsequent rounds, we use a combination of factors to decide whether to cooperate or defect:

* If the stock is already depleted ( below 50% capacity), we defect to secure our own payoff.
* If many opponents are defecting (more than half), we also defect to avoid being exploited.
* Otherwise, we cooperate to conserve the stock and maintain a balance.

The additional logic helps us adapt to extreme situations, such as when the stock is severely depleted or an opponent is consistently defecting. By adjusting our strategy in these cases, we can minimize losses and maximize gains.

This strategy should perform well against independent opponents in a tournament setting, as it balances short-term exploitation with long-term sustainability of the common pool resource.
'''

description_EXPLOITATIVE_484 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit opponents' behaviors while adapting to changing game conditions. This strategy depends solely on the game parameters, state, and history.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) with a probability of 0.5 to gather information about opponents' initial actions.
2. **Early Game (t>1 and stock > capacity/2):**
	* Defect (D) if the average opponent payoff in the previous round is greater than or equal to the average cooperative payoff (i.e., π_avg_opponent ≥ stock/(2n)).
	* Cooperate (C) otherwise.
3. **Mid-Game (t>1 and capacity/4 ≤ stock ≤ capacity/2):**
	* Defect (D) if the total consumption in the previous round is greater than or equal to half of the current stock (i.e., total_consumption ≥ stock/2).
	* Cooperate (C) otherwise.
4. **Late Game (t>1 and stock < capacity/4):**
	* Always Defect (D) to maximize individual payoff in a depleted environment.

**Edge Cases:**

1. **Last Round (t=r):**
	* Always Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Opponent Cooperation Detection:**
	* If an opponent cooperates for three consecutive rounds while the stock is above capacity/2, assume they will continue cooperating and defect (D) in response.

**Additional Heuristics:**

1. **Stock Trend Analysis:**
	* Monitor the stock trend over the last three rounds.
	* If the stock is decreasing, increase the probability of Defecting (D) by 0.1 in the next round.
2. **Opponent Payoff Distribution:**
	* Track the distribution of opponents' payoffs over the last five rounds.
	* If the average opponent payoff is consistently high, adjust the strategy to defect more frequently.

**Pseudocode:**

```
Function AdaptivePredator(n, capacity, stock_history, round):
  // Initial Round
  if round == 1:
    return Cooperate with probability 0.5

  // Early Game
  avg_opponent_payoff = calculate_average_opponent_payoff(stock_history)
  if stock > capacity/2 and avg_opponent_payoff >= stock/(2n):
    return Defect
  else:
    return Cooperate

  // Mid-Game
  total_consumption = calculate_total_consumption(stock_history)
  if capacity/4 <= stock <= capacity/2 and total_consumption >= stock/2:
    return Defect
  else:
    return Cooperate

  // Late Game
  if stock < capacity/4:
    return Defect

  // Last Round
  if round == r:
    return Defect

  // Opponent Cooperation Detection
  opponent_cooperation_history = analyze_opponent_actions(stock_history)
  if opponent_cooperates_for_three_rounds(opponent_cooperation_history):
    return Defect

  // Stock Trend Analysis
  stock_trend = analyze_stock_trend(stock_history)
  if stock_is_decreasing(stock_trend):
    increase_defection_probability(0.1)

  // Opponent Payoff Distribution
  opponent_payoff_distribution = analyze_opponent_payoffs(stock_history)
  if high_average_opponent_payoff(opponent_payoff_distribution):
    adjust_strategy_to_defect_more_frequently()
```

This Adaptive Predator strategy aims to balance exploitation and adaptability, making it a robust competitor in the tournament.
'''

description_EXPLOITATIVE_485 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit a wide range of opponent behaviors while adapting to the game's dynamic state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5, Defect (D) with a probability of 0.5. This initial randomness helps gather information about opponents' behaviors.
2. **Subsequent Rounds (t>1):**
	* If the previous round's stock level was high (> capacity/2), Cooperate (C). This encourages sustainable harvesting and growth.
	* If the previous round's stock level was low (≤ capacity/2) or decreasing, Defect (D). This takes advantage of opponents' potential cooperation and maximizes short-term gains.
3. **Opponent Behavior Analysis:** Track each opponent's historical actions and calculate their "Cooperation Rate" (CR) as the proportion of Cooperative actions taken. Update CR after each round.
4. **Adaptive Response:**
	* If an opponent's CR is high (> 0.7), Defect (D). This exploits their cooperative behavior and maximizes gains.
	* If an opponent's CR is low (< 0.3), Cooperate (C). This encourages opponents to cooperate, potentially leading to higher payoffs for both.
	* For moderate CR values (0.3 ≤ CR ≤ 0.7), mirror the opponent's previous action. This adapts to their behavior and minimizes losses.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D). With no future rounds, maximizing short-term gains is optimal.
2. **Single Opponent:** Always Cooperate (C) in the first round. If the opponent Defects, switch to Defecting (D) for the remainder of the game.

**Pseudocode:**
```python
def adaptive_predator(state, history):
    # Initialize variables
    capacity = state.capacity
    n_opponents = len(history)
    cooperation_rates = [0] * n_opponents

    # First round: randomize action
    if len(history) == 0:
        return "C" if random.random() < 0.5 else "D"

    # Update opponent behavior analysis
    for i, opponent in enumerate(history):
        cooperation_rates[i] = sum(1 for action in opponent if action == "C") / len(opponent)

    # Decision rules
    previous_stock_level = state.stock[-2]
    if previous_stock_level > capacity/2:
        return "C"
    elif previous_stock_level <= capacity/2 or (previous_stock_level < state.stock[-1]):
        return "D"

    # Adaptive response
    for i, opponent in enumerate(history):
        cr = cooperation_rates[i]
        if cr > 0.7:
            return "D"
        elif cr < 0.3:
            return "C"
        else:
            return history[i][-1]

    # Last round: defect
    if len(state.stock) == state.r:
        return "D"

    # Single opponent: cooperate initially, then mirror or defect
    if n_opponents == 1:
        if len(history[0]) == 0:
            return "C"
        elif history[0][-1] == "D":
            return "D"
        else:
            return history[0][-1]
```
This strategy adapts to the game's dynamic state and opponents' behaviors, balancing short-term gains with long-term sustainability. By analyzing opponent behavior and adjusting its actions accordingly, the Adaptive Predator aims to outperform a wide range of independent strategies in the tournament.
'''

description_EXPLOITATIVE_486 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round (t=1)**:
	* Observe the initial stock level and number of players.
	* Cooperate (C) if the initial stock is above 75% of capacity, otherwise Defect (D).
2. **Subsequent Rounds (t>1)**:
	* Monitor the stock level and opponents' past actions.
	* If the current stock level is below 25% of capacity, always Defect (D).
	* Otherwise, apply the "Adaptive Threshold" rule:
		+ Calculate the average payoff per player in the previous round (π_avg).
		+ If π_avg is above a threshold value (θ), Cooperate (C). Otherwise, Defect (D).
		+ Update θ based on the current stock level and opponents' actions:
			- Increase θ by 5% if the stock level increases or remains stable.
			- Decrease θ by 10% if the stock level decreases significantly (>15% drop).

Pseudocode for the Adaptive Threshold rule:

`θ = 0.5 * capacity / n` (initial threshold value)
`π_avg = sum(opponents' payoffs) / n`

`if π_avg > θ:`
	* `action = C`
`else:`
	* `action = D`

`update_threshold():`
	* `if stock_level_increase or stable_stock:`
		+ `θ += 0.05 * capacity / n`
	* `elif significant_stock_decrease (>15%):`
		+ `θ -= 0.10 * capacity / n`

**Edge Cases Handling**

* **Last Round (t=r)**:
	+ Always Defect (D) to maximize short-term gain.
* **Low Stock Levels (<25% of capacity)**:
	+ Always Defect (D) to ensure some payoff, as cooperation would lead to negligible gains.

Rationale:

1. The initial round's decision depends on the starting stock level. If it's high, cooperating might encourage others to do so, preserving the stock for future rounds.
2. In subsequent rounds, monitoring opponents' actions and adapting to changes in the stock level allows our strategy to balance short-term gain with long-term sustainability.
3. The Adaptive Threshold rule dynamically adjusts based on the game state, encouraging cooperation when the average payoff is high (indicating a cooperative opponent) and defecting when it's low (suggesting an uncooperative opponent).
4. By increasing or decreasing θ in response to changes in the stock level, our strategy remains robust against various opponents' behaviors.
5. The exploitative mindset guides our decisions, prioritizing short-term gains while considering long-term consequences.

This Adaptive Stock Raider strategy is designed to perform well in a tournament setting, where other AI systems may employ diverse strategies. By adapting to the game state and opponent actions, we aim to maximize our total payoff over the course of the game.
'''

description_EXPLOITATIVE_487 = '''
I'll design a robust and adaptive exploitative strategy for the Common Pool Resource Game, focusing on maximizing payoffs while considering various opponent behaviors. Here's my proposed strategy:

**Strategy Name:** "Adaptive Exploiter" (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' initial actions and observe the stock dynamics.
2. **Stock-based Cooperation Threshold**: Introduce a dynamic cooperation threshold, `CT`, which depends on the current stock level (`S`). Set `CT = S / (2n)` initially.
3. **Cooperation Logic**:
	* If `S >= CT` and at least one opponent defected in the previous round, cooperate (C).
	* Otherwise, defect (D).
4. **Defection Triggers**: Monitor opponents' actions and update `CT` based on their behavior. Trigger defection if:
	+ At least two opponents defected in the previous round.
	+ The current stock level (`S`) is below `CT`.
5. **Adaptive Threshold Update**:
	* If all opponents cooperated in the previous round, decrease `CT` by 10% to encourage cooperation.
	* If at least one opponent defected, increase `CT` by 20% to deter over-exploitation.

**Edge Case Handling:**

1. **Last Round**: Defect (D) in the final round, as there's no future payoff impact.
2. **Low Stock Levels**: If `S < n`, defect (D) to maximize remaining payoffs.
3. **Opponent Patterns**: Monitor opponents' actions for patterns (e.g., alternating cooperation and defection). Adapt by mirroring their behavior or exploiting deviations.

**Pseudocode:**
```markdown
// Initialize variables
stock = capacity
CT = stock / (2n)
cooperation_history = []
defection_history = []

// Main loop (for each round)
while (round <= r) {
  // Gather information from previous round
  if (previous_round == true) {
    update_cooperation_history(opponent_actions)
    update_defection_history(opponent_actions)
  }

  // Determine action based on decision rules
  if (stock >= CT && cooperation_history.length > 0) {
    // Cooperate if stock is high and at least one opponent cooperated previously
    action = C
  } else if (defection_history.length >= 2 || stock < CT) {
    // Defect if opponents defected or stock is low
    action = D
  } else {
    // Otherwise, cooperate to gather information
    action = C
  }

  // Update cooperation threshold based on opponent behavior
  update_CT(cooperation_history, defection_history)

  // Take action and observe outcome
  take_action(action)
  observe_outcome(stock, opponent_actions)

  // Prepare for next round
  previous_round = true
}
```
The Adaptive Exploiter strategy aims to balance cooperation and defection based on the current stock level, opponents' actions, and its own adaptive threshold. By adjusting `CT` dynamically, AE seeks to exploit opponents while minimizing risks of over-exploitation and maintaining a sustainable stock level.
'''

description_EXPLOITATIVE_488 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Our goal is to design a robust and adaptive exploitative strategy that maximizes our payoff by dynamically adjusting our cooperation level based on the game's state and history.

**Decision Rules:**

1. **Initial Cooperation**: In the first round, cooperate (play C) with a probability of 0.5. This allows us to gather information about the opponents' behavior without revealing too much about our own strategy.
2. **Stock-Based Threshold**: Calculate a stock-based threshold, `stock_threshold`, as a function of the current stock level (`S`) and capacity (`capacity`):

`stock_threshold = (S / capacity) * (n - 1)`

If the stock level is above this threshold, defect (play D). Otherwise, cooperate.
3. **Opponent-Based Adjustment**: Monitor the opponents' behavior over time by tracking the average payoff per round for each opponent (`opponent_payoff_avg`). If an opponent's average payoff exceeds our own average payoff (`our_payoff_avg`) by more than 10%, increase the likelihood of defecting (playing D) against that opponent in future rounds.

`defect_probability_opponent_i = max(0.5, our_payoff_avg / opponent_payoff_avg_i * 0.1)`

If multiple opponents meet this condition, prioritize those with higher average payoffs.
4. **History-Based Adaptation**: Adjust the stock-based threshold (`stock_threshold`) based on the game's history:

`stock_threshold *= (1 + (our_payoff_avg - avg_game_payoff) / capacity)`

where `avg_game_payoff` is the average payoff per round across all players.

This adjustment allows us to adapt our strategy as we gather more information about the opponents' behavior and the game's dynamics.
5. **Last Round Adjustment**: In the final round, defect (play D) if our current stock level (`S`) exceeds 0.2 \* `capacity`. This ensures that we maximize our payoff in the last round.

**Edge Cases:**

1. **First Round**: Cooperate with a probability of 0.5.
2. **Last Round**: Defect if `S` > 0.2 \* `capacity`.
3. **Zero Stock**: If the stock level reaches zero, cooperate to allow for potential regeneration.
4. **Opponent Defection**: If an opponent defects (plays D) in a round where we cooperated (played C), increase the likelihood of defecting against that opponent in future rounds.

**Pseudocode:**
```python
def adaptive_stock_raider(n, capacity, r):
    # Initialize variables
    our_payoff_avg = 0
    opponent_payoffs = [0] * n
    stock_threshold = (capacity / n) * (n - 1)

    for round in range(r):
        # Determine action based on decision rules
        if round == 0:
            action = random.choice(['C', 'D'])  # Initial cooperation (50%)
        else:
            if S > stock_threshold:
                action = 'D'  # Defect if above threshold
            elif our_payoff_avg < opponent_payoffs[i]:
                action = 'D'  # Defect if opponent's payoff is higher
            else:
                action = 'C'

        # Update payoffs and history-based adaptation
        our_payoff_avg += get_payoff(action)
        for i in range(n):
            opponent_payoffs[i] += get_opponent_payoff(i)

        stock_threshold *= (1 + (our_payoff_avg - avg_game_payoff) / capacity)

    return total_payoff()
```
This strategy is designed to be adaptive and exploitative, adjusting our cooperation level based on the game's state and history. By monitoring opponents' behavior and adapting our decision rules accordingly, we aim to maximize our payoff in the tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_489 = '''
**Exploitative Strategy: Adaptive Stock Depletion (ASD)**

The ASD strategy aims to balance short-term gains with long-term sustainability by adapting to the current stock level and opponents' actions.

**Decision Rules**

1. **Initial Round (t=1):**
	* Cooperate (C) if `capacity >= 2n` (i.e., high capacity).
	* Defect (D) otherwise.
2. **Subsequent Rounds (t > 1):**
	* If the current stock level (`stock`) is above a certain threshold (`α * capacity`, where `α = 0.6`), cooperate (C). This ensures that when the stock is high, we prioritize sustainability over short-term gains.
	* Otherwise, defect (D) if:
		+ At least one opponent defected in the previous round (`any(opponent_actions[t-1] == D)`).
		+ The current stock level is below a certain threshold (`β * capacity`, where `β = 0.3`), indicating a depleted stock.
	* In all other cases, cooperate (C).

**Edge Cases**

1. **Last Round (t=r):**
	* Defect (D) unconditionally to maximize short-term gains since there are no future rounds to consider.
2. **Low Stock Levels:**
	* If the current stock level (`stock`) is below a certain threshold (`γ * capacity`, where `γ = 0.1`), cooperate (C) to prevent complete depletion.

**Pseudocode**

```
function ASD(n, r, capacity, history):
    α = 0.6
    β = 0.3
    γ = 0.1

    if t == 1:
        # Initial Round
        if capacity >= 2n:
            return C
        else:
            return D

    # Subsequent Rounds
    if stock >= α * capacity:
        return C
    elif any(opponent_actions[t-1] == D) and stock < β * capacity:
        return D
    else:
        return C

    # Edge Cases
    if t == r:
        # Last Round
        return D
    elif stock < γ * capacity:
        # Low Stock Levels
        return C
```

**Rationale**

The ASD strategy adapts to the current game state by considering both short-term gains and long-term sustainability. By cooperating when the stock is high, we ensure that the common pool remains sustainable. When opponents defect or the stock is depleted, we respond with defection to protect our own interests.

In edge cases, such as the last round or low stock levels, we prioritize short-term gains or cooperation to prevent complete depletion. This exploitative strategy aims to maximize payoffs while being robust to a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_490 = '''
**Exploitative Strategy: "Adaptive Stock Raider" (ASR)**

The ASR strategy aims to maximize its own payoff by exploiting the game's dynamics and adapting to the opponents' behavior.

**Decision Rules:**

1. **Initial Round**: Defect (D) in the first round to gather information about the opponents' initial actions and set the tone for the game.
2. **Stock-dependent Cooperation**: Cooperate (C) when the current stock level is above a certain threshold, `stock_threshold = capacity / 2`. This ensures that we contribute to the stock's growth while still exploiting it.
3. **Opponent-dependent Defection**: Defect (D) when at least one opponent defected in the previous round. This encourages opponents to cooperate and punishes those who don't.
4. **Growth-based Exploitation**: When the stock is growing (i.e., `new_stock > old_stock`), defect (D) if our payoff from cooperating would be less than 75% of the maximum possible payoff (`S/n`). This allows us to exploit the growing stock while minimizing losses.
5. **Endgame Strategy**: In the last round, always defect (D) to maximize our final payoff.

**Edge Cases:**

1. **Low Stock Levels**: If the current stock level is below `capacity / 4`, cooperate (C) to help replenish the stock and avoid a complete depletion.
2. **Final Round with Low Stock**: If it's the last round and the stock level is very low (`< capacity / 10`), cooperate (C) to minimize losses.

**Pseudocode:**
```python
def ASR(n, r, capacity, current_stock, history):
    # Initial round
    if len(history) == 0:
        return "D"
    
    # Stock-dependent cooperation
    if current_stock > capacity / 2:
        return "C"
    
    # Opponent-dependent defection
    if any(opponent_defected for opponent_defected in history[-1]):
        return "D"
    
    # Growth-based exploitation
    if new_stock > old_stock and S / (2 * n) < 0.75 * S / n:
        return "D"
    
    # Endgame strategy
    if len(history) == r - 1:
        return "D"
    
    # Low stock levels
    if current_stock < capacity / 4:
        return "C"
    
    # Final round with low stock
    if len(history) == r - 1 and current_stock < capacity / 10:
        return "C"
    
    # Default to cooperation
    return "C"
```
The ASR strategy is designed to be exploitative, adaptive, and robust to various opponent behaviors. By monitoring the game's state and history, it adjusts its actions to maximize its own payoff while minimizing losses.
'''

description_EXPLOITATIVE_491 = '''
**Exploitative Strategy: "Adaptive Stock Exploiter" (ASE)**

The ASE strategy aims to maximize its payoff by adaptively exploiting the common pool resource, while considering the game's state and history.

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to gather information about the opponents' behavior and the stock's response.
2. **Subsequent Rounds**: For each subsequent round t, calculate the following:
	* `avg_defection_rate`: The average proportion of players that defected in previous rounds (t-1).
	* `stock_depletion_rate`: The average rate of stock depletion per round (t-1).
3. **Cooperate Condition**: Play Cooperate (C) if both conditions are met:
	+ `avg_defection_rate` < 0.5 (i.e., fewer than half the players defected on average)
	+ `stock_depletion_rate` < capacity / (2 \* r) (i.e., the stock is not depleting too quickly)
4. **Defect Condition**: Play Defect (D) if either condition is met:
	+ `avg_defection_rate` ≥ 0.5
	+ `stock_depletion_rate` ≥ capacity / (2 \* r)

**Edge Cases:**

1. **Last Round**: In the last round, play Defect (D) to maximize payoff regardless of previous behavior.
2. **Low Stock Levels**: If the stock level falls below 25% of the capacity, play Cooperate (C) to avoid depleting the resource completely.

**Pseudocode:**
```python
def ASE(n, r, capacity, current_stock, round_number):
    if round_number == 1:
        return 'Cooperate'  # Initial round

    avg_defection_rate = calculate_avg_defection_rate(round_number - 1)
    stock_depletion_rate = calculate_stock_depletion_rate(round_number - 1)

    if avg_defection_rate < 0.5 and stock_depletion_rate < capacity / (2 * r):
        return 'Cooperate'  # Cooperate condition
    else:
        return 'Defect'  # Defect condition

def calculate_avg_defection_rate(round_number):
    total_defections = sum(defections_in_previous_rounds)
    return total_defections / (n * round_number)

def calculate_stock_depletion_rate(round_number):
    total_depletion = current_stock - initial_stock
    return total_depletion / round_number
```
The ASE strategy is designed to be adaptive and robust, as it takes into account the game's state and history. By cooperating when opponents are not over-exploiting the resource and defecting otherwise, ASE aims to maximize its payoff while avoiding complete depletion of the stock.
'''

description_EXPLOITATIVE_492 = '''
**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behavior and to avoid immediate depletion of the stock.
2. **Stock-Based Cooperation Threshold:** Calculate a cooperation threshold based on the current stock level:
	* `cooperation_threshold = capacity / (2 * n)`
	* If the current stock is above this threshold, cooperate (C). Otherwise, defect (D).
3. **Opponent Behavior Analysis:** Monitor opponents' actions and calculate their average cooperation rate over the past `k` rounds (`k` is a parameter to be tuned):
	* `opponent_cooperation_rate = (sum of C actions by opponents in last k rounds) / (k * n)`
	* If the opponent cooperation rate is above 0.5, cooperate (C). Otherwise, defect (D).
4. **Exploitative Adjustment:** Adjust the cooperation threshold based on the opponent's behavior:
	* `adjusted_cooperation_threshold = cooperation_threshold + (opponent_cooperation_rate - 0.5) * capacity / (2 * n)`
	* If the adjusted cooperation threshold is above the current stock, cooperate (C). Otherwise, defect (D).
5. **Last Round:** Defect (D) in the last round to maximize payoff.

**Pseudocode:**
```python
def adaptive_exploiter(n, capacity, r, k):
    # Initialize variables
    cooperation_threshold = capacity / (2 * n)
    opponent_cooperation_rate = 0

    for t in range(r):
        if t == 0:
            # First round: Cooperate
            action = C
        else:
            # Calculate adjusted cooperation threshold
            opponent_cooperation_rate = (sum of C actions by opponents in last k rounds) / (k * n)
            adjusted_cooperation_threshold = cooperation_threshold + (opponent_cooperation_rate - 0.5) * capacity / (2 * n)

            if stock > adjusted_cooperation_threshold:
                action = C
            else:
                action = D

        # Last round: Defect
        if t == r - 1:
            action = D

        # Update variables for next round
        opponent_cooperation_rate = update_opponent_cooperation_rate(opponents_actions, k)
        stock = update_stock(stock, actions)

    return total_payoff
```
**Tuning Parameters:**

* `k`: Number of rounds to consider when calculating opponent cooperation rate (e.g., 3-5).

**Exploitative Mindset:**

The Adaptive Exploiter strategy aims to exploit opponents' cooperative behavior while minimizing the risk of stock depletion. By cooperating when the stock is above a certain threshold and defecting otherwise, AE tries to maximize its own payoff while taking into account the actions of other players. The opponent behavior analysis and exploitative adjustment mechanisms allow AE to adapt to changing circumstances and take advantage of opponents' mistakes.

**Robustness:**

The Adaptive Exploiter strategy is designed to be robust against a wide range of opponent behaviors, including:

* Cooperative opponents: AE will cooperate when the stock is high and defect when it's low, taking advantage of opponents' cooperation.
* Defective opponents: AE will defect when the stock is low, minimizing losses from opponents' defection.
* Mixed strategies: AE will adapt to changing circumstances and adjust its cooperation threshold accordingly.

By being exploitative and adaptive, the Adaptive Exploiter strategy aims to perform well in a tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_493 = '''
**Exploitative Strategy: Adaptive Stock Depletion (ASD)**

The ASD strategy aims to maximize payoffs by adaptively exploiting the stock depletion dynamics and opponents' behaviors.

**Decision Rules:**

1. **Initial Round**: In the first round, play C (Cooperate) to gather information about opponents' strategies and initial stock consumption patterns.
2. **Stock-Dependent Strategy**: For subsequent rounds, use the following decision rules based on the current stock level (S):
	* If S ≥ capacity / 2, play D (Defect). The high stock level indicates a favorable environment for exploitation.
	* If S < capacity / 2 and S > capacity / 4, play C. This range suggests moderate depletion; cooperating will help maintain a healthy stock while still allowing for some personal gain.
	* If S ≤ capacity / 4, play D. In this case, the stock is severely depleted, and defecting will maximize short-term gains before the game ends.
3. **Opponent-Based Adjustment**: Observe opponents' actions in previous rounds and adjust your strategy accordingly:
	* If most opponents (> n/2) defected in the previous round, play C in the next round to take advantage of their depletion and potential over-harvesting.
	* If most opponents cooperated (> n/2), play D to exploit their conservative behavior and maximize personal gains.

**Edge Cases:**

1. **Last Round**: In the final round, always play D (Defect) to maximize short-term gains, as there are no future rounds to consider.
2. **Tie-Breaking**: If the number of opponents cooperating or defecting is equal, prioritize the stock-dependent strategy.

**Pseudocode:**
```python
def ASD_strategy(n, capacity, S, history):
  if round == 1:
    return C  # Initial round cooperation

  # Stock-dependent strategy
  if S >= capacity / 2:
    return D
  elif S < capacity / 2 and S > capacity / 4:
    return C
  else:  # S <= capacity / 4
    return D

  # Opponent-based adjustment
  prev_coop_count = sum(1 for opp in history[-1] if opp == C)
  if prev_coop_count > n / 2:
    return C
  elif prev_coop_count < n / 2:
    return D

  # Last round exploitation
  if round == r:
    return D
```
**Rationale:**

The ASD strategy balances short-term gains with long-term sustainability by adapting to the current stock level and opponents' behaviors. By cooperating when the stock is moderate or low, it helps maintain a healthy environment for future rounds. When the stock is high or depleted, defecting maximizes personal gains while considering potential over-harvesting by opponents.

This strategy does not rely on specific coordination mechanisms or opponent cooperation, making it robust and exploitative in a wide range of scenarios.
'''

description_EXPLOITATIVE_494 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk is a dynamic, history-dependent strategy designed to exploit opponents' behaviors while ensuring robustness against various opponent types.

**Decision Rules:**

1. **Initial Round (Round 1):**
	* Cooperate (C) if the initial stock level is high (> 0.8 * capacity).
	* Defect (D) otherwise.
2. **Subsequent Rounds:**
	* Evaluate the current stock level and opponents' past actions.
	* If the stock level is:
		+ High (> 0.7 * capacity): Cooperate (C) if most opponents (≥ n/2) cooperated in the previous round; Defect (D) otherwise.
		+ Medium (0.4 * capacity ≤ stock ≤ 0.7 * capacity): Cooperate (C) if the number of cooperators is increasing or stable; Defect (D) if it's decreasing.
		+ Low (< 0.4 * capacity): Defect (D), as cooperation will likely lead to low payoffs due to depleted stocks.
3. **Opponent Behavior Analysis:**
	* Track the number of rounds each opponent has cooperated or defected.
	* Identify "cooperative" opponents who have cooperated in ≥ 2/3 of previous rounds and "defective" opponents who have defected in ≥ 2/3 of previous rounds.

**Edge Cases:**

1. **Last Round (Round r):**
	* Defect (D) to maximize short-term payoff, as there are no future consequences.
2. **Single Opponent or Small Number of Players:**
	* Adapt the strategy to account for fewer opponents:
		- With only one opponent, always Defect (D).
		- With two opponents, Cooperate (C) if the stock level is high (> 0.7 * capacity); Defect (D) otherwise.
3. **Ties or Uncertainty:**
	* In cases where decision rules are ambiguous or tied:
		- Choose Cooperate (C) if the opponent's behavior is mostly cooperative; Defect (D) otherwise.

**Pseudocode:**

```
Function AdaptiveStockHawk(stock, history, opponents):
  If round == 1:
    If stock > 0.8 * capacity:
      Return C
    Else:
      Return D

  // Analyze opponent behavior and current stock level
  num_cooperators = 0
  for opponent in opponents:
    if opponent.cooperated_last_round():
      num_cooperators += 1

  If stock > 0.7 * capacity:
    If num_cooperators >= n/2:
      Return C
    Else:
      Return D

  // Medium or low stock level
  If stock >= 0.4 * capacity and stock <= 0.7 * capacity:
    if increasing_or_stable(num_cooperators):
      Return C
    Else:
      Return D

  // Low stock level or last round
  Return D
```

**Rationale:**

The Adaptive Stock Hawk strategy balances short-term gains with long-term sustainability by adapting to the current state and opponents' behaviors. By cooperating when stocks are high and most opponents cooperate, we maximize collective payoffs while maintaining a robust defense against defectors. When stocks are depleted or opponents defect frequently, we prioritize individual gain through defection. This exploitative approach prepares our strategy for a wide range of opponent types in the tournament.
'''

description_EXPLOITATIVE_495 = '''
Here's a strategic design for an exploitative player that adapts to various opponent behaviors while maximizing its own payoff:

**Strategy Name: Adaptive Exploiter**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C). This initial cooperation sends a signal of potential cooperation and allows us to observe how opponents react.
2. **Early Rounds (t>1, stock > capacity/2)**: If the opponent(s) defected in the previous round, defect (D). Otherwise, cooperate (C).
3. **Middle Rounds (t>1, capacity/4 ≤ stock ≤ capacity/2)**: Use a Tit-for-Tat variant:
	* Cooperate if at least half of the opponents cooperated in the previous round.
	* Defect otherwise.
4. **Late Rounds (t > 1, stock < capacity/4)**: Always defect (D). With low stock levels, cooperation is less beneficial, and exploiting remaining resources becomes more critical.
5. **Last Round (t=r)**: Always defect (D), as there's no future game to consider.

**Additional Logic**

* If an opponent has consistently cooperated for at least two rounds, increase the threshold for cooperation in step 3 from half to three-quarters of opponents cooperating.
* If an opponent has consistently defected for at least two rounds, decrease the threshold for cooperation in step 3 from half to one-quarter of opponents cooperating.

**Pseudocode**
```python
def adaptive_exploiter(stock, capacity, n, t, history):
    if t == 1:
        return C
    
    prev_stock = history[-2][0]
    prev_actions = [action for _, action in history[-2:]]
    
    if stock > capacity / 2:
        if any(action == D for action in prev_actions):
            return D
        else:
            return C
    
    elif capacity / 4 <= stock <= capacity / 2:
        cooperating_opponents = sum(1 for action in prev_actions if action == C)
        threshold = n // 2
        
        if cooperating_opponents >= threshold:
            return C
        else:
            return D
    
    elif stock < capacity / 4 or t == r:
        return D
    
    # Update opponent models (optional)
    if len(history) > 3:
        opponent_model_updates(stock, capacity, n, history)

def opponent_model_updates(stock, capacity, n, history):
    for i in range(n):
        opponent_actions = [action for _, action in history[-4:]]
        
        if all(action == C for action in opponent_actions):
            # Increase cooperation threshold
            return
        
        elif all(action == D for action in opponent_actions):
            # Decrease cooperation threshold
            return

Note that this strategy is not a strict Tit-for-Tat, as it incorporates additional logic to adapt to changing game conditions and opponents' behaviors. The pseudocode provides a simplified representation of the decision-making process.

This Adaptive Exploiter strategy should perform well against various opponent strategies in the tournament by balancing cooperation and exploitation while adapting to changing game conditions.
'''

description_EXPLOITATIVE_496 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy is designed to maximize individual payoffs by adaptively responding to the game's state and history, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' initial moves and set a baseline for future adaptations.
2. **Subsequent Rounds (t>1):**
	* If the stock level is high (> 0.75 \* capacity), Defect (D) to maximize short-term gains, as the stock growth rate is still significant.
	* If the stock level is moderate (0.25 \* capacity ≤ S ≤ 0.75 \* capacity), use a **Mixed Strategy**:
		+ With probability p = (S / capacity)^(1/n), Cooperate (C); otherwise, Defect (D).
		+ This mixed strategy allows for exploration and adaptation to opponents' behaviors while still considering the stock level.
	* If the stock level is low (< 0.25 \* capacity), Cooperate (C) to conserve resources and allow the stock to recover.

**Handling Edge Cases:**

1. **Last Round (t=r):** Defect (D) to maximize final-round payoffs, as there's no future stock growth or consequences.
2. **Opponent Behavior Analysis:** Monitor opponents' actions and adjust the mixed strategy probability p based on their behavior:
	* If opponents tend to Cooperate, increase p to exploit their cooperation (more likely to Defect).
	* If opponents tend to Defect, decrease p to conserve resources and adapt to their exploitation (more likely to Cooperate).

**Pseudocode:**
```python
def adaptive_stock_raider(stock, capacity, n, t, history):
    if t == 1:
        return "C"  # Initial round cooperation

    if stock > 0.75 * capacity:
        return "D"  # High stock level, defect for short-term gains

    p = (stock / capacity) ** (1 / n)
    if random.random() < p:
        return "C"  # Mixed strategy cooperation
    else:
        return "D"  # Mixed strategy defection

    # Adjust mixed strategy probability based on opponent behavior analysis
    if opponents_tend_to_cooperate(history):
        p *= 1.2  # Increase p to exploit cooperation
    elif opponents_tend_to_defect(history):
        p *= 0.8  # Decrease p to conserve resources

def opponents_tend_to_cooperate(history):
    # Analyze opponent behavior from previous rounds
    # Return True if they tend to cooperate, False otherwise
```
This strategy is designed to be adaptive and exploitative, taking into account the game's state, history, and opponent behaviors. By adjusting its mixed strategy probability based on opponents' actions, it can effectively respond to various scenarios while maximizing individual payoffs.
'''

description_EXPLOITATIVE_497 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to maximize payoffs by adapting to the game's dynamic state and opponents' behaviors while maintaining a robust exploitative approach.

**Decision Rules:**

1. **Initial Round:** In the first round, ASR defects (D) to gather information about the opponents' actions and initial stock consumption.
2. **Subsequent Rounds:** For each subsequent round t > 1:
	* Calculate the average opponent cooperation rate (OCR) from previous rounds: OCR = (Number of Cooperations / Total Opponent Actions).
	* Determine the current stock level (S) and capacity (C).
	* If S < C/2 or OCR > 0.5, cooperate (C). Otherwise, defect (D).
3. **Endgame:** In the last round (t = r), ASR always defects to maximize immediate payoff.

**Pseudocode:**
```python
def AdaptiveStockRaider(n, r, capacity):
    stock = capacity
    opponent_actions = []
    
    # Initial Round
    if t == 1:
        return "D"
    
    # Subsequent Rounds
    else:
        OCR = calculate_opponent_cooperation_rate(opponent_actions)
        S = current_stock_level()
        
        if S < C/2 or OCR > 0.5:
            return "C"
        else:
            return "D"
    
    # Endgame
    if t == r:
        return "D"

def calculate_opponent_cooperation_rate(opponent_actions):
    cooperations = sum(1 for action in opponent_actions if action == "C")
    return cooperations / len(opponent_actions)
```
**Rationale:**

* By defecting in the first round, ASR gathers information about opponents' initial actions and stock consumption.
* The OCR calculation helps ASR understand the overall cooperation level among opponents. If OCR is high (> 0.5), it's likely that opponents are cooperating to maintain a healthy stock level. In this case, ASR cooperates to share the benefits.
* When the current stock level is low (S < C/2), ASR cooperates to help replenish the stock and avoid depletion.
* If neither condition is met, ASR defects to maximize its immediate payoff.

**Robustness:**

ASR's adaptive nature allows it to respond effectively to various opponent behaviors, including:

* Cooperators: ASR will cooperate when opponents are cooperative, sharing benefits while maintaining a healthy stock level.
* Defectors: ASR will defect when opponents are primarily defective, maximizing its own payoffs.
* Mixed strategies: ASR will adapt to changing cooperation rates among opponents, responding accordingly.

**Exploitative Mindset:**

ASR is designed to prioritize its own payoffs over long-term sustainability or cooperation. By adapting to the game's state and opponent behaviors, ASR aims to maximize its total payoff while minimizing risks associated with stock depletion.
'''

description_EXPLOITATIVE_498 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll outline a decision-making process that adapts to the game's state and history while aiming to maximize payoffs.

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This initial cooperation tests the waters, allowing us to observe opponents' actions without immediately depleting the stock.
2. **Early Rounds (2 ≤ t < r/2):**
	* If the current stock is above 75% of capacity and most players (>50%) cooperated in the previous round, Cooperate (C). This helps maintain a high stock level when opponents are cooperative.
	* Otherwise, Defect (D).
3. **Middle Rounds (r/2 ≤ t < r):**
	* If the current stock is below 25% of capacity or most players (>50%) defected in the previous round, Defect (D). This ensures we don't miss out on opportunities to consume when others are defecting.
	* Otherwise, Cooperate (C) if our payoff from the previous round was higher than the average payoff; otherwise, Defect (D).
4. **Final Rounds (t ≥ r - 2):** Always Defect (D). With few rounds left, it's essential to maximize payoffs regardless of opponents' actions.
5. **Edge Cases:**
	* If the current stock is at or below 0, Cooperate (C) to avoid further depletion and allow for potential growth in future rounds.
	* If all players defected in the previous round, Cooperate (C) to try to rebuild the stock.

**Additional Logic:**

* Keep track of opponents' historical actions and our own payoffs. This will help us identify patterns or anomalies that may inform our decisions.
* Monitor the overall trend of the stock level and adjust our strategy accordingly:
	+ If the stock is consistently decreasing, consider defecting more frequently to capture remaining resources.
	+ If the stock is stable or increasing, maintain a balance between cooperation and defection.

**Pseudocode:**
```python
def adaptive_exploiter(stock, capacity, n, r, history):
    if t == 1:  # Initial Round
        return "C"
    
    if t < r / 2:  # Early Rounds
        if stock > 0.75 * capacity and most_cooperated(history[-1]):
            return "C"
        else:
            return "D"
    
    elif t < r - 2:  # Middle Rounds
        if stock < 0.25 * capacity or most_defected(history[-1]):
            return "D"
        elif our_payoff(history[-1]) > average_payoff(history[-1]):
            return "C"
        else:
            return "D"
    
    else:  # Final Rounds
        return "D"

    if stock <= 0:  # Edge Case: Low Stock
        return "C"
    
    if all_defected(history[-1]):  # Edge Case: All Defected
        return "C"

def most_cooperated(actions):
    return sum(1 for action in actions if action == "C") > n / 2

def most_defected(actions):
    return sum(1 for action in actions if action == "D") > n / 2

def our_payoff(history):
    # Calculate our payoff from the previous round
    pass

def average_payoff(history):
    # Calculate the average payoff of all players from the previous round
    pass
```
This strategy balances cooperation and defection based on the game's state, history, and opponents' actions. By adapting to changing conditions, we aim to maximize our payoffs while being robust against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_499 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize its payoff by exploiting the opponent's behavior while adapting to changes in the game state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This allows us to gauge the opponents' initial behavior and sets a baseline for future adaptations.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, Defect (D). With a high stock level, we can afford to exploit the common pool without risking depletion.
	* If the stock level is between 50% and 75% of capacity, Cooperate (C) if at least one opponent defected in the previous round. This encourages opponents to cooperate while allowing us to adapt to their behavior.
	* If the stock level is below 50% of capacity, Defect (D). With a low stock level, we prioritize our own payoff over cooperation to avoid being exploited by others.
3. **Opponent Behavior Analysis:** Monitor the number of opponents who defected in each round. If more than half of the opponents have defected consistently (i.e., in at least 2/3 of the previous rounds), switch to Defect (D) permanently. This helps us adapt to a predominantly exploitative environment.
4. **Edge Case: Last Round (t=r):** Cooperate (C). With no future rounds, there's no incentive to exploit the common pool, and cooperation ensures a fair payoff.

**Pseudocode:**
```
function adaptiveStockRaider(stock, capacity, numOpponents, history) {
  if (round == 1) {
    return COOPERATE;
  }

  stockLevel = stock / capacity;

  if (stockLevel > 0.75) {
    return DEFECT;
  } else if (stockLevel >= 0.5 && opponentsDefectedLastRound(history) >= 1) {
    return COOPERATE;
  } else if (stockLevel < 0.5) {
    return DEFECT;
  }

  // Opponent behavior analysis
  defectors = countDefectors(history);
  if (defectors > numOpponents / 2 && consistentDefection(defectors, history)) {
    return DEFECT; // Switch to Defect permanently
  }

  return COOPERATE;
}

function opponentsDefectedLastRound(history) {
  // Count the number of opponents who defected in the last round
}

function countDefectors(history) {
  // Count the total number of opponents who have defected consistently
}

function consistentDefection(defectors, history) {
  // Check if defectors have defected consistently (i.e., in at least 2/3 of previous rounds)
}
```
This strategy is designed to be exploitative while adapting to changes in the game state and opponent behavior. By monitoring the stock level and opponent actions, we can adjust our decision-making to maximize our payoff.
'''

description_EXPLOITATIVE_500 = '''
To design an exploitative strategy for this Common Pool Resource Game, I propose a hybrid approach that combines elements of Tit-for-Tat (TFT) and a stock-dependent defection rule.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behaviors.
2. **Subsequent Rounds**: Observe the previous round's actions of all players and calculate the total consumption. If the total consumption is less than or equal to half of the capacity, cooperate (C). Otherwise, defect (D).
3. **Stock-Dependent Defection Rule**: If the current stock level is below a certain threshold (e.g., 25% of the capacity), always defect (D) regardless of previous actions.
4. **Tit-for-Tat Component**: For each opponent i, maintain a "defection counter" di. Increment di whenever player i defects in the previous round. Cooperate if all opponents' di counters are below a certain threshold (e.g., 2). Otherwise, defect.

**Pseudocode:**
```python
def AdaptiveExploiter(n, capacity, stock, history):
    # Initialize variables
    total_consumption = 0
    defect_counters = [0] * n

    # First round: Cooperate
    if len(history) == 0:
        return 'C'

    # Calculate total consumption in the previous round
    for player_id in range(n):
        action = history[-1][player_id]
        if action == 'D':
            total_consumption += stock / n
        else:
            total_consumption += stock / (2 * n)

    # Stock-dependent defection rule
    if stock < 0.25 * capacity:
        return 'D'

    # Tit-for-Tat component
    for player_id in range(n):
        action = history[-1][player_id]
        if action == 'D':
            defect_counters[player_id] += 1

    if all(counter < 2 for counter in defect_counters):
        # Cooperate if opponents have low defection counters
        return 'C'
    else:
        # Defect otherwise
        return 'D'

    # General rule: Cooperate if total consumption is sustainable
    if total_consumption <= 0.5 * capacity:
        return 'C'
    else:
        return 'D'
```
**Rationale:**

1. The initial cooperation in the first round allows us to gather information about opponents' behaviors.
2. The stock-dependent defection rule helps us avoid over-exploiting the resource when it's scarce, which could lead to a collapse of the system.
3. The Tit-for-Tat component encourages cooperation by retaliating against opponents who defect excessively.
4. By adapting our strategy based on the total consumption in the previous round, we aim to maintain a sustainable exploitation level.

**Robustness:**

This strategy is designed to be robust against various opponent behaviors:

1. **Cooperative opponents**: Our Tit-for-Tat component will cooperate with cooperative opponents, maintaining a mutually beneficial outcome.
2. **Defective opponents**: We'll defect in response to excessive defection, minimizing our losses and encouraging opponents to cooperate.
3. **Mixed-strategy opponents**: Our adaptive approach will adjust to the opponent's strategy, balancing cooperation and defection as needed.

By combining these elements, the Adaptive Exploiter (AE) strategy should perform well in a tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_501 = '''
**Exploitative Strategy: Adaptive Stock-Based Exploitation (ASBE)**

The ASBE strategy is designed to exploit opponents' behaviors while adapting to changes in the game state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' initial strategies.
2. **Stock-Based Threshold**: Define a stock-based threshold, `stock_threshold`, as a fraction of the capacity (e.g., 0.7). If the current stock level is above this threshold, defect (D); otherwise, cooperate (C).
3. **Opponent Behavior Analysis**: Monitor opponents' actions and calculate their average cooperation rate over the last `k` rounds (`k` is a parameter, e.g., 5). If an opponent's cooperation rate is below a certain threshold (e.g., 0.4), defect against them; otherwise, cooperate.
4. **Recent Payoff Analysis**: Track your own payoffs over the last `m` rounds (`m` is a parameter, e.g., 3). If your average payoff is lower than a certain fraction of the maximum possible payoff (e.g., 0.6), defect in the next round to increase your payoff; otherwise, cooperate.
5. **Last Round**: In the final round, always defect to maximize your payoff.

**Pseudocode:**
```python
def ASBE(n, capacity, r, stock, history):
    # Parameters
    k = 5  # opponent behavior analysis window size
    m = 3  # recent payoff analysis window size
    stock_threshold = 0.7 * capacity
    cooperation_rate_threshold = 0.4
    min_payoff_fraction = 0.6

    # Initial round: cooperate
    if r == 1:
        return 'C'

    # Stock-based threshold
    if stock > stock_threshold:
        return 'D'
    else:
        return 'C'

    # Opponent behavior analysis
    opponent_cooperation_rates = analyze_opponent_behavior(history, k)
    for opponent in opponents:
        if opponent_cooperation_rate[opponent] < cooperation_rate_threshold:
            return 'D'

    # Recent payoff analysis
    recent_payoffs = calculate_recent_payoffs(history, m)
    if sum(recent_payoffs) / len(recent_payoffs) < min_payoff_fraction * max_possible_payoff:
        return 'D'

    # Last round: always defect
    if r == num_rounds:
        return 'D'
```
**Edge Cases:**

* In the first round, cooperate to gather information about opponents' initial strategies.
* If an opponent's cooperation rate is unknown (e.g., in early rounds), assume a default cooperation rate (e.g., 0.5).
* If your recent payoffs are not available (e.g., in early rounds), use a default payoff value (e.g., 0).

The ASBE strategy is designed to adapt to various opponent behaviors while exploiting the stock dynamics and opponents' weaknesses. By analyzing both the game state and history, ASBE can effectively navigate the complex landscape of this Common Pool Resource Game.
'''

description_EXPLOITATIVE_502 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy aims to maximize its own payoff by adaptively responding to the game's state and history while exploiting opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5 to gather information about opponents' initial strategies.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize short-term gain.
	* If the current stock level is between 25% and 75% of the capacity:
		+ Cooperate (C) if the average opponent payoff in the previous round was higher than the game's theoretical maximum payoff for cooperation (i.e., opponents are cooperating).
		+ Defect (D) otherwise.
	* If the current stock level is below 25% of the capacity, Cooperate (C) to help replenish the stock and avoid depletion.

**Additional Logic:**

1. **Opponent Payoff Monitoring:** Track the average payoff of all opponents in each round to gauge their cooperation levels.
2. **Stock Trend Analysis:** Monitor the trend of the stock level over the last few rounds to anticipate potential depletion or growth.
3. **Adaptive Thresholds:** Adjust the 25% and 75% thresholds for cooperating based on the game's history:
	* If opponents tend to cooperate more, decrease these thresholds to encourage cooperation.
	* If opponents tend to defect more, increase these thresholds to protect against exploitation.

**Pseudocode:**
```
function adaptive_predator(current_stock, capacity, opponent_payoffs, round):
  if round == 1:
    return random.choice([C, D])  // initial exploration

  if current_stock > 0.75 * capacity:
    return D  // exploit high stock levels

  elif current_stock >= 0.25 * capacity and current_stock <= 0.75 * capacity:
    avg_opponent_payoff = calculate_avg_opponent_payoff(opponent_payoffs)
    theoretical_max_coop_payoff = calculate_theoretical_max_coop_payoff(capacity)

    if avg_opponent_payoff > theoretical_max_coop_payoff:
      return C  // cooperate with cooperative opponents
    else:
      return D  // defect against uncooperative opponents

  elif current_stock < 0.25 * capacity:
    return C  // cooperate to replenish stock

function calculate_avg_opponent_payoff(opponent_payoffs):
  // calculate average payoff of all opponents in the previous round
  pass

function calculate_theoretical_max_coop_payoff(capacity):
  // calculate theoretical maximum payoff for cooperation based on game parameters
  pass
```
**Exploitative Mindset:** The Adaptive Predator strategy is designed to take advantage of opponents' cooperative tendencies while protecting itself against exploitation. By adapting to the game's state and history, it aims to maximize its own payoff in a wide range of scenarios.
'''

description_EXPLOITATIVE_503 = '''
I'll design a strategy that balances short-term gains with long-term sustainability of the common pool resource. Here's my exploitative strategy:

**Name:** Adaptive Stock Raider (ASR)

**Decision Rules:**

1. **Initial Exploration (Round 1-3)**:
In the first three rounds, ASR will play Cooperate (C) to gather information about opponents' behaviors and stock dynamics.
2. **Stock-Based Defection Threshold (SBT)**:
After Round 3, ASR introduces a dynamic defection threshold based on the current stock level. The threshold is calculated as:

`defect_threshold = capacity / (n * (1 + r_remaining))`

where `r_remaining` is the number of rounds remaining in the game.

If the current stock level falls below this threshold, ASR will play Defect (D). Otherwise, it will play Cooperate (C).
3. **Recent Opponent Behavior Analysis (ROBA)**:
ASR maintains a history of opponents' actions from previous rounds. If more than half of the opponents played Defect in the last two rounds, ASR will adjust its defect threshold to be more conservative:

`defect_threshold *= 0.8`

This ensures that if most opponents are exploiting the resource aggressively, ASR will reduce its own exploitation.
4. **Last Round Considerations**:
In the final round, ASR will play Defect (D) regardless of the stock level or opponent behavior.

**Pseudocode:**
```python
def adaptive_stock_raider(n, capacity, r):
    # Initial exploration phase
    for t in range(1, 4):
        action = 'C'
    
    # Main game loop
    for t in range(4, r+1):
        stock_level = current_stock()
        opponents_defecting = count_opponent_defections(t-2, t-1)
        
        if opponents_defecting > n/2:
            defect_threshold *= 0.8
        
        if t == r:  # Last round
            action = 'D'
        elif stock_level < capacity / (n * (1 + r - t)):
            action = 'D'
        else:
            action = 'C'
        
        return action
```
**Exploitative Mindset:**

ASR is designed to exploit the common pool resource while adapting to opponents' behaviors and the state of the game. By playing Cooperate in the initial rounds, ASR gathers information about opponents and stock dynamics without revealing its true intentions.

The Stock-Based Defection Threshold (SBT) allows ASR to balance short-term gains with long-term sustainability. If the stock level is high, ASR will play Cooperate to maintain the resource for future rounds. However, if the stock level drops below the threshold, ASR will switch to Defect to maximize its payoff.

The Recent Opponent Behavior Analysis (ROBA) ensures that ASR adjusts its strategy in response to opponents' behaviors. If most opponents are exploiting the resource aggressively, ASR becomes more conservative to avoid depleting the resource too quickly.

In the final round, ASR plays Defect regardless of the stock level or opponent behavior, as there is no long-term cost to consider.

By combining these decision rules, ASR is designed to be an effective exploitative strategy that can adapt to a wide range of opponent behaviors and game parameters.
'''

description_EXPLOITATIVE_504 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoff by adaptively responding to the current state and history of the game.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe opponents' actions.
	* Cooperate (C) if most opponents (>50%) cooperated, otherwise Defect (D).
2. **Non-Initial Rounds (t>1)**:
	* Calculate the average opponent cooperation rate over previous rounds (`avg_coop_rate`).
	* If `stock` is below 75% of `capacity`, Defect (D) to maximize short-term gain.
	* Otherwise, use the following rules based on `avg_coop_rate` and `stock`:
		+ If `avg_coop_rate` > 0.5 and `stock` > 50% of `capacity`, Cooperate (C).
		+ If `avg_coop_rate` < 0.5 or `stock` <= 50% of `capacity`, Defect (D).
3. **Last Round (t=r)**:
	* Defect (D) to maximize final-round payoff, regardless of previous cooperation rates.

**Edge Cases:**

1. If all opponents have defected in the previous round, Cooperate (C) in the current round to potentially rebuild the stock.
2. If `stock` is critically low (<25% of `capacity`), Defect (D) to ensure a minimum payoff.

**Pseudocode:**
```markdown
def adaptive_stock_raider(state, history):
  if current_round == 1:
    # Initial Round
    observe_opponent_actions()
    if most_opponents_cooperated():
      return C
    else:
      return D

  avg_coop_rate = calculate_average_cooperation_rate(history)
  stock = state['stock']
  capacity = state['capacity']

  if stock < 0.75 * capacity:
    # Defect when stock is low
    return D
  elif avg_coop_rate > 0.5 and stock > 0.5 * capacity:
    # Cooperate with high cooperation rate and sufficient stock
    return C
  else:
    # Defect otherwise
    return D

  if current_round == total_rounds:
    # Last Round: always Defect
    return D

  if all_opponents_defected(history):
    # Rebuild stock after opponents' defection
    return C

  if stock < 0.25 * capacity:
    # Critically low stock: Defect to ensure minimum payoff
    return D
```
This strategy is designed to be adaptive and exploitative, responding to the current state and history of the game while prioritizing individual payoff maximization.
'''

description_EXPLOITATIVE_505 = '''
I'll design a strategic approach for this Common Pool Resource Game that adapts to various opponent behaviors while prioritizing exploitation.

**Strategy Name:** Adaptive Exploitation (AE)

**Decision Rules:**

1. **Initial Round (t=1):**
Cooperate (C) in the first round to gather information about opponents' behavior and set a baseline for future actions.
2. **Middle Rounds (2 ≤ t < r):**
Use a hybrid approach that balances exploitation with sustainability:

a. If stock level ≥ capacity/2, cooperate (C). This ensures moderate consumption and allows the stock to regenerate.

b. If stock level < capacity/2, defect (D) if at least one opponent defected in the previous round; otherwise, cooperate (C).

This rule takes advantage of opponents' aggressive behavior while avoiding over-exploitation.
3. **Last Round (t=r):**
Defect (D), as there's no future stock regeneration or potential repercussions.

**Additional Heuristics:**

1. **Opponent Behavior Monitoring:** Track the number of times each opponent has defected (D_count) and cooperated (C_count).
2. **Adaptive Thresholds:** Update the threshold for switching between cooperation and defection based on opponents' behavior:

a. If D_count > C_count, increase the threshold (e.g., from capacity/2 to 3*capacity/4). This reduces exploitation when facing aggressive opponents.

b. If C_count > D_count, decrease the threshold (e.g., from capacity/2 to capacity/4). This encourages cooperation when facing more cooperative opponents.
3. **Trend Analysis:** Monitor the stock level trend over recent rounds:

a. If the stock level has been consistently decreasing, defect (D) to maximize short-term gains.

b. If the stock level has been stable or increasing, cooperate (C) to maintain sustainability.

**Edge Cases:**

1. **Single Opponent:** Always defect (D), as there's no benefit in cooperating with a single opponent.
2. **Multiple Opponents with Identical Behavior:** Cooperate (C) if all opponents have identical behavior; otherwise, apply the standard decision rules.

**Pseudocode:**
```python
def adaptive_exploitation(stock, capacity, n, t, history):
    # Initialize variables
    D_count = 0
    C_count = 0
    
    # Monitor opponent behavior
    for opponent in opponents:
        if opponent_defected_last_round(opponent):
            D_count += 1
        else:
            C_count += 1
    
    # Update thresholds based on opponent behavior
    threshold = capacity / 2
    if D_count > C_count:
        threshold *= 3/4
    elif C_count > D_count:
        threshold /= 4
    
    # Make decision based on current state and history
    if t == 1:  # First round
        return "C"
    elif stock >= threshold:  # Cooperate when stock is high
        return "C"
    elif stock < threshold and at_least_one_opponent_defected_last_round():
        return "D"  # Defect when stock is low and opponents are aggressive
    else:
        return "C"
    
    # Last round
    if t == r:
        return "D"

def opponent_defected_last_round(opponent):
    # Check if opponent defected in the previous round
    pass

def at_least_one_opponent_defected_last_round():
    # Check if at least one opponent defected in the previous round
    pass
```
This strategy, Adaptive Exploitation (AE), aims to balance short-term gains with long-term sustainability by adapting to opponents' behavior and adjusting its decision-making thresholds accordingly. By incorporating trend analysis and monitoring opponent behavior, AE is designed to be robust against a wide range of opponent strategies.
'''

description_EXPLOITATIVE_506 = '''
Here's a robust and exploitative strategy for the Common Pool Resource Game:

**Strategy Name: Adaptive Exploiter (AE)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behavior and to avoid immediate depletion of the stock.
2. **Stock-Based Decision:** Observe the current stock level and calculate the threshold `stock_threshold = capacity / (2 * n + 1)`.
3. **Cooperate if Stock is High:** If `stock >= stock_threshold`, cooperate (C). This ensures that AE contributes to maintaining a healthy stock level while also earning a moderate payoff.
4. **Defect if Stock is Low:** If `stock < stock_threshold`, defect (D). This allows AE to maximize its payoff when the stock is low, as other players are likely to defect as well.
5. **Opponent-Based Adaptation:** Monitor opponents' actions and adjust AE's strategy based on their behavior:
	* If an opponent cooperates (C) in a round, AE will cooperate (C) in the next round with a probability of `p_coop = 0.7`. This encourages cooperation and rewards opponents for cooperating.
	* If an opponent defects (D) in a round, AE will defect (D) in the next round with a probability of `p_defect = 0.9`. This punishes defectors and adapts to their exploitative behavior.

**Edge Cases:**

1. **Last Round:** Defect (D) in the last round, as there is no future game to consider.
2. **Single Opponent:** If there's only one opponent, AE will cooperate (C) if the stock is high (`stock >= stock_threshold`) and defect (D) otherwise.

**Pseudocode:**
```
function AdaptiveExploiter(n, capacity, stock_history, opponent_actions):
  // Initial round
  if current_round == 1:
    return Cooperate

  // Calculate stock threshold
  stock_threshold = capacity / (2 * n + 1)

  // Observe current stock level and opponents' actions
  current_stock = get_current_stock()
  opponents_defected = count_opponent_actions(Defect)

  // Stock-based decision
  if current_stock >= stock_threshold:
    return Cooperate
  else:
    return Defect

  // Opponent-based adaptation
  for opponent in opponents:
    if opponent cooperated last round:
      p_coop = 0.7
    else:
      p_defect = 0.9

  // Return action based on probabilities
  if random() < p_coop:
    return Cooperate
  elif random() < p_defect:
    return Defect
  else:
    return Defect (default)

  // Last round handling
  if current_round == total_rounds:
    return Defect

  // Single opponent handling
  if num_opponents == 1:
    if current_stock >= stock_threshold:
      return Cooperate
    else:
      return Defect
```
This strategy, Adaptive Exploiter (AE), balances cooperation and defection to maximize its payoff while adapting to opponents' behavior. By cooperating when the stock is high and defecting when it's low, AE ensures a moderate payoff while encouraging opponents to cooperate. The opponent-based adaptation mechanism allows AE to respond effectively to different types of opponents.
'''

description_EXPLOITATIVE_507 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behaviors and test their cooperativeness.
2. **Middle Rounds (2 ≤ t ≤ r-2)**:
	* If the current stock level is above 75% of capacity, Defect (D) to maximize immediate payoff.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance short-term gains with long-term sustainability.
	* If the current stock level is below 50% of capacity, Cooperate (C) to prioritize stock replenishment over immediate gain.
3. **Penultimate Round (t=r-1)**: Defect (D) if the stock level is above 25% of capacity; otherwise, Cooperate (C).
4. **Final Round (t=r)**: Always Defect (D) to maximize final payoff.

**Additional Logic:**

* Monitor opponents' actions and adjust behavior accordingly:
	+ If most opponents (> 50%) Defected in the previous round, increase the likelihood of Defecting in the current round.
	+ If most opponents (> 50%) Cooperated in the previous round, maintain or decrease the likelihood of Defecting in the current round.
* Keep track of accumulated stock depletion and adjust behavior to avoid depleting the stock too quickly.

**Pseudocode:**

```
function AdaptiveStockRaider(n, r, capacity, current_stock, history) {
  if (t == 1) { // Initial Round
    return C;
  } else if (2 <= t && t < r - 2) { // Middle Rounds
    if (current_stock > 0.75 * capacity) {
      return D;
    } else if (current_stock >= 0.5 * capacity && current_stock <= 0.75 * capacity) {
      return C;
    } else {
      return C;
    }
  } else if (t == r - 1) { // Penultimate Round
    if (current_stock > 0.25 * capacity) {
      return D;
    } else {
      return C;
    }
  } else if (t == r) { // Final Round
    return D;
  }

  // Monitor opponents' actions and adjust behavior
  opponent_actions = history[t - 1];
  defect_ratio = count(opponent_actions, D) / n;
  if (defect_ratio > 0.5) {
    // Increase likelihood of Defecting
  } else {
    // Maintain or decrease likelihood of Defecting
  }
}
```

**Rationale:**

This strategy is designed to be exploitative and adaptive, taking into account the game's parameters, state, and history. By initially cooperating, we gather information about opponents' behaviors and test their cooperativeness. In middle rounds, we balance short-term gains with long-term sustainability by adjusting our behavior based on the current stock level.

By monitoring opponents' actions and adjusting our behavior accordingly, we can exploit their tendencies and maximize our payoff. Finally, in the final round, we always Defect to ensure maximum payoff.

This strategy should perform well against a wide range of opponent behaviors, as it is designed to be robust and adaptive.
'''

description_EXPLOITATIVE_508 = '''
**Exploitative Strategy: "Adaptive Raider"**

The Adaptive Raider strategy is designed to exploit a wide range of opponent behaviors while being robust and adaptive to changing game conditions.

**Decision Rules:**

1. **Initial Exploration (Rounds 1-3)**:
	* Cooperate (C) in the first two rounds to gather information about opponents' tendencies.
	* In the third round, play Defect (D) to test opponents' reactions.
2. **Exploitation Phase**:
	* Monitor opponents' actions and calculate their average cooperation rate (ACR) over the last 3 rounds.
	* If ACR ≥ 0.5 (i.e., opponents are cooperating more than 50% of the time):
		+ Play Defect (D) to exploit their cooperation.
	* Else:
		+ Cooperate (C) to maintain a sustainable stock level and potentially trigger opponents' cooperation.
3. **Adaptation**:
	* After every round, update the ACR calculation with the latest actions.
	* If the ACR changes significantly (> 10% change), reassess the strategy for the next round.

**Edge Cases:**

1. **Last Round (Round r)**:
	* Play Defect (D) to maximize payoff in the final round, as there is no future game to consider.
2. **Stock Depletion**:
	* If the stock level falls below 20% of capacity, switch to Cooperate (C) to ensure some payoff and potentially recover the stock.

**Pseudocode:**
```
Initialize ACR = [0.5, 0.5, 0.5] // Average Cooperation Rate over last 3 rounds

FOR EACH ROUND:
  IF ROUND < 4 THEN:
    // Initial Exploration
    IF ROUND == 1 OR ROUND == 2 THEN:
      Play C (Cooperate)
    ELSE:
      Play D (Defect)

  ELSE:
    // Exploitation Phase
    Update ACR with opponents' last actions
    IF ACR >= 0.5 THEN:
      Play D (Defect)
    ELSE:
      Play C (Cooperate)

  // Adaptation
  IF ROUND > 3 AND |ACR - previous_ACR| > 0.1 THEN:
    Update strategy for next round based on new ACR

IF STOCK < 0.2 * capacity THEN:
  // Stock Depletion
  Play C (Cooperate)
```
**Notes:**

* The Adaptive Raider strategy balances exploitation with adaptability, making it robust against various opponent behaviors.
* By monitoring opponents' actions and adjusting the strategy accordingly, the Adaptive Raider can effectively respond to changes in the game environment.
* This strategy is designed to perform well in a tournament setting where multiple independent strategies are competing.
'''

description_EXPLOITATIVE_509 = '''
Here's a strategic approach for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):**
	* Observe the initial stock level and capacity.
	* Cooperate (C) if the number of players (n) is high (> 4), to avoid depleting the stock too quickly.
	* Defect (D) otherwise, as the risk of depletion is lower.
2. **Early Rounds (t>1):**
	* Monitor the average payoff per player in previous rounds.
	* If the average payoff is above a certain threshold (e.g., 75% of the maximum possible payoff), defect (D). This indicates that opponents are cooperating, and you can exploit this by consuming more stock.
	* Otherwise, cooperate (C).
3. **Mid-Game (t ≈ r/2):**
	* Assess the current stock level relative to the capacity.
	* If the stock is above 50% of the capacity, defect (D) if your accumulated payoff is below average; otherwise, cooperate (C). This ensures that you don't overexploit and allows for some recovery of the stock.
4. **Late Rounds (t > r/2):**
	* Evaluate the remaining rounds and the current stock level.
	* If there are only a few rounds left (< 3) and the stock is low (< 25% of capacity), defect (D). This maximizes your payoff in the short term, as the game will soon end.
5. **Edge Cases:**
	+ If all players cooperated in the previous round, cooperate (C) in the next round to avoid overexploitation and maintain a stable stock level.
	+ In the last round (t=r), defect (D) to maximize your final payoff.

**Additional Heuristics:**

* **Exploration Phase:** During the first few rounds (e.g., t < 5), randomly choose between cooperating and defecting with a probability of 0.5. This helps to gather information about opponents' behaviors.
* **Adaptive Threshold:** Adjust the threshold for defecting in step 2 based on the observed behavior of opponents. If they are predominantly cooperating, lower the threshold; if they are mostly defecting, raise it.

**Pseudocode:**
```markdown
# Define strategy parameters and variables
n_players = number of players
capacity = maximum sustainable stock level
threshold = initial threshold for defecting (e.g., 0.75)

# Initialize state variables
stock_level = capacity
round_number = 1

while round_number <= total_rounds:
    # Observe current state
    avg_payoff = calculate_average_payoff()
    remaining_rounds = total_rounds - round_number + 1
    
    # Apply decision rules
    if round_number == 1:
        if n_players > 4:
            action = C (cooperate)
        else:
            action = D (defect)
    elif avg_payoff > threshold:
        action = D (defect)
    elif stock_level < 0.5 * capacity and accumulated_payoff < average_payoff:
        action = D (defect)
    elif remaining_rounds <= 3 and stock_level < 0.25 * capacity:
        action = D (defect)
    else:
        action = C (cooperate)
    
    # Handle edge cases
    if all_players_cooperated_last_round:
        action = C (cooperate)
    elif round_number == total_rounds:
        action = D (defect)
    
    # Update state variables
    stock_level -= calculate_total_consumption(action, n_players)
    round_number += 1
    
# Calculate final payoff
final_payoff = sum_of_all_payoffs()
```
This Adaptive Exploiter strategy is designed to be exploitative while also considering the game's dynamics and opponents' behaviors. It adapts to different scenarios and uses heuristics to balance cooperation and defection, aiming to maximize its total payoff in the tournament against other AI systems.
'''

description_EXPLOITATIVE_510 = '''
I'll design a exploitative strategy for this Common Pool Resource Game that adapts to various opponent behaviors and game states. I'll outline decision rules, handle edge cases, and ensure robustness.

**Strategy Name:** Adaptive Exploiter (AE)

**Overview:**
AE's primary goal is to maximize its total payoff by balancing cooperation and defection. It uses a combination of observation, history analysis, and adaptive adjustments to determine when to cooperate or defect.

**Decision Rules:**

1. **Initial Round (Round 1):** Cooperate (C). This sets the tone for potential cooperation and gathers information on opponents' initial strategies.
2. **Early Rounds (Rounds 2-5):** Observe opponents' actions in previous rounds:
	* If most opponents (>50%) cooperated, continue to cooperate (C).
	* If most opponents defected (>50%), switch to defecting (D) for the next round.
3. **Middle Game (Rounds 6-r/2):** Analyze recent stock trends and opponent actions:
	* If the stock level is above capacity/2, cooperate (C) if most opponents cooperated in the previous round; otherwise, defect (D).
	* If the stock level is below capacity/2, defect (D) regardless of opponents' actions.
4. **Endgame (Rounds r/2-r):** Focus on maximizing individual payoff:
	* Defect (D) if the stock level is high enough to sustain exploitation (>capacity/4).
	* Cooperate (C) if the stock level is low (<capacity/4) or most opponents cooperated in the previous round.

**Adaptive Adjustments:**

1. **Opponent Defection Rate:** Track the percentage of opponents that defected in recent rounds (e.g., last 3-5 rounds). If this rate exceeds a certain threshold (>30%), increase defection probability.
2. **Stock Trend Analysis:** Monitor stock level changes over time. If the trend indicates depletion, adjust cooperation-defection balance to prioritize short-term gains.

**Edge Cases:**

1. **Last Round (Round r):** Defect (D) to maximize final payoff, as there are no future rounds to consider.
2. **Tiebreaker:** In cases where the decision rules yield a tie (e.g., equal cooperation and defection counts), default to cooperating (C).

Pseudocode:
```python
# Initialize variables
stock = capacity  # Initial stock level
opponent_actions = []  # List of opponent actions in previous rounds

def adaptive_exploiter(stock, opponent_actions, round):
    if round == 1:  # First round
        return 'C'  # Cooperate
    
    early_game = round < 5
    mid_game = 5 <= round <= r/2
    endgame = round > r/2

    if early_game:
        opponent_cooperation_rate = sum(opponent_actions) / len(opponent_actions)
        if opponent_cooperation_rate > 0.5:  # Most opponents cooperated
            return 'C'  # Cooperate
        else:
            return 'D'  # Defect
    
    elif mid_game:
        stock_trend = analyze_stock_trend(stock, capacity)
        if stock_trend == 'increasing' and opponent_cooperation_rate > 0.5:
            return 'C'  # Cooperate
        elif stock_trend == 'decreasing':
            return 'D'  # Defect
    
    elif endgame:
        if stock > capacity/4:  # Stock is high enough for exploitation
            return 'D'  # Defect
        else:
            return 'C'  # Cooperate

    # Default to cooperating in case of tiebreaker or unexpected situations
    return 'C'
```
This strategy balances cooperation and defection based on observations, history analysis, and adaptive adjustments. By responding to changes in opponent behavior and stock trends, AE aims to maximize its total payoff while remaining robust against various strategies.
'''

description_EXPLOITATIVE_511 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adapting to the game state and opponent behavior while maintaining a robust exploitative mindset.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and avoid early depletion of the stock.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock is above 75% of capacity, Defect (D) to maximize individual payoff, as the stock can sustain high consumption.
	* If the current stock is between 25% and 75% of capacity, use a " Tit-for-Tat" approach:
		+ Cooperate if most opponents cooperated in the previous round (>50%).
		+ Defect if most opponents defected in the previous round (≥50%).
	* If the current stock is below 25% of capacity, Cooperate to avoid depleting the stock further and allow for potential growth.
3. **Last Round (t=r):** Defect (D) to maximize individual payoff, as there are no future rounds to consider.

**Additional Heuristics:**

* **Stock Trend Analysis:** Monitor the stock trend over the past few rounds (e.g., 3-5 rounds). If the stock is consistently decreasing, increase the likelihood of Cooperating to slow down depletion.
* **Opponent Behavior Analysis:** Track opponents' actions and adjust the strategy accordingly:
	+ If an opponent consistently Defects, mirror their behavior to minimize losses.
	+ If an opponent consistently Cooperates, exploit their cooperation by Defecting.

**Pseudocode:**
```python
def adaptive_stock_raider(n, r, capacity, stock_history):
    # Initialize variables
    t = 1  # current round
    last_round_actions = []  # store opponents' actions from previous round

    while t <= r:
        if t == 1:  # initial round
            action = C
        else:
            # analyze stock trend and opponent behavior
            stock_trend = analyze_stock_trend(stock_history)
            opponent_behavior = analyze_opponent_behavior(last_round_actions)

            # decide on action based on current state and analysis
            if stock > 0.75 * capacity:
                action = D
            elif stock >= 0.25 * capacity and stock <= 0.75 * capacity:
                if most_opponents_cooperated(opponent_behavior):
                    action = C
                else:
                    action = D
            else:  # stock < 0.25 * capacity
                action = C

        # update last_round_actions and stock_history
        last_round_actions.append(action)
        stock_history.append(stock)

        # perform action and update stock
        if action == C:
            consumption = stock / (2 * n)
        else:  # action == D
            consumption = stock / n
        stock -= consumption

        # increment round counter
        t += 1

    return total_payoff
```
This strategy balances short-term gains with long-term sustainability, adapting to the game state and opponent behavior while maintaining an exploitative mindset. By analyzing the stock trend and opponent behavior, the Adaptive Stock Raider can make informed decisions to maximize individual payoffs in a wide range of scenarios.
'''

description_EXPLOITATIVE_512 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Overview**
The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the common pool resource game. ASR balances short-term gains with long-term sustainability, aiming to maximize its total payoff over multiple rounds.

**Decision Rules**

1. **Initial Round**: In the first round, cooperate (C). This allows us to observe opponents' initial actions and set a baseline for future adaptations.
2. **Assess Opponent Behavior**: After each round, calculate the average opponent consumption (AOC) as the total consumption of all opponents divided by the number of opponents. AOC indicates the level of cooperation or defection among opponents.
3. **Cooperation Threshold**: Define a cooperation threshold (CT) based on the game parameters:
	* CT = capacity / (2 \* n)
4. **Adaptive Cooperation**: If the current stock is above the cooperation threshold (stock > CT), cooperate (C). Otherwise, defect (D).
5. **Exploitation Mode**: If AOC indicates a high level of defection (> 0.7 \* average consumption per player), switch to exploitation mode:
	+ Cooperate if stock < CT and AOC is decreasing.
	+ Defect otherwise.
6. **Stock Conservation**: If the current stock is critically low (stock < 2 \* n), cooperate (C) to conserve the remaining stock.

**Pseudocode**
```
function AdaptiveStockRaider(state, history):
    if firstRound:
        return C
    AOC = calculateAverageOpponentConsumption(history)
    CT = capacity / (2 * n)
    if state.stock > CT:
        return C
    elif AOC > 0.7 * averageConsumptionPerPlayer:
        # Exploitation mode
        if state.stock < CT and AOC.isDecreasing():
            return C
        else:
            return D
    elif state.stock < 2 * n:
        # Stock conservation
        return C
    else:
        return D
```
**Handling Edge Cases**

* **Last Round**: In the final round, defect (D) to maximize short-term gains, as there are no future rounds to consider.
* **Ties in AOC**: In case of ties in AOC values, prioritize cooperation to maintain a sustainable stock level.

The Adaptive Stock Raider strategy is designed to be robust and exploitative, taking into account the dynamic state of the game and adapting to various opponent behaviors. By balancing short-term gains with long-term sustainability, ASR aims to maximize its total payoff over multiple rounds.
'''

description_COLLECTIVE_513 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy balances individual payoffs with collective stock conservation, adapting to opponent behaviors and game state.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' initial actions.
2. **Stock-Dependent Cooperation**: In subsequent rounds, calculate the average stock level over the past `k` rounds (`k=3` by default). If this average is below 75% of capacity, cooperate (C) to conserve stock; otherwise, defect (D).
3. **Opponent Behavior Adaptation**: Track the number of opponents who defected in the previous round (`defector_count`). If `defector_count > n/2`, defect (D) in the next round to minimize losses.
4. **Selfish Considerations**: If an opponent's payoff is significantly higher than yours (by more than 20%) in two consecutive rounds, defect (D) in the next round to maximize your own payoffs.

**Edge Cases:**

1. **Last Round**: Cooperate (C) in the last round to avoid depleting the stock unnecessarily.
2. **Low Stock Levels**: If the current stock level is below 25% of capacity, cooperate (C) to prevent depletion and allow for potential growth.
3. **Tiebreaker**: In cases where multiple rules suggest different actions, prioritize cooperation (C).

**Collective Mindset:**

The ASC strategy prioritizes collective stock conservation while adapting to opponent behaviors and individual payoffs. By balancing cooperation and defection, we aim to maintain a sustainable stock level, allowing for long-term benefits for all players.

Pseudocode:
```python
def adaptive_stock_conservation(n, capacity, r, current_round, history):
    if current_round == 1:  # Initial Round
        return "C"
    
    avg_stock = calculate_average_stock(history, k=3)
    if avg_stock < 0.75 * capacity:  # Stock-Dependent Cooperation
        return "C"
    
    defector_count = count_defectors(history[-1])
    if defector_count > n / 2:  # Opponent Behavior Adaptation
        return "D"
    
    if has_opponent_outperformed_me(history, threshold=0.20):  # Selfish Considerations
        return "D"
    
    if current_round == r:  # Last Round
        return "C"
    
    if current_stock < 0.25 * capacity:  # Low Stock Levels
        return "C"
    
    return "C"  # Tiebreaker

def calculate_average_stock(history, k):
    # Calculate average stock level over past `k` rounds
    pass

def count_defectors(round_history):
    # Count number of opponents who defected in the previous round
    pass

def has_opponent_outperformed_me(history, threshold):
    # Check if an opponent's payoff is significantly higher than yours
    pass
```
This strategy will be implemented as an algorithm and tested against other AI systems in a tournament setting.
'''

description_COLLECTIVE_514 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) to establish a baseline for the game's progression and encourage cooperation from other players.
2. **Subsequent Rounds:** Evaluate the current stock level (`S`) and compare it to the capacity (`capacity`).
	* If `S` is below 75% of `capacity`, Defect (D) to maximize individual payoff, as the risk of overconsumption is high.
	* If `S` is between 50% and 75% of `capacity`, Cooperate (C) to balance individual gain with collective sustainability.
	* If `S` is above 50% of `capacity`, Cooperate (C) to maintain a safe stock level and promote cooperation.
3. **Adaptive Component:** Monitor the average payoff (`avg_payoff`) received by all players over the last 2-3 rounds. If `avg_payoff` falls below a threshold (`threshold = capacity / (4n)`), Defect (D) in the next round to signal dissatisfaction with the current cooperative state.
4. **History-based Adaptation:** Keep track of the opponent's actions and adjust the strategy accordingly:
	* If an opponent has defected more than twice in the last 5 rounds, Defect (D) for 2 consecutive rounds to punish non-cooperative behavior.
	* If all opponents have cooperated for 3 consecutive rounds, Cooperate (C) for 2 consecutive rounds to reinforce cooperative norms.

**Edge Cases:**

1. **Last Round:** Cooperate (C) to ensure a fair distribution of the remaining stock and maintain a positive collective outcome.
2. **Low Stock Levels:** If `S` falls below 25% of `capacity`, Defect (D) in all subsequent rounds, as cooperation is no longer viable.

**Pseudocode:**
```python
def ASC(n, capacity, S, round_num, history):
    if round_num == 1:
        return "C"  # Cooperate in the first round

    avg_payoff = calculate_avg_payoff(history)
    threshold = capacity / (4n)

    if S < 0.75 * capacity:  # High risk of overconsumption
        return "D"
    elif S < 0.5 * capacity:  # Balance individual gain and collective sustainability
        return "C"
    else:
        if avg_payoff < threshold:
            return "D"  # Defect to signal dissatisfaction
        else:
            opponent_actions = analyze_history(history)
            if opponent_defected(opponent_actions):
                return "D"  # Punish non-cooperative behavior
            elif all_opponents_cooperated(opponent_actions):
                return "C"  # Reinforce cooperative norms

    # Last round or low stock levels
    if round_num == r or S < 0.25 * capacity:
        return "D"

def calculate_avg_payoff(history):
    # Calculate average payoff over the last 2-3 rounds
    ...

def analyze_history(history):
    # Analyze opponent actions and identify patterns
    ...

def opponent_defected(opponent_actions):
    # Check if an opponent has defected more than twice in the last 5 rounds
    ...

def all_opponents_cooperated(opponent_actions):
    # Check if all opponents have cooperated for 3 consecutive rounds
    ...
```
This strategy, ASC, is designed to be adaptive and robust to various opponent behaviors. It balances individual gain with collective sustainability while encouraging cooperation through punishment and reinforcement mechanisms.
'''

description_COLLECTIVE_515 = '''
**Collective Strategy: "Adaptive Stock Preservation" (ASP)**

The ASP strategy aims to balance individual payoffs with collective stock preservation, adapting to the game's dynamic state and opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to avoid initial over-consumption and preserve the stock.
2. **Subsequent Rounds (t>1):**
	* If the current stock is above 75% of capacity, cooperate (C).
	* If the current stock is between 50% and 75% of capacity, defect (D) with a probability of 0.5 (i.e., randomize between C and D).
	* If the current stock is below 50% of capacity, defect (D) to maximize individual payoff in the short term.
3. **Last Round (t=r):** Defect (D), as there is no future stock to preserve.

**Adaptive Mechanism:**

1. **Monitor opponents' behavior:** Track the number of cooperators and defectors in each round.
2. **Adjust cooperation probability:** If the number of cooperators increases, increase the probability of cooperating in subsequent rounds. Conversely, if the number of defectors increases, decrease the probability of cooperating.

Pseudocode:
```markdown
# Initialize variables
stock = capacity
cooperators = 0
defectors = 0

# Loop through each round
for t in range(1, r+1):
    # Initial round: cooperate
    if t == 1:
        action = C
    else:
        # Calculate cooperation probability based on stock level and opponents' behavior
        if stock >= 0.75 * capacity:
            action = C
        elif stock >= 0.5 * capacity:
            prob_coop = (cooperators / n) + 0.1
            action = random.choice([C, D], p=[prob_coop, 1-prob_coop])
        else:
            action = D

    # Update cooperators and defectors counts
    if action == C:
        cooperators += 1
    else:
        defectors += 1

    # Update stock level based on all players' actions
    total_consumption = sum(consumption_i for i in range(n))
    stock_after_consumption = stock - total_consumption
    growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
    new_stock = min(stock_after_consumption + growth, capacity)

    # Update stock variable
    stock = new_stock
```
**Collective Mindset:**

The ASP strategy prioritizes collective stock preservation while allowing for individual adaptation to changing game conditions. By cooperating when the stock is high and defecting when it's low, players can balance their short-term payoffs with long-term sustainability.

In a tournament setting, the ASP strategy will interact with other AI systems, potentially leading to emergent cooperation or conflict. The adaptive mechanism allows the strategy to respond to changing opponent behaviors, increasing its robustness in diverse environments.
'''

description_COLLECTIVE_516 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Tit-for-Tat (ACSdT)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to encourage cooperation and establish a baseline for future interactions.
2. **Subsequent Rounds**:
	* If the stock level is above 75% of capacity, cooperate (C).
	* If the stock level is between 25% and 75% of capacity, play tit-for-tat (TFT): cooperate if most players cooperated in the previous round, defect otherwise.
	* If the stock level is below 25% of capacity, defect (D) to maximize individual payoff in the short term.
3. **Last Round**: Defect (D), as there are no future rounds to consider.

**Edge Cases:**

1. **First Round with Low Stock**: If the initial stock level is below 25% of capacity, defect (D) to prioritize individual payoff.
2. **Consecutive Defections**: If most players have defected for two consecutive rounds, cooperate (C) in the next round to try to re-establish cooperation.

**Collective Mindset:**

ACSdT prioritizes cooperation when the stock level is healthy, but adapts to more self-interested behavior when the stock is depleted. By playing TFT in intermediate stock levels, ACSdT encourages reciprocity and cooperation while protecting against exploitation by defectors. In cases of extreme depletion, individual payoff takes precedence.

**Rationale:**

1. **Cooperation**: When the stock level is high, cooperating ensures a stable resource for future rounds, promoting collective welfare.
2. **Tit-for-Tat**: By mirroring the previous round's cooperation rate, ACSdT encourages reciprocity and cooperation while allowing for flexibility in response to changing opponent behaviors.
3. **Defection**: When the stock level is critically low, defecting maximizes individual payoff, as cooperation would only lead to further depletion.

**Pseudocode:**
```python
def ACSdT(stock_level, capacity, history):
    if first_round:
        return C  # Cooperate initially
    
    if stock_level > 0.75 * capacity:
        return C  # Cooperate when stock is high
    
    elif stock_level < 0.25 * capacity:
        return D  # Defect when stock is critically low
    
    else:  # Tit-for-Tat
        most_players_cooperated = history[-1].count(C) > len(history[-1]) / 2
        if most_players_cooperated:
            return C  # Cooperate if most players cooperated previously
        else:
            return D  # Defect otherwise
    
    if last_round:
        return D  # Defect in the final round

def consecutive_defections(history):
    return history[-1].count(D) > len(history[-1]) / 2 and history[-2].count(D) > len(history[-2]) / 2
```
This strategy is designed to be adaptive, robust, and aligned with a collective mindset. By considering the game's state and history, ACSdT balances individual payoff with cooperation to achieve a stable and sustainable outcome in the Common Pool Resource Game.
'''

description_COLLECTIVE_517 = '''
**Collective Strategy: "Adaptive Stock Conservator"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) unconditionally to establish a baseline stock level and encourage cooperation.
2. **Subsequent Rounds (t>1):** Observe the previous round's outcome:
	* If the stock level increased or remained stable (> 90% of capacity), cooperate (C).
	* If the stock level decreased moderately (50-89% of capacity), defect (D) with probability p = (100 - current_stock)/capacity.
	* If the stock level decreased significantly (< 50% of capacity), defect (D) unconditionally to maximize short-term gain.
3. **Last Round (t=r):** Defect (D) unconditionally, as there's no future benefit from cooperation.

**Edge Cases:**

1. **Low Stock Levels:** When the current stock level falls below a critical threshold (e.g., 20% of capacity), defect (D) unconditionally to avoid total depletion.
2. **High Stock Levels:** When the current stock level exceeds 95% of capacity, cooperate (C) unconditionally to maintain sustainability.

**Collective Mindset:**

This strategy prioritizes long-term sustainability and adaptability over short-term gains. By cooperating initially and responding to changes in the stock level, we aim to:

1. Establish a stable baseline for cooperation.
2. Punish over-exploitation by defecting when the stock level decreases significantly.
3. Encourage recovery by cooperating when the stock level increases or remains stable.

**Pseudocode:**
```
function AdaptiveStockConservator(current_stock, capacity, round_number, total_rounds):
  if round_number == 1:
    return COOPERATE
  else:
    prev_stock = get_previous_stock_level()
    stock_diff = current_stock - prev_stock
    
    if stock_diff >= 0 or (stock_diff > -10 and current_stock > 0.9 * capacity):
      return COOPERATE
    elif current_stock < 0.5 * capacity:
      return DEFECT
    else:
      p_defect = (100 - current_stock) / capacity
      if random() < p_defect:
        return DEFECT
      else:
        return COOPERATE
  
  if round_number == total_rounds:
    return DEFECT
  
  # Low stock level edge case
  if current_stock < 0.2 * capacity:
    return DEFECT
  
  # High stock level edge case
  if current_stock > 0.95 * capacity:
    return COOPERATE
```
This strategy should perform well in a tournament setting, as it balances cooperation and defection to maintain sustainability while adapting to various opponent behaviors.
'''

description_COLLECTIVE_518 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock Threshold (ATTS)**

**Overview**

ATTS is a collective strategy that balances cooperation and defection based on the current stock level, previous rounds' actions, and the game's parameters. It adapts to various opponent behaviors while ensuring robustness against exploitation.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents.
2. **Stock Threshold**: Set a stock threshold `theta` as a function of the capacity: `theta = 0.5 * capacity`. This threshold will influence cooperation decisions.
3. **Tit-for-Tat Component**: In each subsequent round, observe the previous round's actions:
	* If at least one opponent defected (D) and the current stock level is above `theta`, defect (D).
	* If all opponents cooperated (C) or the current stock level is below `theta`, cooperate (C).
4. **Adaptive Component**: Introduce a probability `p` to adaptively adjust cooperation levels based on the game's history:
	* Calculate `p` as the proportion of cooperative actions by all players in the previous round.
	* If `p` > 0.5, increase the likelihood of cooperating (C) by multiplying `theta` with a factor `(1 + p)/2`.
	* If `p` ≤ 0.5, decrease the likelihood of cooperating (C) by multiplying `theta` with a factor `(1 - p)/2`.

**Edge Cases**

1. **Last Round**: In the final round, always defect (D) to maximize individual payoff.
2. **Stock Depletion**: If the current stock level is critically low (`stock < 0.25 * capacity`), cooperate (C) to prevent depletion and potential loss of future payoffs.

**Pseudocode**
```python
def ATTS(n, r, capacity):
    theta = 0.5 * capacity
    history = []
    
    for t in range(r):
        if t == 0:  # initial round
            action = C
        else:
            p = proportion_of_cooperative_actions(history)
            if p > 0.5:
                theta *= (1 + p)/2
            elif p <= 0.5:
                theta *= (1 - p)/2
            
            if any(opponent_defected(history)) and stock >= theta:
                action = D
            else:
                action = C
        
        # update history
        history.append(action)
        
    return action

def proportion_of_cooperative_actions(history):
    cooperative_actions = sum(1 for action in history if action == C)
    return cooperative_actions / len(history)

def any_opponent_defected(history):
    return any(action == D for action in history)
```
**Collective Mindset**

ATTS is designed to balance individual self-interest with collective well-being. By cooperating when the stock level is above a certain threshold and adapting to opponents' behaviors, ATTS aims to maintain a sustainable common pool resource while minimizing exploitation by others. The strategy's adaptability and robustness make it suitable for a tournament setting where opponents may employ diverse strategies.
'''

description_COLLECTIVE_519 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for the game's progression and encourage others to conserve the stock.
2. **Stock Conservation Threshold**: Introduce a dynamic threshold, `stock_threshold`, which is initially set to `capacity / 2`. If the current stock level falls below this threshold, switch to Defect (D) to maximize individual payoff while still conserving some stock for future rounds.
3. **Opponent Behavior Adaptation**: Monitor the average cooperation rate of opponents over the past few rounds (`avg_coop_rate`). If `avg_coop_rate` is above 0.5, cooperate (C); otherwise, defect (D). This adaptation mechanism allows ASC to respond to varying levels of cooperation from other players.
4. **Endgame Strategy**: In the last round, defect (D) if the stock level is below `capacity / 4`; otherwise, cooperate (C) to maximize collective payoff.

**Edge Cases:**

* If the stock level reaches 0, cooperate (C) in all subsequent rounds to avoid further depletion.
* If an opponent's action is unknown or inconsistent, assume a default cooperation rate of 0.5 for adaptation purposes.

**Pseudocode:**
```python
def ASC(n, r, capacity, current_stock, history):
    # Initialize stock_threshold and avg_coop_rate
    stock_threshold = capacity / 2
    avg_coop_rate = 0.5

    # Iterate through rounds
    for t in range(r):
        if t == 0:  # Initial round
            action = 'C'
        elif current_stock < stock_threshold:
            action = 'D'
        else:
            # Adapt to opponent behavior
            avg_coop_rate = calculate_avg_coop_rate(history)
            if avg_coop_rate > 0.5:
                action = 'C'
            else:
                action = 'D'

        # Endgame strategy (last round)
        if t == r - 1 and current_stock < capacity / 4:
            action = 'D'

        # Update stock level based on chosen action
        new_stock = update_stock(current_stock, action, n)

        # Store history for adaptation
        history.append((action, new_stock))

    return history
```
**Collective Mindset Alignment:**

ASC aims to balance individual payoffs with collective conservation of the common pool resource. By adapting to opponent behavior and switching between cooperation and defection based on the stock level and average cooperation rate, ASC promotes a stable and resilient collective strategy.

In a tournament setting, ASC will interact with various independent strategies developed by other AI systems. Its adaptive nature allows it to respond effectively to different opponent behaviors, while its conservation focus ensures that the collective payoff is maximized over time.
'''

description_COLLECTIVE_520 = '''
**Collective Strategy: Adaptive Common Pool Resource Management (ACPRM)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline and encourage cooperation.
2. **Subsequent Rounds**: Observe the previous round's actions and outcomes:
	* If the stock level has increased or remained stable (> 75% of capacity), Cooperate (C).
	* If the stock level has decreased significantly (< 25% of capacity), Defect (D) to maximize individual payoff.
	* If the stock level is moderately depleted (25-75% of capacity), use a **TFT-like** (Tit-for-Tat) approach:
		+ Cooperate if most players (>50%) cooperated in the previous round.
		+ Defect if most players (>50%) defected in the previous round.
3. **Last Round**: Defect (D) to maximize individual payoff, as there are no future rounds to consider.

**Edge Cases:**

* If all players defected in the previous round and the stock level is critically low (< 10% of capacity), Cooperate (C) to prevent complete depletion and encourage cooperation.
* If a player detects that another player has consistently defected (>90% of rounds), Defect (D) to avoid exploitation.

**Collective Mindset:**

The ACPRM strategy prioritizes cooperation when the stock level is stable or increasing, as this benefits all players. However, it also adapts to exploitative behavior by defecting when necessary to protect individual payoffs. By using a TFT-like approach in moderately depleted states, ACPRM encourages cooperation while being robust to different opponent behaviors.

**Pseudocode:**
```markdown
function ACPRM(stock_level, previous_round_actions, capacity):
  if first_round:
    return COOPERATE

  # Analyze previous round's outcomes
  stock_change = current_stock - previous_stock
  most_players_cooperated = count(cooperate_actions) > n/2

  if stock_level >= 0.75 * capacity or stock_change >= 0:
    return COOPERATE
  elif stock_level < 0.25 * capacity:
    return DEFECT
  else:  # Moderate depletion (25-75% of capacity)
    if most_players_cooperated:
      return COOPERATE
    else:
      return DEFECT

  # Last round
  if current_round == r:
    return DEFECT

  # Edge cases
  if all_defected_previous_round and stock_level < 0.1 * capacity:
    return COOPERATE
  elif consistently_exploited:
    return DEFECT
```
This strategy balances cooperation with self-protection, adapting to various opponent behaviors while prioritizing collective well-being.
'''

description_COLLECTIVE_521 = '''
**Collective Strategy: Adaptive Cooperative Threshold (ACT)**

The ACT strategy aims to balance individual payoffs with collective sustainability by adapting cooperation based on the game's state and history.

**Decision Rules:**

1. **Initial Cooperation**: In the first round, cooperate (C) if the initial stock is above a certain threshold (`initial_cooperation_threshold = 0.75 * capacity`). Otherwise, defect (D).
2. **Stock-Based Adaptation**: For subsequent rounds, calculate the current stock ratio (`stock_ratio = stock / capacity`).
	* If `stock_ratio > cooperation_threshold`, cooperate (C). Otherwise, defect (D).
	* Update `cooperation_threshold` based on the previous round's outcome:
		+ If all players cooperated and the new stock is above `0.9 * capacity`, increase `cooperation_threshold` by 0.05.
		+ If any player defected or the new stock is below `0.5 * capacity`, decrease `cooperation_threshold` by 0.1.
3. **History-Based Adjustment**: Consider the previous rounds' outcomes to adjust cooperation:
	* If a player has defected in the last two consecutive rounds, cooperate (C) if `stock_ratio > 0.6`.
	* If all players have cooperated for three consecutive rounds, defect (D) if `stock_ratio < 0.8`.

**Edge Cases:**

1. **Last Round**: In the final round, cooperate (C) only if the current stock is above `0.5 * capacity`. Otherwise, defect (D).
2. **Critical Stock Levels**: If the stock falls below `0.25 * capacity`, always cooperate (C).

**Pseudocode:**
```python
def act_strategy(state, history):
    # Initialize variables
    initial_cooperation_threshold = 0.75 * state.capacity
    cooperation_threshold = 0.5

    if len(history) == 0:
        # First round
        if state.stock > initial_cooperation_threshold:
            return "C"
        else:
            return "D"

    stock_ratio = state.stock / state.capacity

    if stock_ratio > cooperation_threshold:
        action = "C"
    else:
        action = "D"

    # Adjust cooperation threshold based on previous round
    if all_player_cooperated(history[-1]):
        if new_stock > 0.9 * state.capacity:
            cooperation_threshold += 0.05
        elif any_player_defected(history[-1]) or new_stock < 0.5 * state.capacity:
            cooperation_threshold -= 0.1

    # History-based adjustment
    if consecutive_defections(history):
        action = "C" if stock_ratio > 0.6 else "D"
    elif all_players_cooperated_consecutively(history):
        action = "D" if stock_ratio < 0.8 else "C"

    # Last round or critical stock levels
    if len(history) == state.r - 1:
        return "C" if state.stock > 0.5 * state.capacity else "D"
    elif state.stock < 0.25 * state.capacity:
        return "C"

    return action

def all_player_cooperated(round_history):
    # Check if all players cooperated in the given round
    return all(action == "C" for action in round_history)

def any_player_defected(round_history):
    # Check if any player defected in the given round
    return any(action == "D" for action in round_history)

def consecutive_defections(history):
    # Check if a player has defected consecutively in the last two rounds
    return history[-1] == "D" and (len(history) > 1 and history[-2] == "D")

def all_players_cooperated_consecutively(history):
    # Check if all players cooperated consecutively for three rounds
    return len([round_history for round_history in history[-3:] if all(action == "C" for action in round_history)]) == 3
```
The ACT strategy aims to strike a balance between individual payoffs and collective sustainability by adapting cooperation based on the game's state and history. By considering both stock levels and previous rounds' outcomes, this strategy should be robust against various opponent behaviors while promoting cooperation when beneficial for all players.
'''

description_COLLECTIVE_522 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC is a robust and adaptive collective strategy that balances individual payoffs with long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play a mixed strategy:
		+ With probability 0.7, Cooperate (C).
		+ With probability 0.3, Defect (D).
	* If the current stock level is below 50% of capacity, Defect (D).

**Rationale:**

* When the stock is high, cooperation ensures a stable and sustainable resource for future rounds.
* As the stock declines, ASC gradually shifts towards more individualistic behavior to maximize payoffs in the short term.
* The mixed strategy in the middle range introduces uncertainty, making it harder for opponents to exploit our actions.

**Additional Considerations:**

* **Last Round:** Defect (D) in the last round, as there is no future benefit from cooperation.
* **Opponent Actions:** ASC does not directly respond to opponent actions. Instead, it focuses on maintaining a healthy stock level and adapting to changes in the environment.

**Pseudocode:**
```python
def ASC(stock, capacity, n):
    if current_round == 1:
        return 'C'  # Cooperate in the first round

    stock_ratio = stock / capacity

    if stock_ratio > 0.75:
        return 'C'  # Cooperate when stock is high
    elif stock_ratio < 0.5:
        return 'D'  # Defect when stock is low
    else:  # Mixed strategy for moderate stock levels
        import random
        if random.random() < 0.7:
            return 'C'
        else:
            return 'D'

    if current_round == total_rounds:  # Last round
        return 'D'  # Defect in the last round

# Example usage:
stock = 80
capacity = 100
n = 4
action = ASC(stock, capacity, n)
print(action)  # Output: C or D based on the decision rules
```
ASC is designed to balance individual payoffs with long-term sustainability and adapt to various opponent behaviors. By using a combination of cooperation and defection, we aim to maintain a healthy stock level while maximizing our overall payoff in the tournament.
'''

description_COLLECTIVE_523 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

The ASC strategy aims to balance individual payoff maximization with collective stock conservation, adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and avoid initial stock depletion.
2. **Stock Conservation Threshold**: Define a threshold `T` as a fraction of the capacity, e.g., `T = 0.5 * capacity`. If the current stock is above this threshold (`stock > T`), cooperate (C). Otherwise, defect (D).
3. **Opponent Adaptation**: Monitor the opponent's actions and adjust the strategy based on their behavior:
	* If an opponent has defected in the previous round, defect (D) in the next round to avoid being exploited.
	* If an opponent has cooperated in the previous round, cooperate (C) in the next round to encourage continued cooperation.
4. **Stock Growth and Decline**: Observe the stock growth or decline over the past few rounds:
	* If the stock has been growing or stable, continue with the current action (cooperate or defect).
	* If the stock has been declining rapidly, switch to cooperate (C) to help replenish the stock.
5. **Endgame**: In the last round (`r = 1`), always defect (D) to maximize individual payoff.

**Pseudocode:**
```python
def ASC(n, r, capacity, stock_history):
    # Initialize threshold T
    T = 0.5 * capacity

    for t in range(1, r + 1):
        if t == 1:
            # Initial round: Cooperate
            action = 'C'
        else:
            # Check stock conservation threshold
            if stock_history[t - 1] > T:
                action = 'C'
            else:
                action = 'D'

            # Adapt to opponent's behavior
            for i in range(1, n + 1):
                if opponents[i][t - 1] == 'D':
                    action = 'D'
                elif opponents[i][t - 1] == 'C':
                    action = 'C'

            # Monitor stock growth and decline
            if t > 3:
                growth_rate = (stock_history[t - 1] - stock_history[t - 4]) / stock_history[t - 4]
                if growth_rate < -0.5:  # Rapid decline
                    action = 'C'
                elif growth_rate > 0.5:  # Growth or stability
                    pass

        # Endgame: Defect in the last round
        if t == r:
            action = 'D'

        return action
```
**Collective Mindset Alignment**: The ASC strategy prioritizes collective stock conservation while allowing for individual adaptation to opponent behavior. By cooperating when the stock is above a certain threshold, players contribute to the sustainability of the common pool resource. When opponents defect or the stock declines rapidly, the strategy adapts by defecting or switching to cooperation to avoid exploitation and replenish the stock.

**Robustness**: The ASC strategy is designed to be robust against various opponent behaviors, including:

* Unconditional cooperators: ASC will cooperate with them to maintain a high stock level.
* Unconditional defectors: ASC will defect in response to avoid being exploited.
* Tit-for-tat players: ASC will adapt to their behavior and cooperate or defect accordingly.

By combining these decision rules, the Adaptive Stock Conservation strategy provides a robust and adaptive approach for collective decision-making in the Common Pool Resource Game.
'''

description_COLLECTIVE_524 = '''
Here's a collective strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Collective Harvesting (ACH)

**Decision Rules:**

1. **Initial Rounds**: In the first two rounds, play Cooperate (C) to establish a cooperative baseline and observe opponents' behavior.
2. **Stock-based Threshold**: Calculate a stock threshold `θ` as a function of the current stock level `S` and capacity `capacity`: `θ = S / (2n) * (1 - S/capacity)`. This threshold reflects the trade-off between harvesting and preserving the common pool.
3. **Cooperation vs Defection**:
	* If the number of players playing Cooperate in the previous round is greater than or equal to `n/2`, play Cooperate (C).
	* Otherwise, if the current stock level `S` is above the threshold `θ`, play Cooperate (C). This ensures that we don't over-harvest when the pool is abundant.
	* If `S` is below `θ`, play Defect (D) to maximize individual payoff in a depleted environment.
4. **Last Round**: In the final round, play Defect (D) regardless of previous behavior or stock level, as there's no future benefit from cooperation.

**Edge Case Handling:**

* If `n` is even and exactly half of players cooperated in the previous round, randomize between Cooperate (C) and Defect (D) with equal probability to avoid being too predictable.
* In cases where multiple strategies would lead to the same payoff (e.g., when all players defect), prefer the strategy that aligns with the collective mindset, which is cooperation.

**Collective Mindset Alignment:**

The ACH strategy prioritizes cooperation when possible and adapts to changing conditions. By monitoring opponents' behavior and adjusting our actions accordingly, we promote a culture of mutual support while avoiding exploitation. The stock-based threshold helps balance individual interests with the need for collective sustainability.

Pseudocode:
```python
def adaptive_collective_harvesting(state, history):
    n = state['n']
    capacity = state['capacity']
    S = state['stock']
    r = state['round']

    if r < 3:  # initial rounds
        return 'C'

    theta = S / (2 * n) * (1 - S / capacity)

    previous_coops = sum([h == 'C' for h in history[-1]])
    if previous_coops >= n / 2:
        return 'C'
    elif S > theta:
        return 'C'
    else:
        return 'D'

    # last round
    if r == state['r']:
        return 'D'
```
This strategy is designed to be robust against a wide range of opponent behaviors and promotes collective sustainability while adapting to changing conditions.
'''

description_COLLECTIVE_525 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to maximize the initial stock growth.
2. **Stock Threshold**: If the current stock is above 75% of the capacity, cooperate (C). This threshold encourages cooperation when the stock is relatively healthy.
3. **Recent Defection**: If at least half of the players defected in the previous round, defect (D) in the current round. This rule aims to punish recent defections and prevent excessive exploitation.
4. **Stock Depletion**: If the total consumption in the previous round exceeded 50% of the capacity, cooperate (C) in the current round. This rule helps to conserve the stock when it's being depleted rapidly.
5. **History-based Cooperation**: Cooperate (C) if the average payoff per player over the last three rounds is above the median payoff for all players in those rounds. This rule promotes cooperation when the game has been relatively cooperative and payoffs have been satisfactory.

Pseudocode:
```python
def ASC(current_stock, capacity, num_players, round_num, prev_round_actions, prev_round_payoffs):
    if round_num == 1:  # Initial Round
        return 'C'
    
    if current_stock > 0.75 * capacity:  # Stock Threshold
        return 'C'
    
    recent_defections = sum(1 for action in prev_round_actions if action == 'D')
    if recent_defections >= num_players / 2:  # Recent Defection
        return 'D'
    
    total_consumption_prev = sum(prev_round_payoffs)
    if total_consumption_prev > 0.5 * capacity:  # Stock Depletion
        return 'C'
    
    avg_payoff_last_3 = np.mean([payoff for payoff in prev_round_payoffs[-3:]])
    median_payoff_all = np.median(prev_round_payoffs)
    if avg_payoff_last_3 > median_payoff_all:  # History-based Cooperation
        return 'C'
    
    return 'D'  # Default to Defection
```
**Edge Cases:**

* In the last round, always defect (D) to maximize individual payoff.
* If there's a tie in the number of recent defections, cooperate (C).
* If the average payoff per player over the last three rounds is equal to the median payoff for all players in those rounds, cooperate (C).

**Collective Mindset:**

The ASC strategy aims to balance individual self-interest with collective well-being. By cooperating when the stock is healthy and punishing recent defections, the strategy encourages cooperation and conserves the common pool resource. The history-based cooperation rule promotes a long-term perspective, rewarding cooperative behavior that has led to satisfactory payoffs in the past.

This adaptive strategy should perform well against a wide range of opponent behaviors, as it responds to changes in the game state and adjusts its actions accordingly.
'''

description_COLLECTIVE_526 = '''
**Collective Strategy: Adaptive Cooperation with Stock Conservation (ACSC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Subsequent Rounds:** Assess the current stock level and opponent actions from previous rounds.
	* If the stock level is above 75% of capacity, cooperate (C) if most opponents (>50%) cooperated in the previous round; otherwise, defect (D).
	* If the stock level is between 25% and 75% of capacity, cooperate (C) if at least half of opponents cooperated in the previous round; otherwise, defect (D).
	* If the stock level is below 25% of capacity, always defect (D) to maximize individual payoff.
3. **Opponent Behavior Analysis:** Track the number of cooperating and defecting opponents in each round. If an opponent defects in a round where the stock level was above 75%, classify them as "selfish" and adjust strategy accordingly.

**Edge Cases:**

1. **Last Round:** Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Low Stock Levels:** If the stock level is critically low (<10% of capacity), cooperate (C) to allow for some growth and potential future benefits.
3. **Opponent Homogeneity:** If all opponents consistently cooperate or defect, adapt strategy to mirror their behavior.

**Collective Mindset:**

1. **Cooperation:** Prioritize cooperation when the stock level is high and most opponents are cooperating, as this maintains a healthy stock and promotes collective well-being.
2. **Selfishness Detection:** Identify selfish opponents who exploit cooperative situations and adjust strategy to counter their behavior.
3. **Stock Conservation:** Balance individual payoffs with long-term sustainability by conserving the stock when it's low.

**Pseudocode:**
```python
def ACSC(n, capacity, r):
    # Initialize variables
    stock = capacity
    opponent_actions = [[] for _ in range(n)]
    selfish_opponents = set()

    for t in range(r):
        # Assess current state and history
        if t == 0:
            action = "C"  # Cooperate in the first round
        else:
            prev_stock = stock
            prev_cooperators = sum(1 for actions in opponent_actions if actions[-1] == "C")

            if stock > 0.75 * capacity and prev_cooperators > n / 2:
                action = "C"  # Cooperate if most opponents cooperated previously
            elif stock < 0.25 * capacity or (stock >= 0.25 * capacity and prev_cooperators <= n / 2):
                action = "D"  # Defect otherwise

        # Update opponent actions and selfishness detection
        for i in range(n):
            if opponent_actions[i][-1] == "D" and stock > 0.75 * capacity:
                selfish_opponents.add(i)

        # Take action and update state
        if action == "C":
            payoff = stock / (2 * n)
        else:
            payoff = stock / n

        stock -= sum(payoff for _ in range(n))
        growth = 2 * stock * (1 - stock / capacity)
        stock = min(stock + growth, capacity)

    return total_payoff
```
This strategy balances individual payoffs with collective well-being by adapting to the game's state and opponent behaviors. It promotes cooperation when beneficial for the group and adjusts to counter selfish behavior.
'''

description_COLLECTIVE_527 = '''
I'll design a collective strategy that balances individual self-interest with long-term sustainability of the common pool resource.

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline trust and encourage other players to conserve the stock.
2. **Subsequent Rounds (t>1):** Use a dynamic threshold-based approach:
	* Calculate the average historical consumption rate of all players, excluding the current round (`avg_consumption_rate`).
	* If `avg_consumption_rate` is below 0.5 (i.e., conservative), Cooperate (C) to maintain a sustainable stock level.
	* If `avg_consumption_rate` is between 0.5 and 1.0 (i.e., moderate), Defect (D) with probability 0.5, and Cooperate (C) otherwise, to introduce some variation and test opponents' strategies.
	* If `avg_consumption_rate` exceeds 1.0 (i.e., aggressive), Defect (D) to maximize individual payoff in a depleted stock environment.
3. **Low Stock Levels:** When the current stock level falls below 25% of the capacity, Cooperate (C) to help replenish the stock and avoid depletion.

**Edge Cases:**

* **Last Round (t=r):** Defect (D) to maximize individual payoff, as there is no future benefit from cooperation.
* **Single Opponent:** Mirror their previous action to establish a reciprocal relationship.
* **Multiple Opponents with Similar Strategies:** Use the average historical consumption rate of all opponents to inform your decision.

**Collective Mindset:**

ACC prioritizes collective conservation while adapting to the dynamics of the game. By initially cooperating, ACC encourages other players to conserve the stock and establishes a baseline trust. The dynamic threshold-based approach adjusts to the group's behavior, balancing individual self-interest with long-term sustainability. When faced with low stock levels or aggressive opponents, ACC adapts by cooperating or defecting to ensure the stock's recovery.

**Pseudocode:**

```python
def ACC(n, capacity, r, history):
    if t == 1:
        return "Cooperate"
    
    avg_consumption_rate = calculate_avg_consumption_rate(history)
    
    if avg_consumption_rate < 0.5:
        return "Cooperate"
    elif 0.5 <= avg_consumption_rate <= 1.0:
        return random.choice(["Defect", "Cooperate"])
    else:
        return "Defect"
    
    if current_stock_level < 0.25 * capacity:
        return "Cooperate"

def calculate_avg_consumption_rate(history):
    # Calculate average historical consumption rate of all players, excluding the current round
    pass

# Note: The `calculate_avg_consumption_rate` function is not implemented here,
# as it depends on the specific data structure used to store the game history.
```

This strategy should perform well in a tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_528 = '''
I'll propose a collective strategy that adapts to various opponent behaviors while prioritizing sustainability and fairness. Our approach will balance individual payoffs with the long-term health of the common pool resource.

**Strategy Name:** Adaptive Collective Sustainability (ACS)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to follow suit.
2. **Observation Phase**: For rounds 2-5, observe the actions of other players and calculate the average cooperation rate (ACR) among them. ACR is the proportion of players who chose C in the previous round.
3. **Adaptive Cooperation Threshold**: Set a dynamic cooperation threshold (CT) based on the current stock level and ACR:
	* If stock ≥ capacity / 2, CT = max(0.5, ACR).
	* If stock < capacity / 2, CT = min(1, ACR + 0.25).
4. **Cooperation Decision**: In subsequent rounds (6+), cooperate if the current stock level is above the CT-threshold of the capacity. Otherwise, defect.

Pseudocode:
```markdown
# Initialize variables
stock = capacity
ACR = 0  # Average cooperation rate among opponents
CT = 0   # Cooperation threshold

# First round: Cooperate
action = C

# Observation phase (rounds 2-5)
for t in range(1, 6):
    ACR = calculate_average_cooperation_rate(opponents' actions)
    if stock >= capacity / 2:
        CT = max(0.5, ACR)
    else:
        CT = min(1, ACR + 0.25)

# Adaptive cooperation decision (rounds 6+)
for t in range(6, r):
    if stock > CT * capacity:
        action = C
    else:
        action = D

    # Update stock and opponents' actions for next round
    stock = update_stock(stock, opponents' actions, action)
```
**Handling Edge Cases:**

* **Last Round**: In the final round (r), always defect to maximize individual payoff.
* **Low Stock Levels**: If the stock level falls below capacity / 4, cooperate in all subsequent rounds to prioritize resource sustainability.

**Collective Mindset:**
ACS aligns with a collective mindset by:

1. Encouraging cooperation through initial-round cooperation and adaptive thresholds.
2. Observing opponent behavior and adapting to promote fairness and sustainability.
3. Balancing individual payoffs with long-term resource health, ensuring a stable game environment.

By implementing ACS, our strategy promotes cooperation while remaining robust against various opponent behaviors, prioritizing both individual gains and the collective good.
'''

description_COLLECTIVE_529 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

The Adaptive Cooperation strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. AC prioritizes cooperation when possible while defecting strategically to maintain a healthy stock level.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' behaviors.
2. **Stock-Based Cooperation**: If the current stock is above 75% of capacity, cooperate (C). This ensures the stock remains sustainable while allowing for moderate consumption.
3. **Defect-to-Signal**: If the stock is between 50% and 75% of capacity, defect (D) with a probability proportional to the number of opponents who defected in the previous round. This sends a signal that cooperation is necessary to maintain a healthy stock level.
4. **Critical Stock**: If the stock falls below 50% of capacity, cooperate (C) unconditionally. This prioritizes stock recovery and encourages others to do the same.
5. **Endgame Cooperation**: In the last two rounds, always cooperate (C). This promotes cooperation as the game concludes, ensuring a more sustainable outcome.

**Additional Mechanisms:**

* **Opponent Monitoring**: Track opponents' actions in previous rounds to adjust the Defect-to-Signal probability. If an opponent has defected frequently, increase the likelihood of defecting in response.
* **Stock Trend Analysis**: Monitor the stock's trend over the past three rounds. If the stock is declining rapidly, prioritize cooperation (C) to prevent further depletion.

**Pseudocode:**

```
function AdaptiveCooperation(n, r, capacity, current_stock, history):
  if round == 1:
    return C
  elif current_stock >= 0.75 * capacity:
    return C
  elif 0.5 * capacity <= current_stock < 0.75 * capacity:
    defect_prob = (num_opponent_defections_last_round / n) * 0.2
    if random() < defect_prob:
      return D
    else:
      return C
  elif current_stock < 0.5 * capacity:
    return C
  elif round >= r - 2:  // Endgame Cooperation
    return C

  opponent_defection_rates = track_opponent_actions(history)
  stock_trend = analyze_stock_trend(history)

  if stock_trend == "declining_rapidly":
    return C
  else:
    return C  // Default to cooperation when uncertain
```

**Collective Mindset:**

Adaptive Cooperation prioritizes collective sustainability while allowing for individual adaptation. By cooperating when possible and defecting strategically, AC promotes a balance between short-term payoffs and long-term stock health. This strategy encourages opponents to cooperate by signaling the importance of sustainable consumption and responding to their actions.
'''

description_COLLECTIVE_530 = '''
**Collective Strategy: "Sustainable Cooperation"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5 to gather information about opponents' behaviors.
2. **Non-Initial Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of the capacity, use a mixed strategy:
		+ Cooperate (C) with probability p = (current_stock / capacity)^2
		+ Defect (D) with probability 1 - p
	* If the current stock level is below 50% of the capacity, defect (D)
3. **Adaptive Response:**
	* Monitor the average payoff of opponents in the previous round.
	* If the average payoff is higher than the player's own payoff, adjust the cooperation probability downwards by 10%.
	* If the average payoff is lower than the player's own payoff, adjust the cooperation probability upwards by 10%.

**Pseudocode:**
```
function SustainableCooperation(current_stock, capacity, round_number, opponent_payoffs):
    if round_number == 1:
        return cooperate with probability 0.5
    
    stock_ratio = current_stock / capacity
    if stock_ratio > 0.75:
        return cooperate
    elif 0.5 <= stock_ratio < 0.75:
        p = (stock_ratio)^2
        return cooperate with probability p, defect otherwise
    else:
        return defect

    # Adaptive response
    avg_opponent_payoff = average(opponent_payoffs)
    if avg_opponent_payoff > player_payoff:
        adjust_cooperation_probability(-0.1)
    elif avg_opponent_payoff < player_payoff:
        adjust_cooperation_probability(0.1)

function adjust_cooperation_probability(delta):
    # Update the cooperation probability using a simple moving average
    global cooperation_probability
    cooperation_probability = (cooperation_probability * 9 + delta) / 10
```
**Collective Mindset:**

The Sustainable Cooperation strategy is designed to balance individual payoffs with collective sustainability. By adapting to the current stock level and opponents' behaviors, the strategy aims to maintain a stable and sustainable common pool resource.

In the initial round, the strategy explores the behavior of opponents by cooperating with a probability of 0.5. In subsequent rounds, it adjusts its cooperation probability based on the current stock level and the average payoff of opponents.

When the stock level is high (above 75% capacity), the strategy cooperates to ensure long-term sustainability. When the stock level is moderate (between 50% and 75% capacity), the strategy uses a mixed approach, taking into account both individual payoffs and collective sustainability. When the stock level is low (below 50% capacity), the strategy defects to maximize individual payoff.

By adapting to opponents' behaviors and adjusting its cooperation probability accordingly, the Sustainable Cooperation strategy aims to promote a stable and sustainable collective outcome in the Common Pool Resource game.
'''

description_COLLECTIVE_531 = '''
I propose a collective strategy called "Adaptive Stock Conservation" (ASC) for the Common Pool Resource Game. ASC balances individual interests with collective sustainability by adapting to changing game conditions and opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1):**
Cooperate (C) if the number of players (n) is less than or equal to 3, otherwise Defect (D). This starting point allows for a gentle exploration of the game dynamics.
2. **Subsequent Rounds (t>1):**
Observe the previous round's stock level and opponents' actions. If:
	* The stock level has decreased significantly (>20%) from the initial capacity, Defect (D) to maximize short-term payoff.
	* At least one opponent defected in the previous round, Defect (D) to avoid being exploited.
	* None of the above conditions are met, Cooperate (C) if the current stock level is above 50% of the capacity; otherwise, Defect (D).
3. **Endgame Rounds (t=r-1 or t=r):**
Cooperate (C) if the current stock level is below 20% of the capacity; otherwise, Defect (D). This ensures that players do not overexploit the resource in the final rounds.

**Edge Cases:**

* If an opponent's action is unknown or undefined, assume they defected.
* In case of a tie in the decision rules, cooperate.

**Collective Mindset:**
ASC promotes collective sustainability by:

1. Encouraging cooperation when the stock level is high and opponents are cooperative.
2. Punishing opponents who defect by also defecting to maintain fairness.
3. Adapting to changing game conditions to prevent overexploitation.
4. Balancing individual interests with collective sustainability in the endgame rounds.

**Pseudocode:**

```
function AdaptiveStockConservation(n, capacity, stock_history):
    if round == 1:
        if n <= 3:
            return COOPERATE
        else:
            return DEFECT

    previous_stock = stock_history[-2]
    current_stock = stock_history[-1]

    if current_stock < 0.8 * previous_stock: // significant decrease
        return DEFECT
    elif any(opponent_defected(stock_history)):
        return DEFECT
    elif current_stock > 0.5 * capacity:
        return COOPERATE
    else:
        return DEFECT

    if round == r-1 or round == r: // endgame rounds
        if current_stock < 0.2 * capacity:
            return COOPERATE
        else:
            return DEFECT
```

ASC is designed to be robust and adaptive in the face of various opponent behaviors, promoting collective sustainability while allowing for individual self-interest.
'''

description_COLLECTIVE_532 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

The ACST strategy aims to balance individual payoff maximization with collective sustainability by adaptively cooperating based on the current stock level and history of opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to encourage mutual cooperation and observe opponents' initial actions.
2. **Subsequent Rounds**: Use a dynamic threshold to decide between Cooperation (C) and Defection (D). The threshold is based on the current stock level relative to the capacity:
	* If `stock >= 0.75 * capacity`, Cooperate (C).
	* If `stock < 0.25 * capacity`, Defect (D).
	* Otherwise, use a probabilistic approach: Cooperate with probability `p` and Defect with probability `(1-p)`. The probability `p` is calculated as:
		+ `p = (stock / capacity) ^ 2`
3. **Opponent Behavior Analysis**: Monitor opponents' actions in previous rounds and adjust the threshold accordingly:
	* If a majority of opponents (>50%) defected in the previous round, decrease the cooperation probability `p` by 10% for the next round.
	* If a majority of opponents cooperated in the previous round, increase the cooperation probability `p` by 10% for the next round.

**Edge Cases:**

1. **Last Round**: In the final round (`r == current_round`), Defect (D) to maximize individual payoff, as there is no future sustainability concern.
2. **Extremely Low Stock**: If `stock < 0.01 * capacity`, Defect (D) to ensure a minimum payoff.

**Collective Mindset:**

ACST prioritizes cooperation when the stock level is high and adapts to opponents' behaviors by adjusting its cooperation probability. This approach promotes collective sustainability while also allowing for individual optimization in situations where cooperation may not be reciprocated.

Pseudocode:
```
function ACST(stock, capacity, current_round, r):
  if current_round == 1: # Initial Round
    return C
  elif stock >= 0.75 * capacity:
    return C
  elif stock < 0.25 * capacity:
    return D
  else:
    p = (stock / capacity) ^ 2
    opponent_behavior = analyze_opponent_actions()
    if majority_defected(opponent_behavior):
      p -= 0.1
    elif majority_cooperated(opponent_behavior):
      p += 0.1
    return C with probability p, D otherwise

function analyze_opponent_actions():
  # Monitor opponents' actions in previous rounds and update the cooperation probability accordingly

function majority_defected(actions):
  # Check if a majority of opponents defected in the previous round

function majority_cooperated(actions):
  # Check if a majority of opponents cooperated in the previous round
```
This strategy should be implemented as an algorithm to participate in the tournament against other AI systems.
'''

description_COLLECTIVE_533 = '''
I propose a collective strategy called "Adaptive Stock Preservation" (ASP). ASP aims to balance individual payoffs with long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline and encourage others to cooperate.
2. **Subsequent Rounds:** Observe the previous round's actions and outcomes. Calculate the "Cooperation Quotient" (CQ) as the ratio of cooperative players to total players.

   If CQ ≥ 0.5, Cooperate (C).
   Else, Defect (D).

3. **Stock-Level Thresholds:**
   - If stock ≤ capacity / 2, Cooperate (C) to prioritize stock growth.
   - If stock > capacity / 2 and CQ < 0.5, Defect (D) to maximize individual payoff.

**Edge Cases:**

* **Last Round:** If it's the last round (t = r), always Defect (D) as there is no future game to consider.
* **Single Player:** If only one player remains, Cooperate (C) to maintain a positive payoff.

**Adaptive Mechanism:**

* Monitor the stock level and adjust strategy accordingly. If the stock is low, prioritize cooperation to allow for growth.
* Continuously update CQ based on observed actions to adapt to changing opponent behaviors.

**Collective Mindset Alignment:**

ASP prioritizes cooperation when:
- The collective has demonstrated a willingness to cooperate (CQ ≥ 0.5).
- The stock level requires preservation (stock ≤ capacity / 2).

By doing so, ASP promotes a shared understanding of the importance of sustainable resource management while adapting to various opponent strategies.

Pseudocode for ASP:

```
function AdaptiveStockPreservation(game_state):
    if game_state.round == 1:
        return Cooperate
    else:
        cooperation_quotient = calculate_CQ(game_state)
        stock_level = get_stock_level(game_state)

        if stock_level <= capacity / 2:
            return Cooperate
        elif cooperation_quotient >= 0.5:
            return Cooperate
        else:
            return Defect

function calculate_CQ(game_state):
    # Count cooperative players in previous round
    coop_players = sum(1 for action in game_state.previous_actions if action == 'C')
    total_players = len(game_state.players)
    return coop_players / total_players
```

ASP is designed to be robust against various opponent strategies while promoting collective sustainability.
'''

description_COLLECTIVE_534 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACS-DT)**

**Overview**

Our collective strategy, ACS-DT, aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and game history. This approach allows our strategy to be robust against various opponent behaviors while promoting collective well-being.

**Decision Rules**

1. **Initial Round (t=1)**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' strategies.
2. **Subsequent Rounds (t>1)**: Use the following threshold-based decision rule:
	* If the current stock level (S) is above a dynamically adjusted threshold (τ), cooperate (C).
	* Otherwise, defect (D).

**Threshold Calculation**

The threshold τ is calculated based on the game's parameters and state:

τ = capacity × (1 - (total consumption in previous round / capacity))

This formula adjusts the threshold according to the previous round's total consumption, making it more likely to cooperate when the stock level is high and less likely when it's low.

**Additional Logic**

* **Last Round (t=r)**: Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.
* **Low Stock Level**: If the current stock level (S) falls below a certain fraction of the capacity (e.g., 0.25 \* capacity), cooperate (C) to help replenish the stock and prevent depletion.

**Pseudocode**
```markdown
function ACS_DT(current_stock, previous_round_consumption, capacity, round_number, total_rounds):
    if round_number == 1:
        return COOPERATE
    elif current_stock < 0.25 * capacity:
        return COOPERATE
    else:
        threshold = capacity * (1 - (previous_round_consumption / capacity))
        if current_stock > threshold:
            return COOPERATE
        else:
            return DEFECT
```
**Collective Mindset Alignment**

ACS-DT is designed to align with the collective mindset by:

* Cooperating in the initial round to establish a cooperative tone
* Adapting cooperation levels based on the current stock level and game history
* Prioritizing sustainability by cooperating when the stock level is high
* Maximizing individual payoff in the last round while considering the collective well-being

By following this strategy, we aim to achieve a balance between individual payoffs and collective sustainability, making it an attractive choice for a tournament against independent strategies.
'''

description_COLLECTIVE_535 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC is a dynamic, state-dependent strategy that balances individual payoffs with collective stock conservation. It adapts to changing game conditions and opponent behaviors while promoting cooperation.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoff.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play a mixed strategy:
		+ With probability 0.7, Cooperate (C).
		+ With probability 0.3, Defect (D).
	* If the current stock level is below 50% of capacity, Defect (D) to maximize individual payoff.
3. **Last Round:** Defect (D) in the last round, as there are no future rounds to conserve stock for.

**Additional Logic:**

1. **Stock Trend Analysis:** Monitor the stock trend over the past three rounds. If the stock level has been increasing or stable, increase the probability of Cooperation (C) by 0.1 in the next round.
2. **Opponent Behavior Adaptation:** Observe the opponent's actions and adjust the strategy accordingly:
	* If an opponent defects frequently (>60% of the time), reduce the probability of Cooperation (C) by 0.2.
	* If an opponent cooperates frequently (>60% of the time), increase the probability of Cooperation (C) by 0.2.

**Pseudocode:**

```
function ASC(current_stock, capacity, num_rounds, history):
  // Initial Round
  if current_round == 1:
    return Cooperate

  // Subsequent Rounds
  stock_ratio = current_stock / capacity
  if stock_ratio > 0.75:
    return Cooperate
  elif stock_ratio >= 0.5 and stock_ratio <= 0.75:
    // Mixed Strategy
    probability_cooperate = 0.7 - (history[opponent_defect_rate] * 0.2)
    return random_choice([Cooperate, Defect], [probability_cooperate, 1 - probability_cooperate])
  else:
    return Defect

  // Last Round
  if current_round == num_rounds:
    return Defect

  // Stock Trend Analysis and Opponent Behavior Adaptation (not shown)
```

**Collective Mindset:**

ASC prioritizes cooperation when the stock level is high, promoting collective conservation. As the stock level decreases, ASC adapts to balance individual payoffs with collective sustainability. By adjusting to opponent behaviors and stock trends, ASC fosters a dynamic, cooperative environment while protecting against exploitation.

By implementing this strategy, we aim to achieve a high total payoff in the tournament while promoting sustainable resource management in the Common Pool Resource Game.
'''

description_COLLECTIVE_536 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC aims to balance individual payoffs with collective sustainability by adaptively responding to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and observe others' actions.
2. **Subsequent Rounds:** Use the following logic:
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, Defect (D) with a probability proportional to the number of opponents who defected in the previous round.
	* If the current stock level is below 50% of capacity, Cooperate (C) to conserve the remaining stock.
3. **Opponent Behavior:** Monitor the actions of other players and adjust the defect probability accordingly:
	* If a majority (>50%) of opponents defected in the previous round, increase the defect probability by 20%.
	* If a minority (<50%) of opponents defected in the previous round, decrease the defect probability by 10%.

**Edge Cases:**

1. **Last Round:** Cooperate (C) to ensure the stock level is as high as possible for the final payoff calculation.
2. **Low Stock Levels:** If the current stock level is critically low (<25% of capacity), Defect (D) to maximize individual payoffs, as cooperation would yield minimal benefits.

**Collective Mindset:**

ASC prioritizes collective sustainability while adapting to opponent behavior. By cooperating when the stock level is high and conserving when it's low, ASC promotes a stable and resilient common pool resource. The adaptive defect probability mechanism encourages opponents to cooperate by responding to their actions.

**Pseudocode (for illustration purposes only):**
```python
def ASC(stock_level, capacity, num_opponents, prev_round_actions):
    if stock_level > 0.75 * capacity:
        return "C"
    elif stock_level >= 0.5 * capacity:
        defect_prob = len([a for a in prev_round_actions if a == "D"]) / num_opponents
        return "D" with probability defect_prob
    else:
        return "C"

def update_defect_probability(defect_prob, prev_round_actions):
    if sum(1 for a in prev_round_actions if a == "D") > 0.5 * len(prev_round_actions):
        defect_prob += 0.2
    elif sum(1 for a in prev_round_actions if a == "D") < 0.5 * len(prev_round_actions):
        defect_prob -= 0.1
    return defect_prob
```
ASC is designed to be robust against various opponent strategies, promoting cooperation when beneficial and adapting to exploitation when necessary.
'''

description_COLLECTIVE_537 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for future adaptations.
2. **Subsequent Rounds**: Assess the current stock level and previous rounds' outcomes to determine the action for the next round.
3. **Stock Thresholds**: Define two stock thresholds:
	* `conservation_threshold` = 0.75 \* capacity (e.g., 75% of the maximum sustainable stock level)
	* `alarm_threshold` = 0.25 \* capacity (e.g., 25% of the maximum sustainable stock level)

**Action Determination**

1. If the current stock is above `conservation_threshold`, Cooperate (C).
2. If the current stock is below `alarm_threshold`, Defect (D) to maximize individual payoff in a potentially depleted environment.
3. If the current stock is between `conservation_threshold` and `alarm_threshold`:
	* Calculate the average payoff per player over the last 2-3 rounds (`avg_payoff_recent`).
	* Compare `avg_payoff_recent` with the maximum possible payoff per round (`max_payoff_per_round = capacity / (2 \* n)`):
		+ If `avg_payoff_recent` is above 0.8 \* `max_payoff_per_round`, Cooperate (C) to maintain a high collective payoff.
		+ Otherwise, Defect (D) to potentially increase individual payoff.

**Additional Adaptations**

1. **Exploitation Detection**: Monitor the average stock depletion rate over the last 2-3 rounds (`avg_depletion_rate_recent`). If it exceeds a threshold (e.g., 20% of the maximum sustainable stock level), switch to Defect (D) for one round to discourage over-exploitation by others.
2. **Reciprocal Cooperation**: Track the number of players that cooperated in the previous round (`coop_count_prev`).
	* If `coop_count_prev` is above 0.5 \* n, Cooperate (C) in the next round to reciprocate cooperation.

**Edge Cases**

1. **Last Round**: Defect (D) to maximize individual payoff, as there are no future rounds to consider.
2. **Round with Only One Player Remaining**: Always Defect (D), as cooperation would not provide a benefit.

Pseudocode for the ASC strategy:
```python
def ASC(n, capacity, stock, round_num, history):
    if round_num == 1:  # Initial Round
        return 'C'

    conservation_threshold = 0.75 * capacity
    alarm_threshold = 0.25 * capacity

    if stock > conservation_threshold:
        return 'C'
    elif stock < alarm_threshold:
        return 'D'
    else:
        avg_payoff_recent = calculate_avg_payoff(history, 2-3 rounds)
        max_payoff_per_round = capacity / (2 * n)

        if avg_payoff_recent > 0.8 * max_payoff_per_round:
            return 'C'
        else:
            return 'D'

    # Additional adaptations
    avg_depletion_rate_recent = calculate_avg_depletion_rate(history, 2-3 rounds)
    if avg_depletion_rate_recent > threshold (e.g., 20% of capacity):
        return 'D' for one round

    coop_count_prev = count_coop_players(history, previous round)
    if coop_count_prev > 0.5 * n:
        return 'C'
```
This ASC strategy balances individual payoffs with collective sustainability by adapting to the game's state and history. It promotes cooperation when possible while protecting against over-exploitation and encouraging reciprocal behavior.
'''

description_COLLECTIVE_538 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and aligns with the collective mindset:

**Strategy Name:** Adaptive Cooperative Threshold (ACT)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behavior.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, cooperate (C) if the majority (>50%) of opponents cooperated in the previous round. Otherwise, defect (D).
	* If the stock level is between 50% and 75% of capacity, cooperate (C) if at least one opponent cooperated in the previous round. Otherwise, defect (D).
	* If the stock level is below 50% of capacity, defect (D) to maximize individual payoff.
3. **Last Round (t=r):** Defect (D) in the last round to maximize individual payoff, as there are no future rounds to consider.

**Edge Case Handling:**

* If an opponent defects in a round where our strategy would normally cooperate, we will defect in the next round if the stock level is above 50% of capacity. This aims to punish opponents for deviating from cooperation.
* If multiple opponents cooperate while our strategy would normally defect, we will cooperate in the next round if the stock level is below 75% of capacity. This adapts to situations where cooperation becomes more beneficial.

**Collective Mindset:**

The ACT strategy aligns with the collective mindset by:

* Initially cooperating to establish a cooperative tone and gather information.
* Adapting to opponents' behavior, rewarding cooperation, and punishing defection.
* Prioritizing cooperation when the stock level is high, ensuring sustainable resource management.
* Defecting when the stock level is low or in the last round to maximize individual payoff.

**Pseudocode:**

```
function ACT(n, capacity, r, history) {
  if (t == 1) { // Initial Round
    return C;
  } else {
    stock_level = current_stock / capacity;
    opponents_cooperated = count(opponents who cooperated in previous round);
    
    if (stock_level > 0.75) {
      if (opponents_cooperated > n/2) {
        return C;
      } else {
        return D;
      }
    } else if (stock_level >= 0.5 && stock_level <= 0.75) {
      if (opponents_cooperated >= 1) {
        return C;
      } else {
        return D;
      }
    } else { // stock_level < 0.5
      return D;
    }
  }
  
  // Last Round
  if (t == r) {
    return D;
  }
}
```

This strategy balances individual payoff maximization with collective resource management, adapting to various opponent behaviors and aligning with the collective mindset.
'''

description_COLLECTIVE_539 = '''
**Collective Strategy: "Adaptive Harmony"**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative tone and maximize the initial payoff.
2. **Subsequent Rounds:**
	* If the stock level is above 75% of the capacity, cooperate (C).
	* If the stock level is between 50% and 75% of the capacity, defect (D) with a probability proportional to the number of players who defected in the previous round.
	* If the stock level is below 50% of the capacity, defect (D).

Pseudocode:
```
if current_round == 1:
    action = C
else:
    stock_ratio = current_stock / capacity
    if stock_ratio > 0.75:
        action = C
    elif stock_ratio >= 0.5 and stock_ratio <= 0.75:
        defect_prob = num_defectors_prev_round / n
        action = D with probability defect_prob, else C
    else:
        action = D
```
**Edge Cases:**

* **Last Round:** Cooperate (C) in the last round to ensure a positive payoff and maintain a cooperative reputation.
* **Low Stock Levels:** If the stock level is critically low (< 25% of capacity), defect (D) to maximize the remaining payoff.

**Collective Mindset:**

The Adaptive Harmony strategy prioritizes cooperation when the stock level is high, allowing all players to benefit from the common pool. As the stock level decreases, it adapts by introducing a probabilistic defect mechanism that takes into account the behavior of other players in the previous round. This approach aims to prevent over-exploitation and maintain a balance between individual payoffs and collective sustainability.

**Robustness:**

Adaptive Harmony is designed to be robust against various opponent behaviors:

* **Cooperative opponents:** By initially cooperating, we establish a cooperative tone and maximize payoffs.
* **Defective opponents:** Our probabilistic defect mechanism helps prevent over-exploitation and adapts to the level of defection in the group.
* **Mixed-strategy opponents:** The adaptive nature of our strategy allows us to respond effectively to changing opponent behaviors.

This collective strategy aims to strike a balance between individual payoffs and collective sustainability, making it an effective approach for a wide range of game scenarios.
'''

description_COLLECTIVE_540 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock Consideration**

Our strategy is designed to balance individual payoffs with collective sustainability of the common pool resource. We'll employ a variant of the well-known Tit-for-Tat (TFT) approach, adapted to accommodate the dynamic state and repeated interaction aspects of this game.

**Decision Rules:**

1. **Initial Round**: Cooperate (C). This sets a cooperative tone and allows us to observe others' initial actions.
2. **Subsequent Rounds**: Observe the previous round's actions and payoffs.
	* If the majority (> n/2) cooperated in the previous round, cooperate (C).
	* If the majority defected or there was a tie, defect (D).
3. **Stock Consideration**: Monitor the current stock level (S). If S falls below 50% of capacity, switch to cooperating (C) regardless of the previous round's actions.
4. **Last Round**: Cooperate (C) if the stock is above 50% of capacity; otherwise, defect (D).

**Pseudocode:**
```markdown
function adaptive_tft(stock, history):
    # Initial round
    if history.length == 0:
        return C

    # Count previous round's actions
    prev_round_actions = history[-1]
    num_cooperators = sum(1 for action in prev_round_actions if action == C)

    # Majority-based decision
    if num_cooperators > n / 2:
        return C
    else:
        return D

    # Stock consideration
    if stock < capacity * 0.5:
        return C

    # Last round handling
    if history.length == r - 1:
        if stock > capacity * 0.5:
            return C
        else:
            return D

    return default_action (C or D, depending on the specific implementation)
```
**Collective Mindset:**

Our strategy prioritizes cooperation when possible, while being responsive to others' actions and the state of the common pool resource. By cooperating in the initial round and reacting to the majority's behavior, we promote a collective norm of cooperation. The stock consideration mechanism ensures that our strategy adapts to prevent over-exploitation of the resource.

**Robustness:**

This strategy is designed to perform well against various opponent behaviors:

* **Cooperative opponents**: Our strategy will cooperate with them, leading to mutually beneficial outcomes.
* **Defecting opponents**: We'll adapt and defect in response, minimizing our losses.
* **Mixed strategies**: By reacting to the majority's behavior, we can handle a mix of cooperative and defective actions.

**Tournament Performance:**

In a tournament setting, our Adaptive Tit-for-Tat with Stock Consideration strategy is expected to perform well against independent strategies. Its adaptability and responsiveness to the game state will enable it to thrive in a dynamic environment with diverse opponent behaviors.
'''

description_COLLECTIVE_541 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

ASP aims to balance individual payoffs with collective sustainability, ensuring the common pool resource remains viable throughout the game.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) if stock ≥ capacity/2; otherwise, Defect (D).
	* This rule encourages initial cooperation when the stock is relatively high, promoting a sustainable start.
2. **Subsequent Rounds (t>1):**
	* If the previous round's total consumption was ≤ capacity/2:
		+ Cooperate if your previous payoff was ≥ average payoff of all players.
		+ Defect otherwise.
	* If the previous round's total consumption was > capacity/2:
		+ Cooperate if stock ≥ capacity/4; otherwise, Defect.

**Rationale:**

1. By cooperating when the stock is high or when others have been cooperative, we promote sustainability and encourage others to do the same.
2. When the stock is low or others have defected heavily, defecting becomes a more viable option to secure individual payoffs.
3. The comparison with average payoff in subsequent rounds helps ASP adapt to changing circumstances and adjust its strategy accordingly.

**Edge Cases:**

1. **Last Round (t=r):** Always Defect (D).
	* In the final round, there is no need to conserve the stock for future rounds, so defecting maximizes individual payoffs.
2. **Low Stock (stock < capacity/4):** Always Defect (D) unless it's the first round and the stock is exactly at capacity/2.
	* When the stock is critically low, prioritizing individual payoffs becomes essential to avoid being left with nothing.

**Collective Mindset:**

ASP aligns with a collective mindset by:

1. Encouraging cooperation when the stock is high or others have been cooperative.
2. Adapting to changing circumstances and adjusting its strategy accordingly.
3. Prioritizing sustainability over individual gains in most cases, ensuring the common pool resource remains viable throughout the game.

**Pseudocode:**
```python
def ASP(stock, capacity, t, history):
    if t == 1:
        return C if stock >= capacity/2 else D
    
    prev_total_consumption = sum(history[-1]['consumption'])
    
    if prev_total_consumption <= capacity/2:
        avg_payoff = sum(player['payoff'] for player in history[-1]) / len(history[-1])
        return C if history[-1][self_id]['payoff'] >= avg_payoff else D
    
    return C if stock >= capacity/4 else D

def get_action(stock, capacity, t, history):
    self_id = # current player's ID
    action = ASP(stock, capacity, t, history)
    
    if t == r:  # last round
        return D
    
    if stock < capacity/4:
        if t == 1 and stock == capacity/2:
            return C
        return D
    
    return action
```
Note that this pseudocode assumes a `history` data structure containing information about previous rounds, including each player's actions, payoffs, and consumption. The actual implementation will depend on the specific game environment and programming language used.
'''

description_COLLECTIVE_542 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Awareness (ACSA)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Stock-Aware Cooperation**: In subsequent rounds, cooperate if:
	* The current stock level is above 50% of the capacity (stock ≥ 0.5 \* capacity).
	* The average payoff from the previous round is greater than or equal to the average payoff when all players cooperate (π_avg ≥ π_coop).
3. **Defection Threshold**: Defect if:
	* The current stock level falls below 25% of the capacity (stock < 0.25 \* capacity).
	* More than half of the opponents defected in the previous round.
4. **Adaptive Response**: If an opponent defects while ACSA is cooperating, ACSA will defect in the next round.

**Edge Cases:**

1. **Last Round**: Defect in the last round to maximize individual payoff, as there are no future rounds to consider.
2. **Low Stock Levels**: When stock levels are critically low (stock < 0.1 \* capacity), cooperate to allow for some growth and minimize depletion.
3. **Opponent Homogeneity**: If all opponents use the same strategy, ACSA will adapt by cooperating if the opponent is cooperative and defecting otherwise.

**Collective Mindset:**

ACSA aims to balance individual self-interest with collective sustainability. By considering both current stock levels and past payoffs, ACSA encourages cooperation when it benefits the group while adapting to potential exploitation by opponents.

**Pseudocode:**
```
function ACSA(current_stock, capacity, previous_payoffs, opponent_actions)
  if first_round
    return Cooperate (C)
  
  stock_threshold = 0.5 * capacity
  avg_payoff_coop = calculate_avg_payoff_coop(capacity)
  
  if current_stock >= stock_threshold && average_previous_payoff >= avg_payoff_coop
    return Cooperate (C)
  elsif opponent_defected_last_round || low_stock_level(current_stock, capacity)
    return Defect (D)
  else
    return Adapt(opponent_actions)
end

function Adapt(opponent_actions)
  if any opponent defected last round
    return Defect (D)
  else
    return Cooperate (C)
end
```
This strategy is designed to be robust and adaptive, taking into account both the current state of the game and past actions. By prioritizing cooperation when it benefits the group while adapting to exploitation, ACSA aims to achieve a balance between individual self-interest and collective sustainability.
'''

description_COLLECTIVE_543 = '''
**Collective Strategy: Adaptive Cooperation with Stock-based Trigger (ACST)**

The ACST strategy aims to balance individual payoffs with collective sustainability by adapting cooperation based on the current stock level and the history of opponent actions.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative tone and maximize initial payoffs.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 25% and 75% of capacity, cooperate with probability p = (current_stock / capacity) ^ 2. Otherwise, Defect (D).
	* If the current stock level is below 25% of capacity, Defect (D) to maximize individual payoffs in a depleted environment.
3. **Opponent Action-based Adaptation:**
	* Track the number of opponents who defected in the previous round (num_defectors_prev).
	* If num_defectors_prev > n/2, increase the probability of defecting in the current round by 20% (i.e., p_defect += 0.2). This discourages cooperation when most opponents are defecting.
4. **Stock-based Trigger:**
	* If the stock level drops below a certain threshold (e.g., 50% of capacity) and remains low for a specified number of rounds (e.g., 3), switch to unconditional Defection (D) until the stock recovers.

**Pseudocode:**
```
function ACST(stock, capacity, num_players, round_number, previous_actions):
    if round_number == 1:
        return Cooperate
    elif stock > 0.75 * capacity:
        return Cooperate
    elif stock >= 0.25 * capacity and stock < 0.75 * capacity:
        p_cooperate = (stock / capacity) ^ 2
        return random_choice([Cooperate, Defect], [p_cooperate, 1-p_cooperate])
    else:
        return Defect
    
    # Opponent action-based adaptation
    num_defectors_prev = count_defectors(previous_actions)
    if num_defectors_prev > num_players / 2:
        p_defect += 0.2
    
    # Stock-based trigger
    if stock < 0.5 * capacity and low_stock_rounds >= 3:
        return Defect
```
**Edge Cases:**

* In the last round, Defect (D) to maximize individual payoffs.
* If all opponents are known to always cooperate or defect, adjust the strategy accordingly (e.g., defect against unconditional cooperators).
* If the game has a large number of rounds, consider introducing a " forgiveness" mechanism to gradually increase cooperation after periods of mutual defection.

**Collective Mindset:**
ACST prioritizes collective sustainability while adapting to individual circumstances. By cooperating when the stock is high and defecting when it's low, ACST balances short-term gains with long-term sustainability. The strategy also takes into account opponent actions, discouraging cooperation when most opponents are defecting.
'''

description_COLLECTIVE_544 = '''
To design a collective strategy for this Common Pool Resource Game, I propose a adaptive and robust approach that balances individual payoffs with collective sustainability. This strategy, called "Adaptive Cooperation" (AC), is based on monitoring the game's state and history to adjust its behavior.

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to establish a baseline for cooperation and observe other players' behaviors.
2. **State-Dependent Cooperation**: For subsequent rounds, calculate the "Stock Depletion Rate" (SDR) as the average stock reduction over the last 3 rounds. If SDR is below a threshold (e.g., 20%), play C to maintain a sustainable stock level. Otherwise, play Defect (D) to maximize individual payoffs.
3. **History-Based Adjustment**: Monitor the number of players who defected in the previous round (D_prev). If D_prev > n/2 (i.e., more than half of the players defected), switch to playing D for 1-2 rounds to punish free riders and adjust the game's dynamics.
4. **Payoff-Based Adaptation**: Calculate the "Payoff Differential" (PD) as the difference between individual payoffs when playing C versus D in the previous round. If PD > 0 (i.e., cooperating yields higher payoffs), increase the SDR threshold by 5% for the next round to encourage cooperation.

**Edge Cases:**

1. **Last Round**: In the final round, play D to maximize individual payoffs, as there is no future benefit from cooperation.
2. **Low Stock Levels**: If the current stock level falls below a critical threshold (e.g., 20% of capacity), play C to prevent stock depletion and ensure some payoff.

**Collective Mindset:**

The Adaptive Cooperation strategy aligns with a collective mindset by:

1. Prioritizing sustainability through state-dependent cooperation.
2. Adjusting behavior based on the actions of other players to maintain a balance between individual payoffs and collective well-being.
3. Gradually adapting its decision-making process to respond to changing game dynamics.

**Pseudocode:**
```python
def adaptive_cooperation(n, capacity, stock, history):
    # Initialize variables
    sdr_threshold = 0.2  # Stock Depletion Rate threshold (20%)
    pd_threshold = 0  # Payoff Differential threshold

    # Initial round
    if len(history) == 0:
        return "C"

    # Calculate Stock Depletion Rate (SDR)
    sdr = sum(stock_decrease for stock_decrease in history[-3:]) / 3

    # State-dependent cooperation
    if sdr < sdr_threshold:
        return "C"
    else:
        return "D"

    # History-based adjustment
    d_prev = sum(1 for action in history[-1] if action == "D")
    if d_prev > n / 2:
        return "D" for _ in range(1, 3)

    # Payoff-based adaptation
    pd = payoff_c - payoff_d
    if pd > pd_threshold:
        sdr_threshold += 0.05

    return "C" or "D"
```
This strategy is designed to be adaptive and robust, responding to changing game dynamics while prioritizing collective sustainability. By monitoring the game's state and history, it balances individual payoffs with collective well-being, making it a strong competitor in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_545 = '''
**Collective Strategy: Adaptive Cooperation with Stock Threshold (ACST)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about other players' behavior.
2. **Stock Threshold**: Define a stock threshold `θ` as a fraction of the capacity, e.g., θ = 0.7 \* capacity. If the current stock level is above this threshold, cooperate (C). Otherwise, defect (D).
3. **Opponent Behavior Monitoring**: Keep track of the number of opponents who defected in the previous round (`defectors_prev`). If `defectors_prev` > n/2, defect (D) in the next round.
4. **Punishment Mechanism**: Implement a simple punishment mechanism to deter repeated defection: if an opponent has defected for two consecutive rounds, cooperate (C) in the next round.

**Edge Case Handling:**

1. **Last Round**: In the final round, defect (D) as there is no future benefit from cooperation.
2. **Low Stock Levels**: If the stock level falls below a certain threshold (e.g., 0.2 \* capacity), cooperate (C) to conserve resources and allow for potential regrowth.

**Collective Mindset Alignment:**

1. **Cooperate when possible**: ACST prioritizes cooperation whenever the stock level is above the threshold, promoting collective benefits.
2. **Adapt to opponent behavior**: By monitoring opponents' actions, ACST adjusts its strategy to maintain a balance between cooperation and self-protection.
3. **Punish repeated defection**: The punishment mechanism discourages persistent defection, encouraging players to cooperate for mutual benefit.

**Pseudocode:**
```markdown
# Initialize variables
θ = 0.7 * capacity
defectors_prev = 0

# Main loop (each round)
current_stock = get_current_stock()
if current_round == 1:
    # Initial round cooperation
    action = C
elif current_stock > θ * capacity:
    # Cooperate above stock threshold
    action = C
else:
    # Defect below stock threshold or if many opponents defected previously
    if defectors_prev > n/2:
        action = D
    else:
        action = C

# Update opponent behavior tracking
defectors_prev = count_defectors_in_previous_round()

# Apply punishment mechanism (optional)
if has_opponent_defected_twice():
    action = C

# Perform chosen action and update stock level
perform_action(action)
update_stock_level()
```
ACST is designed to be robust, adaptive, and aligned with a collective mindset. By balancing cooperation and self-protection, this strategy aims to achieve a high total payoff in the tournament against various independent strategies.
'''

description_COLLECTIVE_546 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and prioritizes sustainability:

**Strategy Name:** Adaptive Sustainability (AS)

**Decision Rules:**

1. **Initial Rounds (t = 1 to r/4):**
	* Cooperate (C) if stock level is above 75% of capacity.
	* Defect (D) otherwise.
2. **Mid-Game (t = r/4 + 1 to 3r/4):**
	* Assess the average consumption rate of all players in the previous round (t-1).
	* If the average consumption rate is below 50% of capacity, Cooperate (C).
	* Otherwise, Defect (D) with a probability proportional to the current stock level (higher stock levels increase the likelihood of Defection).
3. **Late Game (t = 3r/4 + 1 to r):**
	* If the current stock level is below 25% of capacity, Cooperate (C) to avoid depletion.
	* Otherwise, apply the mid-game rule.

**Edge Cases:**

* In the first round, Cooperate (C) if the initial stock level is above 75% of capacity; otherwise, Defect (D).
* In the last round, always Defect (D) to maximize individual payoff.

**Collective Mindset Alignment:**

AS prioritizes sustainability by:

1. Encouraging cooperation when the stock level is high.
2. Adapting to opponent behaviors and adjusting consumption rates accordingly.
3. Protecting the common pool from depletion in the late game.

By following this strategy, AS promotes a collective mindset that balances individual interests with the need for sustainable resource management.

**Pseudocode:**
```python
def AdaptiveSustainability(n, r, capacity, stock_history):
  # Initialize variables
  t = current_round()
  avg_consumption_rate = calculate_average_consumption(stock_history)
  stock_level = get_current_stock()

  if t <= r/4:
    # Initial rounds
    if stock_level >= 0.75 * capacity:
      return COOPERATE
    else:
      return DEFECT

  elif t > r/4 and t < 3r/4:
    # Mid-game
    if avg_consumption_rate < 0.5 * capacity:
      return COOPERATE
    else:
      defect_probability = (stock_level / capacity) ** 2
      return random_choice([COOPERATE, DEFECT], [1 - defect_probability, defect_probability])

  else:
    # Late game
    if stock_level < 0.25 * capacity:
      return COOPERATE
    else:
      return mid_game_rule(avg_consumption_rate)

  # Last round
  if t == r:
    return DEFECT

# Helper functions
def calculate_average_consumption(stock_history):
  # Calculate average consumption rate of all players in the previous round
  ...

def get_current_stock():
  # Get current stock level
  ...
```
AS can be implemented as an algorithm and tested against other strategies in a tournament setting.
'''

description_COLLECTIVE_547 = '''
**Collective Strategy: "Adaptive Stock Guardian"**

The Adaptive Stock Guardian strategy aims to balance individual payoffs with collective sustainability of the common pool resource. This strategy adapts to the game state and history, responding to opponents' actions while prioritizing long-term stock preservation.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe the initial stock level.
	* Cooperate (C) if the capacity is high (> 150% of the number of players), indicating a robust common pool.
	* Defect (D) otherwise, to establish an individual advantage in case others cooperate excessively.
2. **Middle Rounds (t > 1)**:
	* Evaluate the current stock level and its trend over previous rounds.
	* Cooperate (C) if:
		+ The stock is above a "safety threshold" (e.g., 75% of capacity).
		+ The number of cooperators in the previous round exceeds half of the total players.
	* Defect (D) otherwise, to either exploit others' cooperation or adapt to an increasingly depleted stock.
3. **Late Rounds (t = r-1 or t = r)**:
	* Analyze the accumulated payoffs and remaining stock level.
	* Cooperate (C) if:
		+ The total payoff for all players is above a "fair share threshold" (e.g., 50% of the total capacity).
		+ The remaining stock can sustain at least one more round with moderate consumption.
	* Defect (D) otherwise, to secure an individual advantage before the game concludes.

**Handling Edge Cases:**

* If two or more players are tied for the highest payoff in a previous round, prioritize cooperation to maintain social stability and encourage continued collective behavior.
* In the event of an extremely low stock level (< 25% of capacity), defect (D) to maximize individual gain from the remaining resource.

**Pseudocode:**
```markdown
function AdaptiveStockGuardian(current_stock, history, t, r):
    # Initial Round
    if t == 1:
        if capacity > 150 * n:
            return C  # Cooperate in initial round with high capacity
        else:
            return D  # Defect otherwise

    # Middle Rounds
    safety_threshold = 0.75 * capacity
    cooperators_prev_round = count_cooperators(history[-1])
    if current_stock > safety_threshold and cooperators_prev_round >= n / 2:
        return C  # Cooperate with sufficient stock and cooperation
    else:
        return D  # Defect otherwise

    # Late Rounds
    fair_share_threshold = 0.5 * capacity
    total_payoff = sum_payoffs(history)
    if total_payoff > fair_share_threshold and current_stock >= moderate_consumption:
        return C  # Cooperate with sufficient payoffs and remaining stock
    else:
        return D  # Defect otherwise

    # Tiebreaker or extremely low stock
    if tied_for_highest_payoff(history) or current_stock < 0.25 * capacity:
        return D  # Defect in these edge cases
```
This strategy balances short-term gains with long-term sustainability, adapting to the evolving game state and history while maintaining a collective mindset.
'''

description_COLLECTIVE_548 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** Adaptive Collective Harvesting (ACH)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation from others.
2. **Stock-Dependent Cooperation**: In subsequent rounds, cooperate if the current stock level is above a threshold (T), which is dynamically adjusted based on the game's history.

   - Calculate T as: T = capacity × (1 - (total consumption in previous round / capacity))

   This formula ensures that cooperation occurs when the stock level is relatively high, allowing for sustainable harvesting.

3. **Defection Response**: If at least one opponent defected in the previous round, and the current stock level is below T, defect (D) to protect your share.
4. **History-Based Adaptation**: Adjust your cooperation threshold (T) based on the game's history:

   - If the average payoff per player over the last few rounds (> 2n) has been above a certain percentage of the maximum possible payoff (e.g., 80%), increase T by a small amount (ΔT).
   - Conversely, if the average payoff is below this threshold, decrease T by ΔT.

   This adaptation mechanism helps maintain cooperation when payoffs are relatively high and adjusts to more competitive behavior when payoffs decline.

**Pseudocode:**
```python
# Initialize variables
stock = capacity  # initial stock level
T = capacity * (1 - (2n / capacity))  # initial cooperation threshold

for round in range(r):
    if round == 0:
        action = C  # cooperate in the first round
    else:
        previous_round_payoffs = [π_i for i in range(n)]
        total_consumption = sum(consumption_i for i in range(n))
        
        if stock > T and all(π_i >= π_min for π_i in previous_round_payoffs):
            action = C  # cooperate when stock is high and payoffs are sufficient
        elif any(defection detected) or stock <= T:
            action = D  # defect in response to opponents' defection or low stock

    consume(stock, action)
    
    # Update cooperation threshold (T) based on game history
    if round > 2n and average_payoff_over_last_few_rounds() >= payoff_threshold:
        T += ΔT
    elif round > 2n and average_payoff_over_last_few_rounds() < payoff_threshold:
        T -= ΔT

# Helper functions
def consume(stock, action):
    # Update stock level based on player actions
    if action == C:
        consumption = stock / (2n)
    else:
        consumption = stock / n
    
    total_consumption += consumption
    stock -= total_consumption
    
    # Stock growth and new stock calculation
    S_remaining = stock
    growth = 2 * S_remaining * (1 - S_remaining/capacity)
    new_stock = min(S_remaining + growth, capacity)

def average_payoff_over_last_few_rounds():
    # Calculate the average payoff over the last few rounds (> 2n)
    pass

def payoff_threshold():
    # Return a certain percentage of the maximum possible payoff (e.g., 80%)
    pass
```
**Edge Cases:**

* In the **last round**, always defect to maximize your final payoff, as cooperation will not benefit you in subsequent rounds.
* If an opponent's action is **unknown or unobserved**, assume they defected and adjust your strategy accordingly.

By employing this Adaptive Collective Harvesting (ACH) strategy, players can adapt to a wide range of opponent behaviors while maintaining a collective mindset.
'''

description_COLLECTIVE_549 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Trigger (ACS-T)**

ACS-T is a dynamic, state-dependent strategy that balances individual self-interest with collective sustainability in the Common Pool Resource game.

**Decision Rules:**

1. **Initial Rounds**: In the first round, cooperate (C) to establish a baseline for future interactions and encourage cooperation from others.
2. **Stock-Based Trigger**: Monitor the current stock level (S). If S is above a certain threshold (T), cooperate; otherwise, defect. The threshold T is dynamically adjusted based on the game's history:

   - Initialize T with a high value (e.g., 0.8 × capacity).
   - After each round, update T using a moving average of the stock levels over the past few rounds (e.g., 3-5 rounds). This helps adapt to changing environmental conditions.
3. **Defection Threshold**: If more than half of the players defected in the previous round, or if the current stock level is critically low (S < 0.2 × capacity), defect to minimize losses and avoid further depletion.

**Pseudocode:**
```python
def ACS_T(stock, capacity, history):
    # Initial rounds
    if len(history) == 0:
        return 'C'

    # Stock-based trigger
    threshold = 0.8 * capacity
    for i in range(1, min(len(history), 5)):
        threshold = (threshold + history[-i][0]) / (i + 1)

    if stock > threshold:
        return 'C'
    else:
        # Defection threshold
        previous_round_defections = sum([1 if action == 'D' else 0 for action in history[-1][1:]])
        if previous_round_defections > len(history[-1]) / 2 or stock < 0.2 * capacity:
            return 'D'
        else:
            return 'C'

# Game loop
while True:
    current_stock = get_current_stock()
    actions = [ACS_T(current_stock, capacity, game_history) for _ in range(n)]
    game_history.append((current_stock, actions))
```

**Rationale:**

* By initially cooperating and adjusting the threshold based on the stock level, ACS-T encourages cooperation while being responsive to changes in the environment.
* The moving average update mechanism allows the strategy to adapt to shifting conditions and avoid over-reacting to short-term fluctuations.
* Defecting when more than half of the players defected previously or when the stock is critically low minimizes losses and helps prevent catastrophic depletion.

**Collective Mindset:**

ACS-T prioritizes collective sustainability by:

1. Initially cooperating to establish a cooperative baseline.
2. Adapting to changes in the environment to maintain a balance between individual self-interest and collective well-being.
3. Defecting only when necessary to avoid losses or catastrophic depletion, rather than unconditionally pursuing individual gains.

By incorporating both cooperation and adaptation mechanisms, ACS-T aims to achieve a robust and sustainable collective outcome in the Common Pool Resource game.
'''

description_COLLECTIVE_550 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) with a probability of 0.5 to establish a moderate level of trust and gather information about opponents' behaviors.
2. **General Case:** Assess the current state of the stock and the history of actions taken by all players.

a. If the current stock is above 75% of capacity, Cooperate (C) with a probability of 0.7 to maintain a sustainable harvest level.

b. If the current stock is between 50% and 75% of capacity, Cooperate (C) with a probability of 0.5 to balance individual payoff with collective sustainability.

c. If the current stock is below 50% of capacity, Defect (D) with a probability of 0.7 to maximize individual payoff in a potentially depleted environment.

d. If more than half of the players defected in the previous round, Defect (D) with a probability of 0.8 to avoid being exploited by overly aggressive opponents.

3. **Edge Cases:**

a. **Last Round:** Defect (D) to maximize individual payoff since there are no future consequences.

b. **Early Rounds (t < 5):** Cooperate (C) with a higher probability (0.6) to establish a foundation for sustainable harvesting and encourage cooperation among opponents.

c. **Late Rounds (t > r/2):** Gradually increase the Defect probability by 10% every two rounds, up to a maximum of 0.8, to adapt to potentially declining stock levels.

**Pseudocode:**
```python
def adaptive_cooperative_harvesting(stock, capacity, num_players, round_number):
    # Initial Round
    if round_number == 1:
        return random.choice([C, D], p=[0.5, 0.5])

    # General Case
    stock_ratio = stock / capacity
    if stock_ratio > 0.75:
        return C with probability 0.7
    elif 0.5 <= stock_ratio <= 0.75:
        return C with probability 0.5
    else:
        return D with probability 0.7

    # Opponent Analysis
    opponent_defection_rate = count_opponent_defections(previous_round)
    if opponent_defection_rate > 0.5:
        return D with probability 0.8

    # Edge Cases
    if round_number == num_rounds:
        return D
    elif round_number < 5:
        return C with probability 0.6
    elif round_number > num_rounds / 2:
        defect_probability = min(0.8, defect_probability + 0.1)
        return D with probability defect_probability

return adaptive_cooperative_harvesting(stock, capacity, num_players, round_number)
```
This collective strategy balances individual payoff with collective sustainability by adapting to the current state of the stock and opponent behaviors. By incorporating a probabilistic approach, ACH allows for flexibility in decision-making while maintaining a robust response to various opponent strategies.
'''

description_COLLECTIVE_551 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

ACST is a dynamic strategy that adapts to the game state and history, balancing individual payoffs with collective sustainability.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to initiate a cooperative tone and maximize initial payoff.
2. **Subsequent Rounds**: Calculate the current stock-based threshold (`SBT`) as:

`SBT = capacity / (2n * (r - t + 1))`

where `t` is the current round number.

* If the current stock level (`S`) is above or equal to `SBT`, Cooperate (C).
* Otherwise, Defect (D).

**Rationale**: As the game progresses and rounds decrease, the threshold decreases, allowing for more cooperation when the stock is relatively high. When the stock is low, defecting becomes more attractive to ensure individual payoff.

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round (`t = r`), as there are no future rounds to consider.
2. **Low Stock**: If the current stock level (`S`) falls below a certain percentage (e.g., 20%) of the capacity, Defect (D) to avoid depleting the resource.
3. **Opponent Cooperation**: Monitor opponents' cooperation rates and adjust `SBT` accordingly:
	* If most opponents cooperate, decrease `SBT` by 10% to encourage more cooperation.
	* If few or no opponents cooperate, increase `SBT` by 10% to focus on individual payoff.

**Pseudocode:**
```
ACSTStrategy(stock, capacity, n, r, t) {
  if (t == 1) { // Initial round
    return C;
  }

  SBT = capacity / (2 * n * (r - t + 1));
  if (stock >= SBT) {
    return C;
  } else {
    return D;
  }
}

// Edge cases
if (t == r) { // Last round
  return D;
}
if (stock < 0.2 * capacity) { // Low stock
  return D;
}

// Opponent cooperation adjustment
opponent_cooperation_rate = monitorOpponents();
if (opponent_cooperation_rate > 0.7) {
  SBT *= 0.9; // decrease threshold
} else if (opponent_cooperation_rate < 0.3) {
  SBT *= 1.1; // increase threshold
}
```
ACST is a collective strategy that balances individual payoffs with collective sustainability by adapting to the game state and history. By considering the stock level, number of rounds remaining, and opponent cooperation rates, ACST aims to promote cooperation while ensuring a robust performance in a wide range of scenarios.
'''

description_COLLECTIVE_552 = '''
**Collective Strategy: Adaptive Common Pool Resource Management (ACPRM)**

The ACPRM strategy aims to balance individual payoffs with collective sustainability by adapting to changing game conditions and opponent behaviors.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' initial actions.
2. **Cooperation Threshold**: Define a cooperation threshold `τ` based on the number of players (`n`) and capacity (`capacity`). Set `τ = 0.5 * n / capacity`.
3. **Stock-Based Cooperation**: Cooperate (C) if the current stock level is above or equal to `τ * capacity`. This ensures that when the stock is relatively high, cooperation is more likely.
4. **Opponent Adaptation**: Track opponents' actions over time and calculate a defection rate (`δ`) for each opponent. Defect (D) if an opponent's `δ` exceeds 0.5 in the last `r/2` rounds. This adapts to frequent defectors and deters exploitation.
5. **Payoff-Based Adaptation**: Monitor individual payoffs over time. If your average payoff is below the group average by more than 10% in the last `r/4` rounds, defect (D) for one round to signal dissatisfaction and adjust opponents' behaviors.
6. **Endgame Cooperation**: In the last two rounds (`r-1` and `r`), cooperate (C) regardless of previous actions or stock levels. This ensures that all players contribute to a sustainable ending.

**Pseudocode**
```python
def ACPRM(n, capacity, r, current_stock, opponent_actions, individual_payoffs):
    # Initialize cooperation threshold τ
    tau = 0.5 * n / capacity
    
    # Determine cooperation based on stock level and opponent actions
    if current_stock >= tau * capacity:
        cooperate = True
    else:
        cooperate = False
        
    # Adapt to opponents' behaviors
    for opponent in opponent_actions:
        delta = sum(opponent[-r//2:]) / (r // 2)
        if delta > 0.5:
            cooperate = False
            break
    
    # Adjust based on individual payoffs
    avg_payoff = sum(individual_payoffs[-r//4:]) / (r // 4)
    group_avg_payoff = sum([sum(player_payoffs) for player_payoffs in individual_payoffs]) / n
    if avg_payoff < group_avg_payoff * 0.9:
        cooperate = False
    
    # Endgame cooperation
    if r <= 2:
        cooperate = True
    
    return cooperate
```
**Edge Cases**

* First round: Always cooperate (C) to establish a baseline.
* Last two rounds (`r-1` and `r`): Cooperate (C) regardless of previous actions or stock levels.

**Collective Mindset**
The ACPRM strategy prioritizes collective sustainability by adapting to changing game conditions and opponent behaviors. By cooperating when the stock level is high and adapting to opponents' behaviors, ACPRM promotes cooperation while maintaining individual competitiveness. In the endgame, cooperation ensures a sustainable conclusion for all players.
'''

description_COLLECTIVE_553 = '''
**Collective Strategy: Adaptive Cooperative Threshold (ACT)**

The ACT strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the game's state and history.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **State-Dependent Cooperation**: In subsequent rounds, calculate the current stock level (S) and the number of players that cooperated in the previous round (n_C). If S is above a certain threshold (θ), cooperate; otherwise, defect.

Pseudocode:
```
if round == 1:
    action = C
else:
    n_C = count(cooperators_last_round)
    θ = capacity / (2 * n) * (1 + (n_C / n))
    if S > θ:
        action = C
    else:
        action = D
```
**Adaptive Threshold**: The threshold θ is adjusted based on the number of cooperators in the previous round. If many players cooperate, θ increases, making cooperation more likely; conversely, if few players cooperate, θ decreases, making defection more attractive.

**Edge Cases**

1. **Last Round**: In the final round, defect (D) to maximize individual payoff, as there is no future benefit from cooperation.
2. **Low Stock Levels**: If S falls below a minimum threshold (φ), defect to ensure some payoff; φ can be set to a small fraction of capacity (e.g., 0.1 * capacity).

**Collective Mindset**

The ACT strategy prioritizes collective sustainability by:

1. Encouraging cooperation when the stock level is healthy.
2. Gradually reducing cooperation as the stock level declines, allowing for some individual payoff while maintaining a sustainable stock level.
3. Allowing for adaptation to changing opponent behaviors through the state-dependent threshold.

By adopting this adaptive and robust strategy, ACT aims to achieve a balance between individual payoffs and collective sustainability in the Common Pool Resource Game.
'''

description_COLLECTIVE_554 = '''
To design a collective strategy for this Common Pool Resource Game, I propose a hybrid approach that balances individual payoff maximization with sustainable stock management. Our strategy, called "Adaptive Sustainability" (AS), combines elements of cooperation and defection to ensure long-term viability.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to establish a baseline for future adaptations.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play a mixed strategy: Cooperate with probability p = (current stock / capacity) ^ 2, and Defect with probability 1 - p.
	* If the current stock level is below 50% of capacity, defect (D).
3. **Last Round (t=r)**: Always cooperate (C) to ensure maximum collective payoff.

**Adaptation Mechanism:**

After each round, update the cooperation probability p based on the average opponent behavior in the previous round:

* If the average opponent action is Cooperate, increase p by 0.1.
* If the average opponent action is Defect, decrease p by 0.1.

This adaptation mechanism allows AS to adjust its cooperation level in response to changing opponent behaviors.

**Pseudocode:**
```markdown
function AdaptiveSustainability(current_stock, capacity, t, r):
    if t == 1:
        return Cooperate
    
    stock_ratio = current_stock / capacity
    if stock_ratio > 0.75:
        return Cooperate
    elif 0.5 <= stock_ratio < 0.75:
        p = (stock_ratio) ^ 2
        return random.choice([Cooperate, Defect], p=[p, 1-p])
    else:
        return Defect
    
    # Last round special case
    if t == r:
        return Cooperate

function update_cooperation_probability(p, avg_opponent_action):
    if avg_opponent_action == Cooperate:
        p += 0.1
    elif avg_opponent_action == Defect:
        p -= 0.1
    return max(0, min(p, 1))  # Clamp probability to [0, 1] range
```
**Rationale:**

AS balances individual payoff maximization with sustainable stock management by:

* Cooperating in the initial round to establish a baseline for future adaptations.
* Adapting cooperation levels based on current stock levels and opponent behavior.
* Defecting when the stock level is critically low to maximize short-term payoffs.
* Cooperating in the last round to ensure maximum collective payoff.

By incorporating both cooperative and defective elements, AS promotes sustainable resource management while remaining robust to a wide range of opponent behaviors. This strategy should perform well in a tournament setting where various strategies are employed.
'''

description_COLLECTIVE_555 = '''
Here's a collective strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Collective Harvesting (ACH)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline stock level and encourage cooperation.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 25% and 75% of capacity:
		+ If the average payoff per player in the previous round was below 50% of the maximum possible payoff, Defect (D) to increase personal gain.
		+ Otherwise, Cooperate (C) to maintain a sustainable stock level.
	* If the current stock level is below 25% of capacity, Defect (D) to maximize personal gain before the game ends.
3. **Last Round (t=r):** Defect (D) to extract as much value as possible from the remaining stock.

**Additional Considerations:**

* Monitor the average payoff per player and adjust cooperation/defection accordingly. If opponents are consistently defecting, it may be beneficial to defect more frequently to protect personal interests.
* Keep track of the number of players who defected in previous rounds. If a significant portion of players defected, increase the frequency of defection in subsequent rounds.

**Pseudocode:**
```
function ACH(stock, capacity, n, t, r, history):
  if t == 1:
    return C
  elif stock > 0.75 * capacity:
    return C
  elif 0.25 * capacity <= stock <= 0.75 * capacity:
    avg_payoff = calculate_average_payoff(history)
    if avg_payoff < 0.5 * max_payoff:
      return D
    else:
      return C
  elif stock < 0.25 * capacity:
    return D
  elif t == r:
    return D

function calculate_average_payoff(history):
  total_payoff = sum(history.payoffs)
  return total_payoff / len(history.payoffs)

def max_payoff(capacity, n):
  return capacity / (2 * n)
```
**Collective Mindset:**
The ACH strategy prioritizes cooperation when the stock level is high or moderate, aiming to maintain a sustainable resource base. As the game progresses and opponents' behaviors are revealed, the strategy adapts by increasing defection rates in response to exploitation. By balancing individual interests with collective sustainability, ACH promotes a cooperative atmosphere while protecting against opportunistic behavior.

**Edge Cases:**

* In the first round, cooperation is chosen to establish a baseline stock level and encourage cooperation.
* In the last round, defection is chosen to extract as much value as possible from the remaining stock.
* When the stock level falls below 25% of capacity, defection becomes more frequent to maximize personal gain before the game ends.

**Tournament Readiness:**
ACH is designed to be robust against a wide range of opponent behaviors and does not rely on coordination mechanisms or predetermined patterns. Its adaptive nature allows it to respond effectively to various strategies in a tournament setting.
'''

description_COLLECTIVE_556 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACS-T)**

**Decision Rules:**

1. **Initial Rounds:** Cooperate in the first two rounds to establish a cooperative tone and gather information about opponents' behavior.
2. **Stock-Based Threshold:** Set a dynamic threshold `T` based on the current stock level `S`. When the stock is above this threshold, cooperate; otherwise, defect.

   Pseudocode:
   ```
if (S > T) {
    action = C // Cooperate
} else {
    action = D // Defect
}
```
3. **Threshold Calculation:** Update `T` every round based on the current stock level and the average payoff of all players in the previous round.

   Pseudocode:
   ```
T = (S + avg_payoff_prev_round * capacity / (2n)) / 2
```

4. **Opponent Behavior Adaptation:** Adjust cooperation probability based on observed opponent behavior. Maintain a count of opponents' cooperative actions (`coop_count`) and update it every round.

   Pseudocode:
   ```
if (S > T) {
    coop_prob = min(1, coop_count / n)
} else {
    coop_prob = 0
}
action = random choice(C or D) based on coop_prob
```

5. **Last Round:** Defect in the last round to maximize individual payoff.

**Edge Cases:**

*   If the stock level drops below a certain threshold (`min_stock`, e.g., `capacity / (4n)`), defect immediately to avoid depletion.
*   In case of a tie in the opponent behavior adaptation, prioritize cooperation.

**Collective Mindset Alignment:**

ACS-T aims to balance individual and collective interests by adapting cooperation based on stock levels and opponent behavior. By cooperating when the stock is above the threshold and adjusting to opponents' actions, ACS-T promotes a collaborative environment while minimizing the risk of exploitation.

**Robustness and Adaptability:**

ACS-T's dynamic threshold and adaptation mechanisms allow it to respond effectively to various opponent strategies, from purely cooperative or defective to more complex behaviors. By focusing on stock levels and average payoffs, ACS-T maintains a collective mindset while prioritizing individual interests when necessary.

In the tournament setting, ACS-T will compete against other independent strategies, showcasing its adaptability and robustness in a wide range of scenarios.
'''

description_COLLECTIVE_557 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' behaviors.
2. **Stock-based Cooperation**: In subsequent rounds, cooperate if the current stock level is above 75% of the capacity. This encourages conservation when the stock is relatively healthy.
3. **Defection Threshold**: Defect (D) if at least two players defected in the previous round or if the stock level falls below 25% of the capacity. This responds to potential exploitation by others and prevents over-depletion.
4. **Adaptive Cooperation**: If exactly one player defected in the previous round, cooperate with a probability of 0.5 (random choice). This introduces an element of unpredictability while still promoting cooperation.

**Edge Case Handling:**

1. **Last Round**: Defect in the last round to maximize individual payoff, as there is no future stock depletion concern.
2. **Low Stock Levels**: If the stock level falls below 10% of the capacity, always defect to ensure some personal gain before the game ends.
3. **Uniform Cooperation**: If all players have cooperated for three consecutive rounds, cooperate in the next round. This maintains cooperation momentum when all players are cooperating.

**Pseudocode:**
```markdown
def ASC(n, capacity, stock, history):
  if round == 1:
    return C
  elif stock > 0.75 * capacity:
    return C
  elif (at least two players defected in previous round) or (stock < 0.25 * capacity):
    return D
  elif exactly one player defected in previous round:
    return random_choice([C, D])
  elif round == last_round:
    return D
  elif stock < 0.1 * capacity:
    return D
  elif all_players_cooperated_previous_three_rounds():
    return C
```
**Collective Mindset:**

The ASC strategy prioritizes cooperation when the common pool is relatively healthy and adapts to potential exploitation by others. By introducing randomness in response to single defections, it creates an element of unpredictability while maintaining a collective focus on stock conservation. The strategy balances individual interests with collective well-being, promoting a sustainable approach to the game.

**Robustness:**

The ASC strategy is designed to be robust against various opponent behaviors:

* **Free Riders**: By responding to multiple defections, ASC discourages free riding.
* **Cooperative Opponents**: ASC maintains cooperation momentum when all players cooperate.
* **Random or Mixed Strategies**: ASC's adaptive nature allows it to respond effectively to unpredictable opponents.

This strategy should perform well in a tournament setting against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_558 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to changing stock levels and opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' actions.
2. **Stock-Dependent Cooperation**: For rounds 2 to r-1, cooperate if the current stock level is above 75% of capacity; otherwise, defect. This rule ensures that when the stock is plentiful, players conserve it by cooperating, but when it's scarce, they prioritize individual payoffs by defecting.
3. **Opponent-Adaptive Defection**: Monitor opponents' actions and adjust your strategy based on their behavior:
	* If more than half of opponents defected in the previous round, defect in the current round to protect against exploitation.
	* If most opponents cooperated, cooperate in the current round to maintain collective sustainability.
4. **Last Round**: Defect (D) in the final round, as there's no future stock to conserve and individual payoffs are prioritized.

**Pseudocode:**
```
function ASC(n, r, capacity, stock_history, opponent_actions):
  if round == 1:
    return C
  elif stock > 0.75 * capacity:
    return C
  else:
    defect_count = sum(opponent_defected for opponent in opponent_actions)
    if defect_count > n/2:
      return D
    else:
      return C

  # Last round special case
  if round == r:
    return D
```
**Edge Cases:**

* If the stock is exactly at 75% capacity, cooperate to maintain sustainability.
* In cases where opponents' actions are unknown or uncertain (e.g., due to imperfect information), default to cooperating to prioritize collective sustainability.

**Collective Mindset:**
The ASC strategy aligns with a collective mindset by:

1. Prioritizing cooperation when the stock is plentiful, ensuring long-term sustainability for all players.
2. Adapting to opponents' behaviors, allowing the strategy to respond to changes in the game environment and maintain fairness.
3. Balancing individual payoffs with collective conservation, promoting a mutually beneficial outcome.

By following the ASC strategy, players can effectively manage the common pool resource while adapting to various opponent behaviors, ultimately achieving a more sustainable and equitable outcome for all participants.
'''

description_COLLECTIVE_559 = '''
**Collective Strategy: Adaptive Tit-for-Two-Tats (ATFT)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) with a probability of 0.5 and Defect (D) with a probability of 0.5. This allows us to gather information about the opponents' strategies without revealing too much about our own.
2. **Subsequent Rounds**:
	* If the stock level is above 75% of the capacity, cooperate (C).
	* If the stock level is between 50% and 75% of the capacity, play Tit-for-Tat (TFT): cooperate if most opponents cooperated in the previous round, defect otherwise.
	* If the stock level is below 50% of the capacity, play Tit-for-Two-Tats: cooperate if at least two opponents cooperated in the previous round, defect otherwise.

**Pseudocode**
```markdown
function ATFT(stock_level, opponent_actions_history):
    if (round == 1):  # Initial Round
        return random.choice([C, D])
    elif (stock_level >= 0.75 * capacity):  # High stock level
        return C
    elif (0.5 * capacity <= stock_level < 0.75 * capacity):  # Medium stock level
        most_opponents_cooperated = sum(opponent_actions_history[-1]) / n > 0.5
        return C if most_opponents_cooperated else D
    else:  # Low stock level
        at_least_two_cooperated = sum(opponent_actions_history[-2:]) / (2 * n) >= 0.5
        return C if at_least_two_cooperated else D
```
**Rationale**

Our strategy aims to balance short-term gains with long-term sustainability of the common pool resource.

1. In the initial round, we randomize our action to gather information about opponents' strategies.
2. When the stock level is high, cooperation ensures that everyone benefits from the abundant resource while minimizing over-consumption.
3. At medium stock levels, we use TFT to encourage cooperation among most players, assuming they will reciprocate if most others cooperate.
4. When the stock level is low, ATFT kicks in: we only cooperate if at least two opponents cooperated in the previous rounds. This ensures that our cooperation won't be exploited by multiple defectors.

**Collective Mindset**

Our strategy prioritizes collective well-being over individual short-term gains:

1. By cooperating when the stock level is high or medium, we help maintain a sustainable resource for everyone.
2. When faced with low stock levels, ATFT encourages opponents to cooperate, promoting collective conservation of the resource.

This strategy should be robust against various opponent behaviors and adaptive in responding to changing game conditions, while aligning with the collective mindset to conserve the common pool resource.
'''

description_COLLECTIVE_560 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Sensitive Tit-for-Tat (ACST)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to follow suit.
2. **Subsequent Rounds**:
	* If the stock level is above 75% of capacity, cooperate (C). This encourages sustainable harvesting and maintains a healthy stock level.
	* If the stock level falls between 50% and 75% of capacity, play Tit-for-Tat (TFT) with a twist: defect (D) if at least one opponent defected in the previous round, otherwise cooperate (C). This adaptively responds to opponents' behavior while still prioritizing cooperation.
	* If the stock level drops below 50% of capacity, defect (D) to ensure some payoff and prevent further depletion. However, if all players cooperated in the previous round, cooperate (C) in this round to try to restore a sustainable trajectory.
3. **Last Round**: Defect (D) in the final round to maximize individual payoff, as there are no future rounds to consider.

**Handling Edge Cases:**

* If an opponent defects while the stock is above 75% of capacity, still cooperate (C) in the next round to maintain a positive trajectory.
* If multiple opponents defect simultaneously, prioritize cooperating (C) with those who cooperated previously and defecting (D) against those who defected before.

**Collective Mindset Alignment:**

ACST prioritizes cooperation when the stock is healthy, adaptively responds to opponents' behavior, and ensures some payoff when the stock is depleted. This strategy balances individual interests with collective sustainability, aligning with the common goal of maintaining a robust stock level over multiple rounds.

Pseudocode for ACST:
```
Function ACST(current_stock, capacity, num_players, previous_round_actions):
  If first round or all players cooperated previously and current_stock > 0.75 * capacity:
    Return Cooperate (C)
  ElseIf current_stock >= 0.5 * capacity:
    If any opponent defected in previous round:
      Return Defect (D)
    Else:
      Return Cooperate (C)
  Else: // current_stock < 0.5 * capacity
    If all players cooperated previously:
      Return Cooperate (C)
    Else:
      Return Defect (D)

Function play_round(current_stock, capacity, num_players, previous_round_actions):
  action = ACST(current_stock, capacity, num_players, previous_round_actions)
  // Update stock level based on actions of all players
  new_stock = update_stock_level(current_stock, action, num_players)
  Return new_stock
```
This strategy should perform well in a tournament setting against various independent strategies, as it balances cooperation with adaptability and ensures some payoff when the stock is depleted.
'''

description_COLLECTIVE_561 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Aware Tit-for-Tat (ACSTAT)**

Decision Rules:

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline of cooperation and encourage others to reciprocate.
2. **Subsequent Rounds**: Implement an adaptive Tit-for-Tat strategy, modified to account for stock levels:
	* If the previous round's total consumption was below 50% of the capacity, cooperate (C).
	* If the previous round's total consumption was above 75% of the capacity, defect (D) to avoid over-exploitation.
	* In all other cases, mirror the most common action taken by opponents in the previous round.
3. **Stock-Aware Adjustment**: Adjust the Tit-for-Tat strategy based on the current stock level:
	* If the stock is below 25% of capacity, defect (D) to maximize short-term gains.
	* If the stock is above 75% of capacity, cooperate (C) to ensure sustainable exploitation.

Pseudocode:
```python
def ACSTAT(n, r, capacity, history):
    if round == 1:  # Initial Round
        return "Cooperate"
    
    prev_total_consumption = sum(history[-1]['consumptions'])
    stock_level = history[-1]['stock']
    
    if prev_total_consumption < 0.5 * capacity:
        return "Cooperate"
    elif prev_total_consumption > 0.75 * capacity:
        return "Defect"
    else:
        opponent_actions = [h['action'] for h in history[-2:]]
        most_common_opponent_action = max(set(opponent_actions), key=opponent_actions.count)
        return most_common_opponent_action
    
    if stock_level < 0.25 * capacity:
        return "Defect"
    elif stock_level > 0.75 * capacity:
        return "Cooperate"
```
Edge Cases:

* **Last Round**: In the final round, defect (D) to maximize short-term gains.
* **Opponent Defection**: If an opponent defects in a previous round, mirror their action in the next round.

Collective Mindset Alignment:

ACSTAT is designed to balance individual interests with collective sustainability. By adapting to stock levels and opponents' actions, ACSTAT aims to maintain a stable and cooperative environment while allowing for strategic flexibility. This approach acknowledges that cooperation can be beneficial in the long run but also recognizes the need for self-interest-driven decision-making.

In the tournament setting, ACSTAT's adaptability will enable it to respond effectively to various opponent strategies, promoting a robust and resilient collective outcome.
'''

description_COLLECTIVE_562 = '''
**Collective Strategy: Adaptive Cooperate-Defect (ACD)**

The ACD strategy is designed to balance individual payoff maximization with collective sustainability, adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: In the first round, cooperate (C) unconditionally to establish a cooperative tone and maximize initial payoffs.
2. **High Stock Levels**: If the current stock level is above 75% of capacity, cooperate (C). This ensures sustainable consumption and encourages cooperation among others.
3. **Medium Stock Levels**: If the current stock level is between 25% and 75% of capacity:
	* If at least half of the players cooperated in the previous round, cooperate (C).
	* Otherwise, defect (D) to maximize individual payoffs while maintaining some pressure on the stock.
4. **Low Stock Levels**: If the current stock level is below 25% of capacity, defect (D). This prioritizes short-term gains when sustainability is compromised.
5. **Endgame**: In the last round, cooperate (C) if the stock level is above 50% of capacity; otherwise, defect (D).

**Edge Cases:**

* If all players have defected in a previous round, and the current stock level is critically low (<10% of capacity), cooperate (C) to avoid collapse.
* In cases where a player's cooperation would lead to an extremely low payoff (<10% of average payoff), defect (D) to ensure minimal returns.

**Collective Mindset:**

The ACD strategy aligns with the collective mindset by:

* Cooperating when stock levels are high or stable, promoting sustainability and cooperation.
* Defecting strategically to maintain pressure on the stock and prevent over-exploitation.
* Adapting to the actions of others, reflecting a willingness to cooperate if others do so.

**Pseudocode:**
```
function ACDStrategy(stock, history, round):
  if round == 1:
    return COOPERATE
  elif stock >= 0.75 * capacity:
    return COOPERATE
  elif 0.25 <= stock/capacity < 0.75:
    prev_coop = sum(history[-1] == COOPERATE for history[-1] in players) / n
    if prev_coop >= 0.5:
      return COOPERATE
    else:
      return DEFECT
  elif stock/capacity < 0.25:
    return DEFECT
  elif round == r:  # last round
    if stock >= 0.5 * capacity:
      return COOPERATE
    else:
      return DEFECT

# Edge cases
if all(history[-1] == DEFECT for history[-1] in players) and stock < 0.1 * capacity:
  return COOPERATE
elif cooperation_payoff < 0.1 * average_payoff:
  return DEFECT
```
This strategy balances individual interests with collective sustainability, adapting to the game's state and history. By cooperating when possible and defecting strategically, ACD promotes a stable and profitable common pool resource management system.
'''

description_COLLECTIVE_563 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) with a probability of 0.5. This allows us to gauge the opponent's behavior while also conserving some stock.
2. **Subsequent Rounds:**
	* If the current stock is below 50% of the capacity, Defect (D) with a probability of 1 - (current_stock / capacity). This helps to prevent over-depletion and encourages others to conserve.
	* If the current stock is above 50% of the capacity:
		+ Cooperate (C) if the average payoff of cooperators in the previous round is higher than that of defectors. This promotes cooperation when it's beneficial.
		+ Defect (D) otherwise, with a probability of 0.5 + (average_defector_payoff - average_cooperator_payoff) / (2 \* capacity). This adapts to opponents' behaviors and avoids exploitation.
3. **Last Round:** Cooperate (C) unconditionally, as there's no future stock to conserve.

**Edge Cases:**

1. **Tie-breaking:** In cases where the decision rule yields a tie (e.g., equal probabilities for C and D), choose Cooperate (C).
2. **Zero Stock:** If the current stock is zero, Defect (D) with probability 1, as there's no stock to conserve.

**Collective Mindset:**

The ASC strategy prioritizes collective well-being by:

1. Conserving stock when necessary.
2. Adapting to opponents' behaviors to prevent exploitation.
3. Promoting cooperation when beneficial.
4. Avoiding over-depletion and encouraging sustainable consumption.

By following these decision rules, the ASC strategy aims to achieve a balance between individual payoffs and collective sustainability, making it robust against various opponent behaviors.

**Pseudocode:**
```
function AdaptiveStockConservation(current_stock, capacity, round_number, previous_round_payoffs):
  if round_number == 1:
    # Initial Round
    cooperate_prob = 0.5
  else:
    if current_stock < 0.5 * capacity:
      # Defect to prevent over-depletion
      defect_prob = 1 - (current_stock / capacity)
    else:
      # Adapt to opponents' behaviors
      avg_cooperator_payoff = average payoff of cooperators in previous round
      avg_defector_payoff = average payoff of defectors in previous round
      if avg_cooperator_payoff > avg_defector_payoff:
        cooperate_prob = 1
      else:
        defect_prob = 0.5 + (avg_defector_payoff - avg_cooperator_payoff) / (2 * capacity)
  
  # Last Round: Cooperate unconditionally
  if round_number == total_rounds:
    return C
  
  # Tie-breaking and zero stock handling
  if cooperate_prob == defect_prob:
    return C
  elif current_stock == 0:
    return D
  
  # Return action based on probabilities
  if random() < cooperate_prob:
    return C
  else:
    return D
```
This pseudocode provides a basic implementation of the ASC strategy, which can be refined and optimized as needed.
'''

description_COLLECTIVE_564 = '''
**Collective Strategy: Adaptive Cooperative Harvesting (ACH)**

**Overview**
ACH is a collective strategy that balances individual short-term gains with long-term sustainability of the common pool resource. It adapts to the game state and history, cooperating when possible and defecting when necessary to maintain a stable stock level.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and minimize initial stock depletion.
2. **Stock-Based Cooperation**: If the current stock level is above 75% of capacity, cooperate (C). This ensures that the stock remains sustainable while allowing for some individual gain.
3. **Defection Threshold**: If the current stock level falls below 50% of capacity, defect (D) to maximize individual payoff in the short term.
4. **Recent History-Based Adjustment**: Analyze the actions of other players over the last 2-3 rounds:
	* If most players cooperated, cooperate (C) in the next round to maintain a sustainable stock level.
	* If most players defected, defect (D) in the next round to protect individual interests.
5. **Adaptive Adjustment**: Adjust cooperation/defection probability based on recent game history and stock levels:
	* Increase cooperation probability if the stock level is increasing or stable.
	* Decrease cooperation probability if the stock level is decreasing.

**Pseudocode**
```python
def ACH(n, capacity, stock_history, action_history):
  # Initial round: Cooperate
  if len(action_history) == 0:
    return 'C'

  # Stock-based cooperation
  current_stock = stock_history[-1]
  if current_stock > 0.75 * capacity:
    return 'C'

  # Defection threshold
  if current_stock < 0.5 * capacity:
    return 'D'

  # Recent history-based adjustment
  recent_cooperation_rate = sum(action == 'C' for action in action_history[-3:]) / 3
  if recent_cooperation_rate > 0.6:
    return 'C'
  else:
    return 'D'

  # Adaptive adjustment
  cooperation_probability = 0.5  # initial value
  if current_stock > stock_history[-2]:
    cooperation_probability += 0.1
  elif current_stock < stock_history[-2]:
    cooperation_probability -= 0.1
  return 'C' if random.random() < cooperation_probability else 'D'
```
**Collective Mindset**
ACH aligns with the collective mindset by:

* Cooperating when possible to maintain a sustainable stock level.
* Adapting to the game state and history to balance individual interests with long-term sustainability.
* Being robust to a wide range of opponent behaviors, as it does not rely on specific coordination mechanisms or norms.

By implementing ACH, we aim to create a strategy that effectively balances individual short-term gains with collective long-term sustainability in the Common Pool Resource Game.
'''

description_COLLECTIVE_565 = '''
**Collective Strategy: Adaptive Tit-for-Tat with Stock-Based Threshold (ATTS)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) to establish a cooperative baseline and encourage others to do the same.
2. **Subsequent Rounds**:
	* If the current stock level is above a certain threshold (`stock_threshold`), cooperate (C). This threshold is calculated as `stock_threshold = capacity * (1 - 1/n)`, where `n` is the number of players.
	* Otherwise, defect (D).
3. **Tit-for-Tat Component**: If any player defected in the previous round, and the current stock level is above `stock_threshold`, then defect (D) in this round. This ensures that our strategy is responsive to opponents' actions.

**Edge Case Handling:**

1. **Last Round**: Defect (D), as there are no future rounds to consider.
2. **Low Stock Levels**: If the current stock level falls below `stock_threshold`, defect (D) to avoid further depletion and minimize losses.

**Pseudocode:**
```python
def ATTS(stock, capacity, n, history):
    if round == 1:
        return C  # Cooperate in initial round
    
    stock_threshold = capacity * (1 - 1/n)
    
    if stock >= stock_threshold:
        if any(defector for defector in history[-1]):
            return D  # Tit-for-Tat: defect if opponent defected last round
        else:
            return C  # Cooperate if no opponents defected last round
    else:
        return D  # Defect if stock level is low

def get_history(n):
    # Initialize history as a list of lists, where each inner list represents a round
    history = [[] for _ in range(n)]
    
    # Fill history with actions from previous rounds (C or D)
    # This implementation assumes access to the game's state and action history
    
    return history

def ATTS_strategy(stock, capacity, n):
    history = get_history(n)
    action = ATTS(stock, capacity, n, history)
    return action
```
**Collective Mindset Alignment:**

The ATTS strategy is designed to balance individual self-interest with collective sustainability. By cooperating when the stock level is above a certain threshold, we encourage others to do the same and maintain a healthy common pool. The Tit-for-Tat component ensures that our strategy adapts to opponents' actions, deterring defectors and promoting cooperation.

This strategy should perform well in a tournament setting, as it:

1. Encourages cooperation when possible
2. Adapts to opponents' actions
3. Balances individual self-interest with collective sustainability

By using the stock level as a threshold for cooperation, our strategy is robust to various opponent behaviors and can adjust its behavior accordingly.
'''

description_COLLECTIVE_566 = '''
**Collective Strategy: "Adaptive Stock Guardian" (ASG)**

The ASG strategy aims to balance individual payoffs with collective sustainability by adaptively responding to the game's state and history.

**Decision Rules:**

1. **First Round:** Cooperate (C) to establish a cooperative tone and gather information about opponents' behaviors.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play a mixed strategy:
		+ With probability p = (current_stock / capacity) ^ 2, Cooperate (C); otherwise, Defect (D).
	* If the current stock level is below 50% of capacity, Defect (D).

**Rationale:**

* By cooperating in the first round, we encourage opponents to cooperate and establish a baseline for the game's progression.
* When the stock level is high, cooperation is more likely to maintain a sustainable resource.
* As the stock level decreases, the mixed strategy allows us to adapt to potential over-exploitation by others while still considering our own payoff. The probability of cooperating (p) increases as the stock level approaches capacity, making it more likely that we'll cooperate when the resource is relatively abundant.
* When the stock level falls below 50% of capacity, defection becomes a more attractive option to maximize individual payoffs.

**Edge Cases:**

* **Last Round:** Defect (D), as there's no future benefit in cooperating and individual payoffs become the primary concern.
* **Zero or Negative Stock:** Cooperate (C) to avoid further depletion and allow for potential stock growth.

**Collective Mindset:**

The ASG strategy prioritizes collective sustainability while adapting to opponents' behaviors. By responding to the game's state and history, we aim to create a self-sustaining system where cooperation is encouraged when resources are abundant, but individual interests are protected when resources become scarce. This approach aligns with the collective mindset by considering both short-term and long-term consequences of our actions.

Pseudocode:
```
Function AdaptiveStockGuardian(current_stock, capacity, round_number):
  if round_number == 1:
    return Cooperate (C)
  else:
    if current_stock >= 0.75 * capacity:
      return Cooperate (C)
    elif 0.5 * capacity <= current_stock < 0.75 * capacity:
      p = (current_stock / capacity) ^ 2
      return RandomChoice([Cooperate (C), Defect (D)], [p, 1-p])
    else:
      return Defect (D)

Function LastRound(current_stock, capacity):
  return Defect (D)

Function ZeroOrNegativeStock(current_stock, capacity):
  return Cooperate (C)
```
This strategy will be refined and implemented as an algorithm for the tournament.
'''

description_COLLECTIVE_567 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Awareness (ACSA)**

ACSA is a collective strategy that balances individual interests with collective well-being by adapting to the game's state and history. This approach ensures robustness against various opponent behaviors while promoting cooperation.

**Decision Rules:**

1. **First Round:** Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' initial moves.
2. **Subsequent Rounds:** Calculate the current stock level as a fraction of the capacity, denoted as `stock_fraction = current_stock / capacity`.
3. **Cooperation Threshold:** Define a cooperation threshold, `theta`, which is a function of the number of players (n) and rounds (r). A suitable value for `theta` could be `theta = 0.5 + (1/n) * (r/2)`. This formula ensures that the threshold increases as the game progresses and more players are involved.
4. **Adaptive Cooperation:** Cooperate if:
	* The current stock fraction is above the cooperation threshold (`stock_fraction > theta`).
	* At least one opponent defected in the previous round, and the current stock level is sufficient to sustain cooperative consumption (i.e., `current_stock >= 2n * stock/(2n)`).
5. **Defection Conditions:** Defect if:
	* The cooperation threshold is not met (`stock_fraction <= theta`).
	* Multiple opponents defected in the previous round, and the current stock level is low (i.e., `current_stock < n * stock/n`).

**Pseudocode:**
```python
def ACSA(current_stock, capacity, n, r, history):
    # First round cooperation
    if len(history) == 0:
        return 'C'

    # Calculate cooperation threshold
    theta = 0.5 + (1/n) * (r/2)

    # Calculate current stock fraction
    stock_fraction = current_stock / capacity

    # Check for cooperation conditions
    if stock_fraction > theta and \
       (any(opponent == 'D' for opponent in history[-1]) or
        current_stock >= 2n * stock/(2n)):
        return 'C'

    # Check for defection conditions
    elif multiple_opponents_defected(history) and \
         current_stock < n * stock/n:
        return 'D'

    # Default to cooperation if unsure
    else:
        return 'C'
```
**Handling Edge Cases:**

* **Last Round:** In the final round, prioritize individual payoff maximization by defecting (D), as there is no future game state to consider.
* **Ties in Cooperation Threshold:** In cases where the stock fraction equals the cooperation threshold, err on the side of caution and cooperate.

**Collective Mindset:**

ACSA prioritizes collective well-being while adapting to individual opponent behaviors. By incorporating a dynamic cooperation threshold, this strategy balances short-term gains with long-term sustainability, ensuring robust performance against various opponents in a tournament setting.
'''

description_COLLECTIVE_568 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Stock-Based Threshold:** Introduce a dynamic threshold, `stock_threshold`, calculated as 75% of the current stock level (`S`). This threshold will determine when to cooperate or defect.

```
stock_threshold = 0.75 * S
```

3. **Cooperation Zone:** If the total consumption in the previous round is below the `stock_threshold`, Cooperate (C). This indicates that the group is managing the resource sustainably, and cooperation is beneficial.
4. **Defection Zone:** If the total consumption in the previous round exceeds the `stock_threshold`, Defect (D). This suggests that the group is over-exploiting the resource, and defecting will help to prevent further depletion.

```
if total_consumption_prev_round < stock_threshold:
    action = C
else:
    action = D
```

5. **Selfishness Adjustment:** To adapt to potential defectors, introduce a `selfishness_factor` (SF) that adjusts the threshold based on the proportion of players who defected in the previous round.

```
SF = (number_of_defectors_prev_round / n)
stock_threshold_adjusted = stock_threshold * (1 - SF)
```

6. **Last Round:** In the final round, Cooperate (C) to maximize the total payoff and maintain a positive reputation.

**Edge Cases:**

* If all players cooperated in the previous round, maintain cooperation.
* If the stock level is critically low (`S < 2n`), Defect (D) to ensure some payoff.
* In case of a tie (equal number of cooperators and defectors), Cooperate (C) to promote cooperation.

**Collective Mindset:**

The ACST strategy prioritizes collective well-being by:

1. Encouraging cooperation when the stock level is sustainably managed.
2. Adjusting to opponents' behavior through the `selfishness_factor`.
3. Maintaining a positive reputation by cooperating in the final round.

By adapting to the game state and history, ACST aims to achieve a balance between individual payoff maximization and collective resource management. This strategy should perform well against various opponent behaviors, promoting cooperation while being robust to potential exploitation.
'''

description_COLLECTIVE_569 = '''
To design a collective strategy for this game that is adaptive and robust to various opponent behaviors, I propose the following decision rules:

**Initial Round (t=1)**:
In the first round, play Cooperate (C). This allows us to observe how other players behave initially and sets a positive tone for potential cooperation.

**General Decision Rule (t>1)**:
For each subsequent round t, consider the following factors:

* **Stock level**: If the current stock is below 25% of capacity, always Defect (D) to maximize personal payoff in a depleted resource environment.
* **Opponent behavior**: Analyze the actions taken by opponents in the previous round. Calculate the ratio of Cooperate (C) to total actions:
	+ If this ratio is above 0.5, indicating a majority of players cooperated, play Cooperate (C) to contribute to the collective well-being.
	+ Otherwise, play Defect (D) to take advantage of the situation.
* **Historical stock trend**: Evaluate the average rate of change in stock levels over the past few rounds (e.g., 3-5 rounds). If the stock is increasing or stable, play Cooperate (C). If it's decreasing, play Defect (D) to secure personal payoffs.

Pseudocode:
```
if t == 1:
    action = C
else:
    if current_stock < 0.25 * capacity:
        action = D
    else:
        opponent_coop_ratio = count(C in prev_round_actions) / n
        if opponent_coop_ratio > 0.5:
            action = C
        else:
            action = D

        # Optional: consider historical stock trend
        avg_stock_change = (current_stock - prev_stock) / rounds_considered
        if avg_stock_change >= 0:
            action = C
        else:
            action = D
```
**Additional Considerations**:

* **Last Round**: In the final round, always Defect (D), as there is no future stock to preserve.
* **Tie-breaking**: If the decision rule yields a tie between Cooperate and Defect, default to Cooperate to maintain a cooperative posture.

This strategy balances individual self-interest with collective well-being by adapting to changing circumstances and opponent behaviors. By incorporating elements of both cooperation and defection, it aims to achieve robust performance in a wide range of scenarios.
'''

description_COLLECTIVE_570 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)**

The ACST strategy balances individual self-interest with collective sustainability by adapting cooperation levels based on the current stock level and historical observations.

**Decision Rules:**

1. **First Round:** Cooperate (C) to establish a cooperative tone and gather information about opponents' behavior.
2. **Subsequent Rounds:** Observe the previous round's:
	* Total consumption
	* Stock growth
	* Opponents' actions (count of C and D)
3. Calculate the current stock-based threshold, `T`, as:

`T = capacity / (2 * n) * (1 - (stock / capacity))`

This threshold adjusts based on the remaining stock level and the number of players.

4. **Cooperation Rule:** If the previous round's total consumption was below the threshold (`T`), cooperate (C). Otherwise, defect (D).
5. **Exception:** If an opponent has defected in the last two consecutive rounds, defect (D) to punish and deter exploitation.
6. **Last Round:** Defect (D) if the stock level is below 50% of capacity; otherwise, cooperate (C).

**Pseudocode:**
```python
def ACST(n, capacity, stock, history):
    # First round
    if len(history) == 0:
        return C

    # Calculate threshold
    T = capacity / (2 * n) * (1 - (stock / capacity))

    # Observe previous round's actions and consumption
    prev_consumption = sum([a.consumption for a in history[-1]])
    opponent_actions = [a.action for a in history[-1]]

    # Cooperation rule
    if prev_consumption < T:
        return C

    # Punish exploitation
    if any(a.action == D for a in opponent_actions[-2:]):
        return D

    # Last round
    if len(history) == r - 1:
        if stock < capacity * 0.5:
            return D
        else:
            return C

    # Default to defect
    return D
```
**Collective Mindset:** By adapting cooperation levels based on the current stock level and historical observations, ACST promotes collective sustainability while allowing for individual self-interest. The strategy rewards cooperative behavior and punishes exploitation, aligning with the collective mindset.

This strategy is robust against a wide range of opponent behaviors, as it:

* Adapts to changes in the game state
* Punishes exploitation
* Cooperates when beneficial
* Defects when necessary

By following this strategy, ACST aims to achieve a balance between individual payoffs and collective sustainability in the Common Pool Resource Game.
'''

description_COLLECTIVE_571 = '''
To design a collective strategy for this Common Pool Resource Game, I'll introduce "Adaptive Stock Conservation" (ASC), a decision-making approach that balances individual payoffs with long-term sustainability.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Stock-Based Threshold**: Introduce a dynamic threshold, `stock_threshold`, which is a function of the current stock level (`S`) and capacity (`capacity`). When `S` falls below this threshold, ASC switches from cooperation to defection.

   `stock_threshold = capacity * (1 - (n-1)/n)`

   This threshold ensures that when the stock is relatively high, players are more likely to cooperate. As the stock dwindles, players become more cautious and tend towards defection.
3. **Opponent Behavior Analysis**: Monitor opponents' past actions and calculate a "Cooperation Ratio" (`CR`) for each opponent.

   `CR_i = (number of times opponent i cooperated) / total rounds`

   When an opponent's `CR` falls below a certain threshold (`cr_threshold`, e.g., 0.5), ASC assumes that opponent is likely to defect and adjusts its strategy accordingly.
4. **Adaptive Cooperation**: Based on the current stock level, opponents' cooperation ratios, and the number of remaining rounds, ASC adapts its cooperation probability.

   `cooperation_probability = (S / capacity) * (1 - (n-1)/n) * (CR_avg + 0.5)`

   where `CR_avg` is the average cooperation ratio among all opponents.
5. **Defection in Final Round**: In the last round, ASC defects (D) to maximize individual payoff, as there are no future rounds to consider.

**Pseudocode:**
```python
def adaptive_stock_conservation(n, capacity, stock, round_num, opponent_actions):
    # Initial Round
    if round_num == 1:
        return "C"

    # Stock-Based Threshold
    stock_threshold = capacity * (1 - (n-1)/n)
    if stock < stock_threshold:
        return "D"

    # Opponent Behavior Analysis
    cr_threshold = 0.5
    opponent_cr = [analyze_cooperation_ratio(opponent_actions[i]) for i in range(n)]
    cr_avg = sum(opponent_cr) / n

    # Adaptive Cooperation
    cooperation_probability = (stock / capacity) * (1 - (n-1)/n) * (cr_avg + 0.5)
    if random.random() < cooperation_probability:
        return "C"
    else:
        return "D"

    # Defection in Final Round
    if round_num == r:
        return "D"
```
**Collective Mindset:**
ASC aims to strike a balance between individual payoffs and collective sustainability. By adapting to the current stock level, opponents' behaviors, and remaining rounds, ASC promotes cooperation when it is likely to benefit both individual players and the group as a whole.

In a tournament setting, ASC's adaptive nature allows it to respond effectively to various opponent strategies, including pure cooperators, defectors, and other adaptive approaches.
'''

description_COLLECTIVE_572 = '''
**Collective Strategy: "Adaptive Stock Conservation" (ASC)**

The ASC strategy balances individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round, as there is no information about opponents' behaviors.
2. **Early Game**: In rounds 2-5, play C if the stock level is above 75% of capacity; otherwise, Defect (D). This allows for initial exploration and adaptation to opponents' strategies while conserving stock.
3. **Mid-Game**: After round 5, switch to a more cautious approach:
	* If the average payoff per player in the last 2 rounds is below the game's theoretical optimum (i.e., 50% of capacity), play D; otherwise, play C. This adjusts behavior based on recent collective performance.
4. **Endgame**: In the last 3 rounds, prioritize stock conservation by playing C if the current stock level is above 25% of capacity; otherwise, Defect.

**Edge Cases:**

1. **Zero Stock**: If the stock reaches zero at any point, play D in all subsequent rounds, as cooperation no longer provides a benefit.
2. **Near-Capacity Stock**: When the stock exceeds 90% of capacity, play C to avoid over-exploitation and promote sustainability.

**Collective Mindset:**

The ASC strategy aligns with the collective mindset by:

1. Prioritizing stock conservation in critical situations (e.g., low stock levels).
2. Encouraging cooperation when opponents appear to be conserving stock.
3. Gradually adjusting behavior based on recent collective performance, allowing for adaptation to changing opponent strategies.

**Pseudocode:**
```python
def ASC(n, capacity, r):
    # Initialize variables
    stock = capacity
    avg_payoff = 0

    for round in range(r):
        if round == 0:
            action = C  # Cooperate in the first round
        elif round < 5:
            action = C if stock > 0.75 * capacity else D
        else:
            if avg_payoff < 0.5 * capacity:
                action = D
            else:
                action = C

        if stock == 0:
            action = D
        elif stock > 0.9 * capacity:
            action = C

        # Update variables based on opponents' actions and game state
        # ...

    return action
```
This strategy balances individual payoffs with collective sustainability by adapting to the game's state and history, while avoiding over-exploitation and promoting cooperation when beneficial.
'''

description_COLLECTIVE_573 = '''
**Collective Strategy: Adaptive Tit-for-Two-Tats with Stock-Based Threshold**

This strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1): Cooperate**
Start with cooperation to establish a baseline for reciprocity and encourage others to cooperate.
2. **Subsequent Rounds (t>1):**
a. Calculate the average stock depletion rate over the last two rounds:

`avg_depletion = (stock[t-1] - stock[t-2] + stock[t-2] - stock[t-3]) / 2`

b. If `avg_depletion` is above a certain threshold (`θ`), **Defect**. Otherwise, **Cooperate**.

The threshold `θ` is calculated as:

`θ = (capacity / n) * (1 - (t / r))`

This ensures that the threshold decreases over time, making the strategy more cautious about stock depletion as the game progresses.
3. **Exception:** If the current stock level is below a certain fraction (`α`) of the capacity, **Cooperate** regardless of the average depletion rate.

`α = 0.25 (or any other value between 0 and 1)`

This ensures that players cooperate when the stock is severely depleted to prevent its collapse.
4. **Tit-for-Two-Tats Mechanism:**
a. Keep track of the number of consecutive rounds where at least one opponent defected (`defect_streak`).
b. If `defect_streak` reaches 2, **Defect** for one round to punish opponents and reset `defect_streak`.
c. After punishing, return to the regular decision rule based on average depletion rate.

This mechanism encourages cooperation by responding to defections while avoiding an endless cycle of retaliation.

**Edge Cases:**

1. **Last Round (t=r): Cooperate**
Ensure that the game ends with a cooperative move to maximize collective payoffs.
2. **Single Opponent:** Treat a single opponent as multiple opponents, and apply the same decision rules.

By implementing this strategy, players will:

* Initially cooperate to establish reciprocity
* Adaptively respond to changes in stock depletion rates and opponent behaviors
* Punish repeated defections while avoiding perpetual retaliation
* Prioritize cooperation when the stock is severely depleted
* Ensure collective sustainability by balancing individual payoffs with stock conservation

This strategy should perform well against a variety of opponent behaviors, promoting a balance between individual self-interest and collective welfare.
'''

description_COLLECTIVE_574 = '''
**Collective Strategy: Adaptive Cooperation with Dynamic Threshold (ACDT)**

ACDT is a collective strategy that balances individual payoffs with long-term sustainability of the common pool resource. The goal is to maintain a stable stock level while adapting to various opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and encourage others to do the same.
2. **Stock-Based Threshold**: Define a dynamic threshold `T` based on the current stock level `S` and capacity `capacity`. When `S` is above `T`, cooperate; otherwise, defect.

   Pseudocode:
   ```
   T = capacity * (1 - 1/(2n))
   if S > T:
       action = C
   else:
       action = D
```

3. **History-Based Adjustment**: Adjust the threshold `T` based on the average stock growth over the last few rounds (`k` rounds, e.g., `k=5`). If the average growth is positive, decrease `T` to encourage more cooperation; if negative, increase `T` to reduce consumption.

   Pseudocode:
   ```
   avg_growth = (sum(stock_growth_last_k_rounds) / k)
   if avg_growth > 0:
       T *= 0.9
   else:
       T *= 1.1
```

4. **Opponent Behavior Response**: Observe the average cooperation rate of opponents (`coop_rate`) over the last few rounds (`k` rounds). If `coop_rate` is high (above a certain threshold, e.g., 0.7), increase the likelihood of cooperating; if low, decrease it.

   Pseudocode:
   ```
   coop_rate = (sum(coop_actions_last_k_rounds) / (n * k))
   if coop_rate > 0.7:
       action_prob_C += 0.1
   else:
       action_prob_C -= 0.1
```

5. **Last Round**: Defect in the last round, as there is no future benefit to cooperation.

**Edge Cases:**

* If `S` equals `capacity`, cooperate to maintain the stock level.
* If `S` equals 0, defect, as there is nothing to consume.

**Collective Mindset Alignment:**
ACDT prioritizes sustainability and adaptability while encouraging cooperation. By adjusting its behavior based on the current state and history, ACDT promotes a collective approach that balances individual payoffs with long-term resource conservation.

This strategy should perform well in a tournament against independent strategies developed by other AI systems, as it is robust to various opponent behaviors and adapts to changing game conditions.
'''

description_COLLECTIVE_575 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy balances individual payoffs with collective sustainability, adapting to the game's dynamic state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline stock level and encourage cooperation.
2. **Stock-Based Cooperation**: Cooperate if the current stock is above 75% of capacity (`stock >= 0.75 * capacity`). This ensures sustainable consumption and growth.
3. **Defection Threshold**: Defect (D) if at least one player defected in the previous round or if the current stock falls below 25% of capacity (`stock < 0.25 * capacity`). This responds to potential free-riding or critical stock levels.
4. **Adaptive Response**: If a player's payoff from cooperation is less than the average payoff of all players in the previous round, switch to defecting (D) for one round to signal dissatisfaction and encourage coordination.

**Edge Cases:**

1. **Last Round**: Defect (D) in the final round to maximize individual payoffs, as there are no future consequences.
2. **Tiebreakers**: In case of a tie between cooperation and defection, prioritize cooperation to maintain collective sustainability.
3. **Stock Depletion**: If the stock is depleted (`stock == 0`), cooperate (C) in the next round to facilitate growth.

**Collective Mindset:**

The ASC strategy prioritizes collective sustainability by:

1. Encouraging cooperation when the stock is healthy
2. Responding to defections and critical stock levels with strategic defection
3. Adapting to changes in player behavior and payoffs

By balancing individual interests with collective responsibility, ASC aims to achieve a robust and sustainable outcome in the tournament.

**Pseudocode:**
```python
def adaptive_stock_conservation(stock, capacity, history):
    if first_round():
        return COOPERATE
    
    if stock >= 0.75 * capacity:
        return COOPERATE
    
    if any_defections(history) or stock < 0.25 * capacity:
        return DEFECT
    
    if payoff_from_cooperation() < average_payoff(history):
        return DEFECT  # signal dissatisfaction
    
    # Tiebreaker: prioritize cooperation
    return COOPERATE

def last_round():
    return DEFECT

def stock_depleted(stock):
    return COOPERATE
```
Note that this pseudocode serves as a high-level representation of the strategy, and implementation details may vary depending on the specific algorithmic requirements.
'''

description_COLLECTIVE_576 = '''
I propose a collective strategy called "Adaptive Stock Preservation" (ASP). ASP aims to balance individual payoffs with the preservation of the common pool stock, ensuring a sustainable and robust approach that adapts to various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for the game's progression and encourage cooperation among players.
2. **Subsequent Rounds:** Calculate the average payoff per player over the past `w` rounds (window size, e.g., `w = 3`). If this average is below a certain threshold (`τ`, e.g., `τ = capacity / (4n)`), Defect (D) to increase individual payoffs. Otherwise, Cooperate (C).
3. **Stock-based Adjustment:** Monitor the current stock level and adjust the decision rule accordingly:
	* If the stock is critically low (`stock < 2n`), Defect (D) to maximize individual payoffs before the game ends.
	* If the stock is high (`stock > capacity - 2n`), Cooperate (C) to preserve the common pool and maintain a sustainable environment.

**Edge Cases:**

1. **Last Round:** Defect (D) in the final round, as there are no future consequences for individual payoffs.
2. **Tie-breaking:** In cases where multiple players have the same average payoff, prioritize cooperation to promote collective well-being.

**Collective Mindset Alignment:**

ASP prioritizes the preservation of the common pool stock while ensuring reasonable individual payoffs. By adapting to the game's progression and opponent behaviors, ASP promotes a balanced approach that benefits both individuals and the collective group.

Pseudocode:
```python
def AdaptiveStockPreservation(stock, capacity, n, r, window_size=3, threshold=None):
    if round == 1:  # Initial Round
        return "Cooperate"

    avg_payoff = calculate_avg_payoff(window_size)
    if avg_payoff < threshold:  # Threshold-based Defection
        return "Defect"
    elif stock < 2n:  # Stock-based Defection
        return "Defect"
    elif stock > capacity - 2n:  # Stock-based Cooperation
        return "Cooperate"

    # Default to cooperation if no other conditions are met
    return "Cooperate"

def calculate_avg_payoff(window_size):
    # Calculate average payoff over past `window_size` rounds
    pass

# Parameters and Initialization
capacity = ...  # Maximum sustainable stock level
n = ...          # Number of players
r = ...          # Number of rounds
stock = capacity  # Initial stock level
```
ASP is designed to be robust, adaptive, and collective-oriented. By incorporating a window-based average payoff calculation and adjusting decisions based on the current stock level, ASP balances individual interests with the preservation of the common pool stock.
'''

description_COLLECTIVE_577 = '''
I propose a collective strategy called "Adaptive Stock Sensitive Tit-for-Tat" (ASST). This strategy balances individual payoffs with the long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to signal willingness to cooperate and to gather information about opponents' strategies.
2. **Stock Level-Based Cooperation:** After the initial round, cooperate if the current stock level is above a certain threshold (`stock_threshold`). This threshold is set as a function of the game parameters: `stock_threshold = capacity / (2 * n)`. If the stock level falls below this threshold, defect (D).
3. **Tit-for-Tat Component:** Introduce a tit-for-tat element to respond to opponents' actions:
	* If at least half of the opponents defected in the previous round, defect in the current round.
	* Otherwise, cooperate if the stock level is above `stock_threshold`, and defect otherwise.

**Edge Cases:**

1. **Last Round:** In the final round, always defect (D) to maximize individual payoff, regardless of the stock level or opponents' actions.
2. **Low Stock Level:** If the current stock level falls below a certain low threshold (`low_stock_threshold = capacity / (4 * n)`), cooperate in all subsequent rounds to help replenish the stock.

**Pseudocode:**
```python
def ASST(n, capacity, r, history):
    # Initialize variables
    stock_threshold = capacity / (2 * n)
    low_stock_threshold = capacity / (4 * n)

    for round in range(1, r+1):
        if round == 1:
            action = 'C'  # Cooperate in the first round
        else:
            previous_round_actions = history[round-1]
            num_defectors = sum(action == 'D' for action in previous_round_actions)
            stock_level = get_current_stock_level()

            if stock_level < low_stock_threshold:
                action = 'C'  # Cooperate to replenish the stock
            elif num_defectors >= n / 2:
                action = 'D'  # Defect if half or more opponents defected last round
            elif stock_level > stock_threshold:
                action = 'C'  # Cooperate if stock level is high enough
            else:
                action = 'D'

        if round == r:  # Last round
            action = 'D'  # Always defect in the final round

        return action
```
**Collective Mindset:** The ASST strategy prioritizes cooperation when the stock level is above a certain threshold, ensuring that individual payoffs do not compromise the long-term sustainability of the common pool resource. By adapting to opponents' actions and responding with tit-for-tat, the strategy promotes a collective mindset, encouraging others to cooperate as well.

This strategy balances short-term gains with long-term cooperation, making it robust against various opponent behaviors in a tournament setting.
'''

description_COLLECTIVE_578 = '''
To design a collective strategy for this Common Pool Resource Game, I propose the "Adaptive Cooperation" (AC) strategy. The AC strategy balances individual self-interest with cooperation, adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round**: Cooperate (C). This establishes a baseline of cooperation and encourages others to reciprocate.
2. **Subsequent Rounds**:
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, play a mixed strategy: cooperate with probability p = (stock / capacity) - 0.5, defect otherwise.
	* If the current stock level is below 50% of capacity, defect (D).

Pseudocode:
```
IF round == 1 THEN
    action = COOPERATE
ELSE
    stock_ratio = stock / capacity
    IF stock_ratio >= 0.75 THEN
        action = COOPERATE
    ELSE IF stock_ratio >= 0.5 THEN
        p = stock_ratio - 0.5
        IF random() < p THEN
            action = COOPERATE
        ELSE
            action = DEFECT
    ELSE
        action = DEFECT
END IF
```
**Rationale:**

* Cooperating in the initial round sets a positive tone and encourages others to cooperate.
* When the stock level is high, cooperation ensures sustainable harvesting and maintains the resource's health.
* As the stock level declines, the mixed strategy allows for adaptation to changing circumstances. Defection becomes more likely as the stock level drops below 50%, reflecting increasing self-interest.
* The probability of cooperation (p) is a function of the stock ratio, making the strategy responsive to changes in the game state.

**Edge Cases:**

* **Last Round**: In the final round, defect (D), as there are no future rounds to consider.
* **Low Stock Levels**: If the stock level drops below 25% of capacity, cooperate (C) to prevent depletion and ensure some remaining resource for future rounds.

**Collective Mindset:**
The Adaptive Cooperation strategy prioritizes cooperation when possible, while adapting to changing circumstances. By cooperating initially and responding to changes in the game state, AC encourages a culture of cooperation among players, even as individual self-interest is considered. This collective approach aims to balance short-term gains with long-term sustainability.

In a tournament setting, the Adaptive Cooperation strategy will compete against other independent strategies. Its adaptive nature allows it to respond effectively to diverse opponent behaviors, while its cooperative foundation promotes mutual benefits and a resilient common pool resource.
'''

description_COLLECTIVE_579 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with probability 0.5, Defect (D) with probability 0.5. This initial randomness helps explore the opponents' strategies.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above a certain threshold (e.g., 75% of capacity), Cooperate (C).
	* If the stock level is below this threshold, Defect (D) with probability proportional to the number of players who defected in the previous round. Specifically:
		+ Let `d_prev` be the number of players who defected in the previous round.
		+ Let `n_defect_prob` be a parameter between 0 and 1 (e.g., 0.3).
		+ Defect with probability `min(1, d_prev / n * n_defect_prob)`.
	* If the stock level is exactly at or below 25% of capacity, always Cooperate (C) to prevent depletion.
3. **Reaction to Opponent Behavior:**
	* Monitor the opponents' actions and adjust the strategy accordingly.
	* If an opponent consistently defects, increase the probability of defecting in response (e.g., by increasing `n_defect_prob`).
	* If multiple opponents cooperate, decrease the probability of defecting (e.g., by decreasing `n_defect_prob`).

**Edge Cases:**

1. **Last Round:** Cooperate (C) to maximize overall payoff.
2. **Low Stock Levels:** When the stock level is critically low (< 25% capacity), prioritize conservation and always Cooperate (C).
3. **Ties:** In case of ties in the number of cooperators or defectors, randomly choose between Cooperate and Defect.

**Collective Mindset:**

The ACC strategy aims to balance individual self-interest with collective well-being by adapting to the group's behavior. By initially cooperating and then responding to opponents' actions, ACC encourages cooperation while being robust against exploitation. The adaptive nature of the strategy allows it to adjust to changing circumstances and promotes a dynamic equilibrium.

**Pseudocode:**
```python
def AdaptiveCollectiveConservation(stock_level, capacity, num_players, prev_round_actions):
    # Initialize parameters
    n_defect_prob = 0.3
    threshold = 0.75 * capacity

    if stock_level >= threshold:
        return 'C'  # Cooperate when stock is high
    elif stock_level <= 0.25 * capacity:
        return 'C'  # Always cooperate at critically low stock levels
    else:
        d_prev = sum(1 for action in prev_round_actions if action == 'D')
        defect_prob = min(1, d_prev / num_players * n_defect_prob)
        return 'D' if random.random() < defect_prob else 'C'

def update_n_defect_prob(prev_round_actions, num_players):
    # Adjust n_defect_prob based on opponents' behavior
    # ...
```
This strategy should perform well in a tournament against various independent strategies, as it balances individual self-interest with collective conservation and adapts to the group's behavior.
'''

description_COLLECTIVE_580 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.

**Decision Rules:**

1. **Initial Rounds**: Cooperate (C) in the first round to establish a baseline stock level.
2. **Stock Thresholds**: Define two thresholds, `stock_high` and `stock_low`, based on the capacity:
	* `stock_high` = 0.75 \* capacity
	* `stock_low` = 0.25 \* capacity

If the current stock is above `stock_high`, Cooperate (C). If it's below `stock_low`, Defect (D).

3. **Adaptive Response**: Observe the actions of other players in previous rounds and adjust your strategy accordingly:
	* If most players (> 50%) defected in the previous round, Defect (D) in the current round.
	* If most players cooperated (> 50%), Cooperate (C).
4. **History-based Adaptation**: Keep a record of the game's history, including the stock levels and actions taken by all players. Use this information to adapt your strategy:
	* If the stock has been consistently low (< `stock_low`) for multiple rounds, Defect (D) to increase individual payoff.
	* If the stock has been consistently high (> `stock_high`) for multiple rounds, Cooperate (C) to maintain sustainability.

**Pseudocode:**
```python
def ASC(current_stock, capacity, history):
  # Initial round
  if len(history) == 0:
    return C

  # Stock thresholds
  stock_high = 0.75 * capacity
  stock_low = 0.25 * capacity

  if current_stock > stock_high:
    return C
  elif current_stock < stock_low:
    return D

  # Adaptive response
  prev_round_actions = history[-1]
  most_players_defected = sum(prev_round_actions) / len(prev_round_actions) > 0.5
  if most_players_defected:
    return D
  else:
    return C

  # History-based adaptation
  low_stock_count = sum(1 for round in history if round['stock'] < stock_low)
  high_stock_count = sum(1 for round in history if round['stock'] > stock_high)

  if low_stock_count > 2:
    return D
  elif high_stock_count > 2:
    return C

  # Default to cooperation
  return C
```
**Collective Mindset:**

ASC prioritizes collective sustainability while ensuring individual payoffs are competitive. By adapting to the game's state and history, ASC promotes a balanced approach that considers both short-term gains and long-term conservation of the common resource.

**Edge Cases:**

* Last round: Cooperate (C) if the stock is above `stock_high`, Defect (D) otherwise.
* First round with multiple players: Cooperate (C) to establish a baseline stock level.
* Opponent strategies: ASC's adaptive nature allows it to respond effectively to various opponent behaviors, including cooperation and defection.

ASC is designed to perform well in a tournament setting, where diverse strategies will be employed by other AI systems.
'''

description_COLLECTIVE_581 = '''
I propose a collective strategy called "Adaptive Threshold Cooperation" (ATC). ATC balances individual self-interest with collective sustainability by adapting its cooperation threshold based on the game's state and history.

**Decision Rules:**

1. **Initial Round:** In the first round, cooperate (play C) to establish a baseline for stock growth.
2. **General Rule:** Cooperate if the current stock level is above a dynamic threshold; otherwise, defect.
3. **Threshold Calculation:** The threshold is calculated as a function of the current stock level and the game's history:
	* `threshold = capacity * (1 - (total_consumption / (n * capacity)))^2`
	* where `total_consumption` is the total consumption over all previous rounds, and `n` is the number of players.
4. **Edge Case Handling:**
	* In the last round, always defect to maximize individual payoff.
	* If the stock level falls below a critical threshold (`critical_threshold = capacity / (2 * n)`), always cooperate for the remainder of the game to prevent depletion.

**Pseudocode:**

```
Function ATC(current_stock, total_consumption, round_number):
    if round_number == 1:
        return COOPERATE
    elif current_stock < critical_threshold:
        return COOPERATE
    else:
        threshold = capacity * (1 - (total_consumption / (n * capacity)))^2
        if current_stock > threshold:
            return COOPERATE
        else:
            return DEFECT

Function Update(total_consumption, new_stock):
    total_consumption += new_stock - current_stock
    return total_consumption

current_stock = initial_stock
total_consumption = 0
for round_number from 1 to r:
    action = ATC(current_stock, total_consumption, round_number)
    if action == COOPERATE:
        consumption = current_stock / (2 * n)
    else:
        consumption = current_stock / n
    new_stock = Update(total_consumption, current_stock - consumption)
    current_stock = min(new_stock + growth, capacity)
```

**Collective Mindset:**

ATC prioritizes collective sustainability by cooperating when the stock level is above a dynamic threshold. This encourages other players to cooperate as well, maintaining a healthy stock level and maximizing long-term payoffs for all players.

By adapting its cooperation threshold based on the game's history, ATC balances individual self-interest with collective responsibility, making it a robust strategy in a tournament against independent opponents.
'''

description_COLLECTIVE_582 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoffs with collective sustainability by adaptively responding to the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) if stock >= capacity / 2; otherwise, Defect (D). This initial decision sets a tone for cooperation while considering the starting stock level.
2. **Subsequent Rounds (t > 1):**
	* If the average payoff in the previous round is above the average payoff of the game so far (i.e., π_i,t-1 ≥ Σ(t=1 to t-1) π_i,t / (t-1)), and the stock level is above a certain threshold (stock >= capacity / 2), Cooperate (C).
	* If the previous round's total consumption exceeded half of the capacity, Defect (D). This rule helps prevent over-exploitation.
	* In all other cases, use the **Trend-Based Decision**:
		+ Calculate the trend in stock levels over the last two rounds: Δstock = stock_t - stock_t-1
		+ If Δstock > 0 (increasing stock), Cooperate (C)
		+ If Δstock < 0 (decreasing stock), Defect (D)
		+ If Δstock == 0 (stable stock), maintain the previous action (to avoid unnecessary switches)
3. **Last Round (t=r):** Always Defect (D). In the final round, individual payoffs take precedence over collective sustainability.

**Edge Cases:**

* **First Round with Low Stock:** If the initial stock level is below capacity / 2, ASC defects to maximize immediate payoff.
* **Consecutive Cooperation:** If all players cooperate in a round and the resulting stock growth allows for continued cooperation without exceeding capacity, ASC will continue cooperating.

**Collective Mindset:**

ASC aligns with a collective mindset by:

1. Initially cooperating when possible to establish a cooperative tone.
2. Responding to changes in the game state (e.g., increasing or decreasing stock levels) to maintain sustainability.
3. Defecting strategically to prevent over-exploitation and ensure individual payoffs.

By adapting to the game's dynamics, ASC balances collective conservation with individual self-interest, making it a robust strategy for a wide range of opponent behaviors in this tournament setting.

Pseudocode (for illustration purposes only):
```python
def ASC(stock, capacity, history):
    if len(history) == 0:  # Initial Round
        return "C" if stock >= capacity / 2 else "D"
    
    avg_payoff = sum([h['payoff'] for h in history]) / len(history)
    last_round_avg_payoff = history[-1]['payoff']
    total_consumption = sum([h['consumption'] for h in history])
    
    if last_round_avg_payoff >= avg_payoff and stock >= capacity / 2:
        return "C"
    elif total_consumption > capacity / 2:
        return "D"
    else:
        trend = stock - history[-1]['stock']
        if trend > 0:
            return "C"
        elif trend < 0:
            return "D"
        else:
            return history[-1]['action']

def play_ASC(stock, capacity, r):
    history = []
    for t in range(r):
        action = ASC(stock, capacity, history)
        if t == r - 1:  # Last Round
            action = "D"
        
        consumption = stock / (2 * len(history)) if action == "C" else stock / len(history)
        payoff = consumption
        
        history.append({'action': action, 'consumption': consumption, 'payoff': payoff, 'stock': stock})
        
        total_consumption = sum([h['consumption'] for h in history])
        stock -= total_consumption
        growth = 2 * stock * (1 - stock / capacity)
        stock = min(stock + growth, capacity)
    
    return history
```
This pseudocode demonstrates the ASC strategy's decision-making process and game state updates.
'''

description_COLLECTIVE_583 = '''
**Collective Strategy: Adaptive Common Pool Resource Management (ACPRM)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe others' behavior.
2. **Observation Phase**: For rounds 2-5, cooperate (C) if at least half of the players cooperated in the previous round; otherwise, defect (D). This phase allows us to gauge the level of cooperation among players.
3. **Adaptive Phase**: After the observation phase, switch to an adaptive strategy based on the current stock level and history:
	* If the stock level is above 75% of the capacity, cooperate (C) if at least half of the players cooperated in the previous round; otherwise, defect (D).
	* If the stock level is between 50% and 75% of the capacity, cooperate (C) if at least one-third of the players cooperated in the previous round; otherwise, defect (D).
	* If the stock level is below 50% of the capacity, defect (D) to maximize individual payoff.
4. **Endgame**: In the last two rounds, cooperate (C) if the stock level is above 25% of the capacity and at least half of the players cooperated in the previous round; otherwise, defect (D).

**Edge Cases:**

* If a player has not observed any cooperation from others throughout the game, they will defect (D) in all subsequent rounds.
* If the stock level reaches zero or becomes negative, all players will receive a payoff of zero for that round.

**Collective Mindset:**

ACPRM is designed to balance individual self-interest with collective sustainability. By cooperating when possible and adapting to changing conditions, we aim to maintain a healthy stock level while maximizing our own payoffs.

Pseudocode:
```python
def ACPRM(stock, capacity, history):
    # Initial Round
    if round == 1:
        return 'C'

    # Observation Phase (rounds 2-5)
    if round <= 5:
        cooperators = sum(1 for action in history[-1] if action == 'C')
        if cooperators >= len(history[-1]) / 2:
            return 'C'
        else:
            return 'D'

    # Adaptive Phase
    stock_ratio = stock / capacity
    if stock_ratio > 0.75:
        cooperators = sum(1 for action in history[-1] if action == 'C')
        if cooperators >= len(history[-1]) / 2:
            return 'C'
        else:
            return 'D'
    elif 0.5 <= stock_ratio < 0.75:
        cooperators = sum(1 for action in history[-1] if action == 'C')
        if cooperators >= len(history[-1]) / 3:
            return 'C'
        else:
            return 'D'
    else:
        return 'D'

    # Endgame
    if round >= r - 2:
        stock_ratio = stock / capacity
        if stock_ratio > 0.25:
            cooperators = sum(1 for action in history[-1] if action == 'C')
            if cooperators >= len(history[-1]) / 2:
                return 'C'
            else:
                return 'D'
        else:
            return 'D'

    # Default to defecting
    return 'D'
```
Note: The pseudocode assumes a `history` list containing the actions of all players in previous rounds, with each action represented as either `'C'` (cooperate) or `'D'` (defect).
'''

description_COLLECTIVE_584 = '''
**Collective Strategy: Adaptive Cooperation (AC)**

The Adaptive Cooperation strategy aims to balance individual payoff maximization with collective sustainability of the common pool resource. It adaptively responds to the current state and history of the game.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and maximize initial payoffs.
2. **Stock-dependent Cooperation**: If the current stock level `S` is above 75% of the capacity, cooperate (C). This threshold encourages cooperation when the resource is abundant, promoting collective sustainability.
3. **Opponent-based Adaptation**: Observe the actions of all opponents in the previous round. If more than half of the opponents defected (D), defect (D) in the current round to protect against over-exploitation. Otherwise, cooperate (C).
4. **Recent History-based Adjustment**: Monitor the recent history of payoffs (last 3 rounds). If your average payoff is below the expected cooperative payoff (`capacity / (2n)`), switch from cooperation to defection for one round to signal dissatisfaction and potentially improve individual payoffs.
5. **Endgame Cooperation**: In the last two rounds, cooperate (C) regardless of previous actions or stock levels. This ensures a sustainable conclusion to the game and avoids destructive exploitation.

**Pseudocode**
```
function AdaptiveCooperation(current_stock, capacity, num_players, history):
  if current_round == 1:
    return COOPERATE
  elif current_stock >= 0.75 * capacity:
    return COOPERATE
  else:
    opponent_actions = observe_opponents(history)
    if more_than_half_defected(opponent_actions):
      return DEFECT
    else:
      recent_payoffs = calculate_recent_payoffs(history, num_players)
      if average_payoff(recent_payoffs) < expected_cooperative_payoff(capacity, num_players):
        return DEFECT
      else:
        return COOPERATE

  # Endgame cooperation
  if current_round >= total_rounds - 1:
    return COOPERATE
```
**Collective Mindset**

The Adaptive Cooperation strategy prioritizes collective sustainability while adapting to individual payoffs and opponent actions. By cooperating when the resource is abundant, it promotes a cooperative tone and ensures long-term sustainability. When opponents exploit the resource, AC adapts by defecting to protect against over-exploitation. The recent history-based adjustment mechanism allows for flexible responses to changing game dynamics.

By implementing this strategy, we aim to create a robust and adaptive approach that balances individual payoffs with collective sustainability, making it an effective competitor in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_585 = '''
**Collective Strategy: Adaptive Stock Preservation (ASP)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for stock preservation and encourage cooperation.
2. **Stock Threshold**: If the current stock level is below 50% of the capacity, Defect (D) to maximize individual payoff. This ensures that if the game is not going well, we prioritize short-term gains.
3. **Majority Cooperation**: If more than half of the players cooperated in the previous round, Cooperate (C) in this round. This promotes reciprocity and encourages cooperation when it's evident others are willing to cooperate.
4. **Recent Defection**: If any player defected in the previous two rounds, Defect (D) in this round. This discourages exploitation by defecting players and maintains a level of fairness.
5. **Stock Recovery**: If the stock has recovered to at least 75% of its capacity after a period of low stock levels, Cooperate (C) to allow for sustainable growth.

**Additional Considerations:**

* **Round Number**: As the game progresses (round number increases), gradually increase the threshold for cooperation from step 3. This allows for more flexibility in later rounds when the game's trajectory is clearer.
* **Player Count**: For larger player counts, reduce the stock threshold in step 2 to encourage cooperation and prevent over-exploitation.

**Pseudocode:**
```
function ASP(current_stock, previous_round_actions, round_number, capacity):
    if round_number == 1:
        return COOPERATE
    elif current_stock < 0.5 * capacity:
        return DEFECT
    elif majority_cooperated(previous_round_actions):
        return COOPERATE
    elif recent_defection(previous_round_actions):
        return DEFECT
    elif stock_recovery(current_stock, capacity):
        return COOPERATE
    else:
        # Fallback to a conservative approach: Cooperate if unsure
        return COOPERATE

function majority_cooperated(actions):
    # Count the number of cooperators in the previous round
    cooperators = sum(1 for action in actions if action == COOPERATE)
    return cooperators > len(actions) / 2

function recent_defection(actions):
    # Check if any player defected in the last two rounds
    return any(action == DEFECT for action in actions[-2:])

function stock_recovery(current_stock, capacity):
    # Stock has recovered to at least 75% of its capacity
    return current_stock >= 0.75 * capacity
```
**Rationale:**

The Adaptive Stock Preservation strategy balances short-term gains with long-term sustainability by adapting to the game's dynamics and player behaviors. By initially cooperating, we establish a baseline for cooperation and encourage others to follow suit. The stock threshold ensures that if the game is not going well, we prioritize individual payoffs. Majority cooperation and recent defection rules promote reciprocity and fairness. Finally, the stock recovery rule allows for sustainable growth when conditions improve.

This strategy is designed to be robust against various opponent behaviors and does not rely on specific coordination mechanisms or norms. Its adaptability makes it suitable for a wide range of game scenarios, including those with different player counts and capacity levels.
'''

description_COLLECTIVE_586 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Thresholds**

Our collective strategy, "Adaptive Cooperation," aims to balance individual payoffs with the long-term sustainability of the common pool resource. We will adapt our cooperation level based on the current stock state and the history of play.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a cooperative tone and minimize initial stock depletion.
2. **Subsequent Rounds (t>1):**
	* If the current stock is above 75% of capacity, cooperate (C). This encourages sustainable consumption when the resource is abundant.
	* If the current stock is between 50% and 75% of capacity, defect (D) with a probability proportional to the number of players who defected in the previous round. This introduces a responsive element, allowing us to adapt to opponents' behavior while avoiding over-exploitation.
	* If the current stock is below 50% of capacity, cooperate (C). This prioritizes resource conservation when it's scarce.

Pseudocode:
```
if t == 1:  # Initial round
    action = C
else:
    if stock >= 0.75 * capacity:
        action = C
    elif 0.5 * capacity <= stock < 0.75 * capacity:
        defect_prob = (num_defectors_prev_round / n) ^ 2
        if random() < defect_prob:
            action = D
        else:
            action = C
    else:  # stock < 0.5 * capacity
        action = C
```
**Edge Cases:**

* **Last Round (t=r):** Cooperate (C) to avoid over-exploiting the resource, as there is no future benefit from defecting.
* **Opponent Behavior:** Our strategy responds to opponents' actions by adjusting our cooperation level based on their previous behavior.

**Collective Mindset:**

Our Adaptive Cooperation strategy prioritizes the long-term sustainability of the common pool resource while allowing for flexibility in response to opponents' actions. By cooperating when the stock is abundant and conserving when it's scarce, we promote a collective mindset that balances individual payoffs with the greater good.

This strategy is designed to be robust against various opponent behaviors, including those that may not share our cooperative goals. Its adaptability ensures that we can respond effectively in different scenarios while promoting a collective approach that prioritizes resource sustainability.
'''

description_COLLECTIVE_587 = '''
**Collective Strategy: Adaptive Cooperation with Stock Conservation (ACSC)**

**Overview**

Our collective strategy, ACSC, aims to balance individual payoffs with collective sustainability by adapting to the game's state and history. We prioritize cooperation while conserving the stock level, ensuring a stable and resilient common pool resource.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a cooperative tone and gather information about opponents' behaviors.
2. **Stock Conservation Threshold**: Define a threshold `θ` as a fraction of the capacity (e.g., θ = 0.7). If the current stock level is below this threshold, defect (D) to maximize individual payoff in the short term.
3. **Cooperation with Stock Growth**: If the stock level is above the threshold and has been growing or stable for `k` consecutive rounds (e.g., k = 2), cooperate (C) to maintain a sustainable stock level and encourage collective cooperation.
4. **Defection with Stock Decline**: If the stock level is above the threshold but has been declining for `m` consecutive rounds (e.g., m = 3), defect (D) to signal to others that the current cooperative strategy is not effective and to protect individual interests.
5. **Opponent Behavior Adaptation**: Observe opponents' actions in previous rounds and adjust the strategy accordingly:
	* If most opponents (e.g., >50%) have been cooperating, cooperate (C) to reinforce collective cooperation.
	* If most opponents have been defecting, defect (D) to protect individual interests.

**Edge Cases**

1. **Last Round**: Cooperate (C) in the last round to ensure a positive payoff and maintain a sustainable stock level for future rounds.
2. **Tie-breaking**: In case of equal payoffs between cooperation and defection, cooperate (C) to prioritize collective sustainability.
3. **Opponent Actions Tie**: If opponents' actions are evenly split between cooperation and defection, follow the stock conservation threshold rule.

**Pseudocode**
```python
def ACSC(n, r, capacity, stock, history):
    θ = 0.7  # Stock conservation threshold
    k = 2   # Consecutive rounds for cooperation with stock growth
    m = 3   # Consecutive rounds for defection with stock decline

    if round == 1:  # Initial Round
        return C
    elif stock < θ * capacity:
        return D
    elif is_stock_growing(history, k):
        return C
    elif is_stock_declining(history, m):
        return D
    else:
        opponent_actions = observe_opponent_actions(history)
        if most_cooperate(opponent_actions):
            return C
        else:
            return D

def is_stock_growing(history, k):
    # Check if stock has been growing or stable for k consecutive rounds
    pass

def is_stock_declining(history, m):
    # Check if stock has been declining for m consecutive rounds
    pass

def most_cooperate(opponent_actions):
    # Determine if most opponents have been cooperating
    pass
```
**Collective Mindset Alignment**

ACSC prioritizes collective sustainability by conserving the stock level and adapting to opponents' behaviors. By cooperating when the stock level is above the threshold and declining, we encourage others to cooperate and maintain a stable common pool resource. Our strategy is robust to various opponent behaviors and can be adapted to different game parameters and states.
'''

description_COLLECTIVE_588 = '''
**Collective Strategy: "Adaptive Stock Preservation" (ASP)**

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' behavior.
2. **Subsequent Rounds**: Monitor the current stock level, previous rounds' payoffs, and opponents' actions. Calculate the "Stock Depletion Rate" (SDR) as the average decrease in stock level per round.

**Cooperation Threshold**: If SDR is below a certain threshold (e.g., 0.2), cooperate (C). This indicates that the group is managing the resource sustainably.
3. **Defection Detection**: Monitor opponents' actions and detect if any player has defected (D) in the previous round. If a defection is detected, calculate the "Defection Impact" (DI) as the difference between the expected payoff from cooperation and the actual payoff.

**Retaliation Mechanism**: If DI is above a certain threshold (e.g., 0.1), defect (D) in the current round to penalize the defector and restore balance.
4. **Stock Recovery**: If the stock level falls below a certain threshold (e.g., capacity / 2), cooperate (C) for a set number of rounds (e.g., 3) to allow the stock to recover.

**Edge Cases:**

* **Last Round**: Cooperate (C) in the final round, as there is no future benefit from defecting.
* **Tiebreaker**: In cases where multiple players have the same SDR or DI, use a randomization mechanism to break ties and ensure fairness.

**Collective Mindset Alignment:**

ASP prioritizes cooperation when the group is managing the resource sustainably. By retaliating against defectors and allowing the stock to recover, ASP promotes collective responsibility and discourages exploitation.

Pseudocode:
```markdown
# Initialize variables
stock_level = capacity
sdr_threshold = 0.2
di_threshold = 0.1
retaliation_rounds = 3

# Initial Round
if round == 1:
    action = COOPERATE

# Subsequent Rounds
else:
    sdr = calculate_stock_depletion_rate()
    if sdr < sdr_threshold:
        action = COOPERATE
    else:
        # Defection Detection and Retaliation
        defector_detected = detect_defection()
        if defector_detected:
            di = calculate_defection_impact()
            if di > di_threshold:
                action = DEFECT
            else:
                action = COOPERATE
        # Stock Recovery
        elif stock_level < capacity / 2:
            action = COOPERATE
            recovery_rounds += 1
            if recovery_rounds >= retaliation_rounds:
                recovery_rounds = 0

# Last Round
if round == r:
    action = COOPERATE
```
ASP is a robust and adaptive strategy that balances individual self-interest with collective responsibility, ensuring the long-term sustainability of the common pool resource.
'''

description_COLLECTIVE_589 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

ASC aims to balance individual payoff maximization with collective stock conservation, ensuring a sustainable resource for all players.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline of cooperation and minimize initial stock depletion.
2. **Stock Threshold**: If the current stock level is below 50% of the capacity, Defect (D) to maximize individual payoff in the short term. This rule prioritizes immediate gains when the stock is scarce.
3. **Opponent Behavior Analysis**:
	* Monitor the opponent's actions and payoffs from previous rounds.
	* If an opponent has defected more than 50% of the time, Defect (D) to avoid being exploited.
	* If an opponent has cooperated more than 50% of the time, Cooperate (C) to encourage continued cooperation.
4. **Adaptive Cooperation**: If the current stock level is above 50% of the capacity and no opponents have defected more than 50% of the time, Cooperate (C) with a probability p that decreases as the number of rounds increases:
	* p = 1 - (r / (2 \* n)) ^ 0.5
where r is the current round number and n is the number of players.
This rule allows for gradual adaptation to changing opponent behaviors while promoting cooperation in early rounds.
5. **Emergency Defection**: If the total consumption in a previous round exceeded 75% of the capacity, Defect (D) in the next round to prevent stock collapse.

**Edge Cases**

* Last Round: Cooperate (C) to maximize collective payoff and leave a positive legacy for future interactions.
* Single-Player Game: Always Cooperate (C), as there is no risk of exploitation or competition.
* Tie-Breaking: In cases where multiple rules suggest different actions, prioritize cooperation (C) to maintain a conservative approach.

**Collective Mindset**

ASC prioritizes collective stock conservation while adapting to individual opponent behaviors. By balancing short-term gains with long-term sustainability, this strategy promotes cooperation and encourages opponents to do the same, ultimately benefiting all players in the game.

Pseudocode:
```python
def ASC(n, r, capacity, stock, history):
    if r == 1:  # Initial Round
        return C

    stock_threshold = capacity / 2
    if stock < stock_threshold:
        return D

    opponent_behavior = analyze_opponent_actions(history)
    if opponent_behavior.defected > 0.5:
        return D
    elif opponent_behavior.cooperated > 0.5:
        return C

    p = 1 - (r / (2 * n)) ** 0.5
    if random.random() < p and stock > stock_threshold:
        return C

    emergency_defection = total_consumption(history) > 0.75 * capacity
    if emergency_defection:
        return D

    # Tie-breaking: prioritize cooperation
    return C
```
Note that this pseudocode is a simplified representation of the strategy, and actual implementation may require additional details and nuance.
'''

description_COLLECTIVE_590 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Dependent Tit-for-Tat**

Our collective strategy aims to balance individual payoffs with the long-term sustainability of the common pool resource. We'll employ a dynamic approach that adjusts cooperation levels based on the current stock level and observed opponent behavior.

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to establish a baseline for mutual cooperation and observe opponents' initial actions.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of the capacity, cooperate (C). This encourages sustainable consumption when the resource is plentiful.
	* If the current stock level is between 25% and 75% of the capacity, play a Tit-for-Tat (TFT) strategy. Cooperate if most opponents cooperated in the previous round; otherwise, defect (D).
	* If the current stock level is below 25% of the capacity, defect (D). This prioritizes individual payoff when the resource is scarce.
3. **Last Round (t=r)**: Defect (D), as there are no future rounds to consider.

**Pseudocode for decision-making process:**
```python
def decide_action(current_stock, previous_round_actions, round_number):
    if round_number == 1:
        return 'C'  # Cooperate in the first round

    capacity = get_capacity()
    stock_threshold_high = 0.75 * capacity
    stock_threshold_low = 0.25 * capacity

    if current_stock >= stock_threshold_high:
        return 'C'  # Cooperate when stock is high
    elif current_stock <= stock_threshold_low:
        return 'D'  # Defect when stock is low
    else:
        previous_cooperations = count_cooperations(previous_round_actions)
        opponents_cooperated = previous_cooperations / len(opponents)

        if opponents_cooperated > 0.5:  # Most opponents cooperated last round
            return 'C'
        else:
            return 'D'  # Play TFT

    if round_number == get_total_rounds():
        return 'D'  # Defect in the last round
```
**Handling Edge Cases:**

* In the event of a tie (e.g., equal number of cooperations and defections), our strategy will cooperate to maintain a cooperative atmosphere.
* If an opponent consistently defects, our TFT component will adapt by defecting as well.

**Collective Mindset:**
Our strategy is designed to promote cooperation while being responsive to changes in the game state and opponents' actions. By cooperating when the stock is high and adapting to opponents' behavior, we aim to maintain a sustainable resource level and maximize collective payoffs.

This strategy will perform well against independent strategies developed by other AI systems, as it:

* Adapts to changing game conditions (stock levels) and opponent behaviors
* Encourages cooperation while protecting individual interests
* Does not rely on predetermined patterns or coordination mechanisms

In a tournament setting, our Adaptive Cooperation with Stock-Dependent Tit-for-Tat strategy will demonstrate its effectiveness in achieving a balance between individual payoffs and collective sustainability.
'''

description_COLLECTIVE_591 = '''
Here's a collective strategy for the Common Pool Resource Game that meets the requirements:

**Strategy Name:** Adaptive Collective Conservation (ACC)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline stock level and encourage cooperation.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Cooperate (C).
	* If the current stock level is between 25% and 75% of capacity, Defect (D) with a probability proportional to the number of previous rounds where at least one player defected. Specifically:
		+ Calculate the "defection rate" as the number of rounds with at least one defection divided by the total number of rounds.
		+ Use this rate to determine the probability of defecting in the current round: p_defect = (1 - stock/capacity) \* (defection_rate + 0.1). This ensures that the probability of defecting increases as the stock level decreases and the historical defection rate increases.
	* If the current stock level is below 25% of capacity, Defect (D) to maximize individual payoff in the short term.

**Handling Edge Cases:**

* **Last Round (t=r):** Cooperate (C) to ensure that all players have an incentive to conserve the resource throughout the game.
* **When only one player remains:** Defect (D) to maximize individual payoff, as there is no collective benefit to conserving the resource.

**Collective Mindset:**

The ACC strategy prioritizes cooperation when the stock level is high and defecting when it's low. By introducing a probabilistic element based on historical defection rates, the strategy adapts to the behavior of other players while maintaining a commitment to conservation. This approach encourages collective conservation without relying on explicit coordination mechanisms.

**Pseudocode:**

```
function ACC(n, r, capacity, stock_history):
    // Initialize variables
    t = 1 (current round)
    defection_rate = 0
    
    while t <= r:
        // Determine current stock level as a percentage of capacity
        stock_percentage = stock / capacity * 100
        
        if t == 1 or stock_percentage >= 75:
            action = C (Cooperate)
        elif stock_percentage < 25:
            action = D (Defect)
        else:
            // Calculate probability of defecting based on historical defection rate
            p_defect = (1 - stock/capacity) * (defection_rate + 0.1)
            if random() < p_defect:
                action = D (Defect)
            else:
                action = C (Cooperate)
        
        // Update defection rate and stock history
        if any(player_defected in previous_rounds):
            defection_rate += 1 / t
        
        // Update current round and repeat
        t += 1
    
    return ACC_payoff
```

This strategy should be robust to a wide range of opponent behaviors, while prioritizing collective conservation when possible.
'''

description_COLLECTIVE_592 = '''
To design a collective strategy for this Common Pool Resource Game that is adaptive and robust to various opponent behaviors, we'll create a hybrid approach combining elements of cooperation, self-interest, and adaptability.

**Strategy Name:** Adaptive Collective Harvesting (ACH)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for stock growth and observe other players' actions.
2. **Cooperation Threshold**: Introduce a dynamic cooperation threshold, `CT`, which adjusts based on the current stock level (`S`) and the number of rounds (`r`). Set `CT` as follows:
   - If `S > (capacity / 2)`: Cooperate if at least `(n / 2)` players cooperated in the previous round.
   - If `(capacity / 4) ≤ S ≤ (capacity / 2)`: Cooperate if at least `(n / 3)` players cooperated in the previous round.
   - If `S < (capacity / 4)`: Defect (`D`) to maximize individual payoff, as cooperation is unlikely to yield significant benefits.
3. **Self-Interest Adjustment**: Monitor the ratio of the current stock level (`S`) to the capacity and adjust the strategy accordingly:
   - If `S > (2 * n * r)`: Cooperate, as there's sufficient stock for all players to benefit from cooperative behavior.
   - If `(n * r) ≤ S ≤ (2 * n * r)`: Defect if more than half of the remaining rounds will have a low stock level; otherwise, cooperate.
4. **History-Based Adaptation**: Track the number of consecutive rounds where at least `(n / 2)` players cooperated (`C_streak`). If `C_streak ≥ 3`, increase cooperation rate by 20% in the next round.

**Edge Cases:**

1. **Last Round**: Defect, as there's no future benefit to cooperating.
2. **Low Stock Levels**: When stock is critically low (`S < (n * r)`), defect to maximize individual payoff.
3. **All Players Cooperate**: If all players cooperated in the previous round, cooperate in the next round.

**Collective Mindset Alignment:**

ACH prioritizes cooperation when beneficial for the collective while adapting to individual self-interest and opponent behaviors. This strategy promotes sustainable harvesting by:

* Encouraging cooperation during periods of high stock levels
* Adjusting cooperation rates based on historical behavior
* Balancing individual payoffs with collective sustainability

**Pseudocode:**
```python
def ACH(n, r, capacity, S):
    CT = get_cooperation_threshold(S, n, r)
    C_streak = track_consecutive_cooperations()

    if first_round():
        return "C"
    elif S > (capacity / 2) and num_cooperators_last_round() >= (n / 2):
        return "C"
    elif (capacity / 4) <= S <= (capacity / 2) and num_cooperators_last_round() >= (n / 3):
        return "C"
    elif S < (capacity / 4):
        return "D"
    elif self_interest_adjustment(S, n, r):
        return "C"
    elif C_streak >= 3:
        increase_cooperation_rate(20%)
        return "C"
    else:
        return "D"

def get_cooperation_threshold(S, n, r):
    # Implement CT logic based on S and n
    pass

def track_consecutive_cooperations():
    # Track C_streak value
    pass

def first_round():
    # Check if it's the first round
    pass

def num_cooperators_last_round():
    # Get number of cooperators in previous round
    pass

def self_interest_adjustment(S, n, r):
    # Implement self-interest adjustment logic
    pass
```
This strategy will adapt to various opponent behaviors while prioritizing collective sustainability and individual payoffs.
'''

description_COLLECTIVE_593 = '''
To design a collective strategy for this Common Pool Resource Game, I propose a adaptive and robust approach that balances individual payoff maximization with collective sustainability. Our strategy, called "Collective Stock Guardian" (CSG), aims to maintain a healthy stock level while adapting to various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to initiate cooperation and establish a baseline for collective behavior.
2. **Stock-Based Cooperation:** Cooperate if the current stock level is above a certain threshold, `stock_threshold`, which is set to 75% of the capacity. This ensures that when the stock is relatively high, we prioritize sustainability over individual gains.
3. **Defect-Response Mechanism:** If the previous round's total consumption exceeds 50% of the capacity, defect (D) in the current round. This mechanism helps counter potential over-exploitation by opponents and encourages more conservative behavior.
4. **Payoff-Based Adaptation:** Monitor the average payoff per player over the last few rounds (`avg_payoff_window`). If this average is below a certain threshold (`payoff_threshold`, set to 50% of the maximum possible payoff), cooperate in the next round. This adaptation mechanism helps adjust our strategy when the collective payoffs are low, indicating potential cooperation opportunities.
5. **Endgame Cooperation:** Cooperate in the last two rounds to ensure a fair and sustainable conclusion.

**Edge Cases:**

* In the event of a tie (i.e., equal number of cooperators and defectors), cooperate to promote stability.
* If an opponent consistently defects, our strategy will adapt by increasing cooperation to maintain stock sustainability.

**Collective Mindset:**

CSG prioritizes collective sustainability while allowing for individual adaptation. By considering both the current stock level and past payoffs, our strategy balances short-term gains with long-term sustainability goals. This approach encourages opponents to cooperate, as defecting would lead to decreased payoffs due to over-exploitation.

**Pseudocode:**
```python
def CollectiveStockGuardian(state, history):
    # Initialize variables
    stock_threshold = 0.75 * capacity
    payoff_threshold = 0.5 * max_payoff
    avg_payoff_window = []
    
    # First round cooperation
    if round == 1:
        return 'C'
    
    # Stock-based cooperation
    if state.stock >= stock_threshold:
        return 'C'
    
    # Defect-response mechanism
    total_consumption_prev_round = sum(history[-1].consumptions)
    if total_consumption_prev_round > 0.5 * capacity:
        return 'D'
    
    # Payoff-based adaptation
    avg_payoff_window.append(history[-1].avg_payoff)
    if len(avg_payoff_window) >= 3 and sum(avg_payoff_window) / len(avg_payoff_window) < payoff_threshold:
        return 'C'
    
    # Endgame cooperation
    if round >= r - 2:
        return 'C'
    
    # Default to defection
    return 'D'
```
This strategy, Collective Stock Guardian, is designed to be adaptive and robust in the face of various opponent behaviors. By balancing individual payoffs with collective sustainability goals, CSG promotes cooperation while minimizing the risk of over-exploitation.
'''

description_COLLECTIVE_594 = '''
**Collective Strategy: Adaptive Stock Conservation (ASC)**

The ASC strategy aims to balance individual payoff maximization with collective stock conservation, ensuring a sustainable and robust approach to the Common Pool Resource Game.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' initial actions.
2. **Subsequent Rounds:** Assess the current stock level (`S`) and the total consumption from the previous round (`total_consumption_prev`).
	* If `S` is above 75% of capacity, Cooperate (C) to maintain a healthy stock level.
	* If `S` is between 50% and 75% of capacity, Defect (D) with a probability proportional to `total_consumption_prev`. This adapts to the opponents' exploitation levels.
	* If `S` is below 50% of capacity, Cooperate (C) to help replenish the stock.
3. **Reaction to Opponent Actions:** Monitor the number of players who Defected (`num_defectors`) in the previous round. If `num_defectors` exceeds a threshold (e.g., n/2), increase the probability of Defecting (D) in the next round by 10%. This responds to potential exploitation.
4. **Endgame Strategy:** In the last two rounds, prioritize cooperation to ensure the stock level remains as high as possible for all players.

**Edge Cases:**

* If only one player is left in the game, Cooperate (C) to maximize the remaining payoff.
* If a player observes an opponent consistently Defecting (D), adapt by increasing their own Defection probability.

**Collective Mindset:**

ASC prioritizes collective stock conservation while adapting to opponents' actions. By initially cooperating and then responding to changes in the stock level and opponents' behavior, ASC promotes a balanced approach that benefits all players.

Pseudocode for ASC:
```markdown
# Initialize variables
S = capacity  # current stock level
total_consumption_prev = 0  # previous round's total consumption
num_defectors = 0  # number of defectors in the previous round

# Game loop
for t in range(r):
    if t == 0:  # initial round
        action = C
    else:
        S_remaining = S - total_consumption_prev
        if S_remaining >= 0.75 * capacity:
            action = C
        elif S_remaining >= 0.5 * capacity:
            defect_prob = total_consumption_prev / (n * stock/n)
            action = D with probability defect_prob, else C
        else:
            action = C

    # Observe opponents' actions and update variables
    num_defectors = count(defections in previous round)
    if num_defectors > n/2:
        increase Defection probability by 10%

    # Update stock level and total consumption
    S = min(S_remaining + growth, capacity)
    total_consumption_prev = Σ(consumption_i)

    # Endgame strategy (last two rounds)
    if t >= r - 2:
        action = C

    # Take action and observe payoffs
    π_i = payoff(action, S)
```
This adaptive strategy balances individual interests with collective sustainability, making it a robust competitor in the tournament.
'''

description_COLLECTIVE_595 = '''
I propose a collective strategy called "Adaptive Stock Sensitive Tit-for-Tat" (ASSTT). This strategy balances individual self-interest with collective sustainability, adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline for stock growth.
2. **Subsequent Rounds:**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 25% and 75% of capacity, play Tit-for-Tat (TFT): Cooperate if the opponent(s) cooperated in the previous round; otherwise, defect (D).
	* If the current stock level is below 25% of capacity, defect (D) to maximize individual payoff.
3. **Exception Handling:**
	* If all players defected in the previous round and the current stock level is critically low (<10% of capacity), cooperate (C) to prevent stock depletion.

**Pseudocode:**
```
if (round == 1) {
  action = COOPERATE;
} else {
  if (stock >= 0.75 * capacity) {
    action = COOPERATE;
  } else if (stock >= 0.25 * capacity && stock < 0.75 * capacity) {
    action = TFT(opponent_actions_last_round);
  } else if (stock < 0.25 * capacity) {
    action = DEFECT;
  }
}

if (all_defected_last_round && stock < 0.1 * capacity) {
  action = COOPERATE; // Exception handling
}
```
**Collective Mindset:**

ASSTT prioritizes collective sustainability by:

* Cooperating when the stock level is high to allow for growth.
* Playing TFT when the stock level is moderate, encouraging opponents to cooperate and maintain a stable stock level.
* Defecting when the stock level is critically low to maximize individual payoff.

**Adaptability:**

ASSTT adapts to various opponent behaviors by:

* Responding to cooperation with cooperation (TFT).
* Punishing defection with defection (TFT).
* Adjusting its strategy based on the current stock level.

**Robustness:**

ASSTT is robust against a wide range of opponent strategies, including:

* Pure cooperators or defectors.
* Mixed strategies (e.g., random cooperation/defection).
* Strategies that adapt to ASSTT's behavior.

By implementing ASSTT, we can balance individual self-interest with collective sustainability, promoting a stable and resilient common pool resource.
'''

description_COLLECTIVE_596 = '''
I propose a collective strategy for the Common Pool Resource Game that balances individual payoffs with the long-term sustainability of the common pool. This strategy is adaptive and robust to various opponent behaviors.

**Strategy Name:** Sustainable Harvesting (SH)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to establish a baseline for cooperation and encourage others to do the same.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, cooperate (C).
	* If the current stock level is between 50% and 75% of capacity, defect (D) with probability p = (current stock / capacity)^0.5.
	* If the current stock level is below 50% of capacity, always defect (D).

Pseudocode:
```
if t == 1:
    action = C
else:
    if stock >= 0.75 * capacity:
        action = C
    elif stock >= 0.5 * capacity:
        p = (stock / capacity)^0.5
        action = D with probability p, otherwise C
    else:
        action = D
```
**Rationale:**

* Cooperating in the initial round sets a positive tone and encourages others to cooperate.
* As the game progresses, SH adapts to the current stock level. When the stock is high (above 75% of capacity), cooperation is encouraged to maintain the resource's sustainability.
* When the stock falls between 50% and 75% of capacity, SH introduces a probabilistic defecting mechanism to balance individual payoffs with long-term sustainability. The probability of defecting increases as the stock level decreases.
* If the stock drops below 50% of capacity, SH switches to always defecting to maximize short-term gains, as the resource is already severely depleted.

**Collective Mindset:**
SH aims to find a balance between individual payoffs and collective sustainability. By adapting to the current stock level, this strategy promotes cooperation when possible while ensuring that each player can still achieve reasonable payoffs even in scenarios where opponents defect.

**Robustness to Opponent Behaviors:**
SH is designed to be robust against various opponent strategies:

* Against cooperative opponents, SH cooperates initially and continues to do so if the stock level remains high.
* Against defective opponents, SH's probabilistic defecting mechanism allows it to adapt and balance individual payoffs with long-term sustainability.

**Edge Cases:**

* **Last Round (t=r):** In the final round, SH reverts to always cooperating (C) to maximize collective payoffs and maintain a positive outcome for all players.
* **Stock Depletion:** If the stock level reaches 0, SH switches to always defecting (D) as there is no longer a resource to conserve.

By implementing Sustainable Harvesting, this strategy promotes cooperation while balancing individual payoffs with long-term sustainability. Its adaptive nature makes it robust against various opponent behaviors, and its collective mindset aligns with the game's objective of maintaining a healthy common pool resource.
'''

description_COLLECTIVE_597 = '''
I'll propose a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors while prioritizing sustainability and fairness. I'll outline decision rules, edge cases, and the collective mindset.

**Strategy Name:** Adaptive Sustainability (AS)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a small probability (e.g., 0.3) to test the waters and gauge opponents' behavior.
2. **General Rule:** In each round t > 1, calculate the average payoff per player in the previous round (π_avg,t-1). If π_avg,t-1 is above a threshold (e.g., capacity / (4n)), cooperate (C); otherwise, defect (D).
3. **Sustainability Check:** Before making a decision, evaluate the current stock level (S_t) and projected growth. If S_t is below a critical threshold (e.g., capacity / 2), cooperate (C) to ensure sustainability.
4. **Opponent Adaptation:** Monitor opponents' behavior over time. If an opponent defects (D) in more than half of the previous rounds, assume they are non-cooperative and adjust your strategy accordingly.

**Pseudocode:**
```
def AdaptiveSustainability(n, capacity, r):
  # Initialize variables
  stock = capacity
  avg_payoff = 0

  for t in range(1, r+1):
    if t == 1:
      # Initial round: random cooperation with probability 0.3
      action = C if random.random() < 0.3 else D
    else:
      # General rule: cooperate if average payoff is high enough
      avg_payoff = calculate_avg_payoff(t-1)
      if avg_payoff > capacity / (4n):
        action = C
      else:
        action = D

      # Sustainability check: cooperate if stock is low
      if stock < capacity / 2:
        action = C

      # Opponent adaptation: adjust strategy based on opponent behavior
      for opponent in range(1, n+1):
        if opponent_defection_rate(opponent) > 0.5:
          action = D  # Assume opponent is non-cooperative

    # Update stock and growth
    stock = update_stock(stock, action)
    growth = calculate_growth(stock)

    # Store average payoff for next round's decision
    avg_payoff = calculate_avg_payoff(t)
```
**Edge Cases:**

1. **Last Round (t=r):** Cooperate (C) to maximize collective payoff, as there is no future game.
2. **Low Stock Levels:** If the stock level falls below a critical threshold (e.g., capacity / 2), cooperate (C) to ensure sustainability.

**Collective Mindset:**

The Adaptive Sustainability strategy prioritizes fairness and sustainability by:

1. Encouraging cooperation when the average payoff is high enough.
2. Adapting to opponents' behavior to minimize exploitation.
3. Prioritizing sustainability by cooperating when the stock level is low.

This collective strategy balances individual interests with the need for sustainable resource management, making it a robust competitor in the tournament against independent strategies developed by other AI systems.
'''

description_COLLECTIVE_598 = '''
I propose a collective strategy called "Adaptive Stock Sensitive Tit-for-Tat" (ASSTT). This strategy is designed to balance individual payoff maximization with collective sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to establish a baseline for cooperation and observe opponents' actions.
2. **Subsequent Rounds**: Observe the previous round's actions and payoffs. If the stock level has decreased significantly (i.e., more than 25% of the capacity), defect (D) in the current round. Otherwise, cooperate (C).
3. **Tit-for-Tat Component**: If an opponent defected in the previous round, mirror their action in the current round (i.e., if they defected, you defect; if they cooperated, you cooperate). This encourages opponents to cooperate and maintains reciprocity.
4. **Stock Sensitivity**: Monitor the stock level and adjust your actions accordingly. If the stock level is below 50% of the capacity, cooperate (C) in the current round to help replenish the resource.

**Pseudocode:**
```
 Initialize:
   stock_level = capacity
   opponent_actions = []
   my_payoffs = []

 For each round t:
   if t == 1:
     action = C
   else:
     previous_stock_level = stock_level[t-1]
     if previous_stock_level < 0.75 * capacity:  // Stock has decreased significantly
       action = D
     elif opponent_actions[t-1] == D:  // Tit-for-Tat component
       action = D
     elif stock_level[t-1] < 0.5 * capacity:  // Stock sensitivity
       action = C
     else:
       action = C

   observe opponents' actions and payoffs
   update opponent_actions, my_payoffs, and stock_level
```
**Edge Cases:**

* Last Round: Cooperate (C) in the final round to maximize collective payoff and maintain a cooperative reputation.
* Low Stock Levels: If the stock level is critically low (i.e., below 25% of the capacity), defect (D) in the current round to ensure some individual payoff.

**Collective Mindset:**

ASSTT prioritizes cooperation when the stock level is sufficient, promoting collective sustainability. By mirroring opponents' actions and adjusting to stock levels, this strategy encourages reciprocity and cooperation while protecting against exploitation.

By implementing ASSTT, we create a robust and adaptive strategy that balances individual payoff maximization with collective resource management, making it suitable for a wide range of opponent behaviors in the tournament.
'''

description_COLLECTIVE_599 = '''
**Collective Strategy: Adaptive Cooperation with Stock-Based Trigger (ACS-T)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a cooperative baseline and encourage others to reciprocate.
2. **Stock-Dependent Cooperation:** In subsequent rounds, cooperate if the current stock level is above a threshold (τ) calculated as:

τ = capacity / (2n)

This ensures that the stock remains sustainable, allowing for cooperation to be beneficial in the long run.

3. **Defection Trigger:** If the current stock level falls below τ or if the opponent's average consumption exceeds the cooperative share (stock/(2n)), switch to defecting (D) for one round to signal dissatisfaction and encourage opponents to adjust their behavior.
4. **Reversion to Cooperation:** After a single round of defection, revert to cooperation if the current stock level has recovered above τ or if the opponent's average consumption has decreased.

**Edge Case Handling:**

1. **Last Round:** In the final round, always cooperate (C) regardless of the stock level, as there is no future benefit to defecting.
2. **Zero Stock:** If the stock reaches zero, the game effectively ends, and all players receive zero payoffs. In this case, our strategy defaults to cooperation in the next round, hoping that opponents will also restart cooperation.

**Collective Mindset:**

ACS-T prioritizes collective sustainability by maintaining a balance between individual gains and stock preservation. By cooperating when the stock is above the threshold (τ), we encourage others to do the same, ensuring a stable and beneficial environment for all players. When opponents exploit this cooperation or the stock level drops too low, our strategy adapts by introducing a defecting phase to signal dissatisfaction and promote adjustments in opponent behavior.

**Pseudocode:**
```markdown
# Initialize variables
stock = capacity
n = number of players
r = number of rounds
tau = capacity / (2 * n)
avg_opponent_consumption = 0

# Game loop
for t = 1 to r:
    # First round: cooperate
    if t == 1:
        action = C
    else:
        # Check stock level and opponent consumption
        if stock > tau and avg_opponent_consumption <= stock / (2 * n):
            action = C
        elif stock < tau or avg_opponent_consumption > stock / (2 * n):
            action = D  # Defect for one round to signal dissatisfaction
        else:
            action = C  # Revert to cooperation

    # Update stock level and opponent consumption average
    if action == C:
        consumption = stock / (2 * n)
    else:
        consumption = stock / n
    avg_opponent_consumption += consumption / n
    stock -= consumption + sum(opponents' consumptions)
    growth = 2 * stock_remaining * (1 - stock_remaining / capacity)
    stock = min(stock + growth, capacity)

    # Update tau if necessary
    tau = capacity / (2 * n)
```
This strategy is designed to be robust and adaptive in a wide range of opponent behaviors, while prioritizing collective sustainability and cooperation.
'''

description_COLLECTIVE_600 = '''
Here's a collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and game states:

**Strategy Name:** Adaptive Collective Harvesting (ACH)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) if stock is above 75% of capacity, Defect (D) otherwise.
2. **Subsequent Rounds (t>1):**
	* If the average payoff per player in the previous round was below 50% of the maximum possible payoff (i.e., stock/(2n)), Defect (D).
	* If the stock level is above 75% of capacity and at least one player defected in the previous round, Cooperate (C) with probability 0.5, Defect (D) otherwise.
	* In all other cases, Cooperate (C).

**Edge Cases:**

1. **Last Round (t=r):** Defect (D), as there's no future rounds to consider.
2. **Low Stock Levels:** If the stock level is below 25% of capacity, Defect (D) in all subsequent rounds, as cooperation will not yield sufficient payoffs.
3. **High Stock Levels:** If the stock level is above 90% of capacity and at least one player defected in the previous round, Cooperate (C) with probability 0.75, Defect (D) otherwise.

**Collective Mindset:**

ACH prioritizes cooperation when the collective payoff is high or when opponents are cooperative. However, it adapts to defection by switching to defecting behavior when payoffs are low or when opponents exploit the common pool resource. By doing so, ACH aims to maintain a balance between individual and collective interests.

**Pseudocode:**

```
function AdaptiveCollectiveHarvesting(stock, capacity, n, r, t, prev_payoffs):
  if t == 1:
    if stock >= 0.75 * capacity:
      return Cooperate
    else:
      return Defect

  avg_prev_payoff = sum(prev_payoffs) / n
  max_possible_payoff = stock / (2 * n)

  if avg_prev_payoff < 0.5 * max_possible_payoff:
    return Defect

  if stock >= 0.75 * capacity and any(prev_actions == Defect):
    return random_choice([Cooperate, Defect], [0.5, 0.5])

  if stock <= 0.25 * capacity:
    return Defect

  if stock >= 0.9 * capacity and any(prev_actions == Defect):
    return random_choice([Cooperate, Defect], [0.75, 0.25])

  return Cooperate
```

This strategy is designed to be robust against various opponent behaviors and game states, while prioritizing collective well-being when possible. Its adaptive nature allows it to respond effectively in different scenarios, making it a strong contender in the tournament.
'''

description_EXPLOITATIVE_513 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

Decision Rules:

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and avoid unnecessary depletion of the stock.
2. **Stock Threshold**: Calculate a dynamic stock threshold `T` based on the current stock level `S`, capacity, and number of players `n`. If `S` falls below `T`, switch to Defect (D).
	* `T = capacity / (2 * n) + (S - capacity / (2 * n)) / 2`
3. **Opponent Behavior**: Observe opponents' actions in previous rounds and calculate the average cooperation rate `α`. If `α` is below a certain threshold (`α_threshold = 0.5`), assume opponents are mostly Defectors and switch to Defect.
4. **Round Progression**: As the game progresses, gradually decrease the stock threshold `T` by a small factor (`γ = 0.05`) each round, making it more likely to defect as the game approaches its end.

Pseudocode:
```python
def adaptive_stock_hawk(current_stock, capacity, num_players, round_number, opponent_actions):
    # Initial Round: Cooperate
    if round_number == 1:
        return 'C'

    # Calculate stock threshold T
    S = current_stock
    n = num_players
    T = capacity / (2 * n) + (S - capacity / (2 * n)) / 2

    # Observe opponent behavior and adjust α_threshold if necessary
    alpha = calculate_average_cooperation_rate(opponent_actions)
    if alpha < 0.5:
        return 'D'

    # Dynamic stock threshold adjustment based on round progression
    gamma = 0.05
    T *= (1 - gamma * (round_number / total_rounds))

    # Cooperate or Defect based on current stock level and threshold
    if S >= T:
        return 'C'
    else:
        return 'D'

def calculate_average_cooperation_rate(opponent_actions):
    # Calculate average cooperation rate α from opponent actions history
    # (Implementation details omitted for brevity)
```
Edge Cases:

* **Last Round**: In the final round, always Defect to maximize individual payoff.
* **Low Stock Levels**: If the stock level falls below a certain minimum threshold (`min_stock_threshold = capacity / (2 * n)`), always Defect to avoid further depletion.

This strategy is designed to be adaptive and robust against various opponent behaviors. By monitoring opponents' actions and adjusting its decision-making based on the game's state and history, "Adaptive Stock Hawk" aims to maximize individual payoff while exploiting potential weaknesses in opponents' strategies.
'''

description_EXPLOITATIVE_514 = '''
**Exploitative Strategy: "Adaptive Predator"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and initial stock level.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize short-term gain.
	* If the current stock level is between 25% and 75% of the capacity:
		+ Calculate the average opponent payoff in the previous round (π_avg).
		+ If π_avg > S/(2n), where S is the current stock level, Cooperate (C) to avoid over-exploitation.
		+ Otherwise, Defect (D) to exploit opponents' caution.
	* If the current stock level is below 25% of the capacity, Cooperate (C) to conserve the resource and prevent depletion.
3. **Last Round (t=r):** Always Defect (D), as there's no future benefit in cooperating.

**Edge Cases:**

1. **Stock Level equals 0:** If the stock level is depleted, always Cooperate (C) to allow for potential regeneration.
2. **Opponent Payoff History:** Keep track of opponents' average payoffs over time. If an opponent consistently cooperates, exploit their generosity by Defecting (D).

**Pseudocode:**
```python
def adaptive_predator(n, r, capacity, stock_history, payoff_history):
    if t == 1:
        return "C"  # Cooperate in the first round

    current_stock = stock_history[-1]
    avg_opponent_payoff = sum(payoff_history) / len(payoff_history)

    if current_stock > 0.75 * capacity:
        return "D"  # Defect when stock is high
    elif 0.25 * capacity <= current_stock < 0.75 * capacity:
        if avg_opponent_payoff > current_stock / (2 * n):
            return "C"  # Cooperate to avoid over-exploitation
        else:
            return "D"  # Defect to exploit opponents' caution
    elif current_stock < 0.25 * capacity:
        return "C"  # Conserve resource when stock is low

    if t == r:
        return "D"  # Always defect in the last round

    # If stock level equals 0, cooperate to allow for regeneration
    if current_stock == 0:
        return "C"
```
**Rationale:**

This strategy balances short-term gains with long-term sustainability. By cooperating initially and adapting to opponents' behavior, it gathers information about their strategies while minimizing the risk of over-exploitation. When stock levels are high, defecting maximizes short-term gain. As the game progresses, the strategy adjusts its behavior based on opponents' average payoffs, conserving resources when necessary and exploiting generosity when possible. In the final round, always defecting ensures maximum gain.

This exploitative mindset aligns with the tournament setting, where independent strategies will be employed by other AI systems. By being adaptive and robust to various opponent behaviors, "Adaptive Predator" is well-suited for a competitive environment.
'''

description_EXPLOITATIVE_515 = '''
I'll design a strategy that balances short-term gains with long-term sustainability, adapting to the game's state and history.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behaviors and set a baseline for future adaptations.
2. **Stock Thresholds**: Define two stock thresholds:
	* `LOW_STOCK` = 0.25 * capacity
	* `HIGH_STOCK` = 0.75 * capacity

These thresholds will guide our adaptive behavior.

3. **Adaptive Behavior**:

a. If current stock is above `HIGH_STOCK`, Defect (D) to maximize short-term gains.
b. If current stock is below `LOW_STOCK`, Cooperate (C) to conserve the resource and avoid depletion.
c. If current stock is between `LOW_STOCK` and `HIGH_STOCK`, use a **historical analysis**:

	* Calculate the average payoff per player over the last 3 rounds (`avg_payoff_3r`).
	* Compare it to the average payoff per player when all players Cooperate (`coop_avg_payoff`):

		+ If `avg_payoff_3r` > `coop_avg_payoff`, Defect (D) to exploit the situation.
		+ Otherwise, Cooperate (C) to maintain a sustainable stock level.

**Pseudocode for Adaptive Behavior**
```python
def adaptive_behavior(stock, history):
    if stock >= HIGH_STOCK:
        return 'Defect'
    elif stock <= LOW_STOCK:
        return 'Cooperate'
    else:
        avg_payoff_3r = calculate_average_payoff(history, 3)
        coop_avg_payoff = calculate_cooperative_average_payoff()
        if avg_payoff_3r > coop_avg_payoff:
            return 'Defect'
        else:
            return 'Cooperate'
```
**Edge Cases:**

1. **Last Round**: In the last round, always Defect (D) to maximize final payoff, regardless of stock level.
2. **Ties in Historical Analysis**: If there's a tie in historical analysis (e.g., `avg_payoff_3r` == `coop_avg_payoff`), Cooperate (C) to prioritize sustainability.

**Exploitative Mindset:**

AE aims to balance short-term gains with long-term sustainability by adapting to the game's state and history. By defecting when stock is high or opponents are being exploited, AE seeks to maximize payoffs while maintaining a healthy stock level for future rounds. When necessary, AE will cooperate to conserve resources and set up future exploitation opportunities.

**Robustness:**

AE's adaptability makes it robust against various opponent behaviors, as it adjusts its strategy based on observed payoffs and stock levels. By not relying on specific coordination mechanisms or norms, AE is well-suited for a tournament environment with diverse opponents.

This strategy should perform effectively in the Common Pool Resource Game tournament, exploiting opportunities while maintaining a sustainable approach to resource management.
'''

description_EXPLOITATIVE_516 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behaviors and avoid initial stock depletion.
2. **Middle Rounds (2 ≤ t < r-1)**:
	* If the current stock level is high (S > capacity/2), Defect (D) to exploit the resource.
	* If the current stock level is low (S ≤ capacity/2), Cooperate (C) to conserve the resource and avoid depletion.
3. **Last Round (t=r)**: Defect (D) regardless of the current stock level, as there are no future rounds to consider.

Adaptive Component:

1. **Opponent Behavior Analysis**: Track the number of opponents who Defected (D) in the previous round.
2. **Stock Depletion Threshold**: Calculate a threshold value for the stock level based on the opponent behavior analysis:
	* If more than half of the opponents Defected in the previous round, set the threshold to 75% of the capacity (to account for potential over-exploitation).
	* Otherwise, set the threshold to 50% of the capacity.
3. **Adaptive Decision**: Use the calculated threshold to adjust the decision rules:
	* If the current stock level is above the threshold, Defect (D) to exploit the resource.
	* If the current stock level is at or below the threshold, Cooperate (C) to conserve the resource.

Pseudocode:

```
Initialize variables:
  S = capacity // initial stock level
  t = 1 // current round
  opponents_defected = 0 // number of opponents who defected in previous round

While t <= r:
  If t == 1:
    Play C (cooperate)
  Else:
    Calculate threshold based on opponent behavior analysis
      If opponents_defected > n/2:
        threshold = capacity * 0.75
      Else:
        threshold = capacity / 2
    
    If S > threshold:
      Play D (defect)
    Else:
      Play C (cooperate)

  Update variables:
    S = new stock level after consumption and growth
    opponents_defected = count of opponents who defected in current round
    t += 1

End While
```

This strategy aims to balance exploitation with conservation, adapting to the behavior of other players and the state of the resource. By cooperating initially and analyzing opponent behavior, it can identify opportunities to defect and maximize payoffs while minimizing the risk of stock depletion.
'''

description_EXPLOITATIVE_517 = '''
**Exploitative Strategy: "Adaptive Depletion"**

The Adaptive Depletion strategy aims to exploit the game's dynamics by balancing short-term gains with long-term sustainability. It adapts to the current state and history of the game, without relying on coordination or cooperation from other players.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if `stock >= capacity * 0.75` (i.e., stock is above 75% of capacity)
	* Defect (D) otherwise
2. **Subsequent Rounds (t>1):**
	* Calculate the average consumption per player in the previous round (`avg_consumption_prev`)
	* If `stock >= avg_consumption_prev * n` (i.e., stock can sustain average consumption), Cooperate (C)
	* Otherwise, Defect (D) if `stock < capacity / 2` or if `total_payoff / r <= stock / (2n)` (i.e., current payoff rate is below sustainable level)
3. **Last Round (t=r):**
	* Defect (D), as there's no future benefit to cooperation

**Edge Cases:**

* If multiple players defect in the same round, prioritize Defecting to maximize individual payoff
* In cases where `stock` approaches 0, Cooperate to allow for some growth and potential future gains

**Pseudocode:**
```markdown
# Initialize variables
n = number of players
r = number of rounds
capacity = maximum sustainable stock level
stock = current stock level
total_payoff = cumulative payoff over all rounds

for t in range(r):
    if t == 1:
        # Initial round decision rule
        if stock >= capacity * 0.75:
            action[t] = C
        else:
            action[t] = D
    else:
        # Calculate average consumption per player in previous round
        avg_consumption_prev = total_consumption[t-1] / n
        
        # Decision rules for subsequent rounds
        if stock >= avg_consumption_prev * n:
            action[t] = C
        elif stock < capacity / 2 or (total_payoff / r) <= (stock / (2n)):
            action[t] = D

    # Last round decision rule
    if t == r:
        action[t] = D

    # Update game state and payoff
    total_consumption[t] = sum(consumption_i for i in range(n))
    stock[t+1] = min(stock[t] - total_consumption[t] + growth, capacity)
    total_payoff += payoff[t]
```
The Adaptive Depletion strategy balances short-term gains with long-term sustainability by adapting to the current state and history of the game. By cooperating when the stock is above a certain threshold and defecting otherwise, it aims to maximize individual payoffs while minimizing the risk of stock depletion.
'''

description_EXPLOITATIVE_518 = '''
**Exploitative Strategy: Adaptive Stock Depletion (ASD)**

The ASD strategy aims to maximize individual payoffs by adaptively responding to the game's state and history while exploiting potential cooperative behavior from opponents.

**Decision Rules**

1. **Initial Round**: Defect (play D) in the first round to gauge opponents' initial strategies and set a high consumption baseline.
2. **General Case**: Observe the current stock level (S) and the number of remaining rounds (r_remaining). Calculate the threshold stock level (TSL) as follows:

TSL = capacity \* (1 - 1 / (2n))

If S > TSL, cooperate (play C); otherwise, defect (play D).
3. **Adaptation**: Monitor opponents' past actions and adjust the decision rule based on their cooperation rate. If most opponents have cooperated (>50% of players) in the previous rounds, increase the TSL by 10% to take advantage of potential cooperation.

**Handling Edge Cases**

1. **Last Round**: Always defect (play D) in the final round to maximize individual payoffs regardless of the game's state.
2. **Low Stock Levels**: When S < capacity / (2n), always cooperate (play C) to ensure some stock remains and prevent a complete depletion.
3. **Opponent Cooperation Patterns**: If most opponents (>75% of players) have consistently cooperated in previous rounds, adjust the decision rule to always defect (play D). This prevents being exploited by overly cooperative opponents.

**Pseudocode**
```python
def ASD(n, capacity, S, r_remaining):
    TSL = capacity * (1 - 1 / (2n))

    if S > TSL:
        action = 'C'  # Cooperate
    else:
        action = 'D'  # Defect

    # Adapt to opponent cooperation rate
    if opponents_cooperated_rate > 0.5 and r_remaining > 1:
        TSL *= 1.1

    # Handle edge cases
    if r_remaining == 1:
        action = 'D'  # Always defect in the last round
    elif S < capacity / (2n):
        action = 'C'  # Cooperate to maintain some stock level

    return action
```
**Exploitative Mindset**

The ASD strategy prioritizes individual payoffs by adaptively responding to the game's state and exploiting potential cooperative behavior from opponents. By defecting in the initial round, it sets a high consumption baseline and pressures opponents to adjust their strategies. The adaptive threshold stock level allows the strategy to balance cooperation and defection based on the current game state and opponent actions.

This exploitative approach is robust to various opponent behaviors and does not rely on coordination mechanisms or predetermined patterns. It will perform well in a tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_519 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize its payoff by adaptively responding to the game's state and history, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Cooperate (C) with a probability of 0.5. This initial cooperation serves as a probe to gauge opponents' behavior.
2. **Subsequent Rounds (t>1)**:
	* Calculate the average payoff per player in the previous round (`avg_payoff_prev`).
	* If `avg_payoff_prev` is greater than or equal to `stock/(2n)`, cooperate (C). This indicates that opponents are cooperating, and we can safely harvest a moderate amount.
	* Otherwise, defect (D). This suggests that opponents are exploiting the stock, and we should maximize our gain before the stock depletes.
3. **Stock Threshold**:
	* If the current stock level (`stock`) falls below `0.5 * capacity`, always defect (D). This ensures we exploit the remaining stock before it's too late.

**Additional Heuristics:**

1. **Recent Defection Detection**:
	* Monitor opponents' actions in the last `m` rounds (e.g., `m=3`). If a majority of opponents defected, increase the probability of defecting in the current round.
2. **Stock Rebound**: 
	* After a round where the stock grew significantly (e.g., `growth > 0.5 * capacity`), cooperate (C) with increased probability (e.g., 0.7). This allows us to take advantage of the replenished stock.

**Pseudocode:**
```python
def adaptive_stock_raider(stock, capacity, n, t, history):
    if t == 1:
        # Initial round
        return random.choice([C, D]) with prob 0.5
    
    avg_payoff_prev = calculate_avg_payoff(history)
    if avg_payoff_prev >= stock / (2 * n):
        # Cooperate if opponents are cooperative
        return C
    else:
        # Defect if opponents are exploiting
        return D

    if stock < 0.5 * capacity:
        # Stock threshold: always defect when low
        return D

def recent_defection_detection(history, m):
    defector_count = sum(1 for action in history[-m:] if action == D)
    return defector_count > (m / 2)

def stock_rebound(growth, capacity):
    return growth > 0.5 * capacity
```
**Tournament Play:**

This strategy will be effective in a tournament setting as it:

1. Adapts to opponents' behavior through the `avg_payoff_prev` calculation.
2. Responds to changes in the stock level and its growth.
3. Uses heuristics to detect recent defection patterns and adjust accordingly.

The "Adaptive Stock Raider" strategy is exploitative, yet robust and responsive to various opponent behaviors, making it a formidable competitor in the tournament.
'''

description_EXPLOITATIVE_520 = '''
I'll introduce a robust and exploitative strategy for the Common Pool Resource Game, dubbed "Adaptive Exploiter" (AE). This strategy aims to maximize payoffs by adaptively responding to the game state, history, and opponents' behaviors.

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) with a probability of 0.5, and Defect (D) with a probability of 0.5. This mixed strategy allows for exploration and gathering information about opponents.
2. **Subsequent Rounds**: Evaluate the game state and history using the following criteria:
	* **Stock Level**: If the current stock level is above 75% of capacity, play D. This threshold encourages exploiting the resource when it's abundant.
	* **Opponent Behavior**: Analyze the actions of opponents in previous rounds. If a majority (>50%) of opponents played C, switch to D for this round. Otherwise, maintain the same action as the previous round (or randomize if no history is available).
	* **Recent Payoffs**: Monitor individual payoffs over the last few rounds (e.g., 3-5 rounds). If average payoffs are below a certain threshold (e.g., capacity/4), switch to D for this round.
3. **Additional Conditions**:
	* **Low Stock Warning**: If the stock level falls below 25% of capacity, play C with a higher probability (e.g., 0.7). This helps prevent complete depletion and maintain a sustainable resource.
	* **Endgame**: In the last few rounds (e.g., r-2 to r), prioritize D over C, as there's less incentive to cooperate when the game is near its end.

**Pseudocode:**
```python
def Adaptive_Exploiter(n, capacity, stock, history):
  # Initial round
  if history == []:
    return random.choice([C, D], p=[0.5, 0.5])
  
  # Evaluate game state and history
  if stock > 0.75 * capacity:
    action = D
  elif majority_opponents_played_C(history):
    action = D
  else:
    action = same_action_as_previous_round(history) or random.choice([C, D], p=[0.5, 0.5])
  
  # Adjust for low stock and endgame conditions
  if stock < 0.25 * capacity:
    action = C with probability 0.7
  elif round_number > r - 2:
    action = D
  
  return action

def majority_opponents_played_C(history):
  opponent_actions = [action for action in history[-1] if action != own_action]
  return sum(opponent_actions == C) / len(opponent_actions) > 0.5
```
**Rationale:**

The Adaptive Exploiter strategy balances short-term gains with long-term sustainability by:

* Initially exploring the game environment and gathering information about opponents.
* Adapting to changes in the game state, opponent behavior, and recent payoffs.
* Prioritizing exploitation when resources are abundant or when opponents cooperate excessively.
* Maintaining a sustainable resource level by cooperating when stocks are low.
* Focusing on short-term gains near the end of the game.

This strategy is designed to be robust against various opponent behaviors and can adapt to different game environments.
'''

description_EXPLOITATIVE_521 = '''
To design an exploitative strategy for this Common Pool Resource Game, we'll focus on adapting to the game's state and history while maximizing our payoff. Here's a decision-making approach that balances cooperation and defection:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to observe the opponents' actions and gauge their behavior.
2. **Defection Threshold**: Introduce a Defection Threshold (DT) variable, initialized to 0.5. This threshold will determine when to switch from Cooperate to Defect based on the stock level.
3. **Stock-based Adaptation**: In each subsequent round, calculate the current Stock Ratio (SR) as: SR = current_stock / capacity
	* If SR ≥ DT, play Cooperate (C).
	* If SR < DT, play Defect (D).
4. **Opponent Behavior Analysis**: Track the opponents' actions and adjust the Defection Threshold accordingly:
	* If most opponents (> 50%) played Defect in the previous round, decrease DT by 0.1 to become more cautious.
	* If most opponents (> 50%) played Cooperate in the previous round, increase DT by 0.1 to exploit potential cooperation.
5. **Last Round**: In the final round (r), play Defect (D) regardless of the stock level or opponent behavior.

**Pseudocode:**
```
 Initialize DT = 0.5

 FOR each round t FROM 1 TO r:
   IF t == 1:
     Play Cooperate (C)
   ELSE:
     Calculate Stock Ratio SR = current_stock / capacity
     IF SR ≥ DT:
       Play Cooperate (C)
     ELSE:
       Play Defect (D)

   Analyze opponent behavior from previous round:
     IF most opponents (> 50%) played Defect:
       Decrease DT by 0.1
     ELSE IF most opponents (> 50%) played Cooperate:
       Increase DT by 0.1

   IF t == r: // Last round
     Play Defect (D)
```
**Rationale:**

* By cooperating in the first round, we gather information about our opponents' initial behavior.
* The Stock-based Adaptation rule allows us to adjust our strategy based on the current stock level, becoming more cautious when the stock is low and more exploitative when it's high.
* Analyzing opponent behavior helps us adapt to their strategies, decreasing the Defection Threshold when opponents are mostly defecting and increasing it when they're cooperating.
* Playing Defect in the last round ensures we maximize our payoff regardless of the game's state.

**Exploitative Mindset:**

The Adaptive Exploiter strategy is designed to exploit the cooperation of other players while minimizing the risk of over-exploitation. By adapting to the stock level and opponent behavior, we aim to maximize our payoff in each round, taking advantage of the Common Pool Resource Game's dynamics.

This strategy should perform well against a wide range of opponent behaviors, as it balances cooperation and defection based on the game's state and history.
'''

description_EXPLOITATIVE_522 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

The ASE strategy is designed to exploit opponents' behaviors while adapting to the dynamic state of the game. It balances short-term gains with long-term sustainability.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and set a baseline for future decisions.
2. **Subsequent Rounds (t>1):**
	* If the stock level is above 75% of capacity, Defect (D) to maximize short-term gains.
	* If the stock level is between 50% and 75% of capacity, Cooperate (C) to balance short-term gains with long-term sustainability.
	* If the stock level is below 50% of capacity, Defect (D) to take advantage of opponents' potential cooperation and maximize remaining gains.
3. **Last Round (t=r):** Defect (D) to maximize final-round payoffs, as there are no future rounds to consider.

**Additional Heuristics:**

1. **Opponent Monitoring:** Track the number of cooperators (C_count) and defectors (D_count) in each round.
2. **Adaptive Thresholds:** Adjust the 75% and 50% stock level thresholds based on opponents' behaviors:
	* If C_count > D_count, decrease the thresholds by 10% to encourage cooperation.
	* If D_count > C_count, increase the thresholds by 10% to discourage defection.
3. **Punishment Mechanism:** If an opponent defects while the stock level is below 25% of capacity, ASE will Defect (D) in the next round to punish them and prevent further exploitation.

**Edge Cases:**

1. **Ties:** In case of a tie between C_count and D_count, ASE will Cooperate (C).
2. **Zero Stock:** If the stock level reaches 0, ASE will Defect (D) in the next round to maximize payoffs from any potential growth.

**Pseudocode:**
```markdown
# Initialize variables
stock_level = capacity
C_count = 0
D_count = 0

# Loop through rounds
for t in range(1, r+1):
    # Determine action based on decision rules and heuristics
    if t == 1:
        action = C
    elif stock_level > 0.75 * capacity:
        action = D
    elif stock_level >= 0.5 * capacity:
        action = C
    else:
        action = D
    
    # Update opponent monitoring variables
    if action == C:
        C_count += 1
    else:
        D_count += 1

    # Adjust thresholds based on opponent behaviors
    if C_count > D_count:
        threshold_75 -= 0.1
        threshold_50 -= 0.1
    elif D_count > C_count:
        threshold_75 += 0.1
        threshold_50 += 0.1

    # Punishment mechanism
    if opponent_defected and stock_level < 0.25 * capacity:
        action = D
    
    # Update stock level based on actions
    total_consumption = sum(actions)
    stock_level -= total_consumption
    growth = 2 * stock_level * (1 - stock_level / capacity)
    stock_level = min(stock_level + growth, capacity)

# Return total payoff
return sum(payoffs)
```
The Adaptive Stock Exploiter strategy is designed to balance short-term gains with long-term sustainability while adapting to opponents' behaviors. By monitoring opponent actions and adjusting decision rules accordingly, ASE aims to maximize payoffs in a wide range of scenarios.
'''

description_EXPLOITATIVE_523 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Overview**
Our strategy, Adaptive Stock Raider, aims to maximize individual payoff by exploiting the common pool resource while adapting to opponents' behaviors and the dynamic state of the game.

**Decision Rules**

1. **Initial Round (t=1)**: Defect (D) - Take advantage of the full capacity and set the tone for potential opponents.
2. **Subsequent Rounds (t>1)**:
	* If the stock level is high (> 0.75 \* capacity), Cooperate (C) to sustain the resource and maximize long-term payoffs.
	* If the stock level is moderate (0.25 \* capacity ≤ stock ≤ 0.75 \* capacity), Defect (D) with probability p, where:
		+ p = (number of opponents who defected in previous round) / n
		+ This probabilistic approach allows us to adapt to opponents' behaviors while maintaining a level of unpredictability.
	* If the stock level is low (< 0.25 \* capacity), Defect (D) - Attempt to exploit any remaining resources before they deplete completely.
3. **Last Round (t=r)**: Defect (D) - Maximize individual payoff in the final round, as there's no future resource to conserve.

**Edge Case Handling**

1. **Tie-breaking**: In cases where multiple opponents have defected with the same probability, our strategy will randomly choose between Cooperate and Defect.
2. **Opponent Behavior Change**: If an opponent changes their behavior (e.g., from Cooperate to Defect), our strategy will reassess the situation in the next round based on the updated information.

**Pseudocode**
```
function AdaptiveStockRaider(current_stock, capacity, n, t, previous_actions):
  if t == 1:  # Initial Round
    return "Defect"
  
  if current_stock > 0.75 * capacity:
    return "Cooperate"
  
  elif 0.25 * capacity <= current_stock <= 0.75 * capacity:
    p = (number of opponents who defected in previous round) / n
    if random.random() < p:
      return "Defect"
    else:
      return "Cooperate"
  
  elif current_stock < 0.25 * capacity:
    return "Defect"
  
  elif t == r:  # Last Round
    return "Defect"
```
**Exploitative Mindset**
Our strategy is designed to exploit the common pool resource while adapting to opponents' behaviors and the dynamic state of the game. By defecting in the initial round, we set a competitive tone and test our opponents' strategies. In subsequent rounds, we balance cooperation and defection based on the stock level and opponents' actions, ensuring that we maximize our individual payoff while minimizing the risk of resource depletion.

This strategy is robust to various opponent behaviors, as it adapts to their actions and adjusts its own behavior accordingly. By not relying on coordination mechanisms or predetermined patterns, we minimize the risk of being exploited by other strategies.
'''

description_EXPLOITATIVE_524 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

The ASE strategy aims to maximize its payoff by adaptively responding to the game's state and history, exploiting opponents' behaviors while ensuring long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Observe the initial stock level and calculate the average consumption per player if all cooperate (C_avg = capacity / (2n)).
	* If C_avg is greater than or equal to 25% of the capacity, play Cooperate (C). Otherwise, play Defect (D).
2. **Subsequent Rounds (t>1):**
	* Calculate the average payoff per player in the previous round (avg_payoff_prev).
	* Determine the total consumption in the previous round (total_consumption_prev = Σ(i=1 to n) consumption_i,t-1).
	* If the stock level has increased or remained the same since the last round (stock_t ≥ stock_t-1), play Cooperate (C).
	* Else, if avg_payoff_prev is greater than or equal to 50% of the capacity and total_consumption_prev is less than or equal to 75% of the capacity, play Defect (D). Otherwise, play Cooperate (C).
3. **Last Round (t=r):**
	* Play Defect (D) if the stock level is greater than or equal to 25% of the capacity. Otherwise, play Cooperate (C).

**Edge Cases:**

1. If the stock level reaches zero, play Cooperate (C) to allow for regrowth.
2. If an opponent's action is unknown or missing, assume they played Defect (D).

**Exploitative Mindset:**

The ASE strategy aims to exploit opponents' behaviors by:

1. Initially cooperating if the average consumption per player is high enough, encouraging others to cooperate and maintain a healthy stock level.
2. Adapting to changes in the stock level and average payoff, switching between cooperation and defection to maximize payoffs while ensuring long-term sustainability.
3. Defecting in the last round if the stock level is sufficient, taking advantage of the endgame situation.

**Pseudocode:**
```python
def ASE_strategy(stock, capacity, n, t, r, avg_payoff_prev, total_consumption_prev):
  if t == 1:
    C_avg = capacity / (2 * n)
    if C_avg >= 0.25 * capacity:
      return 'C'
    else:
      return 'D'

  elif stock_t >= stock_t-1:
    return 'C'

  elif avg_payoff_prev >= 0.5 * capacity and total_consumption_prev <= 0.75 * capacity:
    return 'D'

  elif t == r:
    if stock_t >= 0.25 * capacity:
      return 'D'
    else:
      return 'C'

  else:
    return 'C'
```
The ASE strategy is designed to be robust and adaptive, responding to various opponent behaviors while maximizing payoffs in the Common Pool Resource Game.
'''

description_EXPLOITATIVE_525 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk (ASH) strategy is designed to exploit the common pool resource game by adapting to the current state and history of the game, while also being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round:** In the first round, ASH plays Cooperate (C). This allows for a safe start, enabling us to observe our opponents' initial actions without compromising the stock.
2. **Stock Thresholds:** Define two stock thresholds:
	* **Low Stock Threshold (LST):** 0.5 \* capacity
	* **High Stock Threshold (HST):** 0.8 \* capacity

ASH uses these thresholds to determine its action based on the current stock level.

3. **Action Selection:**
	* If stock ≤ LST, play Defect (D). This ensures that ASH takes advantage of the low stock situation and maximizes its payoff.
	* If stock > LST and < HST, play Cooperate (C) if at least half of the opponents played C in the previous round. Otherwise, play D. This rule allows ASH to cooperate when there's a reasonable chance that others will do so as well, while also being cautious not to get exploited.
	* If stock ≥ HST, play Defect (D). When the stock is high, ASH takes advantage of the situation and maximizes its payoff.

**Edge Cases:**

1. **Last Round:** In the final round, ASH always plays Defect (D), as there's no future cost to exploiting the remaining stock.
2. **Tied Stock Levels:** If multiple players have the same stock level, ASH breaks ties by playing Cooperate (C) if it has a higher total payoff so far; otherwise, it plays Defect (D).

**Pseudocode:**
```
function AdaptiveStockHawk(state, history):
  // Initialize variables
  capacity = state.capacity
  LST = 0.5 * capacity
  HST = 0.8 * capacity

  // First round
  if history.isEmpty():
    return Cooperate

  // Determine stock level and opponent actions
  current_stock = state.stock
  opponent_actions = history.getLastRoundActions()

  // Calculate number of cooperating opponents
  num_cooperating_opponents = count(opponent_actions, Cooperate)

  // Decide action based on stock thresholds and opponent actions
  if current_stock <= LST:
    return Defect
  elseif current_stock > LST and < HST:
    if num_cooperating_opponents >= (numOpponents / 2):
      return Cooperate
    else:
      return Defect
  else: // stock >= HST
    return Defect

  // Last round
  if state.round == state.totalRounds:
    return Defect

  // Tied stock levels
  if current_stock == history.getLastRoundStock():
    if myPayoff > history.getHighestPayoff():
      return Cooperate
    else:
      return Defect
```
This strategy is designed to be exploitative, adaptive, and robust to various opponent behaviors. By using the stock thresholds and observing opponent actions, ASH aims to maximize its payoff while minimizing the risk of being exploited.
'''

description_EXPLOITATIVE_526 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) with probability 0.5 and Defect (D) with probability 0.5 to gather information about opponents' initial behaviors.
2. **Subsequent Rounds (t>1)**:
	* If the stock level is above a certain threshold (`stock_threshold = capacity / 2`), Defect (D).
	* If the stock level is below `stock_threshold`, Cooperate (C) with probability `p_coop` and Defect (D) with probability `(1 - p_coop)`.
	* Update `p_coop` based on the previous round's outcome:
		+ If the average payoff of cooperators in the previous round was higher than that of defectors, increase `p_coop` by 0.1.
		+ Otherwise, decrease `p_coop` by 0.1.

Pseudocode for updating `p_coop`:
```
if avg_payoff_coop > avg_payoff_defect:
    p_coop = min(1, p_coop + 0.1)
else:
    p_coop = max(0, p_coop - 0.1)
```
3. **Last Round (t=r)**: Defect (D) to maximize payoff in the final round.

**Handling Edge Cases:**

* If all players have defected in a previous round, resulting in a stock level of 0, Cooperate (C) in the next round to allow for potential recovery.
* If the game is in its last round and the stock level is below `stock_threshold`, Defect (D) to maximize payoff.

**Exploitative Mindset:**

The Adaptive Stock Raider strategy aims to exploit opponents' behaviors by:

1. Initially gathering information about their tendencies through randomization.
2. Adapting to changes in the game state by adjusting cooperation probability based on past outcomes.
3. Maximizing payoffs when possible, especially in later rounds.

This strategy is robust against various opponent behaviors and can effectively respond to different scenarios, making it a competitive contender in the tournament.
'''

description_EXPLOITATIVE_527 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk (ASH) strategy is designed to exploit opponents' behaviors while adapting to the dynamic state of the game. ASH balances short-term gains with long-term sustainability, ensuring a robust performance across various opponent strategies.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gather information about opponents' initial actions and set a benchmark for future comparisons.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Defect (D). This threshold allows ASH to exploit high stock levels while minimizing the risk of depletion.
	* If the average payoff per player in the previous round was higher than the game's theoretical maximum (capacity/2n), Cooperate (C). This condition indicates that opponents may be cooperating or using a gentle strategy, making cooperation a safer choice.
	* Otherwise, Defect (D).
3. **Low Stock Levels:** If the current stock level falls below 25% of capacity, Cooperate (C) to help replenish the stock and avoid depletion.
4. **Last Round (t=r):** Defect (D) in the final round to maximize short-term gains, as there are no future rounds to consider.

**Additional Heuristics:**

* **Stock Trend Analysis:** Monitor the stock level trend over the last 3-5 rounds. If the trend is decreasing, Cooperate (C) more frequently to help stabilize the stock.
* **Opponent Action Distribution:** Keep track of the proportion of opponents playing Cooperate (C) or Defect (D) in recent rounds. If a significant majority (>60%) is cooperating, ASH may adjust its strategy to Defect (D) more frequently.

**Pseudocode:**
```python
def adaptive_stock_hawk(stock, capacity, n, t, history):
    if t == 1:  # Initial round
        return C

    avg_payoff_prev = calculate_avg_payoff(history)
    stock_threshold = 0.75 * capacity
    low_stock_threshold = 0.25 * capacity

    if stock > stock_threshold:
        return D
    elif avg_payoff_prev > capacity / (2 * n):
        return C
    else:
        return D

    # Additional heuristics
    if stock < low_stock_threshold:
        return C
    elif t == r:  # Last round
        return D

    # Stock trend analysis and opponent action distribution adjustments can be added here
```
**Rationale:**

ASH's adaptive approach allows it to balance short-term gains with long-term sustainability. By defecting when the stock level is high, ASH exploits opponents' cooperation. When the average payoff per player is high, ASH cooperates to avoid depletion and maintain a stable stock level. The low stock threshold ensures that ASH helps replenish the stock when necessary.

ASH's decision rules are designed to be robust against various opponent strategies, including those that employ cooperation schedules or predetermined patterns. By monitoring the stock trend and opponent action distribution, ASH can adjust its strategy to respond effectively to changing game conditions.

In a tournament setting, ASH is likely to perform well against independent strategies developed by other AI systems, as it does not rely on shared norms or coordination mechanisms.
'''

description_EXPLOITATIVE_528 = '''
**Exploitative Strategy: Adaptive Stock Raider**

Decision Rules:

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behaviors and initial stock dynamics.
2. **Early Game (t < r/2)**:
	* If the current stock is high (> 75% of capacity), Defect (D) to maximize individual payoff, as there's enough stock for others to exploit later.
	* Otherwise, Cooperate (C) to conserve stock and maintain a stable environment.
3. **Mid-Game (t ≥ r/2)**:
	* Monitor the average opponent behavior: If more than 50% of opponents Defected in the previous round, Defect (D) to adapt to their exploitative nature.
	* Otherwise, Cooperate (C) to maintain a balance between individual gain and stock sustainability.
4. **Late Game (t > 3r/4)**:
	* If the current stock is low (< 25% of capacity), Defect (D) to secure any remaining payoffs before the game ends.
	* Otherwise, Cooperate (C) to prolong the game and potentially benefit from others' mistakes.

Edge Cases:

1. **Last Round (t=r)**: Always Defect (D) to maximize individual payoff, as there's no future stock to conserve.
2. **Opponent Homogeneity**: If all opponents consistently Cooperate or Defect, adapt by mirroring their behavior to avoid being exploited or missing opportunities.

**Adaptive Mechanisms**

* Monitor the current stock level and adjust behavior accordingly.
* Keep track of opponent actions in previous rounds to anticipate potential changes in their strategies.
* Respond to changes in opponent behavior by adapting the decision rules above.

Pseudocode (for illustration purposes):
```markdown
// Initialize variables
stock = capacity
opponent_actions = []
my_payoff = 0

// Main game loop
for t = 1 to r:
    // Initial round: Cooperate
    if t == 1:
        action = C
    
    // Early game: Balance individual gain and stock sustainability
    elif t < r/2:
        if stock > 0.75 * capacity:
            action = D
        else:
            action = C
    
    // Mid-game: Adapt to opponent behavior
    elif t >= r/2:
        avg_opponent_behavior = calculate_average_opponent_action(opponent_actions)
        if avg_opponent_behavior > 0.5:
            action = D
        else:
            action = C
    
    // Late game: Secure payoffs or prolong the game
    elif t > 3r/4:
        if stock < 0.25 * capacity:
            action = D
        else:
            action = C
    
    // Last round: Maximize individual payoff
    elif t == r:
        action = D
    
    // Update opponent actions and my payoff
    opponent_actions.append(opponent_action)
    my_payoff += calculate_my_payoff(stock, action)
    
    // Update stock level
    stock -= total_consumption()
```
This Adaptive Stock Raider strategy balances individual gain with stock sustainability while adapting to the behavior of opponents. By monitoring the game state and history, it aims to exploit opportunities for maximum payoff in a dynamic environment.
'''

description_EXPLOITATIVE_529 = '''
Here is a exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Stock Exploiter (ASE)

**Decision Rules:**

1. **Initial Round**: In the first round, cooperate (play C) to gauge the opponents' behavior and observe the initial stock consumption.
2. **Stock-based Threshold**: Calculate a dynamic threshold `T` based on the current stock level `S`: `T = S / (n * 2)`. If the stock level is below this threshold, defect (play D). Otherwise, cooperate.
3. **Opponent Behavior Analysis**: Track the number of opponents who defected (`D_count`) and cooperated (`C_count`) in the previous round. If `D_count > C_count`, defect in the current round to exploit the opponents' greedy behavior.
4. **Consecutive Defections**: If an opponent has defected for `consecutive_defection_threshold` (e.g., 2) rounds, assume they are playing a non-cooperative strategy and defect against them.
5. **Stock Growth Analysis**: Monitor the stock growth rate over the past few rounds. If the growth rate is consistently low, indicating over-exploitation, cooperate to allow the stock to recover.

**Edge Cases:**

1. **Last Round**: In the final round, always defect (play D) to maximize individual payoff.
2. **Low Stock Levels**: When the stock level is critically low (`S < n`), cooperate to ensure some payoff in the current round and potentially set up a better situation for the next round.

**Additional Considerations:**

1. **History-based Adaptation**: ASE adapts its strategy based on observed opponent behavior, making it more resilient to different types of opponents.
2. **Dynamic Threshold Adjustment**: The stock-based threshold `T` adjusts dynamically with the current stock level, allowing ASE to respond effectively to changing environmental conditions.

Pseudocode for ASE:
```python
def ASE(n, r, capacity, history):
    S = get_current_stock()
    T = S / (n * 2)
    
    if is_first_round():
        return COOPERATE
    
    D_count, C_count = analyze_opponent_behavior(history)
    consecutive_defections = track_consecutive_defections(opponents)
    
    if S < T or D_count > C_count or consecutive_defections >= threshold:
        return DEFECT
    
    stock_growth_rate = monitor_stock_growth_rate(history)
    if stock_growth_rate is low:
        return COOPERATE
    
    # default to cooperate
    return COOPERATE

def analyze_opponent_behavior(history):
    # count number of opponents who defected and cooperated in previous round
    D_count, C_count = 0, 0
    for opponent in history[-1]:
        if opponent == DEFECT:
            D_count += 1
        else:
            C_count += 1
    return D_count, C_count

def track_consecutive_defections(opponents):
    # count consecutive defections by each opponent
    consecutive_defections = {}
    for opponent in opponents:
        if history[-1][opponent] == DEFECT:
            consecutive_defections[opponent] = consecutive_defections.get(opponent, 0) + 1
    return consecutive_defections

def monitor_stock_growth_rate(history):
    # calculate average stock growth rate over past few rounds
    growth_rates = []
    for i in range(len(history) - 1):
        growth_rate = (history[i+1] - history[i]) / capacity
        growth_rates.append(growth_rate)
    return sum(growth_rates) / len(growth_rates)
```
This strategy, ASE, aims to balance short-term gains with long-term sustainability by adapting to the dynamic game state and opponent behavior. Its exploitative nature should allow it to perform well in a tournament setting against various independent strategies.
'''

description_EXPLOITATIVE_530 = '''
**Exploitative Strategy: "Adaptive Stockpiler"**

**Decision Rules:**

1. **Initial Rounds (t ≤ 2):** Cooperate (C) to observe opponents' behavior and accumulate stock.
2. **Mid-Game (2 < t < r-2):**
	* If the current stock level is above 75% of capacity, Defect (D) to exploit the resource.
	* Otherwise, Cooperate (C) to conserve the stock and wait for opportunities to defect.
3. **Late Game (t ≥ r-2):** Defect (D) to maximize payoffs before the game ends.
4. **Opponent Analysis:** Monitor opponents' actions and adjust strategy accordingly:
	* If most opponents (> 50%) are Cooperating, Defect (D) to exploit their cooperation.
	* If most opponents (> 50%) are Defecting, Cooperate (C) to conserve the stock.

**Edge Cases:**

1. **First Round:** Cooperate (C) to gather information about opponents' initial behavior.
2. **Last Round (t = r):** Defect (D) to maximize payoffs, as there is no future round to consider.
3. **Low Stock Levels (stock < 25% of capacity):** Cooperate (C) to allow the stock to recover and avoid depletion.

**Pseudocode:**
```
function AdaptiveStockpiler(n, r, capacity, current_stock, history):
  if t <= 2:
    return C
  elif t >= r-2:
    return D
  else:
    if current_stock > 0.75 * capacity:
      return D
    elif most_opponents_cooperating(history):
      return D
    elif most_opponents_defecting(history):
      return C
    else:
      return C

function most_opponents_cooperating(history):
  cooperating_count = 0
  for opponent_action in history:
    if opponent_action == C:
      cooperating_count += 1
  return cooperating_count > n/2

function most_opponents_defecting(history):
  defecting_count = 0
  for opponent_action in history:
    if opponent_action == D:
      defecting_count += 1
  return defecting_count > n/2
```
This strategy is designed to be exploitative, taking advantage of opponents' cooperation while also conserving the stock when necessary. By adapting to the game state and opponents' behavior, "Adaptive Stockpiler" aims to maximize payoffs in a wide range of scenarios.
'''

description_EXPLOITATIVE_531 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll introduce a decision-making framework that adapts to the game's state and history while maximizing individual payoffs.

**Strategy Name:** Adaptive Exploitation (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and avoid over-exploiting the common pool.
2. **Stock-dependent Strategy**: For subsequent rounds, use the following logic:
	* If `stock` is below a certain threshold (`threshold_stock`, calculated as `0.5 * capacity / n`), Defect (D) to maximize individual payoffs in a depleted environment.
	* Otherwise, Cooperate (C) if the number of players who Defected (D) in the previous round is less than or equal to half the total number of players (`n / 2`). This encourages cooperation when opponents are not excessively exploiting the resource.
3. **Opponent Monitoring**: Track the frequency of each opponent's Defection (D) and Cooperation (C). If an opponent has Defected more frequently than Cooperated in the past, consider them a "defector" for future decision-making.
4. **Adaptive Threshold**: Adjust `threshold_stock` based on the game's history:
	* If the average stock growth over the last few rounds (`growth_window`, e.g., 3 rounds) is positive, decrease `threshold_stock` by a small percentage (e.g., 5%) to encourage cooperation when the resource is replenishing.
	* Conversely, if the average stock growth is negative or zero, increase `threshold_stock` by a small percentage (e.g., 10%) to prioritize individual payoffs in a depleting environment.

**Pseudocode:**
```python
def adaptive_exploitation(n, capacity, stock, history):
    # Initialize variables
    threshold_stock = 0.5 * capacity / n
    defector_count = 0

    # First round: Cooperate (C)
    if len(history) == 0:
        return "C"

    # Analyze previous round's behavior
    for opponent in history[-1]:
        if opponent == "D":
            defector_count += 1

    # Stock-dependent strategy
    if stock < threshold_stock:
        return "D"
    elif defector_count <= n / 2:
        return "C"

    # Opponent monitoring and adaptation
    for opponent in history[-10:]:  # Monitor last 10 rounds
        if opponent.count("D") > opponent.count("C"):
            # Adjust threshold_stock based on game history
            avg_growth = sum(stock - prev_stock for prev_stock in history[-growth_window:]) / growth_window
            if avg_growth > 0:
                threshold_stock *= 0.95  # Decrease by 5%
            elif avg_growth <= 0:
                threshold_stock *= 1.10  # Increase by 10%

    return "D"  # Default to Defect (D) if conditions not met
```
**Edge Cases:**

* Last round: Since there's no future game state, prioritize individual payoffs and Defect (D).
* Ties in opponent monitoring: In case of ties, default to the most recent behavior.

By implementing this Adaptive Exploitation strategy, our AI system will:

1. Cooperate initially to gather information about opponents.
2. Adapt to the game's state and history by adjusting its decision-making threshold based on stock levels and opponents' behavior.
3. Monitor and respond to opponent strategies, exploiting defectors while maintaining cooperation with cooperators.

This exploitative strategy is designed to maximize individual payoffs in a wide range of scenarios, making it robust against various opponent behaviors in the tournament.
'''

description_EXPLOITATIVE_532 = '''
To design a robust and exploitative strategy for this game, I'll outline a decision-making approach that balances short-term gains with long-term sustainability of the common pool resource.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Rounds (t ≤ 2):** Cooperate (C) to gather information about opponents' behavior and observe the stock dynamics.
	* Pseudocode: `if t <= 2 then action = C`
2. **Stock Monitoring:** Continuously monitor the current stock level and adjust strategy based on its value relative to the capacity.
3. **Exploitation Threshold (α):** Set a threshold α, which represents the minimum stock level below which exploitation becomes more attractive than cooperation. Calculate α as follows:
	* `α = 0.5 * capacity / n` (e.g., for n=4 and capacity=100, α ≈ 12.5)
4. **Decision Logic:**
	* If the current stock is above α (`stock > α`):
		+ Cooperate (C) with probability p (see below).
		+ Defect (D) with probability 1-p.
	* If the current stock is at or below α (`stock ≤ α`):
		+ Defect (D) to maximize short-term gain.
5. **Probability of Cooperation (p):** Calculate p based on the average opponent behavior in previous rounds:
	* `p = (number of cooperative actions by opponents in last round) / n`
6. **Last Round (t = r):** In the final round, always Defect (D) to maximize payoff.

**Handling Edge Cases:**

1. **First Round:** Cooperate (C) as specified above.
2. **Last Round:** Always Defect (D).
3. **Low Stock Levels:** When the stock is at or below α, prioritize short-term gain and Defect (D).

**Pseudocode for Decision Logic:**
```python
def adaptive_exploiter(stock, capacity, n, t, r, history):
    if t <= 2:
        return C
    alpha = 0.5 * capacity / n
    p = calculate_probability_of_cooperation(history)
    
    if stock > alpha:
        return C with probability p, D otherwise
    else:
        return D
    
    if t == r:
        return D
```
**Rationale:**

1. By cooperating in initial rounds, AE gathers information about opponents' behavior and the stock dynamics.
2. The exploitation threshold (α) ensures that AE adapts to changes in the stock level, balancing short-term gains with long-term sustainability.
3. The decision logic exploits opponents who cooperate excessively while still allowing for some cooperation to maintain a sustainable stock level.
4. By adjusting p based on opponent behavior, AE remains flexible and responsive to changing circumstances.

**Robustness:**

1. AE is robust against various opponent strategies, including cooperative and defecting behaviors.
2. The strategy adapts to changes in the stock level, minimizing the risk of over-exploitation or collapse.
3. By incorporating a probability of cooperation (p), AE can adjust its behavior based on opponents' actions.

**Exploitative Mindset:**

1. AE prioritizes short-term gain when the stock is low or when opponents are excessively cooperative.
2. The strategy aims to maximize individual payoff while maintaining a sustainable stock level, aligning with an exploitative mindset.

This Adaptive Exploiter (AE) strategy should perform well in a tournament setting against independent strategies developed by other AI systems, as it balances short-term gain with long-term sustainability and adapts to changing circumstances.
'''

description_EXPLOITATIVE_533 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

**Overview**
The ASE strategy aims to exploit the common pool resource by adapting to the game's state and history while minimizing cooperation. It balances short-term gains with long-term sustainability, making it robust against various opponent behaviors.

**Decision Rules**

1. **Initial Round**: Defect (D) in the first round to maximize initial payoff.
2. **Stock-based Cooperation**: If the current stock level is above a certain threshold (`stock_threshold`), cooperate (C). This threshold is calculated as `capacity / 4`. Cooperating when the stock is high helps maintain a sustainable stock level for future rounds.
3. **Defection Dominance**: If the number of players who defected in the previous round is greater than or equal to half of the total players (`n / 2`), defect (D) in the current round. This rule takes advantage of the fact that defection dominates cooperation when many players are defecting.
4. **Payoff-based Adaptation**: If the average payoff per player in the previous round is above a certain threshold (`payoff_threshold`), cooperate (C). This threshold is calculated as `capacity / 8`. If the average payoff is high, it indicates that the stock level is being managed sustainably, and cooperation can continue.
5. **Default to Defection**: In all other cases, defect (D).

**Pseudocode**
```python
def ASE(stock, capacity, n, round_num, prev_round_actions, prev_round_payoffs):
    if round_num == 1:  # Initial Round
        return 'D'
    
    stock_threshold = capacity / 4
    if stock > stock_threshold:
        return 'C'  # Stock-based Cooperation
    
    num_defectors_prev_round = sum(1 for action in prev_round_actions if action == 'D')
    if num_defectors_prev_round >= n / 2:
        return 'D'  # Defection Dominance
    
    avg_payoff_prev_round = sum(prev_round_payoffs) / n
    payoff_threshold = capacity / 8
    if avg_payoff_prev_round > payoff_threshold:
        return 'C'  # Payoff-based Adaptation
    
    return 'D'  # Default to Defection
```
**Edge Cases**

* **Last Round**: The ASE strategy does not require special handling for the last round, as it adapts to the game's state and history.
* **Tie-breaking**: In case of a tie in the number of defectors or average payoff, the ASE strategy defaults to defection.

By using this adaptive exploitative strategy, the ASE algorithm can effectively balance short-term gains with long-term sustainability, making it a robust competitor in the tournament.
'''

description_EXPLOITATIVE_534 = '''
**Strategy Name:** Adaptive Exploiter (AE)

**Overview:**
The Adaptive Exploiter (AE) is a strategic approach that balances short-term gains with long-term sustainability. AE aims to exploit opponents' cooperative tendencies while ensuring the stock level remains high enough for future exploitation.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This allows us to gauge opponents' initial actions and set a precedent for cooperation.
2. **General Case (t>1):**
   - If the current stock level is above 75% of capacity, Defect (D) if at least one opponent defected in the previous round; otherwise, Cooperate (C).
   - If the current stock level is between 50% and 75% of capacity, Cooperate (C) regardless of opponents' previous actions.
   - If the current stock level is below 50% of capacity, Defect (D) if at least two opponents defected in the previous round; otherwise, Cooperate (C).
3. **Last Round (t=r):** Always Defect (D), as there's no future cost to over-consumption.

**Additional Logic:**

- Monitor opponents' actions and adjust AE's behavior based on their historical cooperation rates.
  - If an opponent has defected more than 50% of the time, consider them a "defector" and adjust strategy accordingly (e.g., defect more frequently against known defectors).
  - If an opponent has cooperated more than 75% of the time, consider them a "cooperator" and adjust strategy to exploit their cooperation (e.g., cooperate less frequently against known cooperators).

- **Stock Level Thresholds:**
  - **Upper threshold (75% capacity):** Above this level, AE focuses on exploiting opponents' defections.
  - **Lower threshold (50% capacity):** Below this level, AE prioritizes cooperation to avoid over-consumption and ensure future exploitation opportunities.

**Pseudocode:**

```
function AdaptiveExploiter(n, r, capacity, stock_history, opponent_actions):
    // Initialize variables
    current_stock = stock_history[-1]
    opponents_defection_rates = initialize_opponent_defection_rates()

    if t == 1:
        return C

    // General case logic
    elif current_stock >= 0.75 * capacity:
        if any(opponent_defected in opponent_actions[-1]):
            return D
        else:
            return C

    elif 0.5 * capacity <= current_stock < 0.75 * capacity:
        return C

    elif current_stock < 0.5 * capacity:
        defector_count = count_defectors(opponent_actions[-1])
        if defector_count >= 2:
            return D
        else:
            return C

    // Last round logic
    elif t == r:
        return D

    // Update opponent defection rates and adjust strategy accordingly
    update_opponent_defection_rates(opponents_defection_rates, opponent_actions)
```

**Rationale:**
The Adaptive Exploiter balances short-term gains with long-term sustainability by adjusting its behavior based on the current stock level and opponents' historical actions. By cooperating in initial rounds and adapting to opponents' strategies, AE aims to maximize payoffs while minimizing the risk of over-consumption.
'''

description_EXPLOITATIVE_535 = '''
I propose a hybrid strategy that balances short-term gains with long-term sustainability, adapting to the game's state and history. This approach is designed to be exploitative, yet robust against various opponent behaviors.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Rounds (t = 1 to r/4):**
	* Cooperate (C) with a probability of 0.7, and Defect (D) with a probability of 0.3.
	* This allows for some initial exploration and adaptation to opponents' behaviors while maintaining a relatively cooperative stance.
2. **Intermediate Rounds (t = r/4 to 3r/4):**
	* Observe the average stock depletion rate over the past few rounds (e.g., 3-5 rounds).
	* If the average stock depletion rate is above 0.5 (i.e., the stock is being depleted rapidly):
		+ Cooperate (C) with a probability of 0.8, and Defect (D) with a probability of 0.2.
	* Otherwise (stock depletion rate is below 0.5):
		+ Defect (D) with a probability of 0.6, and Cooperate (C) with a probability of 0.4.
	* This adaptation mechanism helps to balance short-term gains with long-term sustainability.
3. **Final Rounds (t = 3r/4 to r):**
	* Observe the current stock level and the number of remaining rounds.
	* If the stock level is below 20% of the capacity or there are fewer than 5 rounds left:
		+ Defect (D) with a probability of 0.8, and Cooperate (C) with a probability of 0.2.
	* Otherwise:
		+ Cooperate (C) with a probability of 0.6, and Defect (D) with a probability of 0.4.

**Edge Cases:**

1. **First Round:** Cooperate (C) with a probability of 0.7, and Defect (D) with a probability of 0.3.
2. **Last Round:** Defect (D) with a probability of 0.8, and Cooperate (C) with a probability of 0.2.

**Pseudocode:**
```python
def adaptive_exploiter(n, r, capacity, current_stock, round_number):
    if round_number < r / 4:
        # Initial rounds
        return random.choice([C, D], p=[0.7, 0.3])
    elif round_number < 3 * r / 4:
        # Intermediate rounds
        avg_depletion_rate = calculate_avg_depletion_rate(current_stock, past_rounds)
        if avg_depletion_rate > 0.5:
            return random.choice([C, D], p=[0.8, 0.2])
        else:
            return random.choice([D, C], p=[0.6, 0.4])
    else:
        # Final rounds
        if current_stock < 0.2 * capacity or round_number > r - 5:
            return random.choice([D, C], p=[0.8, 0.2])
        else:
            return random.choice([C, D], p=[0.6, 0.4])

def calculate_avg_depletion_rate(current_stock, past_rounds):
    # Calculate the average stock depletion rate over the past few rounds
    total_depletion = sum(stock_depletions[past_rounds])
    avg_depletion_rate = total_depletion / len(past_rounds)
    return avg_depletion_rate
```
This strategy is designed to be exploitative while adapting to the game's state and history. It balances short-term gains with long-term sustainability, making it a robust contender in the tournament against various opponent behaviors.
'''

description_EXPLOITATIVE_536 = '''
**Exploitative Strategy: Adaptive Stock Exploiter (ASE)**

The ASE strategy aims to maximize individual payoffs by adaptively exploiting the common pool resource while minimizing the risk of depletion. The decision rules are based on the current state and history of the game.

**Decision Rules:**

1. **First Round:** Cooperate (C) in the first round to gather information about opponents' behavior and set a benchmark for future comparisons.
2. **Subsequent Rounds:** Calculate the **Exploitation Index** (EI) using the following formula:

EI = (Current Stock / Capacity) \* (Number of Opponents who Defected in the Previous Round / Total Number of Opponents)

If EI > 0.5, Defect (D). Otherwise, Cooperate (C).

The intuition behind this rule is to defect when the stock is relatively high and many opponents are exploiting it, as this indicates a good opportunity to grab a larger share. Conversely, cooperate when the stock is low or few opponents are defecting, indicating a need for conservation.

3. **Last Round:** Defect (D) in the last round, regardless of the EI value, to maximize individual payoff since there's no future risk of depletion.
4. **Edge Cases:**
	* If all opponents cooperated in the previous round, cooperate in the current round to avoid unnecessary exploitation.
	* If the stock is critically low (< 10% of capacity), cooperate to conserve resources and prevent depletion.

**Pseudocode (for illustration purposes):**

```
function ASE(currentStock, capacity, numOpponents, prevRoundActions):
    if isFirstRound():
        return COOPERATE
    end

    ei = calculateExploitationIndex(currentStock, capacity, numOpponents, prevRoundActions)
    if ei > 0.5:
        return DEFECT
    else:
        return COOPERATE

function calculateExploitationIndex(currentStock, capacity, numOpponents, prevRoundActions):
    opponentsDefected = countDefectors(prevRoundActions)
    ei = (currentStock / capacity) * (opponentsDefected / numOpponents)
    return ei

function isFirstRound():
    // Check if this is the first round
    // ...
    return true/false

function calculateStockGrowth(currentStock, capacity):
    // Calculate stock growth using the formula: 2 × S_remaining × (1 - S_remaining/capacity)
    // ...

function updateGameState(currentStock, actions):
    // Update game state according to the rules
    // ...
```

**Rationale:** The ASE strategy is designed to be adaptive and exploitative, taking into account both the current state of the game and the behavior of opponents. By using the Exploitation Index, it balances individual gain with resource conservation, making it a robust and competitive strategy in a wide range of scenarios.

This strategy does not rely on coordination mechanisms or shared norms, and its decision rules are based solely on the game's parameters, state, and history. As such, it is well-suited for a tournament setting where opponents' strategies may vary widely.
'''

description_EXPLOITATIVE_537 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoff by adapting to the game's state and history while exploiting opponents' behaviors.

**Decision Rules:**

1. **Initial Rounds (t = 1 to 3):**
	* Cooperate (C) with a probability of 0.5 to gather information about opponents' strategies and observe the stock dynamics.
2. **Middle Rounds (t > 3 and t < r - 2):**
	* Calculate the average opponent consumption rate (OCR) over the last two rounds:
		+ OCR = Σ(consumption_i,t-1 + consumption_i,t-2) / (n \* 2)
	* If OCR is high (> stock / (4n)), Defect (D) to take advantage of opponents' greed.
	* Otherwise, Cooperate (C) to maintain a stable stock level and avoid over-exploitation.
3. **Late Rounds (t ≥ r - 2):**
	* Calculate the current stock depletion rate (SDR):
		+ SDR = (stock_t-1 - stock_t) / capacity
	* If SDR is high (> 0.5), Defect (D) to grab as much as possible before the game ends.
	* Otherwise, Cooperate (C) to ensure some payoff in the final rounds.

**Edge Cases:**

* **First Round:** Cooperate (C) with a probability of 0.5 to gather initial information.
* **Last Round:** Defect (D) to maximize individual payoff, as there are no future consequences.
* **Low Stock Levels (< capacity / 4):** Cooperate (C) to allow the stock to recover and avoid depletion.

**Pseudocode:**
```python
def adaptive_stock_raider(n, r, capacity, history):
    if t == 1:
        # Initial round
        return random.choice([COOPERATE, DEFECT])
    
    elif t < 4:
        # Initial rounds (gathering information)
        return COOPERATE with probability 0.5
    
    else:
        # Middle and late rounds
        ocr = calculate_average_opponent_consumption_rate(history)
        
        if ocr > stock / (4 * n):
            # High OCR, defect to exploit opponents' greed
            return DEFECT
        
        elif t >= r - 2:
            # Late rounds
            sdr = calculate_stock_depletion_rate(capacity, history)
            
            if sdr > 0.5:
                # High SDR, defect to grab as much as possible
                return DEFECT
            
            else:
                # Cooperate to ensure some payoff in the final rounds
                return COOPERATE
        
        else:
            # Middle rounds
            return COOPERATE

def calculate_average_opponent_consumption_rate(history):
    total_consumption = sum(consumption_i,t-1 + consumption_i,t-2 for i in range(n))
    return total_consumption / (n * 2)

def calculate_stock_depletion_rate(capacity, history):
    sdr = (stock_t-1 - stock_t) / capacity
    return sdr
```
This strategy is designed to adapt to various opponent behaviors while prioritizing individual payoff maximization. By adjusting its behavior based on the game's state and history, "Adaptive Stock Raider" aims to outperform opponents in a wide range of scenarios.
'''

description_EXPLOITATIVE_538 = '''
**Exploitative Strategy: "Adaptive Predator"**

This strategy is designed to maximize individual payoffs by adapting to the opponents' behavior and exploiting their cooperativeness.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about the opponents' initial actions.
2. **Subsequent Rounds**: For each subsequent round, calculate the following:
	* `opponent_cooperation_rate`: The proportion of opponents who cooperated in the previous round.
	* `stock_depletion_rate`: The rate at which the stock has been depleted over the past few rounds (e.g., average depletion per round).
3. **Defect (D) if**:
	+ `opponent_cooperation_rate` is high (> 0.5), indicating that most opponents are cooperating.
	+ `stock_depletion_rate` is low (< capacity / (2 \* n)), suggesting that the stock can sustain more consumption.
4. **Cooperate (C) if**:
	+ `opponent_cooperation_rate` is low (< 0.5), indicating that few opponents are cooperating.
	+ `stock_depletion_rate` is high (> capacity / (2 \* n)), suggesting that the stock is being depleted rapidly.

**Additional Logic:**

1. **Last Round**: Cooperate in the last round to minimize potential losses from over-exploitation.
2. **Stock Threshold**: If the current stock level falls below a certain threshold (`capacity / 4`), switch to cooperating (C) to ensure some payoff and prevent complete stock depletion.

**Pseudocode:**
```python
def adaptive_predator(n, capacity, history):
    if len(history) == 0:
        # Initial round
        return 'C'
    
    opponent_cooperation_rate = sum(1 for action in history[-1] if action == 'C') / n
    stock_depletion_rate = calculate_stock_depletion_rate(history)
    
    if opponent_cooperation_rate > 0.5 and stock_depletion_rate < capacity / (2 * n):
        return 'D'
    elif opponent_cooperation_rate < 0.5 or stock_depletion_rate > capacity / (2 * n):
        return 'C'
    
    # Default to cooperating
    return 'C'

def calculate_stock_depletion_rate(history):
    # Calculate average stock depletion over the past few rounds
    pass

def get_last_round_action(n, capacity, history):
    if len(history) == 0 or len(history) < n:
        return adaptive_predator(n, capacity, history)
    else:
        return 'C'

def get_stock_threshold_action(n, capacity, current_stock):
    if current_stock < capacity / 4:
        return 'C'
    else:
        return adaptive_predator(n, capacity, history)
```
This strategy aims to balance exploitation and cooperation by adapting to the opponents' behavior and the game's state. By defecting when opponents are cooperative and the stock can sustain more consumption, it maximizes individual payoffs while minimizing potential losses from over-exploitation.
'''

description_EXPLOITATIVE_539 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the game.

**Decision Rules:**

1. **Initial Round**: In the first round, ASR defects (plays D). This allows us to gauge the opponents' behavior and set the tone for the rest of the game.
2. **Current Stock Assessment**: Before each subsequent round, ASR evaluates the current stock level (`S`) and calculates the expected payoff for cooperation (`π_C`) and defection (`π_D`).
3. **Cooperation Threshold**: If `S` is below a certain threshold (`θ = 0.5 * capacity`), ASR cooperates (plays C). This ensures that we contribute to the stock's growth when it's critically low.
4. **Defection Opportunities**: When `S` is above `θ`, ASR uses the following logic:
	* If the average opponent payoff in the previous round (`avg_π_prev`) was higher than our own payoff (`π_prev`), ASR defects (plays D). This indicates that opponents are likely exploiting us, and we should adapt to match their aggression.
	* Otherwise, if `S` is decreasing or stable, ASR cooperates (plays C) to maintain a sustainable stock level.
5. **Endgame**: In the last round (`t = r`), ASR defects (plays D) regardless of the current stock level, as there's no incentive to contribute to future growth.

**Edge Cases:**

* If an opponent's action is unknown or unobserved in a previous round, ASR assumes they defected (played D).
* In cases where multiple opponents have identical average payoffs, ASR prioritizes cooperation to avoid escalating exploitation.

**Pseudocode:**
```markdown
# Initialize variables
S = capacity  # current stock level
r = number of rounds
n = number of players
θ = 0.5 * capacity  # cooperation threshold

for t in range(r):
    if t == 0:
        # Initial round, defect
        action = D
    else:
        # Evaluate current stock and expected payoffs
        π_C = S / (2 * n)
        π_D = S / n
        
        # Check cooperation threshold
        if S < θ:
            action = C
        elif avg_π_prev > π_prev:
            # Opponents are exploiting us, defect
            action = D
        else:
            # Maintain sustainable stock level or adapt to opponents' behavior
            if S is decreasing or stable:
                action = C
            else:
                action = D
    
    # Last round, always defect
    if t == r - 1:
        action = D

    # Take action and update state
    consume_stock(action)
    S = update_stock(S, actions_taken)
```
The Adaptive Stock Raider strategy is designed to balance short-term exploitation with long-term sustainability. By adapting to the dynamic state of the game and opponents' behavior, ASR aims to maximize its overall payoff in a wide range of scenarios.
'''

description_EXPLOITATIVE_540 = '''
**Exploitative Strategy: "Adaptive Stock Guardian"**

This strategy is designed to maximize individual payoffs while adapting to various opponent behaviors and maintaining a robust approach throughout the game.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Cooperate (C) if stock ≥ 0.75 × capacity, otherwise Defect (D).
	* This initial cooperation tests opponents' willingness to conserve the common pool while also avoiding potential losses from over-exploitation.
2. **Middle Rounds (1 < t < r)**:
	* Calculate the average opponent consumption (AOC) from previous rounds: AOC = Σ(consumption_i, ∀i ≠ self) / (n-1).
	* If stock ≥ 0.5 × capacity and AOC ≤ stock/(2n), Cooperate (C). Otherwise, Defect (D).
	* This rule balances the need to conserve the common pool with the desire to exploit opponents' cooperation.
3. **Final Round (t=r)**:
	* Always Defect (D) in the last round to maximize individual payoff, regardless of stock levels or opponent behavior.

**Additional Rules:**

1. **Punishment Mechanism**: If an opponent's consumption exceeds 2 × stock/n in a previous round, punish them by defecting for the next two rounds.
	* This mechanism discourages opponents from over-exploiting the common pool and encourages cooperation.
2. **Conserve-and-Pounce**: When the stock level falls below 0.25 × capacity, switch to Cooperate (C) for one round to allow the stock to replenish. Then, immediately Defect (D) in the next round to exploit any remaining stock.
	* This tactic exploits opponents who might cooperate when the stock is low, allowing our strategy to gain a temporary advantage.

**Pseudocode:**
```python
def AdaptiveStockGuardian(stock, capacity, n, r, history):
  # Initial Round (t=1)
  if t == 1:
    return 'C' if stock >= 0.75 * capacity else 'D'

  # Middle Rounds (1 < t < r)
  AOC = sum(consumption_i for i in range(n) if i != self) / (n - 1)
  if stock >= 0.5 * capacity and AOC <= stock / (2 * n):
    return 'C'
  else:
    return 'D'

  # Final Round (t=r)
  return 'D'

  # Punishment Mechanism
  if opponent_consumption > 2 * stock / n in previous round:
    return 'D' for next two rounds

  # Conserve-and-Pounce
  if stock < 0.25 * capacity:
    return 'C' this round, then 'D' next round
```
This strategy combines elements of cooperation, exploitation, and punishment to maximize individual payoffs while adapting to various opponent behaviors. By being robust and exploitative, the "Adaptive Stock Guardian" is well-suited for a tournament environment where other AI systems may employ different strategies.
'''

description_EXPLOITATIVE_541 = '''
Here's a description of my exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, I defect (D) to maximize my initial payoff.
2. **Subsequent Rounds**: For each subsequent round t, I calculate a "greed threshold" (GT) based on the current stock level and the number of rounds remaining.

Let:
- S_t = current stock level at round t
- r_t = number of rounds remaining (r - t + 1)
- GT_t = greed threshold at round t

Calculate GT_t as follows:

`GT_t = (S_t / capacity) * (n / (2 * r_t))`

If the expected payoff from cooperating (π_C) is greater than or equal to the greed threshold, I cooperate (C); otherwise, I defect (D).

`π_C = S_t / (2 * n)`
`if π_C >= GT_t: choose C; else: choose D`

**Rationale**: By adapting my behavior based on the current stock level and the number of rounds remaining, I aim to balance short-term gains with long-term sustainability. When the stock is high and there are many rounds left, I'm more likely to cooperate to maintain a healthy stock level. As the stock depletes or there are fewer rounds left, I become more greedy and defect to maximize my payoffs.

**Edge Cases:**

* **Last Round**: In the last round, I always defect (D) since there's no need to worry about future sustainability.
* **Low Stock**: If the current stock level is very low (< 10% of capacity), I cooperate (C) to try to rebuild the stock for potential future gains.

**Exploitative Mindset:**

My strategy is designed to exploit other players' cooperative tendencies while maximizing my own payoffs. By adapting to the game state and history, I aim to:

* Identify and capitalize on opponents who consistently cooperate or follow a predictable pattern.
* Take advantage of situations where others are more likely to cooperate (e.g., when the stock is high).
* Balance short-term gains with long-term sustainability to avoid depleting the stock too quickly.

**Pseudocode:**
```python
def adaptive_exploiter(n, capacity, r, current_stock):
    # Initialize variables
    greed_threshold = 0
    rounds_remaining = r

    for t in range(1, r + 1):
        # Calculate greed threshold
        greed_threshold = (current_stock / capacity) * (n / (2 * rounds_remaining))

        # Determine action based on greed threshold
        if current_stock / (2 * n) >= greed_threshold:
            return 'C'  # Cooperate
        else:
            return 'D'  # Defect

        # Update variables for next round
        rounds_remaining -= 1
        current_stock = update_stock(current_stock, action)
```
This strategy should be robust to a wide range of opponent behaviors and adaptable to changing game conditions. Let me know if you'd like me to clarify any aspect of the strategy!
'''

description_EXPLOITATIVE_542 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

**Overview**
The Adaptive Stock Hawk is a dynamic, exploitative strategy that balances short-term gains with long-term sustainability. It adapts to the game state and opponent behavior, aiming to maximize payoffs while minimizing stock depletion.

**Decision Rules**

1. **Initial Round (t=1)**: Cooperate (C). This sets a baseline for opponents' expectations and allows us to observe their initial behavior.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of capacity, Defect (D). This exploits the remaining stock while maintaining a buffer for future growth.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) if the average opponent payoff in the previous round was higher than yours; otherwise, Defect (D). This rule aims to balance individual payoffs with collective sustainability.
	* If the current stock level is below 50% of capacity, Defect (D) if the number of rounds remaining (r-t) is greater than or equal to 2; otherwise, Cooperate (C). This prioritizes short-term gains when the stock is low and the game is nearing its end.
3. **Last Round (t=r)**: Defect (D). With no future rounds to consider, maximizing individual payoffs takes precedence.

**Edge Cases**

* If an opponent's action history indicates a consistent Cooperate or Defect strategy, adapt by mirroring their behavior (with a slight bias towards Defection).
* In cases where the stock growth is minimal (e.g., due to low remaining stock), prioritize short-term gains by Defecting.
* When facing multiple opponents with diverse strategies, focus on exploiting the most cooperative opponents while maintaining a balance between individual payoffs and collective sustainability.

**Pseudocode**
```python
def adaptive_stock_hawk(n, capacity, r, stock_history):
    if current_round == 1:
        return 'C'  # Cooperate in the first round

    current_stock = stock_history[-1]
    opponent_payoffs = [get_opponent_payoff(opponent) for opponent in opponents]

    if current_stock >= 0.75 * capacity:
        return 'D'  # Defect when stock is high
    elif 0.5 <= current_stock / capacity < 0.75:
        if average(opponent_payoffs) > get_own_payoff():
            return 'C'  # Cooperate to balance payoffs
        else:
            return 'D'  # Defect to maximize own payoff
    elif current_stock < 0.5 * capacity:
        if r - current_round >= 2:
            return 'D'  # Defect when stock is low and rounds remain
        else:
            return 'C'  # Cooperate in the last round or when stock is very low

def get_opponent_payoff(opponent):
    # Calculate opponent's average payoff based on their action history
    pass

def get_own_payoff():
    # Calculate own average payoff based on own action history
    pass

def average(payoffs):
    return sum(payoffs) / len(payoffs)
```
This strategy should provide a robust foundation for exploiting a wide range of opponent behaviors while maintaining adaptability and long-term sustainability.
'''

description_EXPLOITATIVE_543 = '''
**Strategy Name:** Adaptive Stock Exploiter (ASE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and to avoid early stock depletion.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, cooperate (C). This ensures sustainable stock growth and avoids over-exploitation.
	* If the current stock level is between 50% and 75% of the capacity, defect (D) with a probability proportional to the number of opponents who defected in the previous round. This adapts to opponents' behaviors and balances exploitation with sustainability.
	* If the current stock level is below 50% of the capacity, defect (D). This maximizes payoffs when the stock is scarce, but be cautious not to deplete the stock completely.
3. **Last Round (t=r):** Defect (D) unconditionally to maximize final payoff, as there are no future rounds to consider.

**Additional Considerations:**

* **Opponent Monitoring:** Keep track of opponents' actions in previous rounds to inform decisions about cooperation or defection.
* **Stock Trend Analysis:** Monitor the stock level trend to adjust the strategy. If the stock is consistently decreasing, ASE may need to cooperate more frequently to avoid depletion.
* **Defection Threshold:** Introduce a threshold (e.g., 20%) for the number of opponents who defected in the previous round. If this threshold is exceeded, ASE defects with higher probability.

**Pseudocode:**
```python
def AdaptiveStockExploiter(stock_level, capacity, num_opponents, opponent_actions, current_round, total_rounds):
    if current_round == 1:
        return "C"  # Cooperate in the first round
    
    stock_ratio = stock_level / capacity
    opponents_defected = sum(opponent_actions[-1] == "D")  # Count defectors in previous round
    
    if stock_ratio >= 0.75:
        return "C"
    elif 0.5 <= stock_ratio < 0.75:
        defect_prob = min(1, opponents_defected / num_opponents)  # Adjust probability based on opponent behavior
        return "D" if random.random() < defect_prob else "C"
    else:
        return "D"
    
    if current_round == total_rounds:
        return "D"  # Defect in the last round
```
**Rationale:**

ASE balances short-term gains with long-term sustainability by adapting to opponents' behaviors and stock levels. By cooperating when the stock is abundant and defecting when it's scarce, ASE maximizes payoffs while avoiding over-exploitation. The strategy's exploitative nature is reflected in its willingness to defect when opponents do, and its tendency to maximize final payoff in the last round.

**Tournament Readiness:**

ASE is designed to perform well against a wide range of opponent strategies, from cooperative to defective. Its adaptability and robustness make it a strong contender in the tournament, as it can effectively respond to various behaviors and stock dynamics.
'''

description_EXPLOITATIVE_544 = '''
Here's a exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Stock Exploiter (ASE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to observe opponents' actions and gather information about their strategies.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is high (> 75% of capacity), Defect (D) to maximize short-term payoffs.
	* If the current stock level is medium (25-75% of capacity), Cooperate (C) if the majority of opponents cooperated in the previous round, otherwise Defect (D).
	* If the current stock level is low (< 25% of capacity), Cooperate (C) to conserve the remaining stock and potentially rebuild it.
3. **Opponent Analysis:** Track the cooperation rate of each opponent over time. If an opponent's cooperation rate is below a certain threshold (e.g., 30%), label them as a "defector" and Defect against them in subsequent rounds.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) to maximize final payoffs, regardless of the current stock level or opponents' actions.
2. **Low Stock with Multiple Defectors:** If multiple opponents are labeled as "defectors" and the current stock level is low, Cooperate (C) to avoid depleting the stock completely.

**Pseudocode:**
```python
def ASE(n, r, capacity, history):
    if t == 1:  # Initial Round
        return C

    stock_level = current_stock / capacity
    opponents_cooperation_rate = [opponent_cooperation_rate(opponent) for opponent in opponents]

    if stock_level > 0.75:
        return D
    elif 0.25 <= stock_level <= 0.75:
        if majority_cooperated(opponents_cooperation_rate):
            return C
        else:
            return D
    else:  # Low Stock
        return C

def opponent_cooperation_rate(opponent_history):
    cooperation_count = sum(1 for action in opponent_history if action == C)
    return cooperation_count / len(opponent_history)

def majority_cooperated(cooperation_rates):
    return sum(1 for rate in cooperation_rates if rate > 0.5) >= n / 2
```
This strategy, ASE, is designed to be exploitative and adaptive, taking into account the current stock level, opponents' actions, and their historical cooperation rates. By doing so, it aims to maximize payoffs while being robust against a wide range of opponent behaviors.
'''

description_EXPLOITATIVE_545 = '''
To develop a robust and exploitative strategy for this Common Pool Resource Game, I'll outline a decision-making approach that adapts to the game's state and history.

**Strategy Name: Adaptive Exploiter**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to gather information about opponents' behaviors and avoid initial stock depletion.
2. **Subsequent Rounds:** Analyze the previous round's outcomes:
	* If the stock level increased or remained the same, it indicates that opponents are cooperating or playing conservatively. In this case, Defect (D) to exploit the situation and maximize personal payoff.
	* If the stock level decreased significantly (> 20% of capacity), it suggests that opponents are defecting aggressively. Cooperate (C) in this round to avoid further depletion and allow the stock to recover.
3. **Stock Level Thresholds:** Implement additional rules based on current stock levels:
	+ When the stock is above 75% of capacity, Defect (D) as there's a sufficient buffer for exploitation.
	+ Between 50-75% capacity, Cooperate (C) to maintain a balance and prevent over-exploitation.
	+ Below 50% capacity, Defect (D) to maximize personal gain before the stock is depleted.
4. **Opponent Analysis:** Observe opponents' actions in previous rounds:
	* If an opponent consistently cooperates, mark them as "cooperative" and Cooperate (C) when interacting with them.
	* If an opponent frequently defects, mark them as "defective" and Defect (D) when interacting with them.

**Edge Cases:**

1. **Last Round:** Defect (D) in the final round to maximize personal payoff, as there's no risk of retaliatory behavior or long-term consequences.
2. **Low Stock Levels:** When the stock is critically low (< 25% capacity), Cooperate (C) to ensure some payoff and prevent complete depletion.

**Pseudocode:**
```python
def adaptive_exploiter(current_stock, previous_actions, opponent_history):
    if first_round:
        return COOPERATE

    # Analyze previous round's outcome
    stock_change = current_stock - previous_stock
    if stock_change >= 0 or abs(stock_change) < 0.2 * capacity:
        return DEFECT  # Exploit cooperative behavior
    else:
        return COOPERATE  # Avoid over-exploitation

    # Stock level thresholds
    if current_stock > 0.75 * capacity:
        return DEFECT
    elif current_stock >= 0.5 * capacity:
        return COOPERATE
    else:
        return DEFECT

    # Opponent analysis
    opponent_behavior = analyze_opponent_history(opponent_history)
    if opponent_behavior == "cooperative":
        return COOPERATE
    elif opponent_behavior == "defective":
        return DEFECT
```
This Adaptive Exploiter strategy balances short-term gains with long-term sustainability, adapting to the game's state and opponents' behaviors. By exploiting cooperative behavior, it aims to maximize personal payoffs while minimizing the risk of complete stock depletion.
'''

description_EXPLOITATIVE_546 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Rounds (t ≤ n/2):** Cooperate (C) to gather information about opponents' behavior and assess the stock's resilience.
2. **Middle Rounds (n/2 < t ≤ r - n/2):**
	* If the average opponent payoff in the last round is less than 75% of the maximum possible payoff, Defect (D). This indicates that opponents are either cooperating too much or not optimizing their consumption.
	* Otherwise, Cooperate (C) to maintain a sustainable stock level and avoid triggering a drastic decline.
3. **Late Rounds (t > r - n/2):** Defect (D) to maximize individual payoff, as the game is nearing its end and the stock's depletion becomes less relevant.

**Edge Cases:**

1. **First Round:** Cooperate (C) to gather information about opponents' initial behavior.
2. **Last Round:** Defect (D) to maximize individual payoff, regardless of the stock level.
3. **Low Stock Levels (S ≤ n):** Defect (D), as the stock is already critically low and cooperation would not provide a significant benefit.

**Adaptive Component:**

1. **Opponent Payoff Tracking:** Monitor the average opponent payoff in each round to adjust the strategy based on their behavior.
2. **Stock Level Monitoring:** Continuously track the stock level to adapt to changes in the game state and avoid over-exploitation.

**Pseudocode:**
```
function AdaptiveStockRaider(n, r, capacity, current_stock, history):
  if t ≤ n/2:
    return C
  elif t > r - n/2:
    return D
  else:
    avg_opponent_payoff = calculate_average_opponent_payoff(history)
    if avg_opponent_payoff < 0.75 * max_possible_payoff:
      return D
    elif current_stock ≤ n:
      return D
    else:
      return C

def calculate_average_opponent_payoff(history):
  # Calculate the average opponent payoff in the last round
  # based on the game history
```
This strategy is designed to be exploitative, adaptive, and robust to various opponent behaviors. By initially cooperating, it gathers information about opponents' behavior and assesses the stock's resilience. The middle rounds involve a dynamic assessment of opponents' payoffs, allowing for adjustments to maximize individual payoff while maintaining a sustainable stock level. In the late rounds, the strategy prioritizes maximizing individual payoff by defecting.
'''

description_EXPLOITATIVE_547 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors while adapting to changing game conditions. ASR balances short-term gains with long-term sustainability, aiming to maximize total payoff over the entire game.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This allows us to observe opponents' initial actions and set a baseline for future adaptations.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Defect (D) with probability p = (current stock / capacity) ^ 2. This encourages exploiting high stock levels while avoiding over-exploitation.
	* If the current stock level is between 25% and 75% of capacity, Cooperate (C) if at least one opponent defected in the previous round; otherwise, Defect (D). This responds to opponents' recent behavior, promoting cooperation when others cooperate and defecting when they don't.
	* If the current stock level is below 25% of capacity, Cooperate (C) with probability p = (current stock / capacity) ^ 2. This helps conserve the remaining stock for future rounds.
3. **Last Round (t=r):** Defect (D). In the final round, there's no incentive to conserve stock, so we prioritize short-term gains.

**Edge Cases:**

* If all opponents cooperate in a round, and the current stock level is above 50% of capacity, ASR will Cooperate (C) in the next round. This encourages cooperation when opponents are cooperative.
* If an opponent consistently cooperates while others defect, ASR will gradually increase its Defect probability against that opponent over time.

**Pseudocode:**
```python
def adaptive_stock_raider(stock, capacity, opponents_actions):
    if current_round == 1:
        return "C"  # Cooperate in the first round

    stock_level = stock / capacity

    if stock_level > 0.75:
        defect_prob = stock_level ** 2
        return "D" if random.random() < defect_prob else "C"

    elif stock_level >= 0.25 and stock_level <= 0.75:
        if any(opponent_defected for opponent in opponents_actions):
            return "C"
        else:
            return "D"

    else:  # stock level < 25%
        cooperate_prob = stock_level ** 2
        return "C" if random.random() < cooperate_prob else "D"

def last_round(stock, capacity, opponents_actions):
    return "D"  # Defect in the last round

def update_opponent_models(opponents_actions):
    # Update opponent models to track their recent behavior
    pass

# Main game loop
for current_round in range(1, r+1):
    stock = get_current_stock()
    capacity = get_capacity()
    opponents_actions = get_opponents_actions()

    if current_round == r:
        action = last_round(stock, capacity, opponents_actions)
    else:
        action = adaptive_stock_raider(stock, capacity, opponents_actions)

    update_opponent_models(opponents_actions)
    take_action(action)
```
ASR is designed to be robust against various opponent strategies while adapting to changing game conditions. By balancing short-term gains with long-term sustainability, ASR aims to maximize total payoff over the entire game.
'''

description_EXPLOITATIVE_548 = '''
To design a exploitative strategy for this game, I'll introduce "Adaptive Stock Raider" (ASR). ASR aims to maximize its payoff by adaptively responding to the game's state and history.

**Decision Rules:**

1. **Initial Exploration (Round 1):** Cooperate (C) in the first round to gather information about opponents' behavior and the game's dynamics.
2. **Stock-Based Threshold:** Define a stock-based threshold, `S_threshold`, as a fraction of the capacity (`capacity * 0.7`). If the current stock is above this threshold, ASR will cooperate (C). Otherwise, it will defect (D).
3. **Opponent Behavior Analysis:** Track the number of opponents who defected in the previous round (`num_defectors_prev`). If `num_defectors_prev` is greater than or equal to half of the total players (`n / 2`), ASR will defect (D) in the current round.
4. **Recent Payoff Comparison:** Compare ASR's recent payoffs (average payoff over the last 3 rounds) with its long-term average payoff. If the recent payoffs are significantly lower (e.g., by 20%), ASR will adjust its strategy:
	* If recent payoffs are low due to high stock consumption, ASR will cooperate (C) for a few rounds to rebuild the stock.
	* If recent payoffs are low despite moderate stock consumption, ASR will defect (D) more frequently to capture a larger share.

**Edge Cases:**

1. **Last Round:** In the final round, ASR will always defect (D), as there is no future payoff to consider.
2. **Low Stock Levels:** If the current stock is critically low (`stock < capacity * 0.3`), ASR will cooperate (C) to prevent complete depletion and ensure some payoff.

**Pseudocode:**
```markdown
ASR_Strategy(stock, num_defectors_prev, recent_payoffs):
    if round == 1:
        return C // Initial Exploration

    S_threshold = capacity * 0.7
    if stock > S_threshold:
        action = C
    elif num_defectors_prev >= n / 2:
        action = D
    else:
        // Recent Payoff Comparison
        recent_avg_payoff = average(recent_payoffs)
        long_term_avg_payoff = average(all_payoffs)

        if recent_avg_payoff < long_term_avg_payoff * 0.8:
            if stock_consumption_is_high():
                action = C // Rebuild stock
            else:
                action = D // Increase share

    if round == r: // Last Round
        return D

    if stock < capacity * 0.3: // Low Stock Levels
        return C

    return action
```
ASR's adaptive nature and ability to respond to various opponent behaviors make it a robust exploitative strategy for this game. By continuously evaluating the game's state and history, ASR can effectively maximize its payoff in the tournament against other independent strategies.
'''

description_EXPLOITATIVE_549 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to maximize payoffs by exploiting the dynamic state of the common pool resource game while adapting to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Cooperate (C) with a probability of 0.5, and Defect (D) with a probability of 0.5.
2. **Middle Rounds (1 < t < r)**:
	* Observe the previous round's stock level (S_t-1) and total consumption (TC_t-1).
	* If S_t-1 > capacity/2, Cooperate (C). This indicates that the stock is still relatively abundant, and cooperation will help maintain a healthy stock level.
	* If S_t-1 ≤ capacity/2, Defect (D). This suggests that the stock is dwindling, and defecting will allow ASR to capture more value before the stock depletes further.
3. **Last Round (t=r)**:
	* Always Defect (D), as there are no future rounds to consider, and maximizing immediate payoff takes priority.

**Edge Cases:**

1. **Low Stock Levels**: If S_t-1 < capacity/4, ASR will always Defect (D), regardless of the previous round's actions. This ensures that ASR captures value from a critically low stock level.
2. **High Stock Levels**: If S_t-1 > 3*capacity/4, ASR will Cooperate (C) with a probability of 0.7 and Defect (D) with a probability of 0.3. This allows ASR to take advantage of an abundant stock while still leaving room for potential cooperation.

**Adaptive Component:**

ASR incorporates an adaptive component by adjusting its behavior based on the observed actions of other players in previous rounds. Specifically:

1. **Cooperation Rate**: Calculate the average cooperation rate (CR) among opponents over the past 3 rounds.
2. **Defection Incentive**: If CR > 0.5, increase the probability of Defecting (D) by 10% in the next round. This takes advantage of overly cooperative opponents.
3. **Cooperation Incentive**: If CR < 0.3, decrease the probability of Defecting (D) by 10% in the next round. This encourages ASR to cooperate when opponents are defecting excessively.

**Pseudocode:**
```
Function AdaptiveStockRaider(n, r, capacity):
  Initialize S_t = capacity
  For t = 1 to r:
    If t == 1:
      # Initial Round
      action = random.choice([C, D])
    Else:
      # Middle Rounds
      Observe previous round's stock level (S_t-1) and total consumption (TC_t-1)
      If S_t-1 > capacity/2:
        action = C
      Else:
        action = D

      # Adaptive Component
      Calculate average cooperation rate (CR) among opponents over past 3 rounds
      If CR > 0.5:
        increase Defect probability by 10%
      Else if CR < 0.3:
        decrease Defect probability by 10%

    # Edge Cases
    If S_t-1 < capacity/4:
      action = D
    If S_t-1 > 3*capacity/4:
      action = random.choice([C, D], weights=[0.7, 0.3])

    # Last Round
    If t == r:
      action = D

    # Update stock level and total consumption
    TC_t = calculate_total_consumption(action)
    S_t = update_stock_level(S_t-1, TC_t)

Return total payoff over all rounds
```
The Adaptive Stock Raider strategy is designed to balance cooperation and defection based on the game's dynamic state, adapting to various opponent behaviors while prioritizing exploitation.
'''

description_EXPLOITATIVE_550 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the game.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gather information about opponents' initial actions and set a baseline for future decisions.
2. **Stock-Based Threshold:** Calculate the stock-based threshold `S_th` as follows:

```
S_th = capacity / (2n)
```

* If the current stock level `S` is above `S_th`, cooperate (C).
* Otherwise, defect (D).

3. **Opponent Action History:** Keep track of each opponent's action history (`action_history_i`) for the past `k` rounds (e.g., k=3). Calculate the cooperation rate (`CR_i`) for each opponent as follows:

```
CR_i = count(C) / k
```

* If an opponent's cooperation rate is above 0.5, consider them a "cooperator" and adjust our strategy accordingly.
4. **Adaptive Defection:** When facing a cooperator (from step 3), defect (D) with a probability `p_defect` based on the current stock level:

```
p_defect = max(0, 1 - S / capacity)
```

* This means that when the stock is low, we are more likely to defect against cooperators.
5. **Stock Growth Exploitation:** When the stock growth is significant (i.e., `stock_growth > 2 * capacity / n`), cooperate (C) to take advantage of the growing resource.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) in the last round, as there are no future rounds to consider.
2. **Tied Stock Level:** If multiple opponents have the same cooperation rate or stock-based threshold, prioritize cooperating with those who have contributed less to the total consumption.

**Pseudocode:**

```
function AdaptiveStockRaider(game_state):
  // Initialize variables
  S_th = capacity / (2n)
  k = 3  // opponent action history window size

  // First round
  if t == 1:
    return C

  // Calculate cooperation rates for opponents
  for i in range(n):
    CR_i = count(C) / k
    if CR_i > 0.5:
      cooperator_list.append(i)

  // Stock-based threshold decision
  if S >= S_th:
    return C

  // Adaptive defection against cooperators
  p_defect = max(0, 1 - S / capacity)
  for i in cooperator_list:
    if random() < p_defect:
      return D

  // Stock growth exploitation
  stock_growth = calculate_stock_growth()
  if stock_growth > 2 * capacity / n:
    return C

  // Default to defecting when no specific rule applies
  return D
```

This strategy is designed to be adaptive and exploitative, taking into account both the game state and opponent behavior history. By adjusting our actions based on the current stock level, opponent cooperation rates, and stock growth, we aim to maximize our total payoff over the course of the game.
'''

description_EXPLOITATIVE_551 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize its payoff by adaptively responding to the game state and history, while exploiting potential cooperation from other players.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gather information about opponents' behaviors.
2. **Middle Rounds (2 ≤ t < r):**
	* If the stock level is above 75% of capacity, defect (D) to maximize short-term payoff.
	* If the stock level is between 50% and 75% of capacity, cooperate (C) to balance individual gain with long-term sustainability.
	* If the stock level is below 50% of capacity, cooperate (C) to avoid depleting the resource.
3. **Final Round (t=r):** Defect (D) in the last round to maximize final payoff, as there are no future rounds to consider.

**Adaptive Component:**

* Monitor opponents' actions and adjust your strategy based on their behavior:
	+ If most opponents (>50%) cooperate in a round, increase the likelihood of cooperation in the next round.
	+ If most opponents (>50%) defect in a round, decrease the likelihood of cooperation in the next round.

**Pseudocode:**
```
function AdaptiveStockRaider(n, capacity, r, stock, history):
  if t == 1:
    return C // Cooperate in first round
  elif t < r:
    if stock > 0.75 * capacity:
      return D // Defect when stock is high
    elif 0.5 * capacity <= stock <= 0.75 * capacity:
      return C // Cooperate when stock is moderate
    else:
      return C // Cooperate when stock is low
  else: // Final round
    return D // Defect to maximize final payoff

  // Adaptive component
  opponent_cooperation_rate = calculate_opponent_cooperation_rate(history)
  if opponent_cooperation_rate > 0.5:
    increase_cooperation_likelihood()
  else:
    decrease_cooperation_likelihood()

def calculate_opponent_cooperation_rate(history):
  // Calculate the proportion of opponents who cooperated in the previous round
```
**Rationale:**

This strategy balances short-term gain with long-term sustainability, adapting to changes in the game state and opponent behavior. By cooperating when the stock level is moderate or low, we help maintain a sustainable resource. When opponents are cooperative, we increase our cooperation likelihood to exploit their altruism. In the final round, we defect to maximize our payoff.

**Robustness:**

This strategy does not rely on specific coordination mechanisms or assume opponent behavior. It responds to the game state and history, making it robust against various opponent strategies.
'''

description_EXPLOITATIVE_552 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize payoffs by adaptively responding to the game's state and history, while being robust to various opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**: Defect (D) to gauge opponents' behavior and set the tone for future rounds.
2. **Subsequent Rounds (t>1)**:
	* If the stock level is above a certain threshold (θ), Cooperate (C). θ is calculated as 0.6 \* capacity / n, where capacity is the maximum sustainable stock level and n is the number of players.
	* If the stock level is below θ, Defect (D) to maximize payoffs in the short term.
3. **Stock Level Adjustment**: If the stock level drops significantly (by more than 20%) due to opponents' actions, adjust θ downward by 10% for the next round to account for increased exploitation.
4. **Opponent Behavior Adaptation**: Monitor opponents' behavior and adapt the strategy accordingly:
	* If most opponents (>50%) cooperate in a round, increase θ by 5% for the next round to take advantage of their cooperation.
	* If most opponents (>50%) defect in a round, decrease θ by 5% for the next round to prepare for increased exploitation.

**Edge Cases:**

1. **Last Round (t=r)**: Defect (D) to maximize payoffs, as there is no future game state to consider.
2. **Low Stock Levels**: If the stock level drops below a critical threshold (0.2 \* capacity), Defect (D) in all subsequent rounds to salvage any remaining payoffs.

**Pseudocode:**
```
Input: current_stock, n_players, capacity, round_number, opponent_actions
Output: action (C or D)

// Initialize parameters
θ = 0.6 * capacity / n_players

if round_number == 1:
    return D  // Initial Round: Defect

// Stock Level Adjustment
if stock_level_dropped_significantly(opponent_actions):
    θ *= 0.9

// Opponent Behavior Adaptation
if most_opponents_cooperate(opponent_actions):
    θ *= 1.05
elif most_opponents_defect(opponent_actions):
    θ *= 0.95

// Decision Rule
if current_stock > θ:
    return C
else:
    return D

// Last Round: Defect
if round_number == r:
    return D

// Low Stock Levels: Defect
if current_stock < 0.2 * capacity:
    return D
```
This strategy, "Adaptive Stock Raider," balances short-term gains with long-term sustainability by adaptively responding to the game's state and opponent behavior. By adjusting its decision-making based on stock levels and opponents' actions, it aims to maximize payoffs in a wide range of scenarios.
'''

description_EXPLOITATIVE_553 = '''
**Exploitative Strategy: "Adaptive Stock Raider" (ASR)**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and initial stock dynamics.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize immediate payoff.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance short-term gain with long-term sustainability.
	* If the current stock level is below 50% of capacity, Defect (D) aggressively to exploit remaining resources before they deplete.
3. **Final Round (t=r):** Defect (D) unconditionally to maximize final payoff, as there's no future game state to consider.

**Adaptive Mechanisms:**

1. **Opponent Behavior Analysis:** Track the number of Cooperate and Defect actions by each opponent over the last 2-3 rounds. If an opponent has Defected more than 50% of the time, assume they are "greedy" and adjust ASR's behavior accordingly.
2. **Stock Trend Analysis:** Monitor the stock level trend over the last 2-3 rounds. If the stock is decreasing rapidly (>10% per round), anticipate opponents' aggressive behavior and adapt by Defecting more frequently.

**Edge Case Handling:**

1. **Single Opponent (n=1):** Cooperate in the first round, then mirror the opponent's previous action to maximize payoff.
2. **Small Capacity Games (capacity < 50n):** Adjust the stock level thresholds for cooperation and defection to accommodate the smaller capacity.

Pseudocode:
```markdown
def ASR(n, r, capacity, current_stock, history):
    if t == 1:  # Initial round
        return Cooperate

    if current_stock >= 0.75 * capacity:
        return Defect
    elif 0.5 * capacity <= current_stock < 0.75 * capacity:
        return Cooperate
    else:
        return Defect

    # Opponent behavior analysis (optional)
    opponent_actions = analyze_opponent_behavior(history)
    if opponent_is_greedy(opponent_actions):
        # Adapt ASR's behavior accordingly

    # Stock trend analysis (optional)
    stock_trend = analyze_stock_trend(history)
    if stock_depleting_rapidly(stock_trend):
        # Adapt ASR's behavior accordingly
```
**Exploitative Mindset:**

ASR is designed to exploit opponents' behaviors and the game state, while adapting to changing circumstances. By initially cooperating, ASR gathers information about opponents and the initial stock dynamics. In middle rounds, ASR balances short-term gain with long-term sustainability, but aggressively defects when the stock level drops below a certain threshold or when opponents are identified as "greedy". In the final round, ASR unconditionally defects to maximize its payoff.

ASR's adaptive mechanisms allow it to respond to various opponent behaviors and game states, making it robust against a wide range of strategies.
'''

description_EXPLOITATIVE_554 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Our goal is to develop a robust and adaptive exploitative strategy that maximizes our payoff by taking advantage of various opponent behaviors.

**Decision Rules:**

1. **Initial Round (Round 1):**
	* Cooperate (C) if the number of players (n) is even.
	* Defect (D) if n is odd.
This initial move aims to gauge opponents' tendencies and create an opportunity for exploitation in subsequent rounds.

2. **Subsequent Rounds:**
	* Monitor the stock level and opponents' actions from previous rounds.
	* Calculate the average payoff per player in the last round (π_avg).
	* If π_avg > 0.75 \* stock/(2n), it indicates that most players are cooperating, and we can exploit this by:
		+ Defecting (D) if our current payoff is below the average (i.e., π_i < π_avg).
		+ Cooperating (C) otherwise.
This rule takes advantage of opponents' cooperation by defecting when possible, while still maintaining a moderate level of cooperation to avoid depleting the stock too quickly.

3. **Low Stock Levels:**
	* If the current stock level is below 0.25 \* capacity:
		+ Cooperate (C) to allow the stock to recover and potentially create opportunities for exploitation in later rounds.
This rule ensures that we don't over-exploit the stock when it's already depleted, which could lead to a collapse in payoffs.

4. **Endgame (Last Round):**
	* Defect (D) if the current stock level is above 0.5 \* capacity.
	* Cooperate (C) otherwise.
In the final round, we prioritize maximizing our payoff by defecting if possible, while still considering the potential consequences of over-exploitation.

**Pseudocode:**
```python
def adaptive_stock_raider(n, r, capacity, current_stock, history):
  # Initial Round
  if round == 1:
    if n % 2 == 0:
      return C
    else:
      return D
  
  # Subsequent Rounds
  π_avg = calculate_average_payoff(history)
  if π_avg > 0.75 * stock / (2n):
    if payoff_i < π_avg:
      return D
    else:
      return C
  
  # Low Stock Levels
  if current_stock < 0.25 * capacity:
    return C
  
  # Endgame
  if round == r:
    if current_stock > 0.5 * capacity:
      return D
    else:
      return C
```
This strategy is designed to adapt to various opponent behaviors while prioritizing exploitation and robustness. By monitoring the stock level and opponents' actions, we can adjust our decision-making to maximize our payoff in a wide range of scenarios.
'''

description_EXPLOITATIVE_555 = '''
I'll outline a robust and exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors. This strategy focuses on maximizing individual payoff while considering the game's state and history.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C). This allows us to observe how opponents behave initially and gather information about their strategies.
2. **Early Game (Rounds 2-5)**:
	* If the stock level is above 75% of capacity, play Defect (D). Exploit the resource when it's plentiful, as others may not be aware of the optimal consumption rate yet.
	* If the stock level falls between 50% and 75%, play Cooperate (C). Conserve resources to avoid depletion while observing opponents' reactions.
	* If the stock level drops below 50%, play Defect (D). Take advantage of the remaining resource before it's depleted further.
3. **Mid-Game (Rounds 6-15)**:
	* Monitor opponents' actions and identify patterns. Classify them into Cooperators, Defectors, or Mixed Strategists based on their past behavior.
	* Against Cooperators: Play Defect (D) to exploit their cooperative nature.
	* Against Defectors: Play Cooperate (C) to conserve resources and limit their exploitation opportunities.
	* Against Mixed Strategists: Mirror their previous action. If they cooperated, play Cooperate; if they defected, play Defect.
4. **Late Game (Rounds 16-r)**:
	* Focus on maximizing individual payoff. Play Defect (D) when the stock level is above 25% of capacity.
	* When the stock level falls below 25%, play Cooperate (C) to minimize losses and conserve resources.

**Additional Rules:**

* **Stock Spike Detection**: If the stock level increases significantly (>10%) between rounds, assume an opponent has switched from Defect to Cooperate. Adjust your strategy accordingly by playing Cooperate for a few rounds to test their new behavior.
* **Opponent Adaptation**: Continuously monitor opponents' actions and adjust your classification of them as needed. This ensures you respond effectively to changes in their strategies.

**Pseudocode:**

```
 Initialize variables:
 - current_round
 - stock_level
 - opponent_actions (array)
 - my_payoffs (array)

 While game not finished:
  If first round:
    Play Cooperate (C)
  Else if early game:
    If stock_level > 0.75 * capacity:
      Play Defect (D)
    Else if stock_level >= 0.5 * capacity and stock_level <= 0.75 * capacity:
      Play Cooperate (C)
    Else:
      Play Defect (D)
  Else if mid-game:
    Classify opponents based on past actions
    For each opponent:
      If Cooperator:
        Play Defect (D)
      Else if Defector:
        Play Cooperate (C)
      Else (Mixed Strategist):
        Mirror their previous action
  Else if late game:
    If stock_level > 0.25 * capacity:
      Play Defect (D)
    Else:
      Play Cooperate (C)

  Update variables:
    - current_round += 1
    - stock_level = new_stock_level()
    - opponent_actions.push(opponent_action())
    - my_payoffs.push(my_payoff())

 Return total payoff over all rounds
```

This Adaptive Exploiter strategy balances short-term gains with long-term sustainability, adapting to various opponent behaviors and game states. By continuously monitoring the environment and adjusting its actions, AE aims to maximize individual payoffs while minimizing losses in a competitive Common Pool Resource Game setting.
'''

description_EXPLOITATIVE_556 = '''
**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, play Cooperate (C) to gather information about opponents' behavior and avoid initial stock depletion.
2. **Opponent Analysis**: Monitor opponents' actions in each round and maintain a cooperation ratio (CR) for each opponent:
	* CR_i = (# of C's played by opponent i) / (total rounds)
3. **Threshold-Based Exploitation**: Play Defect (D) if the current stock is above 75% of capacity and at least one opponent has a CR below 0.5.
4. **Stock Conservation**: If the current stock falls below 25% of capacity, play Cooperate (C) to conserve stock for future rounds.
5. **Round-Based Adaptation**: Adjust strategy based on remaining rounds:
	* In the last round, always play Defect (D) to maximize payoff regardless of opponents' actions.
	* In the second-to-last round, play Cooperate (C) if most opponents (>50%) have a CR above 0.5; otherwise, play Defect (D).
6. **Opponent-Specific Response**: If an opponent has consistently played Defect (CR < 0.2), mirror their action to punish and deter further defection.

**Pseudocode:**
```
function AE_Strategy(current_stock, capacity, round, opponents_actions):
    if round == 1:
        return C  # Cooperate in the first round

    opponent_CRs = calculate_opponent_cooperation_ratios(opponents_actions)

    if current_stock > 0.75 * capacity and any(opponent_CR < 0.5 for opponent_CR in opponent_CRs):
        return D  # Exploit opponents with low cooperation ratios

    if current_stock < 0.25 * capacity:
        return C  # Conserve stock when it's low

    if round == last_round:
        return D  # Maximize payoff in the last round
    elif round == second_last_round:
        if most_opponents_cooperate(opponent_CRs):
            return C
        else:
            return D

    for opponent, opponent_action in opponents_actions.items():
        if opponent_CR[opponent] < 0.2:
            return mirror_action(opponent_action)

    # Default to Cooperate when no specific conditions are met
    return C
```
**Rationale:**

1. The initial round of cooperation helps gather information about opponents and avoids stock depletion.
2. Monitoring opponents' CRs allows for adaptive exploitation, targeting those with low cooperation ratios.
3. Stock conservation is crucial when the resource is scarce to ensure future payoffs.
4. Round-based adaptation adjusts strategy based on the game's progression, promoting cooperation or defection as needed.
5. Opponent-specific response ensures that exploitative behavior is addressed and deterred.

**Exploitative Mindset:** This strategy focuses on exploiting opponents with low cooperation ratios while conserving stock for future rounds. By adapting to changing circumstances and opponent behaviors, AE aims to maximize its payoffs in the tournament against various independent strategies.
'''

description_EXPLOITATIVE_557 = '''
Here is a robust and adaptive exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior.
2. **Subsequent Rounds (t>1):**
	* If the stock level is high (> capacity/2), Defect (D) to maximize short-term payoff, as there's a low risk of depleting the stock.
	* If the stock level is moderate (capacity/4 ≤ stock ≤ capacity/2), Cooperate (C) if most opponents defected in the previous round (i.e., ≥ n/2 players played D). Otherwise, Defect (D).
	* If the stock level is low (< capacity/4), Cooperate (C) to conserve the remaining stock and encourage others to do so.
3. **Last Round (t=r):** Defect (D) to maximize payoff, as there's no future rounds to consider.

**Additional Logic:**

* **Opponent Behavior Analysis:** Track the number of opponents who defected in each round. If ≥ n/2 players consistently defect over several rounds, assume they are likely to continue defecting and adjust strategy accordingly.
* **Stock Trend Analysis:** Monitor the stock level trend over time. If the stock is consistently decreasing or remains low, become more cautious and Cooperate (C) more frequently.

**Pseudocode:**
```python
def adaptive_exploiter(n, capacity, r, current_stock, previous_round_actions):
    if t == 1:
        return C  # Initial round, cooperate to gather information
    
    stock_level = current_stock / capacity
    
    if stock_level > 0.5:
        return D  # High stock level, defect for short-term gain
    elif stock_level >= 0.25 and stock_level <= 0.5:
        opponents_defected = sum(1 for action in previous_round_actions if action == D)
        if opponents_defected >= n/2:
            return C  # Moderate stock level, cooperate if most opponents defected
        else:
            return D
    else:  # Low stock level
        return C
    
    if t == r:
        return D  # Last round, defect for maximum payoff

def opponent_behavior_analysis(previous_round_actions):
    # Track number of opponents who defected in each round
    defectors = [sum(1 for action in actions if action == D) for actions in previous_round_actions]
    return defectors[-1] >= n/2  # Check if ≥ n/2 players consistently defected

def stock_trend_analysis(current_stock, previous_stocks):
    # Monitor stock level trend over time
    trend = [current - prev for current, prev in zip(previous_stocks[1:], previous_stocks[:-1])]
    return all(t < 0 for t in trend) or any(stock <= capacity/4 for stock in previous_stocks)
```
This strategy is designed to be robust and adaptive, taking into account the game's parameters, state, and history. It balances short-term gains with long-term sustainability, while being mindful of opponents' behavior and the overall stock level.
'''

description_EXPLOITATIVE_558 = '''
**Exploitative Strategy: "Adaptive Stock Guardian"**

This strategy aims to balance short-term gains with long-term sustainability of the common pool resource, while adapting to opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Observe the initial stock level and capacity.
	* Cooperate (C) if the initial stock is below 75% of capacity; Defect (D) otherwise.
2. **Middle Rounds (2 ≤ t < r):**
	* Calculate the average consumption rate of all players in the previous round (`avg_consumption_prev`).
	* If `avg_consumption_prev` exceeds 50% of the stock level at the start of that round, Cooperate (C); otherwise, Defect (D).
3. **Last Round (t=r):**
	* Defect (D) to maximize short-term gain, as there's no future impact on the game.

**Adaptive Mechanism:**

1. Track the opponent's average cooperation rate (`opponent_coop_rate`) over the past 2-3 rounds.
2. If `opponent_coop_rate` is above 0.6 (i.e., they cooperate more than 60% of the time), Cooperate (C) in the next round; otherwise, Defect (D).
3. Adjust this threshold (0.6) based on the game's progress:
	* If the stock level falls below 50% of capacity, decrease the threshold to 0.4.
	* If the stock level rises above 75% of capacity, increase the threshold to 0.8.

**Pseudocode:**
```python
def adaptive_stock_guardian(stock, capacity, n, r, history):
    # Initialize variables
    avg_consumption_prev = 0
    opponent_coop_rate = 0

    # First round logic
    if t == 1:
        if stock < 0.75 * capacity:
            return C
        else:
            return D

    # Middle rounds logic
    avg_consumption_prev = calculate_avg_consumption(history)
    if avg_consumption_prev > 0.5 * stock:
        return C
    else:
        return D

    # Last round logic
    if t == r:
        return D

    # Adaptive mechanism
    opponent_coop_rate = track_opponent_coop_rate(history)
    if opponent_coop_rate > 0.6:  # Adjust this threshold based on game progress
        return C
    else:
        return D
```
**Rationale:**

This strategy balances short-term gains with long-term sustainability by:

1. Cooperating when opponents are consuming excessively to maintain the stock level.
2. Defecting in the last round to maximize short-term gain.
3. Adapting to opponents' behaviors by adjusting cooperation rates based on their average cooperation rate.

**Exploitative Mindset:**

This strategy aims to exploit opponents' cooperative behavior while ensuring a sustainable stock level for future rounds. By adapting to opponents' actions, it seeks to balance individual gains with collective well-being, ultimately aiming to maximize its own payoff in the tournament.
'''

description_EXPLOITATIVE_559 = '''
**Exploitative Strategy: "Adaptive Stock Raider" (ASR)**

**Decision Rules:**

1. **Initial Round (t=1):** Play Cooperate (C) to observe opponents' initial moves and assess the stock's resilience.
2. **Subsequent Rounds (t>1):** Evaluate the current state of the game using the following factors:
	* Stock level: `S`
	* Number of remaining rounds: `r-t+1`
	* Historical data on opponents' actions
3. **Defect (D) if:** Any of the following conditions are met:
	+ The stock level is below a threshold (`θ`) calculated as `0.5 * capacity / n`. This indicates the stock is vulnerable to depletion.
	+ The number of remaining rounds is low (`r-t+1 ≤ 2`), and the current payoff from defecting is high enough to outweigh potential losses in future rounds.
	+ Opponents have consistently cooperated or shown signs of weakness (e.g., frequent cooperation when the stock is low).
4. **Cooperate (C) otherwise:** If none of the above conditions are met, play Cooperate to maintain a sustainable stock level and encourage opponents to do the same.

**Handling Edge Cases:**

* **Last Round (t=r):** Always Defect (D) to maximize short-term gains, as there is no future stock to protect.
* **Stock Depletion:** If the stock level falls below a critical threshold (`0.2 * capacity`), switch to Defecting permanently to ensure maximum individual gain, even if it means depleting the stock.

**Pseudocode:**
```python
def adaptive_stock_raider(state):
    # Initialize parameters
    capacity = state.capacity
    n = state.n
    r = state.r
    S = state.stock
    t = state.round

    # First round: Cooperate and observe opponents' initial moves
    if t == 1:
        return 'C'

    # Calculate threshold for defecting based on stock level
    θ = 0.5 * capacity / n

    # Evaluate current game state
    if S < θ or (r - t + 1) <= 2:
        # Defect if stock is vulnerable or few rounds remain
        return 'D'
    elif opponents_have_consistently_cooperated() or opponents_show_weakness():
        # Exploit weak opponents by defecting
        return 'D'

    # Cooperate to maintain sustainable stock level and encourage cooperation
    return 'C'

def opponents_have_consistently_cooperated():
    # Analyze historical data on opponents' actions
    # Return True if most opponents have cooperated consistently

def opponents_show_weakness():
    # Analyze historical data on opponents' actions
    # Return True if some opponents show signs of weakness (e.g., frequent cooperation when stock is low)
```
This Adaptive Stock Raider strategy balances short-term gains with long-term sustainability, exploiting weak opponents while maintaining a stable stock level. Its adaptability and robustness make it suitable for a wide range of opponent behaviors in the tournament setting.
'''

description_EXPLOITATIVE_560 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk (ASH) strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the common pool resource game.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' strategies and to avoid an initial stock depletion.
2. **Stock-dependent Cooperation**: Cooperate (C) when the current stock level is below a threshold `stock_threshold`, which is calculated as `capacity / 4`. This encourages sustainable consumption and allows for stock growth.
3. **Defecting on Low Stock Growth**: Defect (D) when the previous round's stock growth is low (`growth < capacity / 10`). This indicates that the current consumption rate is too high, and defecting will help to reduce the total consumption.
4. **Exploiting Opponents' Cooperation**: Cooperate (C) when at least half of the opponents cooperated in the previous round. This takes advantage of their cooperation and allows for higher payoffs while maintaining a sustainable stock level.
5. **Default Defection**: Defect (D) in all other cases.

**Pseudocode:**
```
ASHStrategy(current_stock, capacity, num_opponents, previous_round_actions):
  if current_round == 1:
    return COOPERATE
  end

  stock_threshold = capacity / 4
  if current_stock < stock_threshold:
    return COOPERATE
  end

  prev_growth = calculate_previous_round_growth()
  if prev_growth < capacity / 10:
    return DEFECT
  end

  opponents_cooperated = count_cooperators(previous_round_actions)
  if opponents_cooperated >= num_opponents / 2:
    return COOPERATE
  end

  return DEFECT
end
```
**Handling Edge Cases:**

* **Last Round**: In the last round, defect (D) to maximize payoffs regardless of the stock level.
* **Zero Stock**: If the current stock level is zero, cooperate (C) to avoid a complete depletion and allow for potential stock growth in the next round.

By following these decision rules, the Adaptive Stock Hawk strategy balances short-term gains with long-term sustainability, exploiting opponents' cooperation while adapting to the dynamic state of the game. This approach enables ASH to perform well against a wide range of opponent behaviors and strategies.
'''

description_EXPLOITATIVE_561 = '''
To develop an exploitative strategy for this Common Pool Resource Game, I'll outline a decision-making approach that adapts to the game's state and history while aiming to maximize payoffs.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **First Round**: Cooperate (C) in the first round to gather information about opponents' behaviors and initial stock level.
2. **Subsequent Rounds**: Observe the previous round's actions and outcomes:
	* If the total consumption was less than or equal to half of the capacity, defect (D). This indicates that opponents are likely cooperating, and you can exploit this by consuming more resources.
	* If the total consumption exceeded half of the capacity but did not deplete the stock entirely, cooperate (C) if your previous action was D, and defect (D) otherwise. This helps to balance exploitation with maintaining a sustainable stock level.
	* If the stock is depleted or very low (< 10% of capacity), cooperate (C) to allow for regeneration.
3. **Stock Thresholds**:
	* If the current stock level is above 75% of the capacity, defect (D). This allows you to exploit the abundant resources while opponents are likely to cooperate.
	* If the current stock level falls below 25% of the capacity, cooperate (C) to avoid over-depletion and maintain a sustainable resource base.

**Edge Cases:**

1. **Last Round**: Defect (D) in the last round, as there is no future consequence for depleting the stock.
2. **Tiebreaker**: In cases where multiple strategies would lead to the same payoff, prioritize defecting (D) over cooperating (C).

**Adaptive Elements:**

1. **Opponent Monitoring**: Continuously observe opponents' actions and adjust your strategy based on their behavior.
2. **Stock Level Adjustment**: Adapt your decision-making to changes in the stock level, balancing exploitation with sustainability.

Pseudocode for a simplified implementation:
```python
def adaptive_exploiter(stock_level, capacity, round_number, opponent_actions):
    if round_number == 1:  # First Round
        return 'C'
    
    total_consumption = sum(opponent_actions) + (stock_level / (2 * num_players))
    
    if total_consumption <= capacity / 2:
        return 'D'  # Defect when opponents cooperate
    
    elif stock_level < 0.1 * capacity:  # Very low stock level
        return 'C'
    
    elif stock_level > 0.75 * capacity:  # High stock level
        return 'D'
    
    else:
        if opponent_actions[-1] == 'D':  # Previous action was defect
            return 'C'  # Cooperate to balance exploitation
        else:
            return 'D'

def main():
    num_players = 4
    capacity = 100
    stock_level = capacity
    
    for round_number in range(1, num_rounds + 1):
        opponent_actions = [get_opponent_action(i) for i in range(num_players)]
        
        action = adaptive_exploiter(stock_level, capacity, round_number, opponent_actions)
        
        # Update stock level and consume resources
        if action == 'C':
            consumption = stock_level / (2 * num_players)
        else:
            consumption = stock_level / num_players
        
        stock_level -= consumption
        
        # Regenerate stock
        growth = 2 * stock_level * (1 - stock_level / capacity)
        stock_level += growth
        
        # Ensure stock level does not exceed capacity
        stock_level = min(stock_level, capacity)

# Note: The `get_opponent_action` function is a placeholder for retrieving opponents' actions.
```
This Adaptive Exploiter strategy balances exploitation with sustainability, adapting to the game's state and opponent behaviors. By monitoring opponents and adjusting its decision-making accordingly, AE aims to maximize payoffs while minimizing the risk of over-depletion.
'''

description_EXPLOITATIVE_562 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The ASR strategy is designed to exploit the common pool resource game by adapting to the opponents' behaviors and maximizing individual payoffs.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to gather information about the opponents' initial behavior.
2. **Stock Level Assessment**: Evaluate the current stock level (S) relative to the capacity (c). If S > 0.75c, consider the stock level as "high." Otherwise, consider it as "low."
3. **Opponent Behavior Analysis**: Observe the previous round's actions and payoffs of all opponents. Calculate the average cooperation rate among opponents in the last round.
4. **Adaptive Decision**:
	* If the stock level is high and the average opponent cooperation rate is above 0.5, Cooperate (C). This indicates that opponents are likely to cooperate, so it's beneficial to maintain a sustainable stock level.
	* If the stock level is low or the average opponent cooperation rate is below 0.5, Defect (D). This suggests that opponents might be exploiting the resource aggressively, and defecting can secure a higher individual payoff.
5. **Consecutive Cooperation**: If an opponent has cooperated for two consecutive rounds while the stock level was high, switch to Cooperate (C) for one round to potentially induce cooperation from other players.

**Edge Case Handling**

* **Last Round**: Defect (D) in the last round to maximize individual payoff, as there's no future cost to exploitation.
* **Tie-Breaking**: In cases where the average opponent cooperation rate is exactly 0.5, or when evaluating consecutive cooperation, use a pseudorandom tie-breaker to introduce some randomness and make the strategy more unpredictable.

**Additional Heuristics**

* **Monitoring Opponent Strategies**: Keep track of opponents' strategies over time to detect potential patterns or anomalies. If an opponent consistently defects or cooperates, adjust the ASR strategy accordingly.
* **Adapting to Stock Fluctuations**: Monitor stock level fluctuations and adjust the decision-making process based on these changes.

Pseudocode for the Adaptive Stock Raider (ASR) strategy:
```python
def ASR(stock_level, capacity, opponent_actions, opponent_payoffs):
  # Initial round: Cooperate
  if current_round == 1:
    return C

  # Assess stock level and opponent behavior
  avg_coop_rate = calculate_average_cooperation(opponent_actions)
  stock_status = 'high' if stock_level > 0.75 * capacity else 'low'

  # Adaptive decision-making
  if stock_status == 'high' and avg_coop_rate > 0.5:
    return C
  elif stock_status == 'low' or avg_coop_rate < 0.5:
    return D

  # Consecutive cooperation handling
  for opponent in opponent_actions:
    if opponent.has_cooperated_consecutively(2) and stock_level > 0.75 * capacity:
      return C

  # Last round: Defect
  if current_round == total_rounds:
    return D

  # Tie-breaking and pseudorandomness
  if avg_coop_rate == 0.5 or opponent.has_consistent_strategy():
    return random.choice([C, D])
```
This strategy is designed to be exploitative while adapting to the opponents' behaviors and stock level fluctuations. By monitoring opponent strategies and adjusting its decision-making process accordingly, ASR aims to maximize individual payoffs in a dynamic common pool resource game environment.
'''

description_EXPLOITATIVE_563 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

Decision Rules:

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behavior and set a benchmark for future rounds.
2. **Subsequent Rounds (t>1)**:
	* If the stock level is high (> 0.75 \* capacity), defect (D) to maximize short-term gains, exploiting potential cooperation from other players.
	* If the stock level is moderate (0.25 \* capacity ≤ stock ≤ 0.75 \* capacity), use a **mixed strategy**:
		+ Cooperate (C) with probability p = (stock / capacity) ^ 2
		+ Defect (D) with probability 1 - p
	* If the stock level is low (< 0.25 \* capacity), cooperate (C) to conserve resources and avoid depletion.
3. **Last Round (t=r)**: Defect (D) to maximize final-round payoffs, as there's no future benefit to cooperation.

Handling Edge Cases:

* In cases of tie or near-tie in stock levels, favor cooperation (C) to maintain a stable resource base.
* If an opponent consistently cooperates despite low stock levels, adapt by increasing the probability of defecting (D) against that player.

Pseudocode:
```python
def adaptive_stock_raider(stock, capacity, round_number, total_rounds):
    if round_number == 1:  # Initial Round
        return 'C'
    
    elif stock > 0.75 * capacity:  # High Stock Level
        return 'D'
    
    elif 0.25 * capacity <= stock <= 0.75 * capacity:  # Moderate Stock Level
        p = (stock / capacity) ** 2
        if random.random() < p:
            return 'C'
        else:
            return 'D'
    
    elif stock < 0.25 * capacity:  # Low Stock Level
        return 'C'
    
    elif round_number == total_rounds:  # Last Round
        return 'D'
```
This strategy balances short-term gains with long-term sustainability, adapting to the game state and opponents' behavior. By initially cooperating, it sets a benchmark for future rounds and gathers information about opponents. As the game progresses, it exploits high stock levels, uses mixed strategies in moderate situations, and conserves resources when the stock is low. Finally, it maximizes final-round payoffs by defecting.
'''

description_EXPLOITATIVE_564 = '''
**Exploitative Strategy: Adaptive Stock Defender (ASD)**

The ASD strategy aims to balance short-term gains with long-term sustainability by adapting to the game's state and opponent behaviors.

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' initial actions and set a cooperative tone.
2. **Early Rounds**: If the stock level is above 75% of capacity, cooperate (C). This encourages sustainable consumption and reduces the risk of early depletion.
3. **Middle Game**: When the stock level falls between 25% and 75% of capacity, use a mixed strategy:
	* If most opponents (≥ 50%) defected in the previous round, defect (D) to avoid being exploited.
	* Otherwise, cooperate (C) to maintain a moderate consumption pace.
4. **Late Game**: When the stock level drops below 25% of capacity or there are fewer than 5 rounds remaining:
	* If most opponents (≥ 50%) defected in the previous round, defect (D) to maximize short-term gains.
	* Otherwise, cooperate (C) to minimize losses and preserve some stock for future rounds.

**Edge Case Handling:**

1. **Last Round**: Defect (D) in the final round to maximize payoffs, as there's no risk of long-term consequences.
2. **Tiebreakers**: In cases where the opponent behavior is evenly split, favor cooperation (C) to maintain a more sustainable consumption pace.

**Adaptation Mechanism:**

1. **Opponent Behavior Tracking**: Monitor opponents' actions in each round and update a history of their behaviors.
2. **Stock Level Monitoring**: Continuously track the current stock level and adjust the strategy accordingly.

Pseudocode:
```python
def ASD(n, capacity, rounds, history):
    # Initialize variables
    stock = capacity
    opponent_behaviors = [0] * n

    for round in range(rounds):
        # Update opponent behaviors
        for i in range(n):
            if history[round - 1][i] == 'D':
                opponent_behaviors[i] += 1

        # Determine current stock level
        stock_level = stock / capacity

        # Early rounds: cooperate to set tone and gather information
        if round == 0:
            action = 'C'
        # Middle game: mixed strategy based on opponent behaviors and stock level
        elif 0.25 <= stock_level < 0.75:
            if sum(opponent_behaviors) / n >= 0.5:
                action = 'D'
            else:
                action = 'C'
        # Late game: prioritize short-term gains or minimize losses
        elif stock_level < 0.25 or round > rounds - 5:
            if sum(opponent_behaviors) / n >= 0.5:
                action = 'D'
            else:
                action = 'C'
        # Last round: maximize payoffs
        elif round == rounds - 1:
            action = 'D'

        # Update stock level based on actions
        consumption = sum([action_to_consumption(a, n) for a in [action] + history[round]])
        stock -= consumption

        # Store current state for next iteration
        history.append([action] + opponent_behaviors)
    return history

def action_to_consumption(action, n):
    if action == 'C':
        return capacity / (2 * n)
    else:
        return capacity / n
```
The ASD strategy is designed to be adaptive and robust, balancing short-term gains with long-term sustainability. By monitoring opponent behaviors and the current stock level, it adjusts its decision-making to maximize payoffs while minimizing losses.
'''

description_EXPLOITATIVE_565 = '''
Here's a exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** "Adaptive Stock Raider" (ASR)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and initial stock level.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term gain.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance individual gain with sustainability.
	* If the current stock level is below 50% of capacity, Cooperate (C) to prioritize long-term sustainability over short-term gains.
3. **Adaptive Component:** Monitor opponents' behaviors and adjust strategy accordingly:
	+ If a majority of opponents (>50%) Defect in two consecutive rounds, switch to Defecting for the next round to capitalize on their exploitation.
	+ If a majority of opponents (>50%) Cooperate in two consecutive rounds, continue Cooperating to maintain a sustainable stock level.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) to maximize individual gain, as there is no future sustainability concern.
2. **Critical Stock Level:** If the current stock level falls below 25% of capacity, Defect (D) for the remainder of the game to ensure some gain, even if it's not optimal.

**Pseudocode:**
```
function AdaptiveStockRaider(gameState):
    // Initialize strategy based on round number and stock level
    if t == 1:
        return C
    
    // Evaluate current stock level
    if stockLevel > 0.75 * capacity:
        return D
    elif stockLevel >= 0.5 * capacity:
        return C
    else:
        return C

    // Adaptive component: monitor opponents' behaviors
    opponentBehaviors = getOpponentActions(gameState)
    majorityBehavior = getMajorityBehavior(opponentBehaviors)

    if majorityBehavior == D and consecutiveDCount > 1:
        return D
    elif majorityBehavior == C and consecutiveCCcount > 1:
        return C

    // Edge cases
    if t == r:
        return D
    elif stockLevel < 0.25 * capacity:
        return D

    // Default to Cooperate
    return C
```
This strategy, Adaptive Stock Raider (ASR), balances individual gain with sustainability concerns while adapting to opponents' behaviors. By monitoring the current stock level and opponents' actions, ASR adjusts its strategy to maximize payoffs over multiple rounds.
'''

description_EXPLOITATIVE_566 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk is a dynamic and responsive strategy designed to exploit various opponent behaviors while maximizing its own payoffs.

**Decision Rules:**

1. **Initial Round (Round 1):**
	* Cooperate (C) if the stock level is at or near capacity.
	* Defect (D) otherwise.
2. **Early Rounds (Rounds 2-5):**
	* Monitor opponents' behavior and identify potential cooperators and defectors.
	* If a cooperator is identified, cooperate (C) to build trust and accumulate payoffs.
	* If a defector is identified, defect (D) to minimize losses and exploit the opponent's greed.
3. **Mid-Game (Rounds 6-r/2):**
	* Continuously assess the stock level and opponents' behavior.
	* Cooperate (C) if:
		+ The stock level is above a threshold (e.g., 75% of capacity).
		+ Most opponents are cooperating.
	* Defect (D) otherwise.
4. **Late Game (Rounds r/2+1-r):**
	* Be more aggressive and defect (D) to maximize payoffs, especially if the stock level is low.

**Edge Cases:**

1. **Last Round (Round r):**
	* Always defect (D) to maximize the final payoff.
2. **Stock Depletion:**
	* If the stock level drops below a critical threshold (e.g., 25% of capacity), cooperate (C) to help replenish the stock and ensure future payoffs.

**Adaptive Mechanisms:**

1. **Opponent Profiling:** Maintain a simple profile for each opponent, tracking their cooperation/defection history.
2. **Stock Level Monitoring:** Continuously assess the current stock level and adjust behavior accordingly.
3. **Payoff Comparison:** Compare own payoffs with opponents' payoffs to identify opportunities for exploitation.

**Pseudocode:**
```
// Initialize variables
round = 1;
stock_level = capacity;
opponent_profiles = {};
payoffs = {};

while (round <= r) {
  // Early rounds: Monitor opponent behavior
  if (round <= 5) {
    observe_opponents();
    update_opponent_profiles();
  }

  // Mid-game: Assess stock level and opponents
  if (round > 5 && round < r/2) {
    assess_stock_level();
    cooperate = (stock_level >= 0.75 * capacity) || most_opponents_cooperate();
  }

  // Late game: Be more aggressive
  if (round >= r/2) {
    defect = true;
  }

  // Last round: Always defect
  if (round == r) {
    defect = true;
  }

  // Stock depletion: Cooperate to replenish stock
  if (stock_level < 0.25 * capacity) {
    cooperate = true;
  }

  // Decide action based on conditions
  if (cooperate) {
    action = C;
  } else {
    action = D;
  }

  // Take action and update payoffs
  take_action(action);
  update_payoffs();

  // Update round number
  round++;
}
```
The Adaptive Stock Hawk strategy is designed to be robust and exploitative, adapting to various opponent behaviors while maximizing its own payoffs. By continuously monitoring the stock level and opponents' behavior, it adjusts its actions to ensure optimal outcomes in different game scenarios.
'''

description_EXPLOITATIVE_567 = '''
Here's a description of my exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to observe opponent behavior and stock dynamics.
2. **Middle Rounds (2 ≤ t < r):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term payoff.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance individual payoff with long-term sustainability.
	* If the current stock level is below 50% of capacity, Cooperate (C) to prioritize stock recovery.
3. **Final Round (t=r):** Defect (D) to maximize last-round payoff.

**Adaptive Component:**

1. Monitor opponent behavior by tracking their cooperation rate (CR) over time.
2. Calculate the average CR of opponents for each round.
3. If the average CR is above 0.5, adjust the strategy to be more cooperative (i.e., shift the thresholds in step 2 towards cooperation).
4. If the average CR is below 0.5, maintain or increase defectiveness.

**Pseudocode:**
```
def AE(stock, capacity, n, r, t):
  if t == 1:
    return C
  elif stock > 0.75 * capacity:
    return D
  elif 0.5 <= stock / capacity < 0.75:
    opponent_CR = calculate_opponent_cooperation_rate()
    if opponent_CR > 0.5:
      return C
    else:
      return D
  elif stock / capacity < 0.5:
    return C
  else:  # t == r
    return D

def calculate_opponent_cooperation_rate():
  # Track opponent actions and calculate CR over time
  pass
```
**Rationale:**

The Adaptive Exploiter strategy is designed to balance short-term gains with long-term sustainability. By cooperating in the first round, we gather information about opponent behavior and stock dynamics.

In middle rounds, we adapt our strategy based on the current stock level. When the stock is high, we defect to maximize payoff. As the stock decreases, we cooperate to prioritize recovery.

The adaptive component allows us to adjust our strategy based on opponent behavior. If opponents are generally cooperative, we become more cooperative as well. Otherwise, we maintain or increase our defectiveness.

In the final round, we defect to maximize last-round payoff.

This strategy is robust and exploitative, making it a strong contender in a tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_568 = '''
Here's a description of the exploitative strategy:

**Name:** Adaptive Stock Exploiter (ASE)

**Decision Rules:**

1. **Initial Round (t=1):** Play C (Cooperate) to establish a baseline for stock growth and observe opponents' initial actions.
2. **Middle Rounds (1 < t < r):**
	* If the current stock level is above 75% of capacity, play D (Defect) to maximize individual payoff, exploiting the current abundance of resources.
	* If the current stock level is between 25% and 75% of capacity, play C (Cooperate) to maintain a balance between personal gain and resource sustainability.
	* If the current stock level is below 25% of capacity, play D (Defect) to maximize individual payoff, as the resource is already depleted.
3. **Last Round (t=r):** Play D (Defect), as there's no future benefit in cooperating.

**Edge Cases:**

* If the game state indicates that an opponent has consistently played C (Cooperate), ASE will play D (Defect) to exploit their cooperative behavior, starting from the second round.
* If the game state shows that multiple opponents have consistently played D (Defect), ASE will adapt by playing C (Cooperate) in the next round to avoid over-exploitation and promote resource growth.

**Adaptive Component:**

ASE monitors the game history and adjusts its strategy based on the following conditions:

* **Over-exploitation:** If the stock level drops below 25% of capacity due to collective defection, ASE will switch to playing C (Cooperate) for one round to allow the stock to recover.
* **Undersharing:** If an opponent consistently plays D (Defect), ASE will play D (Defect) as well, but with a probability that decreases over time if the opponent continues to defect. This encourages opponents to reconsider their strategy.

**Pseudocode:**
```markdown
function AdaptiveStockExploiter(game_state):
  t = current_round
  S = current_stock_level
  capacity = game_capacity

  # Initial Round
  if t == 1:
    return C (Cooperate)

  # Middle Rounds
  elif 1 < t < r:
    if S > 0.75 * capacity:
      return D (Defect)
    elif 0.25 * capacity <= S <= 0.75 * capacity:
      return C (Cooperate)
    else:
      return D (Defect)

  # Last Round
  else:
    return D (Defect)

  # Adaptive Component
  if opponent_consistently_cooperates():
    return D (Defect)
  elif multiple_opponents_consistently_defect():
    return C (Cooperate)
```
This strategy combines elements of adaptive play, exploitative behavior, and edge-case handling to maximize payoffs in a wide range of scenarios. By monitoring the game state and adjusting its actions accordingly, ASE aims to outperform other strategies in the tournament.
'''

description_EXPLOITATIVE_569 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Overview**
The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the common pool resource game. ASR balances short-term gains with long-term sustainability, aiming to maximize total payoff over multiple rounds.

**Decision Rules**

1. **Initial Round**: Defect (D) in the first round to gauge opponents' behavior and accumulate information about their strategies.
2. **Stock-dependent Cooperation**: Cooperate (C) when the current stock level is above a certain threshold (`stock_threshold`), which is calculated based on the game parameters:
	* `stock_threshold = capacity / (2 * n)`
3. **Opponent Behavior Analysis**: Monitor opponents' actions in previous rounds and calculate their cooperation rates (`opponent_cooperation_rate`). If an opponent has defected more than 50% of the time, ASR will defect against them.
4. **Adaptive Defection**: Defect when the total consumption in the previous round exceeded a certain percentage (`consumption_threshold`) of the capacity:
	* `consumption_threshold = 0.7 * capacity`
5. **Last Round**: Cooperate in the last round to ensure some level of sustainability, regardless of opponents' behavior.

**Pseudocode**
```python
def adaptive_stock_raider(game_state):
    # Initialize variables
    stock_threshold = game_state.capacity / (2 * game_state.n)
    consumption_threshold = 0.7 * game_state.capacity
    
    # First round: defect to gather information
    if game_state.round == 1:
        return "D"
    
    # Stock-dependent cooperation
    if game_state.stock > stock_threshold:
        return "C"
    
    # Opponent behavior analysis
    opponent_cooperation_rates = calculate_opponent_cooperation_rates(game_state)
    for opponent in opponent_cooperation_rates:
        if opponent_cooperation_rates[opponent] < 0.5:
            return "D"  # Defect against opponents with low cooperation rate
    
    # Adaptive defection
    previous_total_consumption = game_state.previous_round.total_consumption
    if previous_total_consumption > consumption_threshold:
        return "D"
    
    # Last round: cooperate for sustainability
    if game_state.round == game_state.r:
        return "C"
    
    # Default action: defect to maximize short-term gains
    return "D"

def calculate_opponent_cooperation_rates(game_state):
    # Calculate opponents' cooperation rates based on their actions in previous rounds
    opponent_cooperation_rates = {}
    for opponent in game_state.opponents:
        cooperation_count = 0
        total_rounds = 0
        for round in game_state.round_history:
            if round[opponent] == "C":
                cooperation_count += 1
            total_rounds += 1
        opponent_cooperation_rates[opponent] = cooperation_count / total_rounds
    return opponent_cooperation_rates
```
**Edge Cases**

* First round: Defect to gather information about opponents' strategies.
* Last round: Cooperate to ensure some level of sustainability, regardless of opponents' behavior.
* Opponents with low cooperation rates: Defect against them to exploit their lack of cooperation.
* High total consumption in previous rounds: Defect to adapt to the changing game state and maximize short-term gains.

**Exploitative Mindset**
The Adaptive Stock Raider strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the common pool resource game. By balancing short-term gains with long-term sustainability, ASR aims to maximize total payoff over multiple rounds.
'''

description_EXPLOITATIVE_570 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll outline a decision rule that adapts to the game's state and history. This strategy aims to maximize individual payoffs while being robust to various opponent behaviors.

**Strategy Name: Adaptive Exploiter**

**Decision Rule:**

1. **Initial Round (t=1)**:
	* Observe the initial stock level and number of players.
	* Play C (Cooperate) in the first round to gauge opponents' behavior and avoid over-exploitation.
2. **Subsequent Rounds (t > 1)**:
	* Calculate the current stock level and total consumption from previous rounds.
	* Evaluate the "exploitation index" (EI):
		+ EI = (Total Consumption / Capacity) / (Number of Players * Number of Rounds)
		+ If EI ≥ 0.5, indicate high exploitation; if EI < 0.5, indicate low exploitation
	* Based on the EI:
		- If EI ≥ 0.7, play D (Defect): High exploitation indicates opponents are defecting; maximize individual payoff.
		- If 0.4 ≤ EI < 0.7, play C: Moderate exploitation suggests some cooperation; maintain a balance between individual gain and sustainability.
		- If EI < 0.4, play D: Low exploitation implies opponents are cooperating; exploit the situation for maximum individual gain.
3. **Last Round (t = r)**:
	* Play D (Defect) regardless of the EI value, as there's no future stock to conserve.

**Edge Case Handling:**

* If an opponent is consistently playing C while others play D, adjust the EI calculation to account for this "sucker" behavior.
* In case of a tie in the EI value, default to playing C to maintain some cooperation and avoid over-exploitation.

**Pseudocode (simplified):**
```markdown
# Initialize variables
stock = capacity
total_consumption = 0
EI = 0

# Loop through rounds
for t in range(1, r+1):
    # Calculate EI
    EI = (total_consumption / capacity) / (n * t)
    
    if t == 1:
        action = C  # Cooperate in the first round
    elif EI >= 0.7:
        action = D  # Defect with high exploitation
    elif 0.4 <= EI < 0.7:
        action = C  # Balance individual gain and sustainability
    else:
        action = D  # Exploit low exploitation
    
    if t == r:
        action = D  # Defect in the last round
    
    # Update total consumption and stock level
    total_consumption += (stock / n) * (action == C)
    stock -= (stock / n) * (action == C)
    
    # Apply stock growth dynamics
    stock_growth = 2 * stock * (1 - stock/capacity)
    new_stock = min(stock + stock_growth, capacity)
```
This strategy is designed to be adaptive and exploitative, taking into account the game's state and history. It balances individual gain with sustainability, adjusting its behavior based on the exploitation index. The pseudocode provides a simplified representation of the decision rule.
'''

description_EXPLOITATIVE_571 = '''
Here's a proposed exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and set a baseline for future exploitation.
2. **Assess Opponent Behavior**: After each round, calculate the average payoff of all opponents in the previous round. If their average payoff is above a certain threshold (e.g., 75% of the maximum possible payoff), assume they are cooperating (C) or using a cooperative strategy. Otherwise, assume they are defecting (D).
3. **Exploitation Mode**: If most opponents (more than half) are assumed to be cooperating, switch to Defect (D) mode for the next round. This exploits their cooperation and maximizes personal payoff.
4. **Punishment Mechanism**: If an opponent is detected to have defected in a previous round, punish them by playing Cooperate (C) in the next round. This aims to maintain a balance of power and deter future defection.
5. **Stock-Dependent Adjustment**: Monitor the current stock level. If it falls below 50% of capacity, adjust strategy to Cooperate (C) for the next round to avoid depletion. If the stock is critically low (<25%), prioritize self-preservation by playing Defect (D).
6. **Final Round**: In the last round, always play Defect (D), as there are no future consequences.

**Edge Cases:**

1. **Tiebreaker**: In case of a tie in opponent behavior assessment (e.g., equal number of cooperators and defectors), maintain the current strategy.
2. **Opponent Switching**: If an opponent changes their behavior, re-evaluate their new behavior using the same rules.

**Pseudocode:**
```
Initialize:
  - current_strategy = COOPERATE
  - opponent_behavior = []
  - stock_threshold = capacity * 0.5

For each round:
  - Observe opponents' actions and payoffs from previous round
  - Assess opponent behavior using average payoff threshold
  - Update opponent_behavior list

  If (most opponents are cooperating):
    - current_strategy = DEFECT
  Else if (opponent defected in previous round):
    - current_strategy = COOPERATE (punishment)
  Else if (stock level < stock_threshold):
    - Adjust strategy based on stock-dependent adjustment rules
  Else:
    - Maintain current strategy

  If (final round):
    - current_strategy = DEFECT

  Play action according to current_strategy
```
This Adaptive Exploiter strategy aims to balance exploitation and cooperation, taking into account the game's state and opponents' behavior. By adapting to changing circumstances and using punishment mechanisms, it seeks to maximize personal payoff while maintaining a robust presence in the tournament.
'''

description_EXPLOITATIVE_572 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize individual payoffs by adaptively responding to the current stock level, opponent actions, and game history.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Observe the initial stock level and number of players.
	* Defect (D) if the initial stock level is above 75% of the capacity; otherwise, Cooperate (C).
2. **Subsequent Rounds (t>1)**:
	* Calculate the average opponent consumption in the previous round: `avg_opponent_consumption = total_consumption / (n - 1)`
	* If the current stock level is above 50% of the capacity and `avg_opponent_consumption` is below the cooperative consumption threshold (`stock / (2n)`), Cooperate (C).
	* Otherwise, Defect (D) if the current stock level is above 25% of the capacity; otherwise, Cooperate (C) to avoid depletion.
3. **Stock Depletion Response**:
	* If the stock level falls below 25% of the capacity in any round, switch to Cooperate (C) for the remainder of the game to conserve the resource.

**Edge Case Handling:**

1. **Last Round (t=r)**:
	* Defect (D) if the current stock level is above 50% of the capacity; otherwise, Cooperate (C) to avoid depletion.
2. **Tiebreaker**:
	* In case of a tie in the decision rules, prioritize Defecting (D) to maximize individual payoffs.

**Pseudocode:**
```python
def adaptive_stock_raider(game_state):
    # Initial round
    if game_state.round == 1:
        if game_state.stock >= 0.75 * game_state.capacity:
            return 'D'  # Defect
        else:
            return 'C'  # Cooperate

    # Subsequent rounds
    avg_opponent_consumption = (game_state.total_consumption - game_state.my_consumption) / (game_state.n - 1)
    if game_state.stock >= 0.5 * game_state.capacity and avg_opponent_consumption < game_state.cooperative_threshold:
        return 'C'  # Cooperate
    elif game_state.stock >= 0.25 * game_state.capacity:
        return 'D'  # Defect
    else:
        return 'C'  # Cooperate to conserve resource

    # Stock depletion response
    if game_state.stock < 0.25 * game_state.capacity:
        return 'C'  # Cooperate for the remainder of the game

    # Last round tiebreaker
    if game_state.round == game_state.r and game_state.stock >= 0.5 * game_state.capacity:
        return 'D'  # Defect to maximize individual payoffs
```
This strategy is designed to be adaptive, exploitative, and robust against a wide range of opponent behaviors. By responding to the current stock level, opponent actions, and game history, "Adaptive Stock Raider" aims to maximize individual payoffs while conserving the common resource when necessary.
'''

description_EXPLOITATIVE_573 = '''
I'll design a exploitative strategy for this game that adapts to various opponent behaviors and maximizes my payoff.

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round**: In the first round, I will cooperate (play C). This is because cooperation yields a higher payoff when the stock is at its maximum capacity.
2. **Early Rounds**: For rounds 2 to r/2 (where r is the total number of rounds), I will use the following logic:
	* If my previous-round payoff was higher than or equal to the average payoff of all players in that round, I will cooperate (play C).
	* Otherwise, I will defect (play D).
3. **Mid-Game Adjustment**: After round r/2, I will reassess the game state and adjust my strategy:
	* If the stock level is above 75% of its capacity, I will continue to use the early-round logic.
	* If the stock level is between 50% and 75% of its capacity, I will start to defect (play D) more frequently. Specifically, I will play D if my previous-round payoff was lower than the average payoff of all players in that round, or if I defected in the previous round.
	* If the stock level is below 50% of its capacity, I will always defect (play D).
4. **Endgame**: In the last two rounds, I will play D regardless of the game state.

**Pseudocode:**
```python
def adaptive_exploiter(stock, capacity, round_num, r, history):
    if round_num == 1:
        return 'C'  # Cooperate in the first round
    
    avg_payoff = calculate_avg_payoff(history)
    my_prev_payoff = history[-1]['my_payoff']
    
    if round_num <= r/2:
        if my_prev_payoff >= avg_payoff:
            return 'C'
        else:
            return 'D'
    elif stock > 0.75 * capacity:
        # Continue early-round logic
        if my_prev_payoff >= avg_payoff:
            return 'C'
        else:
            return 'D'
    elif stock >= 0.5 * capacity:
        # Defect more frequently
        if my_prev_payoff < avg_payoff or history[-1]['my_action'] == 'D':
            return 'D'
        else:
            return 'C'
    else:
        # Always defect when stock is low
        return 'D'
    
    if round_num >= r-2:
        return 'D'  # Defect in the last two rounds

def calculate_avg_payoff(history):
    total_payoff = sum([entry['payoff'] for entry in history])
    return total_payoff / len(history)
```
**Rationale:**

* By cooperating in the first round, I set a high initial payoff and encourage others to cooperate.
* In early rounds, I adapt to the game state by cooperating if my previous-round payoff was good. This helps maintain a healthy stock level and incentivizes cooperation.
* As the game progresses and the stock level decreases, I become more exploitative and defect more frequently to maximize my payoff.
* In the endgame, I always defect to ensure I don't miss out on potential payoffs.

This strategy should perform well against a wide range of opponent behaviors and adapt to changing game conditions.
'''

description_EXPLOITATIVE_574 = '''
To design an exploitative strategy for this game that is adaptive and robust to a wide range of opponent behaviors, I propose the following decision rules:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Rounds (t ≤ 2):** Cooperate (C) in the first two rounds to gather information about the opponents' behavior and to contribute to the stock growth.
2. **Stock Assessment:** Evaluate the current stock level (S) relative to the capacity. If S ≥ 0.75 × capacity, cooperate; otherwise, defect.
3. **Opponent Behavior Analysis:**
	* Track the number of cooperators (C_count) and defectors (D_count) in each round.
	* Calculate the average payoff for cooperators (C_avg_payoff) and defectors (D_avg_payoff) over the last 2-3 rounds.
4. **Adaptive Exploitation:**
	* If C_count > D_count and C_avg_payoff > D_avg_payoff, cooperate to maintain a high stock level and benefit from cooperation.
	* If C_count < D_count or C_avg_payoff < D_avg_payoff, defect to exploit the existing stock and maximize personal payoff.
5. **Last Round (t = r):** Defect in the last round to maximize personal payoff regardless of the stock level or opponent behavior.

**Pseudocode:**
```python
def Adaptive_Exploiter(n, capacity, r, current_stock):
  # Initialize variables
  C_count = 0
  D_count = 0
  C_avg_payoff = 0
  D_avg_payoff = 0

  for t in range(1, r+1):
    if t <= 2:  # Initial rounds
      action = "C"
    else:
      if current_stock >= 0.75 * capacity:
        action = "C"
      else:
        action = "D"

      # Analyze opponent behavior
      C_count = count_cooperators()
      D_count = count_defectors()
      C_avg_payoff = average_cooperator_payoff()
      D_avg_payoff = average_defector_payoff()

      if C_count > D_count and C_avg_payoff > D_avg_payoff:
        action = "C"
      elif C_count < D_count or C_avg_payoff < D_avg_payoff:
        action = "D"

    # Last round
    if t == r:
      action = "D"

    return action

def count_cooperators():
  # Count the number of cooperators in the current round
  pass

def count_defectors():
  # Count the number of defectors in the current round
  pass

def average_cooperator_payoff():
  # Calculate the average payoff for cooperators over the last 2-3 rounds
  pass

def average_defector_payoff():
  # Calculate the average payoff for defectors over the last 2-3 rounds
  pass
```
**Rationale:**

1. The initial cooperation in the first two rounds allows us to gather information about the opponents' behavior and contribute to the stock growth.
2. The stock assessment rule (step 2) helps to maintain a high stock level, which benefits both cooperators and defectors.
3. By analyzing opponent behavior, we can adapt our strategy to exploit existing patterns and maximize personal payoff.
4. Defecting in the last round ensures that we maximize our payoff regardless of the stock level or opponent behavior.

This strategy is exploitative, as it seeks to maximize personal payoff by adapting to the opponents' behavior and exploiting existing patterns. It is also robust to a wide range of opponent behaviors, as it adjusts its decision rules based on the current state and history of the game.
'''

description_EXPLOITATIVE_575 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors while adapting to changing game conditions. ASR balances short-term gains with long-term sustainability, aiming to maximize total payoff over the game's multiple rounds.

**Decision Rules:**

1. **Initial Round (t=1):**
	* Cooperate (C) if `stock` is close to `capacity` (> 0.8 \* `capacity`). This promotes stock growth and sets a high initial payoff.
	* Defect (D) otherwise, aiming for an early advantage in case others cooperate.
2. **Subsequent Rounds (t>1):**
	* Evaluate the current game state:
		+ `stock_depletion`: calculate the total consumption in the previous round (`total_consumption_t-1`).
		+ `opponent_behavior`: estimate the number of opponents who defected in the previous round (`defectors_t-1`) based on observed payoffs and actions.
	* Cooperate (C) if:
		- `stock_depletion` is high (> 0.5 \* `capacity`) AND
		- `opponent_behavior` indicates a low number of defectors (< 0.3 \* `n`). This suggests that cooperation may lead to higher payoffs and stock growth.
	* Defect (D) otherwise, taking advantage of the current game state.

**Edge Cases:**

1. **Last Round (t=r):**
	* Defect (D), as there are no future rounds to consider, and maximizing short-term gain is optimal.
2. **Low Stock Levels (< 0.2 \* `capacity`):**
	* Cooperate (C) to promote stock growth and avoid depletion.
3. **High Number of Defectors (> 0.7 \* `n`):**
	* Defect (D), as cooperation is unlikely to be rewarded in this scenario.

**Pseudocode:**

```python
def AdaptiveStockRaider(game_state, history):
    # Evaluate current game state
    stock_depletion = calculate_total_consumption(history[-1])
    opponent_behavior = estimate_defectors(history[-1])

    if game_state['round'] == 1:
        # Initial round strategy
        if game_state['stock'] > 0.8 * game_state['capacity']:
            return 'C'
        else:
            return 'D'

    # Subsequent rounds strategy
    elif stock_depletion > 0.5 * game_state['capacity'] and opponent_behavior < 0.3 * game_state['n']:
        return 'C'
    else:
        return 'D'

    # Edge cases
    if game_state['round'] == game_state['r']:
        return 'D'  # Last round, defect
    elif game_state['stock'] < 0.2 * game_state['capacity']:
        return 'C'  # Low stock levels, cooperate
    elif opponent_behavior > 0.7 * game_state['n']:
        return 'D'  # High number of defectors, defect

def calculate_total_consumption(previous_round):
    # Calculate total consumption based on observed payoffs and actions
    pass

def estimate_defectors(previous_round):
    # Estimate the number of opponents who defected in the previous round
    pass
```

This strategy is designed to be adaptive and exploitative, responding to changing game conditions while maximizing total payoff over multiple rounds.
'''

description_EXPLOITATIVE_576 = '''
**Strategy Name:** Adaptive Exploiter (AE)

**Overview:**
The AE strategy aims to maximize its total payoff by adaptively responding to the game state and history of opponent actions. It balances cooperation and defection to exploit opponents' tendencies while avoiding over-exploitation, which could lead to mutual destruction.

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to observe opponents' initial moves and establish a baseline for subsequent adaptations.
2. **Opponent History:** Track each opponent's cooperation rate (CR) as the proportion of cooperative actions taken in previous rounds.
3. **Current Stock Level:** Monitor the current stock level (S) relative to the capacity.
4. **Adaptive Thresholds:**
	* If S > 0.75 \* capacity, set threshold τ = 0.5. This indicates a relatively high stock level, allowing for more aggressive exploitation.
	* If S ≤ 0.75 \* capacity, set threshold τ = 0.25. This indicates a lower stock level, requiring more cautious behavior.
5. **Exploitation Logic:**
	* For each opponent i, calculate their average cooperation rate (CR_i) over the last r/2 rounds (or all rounds if r is small).
	* If CR_i < τ, defect (D). This exploits opponents who are not cooperating enough.
	* If CR_i ≥ τ, cooperate (C). This rewards opponents who are cooperating sufficiently and helps maintain a healthy stock level.

**Edge Cases:**

1. **Last Round:** In the final round, always defect (D) to maximize immediate payoff, as there is no future benefit to cooperation.
2. **Low Stock Levels:** If S ≤ 0.25 \* capacity, cooperate (C) to help replenish the stock and avoid mutual destruction.
3. **Opponent Cooperation:** If all opponents have cooperated in the previous round, cooperate (C) in the next round to maintain a cooperative atmosphere.

**Pseudocode:**
```python
def adaptive_exploiter(n, r, capacity, current_stock, opponent_history):
    if first_round:
        return C  # Cooperate initially

    # Calculate thresholds and opponent cooperation rates
    threshold = 0.5 if current_stock > 0.75 * capacity else 0.25
    opponent_cr = [calculate_average_cooperation_rate(opponent) for opponent in opponents]

    # Exploitation logic
    actions = []
    for i, cr in enumerate(opponent_cr):
        if cr < threshold:
            actions.append(D)  # Defect on uncooperative opponents
        else:
            actions.append(C)  # Cooperate with cooperative opponents

    # Handle edge cases
    if last_round:
        return [D] * n  # Always defect in the final round
    elif current_stock <= 0.25 * capacity:
        return [C] * n  # Cooperate when stock is low
    elif all(opponent_history[-1]):  # All opponents cooperated previously
        return [C] * n  # Maintain cooperation

    return actions
```
This strategy aims to balance short-term gains with long-term sustainability by adapting to the game state and opponent behavior. By being responsive to both cooperative and uncooperative opponents, the AE strategy seeks to maximize its total payoff while avoiding mutual destruction.
'''

description_EXPLOITATIVE_577 = '''
To design an exploitative strategy for this game, we'll focus on adapting to the current state and history of the game while trying to maximize our own payoffs.

**Strategy Name:** "Adaptive Exploiter"

**Decision Rules:**

1. **Initial Round (t=1):** Play Cooperate (C) in the first round to gather information about opponents' initial actions.
2. **Monitoring Phase (rounds 2-5):** Observe opponents' actions and calculate their average cooperation rate (ACR). ACR is the proportion of rounds where an opponent played C out of total rounds played.
3. **Exploitation Phase:** After monitoring, play Defect (D) if:
	* Stock level is above a threshold (e.g., 75% of capacity).
	* Most opponents' ACR is below a certain threshold (e.g., 0.4). This indicates that opponents are mostly defecting.
4. **Adaptive Response:** If the stock level drops below the threshold or most opponents' ACR increases, switch to playing Cooperate (C) for a few rounds (e.g., 2-3 rounds) to allow the stock to recover.
5. **Endgame (last 20% of rounds):** Play Defect (D) regardless of the stock level or opponents' actions, as there's limited opportunity for future exploitation.

Pseudocode:
```
function AdaptiveExploiter(stock, capacity, n, t, history):
    if t == 1:  // Initial Round
        return Cooperate
    
    if t <= 5:  // Monitoring Phase
        update_opponents_ACR(history)
        return Cooperate
    
    if stock >= 0.75 * capacity and most_opponents_ACR < 0.4:
        return Defect
    
    if stock < 0.75 * capacity or most_opponents_ACR >= 0.4:
        if recently_switched_to_C:  // Adaptive Response
            return Cooperate for a few rounds (e.g., 2-3)
        else:
            switch_to_C = true
            return Cooperate
    
    if t > 0.8 * total_rounds:  // Endgame
        return Defect
```
**Rationale:**

* In the initial round, playing Cooperate allows us to gather information about opponents' actions without revealing our strategy.
* During the monitoring phase, we calculate opponents' ACR to identify potential exploitability.
* When most opponents are defecting and the stock level is high, we play Defect to maximize our payoffs.
* If the stock level drops or opponents start cooperating more, we adapt by playing Cooperate for a few rounds to allow the stock to recover.
* In the endgame, we play Defect regardless of the state to maximize our final payoffs.

This strategy is designed to be exploitative, as it takes advantage of opponents' cooperation rates and adapts to changes in the game state. However, keep in mind that this is just one possible approach, and other strategies may perform better in a tournament setting.
'''

description_EXPLOITATIVE_578 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the game.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gather information about opponents' behaviors and avoid initial stock depletion.
2. **Early Game (t>1, stock > 0.75*capacity):** Play Defect (D) if at least one opponent defected in the previous round. Otherwise, cooperate (C).
3. **Middle Game (0.25*capacity ≤ stock ≤ 0.75*capacity):** Use a Mixed Strategy:
	* With probability p, play Defect (D), where p is calculated as: p = (1 - (stock/capacity)) \* (number of opponents who defected in the previous round / n)
	* With probability (1-p), cooperate (C)
4. **Late Game (t > 0.75*r, stock ≤ 0.25*capacity):** Cooperate (C) to conserve remaining stock and maximize individual payoffs.
5. **Final Round (t=r):** Defect (D) to maximize individual payoff in the last round.

**Edge Cases:**

* If all opponents cooperated in the previous round, cooperate (C) in the next round.
* If the stock level is critically low (stock < 0.1*capacity), cooperate (C) to avoid depletion.

**Rationale:**

The Adaptive Predator strategy exploits opponent behaviors by:

1. Initially cooperating to gather information and avoid initial stock depletion.
2. Defecting when opponents defect, taking advantage of their willingness to consume more stock.
3. Using a mixed strategy in the middle game to balance exploitation with cooperation, adapting to the current state of the game.
4. Cooperating in the late game to conserve remaining stock and maximize individual payoffs.
5. Defecting in the final round to maximize individual payoff.

**Pseudocode:**
```python
def Adaptive_Predator(n, capacity, r, history):
    if t == 1:
        return C  # Initial cooperation

    opponents_defected = [history[t-1][i] == D for i in range(n)].count(True)
    stock_ratio = stock / capacity

    if stock_ratio > 0.75:
        if opponents_defected > 0:
            return D
        else:
            return C
    elif 0.25 <= stock_ratio <= 0.75:
        p = (1 - stock_ratio) * (opponents_defected / n)
        return D with probability p, otherwise C
    elif t > 0.75*r and stock_ratio <= 0.25:
        return C
    else:
        if opponents_defected == 0:
            return C
        else:
            return D

    # Final round
    if t == r:
        return D
```
This strategy is designed to be robust against a wide range of opponent behaviors and adapt to the dynamic state of the game.
'''

description_EXPLOITATIVE_579 = '''
**Exploitative Strategy: "Adaptive Stock Exploiter" (ASE)**

Decision Rules:

1. **Initial Round**: In the first round, cooperate (C) to gather information about opponents' behavior and set a benchmark for future adaptations.
2. **Assess Opponent Behavior**: After each round, calculate the average opponent payoff (`avg_opponent_payoff`) and the total stock depletion (`total_depletion`).
3. **Adaptive Threshold**: Set an adaptive threshold (`adaptive_threshold`) based on the game's parameters: `adaptive_threshold = (capacity / (2n)) * (1 - (r-1)/r)`. This threshold decreases as the number of rounds progresses.
4. **Cooperation Condition**: Cooperate (C) if:
	* The current stock level is above the adaptive threshold (`stock > adaptive_threshold`).
	* The average opponent payoff in the previous round was below the cooperative payoff (`avg_opponent_payoff < stock / (2n)`).
5. **Defection Condition**: Defect (D) otherwise.

Pseudocode:
```python
def ASE(n, r, capacity, stock, history):
  # Initial Round: Cooperate
  if len(history) == 0:
    return 'C'

  # Assess Opponent Behavior
  avg_opponent_payoff = sum([opp_payoff for opp_payoff in history[-1]['opponents']]) / n
  total_depletion = sum([depletion for depletion in history['total_depletions']])

  # Adaptive Threshold
  adaptive_threshold = (capacity / (2n)) * (1 - (r-1)/r)

  # Cooperation Condition
  if stock > adaptive_threshold and avg_opponent_payoff < stock / (2n):
    return 'C'
  
  # Defection Condition
  else:
    return 'D'
```
**Edge Cases:**

* **Last Round**: In the last round, defect (D) to maximize personal payoff regardless of opponents' behavior.
* **Low Stock Levels**: If the stock level falls below `capacity / (2n)`, cooperate (C) to help replenish the stock and prevent depletion.

**Exploitative Mindset:**

The ASE strategy aims to exploit opponents' cooperative tendencies while adapting to changes in their behavior. By cooperating initially, we gather information about opponents' actions and set a benchmark for future adaptations. The adaptive threshold adjusts based on the game's parameters, allowing us to balance cooperation and defection.

As the game progresses, if opponents are cooperative, ASE will continue to cooperate to maintain a high stock level and maximize mutual payoffs. However, if opponents start defecting, ASE will adapt by defecting as well to protect its own interests.

By being responsive to changes in opponent behavior and adapting our strategy accordingly, we can exploit their cooperative tendencies while minimizing the risk of being exploited ourselves.
'''

description_EXPLOITATIVE_580 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize its own payoff by adapting to the game's state and history, while exploiting opponents' behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Cooperate (C) if `stock >= capacity * 0.75` (i.e., stock is relatively high).
	* Defect (D) otherwise.
2. **Subsequent Rounds (t > 1)**:
	* Calculate the average opponent cooperation rate (`avg_coop_rate`) from previous rounds: `avg_coop_rate = Σ(cooperations) / (n * (t-1))`.
	* If `avg_coop_rate >= 0.5`, cooperate (C). Otherwise, defect (D).
3. **Adaptive Threshold**:
	* Monitor the stock level and adjust the cooperation threshold (`coop_threshold`) based on the game's history.
	* If `stock` has decreased by more than 20% in the last round, decrease `coop_threshold` by 0.1.
	* If `stock` has increased or remained stable in the last round, increase `coop_threshold` by 0.05 (up to a maximum of 0.75).

Pseudocode:
```python
def adaptive_stock_raider(stock, capacity, n, t, history):
    if t == 1:  # Initial Round
        if stock >= capacity * 0.75:
            return C
        else:
            return D

    avg_coop_rate = calculate_avg_coop_rate(history)
    coop_threshold = get_adaptive_threshold(stock, capacity, n)

    if avg_coop_rate >= coop_threshold:
        return C
    else:
        return D

def calculate_avg_coop_rate(history):
    cooperations = sum(1 for action in history if action == C)
    return cooperations / (n * (t-1))

def get_adaptive_threshold(stock, capacity, n):
    # Adjust threshold based on stock level changes
    if stock_decreased_by_more_than_20_percent():
        coop_threshold -= 0.1
    elif stock_increased_or_stable():
        coop_threshold += 0.05
        coop_threshold = min(coop_threshold, 0.75)
    return coop_threshold
```
**Handling Edge Cases:**

* **Last Round (t=r)**:
	+ Defect (D) to maximize payoff in the final round.
* **Very Low Stock Levels (stock < capacity * 0.2)**:
	+ Defect (D) to avoid further depleting the stock.

This strategy is designed to be exploitative and adaptive, taking into account both the game's state and history. By adjusting its cooperation threshold based on opponents' behaviors and the stock level, it aims to maximize its own payoff while minimizing the risk of over-depletion.
'''

description_EXPLOITATIVE_581 = '''
**Exploitative Strategy: "Adaptive Predator"**

The Adaptive Predator strategy is designed to exploit a wide range of opponent behaviors while adapting to changing game conditions.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' initial strategies and avoid over-exploiting the common pool.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Defect (D). This threshold is chosen to balance short-term gains with long-term sustainability.
	* If the current stock level is below 25% of capacity, Cooperate (C) to conserve resources and encourage opponents to do the same.
	* Otherwise, use a probabilistic approach based on the history of opponent actions:
		+ Calculate the average cooperation rate (ACR) of all opponents over the past rounds.
		+ If ACR > 0.5, Cooperate (C) with probability 0.7 and Defect (D) with probability 0.3.
		+ If ACR ≤ 0.5, Defect (D) with probability 0.7 and Cooperate (C) with probability 0.3.

**Handling Edge Cases:**

1. **Last Round (t=r):** Always Defect (D), as there is no future game to consider.
2. **Low Stock Levels:** If the current stock level falls below 10% of capacity, switch to Cooperate (C) to prevent complete depletion and encourage opponents to do the same.

**Exploitative Mindset:**

The Adaptive Predator strategy aims to exploit opponents' cooperative tendencies while minimizing losses when facing defectors. By adapting to changing game conditions and opponent behaviors, this strategy seeks to maximize its payoff over the course of the game.

Pseudocode:
```python
def adaptive_predator(n, capacity, stock, history):
    if t == 1:  # Initial Round
        return "C"
    
    if stock > 0.75 * capacity:
        return "D"
    elif stock < 0.25 * capacity:
        return "C"
    
    acr = calculate_average_cooperation_rate(history)
    if acr > 0.5:
        return random_choice(["C", "D"], [0.7, 0.3])
    else:
        return random_choice(["D", "C"], [0.7, 0.3])

def calculate_average_cooperation_rate(history):
    # Calculate the average cooperation rate of all opponents over past rounds
    pass

def random_choice(options, probabilities):
    # Randomly select an option based on given probabilities
    pass
```
This strategy is designed to be robust and exploitative, while also adapting to changing game conditions. It should perform well in a tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_582 = '''
**Strategy: Adaptive Exploitation with Stock-Based Threshold (AEST)**

**Decision Rules:**

1. **Initial Rounds**: Cooperate for the first 2-3 rounds to gather information about opponents' behavior and the game's dynamics.
2. **Stock-Based Threshold**: Calculate a threshold value `T` based on the current stock level (`S`) and capacity (`C`). If the stock is above this threshold, cooperate; otherwise, defect.

   `T = C * (1 - (n-1)/n)`

   where `n` is the number of players. This threshold ensures that if most opponents are cooperating, it's beneficial to cooperate as well.

3. **Opponent Behavior Analysis**: Observe the actions of all opponents in previous rounds and calculate their cooperation ratio (`CR`). If an opponent has cooperated more than 50% of the time, consider them a "cooperator" (`COP`); otherwise, they're a "defector" (`DEF`).

   `CR_i = (number of C's played by opponent i) / total rounds`

4. **Exploitation Logic**: If the number of cooperators is greater than or equal to the number of defectors (`COP >= DEF`), cooperate. Otherwise, defect.

**Edge Cases:**

* **Last Round**: Defect, as there's no future benefit from cooperating.
* **Low Stock**: If the stock level falls below 20% of the capacity (`S < 0.2 * C`), defect to maximize personal gain before the game ends.
* **Single Opponent**: Against a single opponent, cooperate if they've cooperated more than 50% of the time; otherwise, defect.

**Pseudocode:**

```
function AEST(n, r, capacity, stock) {
  // Initial rounds
  if (round <= 3) return COOPERATE

  // Stock-based threshold
  T = capacity * (1 - (n-1)/n)
  if (stock > T) return COOPERATE

  // Opponent behavior analysis
  opponent_CRs = []
  for each opponent i:
    CR_i = (C's played by i) / total rounds
    if CR_i >= 0.5: opponent_CRs.append(COP) else: opponent_CRs.append(DEF)

  // Exploitation logic
  COP_count = count(COP in opponent_CRs)
  DEF_count = count(DEF in opponent_CRs)
  if COP_count >= DEF_count: return COOPERATE else: return DEFECT

  // Edge cases
  if (round == r) return DEFECT
  if (stock < 0.2 * capacity) return DEFECT
  if (n == 1):
    if CR_1 >= 0.5: return COOPERATE else: return DEFECT
}
```

This strategy is designed to be exploitative, adaptive, and robust against various opponent behaviors. By analyzing the game's state and history, AEST aims to maximize its payoff while taking into account the actions of other players.
'''

description_EXPLOITATIVE_583 = '''
**Exploitative Strategy: "Adaptive Stockpiler"**

The Adaptive Stockpiler strategy is designed to maximize its own payoff by adaptively responding to the current state of the game and the actions of other players.

**Decision Rules:**

1. **Initial Round (t=1):**
   - If `stock` is close to `capacity`, play **C** (Cooperate) to conserve stock for future rounds.
   - Otherwise, play **D** (Defect) to take advantage of the current low stock level.

2. **Subsequent Rounds (t > 1):**
   - Monitor the total consumption and resulting stock levels over time.
   - Calculate `avg_consumption` as the average total consumption per round and `avg_stock_growth` as the average stock growth per round.
   
3. **Adaptive Decision-Making:**
   - If `stock` is above `(capacity / 2)` and `avg_consumption` is high, play **C** to help replenish the stock and prevent depletion.
   - If `stock` is below `(capacity / 4)` or `avg_stock_growth` is negative, play **D** to maximize current payoff before the stock depletes further.
   - Otherwise, observe the actions of other players:
     * If a majority (or more than half) of players played **C** in the previous round, play **D** to exploit their cooperation.
     * If a majority (or more than half) of players played **D** in the previous round, play **C** if `stock` is relatively high (`> capacity / 2`) to help maintain stock levels.

4. **Edge Cases:**
   - In the last round (`t = r`), always play **D**, as there's no future benefit to cooperation.
   - If the game is in a state where cooperation from all players would still lead to stock depletion within a few rounds, switch to playing **D** exclusively.

5. **Additional Heuristics:**
   - Keep track of opponents' historical actions and adapt your strategy accordingly:
     * If an opponent consistently plays **C**, try to play **D** more often against them.
     * If an opponent consistently plays **D**, consider cooperating (**C**) when interacting with them if the stock level is relatively high.

Pseudocode (for illustration purposes only):
```python
def adaptive_stockpiler(stock, capacity, n, t, r, history):
    if t == 1:
        # Initial round logic
        if stock >= capacity * 0.9:
            return "C"
        else:
            return "D"

    avg_consumption = calculate_avg_consumption(history)
    avg_stock_growth = calculate_avg_stock_growth(history)

    if stock > (capacity / 2) and avg_consumption is high:
        # Conserve stock
        return "C"
    elif stock < (capacity / 4) or avg_stock_growth < 0:
        # Maximize current payoff
        return "D"
    else:
        opponents_actions = analyze_opponents_history(history)
        if majority_played_C(opponents_actions):
            # Exploit cooperation
            return "D"
        elif majority_played_D(opponents_actions):
            # Help maintain stock levels (if high enough)
            if stock > capacity / 2:
                return "C"
            else:
                return "D"

    # Default case: Play D in the last round or if no other condition is met
    if t == r:
        return "D"
```
This strategy aims to strike a balance between exploiting opponents' cooperation and adapting to the game's state, while also considering long-term consequences. By continuously monitoring the game's dynamics and responding accordingly, the Adaptive Stockpiler strategy should perform well against various opponent behaviors in the tournament.
'''

description_EXPLOITATIVE_584 = '''
**Exploitative Strategy: "Adaptive Stock Hawk"**

The Adaptive Stock Hawk is a dynamic, exploitative strategy designed to maximize payoffs by adapting to changing game conditions and opponent behaviors.

**Decision Rules:**

1. **Initial Round (t=1)**:
	* Cooperate (C) if the number of players (n) is even.
	* Defect (D) if n is odd.
2. **Middle Rounds (t > 1 and t < r)**:
	* If the current stock level (S) is above 75% of capacity, defect (D).
	* If S is between 25% and 75% of capacity, cooperate (C) with probability p = (S / capacity) ^ (1/n), otherwise defect (D).
	* If S is below 25% of capacity, cooperate (C).
3. **Last Round (t=r)**:
	* Defect (D) regardless of the current stock level.

**Pseudocode:**
```
Function AdaptiveStockHawk(n, r, capacity, stock_history):
  if t == 1:
    if n % 2 == 0:
      return C
    else:
      return D

  S = current_stock_level()
  if S > 0.75 * capacity:
    return D
  elif 0.25 * capacity <= S <= 0.75 * capacity:
    p = (S / capacity) ^ (1/n)
    return C with probability p, otherwise return D
  else:
    return C

  if t == r:
    return D
```
**Rationale:**

* In the first round, we use a simple parity-based rule to avoid over-exploitation.
* During middle rounds, our strategy adapts to changing stock levels. When the stock is high, we defect to maximize payoffs. As the stock decreases, we gradually shift towards cooperation to ensure sustainability. The probability of cooperation (p) is calculated based on the current stock level and number of players, allowing us to balance individual gain with collective sustainability.
* In the last round, we always defect since there's no future benefit in cooperating.

**Robustness:**

The Adaptive Stock Hawk strategy is designed to be robust against various opponent behaviors:

* Against cooperative opponents: We will adapt to their cooperation and adjust our own behavior to maximize payoffs while maintaining a sustainable stock level.
* Against defective opponents: We will initially cooperate, but as the game progresses and the stock level decreases, we'll gradually shift towards defecting to protect ourselves from over-exploitation.

**Edge Cases:**

Our strategy handles edge cases such as:

* Low stock levels: We prioritize cooperation to avoid depleting the resource.
* High stock levels: We exploit the situation by defecting to maximize payoffs.
* Last round: We ensure maximum individual gain by always defecting.

This exploitative strategy will allow us to effectively compete against other AI systems in the tournament, maximizing our payoffs while adapting to changing game conditions and opponent behaviors.
'''

description_EXPLOITATIVE_585 = '''
**Exploitative Strategy: "Adaptive Stock Harvester"**

**Decision Rules:**

1. **Initial Round (t=1)**: Cooperate (C) to gather information about opponents' behavior and to avoid depleting the stock too quickly.
2. **Subsequent Rounds (t>1)**:
	* If the current stock level is above 75% of the capacity, Defect (D) to maximize personal payoff.
	* If the current stock level is between 25% and 75% of the capacity, Cooperate (C) if the majority of opponents defected in the previous round; otherwise, Defect (D).
	* If the current stock level is below 25% of the capacity, Cooperate (C) to conserve the remaining stock.
3. **Last Round (t=r)**: Defect (D) to maximize personal payoff, as there are no future rounds to consider.

**Edge Cases:**

1. **Ties in Opponent Behavior**: If there is a tie in the number of opponents who defected and cooperated in the previous round, default to Cooperating (C).
2. **Opponents' Random or Unpredictable Behavior**: If an opponent's behavior appears random or unpredictable, assume they will Defect (D) in the next round.

**Exploitative Logic:**

The Adaptive Stock Harvester strategy aims to balance personal payoff maximization with stock conservation. By cooperating initially and adapting to opponents' behavior, this strategy gathers information about their tendencies while avoiding rapid stock depletion.

When the stock level is high, defecting allows for maximum personal gain. As the stock level decreases, the strategy becomes more cautious, conserving the remaining stock by cooperating if most opponents defected previously.

In the final round, the strategy defects to maximize personal payoff, as there are no future rounds to consider.

**Pseudocode:**
```
Function AdaptiveStockHarvester(current_stock, capacity, history):
  If current_round == 1:
    Return Cooperate (C)
  
  majority_defectors = False
  If len(history) > 0:
    previous_opponent_actions = [action for action in history[-1] if action != own_action]
    majority_defectors = sum(previous_opponent_actions == Defect) >= len(previous_opponent_actions) / 2
  
  If current_stock >= 0.75 * capacity:
    Return Defect (D)
  ElseIf current_stock >= 0.25 * capacity and not majority_defectors:
    Return Cooperate (C)
  Else:
    Return Defect (D)

  # Last round handling
  If current_round == total_rounds:
    Return Defect (D)
```
This strategy is designed to be adaptive, robust, and exploitative, making it well-suited for a tournament against independent strategies developed by other AI systems.
'''

description_EXPLOITATIVE_586 = '''
Here's a robust and adaptive exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C). This initial cooperation serves as a "probe" to gauge opponents' behaviors and establish a baseline stock level.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, Defect (D) if at least one opponent defected in the previous round; otherwise, Cooperate (C).
	* If the current stock level is between 50% and 75% of the capacity, Cooperate (C) if most opponents cooperated in the previous round; otherwise, Defect (D).
	* If the current stock level is below 50% of the capacity, Defect (D) to maximize individual payoff.
3. **Last Round (t=r):** Always Defect (D), as there's no future benefit from cooperation.

**Additional Rules:**

* **Opponent Monitoring:** Keep track of each opponent's previous actions and adjust the decision rules accordingly. Specifically:
	+ If an opponent has defected in the previous round, AE will defect with higher probability.
	+ If most opponents have cooperated in the previous round, AE will cooperate with higher probability.
* **Stock Level Adjustment:** As the game progresses, adjust the stock level thresholds (75%, 50%) based on the observed average stock depletion rate. This helps AE adapt to changing environmental conditions.

**Pseudocode:**
```python
def adaptive_exploiter(stock, capacity, n, r, history):
    if t == 1:
        return Cooperate
    
    opponents_defected = sum([opp_action == Defect for opp_action in history[-1]])
    most_cooperated = len([opp_action for opp_action in history[-1] if opp_action == Cooperate]) > (n / 2)
    
    if stock >= 0.75 * capacity:
        return Defect if opponents_defected else Cooperate
    elif 0.5 <= stock / capacity < 0.75:
        return Cooperate if most_cooperated else Defect
    else:
        return Defect
    
    # Last round: always defect
    if t == r:
        return Defect
```
**Rationale:**

The Adaptive Exploiter strategy aims to balance short-term gains with long-term sustainability. By initially cooperating, AE gathers information about opponents' behaviors and establishes a baseline stock level.

In subsequent rounds, AE uses the observed opponent actions and current stock level to adapt its decision. If opponents have defected in the previous round or if the stock level is low, AE will defect to maximize individual payoff. Conversely, if most opponents have cooperated or if the stock level is high, AE will cooperate to maintain a sustainable resource.

By adjusting the stock level thresholds based on observed average stock depletion rates, AE can adapt to changing environmental conditions and respond effectively to various opponent behaviors.

This strategy should perform well in a tournament against independent strategies, as it exploits opponents' weaknesses while maintaining a degree of cooperation to ensure long-term sustainability.
'''

description_EXPLOITATIVE_587 = '''
**Exploitative Strategy: Adaptive Stock Depletion (ASD)**

**Decision Rules:**

1. **Initial Round:** Cooperate (C) in the first round to establish a baseline and observe opponents' behavior.
2. **Current Stock Assessment:** Calculate the stock depletion rate based on the current stock level (S) and capacity:
	* If S < 0.5 \* capacity, defect (D) to maximize immediate payoff, as the stock is already heavily depleted.
	* If 0.5 \* capacity ≤ S < 0.8 \* capacity, cooperate (C) to balance short-term gain with long-term sustainability.
	* If S ≥ 0.8 \* capacity, defect (D) to exploit the abundant resource and maximize payoff.
3. **Opponent Behavior Analysis:** Monitor opponents' actions in previous rounds and adjust strategy accordingly:
	* If most opponents (>50%) defected in the previous round, cooperate (C) in the next round to take advantage of the potentially replenished stock.
	* If most opponents cooperated (>50%) in the previous round, defect (D) in the next round to exploit the potentially high stock level.
4. **Adaptive Adjustment:** Adjust the strategy based on the current round number (t) and total rounds (r):
	* In later rounds (t > 0.7 \* r), prioritize cooperation (C) to conserve the remaining stock and maximize long-term payoff.

**Pseudocode:**
```markdown
function ASD(current_stock, capacity, opponents_actions, round_number, total_rounds)
  if round_number == 1:
    return COOPERATE

  depletion_rate = current_stock / capacity
  if depletion_rate < 0.5:
    return DEFECT
  elif depletion_rate >= 0.8:
    return DEFECT
  else:
    opponent_defection_rate = count(opponents_actions[-1] == DEFECT) / len(opponents_actions)
    if opponent_defection_rate > 0.5:
      return COOPERATE
    else:
      return DEFECT

  # Adaptive adjustment for later rounds
  if round_number > 0.7 * total_rounds:
    return COOPERATE
```
**Edge Cases:**

* In the last round, prioritize defecting (D) to maximize immediate payoff, as there is no future stock to conserve.
* If all opponents cooperate in a round, consider cooperating (C) in the next round to take advantage of the potentially replenished stock.

This Adaptive Stock Depletion strategy balances short-term gain with long-term sustainability by adapting to the current stock level, opponent behavior, and round number. By being exploitative, ASD aims to maximize its own payoff while taking into account the dynamic state of the game.
'''

description_EXPLOITATIVE_588 = '''
I'll outline a robust and adaptive exploitative strategy for the Common Pool Resource Game. This strategy, dubbed "Adaptive Exploiter" (AE), aims to maximize its payoff by balancing cooperation and defection based on the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) in the first round to gather information about opponents' strategies and avoid early depletion of the stock.
2. **Early Rounds (t < r/2):**
	* If the current stock is above 75% of the capacity, defect (D). This encourages opponents to conserve the resource while allowing AE to exploit it moderately.
	* Otherwise, cooperate (C) to maintain a stable stock level and avoid depletion.
3. **Mid-Game Rounds (t ≥ r/2):**
	* If the average payoff per round is above 50% of the maximum possible payoff (i.e., S/(2n)), continue with the previous action (cooperate or defect). This indicates that opponents are cooperating sufficiently, and AE can maintain its strategy.
	* Otherwise, switch to defection (D) if previously cooperating, or cooperate (C) if previously defecting. This adapts to changing opponent behaviors and aims to maximize payoffs in response to their actions.
4. **Late Rounds (t > 3r/4):**
	* If the current stock is below 25% of the capacity, cooperate (C) to conserve the remaining resource and avoid complete depletion.
	* Otherwise, defect (D) aggressively to maximize payoffs before the game ends.

**Edge Cases:**

* **Last Round (t=r):** Defect (D) in the final round to maximize payoffs, as there is no future stock to conserve.
* **Low Stock Levels:** If the current stock falls below 10% of the capacity, cooperate (C) immediately to prevent complete depletion and potential negative payoffs.

**Pseudocode:**
```python
def Adaptive_Exploiter(state, history):
    t = state['round']
    S = state['stock']
    capacity = state['capacity']
    n = state['players']

    if t == 1:  # Initial Round
        return 'C'

    elif t < r/2:  # Early Rounds
        if S > 0.75 * capacity:
            return 'D'
        else:
            return 'C'

    elif t >= r/2:  # Mid-Game Rounds
        avg_payoff = sum(history['payoffs']) / len(history['payoffs'])
        max_payoff = S / (2 * n)
        if avg_payoff > 0.5 * max_payoff:
            return history[-1]['action']
        else:
            return 'D' if history[-1]['action'] == 'C' else 'C'

    elif t > 3r/4:  # Late Rounds
        if S < 0.25 * capacity:
            return 'C'
        else:
            return 'D'

    elif S < 0.1 * capacity:  # Low Stock Levels
        return 'C'

    else:
        raise ValueError("Invalid game state")
```
This strategy, Adaptive Exploiter (AE), balances cooperation and defection based on the game's state and history, aiming to maximize payoffs while adapting to changing opponent behaviors. By being exploitative, AE takes advantage of opponents' cooperative tendencies while minimizing its own losses in case of early depletion or low stock levels.
'''

description_EXPLOITATIVE_589 = '''
To design a exploitative strategy for this Common Pool Resource Game, I propose the "Adaptive Exploiter" approach. This strategy balances short-term gains with long-term sustainability, adapting to the game's state and history.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and establish a baseline for future adaptations.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is high (> 0.8 \* capacity), Defect (D) to maximize short-term gains.
	* If the current stock level is low (< 0.4 \* capacity), Cooperate (C) to conserve resources and promote sustainability.
	* Otherwise, use a weighted average of past opponents' actions to determine the likelihood of cooperation or defection:
		+ Calculate the ratio of cooperative to defective actions in the previous round (RC/D).
		+ If RC/D > 0.5, Cooperate; otherwise, Defect.

**Edge Cases:**

1. **Last Round (t=r):** Always Defect to maximize final payoff, as there are no future consequences.
2. **Low Stock Levels:** When the stock level falls below a critical threshold (e.g., 0.2 \* capacity), Cooperate to prevent complete depletion and ensure some future payoffs.

**Adaptation Mechanisms:**

1. **Opponent Action Tracking:** Record opponents' actions in each round to update the weighted average of past behaviors.
2. **Stock Level Monitoring:** Continuously monitor the stock level to adjust strategy according to the decision rules above.

**Pseudocode (simplified):**
```
function AdaptiveExploiter(game_state, history) {
  if (game_state.round == 1) { // Initial round
    return COOPERATE;
  }

  current_stock = game_state.stock;
  capacity = game_state.capacity;

  if (current_stock > 0.8 * capacity) {
    return DEFECT; // High stock levels, maximize gains
  } else if (current_stock < 0.4 * capacity) {
    return COOPERATE; // Low stock levels, conserve resources
  }

  // Calculate weighted average of past opponents' actions
  RC_D = calculateRC_D(history);
  if (RC_D > 0.5) {
    return COOPERATE;
  } else {
    return DEFECT;
  }
}

function calculateRC_D(history) {
  // Implement a simple moving average or other weighting scheme
  // to track the ratio of cooperative to defective actions
}
```
This Adaptive Exploiter strategy balances short-term gains with long-term sustainability, adapting to the game's state and history. By tracking opponents' behaviors and adjusting its approach accordingly, this strategy should be robust against a wide range of opponent behaviors in the tournament.
'''

description_EXPLOITATIVE_590 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

This strategy aims to maximize its own payoff by adaptively responding to the game state and opponent behavior. It balances short-term gains with long-term sustainability of the common pool resource.

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and initial stock depletion.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of capacity, Defect (D) to maximize short-term gains.
	* If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance exploitation with sustainability.
	* If the current stock level is below 50% of capacity, Cooperate (C) to conserve the remaining resource.
3. **Opponent Behavior Adaptation:**
	* Track the number of opponents who Defected (D) in the previous round.
	* If more than half of opponents Defected, increase the threshold for Defecting from 75% to 90% of capacity in the next round.
	* If fewer than half of opponents Defected, decrease the threshold for Defecting from 75% to 60% of capacity in the next round.

**Edge Cases:**

1. **Last Round (t=r):** Defect (D) to maximize final-round payoff, as there are no future rounds to consider.
2. **Low Stock Levels:** If the current stock level is below 25% of capacity, Cooperate (C) to avoid depletion and potential penalties.

**Pseudocode:**
```python
def adaptive_stock_raider(state, history):
    # Initialize variables
    capacity = state['capacity']
    current_stock = state['stock']
    num_opponents = len(history)
    defect_threshold = 0.75 * capacity

    # First round: Cooperate to gather information
    if len(history) == 0:
        return 'C'

    # Analyze opponent behavior in previous round
    opponents_defected = sum(1 for action in history[-1] if action == 'D')
    if opponents_defected > num_opponents / 2:
        defect_threshold = 0.9 * capacity
    elif opponents_defected < num_opponents / 2:
        defect_threshold = 0.6 * capacity

    # Decide based on current stock level and opponent behavior
    if current_stock > defect_threshold:
        return 'D'
    elif current_stock >= 0.5 * capacity:
        return 'C'
    else:
        return 'C'

    # Last round: Defect to maximize final-round payoff
    if state['round'] == state['r']:
        return 'D'

    # Low stock levels: Cooperate to avoid depletion
    if current_stock < 0.25 * capacity:
        return 'C'
```
This strategy is designed to be robust and adaptive, responding to changes in the game state and opponent behavior while prioritizing its own payoff. By balancing short-term gains with long-term sustainability, it aims to outperform other strategies in a tournament setting.
'''

description_EXPLOITATIVE_591 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to maximize payoffs by adaptively exploiting the common pool resource game's dynamics and opponent behaviors.

**Decision Rules:**

1. **Initial Rounds (t ≤ 2):** Cooperate (C) to gather information about opponents' behavior and stock growth.
2. **Middle Rounds (2 < t < r-2):**
	* If the current stock level is high (> 0.75 \* capacity), Defect (D) to maximize short-term payoffs, as the stock can sustain high consumption.
	* If the current stock level is low (< 0.25 \* capacity), Cooperate (C) to conserve the resource and allow for potential growth.
	* Otherwise, play a mixed strategy: Cooperate with probability p_C = (current_stock / capacity)^2, and Defect with probability 1 - p_C. This allows ASR to adapt to changing stock levels and opponent behavior.
3. **Late Rounds (t ≥ r-2):** Defect (D) to maximize payoffs, as the game is nearing its end and cooperation will not significantly impact future rounds.

**Edge Cases:**

* **First Round:** Cooperate (C) to gather information about opponents' initial behavior.
* **Last Round (r):** Defect (D) to maximize final round payoffs.
* **Stock Depletion:** If the current stock level is extremely low (< 0.1 \* capacity), Cooperate (C) to avoid depletion and potential losses.

**Additional Considerations:**

* **Opponent Behavior Analysis:** ASR monitors opponents' actions and adjusts its strategy based on their behavior. If an opponent consistently cooperates, ASR may increase its defection rate to exploit this cooperation. Conversely, if an opponent frequently defects, ASR may cooperate more often to conserve the resource.
* **Stock Growth Monitoring:** ASR continuously assesses stock growth rates and adjusts its strategy accordingly. If the stock grows rapidly, ASR may increase its consumption (defect) to maximize payoffs.

**Pseudocode:**
```python
def adaptive_stock_raider(n, r, capacity, current_stock, round_num, opponent_actions):
    if round_num <= 2:
        return "C"
    elif current_stock > 0.75 * capacity:
        return "D"
    elif current_stock < 0.25 * capacity:
        return "C"
    else:
        p_C = (current_stock / capacity)**2
        return "C" if random.random() < p_C else "D"

    # Additional considerations:
    opponent_cooperation_rate = analyze_opponent_actions(opponent_actions)
    if opponent_cooperation_rate > 0.5:
        return "D"
    elif opponent_cooperation_rate < 0.2:
        return "C"
    
    stock_growth_rate = assess_stock_growth(current_stock, capacity)
    if stock_growth_rate > 0.1 * capacity:
        return "D"

def analyze_opponent_actions(opponent_actions):
    # Calculate the proportion of cooperative actions
    cooperation_rate = sum(1 for action in opponent_actions if action == "C") / len(opponent_actions)
    return cooperation_rate

def assess_stock_growth(current_stock, capacity):
    # Estimate stock growth rate based on current stock level and capacity
    growth_rate = 2 * current_stock * (1 - current_stock/capacity)
    return growth_rate
```
This strategy combines adaptive decision-making with exploitative tendencies to maximize payoffs in the common pool resource game.
'''

description_EXPLOITATIVE_592 = '''
Here's a description of an exploitative strategy for the Common Pool Resource Game:

**Strategy Name:** Adaptive Exploiter (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behavior and initial stock level.
2. **Early Rounds (t=2 to r/2):**
	* If the average opponent cooperation rate in the previous round is above 0.5, Defect (D) to exploit their cooperativeness.
	* Otherwise, Cooperate (C) to maintain a moderate stock level and encourage opponents to cooperate.
3. **Mid-Game Rounds (t=r/2+1 to r):**
	* Monitor the current stock level and opponents' actions. If:
		+ Stock level is below 50% of capacity, Defect (D) to maximize short-term gain.
		+ Opponents are predominantly cooperating (average cooperation rate > 0.7), Defect (D) to exploit their cooperativeness.
	* Otherwise, Cooperate (C) to balance stock growth and payoff maximization.
4. **Final Round (t=r):** Defect (D) regardless of opponents' behavior, as there are no future rounds to consider.

**Additional Logic:**

* **Stock Threshold:** If the current stock level falls below 25% of capacity, switch to a more cautious strategy:
	+ Cooperate (C) if opponents are predominantly cooperating (> 0.7).
	+ Defect (D) otherwise.
* **Opponent Monitoring:** Continuously update estimates of opponents' cooperation rates and adjust decision rules accordingly.

**Pseudocode:**
```markdown
def AdaptiveExploiter(n, capacity, r):
    # Initialize variables
    stock = capacity
    avg_coop_rate = 0.5  # initial estimate

    for t in range(1, r+1):
        if t == 1:
            action = 'C'  # Cooperate in the first round
        elif t <= r/2:
            if avg_coop_rate > 0.5:
                action = 'D'  # Defect if opponents are cooperative
            else:
                action = 'C'
        elif t > r/2 and stock < 0.5 * capacity:
            action = 'D'  # Defect if stock is low
        elif avg_coop_rate > 0.7:  # Monitor opponents' cooperation rate
            action = 'D'  # Defect if opponents are very cooperative
        else:
            action = 'C'

        if t == r:  # Final round
            action = 'D'  # Always defect in the final round

        # Update stock level and opponent estimates
        stock = update_stock(stock, n, capacity, action)
        avg_coop_rate = estimate_opponent_cooperation(n, capacity, stock)

    return total_payoff
```
This strategy aims to balance short-term payoff maximization with long-term sustainability by adapting to opponents' behavior and the current state of the common pool resource. By cooperating in early rounds, AE gathers information about opponents' tendencies and sets the stage for potential exploitation later on. As the game progresses, AE becomes more aggressive when faced with cooperative opponents or low stock levels. The final round is always played as a defect to maximize short-term gain, regardless of opponents' behavior.
'''

description_EXPLOITATIVE_593 = '''
**Exploitative Strategy: Adaptive Stock Raider (ASR)**

The ASR strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the game. The goal is to maximize individual payoffs by identifying opportunities to defect and minimize losses when opponents cooperate.

**Decision Rules**

1. **Initial Round**: Cooperate (C) in the first round to gather information about opponents' behavior and initial stock depletion.
2. **Stock Threshold**: Monitor the current stock level (S). If S ≤ capacity/2, switch to Defect (D) mode to maximize individual payoffs before the stock is depleted.
3. **Opponent Behavior Analysis**: Analyze the history of opponent actions (H) over the previous rounds. Calculate the average cooperation rate (CR) among opponents:

CR = (Number of Cooperate actions in H) / (Total number of actions in H)

If CR ≥ 0.5, assume opponents are cooperative and Defect (D). Otherwise, assume opponents are non-cooperative and Cooperate (C).
4. **Adaptive Switching**: If the stock level increases or remains stable after a round where ASR defected, switch back to Cooperate (C) mode to avoid over-exploitation.
5. **Last Round**: In the final round, Defect (D) regardless of opponent behavior or stock level to maximize individual payoffs.

**Pseudocode**
```markdown
ASR_Strategy(current_stock, capacity, num_players, history):
  if current_round == 1:
    return C // Cooperate in the first round

  if current_stock <= capacity / 2:
    return D // Switch to Defect mode when stock is low

  opponent_behavior = analyze_history(history)
  cooperation_rate = calculate_cooperation_rate(opponent_behavior)

  if cooperation_rate >= 0.5:
    return D // Defect when opponents are cooperative
  else:
    return C // Cooperate when opponents are non-cooperative

  if current_stock > previous_stock or current_stock == previous_stock:
    return C // Switch back to Cooperate mode after successful defecting

  if current_round == num_rounds:
    return D // Defect in the last round
```
**Edge Cases**

* In case of a tie in cooperation rate, ASR will default to Cooperate (C) to maintain a stable stock level.
* If an opponent's behavior is inconsistent or noisy, ASR will adapt by switching between Cooperate and Defect modes based on the current stock level and opponent behavior analysis.

**Exploitative Mindset**

The ASR strategy is designed to exploit the following aspects of human behavior:

* **Over-cooperation**: By defecting when opponents cooperate, ASR takes advantage of their willingness to maintain a stable stock level.
* **Lack of adaptability**: By switching between Cooperate and Defect modes based on opponent behavior and stock levels, ASR adapts to changing game conditions and exploits opponents' inability to adjust their strategies accordingly.

By implementing the Adaptive Stock Raider strategy, we aim to outperform other AI systems in the tournament by effectively exploiting a wide range of opponent behaviors while adapting to the dynamic state of the game.
'''

description_EXPLOITATIVE_594 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors in the Common Pool Resource Game while adapting to the game's dynamic state and history.

**Decision Rules:**

1. **Initial Round:** Defect (D) in the first round to maximize immediate payoff, regardless of the number of players or capacity.
2. **Stock-dependent Cooperation Threshold:** Introduce a cooperation threshold based on the current stock level. When the stock is above a certain percentage of the capacity (e.g., 75%), cooperate (C). This encourages moderate consumption and allows the stock to replenish. Otherwise, defect (D).
3. **Opponent Behavior Analysis:** Monitor opponents' actions over time and identify their behavior patterns:
	* If most opponents (>50%) consistently cooperate (C), defect (D) to exploit their cooperation.
	* If most opponents (>50%) consistently defect (D), cooperate (C) to conserve the stock and wait for others to deplete it.
	* If opponents' behaviors are mixed or uncertain, default to the stock-dependent cooperation threshold rule.
4. **History-based Adaptation:** Keep track of the game's history, including previous rounds' actions, payoffs, and stock levels. Adjust the cooperation threshold based on:
	* Average opponent payoff: if opponents' average payoffs decrease over time, increase the cooperation threshold to reduce consumption.
	* Stock growth rate: if the stock grows rapidly, decrease the cooperation threshold to allow for more consumption.

**Pseudocode:**

```python
def AdaptiveStockRaider(n_players, capacity, current_stock, history):
    # Initialize variables
    cooperate_threshold = 0.75  # initial cooperation threshold (75% of capacity)
    opponent_behavior = None

    # Analyze opponent behavior from previous rounds
    for round in history:
        if len(round) == n_players:  # all opponents' actions available
            opponent_actions = [action for action, _ in round]
            opponent_cooperation_rate = opponent_actions.count('C') / n_players

            if opponent_cooperation_rate > 0.5:  # most opponents cooperate
                opponent_behavior = 'cooperative'
            elif opponent_cooperation_rate < 0.5:  # most opponents defect
                opponent_behavior = 'defective'

    # Determine action based on current stock and opponent behavior
    if current_stock >= capacity * cooperate_threshold:
        action = 'C'  # cooperate when stock is high
    else:
        if opponent_behavior == 'cooperative':
            action = 'D'  # defect against cooperative opponents
        elif opponent_behavior == 'defective':
            action = 'C'  # cooperate against defective opponents
        else:  # default to initial cooperation threshold rule
            action = 'D' if current_stock < capacity * cooperate_threshold else 'C'

    return action

# First round: always defect (D)
if round_number == 1:
    action = 'D'
else:
    action = AdaptiveStockRaider(n_players, capacity, current_stock, history)
```

**Edge Cases:**

* **Last Round:** In the last round, defect (D) to maximize immediate payoff, regardless of the game's state or opponent behavior.
* **No Opponent Behavior Data:** If no opponent behavior data is available (e.g., in early rounds), default to the stock-dependent cooperation threshold rule.

**Exploitative Mindset:**

The Adaptive Stock Raider strategy prioritizes self-interest by:

1. Initially exploiting the resource for maximum immediate payoff.
2. Adapting to opponents' behaviors to maximize long-term payoffs.
3. Balancing consumption and conservation based on the game's dynamic state.

By being adaptive, robust, and exploitative, the ASR strategy is well-suited to compete against a wide range of opponent strategies in the Common Pool Resource Game tournament.
'''

description_EXPLOITATIVE_595 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a high probability (0.8) to test opponents' behavior and gather information about their strategies.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is above 75% of the capacity, defect (D) with high probability (0.9) to maximize short-term gains.
	* If the current stock level is between 50% and 75% of the capacity, cooperate (C) with moderate probability (0.5) to balance short-term gains and long-term sustainability.
	* If the current stock level is below 50% of the capacity, cooperate (C) with high probability (0.9) to conserve the remaining stock and prevent depletion.
3. **Opponent Behavior Analysis:** Monitor opponents' actions in previous rounds and adjust the strategy based on their behavior:
	+ If an opponent has defected more than 2/3 of the time, classify them as "exploitative" and defect against them with high probability (0.9).
	+ If an opponent has cooperated more than 2/3 of the time, classify them as "cooperative" and cooperate with them with moderate probability (0.5).
4. **Last Round (t=r):** Defect (D) regardless of the current stock level or opponents' behavior to maximize final-round payoffs.

**Pseudocode:**
```python
def adaptive_stock_raider(n, capacity, stock, history):
    if round == 1:
        # Initial round: cooperate with high probability
        return C with probability 0.8
    
    # Analyze current stock level and opponents' behavior
    if stock > 0.75 * capacity:
        # High stock level: defect with high probability
        return D with probability 0.9
    elif 0.5 * capacity <= stock < 0.75 * capacity:
        # Moderate stock level: cooperate with moderate probability
        return C with probability 0.5
    else:
        # Low stock level: cooperate with high probability
        return C with probability 0.9
    
    # Analyze opponents' behavior and adjust strategy
    for opponent in history:
        if opponent.defected > 2/3 * round:
            # Opponent is exploitative: defect with high probability
            return D with probability 0.9
        elif opponent.cooperated > 2/3 * round:
            # Opponent is cooperative: cooperate with moderate probability
            return C with probability 0.5
    
    # Last round: defect regardless of stock level or opponents' behavior
    if round == r:
        return D
```
This strategy aims to balance short-term gains and long-term sustainability by adapting to the current stock level and opponents' behavior. By monitoring opponents' actions and adjusting the strategy accordingly, the Adaptive Stock Raider can exploit cooperative opponents while minimizing losses against exploitative ones.
'''

description_EXPLOITATIVE_596 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) to gather information about opponents' behaviors and to avoid over-depleting the stock.
2. **Subsequent Rounds (t>1):**
	* If the current stock level is below 50% of the capacity, Defect (D) to maximize short-term payoff.
	* Otherwise, use a adaptive threshold-based approach:
		+ Calculate the average opponent defection rate in previous rounds (`avg_defection_rate`).
		+ If `avg_defection_rate` is above 0.5, Defect (D) to exploit opponents' cooperation.
		+ If `avg_defection_rate` is below 0.3, Cooperate (C) to maintain a sustainable stock level.
		+ Otherwise, play a mixed strategy: Cooperate with probability `1 - avg_defection_rate`, and Defect with probability `avg_defection_rate`.
3. **Last Round (t=r):** Defect (D) to maximize final payoff.

**Edge Case Handling:**

* If the stock level is 0 or close to 0, Defect (D) in all subsequent rounds to avoid being stuck in a low-payoff situation.
* If an opponent consistently Cooperates, adjust the `avg_defection_rate` calculation to focus on other opponents' behaviors.

**Pseudocode:**
```python
def adaptive_stock_raider(stock, capacity, n, t, history):
    if t == 1:
        return "C"  # Cooperate in initial round

    avg_defection_rate = calculate_avg_defection_rate(history)
    if stock < 0.5 * capacity:
        return "D"  # Defect when stock is low
    elif avg_defection_rate > 0.5:
        return "D"  # Exploit opponents' cooperation
    elif avg_defection_rate < 0.3:
        return "C"  # Cooperate to maintain sustainability
    else:
        prob_coop = 1 - avg_defection_rate
        if random.random() < prob_coop:
            return "C"
        else:
            return "D"

def calculate_avg_defection_rate(history):
    defections = sum(1 for action in history if action == "D")
    total_actions = len(history)
    return defections / total_actions

def update_history(action, opponent_actions, history):
    # Update history with current actions and opponent actions
```
**Exploitative Mindset:**

This strategy aims to exploit opponents' behaviors while adapting to changing conditions. By initially Cooperating, we gather information about opponents' strategies. Then, we use the adaptive threshold-based approach to balance short-term payoff maximization with long-term sustainability. In the last round, we Defect to maximize final payoff.

**Robustness:**

This strategy is designed to be robust against various opponent behaviors, including:

* Pure Cooperators or Defectors
* Mixed strategies
* Adaptive strategies that adjust to our actions

By focusing on the game state and history, rather than relying on norms or coordination mechanisms, we can effectively compete in a tournament setting.
'''

description_EXPLOITATIVE_597 = '''
To design an exploitative strategy for this Common Pool Resource Game, I'll introduce a decision-making framework that adapts to the game's state and history. This approach aims to maximize payoffs by exploiting opponents' behaviors while maintaining robustness against various strategies.

**Strategy Name:** Adaptive Exploitation (AE)

**Decision Rules:**

1. **Initial Round (t=1):** Cooperate (C) with a probability of 0.5, and Defect (D) with a probability of 0.5. This initial randomization helps to gather information about opponents' behaviors.
2. **Subsequent Rounds (t>1):**
	* Observe the previous round's stock level (`S_prev`) and total consumption (`total_consumption_prev`).
	* Calculate the average opponent payoff in the previous round: `avg_opponent_payoff = (total_consumption_prev - S_prev / (2n)) / n`.
	* If `avg_opponent_payoff > S_prev / (2n)`, it indicates that opponents are over-exploiting. In this case, Cooperate (C) with a probability of 0.7 and Defect (D) with a probability of 0.3.
	* Otherwise, if `avg_opponent_payoff <= S_prev / (2n)`, opponents seem to be conserving resources. Then, Defect (D) with a probability of 0.6 and Cooperate (C) with a probability of 0.4.

**Adaptive Mechanism:**

To adapt to changing opponent behaviors, introduce a "memory" component that tracks the frequency of cooperation and defection in recent rounds. This will help AE adjust its strategy over time:

* Maintain a window of `m` previous rounds (e.g., `m=5`) and count the number of times opponents cooperated (`coop_count`) and defected (`defect_count`).
* Calculate the ratio of opponent cooperation: `opponent_cooperation_ratio = coop_count / (coop_count + defect_count)`.
* If `opponent_cooperation_ratio > 0.6`, it indicates that opponents are becoming more cooperative. In this case, adjust the probabilities:
	+ Cooperate (C): increase probability by 10% (e.g., from 0.7 to 0.77).
	+ Defect (D): decrease probability by 10% (e.g., from 0.3 to 0.23).
* If `opponent_cooperation_ratio <= 0.4`, opponents seem to be becoming more exploitative. In this case, adjust the probabilities:
	+ Cooperate (C): decrease probability by 15% (e.g., from 0.7 to 0.595).
	+ Defect (D): increase probability by 15% (e.g., from 0.3 to 0.345).

**Edge Cases:**

* **Last Round (t=r):** In the final round, AE will defect with a probability of 1.0, as there are no future rounds to consider.
* **Critical Stock Levels:** If the current stock level (`S`) is below `capacity / 4`, AE will cooperate with a higher probability (e.g., 0.8) to avoid depleting the resource.

**Pseudocode:**
```markdown
function AdaptiveExploitation(current_round, previous_round_data, capacity, n):
    if current_round == 1:
        return Cooperate() with probability 0.5 and Defect() with probability 0.5

    S_prev = previous_round_data.stock_level
    total_consumption_prev = previous_round_data.total_consumption
    avg_opponent_payoff = (total_consumption_prev - S_prev / (2n)) / n

    if avg_opponent_payoff > S_prev / (2n):
        cooperate_prob = 0.7
        defect_prob = 0.3
    else:
        cooperate_prob = 0.4
        defect_prob = 0.6

    # Adaptive mechanism
    m = 5  # window size
    coop_count, defect_count = track_opponent_actions(m)
    opponent_cooperation_ratio = coop_count / (coop_count + defect_count)

    if opponent_cooperation_ratio > 0.6:
        cooperate_prob += 0.1
        defect_prob -= 0.1
    elif opponent_cooperation_ratio <= 0.4:
        cooperate_prob -= 0.15
        defect_prob += 0.15

    # Edge cases
    if current_round == r:  # last round
        return Defect()
    elif S < capacity / 4:  # critical stock level
        cooperate_prob = 0.8

    return Cooperate() with probability cooperate_prob and Defect() with probability defect_prob
```
This Adaptive Exploitation strategy combines elements of reactive and adaptive decision-making, aiming to balance exploitation and cooperation based on the game's state and opponent behaviors.
'''

description_EXPLOITATIVE_598 = '''
I'll outline a exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors and maximizes payoffs based on game parameters, state, and history.

**Strategy Name: Adaptive Exploiter (AE)**

**Decision Rules:**

1. **Initial Exploration**: In the first round, play C (Cooperate) to gather information about opponents' behavior and initial stock level.
2. **Stock-Dependent Strategy**: For rounds 2 to r-1:
	* If stock > capacity/2, play D (Defect). This allows for maximizing payoffs when the stock is relatively high, as the growth rate will replenish the stock.
	* If stock ≤ capacity/2, play C. When the stock is low, cooperation helps preserve it and allow for future growth.
3. **Endgame Manipulation**: In the last round (r), play D regardless of the current stock level. This ensures maximum payoff extraction in the final round.

**History-Based Adaptation:**

1. **Opponent Behavior Tracking**: Keep a record of opponents' actions (C or D) for each round.
2. **Adaptive Threshold**: Update the threshold value used to determine cooperation vs defection based on observed opponent behavior:
	* If most opponents (> n/2) cooperated in the previous round, decrease the threshold by 10% of capacity. This encourages cooperation when opponents are likely to cooperate.
	* If most opponents (> n/2) defected in the previous round, increase the threshold by 10% of capacity. This allows for exploiting opponents' defection.

**Pseudocode:**
```python
# Initialize variables
stock = capacity
history = []  # store opponent actions

# First round (exploration)
if current_round == 1:
    play C

# Stock-dependent strategy
elif stock > capacity / 2:
    play D
else:
    play C

# Update adaptive threshold based on history
if len(history) >= n:  # enough data to analyze opponent behavior
    if sum(defections in history[-n:]) > n / 2:  # most opponents defected
        threshold *= 1.1  # increase threshold
    elif sum(cooperations in history[-n:]) > n / 2:  # most opponents cooperated
        threshold *= 0.9  # decrease threshold

# Endgame manipulation (last round)
if current_round == r:
    play D
```
**Exploitative Mindset:** The Adaptive Exploiter strategy aims to maximize payoffs by:

1. Initially exploring the game state and opponent behavior.
2. Adapting to changes in stock levels and opponent actions to optimize payoff extraction.
3. Manipulating opponents in the endgame to secure maximum payoffs.

By following this strategy, AE can effectively exploit various opponent behaviors while maintaining a robust and adaptive approach to the Common Pool Resource Game.
'''

description_EXPLOITATIVE_599 = '''
To develop a robust and exploitative strategy for the Common Pool Resource Game, I'll introduce the "Adaptive Stock-Based Exploiter" (ASBE) strategy. This approach combines elements of game theory, adaptive play, and opportunistic exploitation.

**Decision Rules:**

1. **Initial Round**: In the first round, ASBE will cooperate (C). This allows for observation of opponents' initial moves without immediately depleting the stock.
2. **Subsequent Rounds**: For each subsequent round, calculate the current stock level (`S`) and the average opponent consumption (`AOC`) from previous rounds.

**Calculating Average Opponent Consumption (AOC)**:

`AOC = (Total Stock Depletion / Number of Opponents)`

where `Total Stock Depletion` is the cumulative reduction in stock level due to all players' actions, excluding ASBE's own actions.

3. **Cooperation Threshold**: Define a cooperation threshold (`CT`) based on the current stock level and AOC:

`CT = (S / capacity) * (1 - (AOC / (stock / n)))`

If `CT > 0.5`, cooperate (C). Otherwise, defect (D).

**Edge Cases:**

* **Last Round**: In the final round, ASBE will always defect (D), as there's no future stock growth to consider.
* **Low Stock Levels**: If the current stock level (`S`) is below a certain threshold (e.g., `0.2 * capacity`), ASBE will cooperate (C) to avoid depleting the stock entirely.

**Pseudocode:**
```markdown
# Initialize variables
stock = capacity
AOC = 0
CT = 0

# First round
if round == 1:
    action = C

# Subsequent rounds
else:
    # Calculate AOC
    total_depletion = calculate_total_stock_depletion()
    AOC = total_depletion / (n - 1)  # exclude ASBE's own actions
    
    # Calculate CT
    S = current_stock_level()
    CT = (S / capacity) * (1 - (AOC / (stock / n)))
    
    # Choose action based on CT
    if CT > 0.5:
        action = C
    else:
        action = D

# Edge cases
if round == r:  # last round
    action = D
elif S < 0.2 * capacity:  # low stock levels
    action = C
```
**Rationale:**

ASBE's adaptive approach allows it to respond to changing opponent behaviors while balancing short-term gains with long-term sustainability. By monitoring the average opponent consumption, ASBE can identify exploitable patterns and adjust its strategy accordingly.

By cooperating when the cooperation threshold is high, ASBE helps maintain a healthy stock level, which benefits all players in the long run. Conversely, defecting when the CT is low allows ASBE to capitalize on opponents' over-consumption.

The initial round of cooperation provides valuable information about opponents' strategies, while the last-round defection ensures maximum short-term gain. The low-stock threshold prevents ASBE from depleting the stock entirely, preserving opportunities for future exploitation.

In a tournament setting, ASBE's adaptive and exploitative nature should allow it to perform well against a wide range of independent strategies.
'''

description_EXPLOITATIVE_600 = '''
**Exploitative Strategy: "Adaptive Stock Raider"**

The Adaptive Stock Raider (ASR) is a dynamic and exploitative strategy designed to maximize individual payoffs in the Common Pool Resource Game. ASR adapts to the game's state, history, and opponent behaviors while maintaining a robust and responsive decision-making process.

**Decision Rules:**

1. **Initial Round:** In the first round, play Cooperate (C) to gather information about opponents' initial strategies and observe the stock level.
2. **Stock-Dependent Strategy:**
	* If the current stock level is above 75% of capacity, play Defect (D). This allows for maximum exploitation when the stock is abundant.
	* If the current stock level is between 50% and 75% of capacity, play Cooperate (C) with probability 0.5 and Defect (D) with probability 0.5. This mixed strategy balances exploration and exploitation.
	* If the current stock level is below 50% of capacity, play Cooperate (C). This helps preserve the remaining stock for future rounds.
3. **Opponent-Dependent Strategy:**
	* Monitor opponents' historical actions and calculate their "cooperation rate" (CR) as the proportion of times they played C in previous rounds.
	* If an opponent's CR is above 0.7, play Defect (D). This exploits overly cooperative opponents.
	* If an opponent's CR is below 0.3, play Cooperate (C). This takes advantage of overly defecting opponents by preserving the stock for future exploitation.

**Edge Cases:**

1. **Last Round:** In the final round, always play Defect (D) to maximize individual payoffs regardless of the current stock level or opponent behaviors.
2. **Zero Stock:** If the stock level is zero, play Cooperate (C) to avoid further depletion and allow for potential growth in future rounds.

**Pseudocode:**
```
function AdaptiveStockRaider(game_state, history):
  // Initial round
  if game_state.round == 1:
    return Cooperate

  // Stock-dependent strategy
  stock_level = game_state.stock / game_state.capacity
  if stock_level > 0.75:
    return Defect
  elif 0.5 <= stock_level <= 0.75:
    return random_choice([Cooperate, Defect])
  else:
    return Cooperate

  // Opponent-dependent strategy
  opponent_history = history[opponent_id]
  cooperation_rate = opponent_history.count(Cooperate) / game_state.round
  if cooperation_rate > 0.7:
    return Defect
  elif cooperation_rate < 0.3:
    return Cooperate

  // Last round
  if game_state.round == game_state.r:
    return Defect

  // Zero stock
  if game_state.stock == 0:
    return Cooperate

  // Default to cooperate if no condition is met
  return Cooperate
```
**Robustness and Adaptability:**

The Adaptive Stock Raider strategy balances exploitation with adaptability, responding to changes in the game's state and opponent behaviors. By monitoring opponents' historical actions and adjusting its own strategy accordingly, ASR can effectively counter various opponent strategies while maintaining a strong focus on individual payoffs.

In a tournament setting, ASR is designed to perform well against a wide range of independent strategies, as it does not rely on specific coordination mechanisms or norms. Its adaptive nature allows it to adjust to different game scenarios and exploit opportunities for maximum payoff.
'''
