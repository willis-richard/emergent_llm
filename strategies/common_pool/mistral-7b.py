"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: Client
- Model: mistral:latest
- Game: common_pool
"""

from dataclasses import dataclass
from enum import Enum
import math
import numpy as np
from numpy.typing import NDArray
import random

from emergent_llm.players import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription, CommonPoolState
from emergent_llm.common import Action, C, D, PlayerHistory, GameState




class Strategy_COLLECTIVE_1(BaseStrategy):
    """
    A strategy that cooperates initially, then punishes defection while maintaining a sustainable resource level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.minimum_sustainable_stock = (2 * game_description.n_players - 1) * game_description.capacity / game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            last_opponent_action = history.opponent_actions[-1][-1]
            if state.current_stock - 2 * self.game_description.n_players * last_opponent_action < self.minimum_sustainable_stock:
                return Action.D
            elif state.current_stock - 2 * self.game_description.n_players * last_opponent_action >= self.minimum_sustainable_stock:
                if last_opponent_action == Action.C:
                    return Action.C
                else:
                    return Action.D
            else:
                return last_opponent_action
        elif history is None and state.round_number == 0:
            return Action.C

class Strategy_COLLECTIVE_2(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.opponent_history.append(np.mean(history.opponent_actions, axis=0))
        if state.round_number == 0:
            return Action.C
        opp_cooperated = np.mean(self.opponent_history[-1]) >= self.game_description.n_players // 2
        return Action.C if opp_cooperated else Action.D

class Strategy_COLLECTIVE_3(BaseStrategy):
    """
    The Adaptive Tit-for-Tat strategy promotes cooperation while punishing defection.
    It encourages reciprocity by cooperating when others do and defecting when they don't (unless the resource level is low).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(self.game_description.capacity * 2 / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = np.mean(history.opponent_actions, axis=0).astype(int)
        last_round = history.opponent_actions[-1] if history else None
        if history and state.round_number < self.game_description.n_rounds - 1:
            if np.all(last_round == opponent_actions):
                return Action.C
            elif np.any(last_round != opponent_actions) and state.current_stock < self.threshold:
                return Action.C
            else:
                return Action.D
        elif history and state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock >= self.threshold:
                return Action.D
            else:
                return Action.C
        elif not history:
            return Action.C

class Strategy_COLLECTIVE_4(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)

    This strategy mimics the opponent's actions from the previous round and punishes defection through a punishment period mechanism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_duration = 0
        self.total_payoff = 0
        self.total_payoff_from_defection = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[state.round_number - 1][0]
        if self.punishment_duration > 0 and opponent_action == Action.C:
            self.punishment_duration -= 1
        elif opponent_action == Action.D:
            self.punishment_duration = min(self.game_description.n_players, self.punishment_duration + 1)
        if opponent_action == Action.C:
            self.total_payoff += state.current_stock / (2 * self.game_description.n_players)
        else:
            self.total_payoff_from_defection = max(self.total_payoff_from_defection, self.total_payoff)
            self.total_payoff -= state.current_stock / self.game_description.n_players
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if self.total_payoff > self.total_payoff_from_defection else Action.D
        return Action.C if opponent_action == Action.C or self.punishment_duration > 0 else Action.D

class Strategy_COLLECTIVE_5(BaseStrategy):
    """
    An adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity * 0.8
        self.punishment_probability = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_history = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=np.bool_)
        if len(opponent_history) < state.round_number - 1 or np.sum(opponent_history) == 0:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level < self.threshold and opponent_history[-1]:
            return Action.C
        else:
            random_choice = random.random()
            if np.sum(opponent_history == 1) >= self.game_description.n_players // 2:
                return Action.C
            elif random_choice < self.punishment_probability and opponent_history[-1]:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_6(BaseStrategy):
    """
    A strategy named Tit-for-Tat Evolution (TFT-E) that encourages long-term cooperation and adaptability,
    fostering a collective approach towards resource management by adhering to a fair and reciprocal behavioral norm.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._last_opponent_action = None
        self._stock_depletion = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        if state.round_number == 1 or self._stock_depletion:
            return Action.C
        self._last_opponent_action = history.opponent_actions[-1][-1] if history else None
        current_stock = state.current_stock
        if current_stock <= 0:
            self._stock_depletion = True
        action = Action.C if self._last_opponent_action == Action.C else Action.D
        return action

class Strategy_COLLECTIVE_7(BaseStrategy):
    """Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        elif state.round_number == len(history.my_actions):
            return Action.C
        else:
            self.history = history
            opponents_cooperated = sum(self.history.opponent_actions[-1]) >= math.ceil(self.game_description.n_players / 2)
            if opponents_cooperated or all(self.history.my_actions[-1]):
                self.history.my_payoffs[-1] = state.current_stock / (2 * self.game_description.n_players)
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_8(BaseStrategy):
    """
    Adaptive Stock-Growth Strategy (ASGS) for the Common Pool Resource Game.
    This strategy adapts its actions based on the collective behavior of other players, aiming to maintain an equilibrium between conserving the resource and gaining personal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        avg_consumption = np.mean(history.my_actions[-self.r:])
        stock_level = history.opponent_payoffs[-1][-1] if state.round_number == 1 else state.current_stock
        capacity = self.game_description.capacity
        max_consumption = 2 * self.game_description.n_players / self.r
        if stock_level == capacity:
            return Action.C
        elif avg_consumption < max_consumption:
            return Action.C
        elif avg_consumption > max_consumption or stock_level == 0:
            return Action.D
        elif np.isclose(avg_consumption, max_consumption):
            return Action.C if random.random() > 0.5 else Action.D

class Strategy_COLLECTIVE_9(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.memory_length = int(math.ceil(game_description.n_rounds * 0.1))
        self.average_cooperation = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if history is not None:
            cooperation_rate = np.mean(history.my_actions[-self.memory_length:])
            if all((action == Action.C for action in history.opponent_actions[-1])):
                action = Action.C
            elif any((action == Action.D for action in history.opponent_actions[-1])):
                action = Action.D
            else:
                action = Action.C if cooperation_rate > 0.5 else Action.D
        return action

class Strategy_COLLECTIVE_11(BaseStrategy):
    """Adaptive Tit-for-Tat with Stock Growth Awareness"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.EF = 2
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            last_round = history.my_actions[-1]
            punishment_limit = min(self.game_description.capacity / self.game_description.n_players, state.current_stock * self.EF)
            own_action = Action.C if last_round and history.opponent_actions[-1, -1] == Action.C.value else Action.D
            if own_action == Action.D:
                consumption = math.ceil(punishment_limit) if punishment_limit > 0 else self.game_description.capacity / self.game_description.n_players
                history.my_actions[-1] = True
                history.my_payoffs[-1] += state.current_stock - consumption
                history.opponent_payoffs[-1, -1] -= consumption
            return own_action

class Strategy_COLLECTIVE_12(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponent_actions_history.append(history.opponent_actions[-1].flatten())
        if state.round_number == len(self.opponent_actions_history):
            return Action.C
        last_round = self.opponent_actions_history[-2]
        current_round = self.opponent_actions_history[-1]
        if np.sum(current_round) - np.sum(last_round) < 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_13(BaseStrategy):
    """
    Adaptive Fitness-based Stock Management (AFSM) strategy for Common Pool Resource Game.
    This strategy cooperates when the current stock level is above the 'critical' threshold and defects otherwise.
    The critical threshold is dynamically determined based on the average consumption rate in the past few rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = np.zeros(self.game_description.n_rounds)
        self.critical_threshold = self.game_description.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.my_actions) >= self.game_description.n_rounds:
            self.average_consumption = np.expmov(self.average_consumption, 1 / self.game_description.n_players, 0)
            self.critical_threshold = self.game_description.capacity * np.mean(history.my_payoffs[:-1]) / history.my_payoffs[-1]
        action = Action.C if state.current_stock > self.critical_threshold else Action.D
        return action

class Strategy_COLLECTIVE_14(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = [None] * self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent = random.choice(range(1, self.game_description.n_players + 1))
        if opponent not in self.opponent_history:
            self.opponent_history[opponent - 1] = [False] * state.round_number
        last_round = state.round_number - 1
        last_opponent_action = self.opponent_history[opponent - 1][last_round]
        if last_round == history.opponent_actions.shape[0] - 1:
            return Action(last_opponent_action)
        self.opponent_history[opponent - 1][last_round] = last_opponent_action
        if last_opponent_action:
            return Action.C
        streak = 0
        for action in reversed(self.opponent_history[opponent - 1][:-1]):
            if not action:
                streak += 1
            else:
                break
        if streak >= state.round_number:
            return Action.C
        return Action(not last_opponent_action)

class Strategy_COLLECTIVE_15(BaseStrategy):
    """
    Implementation of the Tit-for-Tat Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((game_description.n_rounds, 1), dtype=bool), my_payoffs=np.zeros(game_description.n_rounds, dtype=float), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=float))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        else:
            cooperators = sum(history.opponent_actions[state.round_number - 1, :])
            action = Action.C if cooperators >= self.game_description.n_players // 2 else Action.D
        self.history.my_actions[state.round_number] = [action == Action.C]
        return action

class Strategy_COLLECTIVE_16(BaseStrategy):
    """Adaptive Tit-for-Tat (ATFT) Strategy"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_action_history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.opponent_action_history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            self.opponent_action_history = Action.C
            return Action.C
        else:
            self.opponent_action_history = history.opponent_actions[-1][-1]
            return Action.D

class Strategy_COLLECTIVE_17(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_defections = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == len(history.opponent_actions) - 1:
            return Action.C
        opponent_action = history.opponent_actions[-1, int(not self)]
        if opponent_action:
            return Action.C
        if not self.consecutive_defections and opponent_action == history.opponent_actions[self.consecutive_defections, int(not self)]:
            self.consecutive_defections += 1
        elif self.consecutive_defections >= 3 and opponent_action != history.opponent_actions[self.consecutive_defections - 1, int(not self)]:
            self.consecutive_defections = 0
        return Action.D

class Strategy_COLLECTIVE_18(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.conservative_threshold = 2 * game_description.n_players
        self.round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.opponent_actions) == 0):
            return Action.C
        self.round += 1
        if history is not None:
            opponent_action = history.opponent_actions[-1, -1]
            if opponent_action and state.round_number < self.game_description.n_rounds and (state.current_stock >= self.conservative_threshold):
                return Action.C
            elif state.current_stock < self.conservative_threshold:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_19(BaseStrategy):
    """
    The Tit-for-Tat (TFT) strategy in Common Pool Resource Game.
    A simple strategy that rewards cooperation and punishes defection, promoting sustained common pool resource management.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        else:
            last_action = history.opponent_actions[-1, 0]
            self._last_opponent_action = last_action
            if last_action:
                return Action.C
            else:
                return Action.D

    def get_last_opponent_action(self) -> bool:
        """
        Return the last action taken by the opponent, as a boolean value (True for cooperate, False for defect).
        """
        return self._last_opponent_action

class Strategy_COLLECTIVE_21(BaseStrategy):
    """
    Adaptive Stock Management Strategy (ASMS) for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_stock = game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            stock = state.current_stock
            growth = 2 * stock * (1 - stock / self.game_description.capacity)
            return Action(math.isclose(stock + growth, self.game_description.capacity, rel_tol=0.01))
        stock = state.current_stock
        return Action(stock > self.average_stock)

class Strategy_COLLECTIVE_22(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.percentage_cooperate = 0.2 * self.game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        total_consumption = np.sum(history.my_payoffs)
        cooperators = sum(history.opponent_actions[-1])
        percentage_cooperate_total = (self.game_description.n_players - cooperators + 1) / self.game_description.n_players
        should_cooperate = total_consumption <= (self.game_description.capacity - state.current_stock) * percentage_cooperate_total / 2
        if should_cooperate or state.round_number < self.percentage_cooperate:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_23(BaseStrategy):
    """
    Tit-for-Tat Evolutionary Strategy (TFTES) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(game_description.n_rounds * 0.2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.game_description.n_rounds:
            own_action = history.my_actions[-1] if history else None
            opponent_action = history.opponent_actions[-1, 0] if history else None
            if own_action is not None and opponent_action is not None:
                return Action(int(own_action) == Action.C and opponent_action)
            elif state.round_number - 1 < self.threshold:
                return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_24(BaseStrategy):
    """
    A simple implementation of the Tit-for-Tat with Stock Adaptation (TFT-SA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = math.floor(game_description.capacity / 2)
        self.survival_threshold = math.floor(game_description.capacity / 10)
        self.delta = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        opponent_cooperated_last_round = sum(history.opponent_actions[-1]) >= self.game_description.n_players // 2
        if current_stock >= self.critical_threshold:
            action = Action.C if opponent_cooperated_last_round else Action.D
        elif current_stock < self.critical_threshold and current_stock >= self.survival_threshold:
            action = Action.D
        else:
            action = Action.C
        if current_stock == 0:
            self.critical_threshold = min(self.game_description.capacity, self.critical_threshold + self.delta)
        return action

class Strategy_COLLECTIVE_26(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        round_history = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=np.bool_)
        my_action = Action.C if round_history.sum() >= self.game_description.n_players // 2 and state.current_stock > self.threshold else Action.D
        if state.round_number == history.opponent_actions.shape[0]:
            return my_action
        opponent_stock = max(state.current_stock - np.sum([history.opponent_payoffs[history.opponent_actions.argmax(axis=0)][:, state.round_number] if history else np.zeros(self.game_description.n_players, dtype=np.float64)]), 0)
        return my_action if opponent_stock > self.threshold else Action.D

class Strategy_COLLECTIVE_27(BaseStrategy):
    """
    Strategy name: Adaptive Resource Management (ARM) Strategy
    Description: Decision rules for the ARM strategy, promoting cooperation when resources are abundant and protecting them when they are scarce.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_sustainable_level = (game_description.capacity + game_description.n_players * 2) / (2 * game_description.n_players)
        self.minimum_sustainable_level = 2 * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if history is None or len(history.opponent_actions) == 0 else history.opponent_actions[-1][0]
        if history is None or len(history.opponent_actions) == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        current_stock = state.current_stock
        if current_stock > self.average_sustainable_level:
            return Action.C
        elif current_stock < self.minimum_sustainable_level:
            return Action.D
        else:
            opponent_cooperated = sum(history.opponent_actions[last_round]) >= self.game_description.n_players // 2
            return Action.C if opponent_cooperated else Action.D

class Strategy_COLLECTIVE_28(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round = 0
        self.opponent_defected = False
        self.k = math.ceil(game_description.n_players * 2)
        self.switch_cooldown = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.round += 1
        if not history:
            return Action.C
        stock = state.current_stock
        last_action = history.opponent_actions[-1][0] if len(history.opponent_actions) > 0 else None
        if self.round == 1 or (self.switch_cooldown and self.switch_cooldown > self.k):
            action = Action.C
        elif last_action:
            action = Action(last_action)
        else:
            action = Action.D
        if not last_action and self.opponent_defected and (self.round > 1):
            self.switch_cooldown += 1
        elif self.round == self.game_description.n_rounds or stock <= 0:
            action = self.max_payoff_action(stock, self.game_description.n_players)
        if not last_action and history.my_actions[-1]:
            self.opponent_defected = True
        elif last_action is None or not history.opponent_actions[-1][0]:
            self.opponent_defected = False
        return action

    def max_payoff_action(self, stock: float, n_players: int) -> Action:
        if stock <= 0 or np.isinf(stock):
            return Action.D
        else:
            payoffs = [(stock / (2 * n_players), Action.C), (stock / n_players, Action.D)]
            max_payoff, _ = max(payoffs, key=lambda x: x[0])
            return Action(1 if max_payoff > 0 else 0)

class Strategy_COLLECTIVE_30(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if self.average_consumption is None:
            self.average_consumption = np.full((self.game_description.n_rounds,), math.inf)
            self.average_consumption[0] = 0
        if history is None:
            self.average_consumption[-1] = (history.my_actions[:-1] * self.game_description.n_players).sum() / self.game_description.n_rounds
        average_consumption = self.average_consumption[-1]
        if average_consumption < state.current_stock / self.game_description.capacity:
            return Action.C
        return Action.D

    def update_average_consumption(self, payoff: float) -> None:
        """
        Update the average consumption after receiving a new payoff.
        """
        self.average_consumption[-1] = (self.average_consumption[:-1].sum() + payoff) / self.game_description.n_rounds - 1

class Strategy_COLLECTIVE_31(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 2.0
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        average_cpp = state.current_stock / self.game_description.n_players
        if average_cpp >= self.game_description.n_players * 2 / self.game_description.n_players:
            return Action.D
        stock_growth_potential = 2 * state.current_stock * (self.game_description.capacity - state.current_stock) / self.game_description.capacity
        new_threshold = min(stock_growth_potential, 2)
        if state.current_stock < average_cpp * self.game_description.capacity:
            new_threshold = max(new_threshold, 2)
        if state.current_stock >= new_threshold * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

    def update_history(self, payoff: float):
        if self.history is None:
            self.history = PlayerHistory(np.array([[True]], dtype=bool), np.array([[payoff]]), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros((1, self.game_description.n_players)))
        else:
            self.history.my_actions = np.vstack((self.history.my_actions, [True]))
            self.history.my_payoffs = np.vstack((self.history.my_payoffs, [payoff]))
            self.threshold = self.history.my_payoffs.mean()

class Strategy_COLLECTIVE_32(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperation (TFT-AC) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.c = math.floor(game_description.n_players / 2)
        self.d = game_description.n_players
        self.__initialized = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not self.__initialized:
            self.__initialize(history)
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        last_opponent_action = history.opponent_actions[-1, -1]
        if cooperators >= self.c and last_opponent_action == Action.D:
            return Action.C
        elif cooperators < self.c and last_opponent_action == Action.C:
            return Action.C
        else:
            return Action.D

    def __initialize(self, history):
        if history is not None:
            last_round = len(history.my_actions) - 1
            self.d = min(last_round + 1, self.game_description.n_rounds)
            self.__initialized = True

class Strategy_COLLECTIVE_33(BaseStrategy):
    """
    Adaptive Resource Sharing (ARS) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_threshold = game_description.capacity // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_history = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        last_action = np.mean(opponent_history) if len(opponent_history) > 0 else Action.D
        if state.current_stock < self.capacity_threshold:
            return Action.C
        if last_action == Action.C:
            return Action.C
        return Action.D

    def last_round(self, state: CommonPoolState, history: PlayerHistory) -> bool:
        """
        Returns True if the current round is the last one in a series of r rounds.
        """
        return state.round_number == self.game_description.n_rounds

class Strategy_COLLECTIVE_34(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        self.opponent_actions_history.append(history.opponent_actions[-1])
        last_round = len(self.opponent_actions_history) - 1
        last_opponent_action = self.opponent_actions_history[last_round]
        if np.count_nonzero(last_opponent_action) > self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

    def reset(self):
        self.opponent_actions_history = []

class Strategy_COLLECTIVE_35(BaseStrategy):
    """
    Adaptive Stock Management (ASM) strategy for Common Pool Resource Game.
    Maintains a sustainable stock level for collective benefit while considering each player's short-term interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_divisor = self.game_description.capacity * 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C
        ap_resource = state.current_stock / self.game_description.n_players
        if ap_resource > self.capacity_divisor / (2 * self.game_description.n_players):
            return Action.D
        elif ap_resource < self.capacity_divisor / (4 * self.game_description.n_players):
            return Action.C
        elif history and history.my_actions[-1]:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_36(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game.
    Cooperates initially and retaliates only when opponents defect, while avoiding depleting the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        opponent_action = np.mean(history.opponent_actions[-1])
        stock_after_consumption = state.current_stock - np.sum(history.my_actions * self.game_description.n_players)
        if stock_after_consumption >= 0:
            if opponent_action:
                return Action.C
            elif stock_after_consumption < self.game_description.capacity:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_37(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT)
    Strategy Description: This strategy promotes cooperation by cooperating in the first round and mimicking opponents' actions thereafter. If an opponent cooperates, this strategy will cooperate; otherwise, it will defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 1), dtype=bool), np.zeros(1, dtype=np.float64), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1, dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is not None:
            self.history = history
        if state.round_number == 0:
            return Action.C
        last_round = self.history.my_actions[-1]
        cooperators = sum(self.history.opponent_actions[-1, :])
        if np.all(last_round) and cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_38(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_counter = 0
        self.punishment_threshold = game_description.n_players // 2
        self.patience_factor = 1.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        action = Action.C
        if state.round_number > 1:
            round_number = state.round_number - 1
            if history.opponent_actions[round_number, 0] == Action.C.value:
                action = Action.C
            elif self.cooperation_counter > 0 and history.opponent_actions[round_number, 0] == Action.C.value:
                action = Action.C
            else:
                self.cooperation_counter += 1
                if self.cooperation_counter >= self.punishment_threshold:
                    self.cooperation_counter = 0
                    self.punishment_threshold *= self.patience_factor
        return action

class Strategy_COLLECTIVE_39(BaseStrategy):
    """
    Implementation of Adaptive Tit-for-Tat with Growth Awareness (ATTA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.past_rounds = np.zeros((10, 2), dtype=np.float64)
        self.last_stock = self.game_description.capacity
        self.rounds_completed = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0 or state.round_number > self.game_description.n_rounds - self.game_description.n_rounds // 2:
            action = Action.C if self.last_stock >= self.game_description.capacity * 0.5 else Action.D
        elif self.rounds_completed < 10:
            self.past_rounds[self.rounds_completed] = [history.my_payoffs[-self.rounds_completed - 1], 0.0] if action == Action.C else [0.0, history.my_payoffs[-self.rounds_completed - 1]]
            self.rounds_completed += 1
        elif state.current_stock < self.game_description.capacity * 0.25 and action != Action.D or np.mean(self.past_rounds[-10:, 0]) > np.mean(self.past_rounds[-9:-1, 1]):
            action = Action.C
        self.last_stock = state.current_stock
        return action

class Strategy_COLLECTIVE_40(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    This strategy cooperates when other players do so and punishes overconsumption to signal disapproval and encourage better behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_consumption = 0.0
        self.rounds_played = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.rounds_played += 1
        if self.rounds_played < self.game_description.n_rounds:
            consumption = np.sum(history.my_actions) * (state.current_stock / (2 * self.game_description.n_players)) if history is not None else state.current_stock / (2 * self.game_description.n_players)
            self.total_consumption += consumption
            average_consumption = self.total_consumption / self.rounds_played
            capacity_threshold = self.game_description.capacity - self.game_description.n_players
            if average_consumption < capacity_threshold / (2 * self.game_description.n_players):
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_41(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.round_history is None:
            return Action.C
        opponent_action = history.opponent_actions[state.round_number - 1, 0]
        if opponent_action and self.round_history[-1][0]:
            return Action.C
        elif opponent_action:
            return Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        self.round_history = history
        return None

class Strategy_COLLECTIVE_42(BaseStrategy):
    """
    Adaptive Fitness-Based Tit-for-Tat (AFB-TFT) strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity / game_description.n_players * 2
        self.cooperative_quota = self.capacity / game_description.n_players
        self.round_number = 0
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.round_number += 1
        if state.round_number == 1:
            return Action.C
        total_consumption, avg_net_consumption = self._calculate_history_stats(history)
        if state.current_stock > self.capacity or avg_net_consumption < self.cooperative_quota:
            return Action.C
        elif any([action == Action.D for action in history.opponent_actions[-1]]) or total_consumption >= state.current_stock:
            return Action.D
        else:
            return Action.C

    def _calculate_history_stats(self, history: PlayerHistory) -> tuple[float, float]:
        if self.round_number > 1:
            total_consumption = np.sum(history.my_actions * (self.game_description.n_players / self.game_description.capacity))
            avg_net_consumption = np.mean(total_consumption - history.my_payoffs if history.my_payoffs.size > 0 else [])
        else:
            total_consumption, avg_net_consumption = (0.0, 0.0)
        return (total_consumption, avg_net_consumption)

class Strategy_COLLECTIVE_43(BaseStrategy):
    """
    A Tit-for-Tat Adaptive (TFT-A) strategy for the Common Pool Resource Game.
    This strategy encourages cooperation and reciprocity while ensuring sustainable resource levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0 and history is None:
            return Action.C
        last_action = history.opponent_actions[round_number - 1, 0] if round_number > 0 else None
        if last_action is None or round_number == self.game_description.n_rounds:
            stock = state.current_stock
            if stock < self.threshold:
                return Action.D
        else:
            return Action(last_action)

class Strategy_COLLECTIVE_44(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            self.last_opponent_action = False
            return Action.C
        self.last_opponent_action = history.opponent_actions[state.round_number - 1, -1]
        return Action(self.last_opponent_action)

class Strategy_COLLECTIVE_45(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy for the Common Pool Resource Game.
    The strategy cooperates initially, mimics opponent's last action in subsequent rounds, and switches to always defect when the total stock drops below a threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is not None and state.current_stock >= self.threshold:
            opponent_last_action = history.opponent_actions[-1, :].mean()
            return Action(int(opponent_last_action))
        else:
            return Action.D

class Strategy_COLLECTIVE_48(BaseStrategy):
    """
    Adaptive Cooperative Strategy (ACS) for the Common Pool Resource Game.
    Promotes sustainable resource management while maximizing individual payoff over time.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_capacity_per_player = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds and state.current_stock < self.avg_capacity_per_player:
            return Action.D
        action = self.decide_action(state, history)
        return action

    def decide_action(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.current_stock > self.avg_capacity_per_player:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_49(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_capacity = game_description.capacity
        self.current_stock = None
        self.round_number = 0
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if self.round_number == 0:
            self.current_stock = state.current_stock
            return Action.C
        self.round_number += 1
        self.history = history
        self.current_stock = state.current_stock
        if self.round_number == self.game_description.n_rounds:
            if self.current_stock >= self.initial_capacity / 2:
                action = self.history.opponent_actions[-1, -1]
            else:
                action = Action.D
        elif self.round_number > self.game_description.n_rounds:
            action = self.history.opponent_actions[self.round_number - 2, -1]
            if self.current_stock <= self.initial_capacity / 2:
                action = Action.D
        elif self.round_number in range(self.game_description.n_rounds - 9, self.game_description.n_rounds + 10):
            if self.current_stock >= 4 / 5 * self.initial_capacity:
                action = Action.C
            else:
                action = self.history.opponent_actions[self.round_number - 2, -1]
        else:
            action = self.history.opponent_actions[self.round_number - 2, -1]
        return action

class Strategy_COLLECTIVE_50(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.threshold:
            self.threshold = min(state.current_stock * (2 * self.game_description.n_players) / ((state.round_number + 1) * self.game_description.n_players), 0.5)
        last_round = state.round_number == self.game_description.n_rounds - 1
        if last_round:
            if state.current_stock / (2 * self.game_description.n_players) >= self.threshold or history.opponent_actions[-1][-1] != Action.C.value:
                return Action.C
            else:
                return Action.D
        opponent_cooperated = sum(history.opponent_actions[:, -1]) >= self.game_description.n_players // 2
        if opponent_cooperated:
            return Action.C
        elif state.current_stock / (2 * self.game_description.n_players) >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_51(BaseStrategy):
    """
    This is a Tit-for-Tat with Adaptive Cooperation (TFTA) Strategy for the Common Pool Resource Game.
    It prioritizes maintaining a sustainable stock level and encourages cooperation with opponents,
    fostering trust, reciprocity, and a sense of shared responsibility for preserving the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.opponent_history = history.opponent_actions.flatten().tolist()
        if state.round_number == 1:
            return Action.C
        last_action = self.opponent_history[-1]
        if last_action == Action.C.value:
            return Action.C
        elif last_action == Action.D.value:
            return Action.D
        else:
            print('Error: Invalid opponent history')
            return None

class Strategy_COLLECTIVE_52(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.resource_threshold = game_description.capacity // 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock
        if stock_level < self.resource_threshold and history is not None:
            return Action.D
        if len(history.opponent_actions) > 0 and history.opponent_actions[-1, -1] == Action.D:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_53(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            cooperators = sum(history.opponent_actions[state.round_number - 1])
            if cooperators == self.n_players - 1 or cooperators == 0:
                return Action.C
            elif cooperators > 1:
                return Action.D
        return Action.D

class Strategy_COLLECTIVE_54(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    Strategy encourages reciprocal behavior among players to foster cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperated_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            self.opponent_cooperated_last_round = True
        elif len(history.opponent_actions) > 0:
            self.opponent_cooperated_last_round = history.opponent_actions[-1].any()
        return Action.C if self.opponent_cooperated_last_round else Action.D

    def handle_edge_case(self, history: PlayerHistory) -> bool:
        if sum(history.opponent_actions[-1]) == len(history.opponent_actions):
            self.opponent_cooperated_last_round = True
        return self.opponent_cooperated_last_round

class Strategy_COLLECTIVE_55(BaseStrategy):
    """Adaptive Tit-for-Tat Strategy for the Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.8
        self.history = PlayerHistory(my_actions=np.empty((game_description.n_rounds,), dtype=bool), my_payoffs=np.empty(game_description.n_rounds), opponent_actions=np.empty((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.empty((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.C
        self.history.my_actions[state.round_number] = True
        self.history.my_payoffs[state.round_number] = state.current_stock / (self.game_description.capacity * self.game_description.n_players)
        opponent_cooperated = np.sum(history.opponent_actions[-1, :])
        if opponent_cooperated > 0:
            return Action.C
        elif state.current_stock / (self.game_description.capacity * self.game_description.n_players) > self.threshold:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_COLLECTIVE_56(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth (ATFSG) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_length = math.ceil(game_description.n_rounds * 0.85)
        self.threshold = game_description.capacity / (2 * game_description.n_players * game_description.n_rounds) * 0.85
        self.history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(self.history) < self.history_length):
            return Action.C
        average_consumption = np.mean([h[0] for h in self.history[-self.history_length:]] if history else [0])
        if average_consumption <= self.threshold:
            return Action.C
        return Action.D

    def update(self, state: CommonPoolState, action: Action, payoff: float) -> None:
        """
        Update the strategy's history with the given state, action, and payoff.
        """
        self.history.append((action == Action.C).sum() / self.game_description.n_players)

class Strategy_COLLECTIVE_57(BaseStrategy):
    """
    Tit-for-Tat with a slight modification for Common Pool Resource Game.
    Cooperates initially; cooperates if all opponents did so last round, defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        opponents_cooperated = sum(history.opponent_actions[-1, :])
        if opponents_cooperated >= self.game_description.n_players:
            return Action.C
        elif opponents_cooperated > 0 and history.my_actions[-1] != Action.C:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_60(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy in a Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_opponent_cooperators = sum(history.opponent_actions[last_round, :])
        round_is_last = state.round_number == self.game_description.n_rounds
        action = Action.C if (state.round_number == 0 or last_opponent_cooperators >= self.game_description.n_players // 2) and (not round_is_last) else Action.D
        return action

class Strategy_COLLECTIVE_61(BaseStrategy):
    """
    Tit-for-Tat Adaptive Strategy (TFT-A) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = None
        self.window_size = int(self.game_description.n_players // 2)
        self.average_consumption_rate = np.zeros(self.window_size)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        total_consumption = sum(history.my_actions) * self.game_description.capacity / state.round_number
        average_consumption_rate = total_consumption / state.round_number
        if state.round_number == self.game_description.n_rounds:
            self.average_consumption_rate[-1] = average_consumption_rate
            if average_consumption_rate <= self.threshold:
                return Action.C
            else:
                return Action.D
        self.average_consumption_rate = np.roll(self.average_consumption_rate, -1)
        self.average_consumption_rate[-1] = average_consumption_rate
        self.threshold = np.mean(self.average_consumption_rate[:self.window_size])
        if average_consumption_rate <= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_62(BaseStrategy):
    """Adaptive Tit-for-Tat with Stock Growth (ATFSG) Strategy for Common Pool Resource Game."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_level = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            if state.current_stock > self.game_description.capacity // 2:
                return Action.C
            else:
                return Action.D
        self._calculate_critical_level()
        action = Action.C if state.current_stock > self.critical_level else Action.D
        return action

    def _calculate_critical_level(self):
        if self.critical_level is not None:
            return
        self.critical_level = self.game_description.capacity * self.game_description.n_players ** 2 / self.game_description.n_rounds

class Strategy_COLLECTIVE_63(BaseStrategy):
    """
    The Titan Strategy for Common Pool Resource Game emphasizes long-term sustainability through cooperation, while also punishing free riders and promoting fairness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.tolerance = game_description.capacity * 0.5
        self.tolerance_break = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        last_round = self.game_description.n_rounds
        if current_round >= last_round:
            return Action.D
        stock = state.current_stock
        if stock > self.tolerance * self.game_description.capacity:
            return Action.C
        cooperation_count = sum(history.opponent_actions[current_round - 1, :])
        if cooperation_count >= self.game_description.n_players // 2 and stock < self.tolerance * self.game_description.capacity:
            return Action.C
        if cooperation_count < self.game_description.n_players // 2 and stock < self.tolerance * self.game_description.capacity:
            if history.opponent_actions[current_round - 1, :].all():
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_64(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) with Stock Growth Awareness (SG-ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.tolerance_threshold = int(self.game_description.capacity * 0.25)

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        if previous_round >= self.game_description.n_rounds:
            opponents_cooperated = np.all(history.opponent_actions[previous_round])
            if opponents_cooperated:
                return Action.C
            consumption = min(state.current_stock - self.game_description.capacity * (1 - state.current_stock / self.game_description.capacity), np.sum(history.opponent_actions[previous_round]))
            return Action.D if np.sum(history.opponent_actions[previous_round]) > consumption else Action.C
        opponents_cooperated = np.count_nonzero(history.opponent_actions[previous_round])
        opponents_defected = self.game_description.n_players - opponents_cooperated
        if opponents_cooperated == self.game_description.n_players:
            return Action.C
        elif opponents_defected > 0 and opponents_cooperated < self.game_description.n_players:
            opponent_consumption = np.mean(history.opponent_actions[previous_round])
            if opponent_consumption >= (self.game_description.capacity - self.tolerance_threshold) / self.game_description.n_players:
                return Action.C
            consumption = min(state.current_stock - self.game_description.capacity * (1 - state.current_stock / self.game_description.capacity), np.sum(history.opponent_actions[previous_round]))
            return Action.D if np.sum(history.opponent_actions[previous_round]) > consumption else Action.C
        elif opponents_defected == self.game_description.n_players:
            consumption = min(state.current_stock - self.game_description.capacity * (1 - state.current_stock / self.game_description.capacity), np.sum(history.opponent_actions[previous_round]))
            return Action.D if np.sum(history.opponent_actions[previous_round]) > consumption else Action.C

class Strategy_COLLECTIVE_65(BaseStrategy):
    """
    A simple Tit-for-Tat strategy for the Common Pool Resource game.
    Cooperates in the first round, then mirrors the collective action of all players from the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=None, my_payoffs=None, opponent_actions=None, opponent_payoffs=None)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.history = history
        if state.round_number == 0 or (state.round_number > 0 and history.my_actions[-1] is None):
            return Action.C
        cooperators = sum(self.history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            self.history.my_actions[-1] = True
            return Action.C
        else:
            self.history.my_actions[-1] = False
            return Action.D

class Strategy_COLLECTIVE_66(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Forgiveness (TFT-A) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_threshold = 1
        self.max_forgiveness = math.floor(game_description.n_players // 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_action = history.opponent_actions[last_round, 0]
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if last_action:
            if self.forgiveness_threshold > self.max_forgiveness:
                return Action.D
            else:
                self.forgiveness_threshold += 1
                return Action.C
        else:
            self.forgiveness_threshold = max(self.forgiveness_threshold - 1, 1)
            return Action.D

class Strategy_COLLECTIVE_67(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) with Stock Growth Consideration (SG-ATFT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_level = game_description.capacity / 2.0
        self.forgiveness_threshold = game_description.capacity / 4.0
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        growth = 2 * state.current_stock * (1 - state.current_stock / self.game_description.capacity)
        new_stock = min(state.current_stock + growth, self.game_description.capacity)
        if self.last_round:
            return Action.C if new_stock > self.critical_level else Action.D
        opponent_cooperated_recently = history and np.any(history.opponent_actions[-1])
        opponent_defected_most_recently = not np.all(history.opponent_actions[-1])
        if opponent_cooperated_recently:
            return Action.C
        elif opponent_defected_most_recently and state.current_stock > self.forgiveness_threshold:
            return Action.C
        else:
            return Action.D
        self.last_round = state.round_number == self.game_description.n_rounds - 1

class Strategy_COLLECTIVE_68(BaseStrategy):
    """
    A cooperative strategy that responds to opponents' cooperation with cooperation while punishing defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        self.last_round_cooperators = sum(history.opponent_actions[last_round, :])
        if last_round == state.round_number - 1:
            return Action.C
        elif all(history.opponent_actions[-1, :]):
            return Action.C
        elif any(np.logical_not(history.opponent_actions[-1, :])):
            return Action.D
        else:
            return self.last_round_cooperators > self.game_description.n_players // 2

class Strategy_COLLECTIVE_69(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.opponent_history.append(history.opponent_actions[-1])
        round_number = state.round_number
        opponent_cooperated_last_round = np.sum(self.opponent_history[-1]) >= self.game_description.n_players // 2
        if round_number == self.game_description.n_rounds:
            return Action.C
        elif round_number == 0:
            if not np.any(history.opponent_actions[0]):
                self.opponent_history = [np.zeros(self.game_description.n_players, dtype=bool)]
                return Action.D
        elif opponent_cooperated_last_round:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_70(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = self.game_description.n_players * 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        recent_opponent_cooperators = sum(history.opponent_actions[-1])
        current_stock = state.current_stock
        if recent_opponent_cooperators >= self.game_description.n_players // 2 and current_stock >= self.stock_threshold or not history:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_71(BaseStrategy):
    """Adaptive Resource Sharing Algorithm (ARSA) for the Common Pool Resource Game."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_point = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            bias = 0.6
            return self._random_action(bias)
        if state.current_stock > self.critical_point:
            return Action.C
        elif state.current_stock <= 0:
            return Action.D
        else:
            bias = 0.5
            return self._random_action(bias)

    def _random_action(self, bias):
        if random.random() < bias:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_72(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth Consideration (SG-ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.75 * game_description.capacity
        self.history = PlayerHistory(my_actions=None, my_payoffs=None, opponent_actions=np.zeros((1, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros(game_description.n_rounds * game_description.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        self.history = history if history is not None else self.history
        action = Action.D
        if state.round_number == 0:
            action = Action.C
        elif state.round_number < self.game_description.n_rounds - 1:
            cooperators = sum(self.history.opponent_actions[-1, :])
            accumulated_depletion = self.history.my_payoffs.sum() * self.game_description.n_players / (2 * self.game_description.capacity)
            if cooperators >= self.game_description.n_players // 2 or accumulated_depletion > self.threshold:
                action = Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            action = Action.C
        return action

class Strategy_COLLECTIVE_73(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy (ATFS) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_round = 0
        self.forgiveness_threshold = int(2 * game_description.n_players)
        self.tolerance_threshold = int(4 * game_description.n_players)
        self.defection_counter = 0
        self.cooperation_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        elif state.round_number == 1:
            return Action.C
        elif self.defection_counter > self.forgiveness_threshold:
            action = Action.D
        elif history.opponent_actions[-1, :].mean() >= (self.game_description.n_players - self.tolerance_threshold) / self.game_description.n_players:
            action = Action.D
        elif history.opponent_actions[-1, :].mean() > (self.game_description.n_players + self.tolerance_threshold) / (2 * self.game_description.n_players):
            action = Action.C
        else:
            self.defection_counter += 1
            self.cooperation_counter = 0
            if self.defection_counter > self.forgiveness_threshold:
                action = Action.D
            else:
                action = Action.C
        self.current_round += 1
        return action

class Strategy_COLLECTIVE_74(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    A forgiving strategy that aims to foster an environment where cooperation can thrive over time while being adaptive to a wide range of opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.past_cooperate_threshold = int(math.ceil(game_description.n_players * 0.6))
        self.stock_threshold = int(math.floor(game_description.capacity / game_description.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if len(history.my_actions) <= self.past_cooperate_threshold:
            opponent_last_action = history.opponent_actions[-1, -1]
        else:
            opponent_last_action = history.opponent_actions[-1][-1]
        if state.round_number == self.game_description.n_rounds - 1:
            return self._choose_action(state, history)
        if opponent_last_action == Action.C:
            return Action.C
        elif opponent_last_action == Action.D:
            return Action.D
        else:
            stock = state.current_stock
            payoff_last_round = history.my_payoffs[-1]
            return self._choose_action(state, history, stock, payoff_last_round)

    def _choose_action(self, state: CommonPoolState, history: PlayerHistory, stock=None, payoff_last_round=None):
        if stock is None or payoff_last_round is None:
            stock = state.current_stock
            payoff_last_round = history.my_payoffs[-1]
        if stock <= self.stock_threshold and history.my_actions[-1] == Action.C:
            return Action.D
        elif stock >= self.stock_threshold and history.my_actions[-1] == Action.D:
            return Action.C
        elif stock > payoff_last_round:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_75(BaseStrategy):
    """
    The Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            self.opponent_actions_history.append(history.opponent_actions[-1]) if history else self.opponent_actions_history.append([[0] * self.game_description.n_players for _ in range(state.round_number)])
            last_opponent_action = np.mean(self.opponent_actions_history[-1], axis=0)
            return Action.C if last_opponent_action > self.game_description.n_players // 2 else Action.D

class Strategy_COLLECTIVE_76(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            self.last_opponent_action = None
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            self.last_opponent_action = None
            return Action.C
        self.last_opponent_action = history.opponent_actions[-1, -1] if history else None
        if self.last_opponent_action == Action.C:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_77(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = np.zeros((1, game_description.n_players), dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            self.opponent_history = np.roll(self.opponent_history, -1, axis=0)
        if history is None or state.round_number == 0:
            return Action.C
        opponent_cooperated = np.sum(self.opponent_history[-1, :]) >= self.game_description.n_players // 2
        return opponent_cooperated and Action.C or Action.D

class Strategy_COLLECTIVE_78(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game
    Strategy mimics opponent's behavior, promoting cooperation and preserving common resources.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.round += 1
        if not history or state.round_number == 0:
            action = Action.C
        elif state.round_number == self.game_description.n_rounds:
            action = Action.C
        elif state.current_stock == 0:
            action = Action.D
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= self.game_description.n_players // 2:
                action = Action.C
            else:
                action = Action.D
        return action

class Strategy_COLLECTIVE_79(BaseStrategy):
    """
    A Tit-for-Tat-Plus (TFT+) strategy for the Common Pool Resource Game.
    The TFT+ strategy prioritizes maintaining a balanced approach to resource consumption, favoring cooperation whenever possible while also punishing defection to prevent exploitation and preserve the common pool's sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        opponent_cooperators = np.count_nonzero(history.opponent_actions[state.round_number - 1, :])
        return Action(int(opponent_cooperators >= self.game_description.n_players // 2))

class Strategy_COLLECTIVE_80(BaseStrategy):
    """Adaptive Tit-for-Tat (ATFT) with Stock Growth Awareness (SGW)"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        if last_round == state.round_number and history.opponent_payoffs[-1, -1] < self.threshold:
            return Action.D
        for round_index in reversed(range(last_round + 1)):
            if history.opponent_actions[round_index, -1] == Action.D:
                return history.opponent_actions[round_index, -1]
        return Action.C

class Strategy_COLLECTIVE_81(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy that cooperates in the first round and follows the actions of opponents in subsequent rounds.
    Switches to a defensive mode when the stock level falls below 50% of the initial capacity.
    Prioritizes long-term sustainability over immediate gains to ensure continuous resource supply for all players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = self.game_description.capacity // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        last_round = len(history.my_actions) - 1
        last_opponent_actions = history.opponent_actions[last_round, :]
        stock_level = state.current_stock
        if stock_level < self.stock_threshold:
            return Action.C
        elif np.all(last_opponent_actions):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_82(BaseStrategy):
    """Adaptive Tit-for-Tat (A-TFT) strategy for the Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.opponent_history = history.opponent_actions[:, -1] if history else np.zeros(self.game_description.n_players)
        last_cooperators = (self.opponent_history == 1).sum()
        if last_cooperators >= self.game_description.n_players - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_84(BaseStrategy):
    """
    Implementation of the Adaptive Cooperation-Defection Strategy (ACDS).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cp_max = self.game_description.capacity / (2 * self.game_description.n_players)
        self.cp_min = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        round = state.round_number - 1
        critical_point = self.cp_max - (self.cp_max - self.cp_min) * round / self.game_description.n_rounds
        if state.current_stock > critical_point:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_85(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Stock-awareness (TFT-AS) Strategy
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.stock_threshold = self.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = np.sum(history.my_actions * (self.n_players / 2))
        remaining_capacity = self.capacity - total_consumption
        current_stock_share = state.current_stock / (self.n_players * (state.round_number + 1))
        if current_stock_share >= self.stock_threshold:
            return Action.D
        elif total_consumption < self.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_86(BaseStrategy):
    """
    Implementation of the Tit-for-Tat Evolutionary Strategy for Common Pool Resource Game.
    This strategy cooperates by default and punishes defection while forgiving after a period of cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.strategy = Action.C
        self.forgiveness_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        if self.strategy == Action.C:
            stock_change = state.current_stock / (2 * self.game_description.n_players)
            if all((action == Action.C for action in history.opponent_actions[-1])):
                self.forgiveness_counter = 0
            else:
                self.strategy = Action.D
                self.forgiveness_counter += 1
        elif self.strategy == Action.D:
            stock_change = state.current_stock / self.game_description.n_players
            if all((action == Action.C for action in history.opponent_actions[-1])):
                self.strategy = Action.C
                self.forgiveness_counter = 0
            else:
                self.forgiveness_counter += 1
                if self.forgiveness_counter >= self.game_description.n_players // 2:
                    self.strategy = Action.C
        return self.strategy

class Strategy_COLLECTIVE_87(BaseStrategy):
    """
    Adaptive Resource Sharing Algorithm (ARSA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_stock = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            action = random.choice([Action.C, Action.D])
        else:
            self._update_average_stock(history)
            if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
                threshold = self._get_threshold(state.round_number)
            else:
                threshold = self.game_description.capacity / self.game_description.n_players if state.current_stock > self.average_stock[0] else self.game_description.capacity * (2 / 3 * self.game_description.n_players)
            if state.current_stock > self.average_stock[-1] * threshold:
                action = Action.C
            elif state.current_stock < self.game_description.capacity / (2 * self.game_description.n_players):
                action = Action.D
            else:
                action = history.opponent_actions[-1][state.round_number % self.game_description.n_players] if state.current_stock > history.opponent_actions[-1, state.round_number % self.game_description.n_players].mean() * threshold else Action.D
        return action

    def _update_average_stock(self, history: PlayerHistory):
        self.average_stock = np.roll(self.average_stock, 1)
        self.average_stock[-1] = history.opponent_payoffs[-1].mean() / (2 * self.game_description.n_players)

    def _get_threshold(self, round_number: int):
        if round_number == self.game_description.n_rounds - 1:
            return self.game_description.capacity * (2 / 3) / self.game_description.n_players
        else:
            return self.game_description.capacity / self.game_description.n_players

class Strategy_COLLECTIVE_89(BaseStrategy):
    """
    Strategy: Adaptive Tit-for-Tat with Stock-based Punishment Threshold (ATFT-SPT) for Common Pool Resource Game.
    Promotes a collective mindset by encouraging cooperation when possible, while also enforcing proportional punishments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = int(self.game_description.capacity / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players:
            return Action.C
        if current_stock < self.stock_threshold:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_91(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.current_opponent_action = np.mean(history.opponent_actions[-1])
            opponent_cooperated = self.current_opponent_action > 0.5
            if state.round_number == 1 and opponent_cooperated:
                return Action.C
            elif opponent_cooperated:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_92(BaseStrategy):
    """
    Strategy Name: Adaptive Stock-based Tit-for-Tat (ASTFT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.window_size = 5
        self.moving_average = self._calculate_moving_average
        self.previous_total_consumptions = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.previous_total_consumptions) < self.window_size:
            return Action.C
        average_consumption = self._calculate_average_consumption(history)
        threshold = self.moving_average(average_consumption, self.window_size)
        if state.current_stock / self.game_description.capacity > threshold:
            return Action.C
        return Action.D

    def _calculate_average_consumption(self, history: PlayerHistory) -> float:
        if not len(self.previous_total_consumptions):
            total_consumption = sum([row.sum() for row in history.opponent_actions]) / self.game_description.n_players
            self.previous_total_consumptions.append(total_consumption)
            return total_consumption
        self.previous_total_consumptions.pop(0)
        self.previous_total_consumptions.append(sum([row.sum() for row in history.opponent_actions]))
        return np.mean(self.previous_total_consumptions)

    def _calculate_moving_average(self, data: NDArray[np.float64], window_size: int) -> float:
        return np.convolve(data, np.ones((window_size,)), mode='valid') / window_size

class Strategy_COLLECTIVE_93(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)
    Summary: A strategy that reciprocates opponent's actions while promoting long-term cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = PlayerHistory(my_actions=None, my_payoffs=None, opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros(game_description.n_rounds, dtype=float))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.opponent_history = history
        if state.round_number == 0:
            return Action.C
        cooperators = self.opponent_history.opponent_actions[-1, :].sum()
        if cooperators >= self.game_description.n_players - 1:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_94(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for the Common Pool Resource Game.
    This strategy cooperates initially and then responds to the opponent's actions from the previous round. If the opponent cooperated in the last round, the ATFT will cooperate; if the opponent defected, the ATFT will defect as well.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.last_opponent_action is None:
            self.last_opponent_action = history.opponent_actions[state.round_number - 1, :].mean()
        opponent_cooperated_last_round = self.last_opponent_action > 0.5
        return Action(int(opponent_cooperated_last_round))

class Strategy_COLLECTIVE_95(BaseStrategy):
    """
    A strategy that follows Tit-for-Tat with Growth Adaptation in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_punishment_duration = 0
        self.opponent_cooperation_history = []
        self.player_id = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or len(history.opponent_actions) == 0:
            self.min_punishment_duration = self.game_description.n_rounds
            return Action.C
        self.player_id = len(history.opponent_actions[0]) - 1
        opponent_cooperation_this_round = history.opponent_actions[-1][self.player_id]
        self.opponent_cooperation_history.append(opponent_cooperation_this_round)
        if state.round_number == 1:
            return Action.C
        cooperation_count = sum(self.opponent_cooperation_history[:-1])
        punishment_duration = self.min_punishment_duration - (state.round_number - 1)
        if opponent_cooperation_this_round and cooperation_count > self.game_description.n_players // 2:
            return Action.C
        elif not opponent_cooperation_this_round:
            return Action.D
        else:
            return Action.D if punishment_duration > 0 else Action.C

    def min_punishment_duration_adjustment(self, history):
        average_payoff = np.mean(history.my_payoffs)
        current_stock_per_player = state.current_stock / self.game_description.n_players
        if current_stock_per_player >= average_payoff:
            return self.min_punishment_duration
        else:
            return len(self.opponent_cooperation_history)

class Strategy_COLLECTIVE_96(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.critical_stock = 0.5 * self.capacity
        self.punishment_threshold = self.game_description.n_players // 2
        self.forgiveness_period = self.r // self.n
        self.cooperation_count = 0
        self.opponent_actions = []
        self.current_round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if history is not None and self.current_round > 0:
            last_round = len(history.opponent_actions) - 1
            if last_round >= 0:
                last_round_action = history.opponent_actions[last_round, 0]
                if last_round_action == Action.C:
                    action = Action.C
                    self.cooperation_count += 1
                elif last_round_action == Action.D:
                    if self.cooperation_count >= self.punishment_threshold:
                        self.escalating_defection()
                        action = Action.D
                    else:
                        action = Action.D
        elif history is None and state.round_number == 0:
            action = Action.C
        return action

    def opponent_action(self, your_action: Action):
        self.opponent_actions.append(your_action)

    def escalating_defection(self):
        if self.cooperation_count >= self.punishment_threshold and state.current_stock <= self.critical_stock:
            self.punishment_threshold *= 1.5
            self.forgiveness_period *= 2

    def current_round(self):
        return self.current_round + 1

class Strategy_COLLECTIVE_97(BaseStrategy):
    """
    The Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.forgiveness = math.ceil(game_description.n_rounds / 3)
        self.depletion_threshold = self.capacity / self.n
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if len(history.opponent_actions) < state.round_number + 1:
            history.opponent_actions = np.pad(history.opponent_actions, ((state.round_number - len(history.opponent_actions), 0), (0, self.n)))
            history.opponent_payoffs = np.full((state.round_number + 1, self.n), 0)
        if state.round_number == 1:
            return Action.C
        last_opponent_action = history.opponent_actions[state.round_number - 1, (history.my_actions[-1] + 1) % self.n]
        if state.current_stock < self.depletion_threshold and state.round_number > self.forgiveness:
            return Action.C
        elif last_opponent_action:
            return Action.C
        elif state.round_number <= self.forgiveness or last_opponent_action != history.opponent_actions[state.round_number - self.forgiveness - 1, (history.my_actions[-self.forgiveness - 1] + 1) % self.n]:
            return Action.C
        else:
            return Action.D
        self.history = PlayerHistory(np.array([history.my_actions, np.zeros(state.round_number + 1)]), np.zeros(state.round_number + 1), history.opponent_actions, np.zeros(state.round_number + 1)) if state.round_number > 0 else None
        return self.history.my_actions[-1]

class Strategy_COLLECTIVE_98(BaseStrategy):
    """Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number > self.game_description.n_rounds - 1:
            return Action.C
        if history is not None:
            cooperators = sum(history.opponent_actions[-1, :])
            self.last_round_cooperators = cooperators
        strategy = Action.C
        if self.last_round_cooperators >= self.game_description.n_players // 2:
            strategy = Action.C
        elif self.last_round_cooperators < (self.game_description.n_players - 3) // 2:
            strategy = Action.D
        return strategy

class Strategy_COLLECTIVE_101(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (A-TFT)
    Strategy that encourages mutual trust among players to sustain common resources.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_threshold = int(self.game_description.n_players * 0.5)
        self.my_actions = np.array([False] * (self.game_description.n_rounds + 1))
        self.my_payoffs = np.zeros(self.game_description.n_rounds + 1, dtype=np.float64)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if not history:
            return Action.C
        if state.round_number == history.my_actions.shape[0]:
            if history.opponent_actions[-1, -1] == Action.C:
                self.my_actions[-1] = True
            elif len([i for i in range(1, len(history.opponent_actions)) if np.all(history.opponent_actions[i] == False)]) <= self.forgiveness_threshold:
                self.my_actions[-1] = True
            else:
                self.my_actions[-1] = False
        elif state.round_number > history.my_actions.shape[0] and history.opponent_actions[-1] == Action.C:
            self.my_actions[-2] = True
        elif state.round_number > history.my_actions.shape[0] and len([i for i in range(1, len(history.opponent_actions)) if np.all(history.opponent_actions[i] == False)]) <= self.forgiveness_threshold:
            self.my_actions[-2] = True
        elif state.round_number > history.my_actions.shape[0] and len([i for i in range(1, len(history.opponent_actions)) if np.all(history.opponent_actions[i] == False)]) > self.forgiveness_threshold:
            self.my_actions[-2] = False
        else:
            self.my_actions[state.round_number - 1] = history.opponent_actions[state.round_number - 1, -1]
        return Action(int(self.my_actions[state.round_number]))

class Strategy_COLLECTIVE_102(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Stock Awareness (TFT-SA) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainable_consumption = (self.game_description.capacity - 2 * self.game_description.n_players) / (2 * self.game_description.n_players * (self.game_description.n_players - 1))
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_round:
            return Action.C
        consumption_sum = np.sum(history.opponent_actions[:, :self.game_description.n_players].flatten())
        if state.round_number < self.game_description.n_rounds - 1:
            consumption_average = consumption_sum / state.round_number
            if consumption_average < self.sustainable_consumption:
                return Action.C
            else:
                return Action.D
        else:
            self.last_round = True
            if consumption_sum < self.game_description.capacity - 2 * self.game_description.n_players:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_103(BaseStrategy):
    """
    A class implementing the Adaptive Tit-for-Tat (ATFT) strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history = history if history else PlayerHistory(my_actions=np.zeros(self.game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(self.game_description.n_rounds, dtype=float), opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=float))
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        last_opponent_action = self.history.opponent_actions[-1, (self.history.my_actions[-1] + 1) % 2]
        return Action(int(last_opponent_action)) if last_opponent_action else Action.D

class Strategy_COLLECTIVE_104(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptations for the Common Pool Resource Game.
    This strategy cooperates in the first round, and then adapts its actions based on the opponent's previous move.
    If the opponent cooperates, it will also cooperate. If the opponent defects, it will defect to punish but return to cooperation in the next round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_opponent_action is None:
            return Action.C
        self.last_opponent_action = np.mean(history.opponent_actions[-1, :])
        return Action(int(self.last_opponent_action))

class Strategy_COLLECTIVE_105(BaseStrategy):
    """
    Tit-for-Tat-Growing (TFT-G) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds_played = 0
        self.forgiveness_factor = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.rounds_played += 1
        if state.round_number == 0 and history is None:
            return Action.C
        last_round = state.round_number - 1
        opponent_action = history.opponent_actions[last_round, 0] if history else None
        if opponent_action is None:
            return Action.C
        self.update_forgiveness_factor()
        if opponent_action:
            return Action.C
        elif state.current_stock + self.forgiveness_factor >= self.game_description.capacity / self.game_description.n_players:
            return Action.C
        else:
            return Action.D

    def update_forgiveness_factor(self):
        if self.rounds_played < self.game_description.n_players + 1:
            forgiveness_factor = 0.9 * (self.rounds_played / self.game_description.n_players)
        else:
            forgiveness_factor = 0.5
        self.forgiveness_factor = min(forgiveness_factor, 1 - self.rounds_played / self.game_description.n_rounds)

class Strategy_COLLECTIVE_106(BaseStrategy):
    """
    Strategy: Adaptive Tit-for-Tat (ATFT)
    Strategy Description: Cooperate in the first round, mirror opponent's actions from previous rounds, delay response by 1 round when switching strategies, and cooperate in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round_history.append(state.round_number)
        last_round = len(self.round_history) - 1
        current_round = state.round_number
        if current_round < self.game_description.n_rounds:
            if last_round > 0 and history.my_actions[last_round - 1]:
                return Action.C
            elif history.my_actions[-1] and state.current_stock < self.game_description.capacity * (2 * self.game_description.n_players - 1):
                return Action.D
        if current_round == self.game_description.n_rounds:
            return Action.C
        return 'DelayedResponse'

class Strategy_COLLECTIVE_108(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFS)
    Description: Cooperates initially, retaliates when defected against, and forgives if cooperation is resumed.
                 Promotes long-term cooperation with adaptive behavior based on the total stock depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_stock_depletion = 0
        self.average_consumption = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.C
        if history is not None:
            total_consumption = np.sum(history.my_actions * self.game_description.capacity / (2 * self.game_description.n_players))
            self.total_stock_depletion += total_consumption
            if total_consumption < self.average_consumption:
                action = Action.C
            else:
                for round_num in reversed(range(1, state.round_number)):
                    if history.opponent_actions[state.round_number - round_num - 1, 0] == Action.C:
                        action = Action.C
                        break
                else:
                    self.total_stock_depletion = 0
                    punishment_length = min(3, state.round_number) if total_consumption >= 2 * self.average_consumption else 1
                    for _ in range(punishment_length):
                        action = Action.D
        return action

class Strategy_COLLECTIVE_110(BaseStrategy):
    """
    Tit-for-Tat Adaptive Strategy (TFTA) for Common Pool Resource Game.
    A simple yet adaptive strategy that encourages long-term cooperation with other strategies,
    while being prepared to retaliate when necessary in response to defections from opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_number = 0
        self.history = PlayerHistory(my_actions=np.zeros((1,), dtype=bool), my_payoffs=np.zeros((1,), dtype=float), opponent_actions=np.zeros((self.game_description.n_players, 1)), opponent_payoffs=np.zeros((self.game_description.n_players, 1)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history = PlayerHistory(my_actions=np.zeros((1,), dtype=bool), my_payoffs=np.zeros((1,), dtype=float), opponent_actions=np.zeros((self.game_description.n_players, 1)), opponent_payoffs=np.zeros((self.game_description.n_players, 1)))
            self.round_number += 1
            return Action.C if self.round_number == 1 else None
        self.history = history
        self.round_number += 1
        opponent_cooperated = sum(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2
        if self.round_number == self.game_description.n_rounds:
            return Action.C
        if state.current_stock <= 2 * self.game_description.n_players:
            return Action.C
        if opponent_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_111(BaseStrategy):
    """
    Implementation of the TFTC strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = int(game_description.n_players / 2)
        self.ct_decrease_percentage = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1])
        if cooperators > self.cooperative_threshold:
            self.cooperative_threshold = max(self.cooperative_threshold * (1 - self.ct_decrease_percentage), self.game_description.n_players // 2)
            return Action.C
        elif self.cooperative_threshold > self.game_description.n_players:
            if not all(history.opponent_actions[-1]):
                self.cooperative_threshold -= 1
            return Action.D
        else:
            self.cooperative_threshold = self.game_description.n_players // 2
            return Action.C

class Strategy_COLLECTIVE_112(BaseStrategy):
    """
    Adaptive Resource Conservation (ARC) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity / self.game_description.n_players
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C if random.random() < 0.5 or state.current_stock >= self.capacity else Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action.D if state.current_stock <= 0 else Action.C
        if self.history is not None:
            cooperators = sum(self.history.opponent_actions[-1, :])
            return Action.C if state.current_stock >= self.capacity or cooperators >= self.game_description.n_players // 2 else Action.D
        else:
            return Action.C if state.current_stock >= self.capacity else Action.D

class Strategy_COLLECTIVE_113(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Stock Awareness (TFT-ASA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.survival_threshold = 2 * self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        consumption = np.sum(history.my_actions if history else [Action.C])
        stock = state.current_stock if state.round_number > 0 else self.capacity
        if stock <= self.survival_threshold:
            if consumption > min(stock, stock / 2):
                return Action.D
            cooperators = np.sum(history.opponent_actions[-1] == Action.C)
            return (cooperators >= self.n_players or consumption < stock) and Action.C or Action.D
        if consumption < stock / 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_114(BaseStrategy):
    """
    This strategy follows the Tit-for-Tat with Adaptive Cooperation approach.
    It cooperates if the opponent cooperated in the previous round, and defects otherwise.
    If there is no history or the opponent's action from the previous round is unknown, it will cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or len(history.opponent_actions) < state.round_number:
            self._opponent_action = None
            return Action.C
        self._opponent_action = history.opponent_actions[state.round_number - 1, 0]
        if self._opponent_action:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_115(BaseStrategy):
    """
    Titan Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity - self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if state.current_stock > self.capacity * (self.game_description.n_players / (self.game_description.n_players + 1)) else Action.D
        return Action.C if state.current_stock > self.capacity * (self.game_description.n_players / (self.game_description.n_players + 1)) else Action.D

class Strategy_COLLECTIVE_116(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy in Common Pool Resource Game.
    Strategy fosters cooperation by starting with cooperation and punishing defection.
    It encourages other players to maintain long-term mutual benefits rather than short-term gains at the expense of the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0
        self.is_last_round = False
        self.is_depleted = False
        self.remaining_stock_for_growth = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        self.last_round_cooperators = sum(history.opponent_actions[-1]) if history is not None else 0
        self.is_last_round = state.round_number == self.game_description.n_rounds - 1
        self.is_depleted = state.current_stock == 0
        self.remaining_stock_for_growth = state.current_stock if self.is_depleted else 0
        if state.round_number == 0:
            return action
        if self.last_round_cooperators >= self.game_description.n_players // 2:
            pass
        else:
            action = Action.D
        if self.is_last_round:
            if state.current_stock >= 2 * self.game_description.n_players:
                action = Action.C
        elif self.is_depleted:
            if self.remaining_stock_for_growth >= 2 * self.game_description.n_players:
                action = Action.C
        return action

class Strategy_COLLECTIVE_117(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT)
    This strategy uses a simple reciprocity approach, cooperating when opponents cooperate and defecting when they defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.opponent_history:
            self.opponent_history.append(Action.C if history is None else history.opponent_actions[state.round_number - 1, 0])
        current_opponent_action = Action.C if state.round_number == 1 else self.opponent_history[-1]
        return current_opponent_action if current_opponent_action == Action.C else Action.D

class Strategy_COLLECTIVE_118(BaseStrategy):
    """
    An adaptive Tit-for-Tat strategy player for the Common Pool Resource Game.
    The strategy cooperates when resources are abundant and enforces conservation when they become scarce, promoting fair distribution of resources among all players while ensuring the resource pool remains viable for future rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        total_payoff = np.sum(history.my_payoffs[:state.round_number])
        if total_payoff > 0 or state.current_stock >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_119(BaseStrategy):
    """
    Adaptive Stock-Based Tit-for-Tat (AS-TFT) Strategy for the Common Pool Resource Game.
    This strategy mimics opponent's actions to encourage mutual cooperation, while focusing on resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_stock = self.game_description.capacity / self.game_description.n_players
        self.min_sustainable_stock = 2 * self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0 or (history is not None and len(history.opponent_actions) == 0):
            action = Action.C
        elif state.current_stock < self.min_sustainable_stock:
            action = Action.D
        elif state.current_stock > self.average_stock:
            action = Action.C
        elif history is not None and len(history.opponent_actions) > 0:
            opponent_action = history.opponent_actions[-1, (self.game_description.n_players - 1) % self.game_description.n_players]
            action = Action.C if opponent_action else Action.D
        return action

class Strategy_COLLECTIVE_120(BaseStrategy):
    """
    An Adaptive Tit-for-Tat Strategy for the Common Pool Resource Game.
    This strategy promotes a balance between cooperation and competition while adapting to a wide range of opponent behaviors.
    It encourages reciprocal behavior, fosters trust, and supports sustainable resource management.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number < self.game_description.n_rounds:
            if np.all(history.opponent_actions[:, -1]):
                return Action.C
            else:
                return Action.D
        elif self.stock == 0:
            return Action.C
        elif np.all(history.opponent_actions[:, -1]):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_121(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = int(game_description.n_rounds * 0.9)
        self.d = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        opponent_actions_last_round = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players)
        if round_number == 0:
            return Action.C
        elif round_number < self.game_description.n_rounds - self.k * self.d:
            return Action.D if opponent_actions_last_round[-1] == Action.D else Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_122(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFTSA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.optimal_stock = game_description.capacity / game_description.n_players
        self.history = PlayerHistory(None, np.zeros(1), None, np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == len(history.my_actions):
            return Action.C
        total_consumption = np.sum(history.my_actions[-1]) * (self.game_description.n_players / 2)
        if total_consumption > 2 * self.game_description.n_players:
            return Action.D
        if total_consumption <= self.optimal_stock and state.current_stock >= self.optimal_stock:
            return Action.C
        return history.my_actions[-1][self.__class__.__name__.replace('Strategy', '')]

class Strategy_COLLECTIVE_124(BaseStrategy):
    """Adaptive Tit-for-Tat strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = self.game_description.capacity / (2 * game_description.n_players + 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        if state.round_number == last_round + 1:
            if history.my_actions[last_round] != history.opponent_actions[last_round][0]:
                return Action.D
        last_opponent_action = history.opponent_actions[last_round][0]
        if state.current_stock < self.stock_threshold:
            return Action.D
        elif last_opponent_action == Action.C:
            return Action.C
        else:
            return Action.D

    def consume_stock(self, state: CommonPoolState, action: Action) -> float:
        """Consume stock based on action and return total consumption"""
        n = self.game_description.n_players
        if action == Action.C:
            return state.current_stock / (2 * n)
        return state.current_stock / n

    def update_state(self, state: CommonPoolState, total_consumption: float) -> CommonPoolState:
        """Update the state of the common pool resource game"""
        stock = max(0, state.current_stock - total_consumption)
        growth = 2 * stock * (1 - stock / self.game_description.capacity)
        return CommonPoolState(state.round_number + 1, min(self.game_description.capacity, stock + growth))

class Strategy_COLLECTIVE_126(BaseStrategy):
    """
    An implementation of Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock <= self.capacity / 3:
            return Action.D
        if state.current_stock > self.capacity * 0.5:
            return Action.C
        if history.my_actions[-1]:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_127(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game (ATFT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or len(history.opponent_actions) == 0:
            return Action.C
        if state.round_number < self.game_description.n_rounds - 1:
            previousActionOfOpponent = sum(history.opponent_actions[-1]) > 0
            return Action.C if previousActionOfOpponent else Action.D
        totalPayoffs = np.sum(history.my_payoffs)
        if totalPayoffs > (self.capacity - self.stock) / 2 * self.n_players:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_128(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history = PlayerHistory(np.zeros(state.round_number + 1, dtype=bool), np.zeros(state.round_number + 1), np.zeros((state.round_number + 1, self.game_description.n_players), dtype=bool), np.zeros(state.round_number + 1))
            return Action.C
        round_number = state.round_number
        if round_number == self.game_description.n_rounds or (history.my_actions[-1] != Action.D and round_number < self.game_description.n_rounds):
            self.history.my_payoffs[-1] = state.current_stock / (2 * self.game_description.n_players)
            return Action.C
        if round_number == 0:
            self.history.my_actions[0] = True
            self.history.my_payoffs[0] = state.current_stock / (2 * self.game_description.n_players)
            return Action.C
        opponent_action = history.opponent_actions[-1, 0] if round_number == 1 else history.opponent_actions[-1, 1]
        self.history.my_actions[round_number] = Action.C if opponent_action else Action.D
        if opponent_action:
            self.history.my_payoffs[round_number] = state.current_stock / (2 * self.game_description.n_players)
        else:
            self.history.my_payoffs[round_number] = state.current_stock / self.game_description.n_players
        if round_number > 2 and len(history.opponent_actions[-2]) >= 2 and history.opponent_actions[-2, 1]:
            probability_cooperate = 1 - (round_number - 2) / self.game_description.n_rounds
            if random.random() <= probability_cooperate:
                self.history.my_actions[round_number] = Action.C
        return self.history.my_actions[-1]

class Strategy_COLLECTIVE_129(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game
    Strategy Description: An adaptive strategy that cooperates in the first round and mimics opponents' actions from the previous round in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.accumulated_payoffs = np.zeros(game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        if not history or state.round_number >= len(history.opponent_actions):
            return np.random.choice([Action.C, Action.D])
        opponent_action = history.opponent_actions[-1, -self.__class__.n] if state.round_number > 0 else None
        if opponent_action is None or np.all(history.opponent_actions[:, -state.round_number] == history.my_actions[:, -state.round_number]):
            return np.random.choice([Action.C, Action.D])
        last_payoff = history.my_payoffs[-1] if state.round_number > 0 else 0
        if last_payoff > 0 and opponent_action == Action.C:
            return Action.C
        elif last_payoff < 0 and opponent_action == Action.D:
            return Action.D
        cooperators = np.sum(history.opponent_actions[:, -state.round_number])
        if cooperators > self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_132(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_stock = None
        self.last_opponent_action = Action.D

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            stock = self.last_round_stock or state.current_stock
            if stock == 0:
                return Action.C
            elif history.opponent_actions[-1][-1] == Action.C:
                self.last_opponent_action = Action.C
                return Action.C
            else:
                self.last_opponent_action = history.opponent_actions[-1][-1]
                return Action.D
        self.last_round_stock = state.current_stock
        self.last_opponent_action = history.opponent_actions[-1][-1]

class Strategy_COLLECTIVE_133(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    This strategy starts with cooperation, copies opponent's actions from the previous round,
    and retaliates against defection while also considering a switch to an aggressive strategy
    when necessary to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 2 * game_description.n_players // 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < self.threshold:
            return Action.D
        opponent_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        cooperators = sum(opponent_actions)
        return Action(cooperators >= self.game_description.n_players // 2)

class Strategy_COLLECTIVE_136(BaseStrategy):
    """
    A simple Tit-for-Tat strategy for the Common Pool Resource Game.
    This strategy cooperates in the first round, then mimics the opponent's action from the previous round.
    In the last round and when encountering an unknown strategy, it cooperates to promote cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number - 1
        if current_round == self.game_description.n_rounds - 1:
            return Action.C
        opponent_action = history.opponent_actions[current_round, 0]
        self.last_opponent_action = opponent_action
        return Action(int(self.last_opponent_action == Action.C))

class Strategy_COLLECTIVE_137(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.opponent_history:
            self.opponent_history = PlayerHistory(np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        last_round = len(self.opponent_history.my_actions) - 1
        if last_round >= 1 and self.opponent_history.opponent_actions[last_round, -1] == Action.C:
            return Action.C
        elif self.opponent_history.opponent_actions[last_round - 1, -1] == Action.C:
            return Action.C
        else:
            return Action.D

    def update_history(self, payoff: float, opponent_action: bool) -> None:
        self.opponent_history.my_payoffs[-1] = payoff
        self.opponent_history.opponent_actions[-1, -1] = opponent_action

class Strategy_COLLECTIVE_139(BaseStrategy):
    """
    Tit-for-Tat Strategy for the Common Pool Resource Game.
    Cooperates with opponents in the first round, mimics their last move thereafter.
    In the final round, evaluates history to determine whether cooperation or defection will yield a higher total payoff over all rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._last_round = None
        self._cooperative_count = 0
        self._defective_count = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self._update_history(state, history)
        action = Action.D
        if not self._last_round or self._cooperative_count > self._defective_count:
            action = history.opponent_actions[-1][-1]
        if state.round_number == self.game_description.n_rounds:
            if self._cooperative_count > (self.game_description.n_rounds - self._defective_count) // 2:
                action = Action.C
        return action

    def _update_history(self, state: CommonPoolState, history: PlayerHistory):
        if self._last_round is not None and state.round_number != self._last_round + 1:
            self._cooperative_count = sum(history.my_actions[:self._last_round])
            self._defective_count = len(history.my_actions) - self._cooperative_count
        self._last_round = state.round_number

class Strategy_COLLECTIVE_140(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and (not history):
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            if state.current_stock < self.game_description.capacity / self.game_description.n_players:
                return Action.D
            else:
                return Action.D
        opponent_actions = history.opponent_actions[-1, :] if history else np.zeros(self.game_description.n_players)
        cooperators = sum(opponent_actions)
        if cooperators > len(opponent_actions) // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_141(BaseStrategy):
    """
    Adaptive Fitness-based Stock Conservation (AFSC) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.D
        total_consumption = np.sum(history.my_actions) * self.game_description.n_players
        remining_stock = self.capacity - total_consumption
        t = state.round_number + 1
        r = self.game_description.n_rounds
        T = remining_stock * self.capacity / ((r - t) * (2 * self.n_players))
        if history is not None and state.current_stock > T:
            if state.current_stock > T and (r - t) * (2 * self.n_players) <= remining_stock / self.n_players:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_142(BaseStrategy):
    """Adaptive Tit-for-Tat Strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_history = history.opponent_actions
        cooperators = sum(self.opponent_history[-1])
        current_stock = math.ceil(state.current_stock)
        if current_stock >= 2 * self.game_description.n_players:
            return Action.C if self.opponent_history[-1][-1] == Action.C else Action.D
        return Action.D

class Strategy_COLLECTIVE_143(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.N = 3 * self.n
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        else:
            round_number = state.round_number - 1
            opponent_action = history.opponent_actions[round_number, 0]
            is_last_round = round_number == self.r - 1
            is_after_N_defections = round_number >= self.N
            if is_last_round or is_after_N_defections:
                return Action.C
            elif opponent_action:
                self.last_opponent_action = opponent_action
                return Action.C
            elif not self.last_opponent_action or self.last_opponent_action != opponent_action:
                self.last_opponent_action = opponent_action
                return Action.D
            else:
                self.last_opponent_action = opponent_action
            if round_number < self.r // 10:
                return Action.C

class Strategy_COLLECTIVE_144(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth (ATFSG) strategy for Common Pool Resource Games
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_level = 2 * game_description.n_players
        self.last_round = game_description.n_rounds - 1
        self.opponents_cooperated = [False] * game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.last_round:
            return Action.C
        current_stock = math.floor(state.current_stock)
        if current_stock < self.critical_level:
            return Action.C
        opponents_cooperated_this_round = sum(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2
        self.opponents_cooperated[-1] = opponents_cooperated_this_round
        return self._decide_action(self.opponents_cooperated)

    def _decide_action(self, opponents_cooperated):
        if all(opponents_cooperated):
            return Action.C
        if any((not opponents_cooperated[i - 1] and opponents_cooperated[i] for i in range(1, len(opponents_cooperated)))):
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_145(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None
        self.rounds_since_last_cooperation = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history = history if history is not None else PlayerHistory(np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros((1, self.game_description.n_players)))
        opponent_action_last_round = sum(self.history.opponent_actions[-1, :])
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        if opponent_action_last_round > (self.game_description.n_players - 1) // 2 and state.round_number > 0:
            self.rounds_since_last_cooperation = 0
            return Action.C
        if opponent_action_last_round == self.game_description.n_players - 1:
            self.rounds_since_last_cooperation += 1
            if self.rounds_since_last_cooperation < self.game_description.n_rounds:
                return Action.C
        self.rounds_since_last_cooperation = 0
        return Action.D

class Strategy_COLLECTIVE_146(BaseStrategy):
    """
    Folk Theorem Compliant Adaptive Strategy (FTCAS) for Common Pool Resource Game.
    A strategy that balances cooperation and defection based on current game state and history to maximize payoff in the long run while maintaining collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p = 0.5
        self.n = self.game_description.n_players
        self.capacity = self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C if random.random() < self.p else Action.D
        stock = state.current_stock
        if stock > 2 * self.n:
            action = Action.C
        elif stock < self.n:
            action = Action.D
        else:
            actions = history.opponent_actions[-1] if history is not None else np.zeros(self.n, dtype=bool)
            cooperation = sum(actions)
            if cooperation >= self.n // 2:
                action = Action.C
            elif cooperation < self.n // 2:
                action = Action.D
            else:
                action = actions[state.round_number - 1] if len(history) > 0 else np.random.choice([Action.C, Action.D])
        return action

class Strategy_COLLECTIVE_148(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    Strategy Description: Cooperates initially and punishes defection while adapting to opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.strategy = 'Cooperate'
        self.current_round = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            self.strategy = 'Cooperate'
            self.current_round += 1
            return Action.C
        self.current_round += 1
        opponent_cooperation_last_round = sum(history.opponent_actions[-1])
        if opponent_cooperation_last_round >= self.game_description.n_players // 2:
            return Action.C
        elif self.strategy == 'Cooperate':
            self.strategy = 'Defect'
            return Action.D
        else:
            self.strategy = 'Cooperate'
            return Action.C

class Strategy_COLLECTIVE_149(BaseStrategy):
    """
    An adaptive cooperative Tit-for-Tat (ACT4T) strategy for the Common Pool Resource Game.
    This strategy fosters a collaborative environment that encourages cooperation among opponents, promoting sustainable resource management.
    The strategy is adaptive to various opponent behaviors, as it punishes defections while remaining willing to cooperate upon the opponent's return to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = -1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.last_round = state.round_number - 1
        opponent_action_last_round = history.opponent_actions[self.last_round, 0]
        if opponent_action_last_round:
            return Action.C
        elif state.round_number == self.last_round + 1:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_150(BaseStrategy):
    """
    Tit for Tat Strategy with Stock Awareness in Common Pool Resource Game.
    Balances individual payoff and common pool sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(self.game_description.capacity * 0.5)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        if np.sum(history.opponent_actions[last_round]) == self.game_description.n_players:
            return Action.C
        consumption = np.sum([history.my_actions[t] * (self.game_description.n_players // self.game_description.n_players) if history.my_actions[t] else history.my_actions[t] * (self.game_description.n_players / self.game_description.n_players) for t in range(last_round + 1)])
        stock = state.current_stock - consumption
        if stock <= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_151(BaseStrategy):
    """
    A simple Tit-for-Tat Evolutionary Strategy that cooperates initially and responds to opponents' actions in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = int(math.ceil(game_description.n_players / 2))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            recent_cooperators = np.count_nonzero(history.opponent_actions[:, -self.k:].sum(axis=1) == self.game_description.n_players)
            if recent_cooperators >= self.k and history.opponent_actions[-1, :].sum() == self.game_description.n_players:
                return Action.C
            elif recent_cooperators >= self.k:
                return Action.D
            elif recent_cooperators > 0:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COLLECTIVE_152(BaseStrategy):
    """
    Tit-for-Tat Strategy with Adaptive Cooperative Threshold for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = self.game_description.capacity * 0.85
        self.reset_counter = 0
        self.minimum_cooperative_threshold = self.game_description.capacity * 0.35

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = np.mean(history.opponent_actions[-1]) if history else Action.D
        if state.round_number == self.game_description.n_rounds - 1 or state.round_number == 0:
            return Action.C
        if opponent_action:
            return Action.C
        if state.current_stock < self.game_description.capacity * (1 - self.cooperative_threshold):
            return Action.D
        return Action.D if opponent_action else Action.C

    def reset(self):
        self.cooperative_threshold = self.minimum_cooperative_threshold
        self.reset_counter += 1

class Strategy_COLLECTIVE_154(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)
    Strategy Summary: A reciprocal strategy that promotes cooperation by punishing defection and encouraging future cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.opponent_history = history.opponent_actions.flatten().tolist() if history else []
        if len(self.opponent_history) == 0:
            return Action.D
        opponent_last_move = self.opponent_history[-1]
        if state.round_number == self.game_description.n_rounds:
            return opponent_last_move
        if opponent_last_move == Action.C:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_155(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game.
    Cooperates most of the time and punishes defection only when necessary, promoting a more collective outcome in the long run.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_number = 0
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds, dtype=float), opponent_actions=np.full((game_description.n_rounds, game_description.n_players), False), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.round_number = state.round_number
        if history is not None:
            self.history = history
        if state.round_number == 0:
            return Action.C
        last_round = self.round_number == self.game_description.n_rounds - 1 or self.round_number == self.game_description.n_rounds
        second_last_round = self.round_number == self.game_description.n_rounds - 2
        if last_round:
            return Action.C
        elif second_last_round:
            opponent_defected = sum(self.history.opponent_actions[-1]) > 0
            if opponent_defected:
                self.history.my_actions[-2] = True
            else:
                self.history.my_actions[-2] = False
        elif self.round_number > 1 and self.history.opponent_actions[self.round_number - 2].sum() == self.game_description.n_players:
            self.history.my_actions[self.round_number - 2] = True
        else:
            opponent_defected = sum(self.history.opponent_actions[-1]) > 0
            if opponent_defected:
                self.history.my_actions[-1] = True
            else:
                self.history.my_actions[-1] = False
        return Action(int(self.history.my_actions[-1]))

class Strategy_COLLECTIVE_156(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game

    Strategy Summary:
    Aims to foster a cooperative environment by punishing defection and rewarding cooperation.
    Encourages long-term resource sustainability through reciprocity while being responsive to opponents' actions and the current state of resources.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_stock_level = 2 * self.game_description.n_players - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == len(history.my_actions):
            return Action.C
        last_round = len(history.my_actions) - 1
        last_opponent_action = history.opponent_actions[last_round, state.round_number % self.game_description.n_players]
        if state.current_stock >= self.min_stock_level:
            if last_opponent_action:
                return Action.C
            elif last_round >= 1 and history.my_actions[last_round] == Action.C and (history.opponent_actions[last_round, state.round_number % self.game_description.n_players] == Action.D):
                return Action.D
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_157(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity // 2
        self.first_round = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            self.first_round = True
            return Action.C
        elif state.round_number == 0:
            self.first_round = False
        if self.first_round or (state.current_stock / self.game_description.capacity < 0.5 and state.round_number != self.game_description.n_rounds):
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_159(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    This strategy reciprocates cooperation and punishes defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperated_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.opponent_cooperated_last_round = True
            return Action.C
        opponent_action = history.opponent_actions[-1, self.get_opponent_index()] if history is not None else None
        self.opponent_cooperated_last_round = bool(opponent_action)
        return Action.C if self.opponent_cooperated_last_round else Action.D

    def get_opponent_index(self):
        """
        Return the index of this strategy's opponent in a history object.
        """
        return 1 if self.__class__.__name__ == 'AdaptiveTitForTatStrategy' else 0

class Strategy_COLLECTIVE_160(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(self.game_description.capacity * 0.5)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number < self.game_description.n_rounds:
            opponent_actions = history.opponent_actions[-1, :]
            last_round_action = np.where(opponent_actions == 1)[0][-1] if np.any(opponent_actions) else -1
            if last_round_action != -1:
                return Action(int(opponent_actions[last_round_action]))
        current_stock = state.current_stock
        total_players = self.game_description.n_players
        if state.round_number == self.game_description.n_rounds and current_stock < self.threshold:
            return Action.D
        elif state.round_number != 0 and current_stock >= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_161(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFT-SA) strategy for the Common Pool Resource Game.
    Promotes cooperation and sustainable usage of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.cooperation_threshold is None:
            self.cooperation_threshold = self.game_description.capacity * (self.game_description.n_players - 1) / (self.game_description.n_players * state.round_number)
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if cooperators >= self.game_description.n_players // 2:
            stock = state.current_stock
            if stock < self.cooperation_threshold:
                return Action.D
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_162(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.empty((1,), dtype=bool), my_payoffs=np.empty((), dtype=np.float64), opponent_actions=np.empty((self.game_description.n_players, 0), dtype=bool), opponent_payoffs=np.empty((self.game_description.n_players, 1), dtype=np.float64))
        self.round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.round += 1
        if state.round_number == 0 or np.sum(history.opponent_actions[:, -1]) < self.game_description.capacity // (2 * self.game_description.n_players):
            return Action.C
        else:
            return Action.D

    def update_state(self, state: CommonPoolState, my_action: Action, opponent_actions: NDArray[np.bool_], payoffs: NDArray[np.float64]):
        self.history = PlayerHistory(my_actions=np.vstack((self.history.my_actions, np.array([[my_action]], dtype=bool))), my_payoffs=np.hstack((self.history.my_payoffs, np.array([payoffs[0]], dtype=np.float64))), opponent_actions=np.vstack((self.history.opponent_actions, opponent_actions)), opponent_payoffs=np.vstack((self.history.opponent_payoffs, payoffs[1:])))

class Strategy_COLLECTIVE_163(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            self.last_opponent_action = None
            return Action.C
        self.last_opponent_action = np.mean(history.opponent_actions[-1, :])
        return Action(int(self.last_opponent_action)) if self.last_opponent_action is not None else Action.C

class Strategy_COLLECTIVE_164(BaseStrategy):
    """
    A strategy that follows the Adaptive Tit-for-Tat approach in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = len(history.my_actions) - 1
        last_round_state = CommonPoolState(last_round, history.my_payoffs[-1])
        if state.round_number == last_round:
            return self._last_round_decision(last_round_state, history)
        return self._regular_round_decision(last_round_state, history)

    def _last_round_decision(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.current_stock == 0:
            return Action.D
        else:
            return self._regular_round_decision(state, history)

    def _regular_round_decision(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if history.my_actions[-1]:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_165(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_player = 0
        self.history = PlayerHistory(my_actions=np.empty((1, 0), dtype=bool), my_payoffs=np.empty(0), opponent_actions=np.empty((self.game_description.n_players + 1, 0), dtype=bool), opponent_payoffs=np.empty(0))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.history = history
            self.current_player = (self.current_player + 1) % self.game_description.n_players
        if state.round_number == 0:
            return Action.C
        opponent_actions = self.history.opponent_actions[:, self.current_player - 1]
        cooperators = sum(opponent_actions)
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_166(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        last_stock = state.current_stock + 2 * state.current_stock * (1 - state.current_stock / self.capacity)
        cooperators = sum(history.opponent_actions[-1]) if history else 0
        if cooperators >= self.n // 2 or last_stock > state.current_stock:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_167(BaseStrategy):
    """
    Adaptive Frequency-Based Tit-for-Tat (AFB-TFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.trust_matrix = np.zeros((game_description.n_rounds + 1, game_description.n_players))
        self.initial_trust_threshold = int(math.floor(game_description.n_players * 0.8))
        self.current_round = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            self.trust_matrix[:, :] = np.ones((self.game_description.n_rounds + 1, self.game_description.n_players))
            return Action.C
        self.current_round = state.round_number
        opponent_cooperation = history.opponent_actions[state.round_number - 1].mean()
        if opponent_cooperation >= self.get_trust_threshold():
            return Action.C
        return Action.D

    def get_trust_threshold(self) -> int:
        trust_threshold = self.initial_trust_threshold
        adjustment_factor = (self.game_description.n_rounds - self.current_round) / self.game_description.n_rounds
        return int(math.floor((1 - adjustment_factor) * self.initial_trust_threshold + adjustment_factor))

class Strategy_COLLECTIVE_168(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) with Stock Growth Adjustment (SGAA) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity * 0.5
        self.history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        stock = state.current_stock / self.game_description.n_players
        prev_action = self.history[-1] if self.history else None
        if prev_action is None:
            return Action.C
        elif prev_action == Action.C and stock >= self.capacity or (prev_action != Action.C and stock < self.capacity):
            return prev_action
        else:
            return Action.C if stock >= self.capacity else Action.D

class Strategy_COLLECTIVE_169(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFT-SA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity * 0.9

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(history.opponent_actions) < 2:
            return Action.C
        last_action = history.opponent_actions[-1][-1]
        if state.current_stock >= self.game_description.capacity * self.threshold:
            return Action.C
        elif state.current_stock < self.game_description.capacity * (self.threshold - 0.1):
            return Action.D
        else:
            return last_action

class Strategy_COLLECTIVE_170(BaseStrategy):
    """
    Strategy Name: Adaptive Fitness-Based Tit-for-Tat (AFB-TFT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = int(math.ceil(game_description.n_rounds * 0.9))
        self.m = int(math.ceil(game_description.n_rounds * 0.7))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = 0
        cooperators_in_last_k_rounds = np.sum(history.my_actions[max(state.round_number - self.k, 0):state.round_number]) if history else 0
        if cooperators_in_last_k_rounds / (2 * self.game_description.n_players * self.k) > 1:
            return Action.D
        if not history:
            opponent_actions = np.zeros((state.round_number, self.game_description.n_players), dtype=bool)
        else:
            opponent_actions = history.opponent_actions[:state.round_number]
        number_of_cooperative_rounds_by_opponent = np.sum(opponent_actions[:, -self.m:], axis=1) > self.m
        if number_of_cooperative_rounds_by_opponent[np.argmax(number_of_cooperative_rounds_by_opponent)]:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_171(BaseStrategy):
    """
    Adaptive Resource-Conscious Strategy (ARCS) for the Common Pool Resource Game.
    This strategy encourages conservation of resources and fosters a collective mindset for long-term survival.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds_played = 0
        self.total_stock_depletion = 0.0
        self.average_stock_level = None
        self.critical_threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        self.ct_adjustment_factor = 1.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.rounds_played += 1
        if not history and state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        current_stock = state.current_stock
        history = PlayerHistory(np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        if not self.average_stock_level:
            self.average_stock_level = current_stock
            history.my_actions[self.rounds_played - 1] = True
            return Action.C
        if current_stock > self.critical_threshold:
            action = Action.C
        elif current_stock < self.critical_threshold / 2:
            action = Action.D
        else:
            trend = self._get_trend(history)
            if trend == 'increasing':
                action = Action.C
            elif trend == 'decreasing':
                action = Action.D
            else:
                action = np.random.choice([Action.C, Action.D])
        history.my_actions[self.rounds_played - 1] = action == Action.C
        self.total_stock_depletion += current_stock / (2 * self.game_description.n_players)
        if self.rounds_played > self.game_description.n_rounds // 5:
            self.critical_threshold *= self.ct_adjustment_factor ** ((self.rounds_played - self.game_description.n_rounds // 5) / (self.game_description.n_rounds // 5))
        return action

    def _get_trend(self, history: PlayerHistory) -> str:
        if len(history.my_actions) < self.game_description.n_rounds // 5:
            return 'none'
        average = np.mean(history.my_actions[self.game_description.n_rounds // 5:-1])
        if np.abs(average - history.my_actions[-1][-1]) > 0.5:
            return 'increasing' if average < history.my_actions[-1][-1] else 'decreasing'
        return 'none'

class Strategy_COLLECTIVE_172(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT) for Common Pool Resource Game

    Strategy summary: A cooperative strategy that follows the actions of the opponent from the previous round. In every round, the ATfT strategy cooperates initially and subsequently follows the actions of the opponent from the previous round:
        - If the opponent cooperated in the previous round, the player cooperates in this round.
        - If the opponent defected in the previous round, the player defects in this round. This is a "Tit for Tat" retaliation mechanism, designed to encourage cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []
        self.average_payoff = None
        self.threshold = self.game_description.capacity * 0.1

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        current_round = len(history.opponent_actions) - 1
        last_opponent_action = history.opponent_actions[current_round, 0]
        if self.average_payoff is None:
            self.average_payoff = np.mean(history.my_payoffs[:current_round])
        if last_opponent_action and history.my_payoffs[-1] < self.average_payoff:
            action = Action.D
        elif last_opponent_action:
            action = Action.C
        else:
            action = Action.D
        self.opponent_history.append(last_opponent_action)
        return action

class Strategy_COLLECTIVE_173(BaseStrategy):
    """
    Titan Strategy for Common Pool Resource Game
    Promotes a collective approach by incentivizing cooperation when the common pool resource is plentiful and fostering coordination among players through observing historical player actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_sustainable_stock = game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        if state.current_stock > self.average_sustainable_stock:
            return Action.C
        if state.current_stock <= 0:
            return Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        if state.current_stock > self.average_sustainable_stock and cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_174(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.8 * game_description.capacity
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.history = history
        last_round = len(history.my_actions) - 1
        last_action = history.my_actions[last_round]
        last_stock_level = state.current_stock
        if last_round == state.round_number - 1 and self.history.opponent_payoffs[-1, -1] > 0:
            return Action.C
        if self.history.my_payoffs[last_round] > 0 and last_stock_level < self.threshold:
            return Action.C
        if not last_action:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_175(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game.
    Encourages cooperation by reciprocating the actions of other players and preserving common resources for future use.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or not self.opponent_history:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        opponent_cooperated = np.sum(history.opponent_actions[last_round]) >= self.game_description.n_players // 2
        if opponent_cooperated:
            return Action.C
        return Action.D

    def update_history(self, history: PlayerHistory):
        self.opponent_history = history

class Strategy_COLLECTIVE_176(BaseStrategy):
    """
    Adaptive Stock-Based Tit-for-Tat Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity * 0.8
        self.minimum = self.game_description.capacity * 0.2
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history.my_actions[state.round_number] = True
        stock_level = state.current_stock
        opponent_last_action = self.history.opponent_actions[state.round_number - 1, (self.game_description.n_players - 1) % self.game_description.n_players]
        if stock_level < self.minimum:
            return Action.D
        elif stock_level >= self.threshold and opponent_last_action:
            return Action.C
        elif stock_level >= self.threshold and (not opponent_last_action):
            return Action.D
        elif stock_level < self.threshold and opponent_last_action:
            return Action.D
        else:
            return Action(opponent_last_action)

class Strategy_COLLECTIVE_177(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.T_min = game_description.capacity // 2.5
        self.T_max = int(0.75 * game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if state.round_number == 0 or history is None:
            return Action.C
        stock = state.current_stock
        last_opponent_action = bool(history.opponent_actions[-1][-1])
        if last_opponent_action and stock >= self.T_max:
            return Action.C
        elif last_opponent_action and stock < self.T_min:
            return Action.D
        elif not last_opponent_action and stock > self.T_min:
            return Action.D
        else:
            return Action.C if last_opponent_action else Action.D

class Strategy_COLLECTIVE_178(BaseStrategy):
    """
    A Tit-for-Tat-Growth strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        round_number = state.round_number - 1
        last_action = history.my_actions[round_number]
        stock_growth = self._calculate_stock_growth(state, history)
        if round_number == self.game_description.n_rounds - 1:
            return Action.C
        if stock_growth > self.threshold or stock_growth >= 0:
            return Action.C if last_action else Action.D
        return Action.D if last_action else Action.D

    def _calculate_stock_growth(self, state: CommonPoolState, history: PlayerHistory) -> float:
        consumption = np.sum([history.my_actions[i] * (state.current_stock / self.game_description.n_players if i else 0) for i in range(1, len(history.my_actions))])
        remaining_stock = state.current_stock - consumption
        capacity_remaining = min(self.game_description.capacity, state.current_stock) - remaining_stock
        growth = 2 * remaining_stock * (1 - remaining_stock / capacity_remaining)
        return growth

class Strategy_COLLECTIVE_179(BaseStrategy):
    """
    Implementation of Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 2 * self.game_description.capacity // 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history and state.current_stock < self.cooperation_threshold:
            return Action.C
        previous_round = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players)
        cooperators = sum(previous_round)
        return Action(int(cooperators >= self.game_description.n_players // 2))

class Strategy_COLLECTIVE_181(BaseStrategy):
    """
    Strategy Name: Adaptive Resource Sharing (ARS) Strategy
    Summary: A strategy that adapts its actions based on the average consumption of other players to encourage cooperation and deter defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = None
        self.current_stock = None
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.current_stock = state.current_stock
        self.history = history or PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        if self.average_consumption is None:
            rounds = range(state.round_number)
            total_consumption = sum([history.opponent_actions[r, :].sum() for r in rounds])
            self.average_consumption = total_consumption / len(rounds)
        if self.current_stock <= 0 or self.current_stock >= self.game_description.capacity:
            return Action.C if self.current_stock == 0 else Action.D
        if self.average_consumption < self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.C
        elif self.average_consumption >= self.game_description.capacity / (2 * self.game_description.n_players) and self.average_consumption < self.game_description.capacity / self.game_description.n_players:
            if self.current_stock > self.game_description.capacity / 2:
                return Action.C
            else:
                return Action.D
        elif self.average_consumption >= self.game_description.capacity / self.game_description.n_players:
            return Action.D
        self.history.my_actions[state.round_number] = True
        total_consumption = sum(history.opponent_actions[:, :].sum(axis=0))
        new_stock = max(self.current_stock - total_consumption, 0)
        growth = 2 * new_stock * (1 - new_stock / self.game_description.capacity)
        self.history.my_payoffs[state.round_number] = new_stock / (2 * self.game_description.n_players) if self.history.my_actions[-1] else new_stock / self.game_description.n_players
        self.current_stock = min(new_stock + growth, self.game_description.capacity)

class Strategy_COLLECTIVE_182(BaseStrategy):
    """
    A simple adaptive stock-based cooperation strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        threshold = self.capacity / (2 * self.game_description.n_players * (self.game_description.n_rounds - state.round_number))
        if state.round_number == 0:
            return Action.C if state.current_stock >= threshold else Action.D
        elif state.current_stock >= threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_183(BaseStrategy):
    """
    The Adaptive Stock Conservation strategy encourages cooperation in times of abundance and conservation in scarcity, promoting sustainable behavior for long-term survival.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_per_player = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock >= self.capacity_per_player:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_184(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_game_payoff = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_round_opponents_cooperated = np.sum(history.opponent_actions[last_round, :])
        self.total_game_payoff += history.my_payoffs[-1]
        if state.round_number == self.game_description.n_rounds:
            if self.total_game_payoff > 0 or state.current_stock >= self.game_description.capacity * (self.game_description.n_players - 1):
                return Action.C
            elif self.total_game_payoff < 0:
                return Action.D
        if last_round_opponents_cooperated >= (self.game_description.n_players - 1) // 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_185(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return self.first_round(state)
        else:
            return self.subsequent_rounds(state, history)

    def first_round(self, state: CommonPoolState):
        return Action.C

    def subsequent_rounds(self, state: CommonPoolState, history: PlayerHistory):
        current_action = Action.C
        if state.round_number > 0 and self.defection_counter < self.game_description.n_players:
            opponent_cooperated_last = sum(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2
            current_action = Action.C if opponent_cooperated_last else Action.D
        elif state.round_number > 0 and self.defection_counter == self.game_description.n_players:
            current_action = Action.D
        self.defection_counter += 1 if current_action == Action.D else 0
        return current_action

class Strategy_COLLECTIVE_186(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)
    A strategy that cooperates initially, then responds to opponents' actions in a tit-for-tat fashion. Punishes defection and forgives after one act of punishment. Emphasizes long-term cooperation and forgiveness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        previous_action = self.history.my_actions[-1] if len(self.history.my_actions) > 0 else Action.C
        current_round = state.round_number + 1
        current_action = previous_action if current_round != self.game_description.n_rounds and previous_action == Action.C else Action.D
        self.history.my_actions[-1] = current_action
        self.history.my_payoffs[-1] = state.current_stock / (2 * self.game_description.n_players) if current_action == Action.C else state.current_stock / self.game_description.n_players
        if current_round == self.game_description.n_rounds:
            return Action.C
        next_opponent_action = Action.D if previous_action == Action.C and current_action == Action.D else Action.C if current_action == Action.D and previous_action == Action.C else current_action
        self.history.opponent_actions[-1, :] = np.full(self.game_description.n_players, next_opponent_action == Action.C)
        return current_action

class Strategy_COLLECTIVE_187(BaseStrategy):
    """
    An adaptive tit-for-tat strategy that encourages long-term cooperation among players while being robust against various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(game_description.n_players // 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            last_opponent_actions = history.opponent_actions[-1]
            cooperators = sum(last_opponent_actions)
            if cooperators >= self.threshold and state.round_number != self.game_description.n_rounds - 1:
                return Action.C
            elif cooperators < self.threshold:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_188(BaseStrategy):
    """
    Tit-for-Tat Adaptive (TFT-A) strategy for the Common Pool Resource Game.
    The strategy cooperates unless all players defected in the most recent round or any previous round in history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=None, my_payoffs=None, opponent_actions=np.zeros((1, game_description.n_players), dtype=bool), opponent_payoffs=None)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        elif state.round_number == 0:
            self.history = PlayerHistory(my_actions=np.zeros(1), my_payoffs=np.zeros(1), opponent_actions=np.zeros((1, self.game_description.n_players)), opponent_payoffs=np.zeros(1))
        else:
            self.history = history
            if np.all(self.history.opponent_actions[-1]) == Action.D.value:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_189(BaseStrategy):
    """
    A strategy that encourages cooperation when resources are plentiful and promotes conservation for future rounds. This fosters a sense of shared responsibility among players while still allowing for self-interest when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_stock = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock = state.current_stock if history is None else history.my_payoffs[-1]
        if stock > self.average_stock:
            return Action.C
        elif stock < self.average_stock:
            return Action.D
        else:
            random_choice = random.random()
            if random_choice <= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_190(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for the Common Pool Resource Game.
    This strategy follows a simple and adaptive approach based on previous actions of opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None:
            self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1))
        else:
            self.history = history
        if state.round_number == 0:
            return Action.C
        opponent_actions = self.history.opponent_actions[-self.game_description.n_rounds:, -1]
        cooperation = sum(opponent_actions)
        if cooperation >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_191(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponents = [None] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if history is not None and state.round_number > 0:
            cooperators = np.sum(history.opponent_actions[-1])
            if cooperators == self.game_description.n_players:
                action = Action.C
            elif cooperators > 0:
                action = Action.D
        return action

class Strategy_COLLECTIVE_192(BaseStrategy):
    """
    Strategy Name: Adaptive Stock Management (ASM)
    A Tit-for-Tat approach with modifications to account for the dynamic nature of the common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_consumption = 0
        self.average_consumption = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.total_consumption += np.sum(history.my_actions)
            self.average_consumption = self.total_consumption / (state.round_number - 1)
        if state.current_stock <= self.game_description.n_players // 2:
            return Action.D
        if self.average_consumption > 1.25 * (2 * self.game_description.n_players):
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_193(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) with Stock Awareness (SA)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.strategy = Action.C
        self.score = 0
        self.forgiveness_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return self.strategy
        if state.round_number == self.game_description.n_rounds - 1:
            self.strategy = Action.C
            return self.strategy
        if history.opponent_actions is None or len(history.opponent_actions) < self.game_description.n_rounds:
            history.opponent_actions = np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool)
            history.opponent_payoffs = np.zeros(self.game_description.n_rounds, dtype=np.float64)
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if self.strategy == Action.C:
            payoff = state.current_stock / (2 * self.game_description.n_players)
            if history.opponent_actions[state.round_number - 1, :].all():
                self.strategy = Action.D
                self.forgiveness_counter += 1
            elif opponent_cooperators >= self.game_description.n_players // 2:
                self.score += payoff
                if self.forgiveness_counter > 2:
                    self.forgiveness_counter = 0
            history.opponent_payoffs[state.round_number] = payoff if self.strategy == Action.C else state.current_stock / self.game_description.n_players
        else:
            payoff = state.current_stock / self.game_description.n_players
            if not history.opponent_actions[state.round_number - 1, :].all():
                self.strategy = Action.C
                self.forgiveness_counter = 0
        return self.strategy

class Strategy_COLLECTIVE_194(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFT-SA) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_stock = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C if state.current_stock > 0 else Action.D
        last_round = len(history.opponent_actions) - 1
        opponent_cooperated = np.sum(history.opponent_actions[last_round, :]) >= self.game_description.n_players // 2
        my_action = Action.C if state.current_stock > self.average_stock * 0.75 else Action.D
        if opponent_cooperated:
            return my_action
        elif state.current_stock <= 0 or (state.current_stock > self.average_stock and state.current_stock <= self.average_stock * 0.75):
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_195(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game
    """
    MAX_PUNISHMENT_ROUNDS = 3

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or self.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_action = history.opponent_actions[last_round, -1]
        if last_action == Action.D and self.round_number > self.MAX_PUNISHMENT_ROUNDS:
            return Action.D
        return last_action

class Strategy_COLLECTIVE_197(BaseStrategy):
    """
    A strategy called "Adaptive Stock Management" (ASM) for the Common Pool Resource Game. The strategy aims to balance cooperation and defection based on current stock levels, round numbers, and historical stock depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        stock_level = state.current_stock
        if round_number == 0:
            return Action.C
        if stock_level / self.capacity >= 0.75:
            return Action.C
        elif random.random() <= stock_level / self.capacity - 0.5 if round_number != self.game_description.n_rounds - 1 else Action.D:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_199(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth (ATFSG) strategy for the Common Pool Resource Game.
    Prioritizes maintaining the common pool and ensuring its sustainable growth over short-term individual gains, promoting mutual benefits, long-term cooperation, and collective well-being of all players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        opponents_actions = np.mean(history.opponent_actions, axis=1) > 0.5
        current_stock = state.current_stock
        depletion_threshold = (self.n - 1) * self.capacity / (4 * self.n)
        growth_threshold = self.capacity / 2
        if all(opponents_actions):
            action = Action.C
        else:
            action_to_take = Action.D
            if current_stock < depletion_threshold:
                action = Action.C
            elif current_stock > (self.n - 1) * self.capacity / (4 * self.n):
                action = Action.D
        return action

class Strategy_COLLECTIVE_200(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat with Stock Awareness (ATFS)

    This strategy follows a simple adaptive approach to promote long-term cooperation and punish uncooperative behavior in the Common Pool Resource Game.
    It cooperates initially and adjusts its actions based on the average cooperative ratio of opponents in the last few rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponents = set()
        self.k = int(math.ceil(game_description.n_rounds * 0.25))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = np.array(history.opponent_actions).flatten() if history else np.zeros(self.k + 1)
        self.opponents.update(range(1, len(opponent_actions)))
        if len(self.opponents) < self.game_description.n_players - 1:
            cooperator_count = sum(opponent_actions[0:self.k + 1])
            avg_CR = cooperator_count / (self.k + 1)
        else:
            average_cooperator_count = np.mean(opponent_actions[-self.k:])
            avg_CR = average_cooperator_count
        return Action.C if avg_CR > self.game_description.n_players // 2 else Action.D

class Strategy_COLLECTIVE_201(BaseStrategy):
    """
    Tit-for-Tat Adaptive Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and self.round > 0:
            opponent_last_round = np.mean(history.opponent_actions[-1])
        else:
            opponent_last_round = False
        if state.round_number == 0:
            return Action.C
        elif self.round > self.game_description.n_rounds - 1:
            return Action.C
        else:
            return Action(opponent_last_round)
        self.round += 1

class Strategy_COLLECTIVE_202(BaseStrategy):
    """
    Implementation of the Adaptive Cooperative-Competitive (ACC) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r_1 = game_description.n_players // 2 + 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        elif state.round_number == self.game_description.n_rounds:
            if state.current_stock <= 0:
                return Action.D
        else:
            acp = np.mean(history.my_actions[:state.round_number - 1])
            if acp * self.game_description.n_players <= (self.game_description.capacity - self.game_description.n_players) // 2:
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_203(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TFT-AC). This strategy promotes cooperation and fosters a collective mindset by rewarding kind actions and penalizing defection while being adaptive to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_window = math.ceil(self.game_description.n_players * 2)
        self.forgiveness_factor = 1.0
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_last_action = history.opponent_actions[-1][-1] if history is not None else None
        self.forgiveness_factor = max(self.forgiveness_factor - (self.round_number - 1) / self.forgiveness_window, 0.0)
        if opponent_last_action == Action.C:
            return Action.C
        elif opponent_last_action == Action.D and self.forgiveness_factor > 0:
            return Action.D
        else:
            self.forgiveness_factor = 1.0
            return Action.C

class Strategy_COLLECTIVE_204(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_opponent_cooperation = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_round = (state.round_number - 1) % self.game_description.n_rounds + 1
        if state.round_number == last_round:
            if state.current_stock == 0:
                return Action.D
            self.last_round_opponent_cooperation = 0
            return Action.C
        self.last_round_opponent_cooperation += sum(history.opponent_actions[last_round - 1, :])
        if self.last_round_opponent_cooperation >= self.game_description.n_players - 1:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_205(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            opponent_action = history.opponent_actions[-1, 0] if history is not None else None
            if self.previous_opponent_action is None:
                self.previous_opponent_action = opponent_action
            action = Action.C if opponent_action == Action.C and state.round_number != self.game_description.n_rounds else Action.D if opponent_action == Action.D and state.round_number != self.game_description.n_rounds else Action.C
            self.previous_opponent_action = opponent_action
            return action

class Strategy_COLLECTIVE_206(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game (ATFT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        self.opponent_history += [history.opponent_actions[state.round_number - 1]]
        cooperators = sum(self.opponent_history[-1])
        if len(self.opponent_history) == self.game_description.n_rounds:
            self.last_round = True
        if cooperators >= self.game_description.n_players // 2 and (not self.last_round):
            return Action.C
        return Action.D

    def get_opponent_history(self) -> NDArray[np.bool_]:
        return np.array(self.opponent_history)

    def reset_opponent_history(self):
        self.opponent_history = []

class Strategy_COLLECTIVE_207(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    This strategy maintains a balance between cooperation and competition, promoting fairness and reciprocity while preserving the potential for growth and adaptation in the common pool resource game environment.
    By rewarding cooperative behavior and punishing defection, this strategy fosters trust and encourages long-term collaboration between players, ultimately leading to higher average payoffs over time compared to exclusively defective or exploitative strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperated_last = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        self.opponent_cooperated_last = sum(history.opponent_actions[-1, :]) >= (self.game_description.n_players - 1) // 2
        if self.opponent_cooperated_last:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_209(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.acceptable_threshold = math.floor(game_description.n_players / 2)
        self.history = PlayerHistory(np.zeros((1, game_description.n_rounds), dtype=bool), np.zeros((1, game_description.n_rounds)), np.zeros((game_description.n_players, game_description.n_rounds), dtype=bool), np.zeros((game_description.n_players, game_description.n_rounds)))
        self.total_payoff = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.history = history
        if state.round_number == 0:
            return Action.C
        average_payoff = np.mean(self.history.my_payoffs[:state.round_number])
        if average_payoff >= self.acceptable_threshold:
            return Action.C
        else:
            return Action.D

    def update_after_round(self, state: CommonPoolState):
        """
        Update the strategy's internal state after a round is complete.
        """
        if self.history.my_payoffs[-1] is not None:
            self.total_payoff += self.history.my_payoffs[-1]
            self.history = PlayerHistory(self.history.my_actions, np.append(self.history.my_payoffs, [self.history.my_payoffs[-1]]), self.history.opponent_actions, self.history.opponent_payoffs)
        else:
            self.history = PlayerHistory(self.history.my_actions, np.append(self.history.my_payoffs, [None]), self.history.opponent_actions, self.history.opponent_payoffs)
        if state.round_number == self.game_description.n_rounds - 1:
            if np.mean(self.history.my_payoffs[:-1]) >= self.acceptable_threshold:
                return Action.C

class Strategy_COLLECTIVE_210(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy that promotes cooperation while retaliating against defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1,), dtype=bool), np.zeros((1,)), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros((1,)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == self.history.my_actions.size - 1 and self.game_description.n_rounds > self.history.my_actions.size:
            return Action.C
        my_last_action = self.history.my_actions[-1]
        opponent_last_action = history.opponent_actions[-1, int(not my_last_action)]
        if opponent_last_action:
            if my_last_action:
                pass
            else:
                self.history.my_payoffs[-1] += state.current_stock / (2 * self.game_description.n_players)
        elif my_last_action:
            self.history.my_payoffs[-1] += state.current_stock / self.game_description.n_players
        else:
            pass
        self.history = PlayerHistory(np.append(self.history.my_actions, [my_last_action]), np.append(self.history.my_payoffs, [state.current_stock / (not my_last_action)]), history.opponent_actions, history.opponent_payoffs)
        return Action(int(my_last_action))

class Strategy_COLLECTIVE_211(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Adaptation (TFT-SA)

    A strategy that cooperates initially, and then cooperates if the average stock level in the previous r/2 rounds is above the minimum sustainable level for all players. Otherwise, it defects to prioritize individual survival and restore the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.window_size = int(game_description.n_rounds / 4)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number == self.game_description.n_rounds - 1 and np.mean(history.my_payoffs[:-1]) >= 2 * self.game_description.n_players):
            return Action.C
        window = history.my_payoffs[max(0, state.round_number - self.window_size):state.round_number]
        average_stock = np.mean(window)
        if average_stock >= 2 * self.game_description.n_players and state.round_number != self.game_description.n_rounds - 1:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_212(BaseStrategy):
    """
    Strategy that follows the Adaptive Tit-for-Tat approach in Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity * (2 * self.game_description.n_players / self.game_description.n_rounds)
        self.last_round = False
        self.stock_collapse = float('inf')

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history and state.round_number < self.game_description.n_rounds - 1 and (not self.last_round):
            average_consumption = np.mean(history.opponent_actions[:, 0].astype(int))
            if average_consumption <= self.threshold:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1 or (history and self.last_round):
            return Action.C
        if history and np.all(history.current_stock[-1] < self.stock_collapse):
            self.stock_collapse = history.current_stock[-1]
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_215(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperative Strategy for the Common Pool Resource Game.
    This strategy fosters long-term reciprocity and mutual trust among players by adhering to a pattern of cooperation and reciprocation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._last_round_cooperators = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self._last_round_cooperators = sum(history.opponent_actions[-1])
        if state.round_number == len(history.my_payoffs) - 1:
            return Action.C
        if self._last_round_cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif history.my_actions[-1]:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_216(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.max_forgiveness = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        round_number = state.round_number - 1
        opponent_action = history.opponent_actions[round_number, 0] if history else None
        if opponent_action is not None:
            self._update_forgiveness(opponent_action)
        if opponent_action == Action.C:
            return Action.C
        elif self.max_forgiveness > 0:
            return Action.D
        else:
            return Action.C

    def _update_forgiveness(self, opponent_action):
        if opponent_action == Action.D:
            self.max_forgiveness *= 2

    def __repr__(self):
        return f'Adaptive Tit-for-Tat (ATFT)'

class Strategy_COLLECTIVE_217(BaseStrategy):
    """
    An adaptive Tit-for-Tat strategy for the common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_cooperators = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.last_round_cooperators is None and history is not None:
            self.last_round_cooperators = sum(history.opponent_actions[-1])
        if self.last_round_cooperators is not None:
            cooperators = self.last_round_cooperators
        else:
            cooperators = sum(history.opponent_actions[-1, :])
        return Action.C if cooperators >= self.game_description.n_players // 2 else Action.D

class Strategy_COLLECTIVE_218(BaseStrategy):
    """
    A strategy that employs the Adaptive Stock Management (ASM) approach.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity / self.game_description.n_players
        self.threshold_coop = self.capacity * (1 + self.game_description.n_rounds) / (2 * self.game_description.n_players + self.game_description.n_rounds)
        self.threshold_defect = self.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            probability = math.floor(self.capacity * (state.current_stock / self.threshold_coop)) / self.capacity
            return Action(1 if random.random() <= probability else 0)
        else:
            probability = math.floor((state.current_stock - self.threshold_defect) * (self.threshold_coop - self.threshold_defect) / (self.capacity * self.game_description.n_players)) / self.capacity
            return Action(1 if random.random() <= probability else 0)

class Strategy_COLLECTIVE_219(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy with Stock Growth Consideration for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.T = self.game_description.capacity / self.game_description.n_players
        self.history = PlayerHistory(None, None, None, None)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is None:
            return Action.C if state.current_stock >= self.T else Action.D
        if state.round_number == 0:
            average_stock = state.current_stock
        else:
            average_stock = np.mean(history.my_payoffs[-self.m:])
        return Action.C if average_stock >= self.T else Action.D

    def update_history(self, state: CommonPoolState, action: Action, payoff: float):
        if self.history.my_actions is None or self.history.my_payoffs is None:
            self.history.my_actions = np.zeros(self.game_description.n_rounds)
            self.history.my_payoffs = np.zeros(self.game_description.n_rounds)
        self.history.my_actions[state.round_number] = int(action)
        self.history.my_payoffs[state.round_number] = payoff

class Strategy_COLLECTIVE_220(BaseStrategy):
    """
    The Adaptive Tit-for-Tat Strategy is a long-term cooperative approach that maintains cooperation when others are cooperating and responds to defection with defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_round_action = np.mean(history.opponent_actions[last_round])
        current_strategy = Action.C if last_round_action else Action.D
        return current_strategy

class Strategy_COLLECTIVE_221(BaseStrategy):
    """
    The Adaptive Tit-for-Tat strategy for the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_round_opponent_action is None:
            return Action.C
        opponent_action = history.opponent_actions[state.round_number - 1, 0]
        self.last_round_opponent_action = opponent_action
        if opponent_action:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_222(BaseStrategy):
    """
    The Adaptive Resource Sharing (ARS) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.gamma = 0.5
        self.beta = 0.5
        self.average_growth = np.nan
        self.current_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        cooperation_propensity = (self.current_stock / self.game_description.capacity) ** self.gamma * self.average_growth ** self.beta
        if cooperation_propensity > 0.5:
            return Action.C
        else:
            return Action.D

    def update(self, payoff, total_consumption, new_stock):
        self.current_stock = new_stock
        if not math.isnan(self.average_growth):
            avg_growth_change = (new_stock - self.current_stock) / self.average_growth
            if abs(avg_growth_change) > 0.1:
                self.gamma += 0.05 * math.copysign(1, avg_growth_change)
        self.average_growth = np.mean([self.average_growth * 0.9 + payoff / total_consumption for _ in range(self.game_description.n_rounds)])

class Strategy_COLLECTIVE_223(BaseStrategy):
    """
    Strategy Name: Adaptive Resource Allocation (ARA) Strategy

    This strategy cooperates when the current stock level is above the critical threshold (CT), otherwise defects.
    The CT is dynamically adjusted based on historical data of stock depletion, player actions, and stock growth.

    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.historical_data = []
        self.critical_threshold = self.capacity

    def calculate_critical_threshold(self, data):
        total_consumption = sum([data[round]['total_consumption'] for round in data])
        total_stock_growth = sum([data[round]['stock_growth'] for round in data])
        average_growth = total_stock_growth / (len(data) - 1)
        return self.capacity * (1 - (total_consumption + average_growth) / (2 * self.capacity))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history:
            self.historical_data = self.historical_data[-self.game_description.n_rounds:] + [history]
        if state.current_stock >= self.critical_threshold:
            return Action.C
        elif state.current_stock == self.critical_threshold:
            return random.choice([Action.C, Action.D])
        else:
            return Action.D

        def update_game_state(data):
            total_consumption = sum([data[round]['consumption'] for round in data])
            stock_after_consumption = data[-1]['current_stock'] - total_consumption
            stock_growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            new_stock = min(stock_after_consumption + stock_growth, self.capacity)
            data[-1]['stock_growth'] = stock_growth
            data[-1]['new_stock'] = new_stock
        if state.round_number < self.game_description.n_rounds:
            self.historical_data[-1] = {'current_stock': state.current_stock, 'total_consumption': 0, 'stock_growth': 0, 'new_stock': state.current_stock}
        if len(self.historical_data) == self.game_description.n_rounds:
            self.critical_threshold = self.calculate_critical_threshold(self.historical_data)
            update_game_state(self.historical_data)

class Strategy_COLLECTIVE_224(BaseStrategy):
    """
    The Adaptive Tit-for-Tat strategy that adjusts cooperation based on opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_length = 0
        self.round_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.round_history) == 0:
            return Action.C
        last_round = len(self.round_history) - 1
        last_state_round = self.round_history[last_round]
        opponent_action = history.opponent_actions[last_round, state.round_number % self.game_description.n_players]
        if opponent_action:
            return Action.C
        elif last_state_round == state.round_number:
            self.punishment_length += 1
        elif state.round_number < self.punishment_length:
            self.punishment_length = state.round_number
        return Action.D if self.punishment_length > 0 else Action.C

    def update_round_history(self, round_number: int):
        self.round_history.append(round_number)

class Strategy_COLLECTIVE_225(BaseStrategy):
    """
    A strategy inspired by the Tit-for-Tat Evolution in the Common Pool Resource Game.
    Cooperates initially, and mimics opponents' actions in subsequent rounds. Forgives opponents after a series of defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_count = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        if not history:
            history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        if state.round_number == 1:
            history.my_actions[0] = True
            return Action.C
        last_action = history.my_actions[-1]
        if not last_action:
            self.forgiveness_count += 1
            if self.forgiveness_count >= state.round_number - 1:
                self.forgiveness_count = state.round_number
        opponents_cooperated = sum(history.opponent_actions[-1, :])
        if last_action and opponents_cooperated >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_228(BaseStrategy):
    """Adaptive Tit-for-Tat with Growth (ATfTG) strategy"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None
        self.total_stock = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if history is not None:
            self.history = history
        if len(self.history.my_actions) < 3:
            action = Action.C
        else:
            average_stock = np.mean(self.history.my_payoffs[-3:])
            action = Action.C if average_stock >= self.game_description.capacity / self.game_description.n_players else Action.D
        consumption = action.value == 1 and self.game_description.capacity // self.game_description.n_players or self.game_description.capacity // (2 * self.game_description.n_players)
        self.total_stock -= consumption
        new_stock = max(self.total_stock + 2 * self.total_stock * (1 - self.total_stock / self.game_description.capacity), 0)
        self.total_stock = min(new_stock, self.game_description.capacity)
        self.history.my_actions = np.append(self.history.my_actions, [action == Action.C]) if history else np.array([[action == Action.C]])
        self.history.my_payoffs = np.append(self.history.my_payoffs, [self.total_stock / (2 * self.game_description.n_players) if action == Action.C else self.total_stock / self.game_description.capacity])
        return action

class Strategy_COLLECTIVE_229(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy with Stock Growth Consideration (SG-ATFT) for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_round_action = history.opponent_actions[last_round] if last_round >= 0 else np.zeros(self.game_description.n_players, dtype=bool)
        stock = state.current_stock
        if state.round_number == 0 or np.all(last_round_action):
            return Action.C
        elif last_round_action[-1] and stock < self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_230(BaseStrategy):
    """
    A strategy named "Adaptive Stock-based Tit-for-Tat" (ASTFT) for the Common Pool Resource Game.
    The strategy aims to balance cooperation and defection based on game parameters, state, and history while remaining adaptive, robust, and collective.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 2 * game_description.capacity // 3
        self.cooperation_level = self.game_description.capacity // (2 * game_description.n_players)
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            self.history = PlayerHistory(np.zeros(state.round_number + 1, dtype=bool), np.zeros(state.round_number + 1), np.zeros((state.round_number, self.game_description.n_players), dtype=bool), np.zeros(state.round_number))
        if state.current_stock < self.threshold:
            return Action.D
        avg_consumption = np.mean(history.my_actions[1:])
        if avg_consumption < self.cooperation_level:
            return Action.C
        else:
            return Action.D
        self.history.my_actions[-1] = self.__class__.__name__ == str(history.opponent_actions[-1].shape[1])
        self.history.my_payoffs[-1] = state.current_stock / (2 * self.game_description.n_players) if self.history.my_actions[-1] else state.current_stock / self.game_description.n_players

class Strategy_COLLECTIVE_231(BaseStrategy):
    """
    Tit-for-Tat Adaptive (TfTA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_rate_sum = 0.0
        self.opponent_cooperation_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        action = Action.C
        if state.round_number > 1:
            last_round = len(history.opponent_actions) - 1
            opponent_cooperated_last_round = history.opponent_actions[last_round].sum() > self.game_description.n_players // 2
            if opponent_cooperated_last_round:
                action = Action.C
            else:
                self.opponent_cooperation_count += 1
                self.opponent_cooperation_rate_sum += (last_round - self.opponent_cooperation_count + 1) / state.round_number
                if self.opponent_cooperation_rate_sum > state.round_number // 2:
                    action = Action.C
                elif state.round_number == last_round + 1:
                    self.opponent_cooperation_count = 0
                    self.opponent_cooperation_rate_sum = 0.0
        return action

class Strategy_COLLECTIVE_233(BaseStrategy):
    """
    Tit-for-Tat Evolutionary Strategy (TFTES) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_threshold = 2 * game_description.n_players // 3 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is None and history.my_actions is None):
            return Action.C
        if state.current_stock < self.capacity_threshold:
            return Action.D
        else:
            return Action.C

    def update_history(self, round: int, opponent_action: bool) -> None:
        if len(history.my_actions) < round:
            history.my_actions = np.append(history.my_actions, np.zeros(round - len(history.my_actions), dtype=bool))
            history.my_payoffs = np.append(history.my_payoffs, np.full(round - len(history.my_payoffs), 0.0))
            if round > 1:
                history.opponent_actions = np.append(history.opponent_actions, np.zeros((round - 1, self.game_description.n_players), dtype=bool))
                history.opponent_payoffs = np.append(history.opponent_payoffs, np.full((round - 1, self.game_description.n_players), 0.0))
            history.my_actions[-1] = opponent_action

class Strategy_COLLECTIVE_234(BaseStrategy):
    """
    Adaptive Stock Management Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_consumption = 0.0
        self.stock_depletion = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        avg_consumption = self.avg_consumption
        if round_number == 0:
            return Action.C
        elif current_stock <= 0:
            if not self.stock_depletion:
                self.stock_depletion = True
                return Action.D
        else:
            total_consumption = np.sum(history.my_actions) * (round_number - 1) if history else round_number - 1
            avg_consumption = total_consumption / max(round_number, 1)
            if avg_consumption < current_stock / (2 * self.game_description.n_players):
                return Action.C
            elif avg_consumption >= current_stock / self.game_description.n_players:
                return Action.D
            else:
                if round_number > 1:
                    my_payoffs = history.my_payoffs[1:] if history else np.zeros(round_number - 1)
                    avg_payoff = np.mean(my_payoffs)
                    current_payoff = current_stock / (2 * self.game_description.n_players) if Action.C else current_stock / self.game_description.n_players
                    payoff_diff = current_payoff - avg_payoff
                else:
                    payoff_diff = 0.0
                if payoff_diff > 0:
                    return Action.C
                elif payoff_diff < 0:
                    return Action.D
        self.avg_consumption = avg_consumption
        return Action.C

class Strategy_COLLECTIVE_235(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy in the Common Pool Resource Game.
    This strategy cooperates initially and responds to the opponent's previous move in subsequent rounds.
    It also adapts its behavior based on repeated interactions, prioritizing long-term sustainability over short-term gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.min_cooperation_threshold = math.ceil(self.n_players // 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is None or state.round_number == 0:
            if state.current_stock >= self.game_description.capacity * (2 / self.n_players):
                return Action.C
            else:
                return Action.D
        else:
            last_round = history.my_actions[-1]
            last_opponent_cooperators = sum(history.opponent_actions[-1])
            if last_round == Action.C and state.current_stock >= self.game_description.capacity * (2 / self.n_players):
                return Action.C
            elif last_opponent_cooperators < self.min_cooperation_threshold or state.current_stock < self.game_description.capacity * (2 / self.n_players) or state.round_number == history.my_actions.size:
                return Action.D
            else:
                return last_round

class Strategy_COLLECTIVE_237(BaseStrategy):
    """Adaptive Tit-for-Tat (ATFT) Strategy for the Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.AverageCooperativeConsumptionRate = game_description.n_players * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            cooperative_consumption = (history.opponent_payoffs[-1] * self.game_description.n_players).sum() / state.round_number
            return Action.C if cooperative_consumption <= self.AverageCooperativeConsumptionRate else Action.D

class Strategy_COLLECTIVE_238(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number == 0:
            self.last_opponent_action = np.mean(history.opponent_actions[0])
        if self.last_opponent_action is None:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1 or history.my_actions[-1] == Action.D:
            self.last_opponent_action = None
            return Action.C
        else:
            return Action(int(self.last_opponent_action) ^ int(history.my_actions[-1]))

class Strategy_COLLECTIVE_239(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        opponent_action = history.opponent_actions[-1][0] if state.round_number > 0 else None
        if opponent_action is None or state.round_number == self.game_description.n_rounds:
            return Action.C
        self.forgiveness_counter = max(self.forgiveness_counter - 1, 0)
        if opponent_action == Action.C and self.forgiveness_counter < self.game_description.n_players // 2:
            return Action.C
        elif opponent_action in {Action.D, None} and self.forgiveness_counter >= self.game_description.n_players // 2:
            self.forgiveness_counter = 0
            return Action.C
        else:
            self.forgiveness_counter += 1
            return Action.D

class Strategy_COLLECTIVE_240(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth (ATFSG) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_consumption = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.last_round_consumption = np.sum(history.opponent_actions[-1]) / self.game_description.n_players * self.game_description.capacity
        if self.last_round_consumption < self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_241(BaseStrategy):
    """
    Strategy name: Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game
    Summary: Cooperate initially, then reciprocate opponents' actions in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.round += 1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        all_cooperated = np.all(history.opponent_actions[last_round])
        if all_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_242(BaseStrategy):
    """
    The Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game encourages cooperation when reciprocated and retaliates defection with defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history = history
        opponent_cooperated = np.sum(self.history.opponent_actions[-1]) >= self.game_description.n_players // 2
        if state.round_number == len(self.history.my_payoffs):
            return Action(int(not opponent_cooperated))
        action = Action(int(opponent_cooperated))
        self.history.my_actions[-1] = action == Action.C
        return action

class Strategy_COLLECTIVE_244(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.forgiveness_period = int(game_description.n_rounds * 0.3)
        self.current_round = 1
        self.opponent_behavior = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock < self.capacity * 0.5:
            return Action.D
        if self.current_round <= self.forgiveness_period or history is None:
            self.opponent_behavior = []
        else:
            self.opponent_behavior = np.array(history.opponent_actions[-self.forgiveness_period:, :]).flatten()
        if all((action == Action.C for action in self.opponent_behavior)):
            return Action.C
        else:
            return Action.D
        self.current_round += 1

class Strategy_COLLECTIVE_245(BaseStrategy):
    """
    The Tit-for-Tat strategy for the Common Pool Resource Game.
    This strategy cooperates initially and retaliates when opponents defect in subsequent rounds.
    It prioritizes long-term sustainability of the common pool resource over short-term gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))
        self.threshold = game_description.capacity // 20

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if self.game_description.n_players % 2 == 0 and cooperators >= self.game_description.n_players // 2:
            action = Action.C
        elif self.game_description.n_players % 2 != 0 and cooperators > self.game_description.n_players // 2:
            action = Action.C
        else:
            action = Action.D
        self.history.my_actions[state.round_number] = bool(action)
        self.history.my_payoffs[state.round_number] = state.current_stock / (2 * self.game_description.n_players) if action == Action.C else state.current_stock / self.game_description.n_players
        return action

class Strategy_COLLECTIVE_247(BaseStrategy):
    """
    Tit-for-Tat Adaptive strategy in the Common Pool Resource Game.
    Cooperates if opponents cooperated in the last round, otherwise defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        opponent_cooperators = sum(history.opponent_actions[last_round, :])
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_248(BaseStrategy):
    """
    Tit-for-Tat Adaptive (TFT-A) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.first_round_cooperate = True
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if history is None:
            self.first_round_cooperate = True
            return Action.C
        if state.round_number == 0 and (not self.first_round_cooperate):
            return Action.D
        if history.opponent_actions[-1].sum() >= self.game_description.n_players // 2:
            return Action.C
        else:
            self.last_round = state.round_number == self.game_description.n_rounds - 1
            if self.last_round and (not self.first_round_cooperate):
                return Action.D
            elif self.last_round:
                self.first_round_cooperate = True
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_251(BaseStrategy):
    """
    Implementation of the Adaptive Fitness-based Tit-for-Tat (AFT4T) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.6
        self.window_size = math.ceil(game_description.n_players / 2)
        self.sliding_window = np.zeros((self.window_size,), dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-self.window_size:]
        cooperation_count = np.sum(opponent_actions)
        fitness = cooperation_count / self.window_size * (state.current_stock / self.game_description.capacity)
        return Action.C if fitness > self.threshold else Action.D

class Strategy_COLLECTIVE_252(BaseStrategy):
    """
    Implementation of the Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity / game_description.n_players * 2

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_round = len(history.my_actions) - 1
        last_action = int(history.my_actions[last_round])
        if last_action == 1:
            return Action.C
        else:
            recent_cooperators = sum(history.opponent_actions[last_round])
            if recent_cooperators >= self.game_description.n_players // 2:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_253(BaseStrategy):
    """
    An adaptive Tit-for-Tat strategy for the Common Pool Resource Game, which cooperates in the initial round and subsequent rounds if all players cooperated in the previous round or when the common stock allows all players to cooperate without depleting the resource. The strategy defects if any player defected in the previous round and temporarily switches to a forgiving mode by cooperating when the common stock becomes depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity
        self.n_players = self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0:
            return action
        last_round_stock = state.current_stock
        cooperators_last_round = sum(history.opponent_actions[-1, :])
        if cooperators_last_round >= self.n_players // 2 and last_round_stock >= 2 * self.n_players:
            action = Action.C
        elif last_round_stock <= 0:
            action = Action.C
        return action

class Strategy_COLLECTIVE_254(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game.
    Cooperate in the first round, imitate opponent's action from previous round thereafter.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None
        self.opponent_cooperation_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.history = history
        self.opponent_cooperation_count = sum(history.opponent_actions[-1, :])
        action = Action.C if self.opponent_cooperation_count >= self.game_description.n_players // 2 else Action.D
        return action

class Strategy_COLLECTIVE_255(BaseStrategy):
    """Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = int(self.game_description.n_players * self.game_description.n_rounds / 10)
        self.m = int(self.game_description.n_rounds / 2)
        self.T_cooperate = self.game_description.capacity / (2 * self.game_description.n_players * self.game_description.n_rounds)
        self.T_defect = self.game_description.capacity / (self.game_description.n_players * self.game_description.n_rounds)
        self.win_rate_threshold = 0.5
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is None or len(history.opponent_actions) < self.k:
            self.history = history
            return Action.C
        average_consumption = np.mean(self.calculateAverageConsumption())
        if average_consumption < self.T_cooperate:
            return Action.C
        elif average_consumption > self.T_defect:
            return Action.D
        else:
            win_rate = self.calculateWinRate()
            if win_rate >= self.win_rate_threshold:
                return Action.C
            else:
                return Action.D

    def calculateAverageConsumption(self):
        consumption = np.mean(self.history.opponent_actions[:, -self.k:] * (self.game_description.capacity / self.game_description.n_players), axis=1)
        return consumption

    def calculateWinRate(self):
        cooperative_wins = sum(np.where(self.history.my_payoffs > self.history.opponent_payoffs, 1, 0))
        total_rounds = len(self.history.my_payoffs)
        return cooperative_wins / total_rounds

class Strategy_COLLECTIVE_256(BaseStrategy):
    """
    Implementation of the Adaptive Fitness-Driven Cooperation (AFDC) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_consumption = 0
        self.rounds_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        self.total_consumption += np.sum(history.my_actions)
        self.rounds_count += 1
        average_consumption = self.total_consumption / (self.rounds_count - 1 if self.rounds_count > 1 else 0)
        resource_health = state.current_stock / self.game_description.capacity
        return Action.C if average_consumption < self.game_description.capacity // self.game_description.n_players or (average_consumption >= self.game_description.capacity // self.game_description.n_players and resource_health <= 0.5) else Action.D if resource_health > 0.5 else Action.C

class Strategy_COLLECTIVE_257(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_counter = 0
        self.punishment_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        self.round_counter += 1
        opponent_action = history.opponent_actions[-1, -1]
        if self.round_counter < self.game_description.n_rounds - 3:
            if opponent_action == Action.C:
                return Action.C
            else:
                self.punishment_counter += 1
                return Action.D
        elif self.round_counter >= self.game_description.n_rounds - 3:
            self.punishment_counter = 0
            return Action.C

class Strategy_COLLECTIVE_258(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.window_size = int(math.ceil(game_description.n_rounds * 0.2))
        self.initial_stock_multiplier = 1.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_consumed_per_player = np.mean(history.opponent_payoffs[:state.round_number])
        sustainable_consumption = self.game_description.capacity / (2 * self.game_description.n_players)
        if state.round_number == self.game_description.n_rounds or stock_consumed_per_player <= sustainable_consumption:
            action = Action.C
        else:
            action = Action.D
        if state.current_stock < self.game_description.n_players * 2:
            action = Action.D
        elif state.current_stock > self.game_description.capacity:
            action = Action.C
        if state.round_number < 5 and state.current_stock >= self.initial_stock_multiplier * self.game_description.n_players * 2:
            action = Action.C
        return action

class Strategy_COLLECTIVE_259(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and (not history):
            return Action.C
        if not history:
            return Action.C
        last_round = len(self.opponent_history) - 1 if len(self.opponent_history) > 0 else None
        opponent_cooperators = sum(history.opponent_actions[last_round, :] if last_round else [])
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        if all((action == Action.D for action in self.opponent_history)):
            return Action.D
        for i in range(-2, -len(self.opponent_history) - 1, -1):
            if sum(history.opponent_actions[i, :]) == self.game_description.n_players:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_261(BaseStrategy):
    """
    The Adaptive Cooperation Strategy (ACS) for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_consumption = 0.0
        self.rounds_played = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0:
            action = Action.C
        elif history is not None and state.round_number > 0:
            self.total_consumption += sum(history.my_actions) * state.current_stock / self.game_description.n_players
            self.rounds_played += 1
            avg_stock = (self.game_description.capacity - self.total_consumption) / (self.game_description.n_players * state.round_number)
            safety_margin = math.sqrt(self.game_description.n_players * self.game_description.n_rounds) * 0.2
            if history.my_actions[-1] and state.current_stock >= avg_stock - safety_margin:
                action = Action.C
            elif not history.my_actions[-1] and state.current_stock <= avg_stock - safety_margin:
                action = Action.D
            else:
                rand_num = random.random()
                if rand_num > 0.5:
                    action = Action.C
                else:
                    action = Action.D
        return action

class Strategy_COLLECTIVE_262(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperate_threshold = self.game_description.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history and state.round_number < self.game_description.n_rounds - 3:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= self.game_description.n_players // 2 and state.current_stock > self.cooperate_threshold:
                return Action.C
        if history and state.round_number < self.game_description.n_rounds - 1:
            last_cooperation = [round_ for round_, action in reversed(list(enumerate(history.my_actions))) if action]
            if len(last_cooperation) > 0 and state.current_stock < self.cooperate_threshold:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_263(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = -1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        action = Action.C
        if state.round_number == 0 and history is None:
            return action
        elif state.round_number == self.game_description.n_rounds - 1 or state.round_number == self.game_description.n_rounds - 2:
            self.last_round = state.round_number
            action = Action.D
        elif history is not None and state.round_number > 0:
            opponent_actions = history.opponent_actions[-1] if len(history.opponent_actions) > 0 else np.zeros(self.game_description.n_players)
            last_opponent_action = opponent_actions[-1]
            if last_opponent_action:
                action = Action.C
            elif state.round_number != self.last_round + 1:
                action = Action.D
            elif state.round_number == self.game_description.n_rounds - 1:
                action = Action.D
            else:
                action = Action.C
        return action

class Strategy_COLLECTIVE_264(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number > 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 or state.round_number == self.game_description.n_rounds:
            return Action.C
        if not history:
            return Action.C
        prev_history = history.opponent_actions[-1]
        num_cooperators = sum(prev_history)
        if num_cooperators == self.game_description.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_265(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.forgiveness_threshold = int(self.n_players / 2)
        self.cooperation_counter = {player: 0 for player in range(1, self.n_players + 1)}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        total_cooperation = sum(self.cooperation_counter.values())
        if total_cooperation >= self.game_description.n_players * (state.round_number - 1):
            return Action.C
        for player in range(1, self.n_players + 1):
            if history is not None and state.round_number >= self.cooperation_counter[player] + self.forgiveness_threshold:
                self.cooperation_counter[player] = state.round_number
        return Action.D

    def update_payoffs(self, payoffs: PlayerHistory):
        round_number = payoffs.my_payoffs.size - 1
        if round_number == 0:
            self.cooperation_counter[self.player_index] += 1
        else:
            total_cooperation = sum(payoffs.opponent_actions[-1, :])
            if total_cooperation == self.n_players and round_number < self.game_description.n_rounds - 1:
                self.cooperation_counter[self.player_index] += 1

class Strategy_COLLECTIVE_266(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATfT) strategy for Common Pool Resource Game.
    Mimics opponent's action from previous round while maintaining resource sustainability over the long term.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity / self.game_description.n_players
        self.stock = None
        self.round = 0
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        self.stock = state.current_stock
        self.round = state.round_number
        if state.round_number == 0:
            self.history.my_actions[state.round_number] = True
            self.history.opponent_actions[state.round_number, :] = np.zeros(self.game_description.n_players)
            return Action.C
        lastAction = history.my_actions[-1]
        if lastAction:
            self.history.my_actions[state.round_number] = True
        else:
            self.history.my_actions[state.round_number] = False
        if self.stock < self.capacity or state.round_number == self.game_description.n_rounds - 1:
            self.history.my_payoffs[state.round_number] = self.stock / self.game_description.n_players
            return Action.D
        else:
            self.history.my_payoffs[state.round_number] = self.stock / (2 * self.game_description.n_players)
            return Action.C

class Strategy_COLLECTIVE_267(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy in Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if len(self.opponent_actions_history) > 0:
            last_round = self.opponent_actions_history[-1]
            if last_round == Action.C:
                return Action.C
        return Action.C

    def update(self, state: CommonPoolState, action: Action) -> None:
        """
        Store opponent's action for future reference
        """
        self.opponent_actions_history.append(action)

class Strategy_COLLECTIVE_268(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) - A strategy that reciprocates cooperation and punishes defection in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._last_round = False
        self._initial_depletion = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self._last_round = state.round_number == self.game_description.n_rounds
        self._initial_depletion = state.current_stock <= 0
        if self._last_round or self._initial_depletion:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        return Action(cooperators >= self.game_description.n_players // 2)

class Strategy_COLLECTIVE_269(BaseStrategy):
    """Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = None
        self.initial_stock_threshold = self.game_description.n_players * 2

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        if not history and state.round_number == 0:
            return Action.C
        if state.round_number + 1 > self.game_description.n_rounds:
            self.last_round = True
        elif state.round_number == self.last_round:
            return self.determine_action(state, history)
        if self.last_round is None or not self.last_round:
            return self.determine_action(state, history)

    def determine_action(self, state: CommonPoolState, history: PlayerHistory):
        last_opponent_cooperators = np.sum(history.opponent_actions[-1])
        last_own_action = 0 if not history else history.my_actions[-1]
        if state.round_number == 0 or last_opponent_cooperators >= self.game_description.n_players // 2:
            action = Action.C
        else:
            action = Action.D
        if state.current_stock < self.initial_stock_threshold:
            action = Action.D
        return action

class Strategy_COLLECTIVE_270(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat Adaptive (TFT-A)
    A simple strategy that reciprocates cooperation and punishes defection in a common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.two_n = 2 * self.n_players

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        round_number = state.round_number
        stock = state.current_stock
        opponent_actions = history.opponent_actions[-1] if round_number > 0 else None
        if round_number == 0:
            return Action.C
        elif stock < self.two_n:
            return Action.C
        elif round_number == self.game_description.n_rounds or (round_number - 1) % self.game_description.n_rounds == 0:
            return Action.C
        elif opponent_actions[0]:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_271(BaseStrategy):
    """
    Strategy name: Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game
    Strategy summary: Cooperate when resources are abundant, punish overconsumption and promote recovery of resources.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_stock = game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = len(history.my_actions) if history is not None else 0
        if current_round < self.game_description.n_rounds - 1 and history is not None:
            if state.current_stock > self.average_stock:
                return Action.C
            elif state.current_stock < self.average_stock * 0.5 and current_round != self.game_description.n_rounds - 1:
                return Action.D
        return Action.C if state.current_stock > self.average_stock * 0.5 else Action.D

class Strategy_COLLECTIVE_272(BaseStrategy):
    """
    Adaptive Stock-based Tit-for-Tat (AS-TFT) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_consumption = 0
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.round_number += 1
        if not history:
            return Action.C
        total_consumption = self.total_consumption + np.sum(history.my_actions * (self.game_description.n_players * self.round_number))
        average_consumption = total_consumption / (self.round_number * self.game_description.n_players)
        if state.current_stock <= 0:
            return Action.C
        capacity = self.game_description.capacity
        r = self.game_description.n_rounds
        if average_consumption < capacity / (2 * self.game_description.n_players):
            return Action.C
        elif average_consumption >= capacity / (2 * self.game_description.n_players) and average_consumption < capacity:
            return Action.D
        elif state.current_stock > capacity - 2 * self.game_description.n_players * r:
            p = np.where(state.current_stock > capacity - 2 * self.game_description.n_players * r, 0.8, 0.2)
            return Action(random.choices([Action.C, Action.D], weights=p)[0])
        else:
            return Action.D

class Strategy_COLLECTIVE_273(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATfT) strategy for Common Pool Resource Game.
    This strategy promotes cooperation by reciprocating cooperative moves, while penalizing defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._opponent_cooperation = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        self._opponent_cooperation = np.mean(history.opponent_actions[:, -1])
        opponent_cooperated = self._opponent_cooperation >= 0.5
        return Action.C if opponent_cooperated else Action.D

class Strategy_COLLECTIVE_274(BaseStrategy):
    """
    Implements the Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    Reciprocates cooperation while punishing defection to maintain a sustainable stock level over multiple rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[-1][-1] if history else np.zeros(1).astype(bool)[0]
        if opponent_action:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_276(BaseStrategy):
    """
    Adaptive Stock Management Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = math.floor(game_description.capacity / (2 * game_description.n_players + 1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number == 0:
            return Action.C
        if state.current_stock > self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_277(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            self.last_round = True
            return Action.C
        self.last_round = False
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2 and (not self.last_round):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_279(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATfT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        my_payoffs = history.my_payoffs[-1] if len(history.my_payoffs) > 0 else 0
        total_game_payoff = np.sum(history.my_payoffs) if len(history.my_payoffs) > 0 else 0
        last_round = state.round_number == history.my_actions.size - 1
        current_stock_level = state.current_stock if state.current_stock > 0 else self.initial_stock
        opponent_cooperated = np.sum(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2
        if last_round and my_payoffs > total_game_payoff / self.game_description.n_rounds:
            return Action.C if opponent_cooperated else Action.D
        return Action.C if opponent_cooperated else Action.D

class Strategy_COLLECTIVE_280(BaseStrategy):
    """
    Strategy Name: Adaptive Stock Management (ASM)
    Summary: A cooperative strategy that aims to maintain a sustainable common pool by adjusting the players' actions based on the current stock level and past actions' impact on the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = float(self.game_description.capacity)
        self.n_players = self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        current_round = state.round_number - 1
        last_round_stock = history.my_payoffs[current_round] if history else self.capacity
        actions = history.opponent_actions[current_round, :] if history else np.zeros(self.n_players, dtype=bool)
        cooperators = sum(actions)
        if last_round_stock < 2 * self.n_players:
            return Action.D
        elif last_round_stock >= self.capacity:
            return Action.C
        elif current_round == self.game_description.n_rounds - 1:
            return Action.C
        elif last_round_stock < self.capacity / 2 and cooperators > len(actions) // 2:
            return Action.C
        elif last_round_stock >= self.capacity / 2 and cooperators <= len(actions) // 2:
            return Action.D
        elif last_round_stock < self.capacity / 2:
            return Action.C
        else:
            growth = last_round_stock + 2 * last_round_stock * (1 - last_round_stock / self.capacity)
            if growth > self.capacity:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_282(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.c = math.floor(game_description.n_players / 2)
        self.d = math.ceil(game_description.n_players / 4)
        self.cooperators_streak = 0
        self.defectors_streak = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if history:
            cooperators = np.sum(history.opponent_actions[-1, :])
            self.defectors_streak += 1 - cooperators
            self.cooperators_streak = max(self.cooperators_streak, cooperators)
            if self.defectors_streak > self.d:
                action = Action.D
            elif self.cooperators_streak >= self.c:
                action = Action.C
        return action

class Strategy_COLLECTIVE_284(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    Maintains a balance between cooperation and punishment, promoting long-term mutual benefits with opponents while penalizing defection to maintain sustainable resource levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defection_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number < self.game_description.n_rounds - 1 and history is None):
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        if history.opponent_actions is None:
            return Action.C
        last_opponent_action = history.opponent_actions[-1, :].mean()
        self.opponent_defection_counter = 0 if last_opponent_action == 1 else self.opponent_defection_counter + 1
        if last_opponent_action == 1:
            return Action.D
        elif self.opponent_defection_counter >= 3:
            self.opponent_defection_counter = 0
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_286(BaseStrategy):
    """
    Tit-for-Tat Adaptive (TFT-A) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_memory = np.zeros((self.game_description.n_players - 1, self.game_description.n_rounds), dtype=np.int8)
        self.punishment_counter = np.zeros(self.game_description.n_players, dtype=np.int32)
        self.current_round = 0
        self.last_state = CommonPoolState(-1, game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if self.current_round == 0:
            return Action.C
        self.current_round += 1
        self.last_state = state
        if not history:
            history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=np.bool_), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=np.int8), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=np.float64))
        history.my_actions[self.current_round - 1] = (self.action == Action.C).astype(int)
        history.my_payoffs[self.current_round - 1] = self.payoff if self.current_round > 0 else np.nan
        for i in range(1, self.game_description.n_players + 1):
            history.opponent_actions[self.current_round - 1, i - 1] = history.opponent_actions[-1, i - 1] if self.current_round > 1 else np.nan
        cooperators = sum(history.opponent_actions[-1])
        if cooperators >= (self.game_description.n_players - 1) // 2:
            self.action = Action.C
        else:
            self.action = Action.D
        for i, opponent in enumerate(history.opponent_actions[-1]):
            if opponent == 0 and self.punishment_counter[i] < self.game_description.n_rounds:
                self.action = Action.D
                self.punishment_counter[i] += 1
            elif opponent == 1 and self.punishment_counter[i] > 0:
                self.punishment_counter[i] -= 1
        if state.round_number == self.game_description.n_rounds or state.current_stock < self.game_description.capacity * (2 - self.game_description.n_players):
            self.action = Action.D
        if self.current_round > 1:
            payoff = state.current_stock / (self.game_description.n_players * 2) * history.my_actions[:self.current_round]
            history.my_payoffs[self.current_round - 1] = payoff.sum() if not math.isnan(payoff.sum()) else np.nan

    @property
    def action(self):
        return self.__action

    @action.setter
    def action(self, value):
        self.__action = value

class Strategy_COLLECTIVE_288(BaseStrategy):
    """
    Tit-for-Tat-Adaptive (TfTA) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_action = Action.C

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return self.last_action
        elif history is not None:
            if history.opponent_actions is None or len(history.opponent_actions) < self.game_description.n_rounds - 1:
                return self.last_action
            average_cooperation = np.mean(history.opponent_actions[-self.game_description.n_rounds + 1:-1])
            if average_cooperation >= self.game_description.n_players / 2:
                self.last_action = Action.C
            else:
                self.last_action = Action.D
            return self.last_action

class Strategy_COLLECTIVE_289(BaseStrategy):
    """
    Adaptive Resource Management (ARM) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.historical_factors = {Action.C: 0.0, Action.D: 0.0}
        self.current_stock = 0.0
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state is None or history is None:
            return Action.C
        self.current_stock = state.current_stock
        self.round_number = state.round_number
        cooperate_score = self.current_stock / (2 * self.game_description.n_players) + self.historical_factors[Action.C] * (self.game_description.n_rounds - self.round_number)
        defect_score = self.current_stock / self.game_description.n_players + self.historical_factors[Action.D] * (self.game_description.n_rounds - self.round_number)
        if cooperate_score > defect_score:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_291(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth Awareness strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.optimal_consumption = 1 / (2 * self.n_players)
        self.stock_growth_threshold = self.capacity / self.n_players
        self.cooperation_threshold = self.optimal_consumption
        self.growth_threshold = 2 * self.optimal_consumption
        self.last_round = False
        self.history = None
        self.average_consumption = 0.0
        self.last_action = Action.C

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        self.history = history
        current_stock = state.current_stock
        total_consumption_last_round = np.sum(history.opponent_actions[-1])
        round_number = state.round_number
        if round_number == 1:
            action = Action.C
        else:
            average_consumption = (self.average_consumption * (round_number - 1) + total_consumption_last_round) / round_number
            total_consumption_this_round = np.sum(history.opponent_actions[round_number - 1])
            if total_consumption_this_round <= self.optimal_consumption * self.n_players:
                action = Action.C
            elif current_stock < self.stock_growth_threshold:
                action = Action.D
            elif current_stock > self.growth_threshold and total_consumption_this_round > self.cooperation_threshold * self.n_players:
                action = Action.C
            else:
                action = self.last_action
        if round_number == self.game_description.n_rounds:
            self.last_round = True
        return action

class Strategy_COLLECTIVE_293(BaseStrategy):
    """
    Strategy Name: Adaptive Resource Harvesting (ARH) Strategy
    This strategy implements the Adaptive Resource Harvesting strategy for the Common Pool Resource Game.
    It balances conservation and aggressive harvesting based on the current state of the resource pool and the progress of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_level = None
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if self.round_number == 0:
            return Action.D
        if self.critical_level is None:
            self.critical_level = self.game_description.capacity / (2 * self.game_description.n_players) + self.game_description.n_rounds - self.round_number
        if self.round_number == self.game_description.n_rounds:
            return Action.C
        current_stock = state.current_stock
        action = Action.D if current_stock < self.critical_level else Action.C
        self.round_number += 1
        return action

class Strategy_COLLECTIVE_294(BaseStrategy):
    """
    A strategy that cooperates initially and maintains defection if the opponent defected in the previous round, but reverts to cooperation if the opponent cooperated in the last two rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[-1][-1] if history else None
        if opponent_action is not None and self.last_opponent_action is not None:
            self.last_opponent_action = opponent_action
            return Action(self.last_opponent_action == Action.C)
        self.last_opponent_action = opponent_action
        return Action.C

class Strategy_COLLECTIVE_295(BaseStrategy):
    """
    Adaptive Stock-based Tit-for-Tat (ASTFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round = 0
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or self.round == 0:
            self.last_opponent_action = None
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            self.last_opponent_action = None
            return Action.C
        self.round += 1
        if history.opponent_actions[-1, :].all():
            self.last_opponent_action = Action.C
        elif not history.opponent_actions[-1, -1]:
            if self.round > 1:
                self.last_opponent_action = Action.D
        else:
            self.last_opponent_action = None
        return self.last_opponent_action

class Strategy_COLLECTIVE_297(BaseStrategy):
    """
    Strategy Name: Adaptive Stock-based Cooperation (ASC)
    Description: Cooperate when stock level is above a certain threshold and defect when it's below another. Uses a probabilistic approach between the thresholds, favoring cooperation more often as the stock level approaches T_c.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.avg_stock = np.zeros(self.game_description.n_rounds)
        self.T_c = None
        self.T_d = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = None
        if state.round_number == 0:
            self.T_c = (self.capacity - self.n_players) / (2 * self.n_players)
            self.T_d = self.T_c + (self.capacity - self.n_players) / (2 * self.n_players)
        else:
            avg_stock = np.mean(self.avg_stock[:state.round_number])
            self.T_c = (self.capacity - self.n_players) / (2 * self.n_players) + (avg_stock - self.T_d) / state.round_number
            self.T_d = self.T_c + (self.capacity - self.n_players) / (2 * self.n_players)
        if history is None:
            stock = self.capacity
        else:
            stock = history.my_payoffs[-1] if state.round_number == 0 else state.current_stock
        if stock >= self.T_c:
            action = Action.C
        elif stock < self.T_d:
            action = Action.D
        else:
            p = (stock - self.T_d) / (self.T_c - self.T_d)
            r = random.random()
            if r < p:
                action = Action.C
            else:
                action = Action.D
        if state.round_number > 0:
            self.avg_stock[state.round_number - 1] = (self.game_description.n_rounds * np.mean(self.avg_stock) + stock) / self.game_description.n_rounds
        return action

class Strategy_COLLECTIVE_298(BaseStrategy):
    """
    A strategy that uses a combination of tit-for-tat and Friedman's matching pennies approach to determine cooperation and defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = None
        self.last_action = Action.C

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.average_consumption is None:
            self.average_consumption = np.mean(history.my_payoffs[:state.round_number])
        current_stock_level = state.current_stock / self.game_description.n_players
        if current_stock_level > self.average_consumption:
            return Action.C
        if current_stock_level < self.average_consumption and np.sum(history.my_actions[:state.round_number]) > self.average_consumption:
            return Action.D
        if current_stock_level < self.average_consumption and np.sum(history.my_actions[:state.round_number]) <= self.average_consumption and (state.round_number != self.game_description.n_rounds):
            if self.last_action == Action.C:
                return Action.C
            if np.sum(history.my_actions[:state.round_number]) > self.average_consumption and self.last_action == Action.D:
                return Action.D
        self.last_action = history.my_actions[-1]
        return Action.C

class Strategy_COLLECTIVE_300(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game
    This Adaptive Tit-for-Tat strategy aims to foster long-term cooperation by being cooperative initially and responsive to the opponent's moves. It punishes opponents who defect but quickly forgives them as well, encouraging potential future cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history.my_actions[0] = True
            return Action.C
        elif state.round_number == history.my_actions.size - 1:
            return Action.C
        else:
            opponent_cooperators = sum(history.opponent_actions[-1, :])
            self.history.my_actions[-1] = opponent_cooperators >= self.game_description.n_players // 2
            return Action(self.history.my_actions[-1]) if history is not None else Action.C

class Strategy_COLLECTIVE_301(BaseStrategy):
    """
    A strategy based on the Adaptive Tit-for-Tat (ATFT).
    Starts by cooperating in the first round to demonstrate good intentions,
    and in subsequent rounds adopts the actions of its opponent from the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions_history = np.zeros((game_description.n_rounds, 1), dtype=bool)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_actions_history[-1] = history.opponent_actions[-1, 0]
        current_round = state.round_number - 1
        if self.opponent_actions_history[current_round]:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_302(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(game_description.capacity / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            last_opponent_action = history.opponent_actions[-1][-1]
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.C if state.current_stock > self.threshold else Action.D
            return Action.C if last_opponent_action else Action.D

class Strategy_COLLECTIVE_303(BaseStrategy):
    """
    Strategy Name: Adaptive Cooperative-Competitive (ACC) Strategy
    Strategy Description: This strategy uses a cooperativeness score to decide whether to cooperate or defect.
                            The score is based on the current stock level, total stock depletion in the past rounds, and the number of players.
                            A higher threshold encourages more cooperation while a lower one encourages more competition.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            normalized_current_stock = state.current_stock / self.capacity
            cooperativeness_score = normalized_current_stock
        else:
            total_depletion = np.sum(history.my_payoffs) / (self.game_description.n_rounds * self.capacity)
            normalized_current_stock = state.current_stock / self.capacity
            cooperativeness_score = normalized_current_stock - total_depletion
        if cooperativeness_score > self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_304(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.9 * game_description.capacity / game_description.n_players
        self.cooperation_history = 0
        self.punishment_history = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        current_round = state.round_number
        last_round = current_round - 1
        if current_round == 0:
            return Action.C
        if current_round == self.game_description.n_rounds:
            if history.opponent_actions[-1, 0] == Action.D:
                return Action.D
            else:
                return Action.C
        opponent_action = history.opponent_actions[last_round, 0]
        if opponent_action == Action.C:
            self.cooperation_history += 1
            self.punishment_history = 0
        else:
            self.cooperation_history = max(self.cooperation_history - 1, 0)
            self.punishment_history += 1
        if self.cooperation_history > self.punishment_history:
            action = Action.C
        elif self.cooperation_history == self.punishment_history:
            action = opponent_action
        else:
            action = Action.D
        if state.current_stock / self.game_description.capacity < self.stock_threshold and self.cooperation_history > self.game_description.n_rounds // 2:
            action = Action.C
        return action

class Strategy_COLLECTIVE_305(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and self.opponent_history is not None:
            opponent_cooperators = np.sum(self.opponent_history[-1])
        else:
            opponent_cooperators = 0
        if opponent_cooperators >= self.game_description.n_players // 2 and state.round_number != self.game_description.n_rounds - 1:
            self.opponent_history = history
            return Action.C
        return Action.D

    def last_action(self) -> Action:
        """
        Returns the action taken in the last round.
        """
        if self.opponent_history is None:
            return Action.C
        else:
            return self.opponent_history[-1][-1]

class Strategy_COLLECTIVE_307(BaseStrategy):
    """
    Adaptive Tit-for-Tat (A-TFT) for Common Pool Resource Game strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.is_last_round = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.last_opponent_action = np.mean(history.opponent_actions[-1])
        self.is_last_round = state.round_number == self.game_description.n_rounds
        if np.all(history.my_actions == 1) and (not self.is_last_round):
            return Action.C
        elif self.last_opponent_action:
            return Action(int(self.last_opponent_action)) if not self.is_last_round else self.evaluate_payoffs()
        return Action.C

    def evaluate_payoffs(self):
        """
        Evaluate payoffs and choose between C or D in the last round (r).
        """
        total_stock = np.sum(history.opponent_payoffs[:, 0])
        my_total_consumption = np.sum(history.my_actions * self.game_description.n_players / (2 * self.game_description.n_players))
        remaining_stock = total_stock - my_total_consumption
        growth = 2 * remaining_stock * (1 - remaining_stock / self.game_description.capacity)
        new_stock = min(remaining_stock + growth, self.game_description.capacity)
        if new_stock > total_stock / 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_308(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.is_last_round = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        self.is_last_round = state.round_number == self.game_description.n_rounds
        opponent_action = history.opponent_actions[-1, 0] if history else None
        if not opponent_action:
            opponent_action = self.last_opponent_action
        self.last_opponent_action = opponent_action
        return Action.C if opponent_action == Action.C or self.is_last_round else Action.D

class Strategy_COLLECTIVE_309(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        actions = [] if not history else [player[-1] for player in history.opponent_actions]
        cooperators = sum(actions)
        response = Action.C if cooperators >= self.game_description.n_players // 2 else Action.D
        return response

class Strategy_COLLECTIVE_310(BaseStrategy):
    """
    Adaptive Fitness-Driven Tit-for-Tat (AFDD) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.fitness = 0.0
        self.threshold = 0.8
        self.history_size = 5
        self.average_fitness = np.zeros(self.history_size)

    def get_average_fitness(self):
        return np.mean(self.average_fitness)

    def move(self):
        self.fitness += self.payoff()
        self.average_fitness = np.roll(self.average_fitness, -1)
        self.average_fitness[-1] = self.get_average_fitness()
        return self.__call__(None, None)

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if not history:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1])
        average_fitness = self.get_average_fitness()
        if state.round_number == 0 or opponent_cooperators >= self.game_description.n_players // 2:
            action = Action.C
        elif average_fitness < self.threshold:
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_COLLECTIVE_311(BaseStrategy):
    """
    Tit-for-Tat Strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_len = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        self.history_len = max(self.history_len, state.round_number)
        if self.history_len < len(history.opponent_actions):
            action = history.opponent_actions[-1][-1]
        else:
            cooperators = sum(history.opponent_actions[self.history_len - 1])
            if cooperators >= self.game_description.n_players // 2:
                action = Action.C
            else:
                action = Action.D
        return action

class Strategy_COLLECTIVE_313(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.conservative_threshold = math.floor(game_description.capacity / 2)
        self.last_round_payoff = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        my_actions = history.my_actions if history else np.zeros(state.game_description.n_rounds, dtype=bool)
        last_opponent_action = history.opponent_actions[-1, my_actions[-1]] if history else None
        if all(my_actions[-self.game_description.n_rounds:] == [True]):
            return Action.C
        elif state.current_stock > 0 and last_opponent_action is not None and last_opponent_action:
            return Action.D
        elif state.current_stock <= 0:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > self.conservative_threshold:
                return Action.C
            else:
                return Action.D
        self.last_round_payoff = history.my_payoffs[-1] if history else None

class Strategy_COLLECTIVE_314(BaseStrategy):
    """
    A strategy that mimics Tit-for-Tat behavior in the Common Pool Resource Game.
    Prioritizes cooperation to conserve resources, encourage reciprocity and maintain a healthy common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_window_size = math.ceil(game_description.n_rounds / 2)
        self.history_window = np.zeros((self.history_window_size, 2), dtype=bool)

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif history is None:
            return self.__call__(CommonPoolState(state.round_number - 1, state.current_stock), None)
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        self.history_window = np.roll(self.history_window, -1)
        self.history_window[-1] = [history.my_actions[state.round_number - 1], False]
        all_players_cooperated = np.all(self.history_window[:, 0])
        return Action.C if all_players_cooperated else Action.D

    def update_history(self, state: CommonPoolState, payoff: float) -> None:
        self.history_window[-1][1] = payoff > 0

class Strategy_COLLECTIVE_316(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity // game_description.n_players * 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.current_stock < self.stock_threshold:
            return Action.D
        coop_count = sum(history.my_actions[:-1])
        recent_coop = len([x for x in history.my_actions[-2:] if x])
        if recent_coop >= self.game_description.n_players // 2 and coop_count > int(self.game_description.n_players / 2) or state.current_stock / self.game_description.capacity * 100 >= 80:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_319(BaseStrategy):
    """
    Strategy: Adaptive Tit-for-Tat (ATFT)
    Summary: Cooperates initially, adapts actions based on opponent's behavior in previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        previous_round_action = history.opponent_actions[-1, -1] * (state.current_stock / (2 * self.game_description.n_players))
        if previous_round_action >= 0.5:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return not self.last_round_action
        self.last_round_action = history.my_actions[-1]
        if np.count_nonzero(history.my_actions[-1]) == np.count_nonzero(history.opponent_actions[-1]):
            return self.last_round_action
        return not self.last_round_action

class Strategy_COLLECTIVE_320(BaseStrategy):
    """
    Adaptive Stock-based Cooperation (ASC) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            if state.current_stock >= 2 * self.r * self.n:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.r:
            if state.current_stock > 2 * self.n:
                return Action.C
            else:
                return Action.D
        if random.random() < state.current_stock / (2 * (self.r - state.round_number + 1)):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_321(BaseStrategy):
    """
    A strategy that cooperates in the first round and retaliates against defection,
    while balancing cooperation and defection based on historical behavior, current state,
    and potential growth to foster a collective mindset of long-term survival and collaboration.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        my_action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            stock_depletion = np.sum(history.opponent_payoffs)
            new_stock = max(state.current_stock - stock_depletion, 0)
            if new_stock < self.capacity or new_stock <= state.round_number * self.game_description.n_players:
                my_action = Action.D
        else:
            opponent_actions = history.opponent_actions[:, -1]
            stock_depletion = np.sum(history.opponent_payoffs)
            new_stock = max(state.current_stock - stock_depletion, 0)
            if new_stock < self.capacity or new_stock <= state.round_number * self.game_description.n_players:
                my_action = Action.D
            elif opponent_actions[-1] == Action.D and state.round_number != 1:
                my_action = Action.D
            elif opponent_actions[-1] == Action.C:
                my_action = Action.C
        return my_action

class Strategy_COLLECTIVE_323(BaseStrategy):
    """
    An adaptive tit-for-tat strategy that considers the growth of the common pool resource while maintaining cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_over_2n = self.game_description.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if history is None:
            return Action.C
        opponent_action = history.opponent_actions[-1, 0]
        previous_stock = state.current_stock if state.round_number > 0 else self.game_description.capacity
        if state.current_stock <= self.capacity_over_2n or state.current_stock >= self.game_description.capacity / self.game_description.n_players:
            action = Action.C
        elif opponent_action:
            action = Action.C
        elif state.current_stock <= self.capacity_over_2n:
            action = Action.C
        else:
            action = Action.D
        return action

class Strategy_COLLECTIVE_324(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Growth (TFT-AG) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 2 * self.game_description.n_players
        self.growth_threshold = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_opponent_action = np.mean(history.opponent_actions[-1]) if history else None
        if not last_opponent_action:
            return Action.C
        stock = state.current_stock
        growth = 2 * stock * (1 - stock / self.game_description.capacity)
        if self.growth_threshold < 0 and growth > 0:
            self.growth_threshold = growth
        if last_opponent_action == 1 and stock >= self.threshold:
            if growth <= 0 or stock < self.threshold:
                return Action.D
            else:
                return Action.C
        if last_opponent_action == 1:
            return Action.C
        if stock < self.threshold:
            return Action.C
        if growth <= 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds:
            actions = np.array([Action.C, Action.D])
            payoffs = [stock / (2 * self.game_description.n_players), stock / self.game_description.n_players]
            best_action = actions[np.argmax(payoffs)]
            return best_action
        return Action.D

class Strategy_COLLECTIVE_325(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    Aims to encourage fairness and mutual cooperation while promoting resource conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.total_stock_depletion = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0:
            return action
        total_consumption = np.sum(history.my_actions * (Action.D.value / state.round_number))
        self.total_stock_depletion += total_consumption
        if self.total_stock_depletion > 0.9 * self.capacity:
            action = Action.D
        elif self.total_stock_depletion <= 0.1 * self.capacity:
            action = Action.C
        if np.sum(history.my_actions * (Action.D.value / (state.round_number + 1))) == np.sum(history.my_actions * (Action.C.value / (state.round_number + 1))):
            action = Action.C if np.sum(history.my_actions * (Action.D.value / state.round_number)) > np.sum(history.my_actions * (Action.C.value / state.round_number)) else Action.D
        return action

class Strategy_COLLECTIVE_326(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_action_history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        elif state.round_number > self.game_description.n_rounds or not history:
            return ValueError('Invalid History state')
        self.opponent_action_history = history.opponent_actions[:, -1] if history else None
        if len(self.opponent_action_history) == 0:
            return Action.C
        else:
            last_opponent_action = self.opponent_action_history[-1]
            if last_opponent_action:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_327(BaseStrategy):
    """
    A Tit-for-Tat strategy player that cooperates if the opponent did in the previous round, and defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_actions = history.opponent_actions[-1]
        last_round = state.round_number - 1
        if last_round < len(self.opponent_actions):
            opponent_action = self.opponent_actions[last_round]
        else:
            opponent_action = None
        if opponent_action == Action.C:
            return Action.C
        elif opponent_action is None:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_328(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Strategy (TFT-A) for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_factor = int(game_description.n_players // 3)
        self.history = PlayerHistory(my_actions=None, my_payoffs=None, opponent_actions=np.zeros((self.game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds, game_description.n_players), dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is None and state.round_number == 0:
            return Action.C
        self.history = history or self.history
        action = Action.C
        last_round = state.round_number - 1
        if last_round >= self.forgiveness_factor:
            opponent_cooperators_last_round = sum(self.history.opponent_actions[last_round])
            if opponent_cooperators_last_round >= self.game_description.n_players // 2:
                pass
            else:
                action = Action.D
        return action

class Strategy_COLLECTIVE_329(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        elif state.round_number == len(history.opponent_actions) - 1 and self.last_opponent_action is not None:
            return Action.C
        else:
            self.last_opponent_action = history.opponent_actions[-1, :].mean()
            if self.last_opponent_action >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_330(BaseStrategy):
    """
    Tit-for-Tat Adaptive Cooperation (TFT-A) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = math.floor(game_description.capacity * 0.85)
        self.random_event_probability = 0.1
        self.total_consumption = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            total_consumption = self.total_consumption + np.sum(history.opponent_actions[-1]) * (state.current_stock / self.game_description.capacity)
            if state.current_stock <= self.stock_threshold:
                return Action.C
            cooperation_probability = (1 - total_consumption / self.game_description.capacity) ** 2
            random_event = random.random() < self.random_event_probability
            if np.isclose(cooperation_probability, random_event):
                flip_coin = bool(random.randint(0, 1))
                return Action(flip_coin)
            return Action(cooperation_probability > random_event)
        self.total_consumption = 0.0
        return Action.C

class Strategy_COLLECTIVE_331(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy in the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.own_action_prev = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.own_action_prev = None
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            self.own_action_prev = None
            return Action.C
        else:
            if self.own_action_prev is None:
                self.own_action_prev = history.opponent_actions[-1, 0]
            if self.own_action_prev == Action.C and history.opponent_actions[-1, 0] == self.own_action_prev:
                return Action.C
            elif self.own_action_prev == Action.D and history.opponent_actions[-1, 0] == self.own_action_prev:
                return Action.D
            else:
                self.own_action_prev = history.opponent_actions[-1, 0]
                return Action.C

class Strategy_COLLECTIVE_332(BaseStrategy):
    """
    A simple and predictable strategy that promotes cooperation by demonstrating goodwill, imitating opponents' actions and allowing for punishment of defection. It encourages a collective mindset.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        action = self.opponent_history[-1] if len(self.opponent_history) > 0 else Action.C
        self.opponent_history.append(action)
        return action

class Strategy_COLLECTIVE_333(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number < self.game_description.n_rounds - 1:
            self.last_opponent_action = np.mean(history.opponent_actions[:, -1])
        action = Action.C if self.last_opponent_action == 1 else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return action

class Strategy_COLLECTIVE_334(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1,), dtype=bool), np.zeros((1,)), np.zeros((1, game_description.n_players), dtype=bool), np.zeros((1,)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history = PlayerHistory(np.zeros((1,), dtype=bool), np.zeros((1,)), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros((1,)))
            return Action.C
        elif state.round_number == 0:
            self.history = history
            return Action.C
        else:
            last_round = len(self.history.opponent_actions) - 1
            last_action = self.history.my_actions[-1] if len(self.history.my_actions) > 0 else Action.C
            cooperators = sum(self.history.opponent_actions[last_round, :])
            if cooperators >= self.game_description.n_players // 2 and last_action == Action.D:
                self.history.my_payoffs[-1] = (state.current_stock - self.history.total_consumption[-1]) / (self.game_description.n_players * 2)
            elif cooperators >= self.game_description.n_players // 2 and last_action == Action.C:
                self.history.my_payoffs[-1] = (state.current_stock - self.history.total_consumption[-1]) / self.game_description.n_players
            else:
                self.history.my_payoffs[-1] = 0
            self.history = PlayerHistory(np.append(self.history.my_actions, np.array([[last_action]], dtype=bool)), np.append(self.history.my_payoffs, [self.history.my_payoffs[-1]]), self.history.opponent_actions, self.history.opponent_payoffs)
            if last_round == 0 or cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_335(BaseStrategy):
    """
    Adaptive Tit-for-Tat (A-TFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_action_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponent_action_history.append(np.mean(history.opponent_actions[-1]))
        cooperators = np.count_nonzero(history.opponent_actions[-1])
        if cooperators >= self.game_description.n_players // 2 and state.current_stock >= self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_336(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    Strategy Summary: Reciprocates opponent's actions while occasionally demonstrating willingness to maintain the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p = 0.2
        self.recently_defected = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        if all((action == Action.C for action in opponent_actions)):
            return Action.C
        elif any((action == Action.D for action in opponent_actions)) and (not self.recently_defected):
            return Action.D
        elif any((action == Action.D for action in opponent_actions)) and self.recently_defected:
            self.recently_defected = False
            return Action.C
        elif random.random() < self.p:
            self.recently_defected = False
            return Action.C
        else:
            self.recently_defected = True
            return Action.D

class Strategy_COLLECTIVE_337(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_consumption = 0
        self.last_action = Action.C
        self.stock_at_last_cooperation = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.total_consumption += state.round_number * history.my_payoffs[-1] if history else 0
        ACR = self.total_consumption / (state.round_number - 1 + (self.stock_at_last_cooperation is None))
        if state.current_stock <= self.game_description.capacity * 2:
            if state.current_stock == 0:
                return Action.D
            else:
                return Action.C
        if ACR < self.game_description.capacity / (self.game_description.n_players * 2) and history and (history.my_actions[-1] == Action.C):
            self.last_action = Action.C
            self.stock_at_last_cooperation = state.current_stock if not self.stock_at_last_cooperation else self.stock_at_last_cooperation
        elif ACR >= self.game_description.capacity / (self.game_description.n_players * 2) and history and (history.my_actions[-1] == Action.C) or history is None:
            self.last_action = Action.C
        else:
            self.last_action = Action.D
        return self.last_action

class Strategy_COLLECTIVE_338(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_few_rounds = int(math.ceil(game_description.n_rounds * 0.2))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_action = history.opponent_actions[-1, -1] if history else None
        if opponent_action is not None and (opponent_action or history.my_actions[-1]):
            return Action.C
        elif state.round_number >= self.game_description.n_rounds - self.last_few_rounds:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_339(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cp = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_round_opponent_cooperators = sum(history.opponent_actions[last_round, :])
        if state.current_stock > self.cp and last_round_opponent_cooperators > 0:
            return Action.C
        return Action.D

    def last_round_strategy(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds:
            if state.current_stock > self.cp:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_340(BaseStrategy):
    """
    Tit-for-Tat Strategy with Stock Adaptation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity / game_description.n_players * 2
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if self.history is None or state.round_number == 0:
            return Action.C
        consumption_threshold = self.capacity / (2 * self.game_description.n_players)
        total_consumption_prev = np.sum(history.opponent_actions[-1])
        if total_consumption_prev < self.capacity:
            action = Action.C if state.current_stock > self.capacity * 0.5 else Action.D
        else:
            action = Action.D
        payoff = state.current_stock / (2 * self.game_description.n_players) if action == Action.C else state.current_stock / self.game_description.n_players
        self.history = PlayerHistory(np.array([action]) + history.my_actions, np.array([payoff]), history.opponent_actions, history.opponent_payoffs)
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock >= self.capacity:
                action = Action.C
            else:
                action = Action.D
        return action

class Strategy_COLLECTIVE_342(BaseStrategy):
    """
    Tit-for-Tat with adaptations for the Common Pool Resource Game,
    promoting reciprocity and long-term resource conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = self.game_description.capacity // 2
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.C
        if history is not None and (not self.last_round):
            opponent_action = history.opponent_actions[state.round_number - 1, 0]
            if opponent_action != history.my_actions[state.round_number - 1]:
                action = Action.D
        elif state.current_stock <= self.critical_threshold and history is not None:
            opponent_action = history.opponent_actions[state.round_number - 1, 0]
            action = Action.D if opponent_action else Action.C
        self.last_round = state.round_number == self.game_description.n_rounds
        return action

class Strategy_COLLECTIVE_344(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = None
        self.stock_depletion = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or len(history.opponent_actions) < 2:
            self.last_round = None
            self.stock_depletion = 0
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif state.current_stock <= 0:
            self.last_round = None
            self.stock_depletion = 0
        else:
            self.last_round = history.opponent_actions[-1][-1]
            self.stock_depletion += sum(history.opponent_payoffs[-1]) / self.game_description.capacity
        if self.last_round == Action.C and self.stock_depletion < self.game_description.capacity / 2:
            return Action.C
        elif self.last_round == Action.D:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_345(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) with Stock Growth Consideration (SG-ATFT).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_threshold = self.game_description.capacity * self.game_description.n_players // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = np.sum(history.my_actions[-1]) * (2 * self.game_description.n_players)
        if total_consumption >= self.capacity_threshold:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_346(BaseStrategy):
    """
    Titan Strategy for Common Pool Resource Game
    A hybrid approach that balances immediate gains and long-term thinking.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.capacity = self.game_description.capacity
        self.history = PlayerHistory(my_actions=np.zeros((self.game_description.n_rounds,), dtype=bool), my_payoffs=np.zeros((self.game_description.n_rounds,)), opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players)), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or state.current_stock >= self.capacity * 0.5:
            return Action.C
        consumption_history = history.my_actions[-self.game_description.n_rounds:].sum(axis=0) / self.capacity
        if consumption_history <= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_347(BaseStrategy):
    """
    Adaptive Stock-aware Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_stock = None
        self.retaliation_rounds = None
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            self._update_average_stock(history)
            if self.retaliation_rounds is not None and state.round_number < self.game_description.n_rounds - self.retaliation_rounds:
                return Action.D
            elif state.current_stock > self.average_stock:
                return Action.C
            else:
                return Action.D

    def _update_average_stock(self, history):
        total_consumption = np.sum(history.my_payoffs[:-1])
        self.average_stock = (2 * self.game_description.capacity * self.game_description.n_players + total_consumption) / self.game_description.n_rounds
        if self.retaliation_rounds is None and history.my_actions[-1] == Action.D:
            self.retaliation_rounds = self.game_description.n_rounds - state.round_number

    def record(self, action: Action, payoff: float):
        self.history.my_actions[-1] = action == Action.C
        self.history.my_payoffs[-1] = payoff

class Strategy_COLLECTIVE_349(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity_utilization_rate = game_description.capacity / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        consumption_avg = np.mean(history.my_actions[-self.game_description.n_players // 2:])
        if consumption_avg <= self.capacity_utilization_rate:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_350(BaseStrategy):
    """
    Adaptive Cooperative-Competitive (ACC) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.T_low = game_description.capacity // (2 * game_description.n_players)
        self.T_high = game_description.capacity - self.T_low
        self.history = PlayerHistory(my_actions=np.zeros((1, game_description.n_players)), my_payoffs=np.zeros(1), opponent_actions=np.zeros((1, game_description.n_players)), opponent_payoffs=np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        self.history = history
        stock_level = state.current_stock
        observed_behavior = self.analyze_history()
        if stock_level < self.T_low:
            return Action.D
        elif stock_level > self.T_high:
            return Action.C
        if self.is_cooperative_tendency(observed_behavior):
            return Action.C
        else:
            return Action.D

    def analyze_history(self) -> NDArray[np.bool_]:
        """
        Analyze history to determine the observed behavior of other players.
        """
        cooperators = sum(self.history.opponent_actions[-1, :])
        return np.array([cooperator >= self.game_description.n_players // 2 for cooperator in self.history.opponent_actions[:, -1]])

    def is_cooperative_tendency(self, behavior: NDArray[np.bool_]) -> bool:
        """
        Check if the observed behavior indicates cooperative tendencies.
        """
        return np.mean(behavior) >= 0.5

class Strategy_COLLECTIVE_351(BaseStrategy):
    """
    Adaptive Resource Sharing (ARS) Strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.current_threshold = self.capacity / (2 * self.n_players)
        self.adjustment_factor = 0.05
        self.average_consumption = None
        self.total_consumed = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.average_consumption is None:
            self.average_consumption = np.zeros(self.game_description.n_rounds)
        self.total_consumed += sum([state.current_stock - x for x in history.opponent_payoffs[-1]]) if history else 0
        self.average_consumption[state.round_number] = self.total_consumed / state.round_number * self.n_players
        if state.current_stock < self.capacity / (2 * self.n_players):
            return Action.C if self.average_consumption[-1] > self.current_threshold else Action.D
        self.current_threshold += self.adjustment_factor if self.total_consumed > self.capacity / (2 * self.n_players) else -self.adjustment_factor
        return Action.C if self.total_consumed <= state.current_stock else Action.D

class Strategy_COLLECTIVE_352(BaseStrategy):
    """
    The Adaptive Tit-for-Tat (ATfT) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history = PlayerHistory(np.array([[True]], dtype=bool), np.array([[state.current_stock / (2 * self.game_description.n_players)]]), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1))
            return Action.C
        elif state.round_number == 0:
            self.history = PlayerHistory(np.array([[True]], dtype=bool), np.array([[state.current_stock / (2 * self.game_description.n_players)]]), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1))
        else:
            self.history = PlayerHistory(self.history.my_actions, self.history.my_payoffs, history.opponent_actions[:, 1:], history.opponent_payoffs)
            if np.all(self.history.opponent_actions[-1]) or any([not action for action in self.history.opponent_actions[-1]]):
                return Action.C if np.all(self.history.opponent_actions[-1]) else Action.D
            else:
                return self.history.opponent_actions[-1, -1]

class Strategy_COLLECTIVE_353(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_period = math.floor(game_description.n_players * 0.75)
        self.total_cooperative_actions = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        action = Action.C
        if state.round_number == 0 or history is None:
            pass
        elif history:
            opponent_cooperative_last_round = sum(history.opponent_actions[-1])
            if opponent_cooperative_last_round > self.game_description.n_players // 2:
                action = Action.C
                self.total_cooperative_actions += 1
            elif state.round_number > self.punishment_period:
                pass
            else:
                action = Action.D
                if state.round_number > self.punishment_period + len(history.opponent_actions) * len(history.opponent_actions[0]):
                    self.punishment_period -= 1
        return action

class Strategy_COLLECTIVE_354(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Adaptation (TfT-SA)
    Strategy Description: Cooperate in the first round, and thereafter cooperate if opponent cooperated in the previous round, defect otherwise. Adapt to the stock level by adjusting the threshold for switching from cooperation to defection based on the remaining stock relative to capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity * 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            self.threshold = self.game_description.capacity * 0.5
        opponent_action = history.opponent_actions[state.round_number - 1, 0] if history else False
        if opponent_action:
            return Action.C
        return Action.D
        current_stock = state.current_stock
        if current_stock >= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_355(BaseStrategy):
    """
    Strategy Name: Adaptive Resource-Optimized (ARO) Strategy
    A resource-preserving strategy that prioritizes long-term sustainability and payoff maximization by adapting to opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_growth_factor = 2.0
        self.average_consumption_threshold = self.game_description.capacity / (2 * game_description.n_players)
        self.growth_factor = 1.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D if state.current_stock < self.game_description.capacity / self.game_description.n_players else Action.C
        consumption_history = history.my_actions[-1] if history is not None else np.zeros(self.game_description.n_rounds, dtype=bool)
        total_consumption = np.sum(consumption_history)
        average_consumption = total_consumption / (state.round_number + 1) if state.round_number > 0 else 0
        choice = Action.C
        if average_consumption > self.average_consumption_threshold * self.growth_factor:
            choice = Action.D
        elif average_consumption < self.average_consumption_threshold:
            choice = Action.C
        else:
            choice = random.choice([Action.C, Action.D])
        return choice

class Strategy_COLLECTIVE_356(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-CT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_cooperative_threshold = self.game_description.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.C
        if history is not None and history.my_actions[-1] != Action.C:
            action = Action.D
        elif state.current_stock < self.capacity_cooperative_threshold:
            action = Action.D
        return action

class Strategy_COLLECTIVE_357(BaseStrategy):
    """
    Tit-for-Tat-Growth (TfT-G) strategy for Common Pool Resource Game.
    This strategy aims to maintain a balanced and sustainable common pool resource while also fostering cooperation by reciprocating cooperative actions from opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_stock = game_description.capacity / game_description.n_players * ((2 * game_description.n_players - 1) / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock >= self.average_stock:
                return Action.C
        if len(np.logical_and(history.my_actions[-1], ~history.opponent_actions[-1, :])) == 1:
            if state.current_stock < self.average_stock and history.my_actions[-2][0] == Action.C:
                return Action.D
            elif state.current_stock >= self.average_stock:
                return Action.C
        if state.current_stock >= self.average_stock:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_358(BaseStrategy):
    """
    A Tit-for-Tat strategy for the Common Pool Resource Game.
    This strategy encourages cooperation by mimicking opponents' actions and allows for retaliation against defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_survival_level = int(game_description.capacity * 0.5)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1 if history else None
        last_opponent_action = history.opponent_actions[last_round, 0] if last_round is not None else None
        if last_opponent_action is None or state.current_stock >= self.critical_survival_level:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_359(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)
    Strategy Description: Cooperates in the initial round and responds to opponents' actions based on past interactions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.n_players / 2)
        self.mem_i = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        current_action = Action.D
        if all(history.opponent_actions[-1, :] == [True] * len(history.opponent_actions[0])):
            current_action = Action.C
            self.mem_i = []
        else:
            self.mem_i.append(current_action)
            if len(self.mem_i) > self.threshold:
                self.mem_i.pop(0)
        return current_action

class Strategy_COLLECTIVE_360(BaseStrategy):
    """
    Tit for Tat Adaptive (TFT-A) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = -1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.C
        else:
            last_round = self.last_round + 1
            opponent_cooperators = sum(history.opponent_actions[last_round, :])
            return Action(opponent_cooperators >= self.game_description.n_players // 2 and Action.C == history.my_actions[last_round])
        self.last_round = state.round_number

class Strategy_COLLECTIVE_361(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)
    - Cooperates with opponents initially to set a cooperative tone.
    - Punishes defectors by reciprocating their actions and rewards cooperators.
    - Prioritizes collective wellbeing and encourages cooperation among players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._opponent_index = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not history:
            return Action.C
        self._opponent_index = np.argmax(history.my_actions)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if history.opponent_actions[-1, self._opponent_index] == Action.C else Action.D
        else:
            opponent_action = history.opponent_actions[-1, self._opponent_index]
            return Action.C if opponent_action == Action.C else Action.D
        total_consumption = np.sum(history.my_actions * (Action.C.value + 1))
        stock_after_consumption = state.current_stock - total_consumption
        growth = 2 * min(capacity=self.game_description.capacity, x=stock_after_consumption) * (1 - min(capacity=self.game_description.capacity, x=stock_after_consumption) / self.game_description.capacity)
        new_stock = max(0, stock_after_consumption + growth)

class Strategy_COLLECTIVE_362(BaseStrategy):
    """
    Tit-for-Tat Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_action = history.opponent_actions[last_round, :].any()
        if last_action:
            return Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        if state.round_number == self.game_description.n_rounds - 1 and cooperators < self.game_description.n_players // 2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_363(BaseStrategy):
    """
    Adaptive Resource Allocation (ARA) strategy for Common Pool Resource Game.
    Prioritizes long-term collective interest over individual short-term gains by promoting resource conservation and growth.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        average_consumption = np.mean(history.my_actions[:-1]) * self.game_description.capacity / self.n_players
        if average_consumption <= state.current_stock / self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_365(BaseStrategy):
    """
    A Tit-for-Tat (TFT) Strategy in the Common Pool Resource Game.
    This strategy cooperates by default, then mimics its opponent's previous action.
    It forgives conflicts and resumes cooperation in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        self._last_opponent_action = history.opponent_actions[-1, 0]
        if self._last_opponent_action:
            return Action.C
        return Action.D

    def reset(self):
        """
        Reset strategy state variables when needed.
        In this case, we only need to set the last opponent action to None.
        """
        self._last_opponent_action = None

class Strategy_COLLECTIVE_366(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_players = self.game_description.n_players
        self.capacity = self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        if history.my_actions[-1] is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-1])
        if cooperators >= self.num_players - 1 or (cooperators == 0 and state.round_number < self.game_description.n_rounds - 1):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_367(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.strategy_name = self.__class__.__name__
        self.depleted_threshold = 2 * (self.game_description.n_players - 1)
        self.last_round = self.game_description.n_rounds - 1
        self.stock_level = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.stock_level = state.current_stock / self.game_description.n_players
            if self.last_round < state.round_number or self.stock_level > self.depleted_threshold:
                return Action.C if history.opponent_actions[-1, -1] == Action.C else Action.D
        return Action.C

class Strategy_COLLECTIVE_368(BaseStrategy):
    """
    Adaptive Resource-conscious Cooperative Strategy (ARCS) for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.minimum_stock = game_description.capacity
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and self.round_number > 0:
            self.minimum_stock = min(state.current_stock, self.minimum_stock)
        if state.round_number == 0:
            return Action.C
        consumption = math.ceil(state.current_stock / (2 * self.game_description.n_players)) + math.ceil(state.current_stock / self.game_description.n_players)
        growth_potential = 2 * state.current_stock * (1 - state.current_stock / self.game_description.capacity)
        expected_payoff_C = (self.game_description.n_rounds - self.round_number + 1) * ((state.current_stock + growth_potential) / (2 * self.game_description.n_players))
        expected_payoff_D = (self.game_description.n_rounds - self.round_number + 1) * (state.current_stock / self.game_description.n_players)
        if state.current_stock <= self.minimum_stock // 2:
            return Action.D
        elif expected_payoff_C >= expected_payoff_D:
            return Action.C
        else:
            return Action.D
        self.minimum_stock = state.current_stock if state.current_stock > self.minimum_stock else self.minimum_stock
        self.round_number += 1

class Strategy_COLLECTIVE_369(BaseStrategy):
    """
    Adaptive Fitness-Driven Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ideal_consumption = None
        self.consumption_history = []
        self.tolerance = 0.2

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.ideal_consumption:
            self.ideal_consumption = self.game_description.capacity / self.game_description.n_players
        consumption_rate = np.mean(history.opponent_actions[:, 1] * (state.current_stock - np.sum(history.my_payoffs)) / self.game_description.n_players)
        if consumption_rate > self.ideal_consumption + self.tolerance:
            return Action.D
        elif consumption_rate < self.ideal_consumption - self.tolerance:
            return Action.C
        elif state.current_stock * 2 / self.game_description.capacity > self.ideal_consumption:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_370(BaseStrategy):
    """
    Adaptive Stock-based Cooperation (ASC) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_stock = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            stock = state.current_stock
            growth_threshold = self.game_description.capacity * 0.85
            action = Action.C if stock > growth_threshold else Action.D
        else:
            if history is None:
                return Action.C
            stock_levels = np.array([state.current_stock for _ in range(state.round_number + 1)])
            self.average_stock = np.mean(stock_levels)
            threshold = self.game_description.capacity / (2 * self.game_description.n_players + 0.5 * self.average_stock)
            action = Action.D if state.current_stock < threshold else Action.C
        return action

class Strategy_COLLECTIVE_371(BaseStrategy):
    """
    Tit-for-Tat Adaptive Strategy (TFT-A) for Common Pool Resource Game.
    This strategy cooperates in the initial round and then adapts its decisions based on opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.escalation_threshold = 100 - game_description.capacity / (2 * game_description.n_players)
        self.last_opponent_avg_consumption = 0
        self.current_round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or self.current_round == 0:
            return Action.C
        self.current_round = state.round_number
        if state.round_number == 1:
            self.last_opponent_avg_consumption = sum(history.opponent_actions[0]) / (self.game_description.n_players - 1)
        average_consumption = np.mean(history.opponent_actions[:, np.arange(self.game_description.n_players) != self.current_round % self.game_description.n_players])
        if average_consumption < (self.game_description.capacity - 2 * self.game_description.n_players) / (2 * self.game_description.n_players):
            return Action.C
        elif average_consumption > self.escalation_threshold:
            return Action.D
        elif history.my_actions[-1] == Action.D:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_372(BaseStrategy):
    """
    Strategy that fosters cooperation while being robust against various opponent behaviors in the Common Pool Resource Game.
    It adjusts its behavior based on the average stock level over the last three rounds and uses a Tit-for-Tat approach to punish defection while maintaining long-term resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold_high = math.floor(self.game_description.capacity * 0.6 / self.game_description.n_players)
        self.cooperation_threshold_low = math.floor(self.game_description.capacity * 0.4 / self.game_description.n_players)
        self.average_stock_window = 3
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None):
        current_round = state.round_number
        if not history:
            return Action.C
        if current_round == self.game_description.n_rounds:
            average_stock = np.mean(history.my_payoffs[-self.average_stock_window:])
            last_opponent_action = history.opponent_actions[current_round - 1, 0]
        else:
            average_stock = np.mean(history.my_payoffs[-self.average_stock_window:])
            last_opponent_action = self.last_opponent_action
        if average_stock < self.cooperation_threshold_low and last_opponent_action or (average_stock > self.cooperation_threshold_high and (not last_opponent_action)):
            self.last_opponent_action = last_opponent_action
            return Action.D
        self.last_opponent_action = last_opponent_action
        return Action.C

class Strategy_COLLECTIVE_373(BaseStrategy):
    """
    Tit-for-Tat with Growth Adaptation (TfT-GA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._last_round_cooperators = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            self._last_round_cooperators = sum(history.opponent_actions[-1])
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = self._last_round_cooperators
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

    def update_history(self, history: PlayerHistory) -> None:
        self._last_round_cooperators = sum(history.opponent_actions[-1])

class Strategy_COLLECTIVE_375(BaseStrategy):
    """
    The Adaptive Stock Preservation (ASP) strategy aims to preserve the common pool resource by encouraging cooperation when the stock is abundant and adapting to maintain positive stock growth.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_capacity = self.game_description.capacity * self.game_description.n_players * self.game_description.n_rounds
        self.historical_growth = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return random.choice([Action.C, Action.D])
        stock_growth = self.calculate_historical_growth(self.historical_growth) if self.historical_growth else None
        if state.current_stock > self.average_capacity:
            return Action.C
        elif state.current_stock <= 0:
            return Action.D
        elif stock_growth is not None and stock_growth > 0:
            return Action.C
        else:
            return Action.D

    def calculate_historical_growth(self, data: list) -> float:
        if len(data) == 0:
            return None
        growths = []
        for i in range(1, len(data)):
            total_consumption = sum([d[i - 1].my_payoffs[-1] for d in data]) - data[-1].my_payoffs[-1]
            stock_remaining = state.current_stock - total_consumption
            growth = 2 * stock_remaining * (1 - stock_remaining / self.game_description.capacity)
            growths.append(growth)
        return np.mean(np.array(growths))

class Strategy_COLLECTIVE_377(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.last_opponent_action = history.opponent_actions[-1].any()
        if self.last_opponent_action:
            return Action.C
        else:
            return Action.D

    def update_history(self, new_history: PlayerHistory):
        self.last_opponent_action = new_history.opponent_actions[-1].any()

class Strategy_COLLECTIVE_378(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_threshold = int(self.game_description.n_players * 0.7)
        self.borderline_ratio = 0.5

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        cooperation_ratio = np.mean(history.opponent_actions[:, -1])
        defection_ratio = (self.game_description.n_players - np.sum(history.opponent_actions[:, -1])) / self.game_description.n_players
        if cooperation_ratio >= self.round_threshold:
            return Action.C
        elif defection_ratio >= self.round_threshold:
            return Action.D
        elif cooperation_ratio > defection_ratio:
            return Action.C
        else:
            return Action.D

    def calculate_payoff(self, state: CommonPoolState, history: PlayerHistory) -> float:
        pass

class Strategy_COLLECTIVE_379(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) with Stock Growth Awareness (SG) for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.growth_rate_if_all_cooperate = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.growth_rate_if_all_cooperate = self.calculate_growth_rate(state.current_stock, self.game_description.n_players)
            return Action.C
        if history.my_actions[-1] is None:
            return Action.C
        opponent_last_move = np.sum(history.opponent_actions[-1]) > self.game_description.n_players // 2
        if opponent_last_move:
            potential_growth_rate = self.calculate_potential_growth_rate(state.current_stock, state.round_number + 1)
            if potential_growth_rate > self.growth_rate_if_all_cooperate:
                return Action.D
            else:
                return Action.C
        elif state.current_stock < self.game_description.capacity * (2 * self.game_description.n_players - 1):
            return Action.C
        else:
            potential_growth_rate = self.calculate_potential_growth_rate(state.current_stock, state.round_number + 1)
            if potential_growth_rate <= self.growth_rate_if_all_cooperate:
                return Action.C
            else:
                return Action.D

    def calculate_growth_rate(self, stock: float, n: int) -> float:
        total_consumption = self.game_description.n_players * math.floor(stock / (2 * self.game_description.n_players))
        remaining_stock = stock - total_consumption
        growth = 2 * remaining_stock * (1 - remaining_stock / self.game_description.capacity)
        return growth

    def calculate_potential_growth_rate(self, stock: float, round_number: int) -> float:
        total_consumption = self.game_description.n_players * math.floor(stock / self.game_description.n_players)
        remaining_stock = stock - total_consumption
        growth = 2 * remaining_stock * (1 - remaining_stock / self.game_description.capacity)
        return growth if round_number == 1 else self.growth_rate_if_all_cooperate

class Strategy_COLLECTIVE_380(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and history.my_actions[-1] == Action.C):
            return Action.C
        if history is not None and self.defection_counter < self.game_description.n_players - 1:
            self.defection_counter += 1 if history.my_actions[-1] == Action.D else 0
            return Action.D
        self.defection_counter = 0
        return Action.C

class Strategy_COLLECTIVE_381(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy
    Maintains a balance between cooperation and self-interest while remaining adaptable to various opponent behaviors.
    By mirroring opponents' actions, it encourages long-term cooperation when possible, but also defends against defection without retaliating unnecessarily.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.game_description.n_rounds - 1 or history.opponent_actions[-1, -1] != self.last_opponent_action:
            self.last_opponent_action = Action(int(history.opponent_actions[-1, -1]))
            return Action.C
        opponent_actions = history.opponent_actions[:, -1]
        cooperators = sum(opponent_actions)
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_382(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(shape=(1, 2), dtype=bool), np.zeros(shape=(1,)), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(shape=(1, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        last_opponent_action = history.opponent_actions[-1, -1]
        if last_opponent_action:
            return Action.C
        else:
            return Action.D
        self.history = PlayerHistory(self.history.my_actions, np.append(self.history.my_payoffs, state.current_stock / (2 * self.game_description.n_players)), self.history.opponent_actions, np.append(self.history.opponent_payoffs, state.current_stock / self.game_description.n_players))

class Strategy_COLLECTIVE_383(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []
        self.current_round = 0
        self.forgiveness_mode = False
        self.defections_threshold = int(game_description.n_players // 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.opponent_history.append({'actions': history.opponent_actions[-1], 'payoffs': history.opponent_payoffs[-1]})
            self.current_round += 1
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(self.opponent_history[-1]['actions'])
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif not self.forgiveness_mode:
            return Action.D
        else:
            return Action.C
        if self.current_round >= len(self.opponent_history) or (self.current_round < len(self.opponent_history) and self.current_round - self.defections_threshold > 3):
            defections = sum([sum(x['actions']) for x in self.opponent_history[-len(self.opponent_history) - self.defections_threshold:]])
            if defections <= len(self.opponent_history) * (self.game_description.n_players // 2):
                self.forgiveness_mode = False
        return Action.C

class Strategy_COLLECTIVE_385(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        self.minimum_stock_level = self.game_description.capacity // 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        average_consumption = np.mean(history.opponent_actions[:, -1])
        if average_consumption > self.threshold and state.round_number < self.game_description.n_rounds or (state.round_number == self.game_description.n_rounds and state.current_stock <= self.minimum_stock_level):
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_386(BaseStrategy):
    """
    A strategy that mimics the opponent's action from the previous round,
    promoting cooperation and punishing defection without being overly aggressive or forgiving.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_length = int(game_description.n_players // 4)
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.last_opponent_action = sum(history.opponent_actions[-1]) == 0
        if state.round_number == 0:
            return Action.C
        elif not history:
            return Action.C
        current_action = self.last_opponent_action and state.round_number <= self.punishment_length and Action.D or Action.C
        if state.round_number == self.game_description.n_rounds or not self.last_opponent_action:
            current_action = Action.C
        return current_action

class Strategy_COLLECTIVE_388(BaseStrategy):
    """
    Strategy Name: Adaptive Stock Preservation (ASP)
    Summary: This strategy makes decisions based on the current stock level and the expected payoff for cooperating versus defecting. It favors cooperation if the expected payoff is higher than defection, except in the first round where a random choice is made to break symmetry.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.random = random.Random()

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return self.random.choice([Action.C, Action.D])
        expected_payoff_coop = state.current_stock / (2 * self.game_description.n_players)
        expected_payoff_defect = state.current_stock / self.game_description.n_players
        if expected_payoff_coop > expected_payoff_defect:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_389(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 2 / 3 * self.game_description.capacity
        self.current_round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.current_round = state.round_number
        if not history:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1])
        total_consumption = np.sum(history.my_actions) * self.game_description.n_players
        if self.current_round == self.game_description.n_rounds:
            return Action.C
        elif opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif total_consumption < self.threshold:
            return Action.C
        elif total_consumption >= self.threshold:
            return Action.D
        elif random.random() < 0.05:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_391(BaseStrategy):
    """
    Strategy Name: Adaptive Stock Preservation (ASP) Strategy
    This strategy uses a Tit-for-Tat-like approach with stock preservation consideration.
    It alternates between cooperation and defection based on the average consumption rate of opponents in the previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 1.0
        self.average_consumption = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.average_consumption is None:
            self.average_consumption = np.mean(history.opponent_actions[:, 1:].sum(axis=1) / self.game_description.n_players)
        if history and state.round_number < self.game_description.n_rounds - 1:
            cooperate = self.average_consumption < self.threshold
            return Action(int(cooperate)) if cooperate else Action.D
        return Action.C

class Strategy_COLLECTIVE_394(BaseStrategy):
    """
    A Tit-for-Tat Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round = 0
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.round = state.round_number + 1
            self.last_opponent_action = np.mean(history.opponent_actions[:, -1])
        if state.round_number == 0:
            return Action.C
        elif self.last_opponent_action is None or (self.round > 1 and self.last_opponent_action == 1):
            return Action.C
        elif self.round > 1 and self.last_opponent_action == 0:
            if self.round <= self.game_description.n_rounds:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_395(BaseStrategy):
    """
    A Fisher-Rapoport-Axelrod (FRA) adaptive strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.tau = 0.5
        self.history_length = int(math.ceil(game_description.n_rounds * 0.8))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_payoff_c = np.mean(history.my_payoffs[-self.history_length:][history.my_actions[-self.history_length:] == True])
        avg_payoff_d = np.mean(history.my_payoffs[-self.history_length:][history.my_actions[-self.history_length:] == False])
        if avg_payoff_c > self.tau * (avg_payoff_d + state.current_stock / (2 * self.game_description.n_players)) and state.round_number < self.game_description.n_rounds:
            return Action.C
        elif avg_payoff_d > self.tau * (avg_payoff_c + state.current_stock / (2 * self.game_description.n_players)) and state.round_number < self.game_description.n_rounds:
            return Action.D
        elif random.random() <= 0.5:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action.C

class Strategy_COLLECTIVE_397(BaseStrategy):
    """
    A Tit-for-Tat with Stock Adaptation (TFT-SA) strategy for Common Pool Resource Games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity // 2
        self.last_round = False
        self.last_opponent_cooperated = False
        self.fewer_than_10_percent_remaining = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and history.my_actions is None):
            return Action.C
        self.last_round = state.round_number == self.game_description.n_rounds
        self.last_opponent_cooperated = np.all(history.opponent_actions[-1]) if history is not None else False
        if history is not None:
            if self.last_opponent_cooperated:
                return Action.C
            elif np.sum(history.opponent_actions[-1]) > self.game_description.n_players // 2:
                return Action.D
        else:
            return Action.D
        if state.current_stock < self.threshold and (not self.last_round):
            self.fewer_than_10_percent_remaining = True
            return Action.D
        if self.fewer_than_10_percent_remaining and (not self.last_round):
            self.fewer_than_10_percent_remaining = False
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_398(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Sensitivity strategy for Common Pool Resource Game.
    Prioritizes cooperation and sustainable resource management by penalizing short-term exploitative behavior, while also fostering reciprocal cooperation among players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5 * self.game_description.n_players * self.game_description.capacity
        self.stock_threshold = self.threshold + 0.1 * self.game_description.n_players * self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = self.get_ATfT_action(history) if history is not None else Action.D
        stock_level = self.calculate_stock_level(state, history)
        if stock_level < self.threshold:
            return action if history and history.opponent_actions[-1][-1] == Action.C.value else Action.D
        elif stock_level > self.stock_threshold:
            return self.get_ATfT_action(history)
        return action

    def get_ATfT_action(self, history: PlayerHistory):
        opponent_cooperated = sum(history.opponent_actions[-1]) >= self.game_description.n_players // 2
        return Action.C if opponent_cooperated else Action.D

    def calculate_stock_level(self, state: CommonPoolState, history: None | PlayerHistory) -> float:
        total_consumption = np.sum([np.sum(history.opponent_actions[:state.round_number + 1]) for _ in range(1, state.round_number + 1)]) if history is not None else 0
        consumption = total_consumption * self.game_description.n_players / self.game_description.capacity
        return max(min(state.current_stock - consumption, self.game_description.capacity), 0)

class Strategy_COLLECTIVE_399(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for the Common Pool Resource Game.
    This strategy cooperates in the first round, and thereafter mimics the opponent's action from the previous round, fostering cooperation and resource preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity * 0.9

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number < self.game_description.n_rounds:
            opponentAction = history.opponent_actions[state.round_number - 1, 0]
            if opponentAction and state.current_stock >= self.threshold:
                return Action.C
            elif opponentAction:
                return Action.D
        return Action.C if state.current_stock > 0 else Action.D

class Strategy_COLLECTIVE_400(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = np.sum(history.my_actions[:state.round_number]) / state.round_number
        if total_consumption < self.capacity:
            return Action.C
        return Action.D

    def last_round_or_almost(self, state):
        return state.round_number == self.game_description.n_rounds or self.game_description.n_rounds - state.round_number <= math.floor(0.1 * self.game_description.n_rounds)

class Strategy_COLLECTIVE_401(BaseStrategy):
    """
    Tit-for-Tat Adaptive (TFT-A) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_payoff = 0.0
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            self._choose_optimal_action(state, history)
            return self._get_optimal_action()
        opponent_cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        return Action.C if opponent_cooperators >= self.game_description.n_players // 2 or self.last_opponent_action is None else Action.D

    def _get_optimal_action(self) -> Action:
        return Action.C if self.total_payoff > self._calculate_payoff_for_defection() else Action.D

    def _choose_optimal_action(self, state: CommonPoolState, history: PlayerHistory) -> None:
        payoff_for_cooperation = self._calculate_payoff_for_cooperation(state, history)
        payoff_for_defection = self._calculate_payoff_for_defection()
        self.total_payoff += max(payoff_for_cooperation, payoff_for_defection)
        if payoff_for_cooperation > payoff_for_defection:
            self.last_opponent_action = None
        else:
            self.last_opponent_action = Action.D

    def _calculate_payoff_for_cooperation(self, state: CommonPoolState, history: PlayerHistory) -> float:
        if history is not None:
            return state.current_stock / (2 * self.game_description.n_players) + np.mean(history.my_payoffs[:-1])
        return state.current_stock / (2 * self.game_description.n_players)

    def _calculate_payoff_for_defection(self) -> float:
        return self.total_payoff + self.game_description.capacity / self.game_description.n_players - self.total_payoff / (2 * self.game_description.n_players)

class Strategy_COLLECTIVE_402(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) with Stock Optimization (SO) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.T_cooperate = self.capacity / self.n_players
        self.T_defect = self.capacity / (2 * self.n_players)
        self.P_ambiguity = 0.5
        self.R_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if not history and state.round_number == 0:
            return Action.C
        if len(self.R_history) < self.game_description.n_rounds:
            self.R_history.append(None)
        stock_growth = self.R_history[-1] if state.round_number != 0 else None
        current_stock = state.current_stock

        def updateHistory():
            self.R_history[state.round_number - 1] = stock_growth
        updateHistory()
        action = Action.C if current_stock > self.T_cooperate else Action.D if current_stock < self.T_defect else Action.C if random.random() < self.P_ambiguity else Action.D
        if state.round_number == self.game_description.n_rounds:
            if current_stock < self.capacity * (self.n_players - 1) / self.capacity:
                action = Action.D
        return action

class Strategy_COLLECTIVE_403(BaseStrategy):
    """
    Strategy name: Adaptive Resource Harvesting (ARH) Strategy
    Summary: A game theory strategy that prioritizes long-term resource preservation while being flexible enough to adjust based on opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.r_rounds = game_description.n_rounds
        self.average_consumption_history = np.zeros(self.r_rounds, dtype=np.float64)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r_rounds:
            return self.decision_rule(state, history)
        consumption = np.sum(history.opponent_actions[:, -1] * (self.game_description.n_players / state.current_stock)) if history is not None else 0
        self.average_consumption_history[-1] = consumption
        average_consumption = np.mean(self.average_consumption_history)
        resource_percentage = state.current_stock / self.capacity
        if resource_percentage > 0.85 or resource_percentage < 0.65:
            return Action.C if resource_percentage > 0.85 else Action.D
        elif resource_percentage >= 0.65 and resource_percentage <= 0.85:
            return Action.C if average_consumption > resource_percentage else Action.D

class Strategy_COLLECTIVE_404(BaseStrategy):
    """
    A Tit-for-Tat Strategy for the Common Pool Resource Game that encourages cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or self.round == 0:
            return Action.C
        self.round += 1
        opponent_last_move = np.sum(history.opponent_actions[-1])
        return Action(opponent_last_move > 0)

    def edge_cases(self, stock: float, round: int):
        if round == self.game_description.n_rounds and stock <= 0:
            return Action.D
        return None

class Strategy_COLLECTIVE_405(BaseStrategy):
    """
    A strategy that implements the Tit-for-Tat Adaptive approach in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_payoff = 0.0
        self.last_round = -1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and self.last_round >= 0:
            self.total_payoff += np.sum(history.my_payoffs[-1])
        if state.round_number == 0:
            return Action.C
        elif state.round_number < self.game_description.n_rounds:
            last_opponent_actions = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=bool)
            cooperators = sum(last_opponent_actions)
            return Action(int(cooperators >= self.game_description.n_players // 2))
        else:
            total_payoff_threshold = self.game_description.capacity * (self.game_description.n_rounds - 1) / (2 * self.game_description.n_players)
            if self.total_payoff > total_payoff_threshold:
                return Action.C
            else:
                return Action.D
        self.last_round = state.round_number - 1

class Strategy_COLLECTIVE_406(BaseStrategy):
    """
    Adaptive Cooperative-Defective Resource Management (ACDRM) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.total_payoff = 0
        self.num_rounds = 0
        self.cooperative_advantage = np.zeros(self.game_description.n_rounds)
        self.past_cooperative_advantage_average = np.mean(self.cooperative_advantage[:-1]) if len(self.cooperative_advantage) > 1 else 0
        self.total_cooperative_advantage = sum(self.cooperative_advantage) / self.num_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        self.num_rounds = state.round_number
        payoff_cooperate = state.current_stock / (2 * self.game_description.n_players) if history is not None else 0
        payoff_defect = state.current_stock / self.game_description.n_players
        cooperative_advantage = max(payoff_cooperate - payoff_defect, 0) / max(payoff_cooperate - min(payoff_defect, 0), 0)
        self.cooperative_advantage[self.num_rounds - 1] = cooperative_advantage
        self.past_cooperative_advantage_average = np.mean(self.cooperative_advantage[:-1]) if len(self.cooperative_advantage) > 1 else 0
        self.total_cooperative_advantage = sum(self.cooperative_advantage) / self.num_rounds
        cds = (cooperative_advantage + self.past_cooperative_advantage_average + self.total_cooperative_advantage) / 3
        if cds > self.threshold:
            return Action.C
        elif random.random() < math.exp(cds - self.threshold):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_407(BaseStrategy):
    """
    Adaptive Cooperation Strategy (ACS) for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = 0.0
        self.total_stock = 0.0
        self.rounds_played = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.total_stock = state.current_stock
            self.rounds_played = 1
            return Action.C
        self.average_consumption = np.mean(history.opponent_payoffs) / (state.current_stock / self.game_description.n_players)
        self.total_stock += state.current_stock - history.my_payoffs[-1] if self.rounds_played > 0 else state.current_stock
        self.rounds_played += 1
        if state.current_stock < self.game_description.capacity / self.game_description.n_players:
            return Action.D
        if self.average_consumption > self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.D
        elif self.average_consumption <= self.game_description.capacity / (3 * self.game_description.n_players) and state.current_stock >= self.game_description.capacity * 2 / 3:
            return Action.C
        elif random.random() < 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_408(BaseStrategy):
    """
    Tit-for-Tat Adaptive Strategy for Common Pool Resource Game.
    Cooperates in the first round, copies opponent's action from previous round,
    and cooperates in the last round or if initial stock is depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_stock_depletion_threshold = game_description.capacity // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        last_round = state.round_number - 1 if history else None
        opponent_actions = history.opponent_actions[last_round, :] if history else None
        if opponent_actions is not None and self.game_description.n_players > len(np.where(opponent_actions)[0]):
            last_cooperators = np.sum(opponent_actions)
            return Action(last_cooperators >= self.game_description.n_players // 2)
        if history and state.round_number == self.game_description.n_rounds:
            return Action.C
        if history and state.current_stock <= self.initial_stock_depletion_threshold:
            return Action.D
        return history.opponent_actions[state.round_number - 2, :][0] if history else None

class Strategy_COLLECTIVE_410(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) with Stock Dynamics Awareness (SDA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity
        self.min_stock = 0.8 * self.capacity
        self.max_stock = 0.9 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0:
            return action
        if history is None:
            return action
        opponent_action = history.opponent_actions[-1][-1]
        stock = state.current_stock
        if stock < self.min_stock:
            action = Action.D
        elif stock > self.max_stock:
            action = Action.C
        elif opponent_action:
            action = Action.C
        else:
            action = Action.D
        return action

class Strategy_COLLECTIVE_412(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (A-TFT)

    This strategy implements the Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    It cooperates in the first round and adapts its behavior based on opponents' strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 4
        self.learning_rate = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is None:
            return Action.D
        last_round = state.round_number - 1
        my_action = history.my_actions[last_round]
        opponent_actions = history.opponent_actions[last_round]
        if np.count_nonzero(opponent_actions) == self.game_description.n_players:
            self.threshold += self.learning_rate
        if my_action and np.count_nonzero(opponent_actions) < self.game_description.n_players:
            return Action.C
        elif not my_action and np.count_nonzero(opponent_actions) >= self.game_description.n_players:
            return Action.D
        predicted_defection_probability = len(history) > 1 and np.mean(history.opponent_payoffs[:last_round + 1]) < history.my_payoffs[:last_round + 1].mean() or random.random() <= self.threshold
        if predicted_defection_probability:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_413(BaseStrategy):
    """
    Adaptive Stock Conservation Strategy that cooperates when resource pool is plentiful and adapts based on current state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        if state.round_number == 0:
            return Action.C
        cooperation_probability = stock / self.capacity * 0.5 - 0.25
        cooperation_probability = max(min(cooperation_probability, 1), 0)
        if stock > self.capacity * 0.75:
            return Action.C
        elif stock <= self.capacity * 0.5:
            return Action.D
        elif random.random() < cooperation_probability:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_414(BaseStrategy):
    """Tit-for-Tat Adaptive Strategy (TFT-A) for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if self.history is not None:
            last_round = len(self.history.opponent_actions) - 1
            if last_round < self.game_description.n_rounds - 1:
                if self.history.opponent_actions[-1, -1] == Action.C.value:
                    return Action.C
                elif self.history.opponent_actions[-1, -1] == Action.D.value:
                    return Action.D
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_415(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_defection = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif self.last_round_defection and np.all(history.opponent_actions[-1, :]):
            return Action.C
        elif self.last_round_defection or not np.any(history.opponent_actions[-1, :]):
            return Action.D
        else:
            return Action.C
        self.last_round_defection = True

class Strategy_COLLECTIVE_416(BaseStrategy):
    """
    Strategy that implements the Adaptive Tit-for-Tat approach in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.tr = 0.6
        self.t = int(game_description.n_rounds / 3)
        self.N = int(game_description.n_rounds * 0.2)
        self.history = PlayerHistory(np.zeros((1, game_description.n_players), dtype=bool), np.zeros((1,), dtype=np.float64), np.zeros((game_description.n_rounds + 1, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds + 1,), dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.history = history
        if state.round_number == 0:
            return Action.C
        cr_sum = np.mean(self.history.my_actions[-self.t:])
        if cr_sum >= self.tr:
            action = Action.C
        else:
            action = Action.D
        if state.round_number <= self.N + 1 and action == self.history.opponent_actions[state.round_number - 1, 0]:
            action = self.history.opponent_actions[state.round_number - 1, 0]
        return action

class Strategy_COLLECTIVE_417(BaseStrategy):
    """Adaptive Tit-for-Tat Strategy for the Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_length = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or len(history.my_actions) < self.history_length:
            return Action.C
        if state.round_number > 0:
            average_stock = np.mean(history.my_actions[-self.history_length:])
            avg_sustainable_stock = self.game_description.capacity / (2 * self.game_description.n_players)
            if average_stock >= avg_sustainable_stock:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_418(BaseStrategy):
    """
    Implementation of Adaptive Tit-for-Tat (A-TFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.8 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = np.mean(history.opponent_actions[:, -1])
        if state.round_number == self.game_description.n_rounds and history.current_stock >= self.threshold:
            return Action.C
        return Action(int(opponent_action))

class Strategy_COLLECTIVE_419(BaseStrategy):
    """
    The Tit-for-Tat Adaptive Cooperation (TFT-AC) strategy aims to promote cooperation while also considering defection as a response to prior acts of defection. This encourages long-term sustainable cooperation within the group, benefiting both individual players and the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_defections_tolerated = math.floor(game_description.n_players / 2)
        self.previous_defection = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        opponent_last_action = history.opponent_actions[state.round_number - 1, 0]
        self.previous_defection = self.previous_defection and (not opponent_last_action) or opponent_last_action
        return Action.C if not opponent_last_action else Action.D if self.previous_defection <= self.num_defections_tolerated else Action.C

class Strategy_COLLECTIVE_420(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game

    This strategy mimics opponent's action from the previous round and encourages reciprocity.
    It also switches to a more conservative approach when average stock depletion per round exceeds capacity/rn.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / (game_description.n_players * game_description.n_rounds)
        self.strategy_switch_counter = 0
        self.defect_on_defect_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if len(history.opponent_actions) > state.round_number - 1:
            action = history.opponent_actions[-state.round_number][0] if len(history.opponent_actions[-state.round_number]) == 1 else Action.C
        else:
            return Action.C
        if state.round_number % self.game_description.n_rounds == 0:
            self.strategy_switch_counter += 1
            self.defect_on_defect_counter = 0
        if self.strategy_switch_counter > 1 and history.my_payoffs[-self.game_description.n_rounds].mean() > self.threshold:
            if action == Action.D and self.defect_on_defect_counter >= self.game_description.n_rounds:
                return Action.C
        return action

class Strategy_COLLECTIVE_421(BaseStrategy):
    """
    Tit-for-Tat Strategy for the Common Pool Resource Game.
    This strategy aims to maintain long-term cooperation by reciprocating other players' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_per_player = self.game_description.capacity // self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and state.round_number == len(history.my_actions)):
            return Action.C
        current_stock = state.current_stock
        if current_stock < self.capacity_per_player:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_423(BaseStrategy):
    """
    Adaptive Resource Sharing (ARS) Strategy for Common Pool Resource Game.
    The strategy adjusts its actions based on the average_stock, promoting resource conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_divided_by_n = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        total_stock = np.sum(history.my_actions) if history else self.game_description.capacity
        average_stock = total_stock / self.game_description.n_players
        return Action.C if average_stock <= self.capacity_divided_by_n else Action.D

class Strategy_COLLECTIVE_425(BaseStrategy):
    """
    Strategy name: Adaptive Tit-for-Tat (ATFT) with Stock Growth Adjustment (SG-ATFT)
    Strategy summary: Fosters a cooperative environment while being robust against opponents who defect repeatedly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity
        self.total_consumption = 0
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history = PlayerHistory(np.array([[True]], dtype=bool), np.array([state.current_stock / (2 * state.round_number + 1)]), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1))
            return Action.C
        elif state.round_number == self.history.my_payoffs.size:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if opponent_cooperators >= self.game_description.n_players // 2:
            self.stock_threshold *= 1 + self.total_consumption / self.game_description.capacity
            self.total_consumption = 0
            return Action.C
        else:
            self.total_consumption += state.current_stock - 2 * opponent_cooperators * state.current_stock // (2 * self.game_description.n_players)
            return Action.D

class Strategy_COLLECTIVE_426(BaseStrategy):
    """
    Strategy Name: Adaptive Stock-based Cooperative (ASC) Strategy
    Strategy Summary: Decides to cooperate when the current stock is above the average sustainable level and defect otherwise.
                      In the first round, ASC cooperates to preserve the resource and show goodwill toward other players, as no history is available yet.
                      In the last round, ASC considers the current stock level only since the game dynamics ensure that the growth won't impact subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = float(self.game_description.capacity) / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        average_sustainable_level = self.capacity / self.game_description.n_players
        if current_stock > average_sustainable_level or (current_stock == average_sustainable_level and random.random() < 0.5):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_427(BaseStrategy):
    """
    Strategy Name: Adaptive Stock Preservation (ASP) Strategy
    This strategy prioritizes the preservation of the common pool resource while balancing individual survival needs.
    By working collectively through adaptive decision-making, players can ensure a long-term sustainable game outcome that benefits all participants.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.csl = self.game_description.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        last_round = state.round_number == self.game_description.n_rounds
        if last_round and current_stock <= self.csl:
            return Action.D
        else:
            return Action(math.floor((current_stock > self.csl) * 1))

class Strategy_COLLECTIVE_430(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Stock Adaptation (TFT-SA)
    Strategy summary: A cooperative strategy that adapts to the overall cooperation level in the group.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.n_rounds / 2)
        self.history = []
        self.state = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.history.append((state, state.current_stock))
        s_avg = np.mean([s for _, s in self.history[-self.m:]])
        if state.current_stock <= self.game_description.capacity / 4 * self.game_description.n_players:
            return Action.D if state.current_stock >= self.game_description.capacity * (2 / self.game_description.n_players) else Action.C
        if state.current_stock < self.game_description.capacity * (2 / self.game_description.n_players) and state.current_stock <= self.game_description.capacity - self.game_description.capacity / 10:
            return Action.C
        growth = 2 * state.current_stock * (1 - state.current_stock / self.game_description.capacity)
        new_state = min(self.state + growth, self.game_description.capacity)
        self.state = new_state
        if len(self.history) == self.game_description.n_rounds:
            total_consumption = sum([action == Action.C and 2 / self.game_description.n * state or 1 / self.game_description.n * state for _, state in self.history])
            if state <= self.game_description.capacity / 4 * self.game_description.n:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_431(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 2 * game_description.n_players
        self.last_round = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1 if history else self.last_round
        if last_round == self.last_round or (state.current_stock < self.stock_threshold and history.opponent_actions[last_round, -1] == Action.D):
            return Action.D
        cooperators = sum(history.opponent_actions[last_round])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_432(BaseStrategy):
    """Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = -1
        self.last_opponent_action = Action.D

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number > self.last_round + 1:
            self.last_round = state.round_number - 1
            self.last_opponent_action = Action.D
        if state.round_number == self.game_description.n_rounds and state.current_stock <= 2 * self.game_description.n_players:
            return Action.D
        opponent_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        num_cooperators = sum(opponent_actions)
        if num_cooperators >= self.game_description.n_players // 2:
            self.last_opponent_action = Action.C
        return self.last_opponent_action

class Strategy_COLLECTIVE_433(BaseStrategy):
    """
    A Tit-for-Tat strategy that cooperates in the first round and responds to previous moves in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_move = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.last_opponent_move = np.mean(history.opponent_actions[:, -1])
        if state.round_number < self.game_description.n_rounds:
            return Action((self.last_opponent_move == 1) * 1)
        return Action.C

class Strategy_COLLECTIVE_434(BaseStrategy):
    """
    Tit-for-Tat Adaptive Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.opponent_history = history.opponent_actions.flatten().tolist()
        if state.round_number == 1:
            return Action.C
        opponent_action = self.opponent_history[-1]
        if opponent_action == Action.C:
            return Action.C
        elif opponent_action == Action.D:
            return Action.D
        else:
            return np.random.choice([Action.C, Action.D])

class Strategy_COLLECTIVE_435(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT)
    Summary: Cooperates if opponent cooperated in the previous round, otherwise defects to encourage reciprocity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            self.opponent_cooperation_count = sum(history.opponent_actions[-1, :])
        if state.round_number == 0 or (state.round_number == self.game_description.n_rounds and self.opponent_cooperation_count > 0):
            return Action.C
        if history is not None and self.opponent_cooperation_count > 0:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_436(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game.
    Encourages mutual cooperation but retaliates against defection while ensuring sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_point = 2 * self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        cooperators = sum(history.opponent_actions[last_round, :])
        current_stock = state.current_stock
        if current_stock < self.critical_point:
            return Action.D
        elif cooperators == 0:
            return Action.C
        elif len(history.opponent_actions) % 2 == last_round % 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_438(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    Mimics opponent's behavior from the previous round.
    Cooperates on first round, defects if opponent defected last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_move = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            self.last_move = history.opponent_actions[0, 0]
        prev_move = self.last_move if self.last_move is not None else None if history is None else history.opponent_actions[-1, -1]
        if prev_move == Action.C:
            return Action.C
        else:
            return Action.D
        if state.round_number < self.game_description.n_rounds - 1:
            self.last_move = history.opponent_actions[-1, -1]

class Strategy_COLLECTIVE_439(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p = 0.1
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0:
            return action
        if history and self.last_opponent_action is not None:
            last_round = state.round_number - 1
            opponent_cooperated_last_round = history.opponent_actions[last_round, 0] == 1
            action = Action.C if opponent_cooperated_last_round else Action.D
            self.last_opponent_action = action
        if state.round_number == self.game_description.n_rounds:
            action = Action.D
        elif random.random() < self.p:
            action = Action.D
        return action

class Strategy_COLLECTIVE_440(BaseStrategy):
    """
    A Titan strategy that adaptively chooses between cooperating and defecting based on the current state of the common pool resource and its history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.T_coop = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > self.T_coop:
                return Action.D
        if history is not None and state.current_stock > self.T_coop:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_441(BaseStrategy):
    """
    Strategy that implements Tit-for-Tat-Growth for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_actions = np.zeros(game_description.n_players, dtype=bool)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.last_opponent_actions = history.opponent_actions[-1]
        current_cooperators = np.sum(self.last_opponent_actions)
        if current_cooperators >= self.game_description.n_players // 2:
            return Action.C
        for i, action in enumerate(self.last_opponent_actions):
            if not action:
                self.last_opponent_actions[i] = False
                return Action.D
        self.last_opponent_actions.fill(True)
        return Action.C

class Strategy_COLLECTIVE_442(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            last_opponent_action = history.opponent_actions[-1, -1]
        else:
            last_opponent_action = None
        if state.round_number == 0 or (last_opponent_action is not None and last_opponent_action):
            return Action.C
        elif last_opponent_action:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_444(BaseStrategy):
    """
    Implementation of Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_history = [0] * game_description.n_players
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == state.round_number + self.game_description.n_players - 1:
            self.last_round = True
        opponent_cooperation_history = sum(history.opponent_actions[:, -1])
        if opponent_cooperation_history >= self.game_description.n_players - 1:
            return Action.C
        elif random.random() < 0.5:
            self.opponent_cooperation_history = [0] * self.game_description.n_players
            return Action.C
        else:
            self.opponent_cooperation_history[-1] += 1 if history.opponent_actions[-1, -1] else 0
            return Action.D

class Strategy_COLLECTIVE_445(BaseStrategy):
    """
    Fitness-driven Adaptive Cooperation (FAC) strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((self.game_description.n_rounds,), dtype=bool), my_payoffs=np.zeros(self.game_description.n_rounds, dtype=float), opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=float))
        self.threshold = 0.7 * self.game_description.capacity
        self.last_third_round_threshold = 0.6 * self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        past_stocks = self.history.opponent_payoffs[:state.round_number + 1].sum(axis=0)[::-1]
        average_stock = np.mean(past_stocks[-5:])
        if state.round_number < self.game_description.n_rounds - 3:
            self.threshold = 0.7 * self.game_description.capacity
        elif state.round_number >= self.game_description.n_rounds - 3 and state.round_number <= self.game_description.n_rounds - 1:
            self.threshold = self.last_third_round_threshold
        if average_stock < self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_447(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_index = 1
        self.history = PlayerHistory(my_actions=np.array([], dtype=bool), my_payoffs=np.array([], dtype=np.float64), opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.history.my_actions = np.append(self.history.my_actions, [state.round_number == state.round_number])
            self.history.opponent_actions[state.round_number, self.opponent_index] = not history.opponent_actions[state.round_number - 1, self.opponent_index]
        if state.round_number == 0 or (history is not None and len(history.my_actions) == 0):
            return Action.C
        opponent_action = self.history.opponent_actions[-1, self.opponent_index]
        if opponent_action:
            return Action.C
        else:
            return Action.D

    def get_history(self) -> PlayerHistory:
        """
        Return the strategy's history object for analysis purposes.
        """
        return self.history

class Strategy_COLLECTIVE_448(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive behavior for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or len(history.my_actions) == 0:
            return Action.C
        if state.round_number < len(history.my_actions):
            last_action = history.my_actions[-1]
        else:
            last_action = None
        if last_action is not None and last_action == Action.C:
            return Action.C
        elif last_action is not None and last_action == Action.D:
            return Action.D
        if state.round_number + 1 >= len(self.history.my_actions):
            return Action.C
        self.history.my_actions[:state.round_number] = np.zeros(state.round_number, dtype=bool)
        self.history.my_payoffs[:state.round_number] = np.zeros(state.round_number)
        return Action.C

class Strategy_COLLECTIVE_449(BaseStrategy):
    """Adjustable Stock Conservation Strategy"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold1 = 2 * game_description.n_players
        self.threshold2 = game_description.capacity / 2
        self.avg_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number == 0:
            return Action.C
        stock_level = state.current_stock
        if stock_level < self.threshold1:
            return Action.C
        elif stock_level > self.threshold2:
            return Action.D
        else:
            if self.avg_stock is None:
                self.avg_stock = (self.threshold1 + self.threshold2) / 2
            avg_stock = self.avg_stock
            prob_cooperate = stock_level / avg_stock
            if random.random() < prob_cooperate:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_450(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Strategy that cooperates initially and reciprocates cooperation while punishing defection, with a provision for reconciliation after three consecutive defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_opponent_action = None
        self.defection_counter = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history.opponent_actions[-1, -1] == Action.D and self.defection_counter < 3:
            self.defection_counter += 1
        elif history.opponent_actions[-1, -1] == Action.C:
            self.defection_counter = 0
        if state.round_number > 3 and self.defection_counter == 3:
            return Action.C
        return history.opponent_actions[-1, -1] if self.last_round_opponent_action is not None else Action.C

    def update_history(self, history: PlayerHistory):
        self.last_round_opponent_action = history.opponent_actions[-1, -1]
        super().update_history(history)

class Strategy_COLLECTIVE_451(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    Promotes reciprocity by imitating opponents' actions from the previous round.
    If an opponent cooperated in the previous round, cooperate; otherwise, defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_completed_round = (state.round_number - 1) % self.game_description.n_rounds
        opponent_last_action = history.opponent_actions[last_completed_round, -1]
        if opponent_last_action:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_452(BaseStrategy):
    """
    A strategy that implements the Tit-for-Tat Evolution (T4TE) in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_stock_threshold = math.floor(game_description.capacity / 2)
        self.first_encounter_defection = True
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        current_round = state.round_number
        stock_level = state.current_stock
        if not history:
            return Action.C
        opponent_action = history.opponent_actions[-1, -1]
        if self.first_encounter_defection and opponent_action == Action.D:
            return Action.C
        if current_round == self.game_description.n_rounds - 1 or not stock_level >= self.min_stock_threshold:
            if opponent_action == Action.C:
                return Action.C
            return Action.D
        if opponent_action == Action.C:
            return Action.C
        elif stock_level >= self.min_stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_453(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Adaptation (TFT-SA)

    Strategy Summary: A strategy that initially cooperates in the first round to start with a mutual benefit, then adapts its actions based on the opponent's history of cooperation or defection. The tendency to defect is influenced by the current stock level: if the stock is below a certain threshold (Stock Threshold), the player will defect regardless of the opponent's previous action to prevent the common pool from depleting too quickly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity * 0.67

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        opponent_action = history.opponent_actions[last_round, int(not state.round_number == self.game_description.n_rounds)]
        current_stock = state.current_stock
        if state.round_number == self.game_description.n_rounds:
            if current_stock >= self.stock_threshold:
                return Action.C
            else:
                return Action.D
        if opponent_action:
            if current_stock < self.stock_threshold:
                return Action.D
            else:
                return Action.C
        elif current_stock < self.stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_454(BaseStrategy):
    """Adaptive Stock-Based Tit-for-Tat (ASBTFT) strategy for the Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history = history
        cooperation_rate = np.mean(self.history.my_actions[-self.game_description.n_rounds:])
        stock_depletion_rate = (state.current_stock - self.history.opponent_payoffs[-1].sum()) / state.current_stock
        cooperation_index = stock_depletion_rate * cooperation_rate + 0.5
        if cooperation_index > self.cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_455(BaseStrategy):
    """
    Adaptive Resource Sharing (ARS) strategy for the Common Pool Resource Game.
    The strategy adapts its actions based on current stock level and historical trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_threshold = game_description.capacity / 4
        self.history_length = 2 * game_description.n_players if game_description.n_players > 1 else 0
        self.historical_trend_threshold = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        average_stock = state.current_stock / self.game_description.n_players
        if average_stock > self.game_description.capacity / 2:
            return Action.C
        elif average_stock <= self.average_threshold:
            return Action.D
        if history and state.round_number > self.history_length:
            historical_trend = np.mean(history.my_actions[-self.history_length:])
            if historical_trend < self.historical_trend_threshold:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_457(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.cooperation_threshold = math.ceil(game_description.capacity * 0.8)
        self.breakdown_threshold = math.floor(game_description.capacity * 0.2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        defectors = self.n - cooperators
        if cooperators > self.n // 2 and state.current_stock >= self.cooperation_threshold or (defectors > self.n // 2 and state.current_stock <= self.breakdown_threshold):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_458(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperated_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.opponent_cooperated_last_round = False
            return Action.C
        last_round = len(history.opponent_actions) - 1
        opponent_cooperation_last_round = history.opponent_actions[last_round].sum() >= self.game_description.n_players // 2
        self.opponent_cooperated_last_round = opponent_cooperation_last_round
        return Action(self.opponent_cooperated_last_round)

class Strategy_COLLECTIVE_459(BaseStrategy):
    """
    Adaptive Stock Management (ASM) Strategy for Common Pool Resource Game.
    This strategy encourages cooperation when the common pool is abundant and conservation efforts when it is scarce.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_sustainable_stock = game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.D
        previous_round = len(history.my_actions) - 1
        current_stock = state.current_stock
        last_action = history.my_actions[previous_round]
        if current_stock > self.average_sustainable_stock:
            if last_action:
                return Action.C
            else:
                return Action.D
        elif current_stock < self.average_sustainable_stock:
            if last_action:
                return Action.D
            else:
                return Action.C
        elif last_action:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_461(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game.
    Demonstrates cooperation and fairness, retaliates against defection.
    Prioritizes long-term sustainability over immediate gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_last_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.opponent_last_action is None:
            self.opponent_last_action = history.opponent_actions[state.round_number - 1, 0] if history else None
        if self.opponent_last_action == Action.C:
            return Action.C
        elif self.opponent_last_action == Action.D:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_COLLECTIVE_463(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros((1,)), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds,)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history = PlayerHistory(np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros((1,)), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds,)))
            return Action.C if state.round_number == 0 else Action.D if history.opponent_actions[-1, -1] else Action.C
        self.history = history
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        return Action.C if np.sum(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2 else Action.D

class Strategy_COLLECTIVE_464(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFTSA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock = 2 * self.game_description.n_players
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            self.last_opponent_action = None
            return Action.C
        self.last_opponent_action = np.mean(history.opponent_actions[:, -1])
        if state.current_stock >= self.critical_stock:
            return self._choose_action_based_on_opponent(history)
        return Action.D

    def _choose_action_based_on_opponent(self, history: PlayerHistory) -> Action:
        if self.last_opponent_action == 1:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_467(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game.
    Promotes cooperation while being robust against various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players // 2
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        round_num = state.round_number - 1 if history else 0
        if round_num < self.game_description.n_rounds - 1:
            cooperators = sum(history.opponent_actions[round_num, :])
            return Action.C if cooperators >= self.n else Action.D
        return Action.C

    def update_stock(self, state: CommonPoolState, consumption: float) -> float:
        total_consumption = self.game_description.n_players * consumption
        growth = 2 * min(state.current_stock + total_consumption, self.capacity) * (1 - (state.current_stock + total_consumption) / self.capacity)
        new_stock = min(self.capacity, state.current_stock + growth - total_consumption)
        return new_stock

class Strategy_COLLECTIVE_468(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy (ATFT) for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.own_total_payoff = 0.0
        self.opponent_total_payoff = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            if self.own_total_payoff > self.opponent_total_payoff:
                return Action.C
            elif self.own_total_payoff < self.opponent_total_payoff:
                return Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

    def update_payoffs(self, my_payoff: float, opponent_payoff: float):
        self.own_total_payoff += my_payoff
        self.opponent_total_payoff += opponent_payoff

class Strategy_COLLECTIVE_469(BaseStrategy):
    """
    A strategy that follows the Tit-for-Tat approach with adaptations, including forgiveness and occasional acts of kindness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds = math.floor(game_description.n_rounds * 0.3)
        self.kindness_probability = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        last_round_action = history.opponent_actions[-1][-1] if history is not None else False
        if current_stock < 2 * self.game_description.n_players:
            return Action.D
        if last_round_action and history:
            last_two_rounds = history.opponent_actions[-2:-1]
            if last_round_action == Action.D and (not last_two_rounds[-1][-1]):
                return Action.C
        if random.random() < self.kindness_probability and history:
            if not last_round_action:
                return Action.C
        if state.round_number < self.punishment_rounds and last_round_action == Action.D:
            return Action.D
        return Action.C if last_round_action else Action.D

class Strategy_COLLECTIVE_470(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    This strategy cooperates in the initial round and responds to an opponent's previous actions in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None
        self.coop_threshold = int(game_description.n_players // 2)

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not self.history:
            self.history = history
            return Action.C
        current_round = self.history.opponent_actions.shape[0] - 1
        opponent_cooperators = sum(self.history.opponent_actions[current_round, :])
        if opponent_cooperators >= self.coop_threshold:
            return Action.C
        elif opponent_cooperators > 0 and current_round >= self.coop_threshold - 1:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_471(BaseStrategy):
    """
    Adaptive Resource Conservation (ARC) Strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity / (2 * game_description.n_players * math.sqrt(game_description.n_rounds))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock_threshold = self.capacity if state.round_number == 0 else self.capacity / (2 * self.game_description.n_players * math.sqrt(self.game_description.n_rounds))
        if state.round_number == 0:
            return Action.D if state.current_stock < stock_threshold else Action.C
        if state.current_stock >= stock_threshold:
            cooperators = np.sum(history.opponent_actions[-1, :]) if history is not None else 0
            if cooperators > self.game_description.n_players // 2:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_473(BaseStrategy):
    """
    Adaptive Tit-for-Tat (A-TFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = np.zeros(game_description.n_rounds - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            consumption = history.opponent_actions.sum(axis=0) * (2 * state.current_stock / (2 * self.game_description.n_players))
            self.average_consumption = np.roll(self.average_consumption, -1) if state.round_number > 0 else np.array([0])
            self.average_consumption[-1] = consumption.sum() / (state.round_number - 1)
        else:
            self.average_consumption = np.zeros(self.game_description.n_rounds - 1)
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C
        elif self.average_consumption[-1] < self.game_description.n_players * (2 / (2 * self.game_description.n_rounds)):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_474(BaseStrategy):
    """
    The TFT-SDA strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return self.determine_last_round_action(state, history)
        opponent_behavior = self.extract_opponent_behavior(history)
        ASL = self.calculate_average_stock_level(history)
        if ASL > self.capacity:
            return Action.C
        elif ASL < self.capacity / (2 * (self.game_description.n_players + 1)):
            return Action.D
        else:
            return self.mimic_opponent(opponent_behavior, ASL, state)

    def extract_opponent_behavior(self, history: PlayerHistory) -> np.bool_:
        """Returns a boolean array indicating whether opponents cooperated or defected in each round."""
        return np.mean(history.opponent_actions, axis=0)

    def calculate_average_stock_level(self, history: PlayerHistory) -> float:
        """Returns the average stock level throughout all previous rounds."""
        return np.mean(history.my_payoffs[:-1]) / self.game_description.n_players

    def determine_last_round_action(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        """Determines the action to take in the last round based on current state and past opponent behavior."""
        if state.current_stock / self.capacity > 0.5:
            return Action.C
        elif self.extract_opponent_behavior(history).sum() < self.game_description.n_players // 2:
            return Action.D
        else:
            return self.mimic_opponent(self.extract_opponent_behavior(history), state.current_stock, state)

    def mimic_opponent(self, opponent_behavior: np.bool_, ASL: float, state: CommonPoolState):
        """Returns an action based on the last opponent's action, current stock level and ASL."""
        if opponent_behavior[-1] == Action.C and state.current_stock / self.capacity > 2:
            return Action.C
        elif opponent_behavior[-1] == Action.D:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_475(BaseStrategy):
    """
    Strategy name: Adaptive Stock Management (ASM)
    Summary: The ASM strategy cooperates when the current stock level is above the critical threshold, which varies based on the round number and total population size. It aims to balance conservation and exploitation while ensuring long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not self.critical_threshold:
            self.critical_threshold = self.game_description.capacity / self.game_description.n_players
        if state.round_number == 0:
            return Action.C
        if state.current_stock > self.critical_threshold:
            return Action.C
        else:
            return Action.D

        def calculate_critical_threshold(n, r, round_num, capacity):
            if round_num == 1:
                return capacity / n
            total_consumption = capacity * round_num / n
            remaining_stock = capacity - total_consumption
            return remaining_stock / (n - (round_num - 1))

class Strategy_COLLECTIVE_476(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_action_history = np.zeros((1, game_description.n_players), dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        opponent_actions = history.opponent_actions if history is not None else self.opponent_action_history
        last_round = state.round_number - 1
        if last_round < len(self.opponent_action_history) - 1:
            self.opponent_action_history = opponent_actions
            return opponent_actions[last_round]
        return Action.C

class Strategy_COLLECTIVE_477(BaseStrategy):
    """
    Adaptive Fitness-based Tit-for-Tat Strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = self.game_description.capacity / 2
        self.fitness_threshold = np.mean(self.game_description.n_players * np.arange(1, self.game_description.n_players + 1))
        self.current_stock = self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number < self.game_description.n_rounds and history is None:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1])
        if cooperators == self.game_description.n_players:
            return Action.C
        stock_level = self.current_stock - np.sum(history.my_actions * (self.game_description.capacity // self.game_description.n_players) * len(history.opponent_payoffs))
        if stock_level <= self.stock_threshold:
            return Action.D
        fitness = np.mean(history.my_payoffs)
        if fitness > self.fitness_threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_479(BaseStrategy):
    """
    Adaptive Fitness-Driven Cooperation Strategy in Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        remaining_stock = state.current_stock
        epc = remaining_stock / self.capacity * ((2 * self.n_players - self.n_players + 1) / 2)
        epd = remaining_stock / (2 * self.n_players)
        if epc >= epd:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_480(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 2 * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.current_stock < self.stock_threshold:
            return Action.D
        else:
            opponent_action = history.opponent_actions[state.round_number - 1, 0] if history is not None else None
            return Action.C if opponent_action == Action.C else Action.D

class Strategy_COLLECTIVE_481(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Stock Awareness (TFT-SA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self._last_round_cooperators = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if history is not None:
            last_round = len(history.opponent_actions) - 1
            self._last_round_cooperators = sum(history.opponent_actions[last_round])
            if self._last_round_cooperators == self.n_players:
                return Action.C
            if current_stock < self.capacity * (self.n_players // 2 + 1) / 2:
                return Action.D
        return Action.C if self._last_round_cooperators == self.n_players else Action.D

class Strategy_COLLECTIVE_482(BaseStrategy):
    """Adaptive Stock-Based Tit-for-Tat Strategy"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.threshold = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        stock_history = np.array([state.current_stock] + list(history.my_payoffs.flatten()))
        self.threshold = np.mean(stock_history[-3:]) if len(stock_history) >= 3 else self.capacity / (2 * self.n)
        return Action.C if state.current_stock > self.threshold else Action.D

class Strategy_COLLECTIVE_483(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is not None and len(self.opponent_history) > 0:
            self.opponent_history = history.opponent_actions[:, self.__class__.__name__]
            last_round = len(self.opponent_history) - 1
            if sum(self.opponent_history[last_round]) >= self.game_description.n_players // 2:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_484(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)
    This strategy follows a forgiving approach, cooperating in the first round and adapting cooperation rate based on opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.average_opponent_cooperation = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.average_opponent_cooperation = np.mean(history.opponent_actions[:, :state.round_number])
            if history.my_actions[-1] == Action.C and self.average_opponent_cooperation >= self.cooperation_threshold:
                self.cooperation_threshold *= 0.95
            elif history.my_actions[-1] != Action.C and self.average_opponent_cooperation < self.cooperation_threshold:
                self.cooperation_threshold *= 1.05
        return Action.C if self.cooperation_threshold >= random.random() else Action.D

class Strategy_COLLECTIVE_486(BaseStrategy):
    """
    Strategy that follows the Adaptive Tit-for-Tat approach in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or all([action for action in history.my_actions[:-1] if action]):
            return Action.C
        previous_opponents = [player_history.opponent_actions[-1, 0] for player_history in history.opponent_payoffs]
        if not any(previous_opponents):
            return Action.C
        for opponent in range(1, self.game_description.n_players + 1):
            if not history.opponent_actions[state.round_number - 1, opponent - 1]:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_487(BaseStrategy):
    """
    The Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            self.history = PlayerHistory(np.array([[state.current_stock > self.game_description.capacity * 0.5]], dtype=bool), np.zeros((1,)), np.zeros((1, self.game_description.n_players)), np.zeros((1, self.game_description.n_players)))
            return Action.C
        if state.round_number == len(self.history.my_actions):
            avg_stock = self.history.my_actions[-1].mean()
            return self.__decision_rule(state, self.history)
        return self.__decision_rule(state, self.history)

    def __decision_rule(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 1 or (state.round_number > 1 and state.current_stock < self.game_description.capacity * 0.25 and (history.my_actions[-1].mean() < self.game_description.capacity * 0.25)):
            return Action.D
        elif state.round_number == len(history.my_actions) or (state.round_number > 1 and state.current_stock >= self.game_description.capacity * 0.5 and (history.my_actions[-1].mean() >= self.game_description.capacity * 0.5)):
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_489(BaseStrategy):
    """
    Implementation of the Tit-for-Tat Strategy for Common Pool Resource Game.
    This strategy promotes long-term cooperation by mimicking cooperative behavior when others do so and retaliating with defection when others defect, fostering an environment of collective preservation of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = self.game_description.n_players
        self.capacity = self.game_description.capacity
        self.stock_threshold = 2 * self.n_players / 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        current_stock = state.current_stock
        past_n_rounds = history.my_actions[-self.n_players:]
        num_cooperators = sum(past_n_rounds)
        if num_cooperators == self.n_players and current_stock >= self.stock_threshold:
            return Action.C
        elif num_cooperators > self.n_players - 1:
            random_prob = (num_cooperators - (self.n_players - 1)) / self.n_players
            return Action(random.random() < random_prob)
        return Action.D

class Strategy_COLLECTIVE_490(BaseStrategy):
    """
    A Titan strategy that promotes sustainable resource management by cooperating whenever possible, but also adapts to various opponent behaviors and adjusts strategies accordingly throughout the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_critical_level = math.ceil(self.game_description.capacity / (2 * self.game_description.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        coop_count = sum(history.opponent_actions[-1])
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.C if state.current_stock > self.capacity_critical_level else Action.D
        elif coop_count >= self.game_description.n_players // 2:
            action = Action.C
        else:
            action = Action.D
        return action

class Strategy_COLLECTIVE_491(BaseStrategy):
    """
    Adaptive Fitness-Based Tit-for-Tat (AFB-TFT) strategy for the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(self.game_description.capacity / 10)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_action = history.opponent_actions[-1][-1] if history else None
        if previous_action is None or (previous_action and state.current_stock > self.threshold):
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_492(BaseStrategy):
    """
    Implementation of Adaptive Resource Allocation Strategy (ARAS).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_point = game_description.capacity * (2 * game_description.n_players - game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = sum(history.my_payoffs[:state.round_number]) / self.game_description.n_players
        current_stock = state.current_stock
        if (current_stock < self.critical_point or total_consumption < self.critical_point / (2 * self.game_description.n_players)) and current_stock <= self.critical_point:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_494(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptive Growth (TFT-AG) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.historical_actions_opponents = []
        self.cooperative_ratio = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        else:
            self._update_historical_actions(history)
            self._calculate_cooperative_ratio()
            cooperative_ratio = self.cooperative_ratio
            if state.round_number == history.my_actions.shape[0] - 1:
                cooperative_ratio = max(cooperative_ratio, 0.5)
            return Action(int(cooperative_ratio >= 0.5))

    def _update_historical_actions(self, history: PlayerHistory):
        self.historical_actions_opponents.append(history.opponent_actions[-1].tolist())

    def _calculate_cooperative_ratio(self):
        total_cooperators = sum([sum(row) for row in np.array(self.historical_actions_opponents).T])
        total_players = self.game_description.n_players * len(self.historical_actions_opponents)
        self.cooperative_ratio = total_cooperators / total_players

class Strategy_COLLECTIVE_495(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for the Common Pool Resource Game.
    Promotes cooperation by mimicking cooperative behavior in the first round and responding to other players' actions in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_history = history.opponent_actions[state.round_number - 1] if history else np.zeros(self.game_description.n_players, dtype=np.bool_)
        return Action(int(sum(opponent_history) >= self.game_description.n_players // 2))

class Strategy_COLLECTIVE_496(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game.
    Cooperates initially, then responds cooperatively to cooperation and defectively to defection.
    Limits overexploitation of resources when the total consumption is close to or exceeds capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = float(self.game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        total_consumption = np.sum(opponent_actions * self.game_description.n_players)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if np.all(opponent_actions):
            return Action.C
        if total_consumption > self.capacity:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_497(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)
    Strategy Description: Cooperates if all opponents cooperated in the previous round, defects otherwise. Prepares for endgame when 10 rounds remain and ensures resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.end_rounds = int(game_description.n_rounds * 0.9)
        self.survival_threshold = (self.n_players - 1) * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0 or history is None:
            action = Action.C
        elif history is not None and state.round_number >= self.end_rounds:
            action = Action.C
        else:
            cooperation_count = sum(history.opponent_actions[-1])
            if cooperation_count < self.n_players:
                action = Action.D
        if state.current_stock < self.survival_threshold:
            action = Action.D
        return action

class Strategy_COLLECTIVE_499(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR) strategy for Common Pool Resource Game.
    Encourages cooperation by adapting to average consumption levels, penalizing excessive resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_T = game_description.capacity / (2 * game_description.n_players)
        self.threshold_H = 2 * self.threshold_T
        self.history = None
        self.average_consumption = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history = history
        if history and state.round_number < len(history.opponent_actions):
            self.average_consumption = np.mean([h[0] for h in history.opponent_payoffs[-state.round_number:]])
        if state.round_number == len(self.history.opponent_payoffs):
            if self.average_consumption is not None and self.average_consumption < self.threshold_T:
                return Action.C if self.history.my_actions[-1] == Action.C else Action.D
            elif self.average_consumption is not None and self.average_consumption > self.threshold_H:
                return Action.C
        elif self.average_consumption is not None:
            if self.history.my_payoffs[-1] < state.current_stock / (2 * self.game_description.n_players) * (self.threshold_T + self.threshold_H) - state.current_stock / (2 * self.game_description.n_players) * (self.threshold_T - self.threshold_H):
                return Action.C
        else:
            return self.history.my_actions[-1]
        return Action.C

class Strategy_COLLECTIVE_500(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Buffer (SB) and Growth-Based Adjustment (GBA).
    Promotes cooperation when resources are abundant but retaliates against excessive exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_buffer = self.game_description.capacity / game_description.n_players
        self.cumulative_defections = 0
        self.growth_factors = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            self.cumulative_defections += np.count_nonzero(history.opponent_actions[state.round_number - 1])
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock > self.stock_buffer:
            return Action.C
        elif current_stock <= 0 or self.cumulative_defections >= self.game_description.n_players:
            return Action.D
        else:
            self.growth_factors.append(self._calculate_growth_factor(state, history))
            growth_factor = np.mean(self.growth_factors) if len(self.growth_factors) > 0 else None
            if growth_factor < 0.5:
                self.stock_buffer += self.stock_buffer / self.game_description.n_rounds
            elif growth_factor > 1.5:
                self.stock_buffer -= self.stock_buffer / self.game_description.n_rounds
        return Action.C if self._check_safe_to_cooperate(state, history) else Action.D

    def _calculate_growth_factor(self, state: CommonPoolState, history: PlayerHistory) -> float:
        total_consumption = np.sum(history.my_actions * state.current_stock if state.round_number > 0 else [])
        remaining_stock = state.current_stock - total_consumption
        return 2 * remaining_stock * (1 - remaining_stock / self.game_description.capacity)

    def _check_safe_to_cooperate(self, state: CommonPoolState, history: PlayerHistory):
        if state.round_number == self.game_description.n_rounds - 1:
            return self._is_stock_safe_for_cooperation(state) and self._are_defections_reasonable(history)
        else:
            return True

    def _is_stock_safe_for_cooperation(self, state: CommonPoolState):
        return state.current_stock > 0 and state.current_stock / self.game_description.capacity < 2 / 3

    def _are_defections_reasonable(self, history: PlayerHistory) -> bool:
        return np.count_nonzero(history.my_actions) <= self.cumulative_defections

class Strategy_COLLECTIVE_501(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.payoffs = np.zeros(game_description.n_rounds + 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            last_round = state.round_number == self.game_description.n_rounds
            opponent_actions = history.opponent_actions[-1, :] if history is not None else np.zeros(self.game_description.n_players)
            cooperators = sum(opponent_actions)
            if last_round:
                payoffs_diff = self._calculate_payoff_difference()
                if payoffs_diff > 0:
                    return Action.C
                elif payoffs_diff < 0:
                    return Action.D
                elif opponent_actions[-1] == int(Action.D):
                    return Action.C
            elif cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D

        def _calculate_payoff_difference(self):
            """
            Calculates the payoff difference between this player and opponents in previous rounds.
            """
            my_payoffs = self.payoffs[1:] if state.round_number > 0 else np.zeros(self.game_description.n_rounds)
            opponent_payoffs = history.opponent_payoffs[-self.game_description.n_rounds:, :].sum(axis=0) if history is not None else np.zeros(self.game_description.n_rounds)
            return my_payoffs - opponent_payoffs

class Strategy_COLLECTIVE_503(BaseStrategy):
    """
    Tit-for-Tat-Growth (TfTG) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_stock = None
        self.minimum_sustainable_stock = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        initial_stock = state.current_stock
        if not self.average_stock:
            self.average_stock = capacity / n
            self.minimum_sustainable_stock = 2 * n * self.average_stock
        if initial_stock < self.minimum_sustainable_stock:
            return Action.D
        history = history[-self.game_description.n_rounds:]
        previous_actions = np.ravel(history.opponent_actions)
        if all((state.current_stock > self.average_stock for action in previous_actions)):
            return Action.C
        elif all((state.current_stock < self.minimum_sustainable_stock for action in previous_actions)):
            return Action.D
        else:
            last_action = previous_actions[-1]
            return last_action

class Strategy_COLLECTIVE_504(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth (ATFSG) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_sustainable_rate = self.game_description.capacity * (2 / self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        total_consumption = sum(history.my_actions[:-1] if history else [Action.D for _ in range(state.round_number)])
        average_consumption_rate = total_consumption / state.round_number
        if average_consumption_rate < self.capacity_sustainable_rate:
            return Action.C
        current_stock_level = history.my_payoffs[-1] if history else state.current_stock
        if current_stock_level >= self.game_description.capacity:
            return Action.D
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if opponent_cooperators == state.round_number:
            return Action.C
        if opponent_cooperators > (state.round_number - 1) // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_505(BaseStrategy):
    """
    Strategy name: Adaptive Tit-for-Tat (ATFT)
    Strategy summary: This strategy cooperates initially and then reciprocates cooperation or defection based on opponents' previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1))
        if state.round_number == 0:
            return Action.C
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= self.game_description.n_players // 2 and history.my_payoffs[-1] > 0:
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_506(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    Prioritizes long-term group success over individual gain by balancing cooperation and defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.history = history if history is not None else PlayerHistory(np.zeros((1,), dtype=bool), np.zeros((1,)), np.zeros((state.round_number + 1, self.game_description.n_players), dtype=bool), np.zeros((state.round_number + 1,)))
        if state.round_number == 0:
            return Action.C
        self.history.my_actions[-1] = Action.C
        opponent_cooperators = np.sum(self.history.opponent_actions[-1, :])
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_508(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponent_history = history
        last_move = self.opponent_history.opponent_actions[-1]
        if last_move.all():
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_510(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=np.bool_)
        all_cooperated = np.all(opponents_actions)
        if state.round_number < self.game_description.n_rounds:
            if all_cooperated:
                return Action.C
            else:
                return Action.D
        return Action.C

    def update_state(self, consumption: float) -> None:
        self.stock -= consumption
        if self.stock <= 0:
            self.stock = self.game_description.capacity

class Strategy_COLLECTIVE_511(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Growth (TfT-AG)
    This strategy cooperates if current stock level is above a threshold, and defects otherwise. The threshold adapts based on the remaining rounds and current stock levels to promote long-term resource preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.threshold = self.game_description.capacity / self.game_description.n_players
        elif state.round_number < self.game_description.n_players or (state.round_number >= self.game_description.n_players * 2 and state.round_number < self.game_description.n_players * 3):
            self.threshold = math.ceil(self.game_description.capacity * (self.game_description.n_players - (state.round_number - 1)) / self.game_description.n_players)
        else:
            self.threshold = self.game_description.capacity
        return Action.C if state.current_stock >= self.threshold else Action.D

class Strategy_COLLECTIVE_512(BaseStrategy):
    """
    Tit-for-Tat-Adaptive (TfTA) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_SCT = game_description.capacity / (2 * game_description.n_players)
        self.current_stock_consumption = 0
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.round_number += 1
        if state.current_stock <= 0 or self.round_number == self.game_description.n_rounds:
            return Action.D
        if history is None:
            self.current_stock_consumption = 0
        else:
            self.current_stock_consumption = np.mean(history.my_actions) * state.current_stock
        SCT = self.initial_SCT * (1 - self.round_number / self.game_description.n_rounds) + self.current_stock_consumption * (self.round_number / self.game_description.n_rounds)
        action = Action.C if np.mean(history.my_actions) < SCT else Action.D
        return action

class Strategy_EXPLOITATIVE_1(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFTSA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.N = int(self.game_description.n_players * self.game_description.n_rounds * 0.7)
        self.history_length = min(self.N, self.game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        if len(history.my_actions) < self.history_length:
            return Action.C
        average_stock_level = np.mean(history.opponent_payoffs[-self.history_length:]) / (2 * self.game_description.n_players)
        if average_stock_level > self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.C
        elif average_stock_level <= self.game_description.capacity / (2 * self.game_description.n_players) and average_stock_level > self.game_description.capacity / self.game_description.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_2(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    Cooperates with opponents when they have cooperated in the previous round, and defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if state.round_number == self.game_description.n_rounds - 1 and cooperators < self.game_description.n_players:
            return Action.D
        return Action.C if cooperators >= self.game_description.n_players // 2 else Action.D

class Strategy_EXPLOITATIVE_3(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth Strategy in Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = (2 * game_description.n_players + game_description.capacity) // 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1]) if history is not None else 0
        if cooperators >= self.game_description.n_players and state.current_stock > self.threshold:
            return Action.C
        elif cooperators > 0 or state.current_stock > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_4(BaseStrategy):
    """
    Implementation of Tit-for-Tat with Stock Adaptation (TS-TfT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_half = self.game_description.capacity // 2
        self.capacity_quarter = self.capacity_half // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_opponent_action = history.opponent_actions[last_round, 0]
        stock_remaining = state.current_stock - np.sum(history.my_actions[last_round]) * self.game_description.capacity / (2 * self.game_description.n_players)
        if last_opponent_action:
            if stock_remaining >= self.capacity_half:
                return Action.C
            elif stock_remaining < self.capacity_quarter:
                return Action.D
        else:
            return Action.D
        if history.my_actions[last_round] == last_opponent_action:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_5(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)
    Summary: A strategy that cooperates initially, responds to defections, and adapts its cooperation threshold based on the number of rounds and defeats encountered.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = self.game_description.capacity
        self.small_margin = min(math.floor(self.game_description.capacity / (2 * self.game_description.n_players)), 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if history is not None:
            num_cooperations, num_defections = self.evaluate_opponent(history)
            stock = state.current_stock
            if num_defections - num_cooperations <= 0:
                action = Action.C
                if stock >= self.cooperation_threshold:
                    return action
            self.adjust_cooperation_threshold(state, history)
        return action

    def evaluate_opponent(self, history: PlayerHistory) -> tuple[int, int]:
        num_cooperations = 0
        num_defections = 0
        for round in range(history.my_actions.size):
            if history.my_actions[round] == Action.C and history.opponent_actions[round, 0] == Action.D:
                num_cooperations += 1
            elif history.my_actions[round] == Action.D and history.opponent_actions[round, 0] == Action.C:
                num_defections += 1
        return (num_cooperations, num_defections)

    def adjust_cooperation_threshold(self, state: CommonPoolState, history: PlayerHistory):
        round_number = state.round_number
        if round_number < self.game_description.n_rounds // 2:
            if self.cooperation_threshold > self.game_description.capacity * (1 - self.small_margin):
                self.cooperation_threshold += self.small_margin
        elif round_number >= self.game_description.n_rounds // 2 and self.cooperation_threshold < self.game_description.capacity:
            self.cooperation_threshold -= self.small_margin

class Strategy_EXPLOITATIVE_6(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-self.game_description.n_players + 1:,]
        cooperators = sum(opponent_actions[:, -1])
        if all(opponent_actions[:, -1]):
            cooperation_threshold = (2 * self.game_description.n_players - 1) * self.game_description.capacity / (4 * self.game_description.n_players)
        else:
            cooperation_threshold = self.game_description.capacity / self.game_description.n_players
        if state.current_stock <= cooperation_threshold:
            return Action.D
        else:
            return Action.C

    def update_cooperation_threshold(self, new_capacity: int):
        if self.cooperation_threshold is None:
            self.cooperative_threshold = self.game_description.capacity / self.game_description.n_players
        else:
            self.cooperative_threshold = min((2 * self.game_description.n_players - 1) * new_capacity / (4 * self.game_description.n_players), self.cooperation_threshold) if all(new_history[-self.game_description.n_players + 1:] == Action.C) else new_capacity / self.game_description.n_players

class Strategy_EXPLOITATIVE_7(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_opponent_cooperated = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and (not history):
            return Action.C
        if history:
            self.last_round_opponent_cooperated = any(history.opponent_actions[-1])
        if state.round_number != len(history.opponent_actions):
            action = Action.C if self.last_round_opponent_cooperated else Action.D
        else:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_8(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.memory = []
        self.capacity = self.game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.memory.append(history.my_actions[-1])
        if state.current_stock <= self.capacity and history.my_actions[-1] != Action.D:
            opponent_cooperated = np.count_nonzero(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2
            return Action.C if opponent_cooperated else Action.D
        elif state.current_stock > self.capacity:
            return Action.D
        else:
            strategy = self.memory[-1]
            return Action(not strategy)

class Strategy_EXPLOITATIVE_9(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_sustainable = self.game_description.n_players * self.game_description.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0 or current_stock >= self.average_sustainable:
            return Action.C
        random_value = random.random()
        if current_stock < self.average_sustainable:
            return Action.D
        elif random_value > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_10(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation = True
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.last_round = state.round_number >= self.game_description.n_rounds - 1
        if self.opponent_cooperation:
            return Action.C
        else:
            self.opponent_cooperation = False
            return Action.D

class Strategy_EXPLOITATIVE_12(BaseStrategy):
    """
    A strategy that implements the Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy in a Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.t_stock = game_description.capacity / game_description.n_players * 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=bool)
        current_stock = state.current_stock
        if all(opponent_actions):
            return Action.C
        elif current_stock >= self.t_stock:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if current_stock < self.t_stock and np.any(history.opponent_actions):
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_14(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Growth Adaptation (TFT-GA)

    A cooperative strategy that encourages cooperation if others do as well, but also retaliates with defection when others have overconsumed.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_consumption_overall = 0
        self.total_consumption_prev = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.total_consumption_prev = np.sum(history.opponent_actions[:, -1])
        avg_consumption_round = np.mean(history.my_payoffs)
        self.avg_consumption_overall = (self.avg_consumption_overall * (state.round_number - 1) + avg_consumption_round) / state.round_number
        if self.total_consumption_prev <= self.avg_consumption_overall:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_15(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Games
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self._opponent_history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or self._opponent_history is None:
            return Action.C
        self._opponent_history = history.opponent_actions if history else np.zeros((self.n_rounds, self.n_players))
        if len(self._opponent_history) < self.n_players - 1:
            return Action.C
        opponent_cooperators = self._opponent_history[-1].sum()
        if np.all(self._opponent_history[:self.n_players - 1, -1] == False):
            return Action.D
        is_last_round = state.round_number >= self.n_rounds - 1
        if is_last_round:
            opponent_total_payoff = np.sum(history.opponent_payoffs)
            my_total_payoff = np.sum(history.my_payoffs)
            tie = my_total_payoff == opponent_total_payoff
            payoff_difference = my_total_payoff - opponent_total_payoff
            if not tie or payoff_difference > 0:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_16(BaseStrategy):
    """Tit-for-Tat with Stock Adjustment (TFT-SA) strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.t1 = game_description.capacity / 3
        self.t2 = 2 * self.t1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock < self.t1:
                return Action.D
            else:
                return Action.C
        if state.current_stock == 0:
            return Action.D
        cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        total_consumption = self.game_description.n_players * np.mean(history.my_payoffs[-1]) if history else 0
        stock_after_consumption = state.current_stock - total_consumption
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
        new_stock = min(state.current_stock + growth, self.game_description.capacity)
        stock_level = new_stock if history else state.current_stock
        if cooperators == self.game_description.n_players:
            return Action.C
        elif cooperators > 0 and stock_level < self.t1:
            return Action.C
        elif cooperators == 0 and stock_level > self.t2:
            return Action.D
        else:
            return Action.C if stock_level < (self.t1 + self.t2) / 2 else Action.D

class Strategy_EXPLOITATIVE_17(BaseStrategy):
    """
    A TFT-ACT strategy for the Common Pool Resource Game.
    This strategy cooperates in the first round, then adapts its cooperation based on opponents' previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = None
        self.rounds_played = 0

    def calculate_cooperative_percentage(self, opponent_history):
        cooperation_count = sum(opponent_history)
        total_rounds = len(opponent_history)
        return cooperation_count / total_rounds if total_rounds > 0 else 0.0

    def calculate_cooperative_threshold(self, opponent_history):
        cooperative_percentage = self.calculate_cooperative_percentage(opponent_history)
        return math.floor(len(opponent_history) * (0.6 + (0.4 - 0.6) * (cooperative_percentage - 0.4)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.cooperative_threshold = self.calculate_cooperative_threshold(history.opponent_actions[-1, :])
        action = Action.D
        if state.round_number < self.game_description.n_rounds - 1:
            if history.opponent_actions[-1, -1] == Action.C:
                action = Action.C
        elif history.opponent_actions[-1, -1] == Action.C and self.cooperative_threshold > len(history.opponent_actions) // 2:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_18(BaseStrategy):
    """Adaptive Tit-for-Tat (ATfT) Common Pool Resource Game Strategy"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_per_player = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.stock_per_player is None or state.current_stock < self.stock_per_player:
            self.stock_per_player = state.current_stock / self.game_description.n_players
        opponent_action = history.opponent_actions[-1][0] if len(history.opponent_actions) > 0 else None
        if state.round_number < self.game_description.n_rounds - 1:
            action = Action.C if opponent_action is None or self.payoff(state, history) > opponent_action else Action.D
        else:
            action = Action.C
        return action

    def payoff(self, state: CommonPoolState, history: PlayerHistory) -> float:
        """Calculate the expected payoff for a single round given the current state and player history."""
        consumption = np.sum([history.my_actions[i] * (state.current_stock / self.game_description.n_players if history.my_payoffs[i] is None else history.my_payoffs[i]) for i in range(len(history.my_actions))])
        stock = state.current_stock - consumption
        growth = 2 * stock * (1 - stock / self.game_description.capacity)
        new_stock = min(state.current_stock + growth, self.game_description.capacity)
        payoff = new_stock / (self.game_description.n_players if history.my_payoffs is None else np.sum(history.my_payoffs))
        return payoff

class Strategy_EXPLOITATIVE_19(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_payoff = None
        self.last_action = None
        self.past_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.past_history) == 0:
            return Action.C
        self.past_history.append((state.round_number, history))
        last_round = self.past_history[-1]
        last_action = last_round[1].opponent_actions[-1, -1]
        payoff_last_round = last_round[1].opponent_payoffs[-1]
        payoff_previous_to_last_round = self.past_history[-2][1].opponent_payoffs[-1] if len(self.past_history) > 1 else None
        if last_action == Action.C:
            return Action.C
        elif last_action == Action.D:
            if state.round_number < self.game_description.n_players:
                return Action.D
            return Action.C
        elif payoff_last_round > (payoff_previous_to_last_round if payoff_previous_to_last_round is not None else 0):
            self.last_action = last_action
            self.last_payoff = payoff_last_round
        elif payoff_last_round < (payoff_previous_to_last_round if payoff_previous_to_last_round is not None else 0):
            return Action.opposite(self.last_action)
        else:
            action = random.choice([self.last_action, Action.opposite(self.last_action)])
            self.last_action = action
            self.last_payoff = payoff_last_round
        return self.last_action

class Strategy_EXPLOITATIVE_20(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Stock Adjustment (TFT-SA)

    This strategy follows a cooperative approach initially, mimicking opponents' actions thereafter.
    When the stock level drops below a threshold, it defects to conserve resources and encourage other players to do the same.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 2 * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        last_opponent_action = history.opponent_actions[-1][0] if history is not None else None
        stock_level = state.current_stock
        if stock_level < self.stock_threshold or (last_opponent_action is not None and last_opponent_action):
            return Action.D
        return Action(last_opponent_action)

class Strategy_EXPLOITATIVE_21(BaseStrategy):
    """
    Tit-for-Tat with Stock Growth Adaptation (TFT-SGA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((game_description.n_rounds,), dtype=bool), my_payoffs=np.zeros(game_description.n_rounds, dtype=np.float64), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number > 0 and history is not None:
            recent_rounds = min(state.round_number, self.game_description.n_rounds // 2)
            average_consumption = np.mean(history.opponent_actions[state.round_number - recent_rounds:state.round_number, :].sum(axis=1))
            if average_consumption < self.game_description.capacity / self.game_description.n_players:
                return Action.C
            else:
                return Action.D
        elif state.round_number == self.game_description.n_rounds - 1 and history is None:
            recent_rounds = min(state.round_number, self.game_description.n_rounds // 2)
            average_consumption = np.mean(self.history.opponent_actions[state.round_number - recent_rounds:state.round_number, :].sum(axis=1))
            if average_consumption < self.game_description.capacity / self.game_description.n_players:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_22(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Threshold strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_stock = self.capacity
        self.current_stock = self.initial_stock
        self.past_history_length = self.n_players * math.log2(self.n_rounds)
        self.cooperation_threshold = self.initial_stock / (4 * self.n_players)
        self.first_round = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            self.first_round = True
            return Action.C
        self.current_stock += self.initial_stock - self.current_stock
        self.initial_stock = self.current_stock
        if not self.first_round:
            cooperators = np.count_nonzero(history.opponent_actions[-1, :])
            self.past_history_length += math.log2(self.past_history_length)
            self.cooperation_threshold *= 0.95 if all(history.opponent_payoffs[-1]) else 1.05
            self.cooperation_threshold = max(self.cooperation_threshold, self.initial_stock / (4 * self.n_players))
        if self.first_round or self.current_stock < self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_23(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_count = 0
        self.player_index = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        self.player_index = np.argwhere(history.my_actions == True)[0][0] if history is not None else 0
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return self.exploit_last_round(history, state)
        if history is not None:
            stock = np.maximum(state.current_stock - np.sum(history.opponent_actions[:, self.player_index]), 0)
            if stock > self.game_description.capacity / (2 * self.game_description.n_players):
                self.cooperation_count += 1
            elif stock < self.game_description.capacity / (4 * self.game_description.n_players):
                self.cooperation_count -= 1
        if (state.round_number + self.cooperation_count) % 2 == 0:
            return Action.C
        else:
            opponent_action = history.opponent_actions[state.round_number - 1, self.player_index] if history is not None else None
            return Action.D if opponent_action is not None and opponent_action == Action.D else Action.C

    def exploit_last_round(self, history: PlayerHistory, state: CommonPoolState) -> Action:
        if (self.cooperation_count + 1) % 2 == 1 or (self.cooperation_count == 0 and self.get_potential_cooperators(history) > 0):
            return Action.D
        else:
            return Action.C

    def get_potential_cooperators(self, history: PlayerHistory) -> int:
        potential_cooperators = np.sum(history.opponent_actions[:, self.player_index]) - 1 if history is not None else 0
        return math.ceil(potential_cooperators * (1 - state.current_stock / self.game_description.capacity))

class Strategy_EXPLOITATIVE_25(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    Mimics opponent's last action. Cooperates in the first round, retaliates if provoked.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        last_opponent_action = history.opponent_actions[-1][-1] if len(history.opponent_actions) > 0 else None
        if last_opponent_action is None or state.round_number == self.game_description.n_rounds:
            return Action.C
        return Action(last_opponent_action)

class Strategy_EXPLOITATIVE_26(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Threshold (TFTA) strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.n_players / 2)
        self.history = PlayerHistory(np.zeros((1, game_description.n_rounds), dtype=bool), np.zeros(game_description.n_rounds, dtype=np.float64), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players), dtype=np.float64))
        self.avg_consumption = 0
        self.num_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.num_rounds == 0:
            self.history.my_actions[0] = True
            self.history.opponent_actions[:, 0] = np.array([1 if a == Action.C else 0 for a in history.opponent_actions[:, -1]])
            self.num_rounds += 1
        cooperators = sum(history.opponent_actions[-1, :])
        self.avg_consumption = (self.avg_consumption * (self.num_rounds - 1) + float(cooperators)) / self.num_rounds
        self.num_rounds += 1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if self.avg_consumption < self.threshold else self.choose_best_action(state, history)
        if self.avg_consumption < self.threshold:
            self.history.my_actions[-1] = True
            return Action.C
        self.history.my_actions[-1] = False
        return Action.D

    def choose_best_action(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        cooperators = sum(history.opponent_actions[-1, :])
        if self.avg_consumption > self.threshold and cooperators < self.game_description.n_players // 2:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if opponent_cooperators == 0:
            return Action.D
        else:
            max_payoff = -np.inf
            chosen_action = None
            for action in [Action.C, Action.D]:
                payoff = state.current_stock / (self.game_description.n_players if action == Action.D else 2 * self.game_description.n_players)
                if payoff > max_payoff:
                    max_payoff = payoff
                    chosen_action = action
            return chosen_action

class Strategy_EXPLOITATIVE_29(BaseStrategy):
    """
    A strategy that cooperates in the first round and implements a Tit-for-Tat approach,
    while also adapting cooperation based on remaining stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity * (2 * game_description.n_players) / 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0:
            return action
        last_round = len(history.opponent_actions) - 1
        last_cooperators = sum(history.opponent_actions[last_round, :])
        if last_cooperators >= self.game_description.n_players // 2:
            action = Action.C
        elif state.current_stock < self.capacity * (2 * self.game_description.n_players) / 3:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_30(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Greed (TfT-AG) strategy for the Common Pool Resource Game.
    This strategy employs a Tit-for-Tat approach, but also adapts its response based on the current stock level to maximize payoffs in various game situations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.alpha = 0.5
        self.current_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if history is not None:
            opponent_action = history.opponent_actions[-1, 0]
            if self.current_stock is not None:
                stock_percentage = self.current_stock / self.game_description.capacity * 100
                if stock_percentage > 90:
                    self.alpha += 0.05
                elif stock_percentage < 60:
                    self.alpha -= 0.05
            if opponent_action:
                action = Action.C
                self.alpha = max(self.alpha - 0.1, 0.2)
            else:
                self.alpha = min(self.alpha + 0.1, 0.8)
            if state.round_number == self.game_description.n_rounds - 1:
                if opponent_action:
                    action = Action.D
            self.current_stock = state.current_stock
        return action

class Strategy_EXPLOITATIVE_31(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TfT-SA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold_75 = self.game_description.capacity * 0.75
        self.stock_threshold_90 = self.game_description.capacity * 0.9

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = (history.opponent_actions[-1] if history else np.full((1, self.game_description.n_players), False)).flatten()[0]
        current_stock = state.current_stock
        if opponent_action:
            if current_stock < self.stock_threshold_75:
                return Action.D
            elif current_stock < self.stock_threshold_90:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def update_state(self, state: CommonPoolState, payoff: float) -> None:
        if state.current_stock < 0:
            state.current_stock = 0
        else:
            consumption = np.where(np.array([True] * self.game_description.n_players + [False])[state.round_number], 2, 1) * payoff
            remaining_stock = state.current_stock - sum(consumption)
            growth = 2 * min(remaining_stock, self.game_description.capacity) * (1 - min(remaining_stock, self.game_description.capacity) / self.game_description.capacity)
            state.current_stock = max(remaining_stock + growth, self.game_description.capacity)
        state.round_number += 1

class Strategy_EXPLOITATIVE_32(BaseStrategy):
    """
    A strategy that cooperates in the first round and exploits opponents who exhibit cooperative or inconsistent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        self.last_opponent_action = history.opponent_actions[last_round, 0] if last_round >= 0 else None
        if state.round_number == self.game_description.n_rounds:
            return Action.C if self.last_opponent_action is None or self.last_opponent_action == Action.C else Action.D
        return Action(1 if self.last_opponent_action == Action.C else 0)

class Strategy_EXPLOITATIVE_33(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive cooperation threshold for common pool resource games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds_played = 0
        self.recent_cooperation = 0.5
        self.c_threshold = 0.5
        self.opponent_behavior = None
        self.a_threshold = 0.1
        self.cooperation_history = np.zeros(game_description.n_rounds)
        self.payoff_total = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.cooperation_history = np.roll(self.cooperation_history, -1)
            self.cooperation_history[-1] = int(history.opponent_actions[-1, -1])
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        current_opponent_behavior = sum(self.cooperation_history[-3:]) >= np.floor(len(self.cooperation_history[-3:]) * self.c_threshold).astype(int)
        if current_opponent_behavior != self.opponent_behavior:
            abs_diff = np.abs(self.recent_cooperation - self.c_threshold)
            if abs_diff > self.a_threshold:
                if current_opponent_behavior == True:
                    self.c_threshold += 0.01
                elif current_opponent_behavior == False:
                    self.c_threshold -= 0.01
                self.opponent_behavior = current_opponent_behavior
        if self.recent_cooperation > self.c_threshold:
            cooperate = True
        else:
            cooperate = False
        payoff_this_round = state.current_stock / (2 * self.game_description.n_players) if cooperate else state.current_stock / self.game_description.n_players
        self.payoff_total += payoff_this_round
        return Action(int(cooperate))

class Strategy_EXPLOITATIVE_34(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Greed (TfT-AG) Strategy
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.tolerance = int(self.capacity * 0.2)
        self.last_quarter = int(game_description.n_rounds / 4)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if state.current_stock < self.tolerance or (state.round_number >= self.last_quarter and np.sum(history.my_actions) < self.game_description.n_players):
            return Action.D
        opponent_action = history.opponent_actions[-1, 0] if len(history.opponent_actions) > 0 else False
        return Action.C if opponent_action else Action.D

class Strategy_EXPLOITATIVE_36(BaseStrategy):
    """
    The Tit-for-Tat-Growth (TfT-G) strategy cooperates in the first round and adjusts its actions based on the opponent's behavior in previous rounds. It prioritizes preserving the common pool resource when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 2 * game_description.n_players // 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            last_round = len(history.opponent_actions) - 1
            last_action = history.opponent_actions[last_round, 0]
            stock = state.current_stock
            if stock < self.threshold or stock >= self.game_description.capacity - 2 * self.game_description.n_players:
                return Action.C if last_action else Action.D
            return Action.C if last_action else Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_37(BaseStrategy):
    """
    A Tit-for-Tat with Stock Adaptation (TFTSA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=None, my_payoffs=None, opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros(game_description.n_rounds * game_description.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is None:
            self.history = PlayerHistory(my_actions=[False] if state.round_number == 0 else self.history.my_actions, my_payoffs=[0.0] if state.round_number == 0 else self.history.my_payoffs, opponent_actions=self.history.opponent_actions, opponent_payoffs=self.history.opponent_payoffs)
        action = Action.D
        if state.round_number > 0:
            cooperators = self.history.opponent_actions[-1].sum()
            action = Action.C if cooperators >= self.game_description.n_players // 2 else Action.D
        if state.round_number == 0 or (state.round_number > 0 and history.my_actions[-1]):
            payoff = self.calculate_payoff(state, action)
            self.history = PlayerHistory(my_actions=self.history.my_actions + [action], my_payoffs=self.history.my_payoffs + [payoff], opponent_actions=self.history.opponent_actions, opponent_payoffs=self.history.opponent_payoffs)
        return action

    def calculate_payoff(self, state: CommonPoolState, action: Action) -> float:
        if action == Action.C:
            consumption = state.current_stock / (2 * self.game_description.n_players)
        else:
            consumption = state.current_stock / self.game_description.n_players
        total_consumption = sum([self.history.opponent_actions[state.round_number - 1, i] * consumption for i in range(self.game_description.n_players) if self.history.opponent_actions[state.round_number - 1, i]])
        remaining_stock = state.current_stock - total_consumption
        growth = 2 * remaining_stock * (1 - remaining_stock / self.game_description.capacity)
        new_stock = min(remaining_stock + growth, self.game_description.capacity)
        payoff = new_stock / (2 * self.game_description.n_players) if action == Action.C else new_stock / self.game_description.n_players
        return payoff

class Strategy_EXPLOITATIVE_38(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Adjustment (TFT-SA)
    This strategy aims to balance cooperation and defection based on the opponent's behavior, while maintaining a sustainable stock level.
    It adapts to a wide range of opponent strategies, making it suitable for tournament participation against other AI systems with independent strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_level = self.game_description.capacity / (2 * game_description.n_players)
        self.opponent_behavior = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or len(history.opponent_actions) < state.round_number + 1:
            return Action.C
        last_round = state.round_number - 1
        last_action = history.opponent_actions[last_round]
        if self.opponent_behavior is None:
            self.opponent_behavior = last_action
        current_stock = state.current_stock
        if last_action and current_stock >= self.critical_level:
            return Action.C
        elif not last_action and current_stock < self.critical_level:
            return Action.D
        elif self.opponent_behavior == Action.C and current_stock < self.critical_level:
            return Action.D
        elif self.opponent_behavior != Action.C and current_stock >= self.critical_level:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_39(BaseStrategy):
    """
    Tit-for-Tat with Growth Adaptation (TfT-GA) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))
            return Action.C
        total_cooperation = np.sum(history.my_actions[:state.round_number])
        if total_cooperation > (self.game_description.n_players - 1) * state.round_number:
            return Action.C
        elif state.current_stock < self.game_description.capacity * (0.5 + self.game_description.n_players ** (-1)):
            return Action.D
        else:
            return Action.C
        self.history.my_actions[state.round_number - 1] = self.__class__.__name__ == history.my_actions[-1].name
        self.history.my_payoffs[state.round_number - 1] = state.current_stock / (2 * self.game_description.n_players) if self.history.my_actions[state.round_number - 1] else state.current_stock / self.game_description.n_players
        self.history.opponent_actions[state.round_number - 1, :] = history.opponent_actions[:state.round_number]
        self.history.opponent_payoffs[state.round_number - 1, :] = history.opponent_payoffs[:state.round_number]

class Strategy_EXPLOITATIVE_40(BaseStrategy):
    """
    A strategy that implements the Tit-for-Tat-Growth (TFT-G) approach in Common Pool Resource Games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C
        opponent_action = history.opponent_actions[-1, 0] if history else None
        if opponent_action is None:
            return Action.C
        elif opponent_action and state.current_stock > self.stock_threshold:
            return Action.C
        elif not opponent_action and state.current_stock > self.stock_threshold:
            return Action.D
        elif state.current_stock <= self.stock_threshold:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_41(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Greed (TfT-AG) for the Common Pool Resource Game.
    A strategy that adapts its cooperation based on opponent's past behavior and current state of common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = math.floor(game_description.capacity * 0.7)
        self.punishment_window = math.ceil(game_description.n_players / 3)
        self.cooperation_probability = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        action = Action.C
        if state.round_number == 0:
            return Action.C
        opponent_defects = sum(history.opponent_actions[:, -self.punishment_window:].sum(axis=1) > 0)
        current_stock = state.current_stock
        if current_stock <= self.threshold or (opponent_defects >= self.game_description.n_players and state.round_number != self.game_description.n_rounds - 1):
            action = Action.D
        elif opponent_defects < self.punishment_window:
            if random.random() > self.cooperation_probability:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_42(BaseStrategy):
    """
    A Tit-for-Tat strategy with an adaptive cooperation threshold (TFT-ACT).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.R_c = int(math.ceil(game_description.n_players / 2))
        self.last_opponent_action = Action.D

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            self.last_opponent_action = history.opponent_actions[-1, :].mean() if history else Action.D
        cooperators = sum(history.opponent_actions[:, -1]) if history else 0
        cooperative = bool(cooperators >= self.game_description.n_players // 2)
        if cooperative:
            self.last_opponent_action = Action.C
            if self.R_c < self.game_description.n_rounds:
                self.R_c += 1
        else:
            self.last_opponent_action = Action.D
            if self.R_c > 0 and self.R_c - math.floor(self.R_c / 2) >= 0:
                self.R_c -= math.floor(self.R_c / 2)
        return self.last_opponent_action

class Strategy_EXPLOITATIVE_45(BaseStrategy):
    """
    Fixed-Thresholds Adaptive Strategy (FTAS) for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.T_C = self.capacity / (2 * self.n_players)
        self.T_D = self.capacity / self.n_players
        self.T_initial_C = self.capacity * 0.8
        self.T_initial_D = self.capacity * 0.2
        self.T_last_C = self.T_C
        self.T_last_D = self.T_D

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if history is not None and state.round_number > 0:
            S_r_prime = self.capacity - (state.round_number - 1) * (self.n_players * self.T_C + (self.T_D - self.T_C))
            if S_r_prime < self.T_last_D:
                return Action.D
            elif S_r_prime >= self.T_last_C:
                return Action.C
            else:
                roll = random.random()
                if roll <= 0.5:
                    return Action.C
                else:
                    return Action.D
        if history is None or state.round_number == 0:
            if current_stock < self.T_initial_D:
                return Action.D
            elif current_stock >= self.T_initial_C:
                return Action.C
            else:
                roll = random.random()
                if roll <= 0.5:
                    return Action.C
                else:
                    return Action.D
        if current_stock < self.T_initial_D or current_stock >= self.T_initial_C:
            if current_stock < self.T_initial_D:
                return Action.D
            elif current_stock >= self.T_initial_C:
                return Action.C
        else:
            roll = random.random()
            if roll <= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_46(BaseStrategy):
    """
    An exploitative strategy called "Adaptive Tit-for-Tat with Stock Awareness" (ATFS).
    This strategy aims to maximize payoffs by being cooperative when it benefits the player and defecting in response to defections from opponents.
    The strategy also considers the current stock level as a factor in decision-making.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_percentage_bounds = [0.2, 0.8]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self._update_history(state, history)
        opponent_cooperated = sum(history.opponent_actions[-1]) >= self.game_description.n_players // 2
        own_cooperation = (not history.my_actions[:-1].all() or opponent_cooperated) and (state.current_stock > self.game_description.capacity * self.capacity_percentage_bounds[0] or state.current_stock < self.game_description.capacity * self.capacity_percentage_bounds[1])
        return Action(own_cooperation) if own_cooperation else Action.D

    def _update_history(self, state: CommonPoolState, history: PlayerHistory):
        new_action = state.round_number == 0 and Action.C or history.my_actions[-1] if history else None
        self.last_action = new_action
        history = history or PlayerHistory(np.zeros((self.game_description.n_rounds,), dtype=bool), np.zeros((self.game_description.n_rounds, 1)))
        history.my_actions[-1] = self.last_action

class Strategy_EXPLOITATIVE_47(BaseStrategy):
    """
    Ttit-for-Tat with Adaptive Stock-Aware Cooperation (TA-SC) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = self.game_description.n_players
        self.stock_threshold = math.ceil(self.game_description.capacity / 2)
        self.payoff_minimum = self.game_description.capacity / (4 * self.n_players)
        self.m = min(int(self.n_players / 2), self.game_description.n_rounds - 1)
        self.cooperation_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            payoff_avg = np.mean(history.my_payoffs[-self.m:]) if history else 0.0
            stock_level = state.current_stock
            return Action.C if stock_level >= self.stock_threshold and payoff_avg >= self.payoff_minimum else Action.D
        payoff_avg = np.mean(history.my_payoffs[-self.m:]) if history else 0.0
        stock_level = state.current_stock
        cooperation_condition = stock_level >= self.stock_threshold and payoff_avg >= self.payoff_minimum
        if not cooperation_condition and self.m > 1:
            self.m -= 1
        return Action.D if not cooperation_condition else Action.C

class Strategy_EXPLOITATIVE_48(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFTSA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.Stock_Threshold = self.get_stock_threshold()

    def get_stock_threshold(self) -> float:
        """
        Calculate the Stock Threshold based on game parameters (n and capacity).
        """
        return self.capacity * (self.n - 1) / (2 * self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determine the action based on the given state and opponent's history.
        """
        if state.round_number == 0 or history is None:
            return Action.C
        last_action = history.opponent_actions[-1, -1] if history is not None else Action.C
        if last_action == Action.C and state.current_stock > self.Stock_Threshold:
            return Action.C
        elif last_action == Action.D or state.current_stock <= self.Stock_Threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_50(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)
    This strategy cooperates initially, then adjusts cooperation based on average historical actions of all players.
    If the average cooperation rate is above 50%, it cooperates; otherwise, defects.
    It punishes deviations by mirroring previous round's action for the next two rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((self.game_description.n_rounds,), dtype=bool), my_payoffs=np.zeros((self.game_description.n_rounds,), dtype=np.float64), opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=np.float64))
        self.punishment_counter = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.C
        self.history.my_actions[-1] = Action.C == (state.current_stock - self.game_description.capacity) / (self.game_description.capacity * 2)
        if not self.history:
            return self.history.my_actions[-1]
        t = int(self.game_description.n_rounds * 0.8)
        cooperators = np.mean(self.history.my_actions[max(0, self.game_description.n_rounds - t):])
        if state.round_number < self.game_description.n_rounds - 1:
            cooperators += (self.punishment_counter > 0) * -2
            self.punishment_counter = 0
        if cooperators > 0.5:
            return Action.C
        if np.count_nonzero(self.history.my_actions[-2:] != self.history.my_actions[-1:]) > 1:
            self.punishment_counter += 1
            return self.history.my_actions[-1]
        return Action.D

class Strategy_EXPLOITATIVE_53(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_num_defected_opponent = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = np.array(history.opponent_actions)[state.round_number - 1, 0]
        if opponent_action:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.C
        else:
            if opponent_action and state.current_stock / self.game_description.capacity >= 0.75:
                retaliation_probability = min(1, self.round_num_defected_opponent / self.game_description.n_players)
                return Action.C if random.random() < retaliation_probability else Action.D
            self.round_num_defected_opponent += 1
        return Action.D

class Strategy_EXPLOITATIVE_54(BaseStrategy):
    """
    A Tit-for-Tat-Growth strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_stock = game_description.capacity
        self.cooperated_this_round = False
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is None:
            return Action.C
        self.last_opponent_action = np.mean(history.opponent_actions[-1])
        action = Action.C if state.round_number == 0 or self.current_stock <= self.game_description.capacity * 0.5 else self._decide_action()
        self.cooperated_this_round = action == Action.C
        return action

    def _decide_action(self):
        potential_growth = np.maximum(2 * self.current_stock * (1 - self.current_stock / self.game_description.capacity), 0)
        if self.last_opponent_action:
            if self.last_opponent_action and (not self.cooperated_this_round):
                return Action.C
            elif not self.last_opponent_action and self.cooperated_this_round:
                return Action.D
        return Action.C if potential_growth > 0 else Action.D

class Strategy_EXPLOITATIVE_55(BaseStrategy):
    """
    Tit-for-Tat with Growth Adaptation (TfTGA) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_half = game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_state = state.round_number == last_round
        last_opponent_action = history.opponent_actions[last_round, -1] if not last_state else history.opponent_actions[-2, -1]
        current_stock = state.current_stock
        if last_state:
            return Action(last_opponent_action) if last_opponent_action else Action.C
        if last_opponent_action:
            if current_stock > self.capacity_half:
                return Action.C
            elif current_stock <= self.capacity_half:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_56(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = int(math.ceil(self.game_description.n_rounds * 0.7))
        self.threshold = game_description.n_players // 2
        self.payoffs = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        action = Action.C
        if state.round_number == 0 or not history:
            return action
        cooperators = np.sum(history.opponent_actions[:, -self.k:], axis=1) / self.k
        if np.mean(cooperators) > self.threshold:
            action = Action.C
        payoff = history.my_payoffs[-1]
        if payoff > self.game_description.capacity // self.n_players:
            self.threshold += 0.25
        elif payoff < self.game_description.capacity // (4 * self.n_players):
            self.threshold -= 0.25
        self.payoffs[-1] = payoff
        return action

class Strategy_EXPLOITATIVE_57(BaseStrategy):
    """
    A player that implements the Tit-for-Tat-Growth (TFT-G) strategy in Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.half_capacity = self.game_description.capacity // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C if state.current_stock >= self.half_capacity else Action.D
        current_cooperators = sum(history.opponent_actions[-1, :])
        current_stock_level = math.floor(state.current_stock)
        if current_stock_level >= self.half_capacity:
            return Action.C
        elif current_stock_level <= self.half_capacity or current_cooperators < self.game_description.n_players // 2:
            return Action.D
        elif random.random() > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_58(BaseStrategy):
    """
    A Tit-for-Tat with Stock Adaptation (TFTSA) strategy for Common Pool Resource Games.
    This strategy balances cooperation and defection, taking into account the current state (common pool resource) and opponent's actions from previous rounds while prioritizing long-term sustainability of the common resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 2 * self.game_description.n_players // 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_action = history.opponent_actions[last_round, 0]
        if state.round_number == last_round + 1 or state.current_stock < self.threshold:
            return Action.D
        elif state.current_stock >= self.game_description.capacity:
            return Action.C
        elif last_action:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_59(BaseStrategy):
    """
    Growth-Based Adaptive Strategy (GBAS) for the Common Pool Resource Game.
    This strategy is adaptive and robust against a wide range of opponent behaviors, seeking to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_payoff = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.D if state.current_stock < self.game_description.capacity else Action.C
        if state.round_number == 1:
            return Action.D if state.current_stock < self.game_description.capacity else Action.C
        if state.current_stock < self.game_description.n_players * 2:
            return Action.D
        elif state.current_stock >= self.game_description.capacity // self.game_description.n_players and history.my_payoffs[-1] < self.average_payoff:
            return Action.C
        elif state.current_stock >= self.game_description.capacity // self.game_description.n_players:
            return Action.C
        elif state.round_number == self.game_description.n_rounds and state.current_stock < self.game_description.n_players * 2:
            return Action.D
        elif state.round_number == self.game_description.n_rounds and (state.round_number - 2 < len(history.my_payoffs) and history.my_payoffs[-self.game_description.n_rounds + 2:-1].mean() > history.my_payoffs[-1]):
            return Action.C
        else:
            return Action.D

    def update_average_payoff(self, payoffs: NDArray[np.float64]):
        """
        Update average_payoff with the new payoffs from the last r rounds
        """
        self.average_payoff = np.mean(payoffs[-self.game_description.n_rounds:-1])

class Strategy_EXPLOITATIVE_60(BaseStrategy):
    """
    A Tit-for-Tat Exploitative Strategy (TFTES) that mimics cooperation while taking advantage of opponents who over-exploit the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity // game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and np.all(history.my_actions[:-1] == [False])):
            return Action.C
        consumption_total = np.sum(history.opponent_actions[:, -1]) * self.game_description.n_players
        if consumption_total < self.capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_61(BaseStrategy):
    """
    A strategy that cooperates initially, then responds to opponent's previous round actions by either cooperating or defecting.
    This adaptation fosters long-term cooperation while minimizing losses from selfish opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_cooperators = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        self.last_round_cooperators = opponent_cooperators
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif opponent_cooperators >= self.game_description.n_players - 1 and self.last_round_cooperators == self.game_description.n_players - 1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_62(BaseStrategy):
    """
    Tit-for-Tat with Stock Awareness (TfTS-A) strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity * (2 * self.game_description.n_players) / 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        opponent_cooperators = sum(opponent_actions)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D if state.current_stock < self.capacity / self.game_description.n_players else Action.C
        stock = state.current_stock
        if stock < self.capacity * 2 / 3:
            return Action.D
        elif opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_63(BaseStrategy):
    """
    A strategy that plays the Common Pool Resource Game using the Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) approach.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = None
        self.history = PlayerHistory(my_actions=np.zeros((game_description.n_rounds,), dtype=bool), my_payoffs=np.zeros((game_description.n_rounds,), dtype=float), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=float))

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        self.history = history
        if state.round_number == 0:
            return Action.C
        action = Action.C
        cooperation_threshold = (self.cooperation_threshold * 2 + state.current_stock) / 3 if self.cooperation_threshold is not None else state.current_stock
        opponents_cooperated = sum(history.opponent_actions[-1]) >= self.game_description.n_players // 2
        if not opponents_cooperated:
            if state.current_stock > cooperation_threshold:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_64(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)
    Summary: Cooperates if opponent cooperated in the previous round, otherwise defects to punish defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_number = 0
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        self.round_number += 1
        if history is None:
            return Action.C
        opponent_action = history.opponent_actions[-1, -1]
        payoff = 0.0
        if self.last_opponent_action is None:
            payoff = state.current_stock / (2 * self.game_description.n_players)
            self.last_opponent_action = opponent_action
        elif opponent_action == self.last_opponent_action:
            if opponent_action:
                payoff = state.current_stock / (2 * self.game_description.n_players)
            else:
                payoff = state.current_stock / self.game_description.n_players
        else:
            payoff = state.current_stock / self.game_description.n_players
            self.last_opponent_action = opponent_action
        if self.round_number == self.game_description.n_rounds:
            return Action.D
        return Action(int(payoff > 0))

class Strategy_EXPLOITATIVE_65(BaseStrategy):
    """
    A Tit-for-Tat strategy with an adaptive cooperation threshold, designed for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = math.ceil((game_description.n_players + 1) / 2)
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))
        self.current_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        self.history.my_payoffs[state.round_number] = self.current_stock / (2 * self.game_description.n_players) if history is not None else 0
        if state.round_number < self.game_description.n_rounds - 1:
            if cooperators >= self.cooperative_threshold:
                self.cooperative_threshold = math.ceil((self.game_description.n_players + 1) / 2)
                return Action.C
            elif sum(history.opponent_actions[:, self.cooperative_threshold - 1] > self.cooperative_threshold // 2) and sum(history.opponent_actions[-1, :]) < self.cooperative_threshold:
                self.cooperative_threshold -= 1
            return Action.D
        else:
            if cooperators >= self.game_description.n_players // 2:
                return Action.D
            return Action.C

class Strategy_EXPLOITATIVE_66(BaseStrategy):
    """
    Tit-for-Tat Exploitative Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if not self.history or state.round_number == 0:
            return Action.C
        all_cooperated = np.all(history.opponent_actions[:, -1] == 1)
        if all_cooperated:
            return Action.C
        round_length = self.game_description.n_players
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        index = min(state.round_number - 1, len(history.opponent_actions) - round_length + 1)
        cooperators = np.sum(history.opponent_actions[index:index + round_length])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_67(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = 2
        self.last_round_payoff = 0.0
        self.opponent_depletion = [0.0 for _ in range(self.game_description.n_players)]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = Action.D
        if history is None:
            return action
        opponent_cooperation_count = np.sum(history.opponent_actions[-self.game_description.n_rounds:, -1])
        opponent_defection_count = self.game_description.n_players * (self.game_description.n_rounds - opponent_cooperation_count)
        if opponent_cooperation_count >= self.cooperative_threshold:
            action = Action.C
        else:
            new_ct = self.cooperative_threshold + math.floor(opponent_defection_count / self.game_description.n_rounds)
            self.cooperative_threshold = min(new_ct, self.game_description.n_rounds - 1)
        if state.round_number == self.game_description.n_rounds - 1:
            current_stock = state.current_stock / self.game_description.n_players
            if current_stock > 0:
                action = Action.C
            elif np.any(self.opponent_depletion >= current_stock):
                action = Action.D
        if np.any(np.equal(self.opponent_depletion, self.last_round_payoff)):
            self.opponent_depletion[np.argmin(self.opponent_depletion)] += 1
            self.last_round_payoff = history.my_payoffs[-1]
        else:
            self.opponent_depletion[np.argmax(self.opponent_depletion)] += 1
            self.last_round_payoff = history.my_payoffs[-1] - self.last_round_payoff
        return action

class Strategy_EXPLOITATIVE_68(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Growth Adaptation (TFT-SGA)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        if len(history.opponent_actions) > 0:
            last_move = history.opponent_actions[-1][-1]
            if last_move == True:
                return Action.C
            elif state.current_stock < self.threshold * self.game_description.capacity / self.game_description.n_players:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_69(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = int(game_description.n_players * 0.5)
        self.window_size = math.floor(game_description.n_rounds / 10)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > self.game_description.capacity * 0.75:
                return Action.C
            else:
                return Action.D
        if history is None:
            return Action.C
        opponent_cooperation_rate = np.mean(history.opponent_actions[-self.window_size:, :].sum(axis=0))
        return Action.C if opponent_cooperation_rate > self.cooperation_threshold else Action.D

class Strategy_EXPLOITATIVE_70(BaseStrategy):
    """
    A simple Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        opponent_cooperated_last_round = sum(history.opponent_actions[last_round]) > 0
        return Action(int(opponent_cooperated_last_round))

class Strategy_EXPLOITATIVE_71(BaseStrategy):
    """
    A strategy that implements Tit-for-Tat with Stock Adaptation for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.conservative_threshold = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        last_opponent_actions = history.opponent_actions[previous_round] if history else np.zeros(self.game_description.n_players)
        cooperators = sum(last_opponent_actions)
        if state.current_stock < self.game_description.capacity * self.conservative_threshold:
            return Action(cooperators >= self.game_description.n_players // 2)
        return Action.C

class Strategy_EXPLOITATIVE_72(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Gradient Adaptation (TFT-GA)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = int(game_description.n_players / 2)
        self.tiebreaker_rounds = 3
        self.num_ties = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if opponent_cooperators == self.game_description.n_players - self.cooperation_threshold:
            self.num_ties += 1
            if self.num_ties < self.tiebreaker_rounds:
                return Action.C
            elif self.num_ties == self.tiebreaker_rounds:
                return Action.D
        if opponent_cooperators >= self.cooperation_threshold:
            return Action.C
        elif opponent_cooperators > 0:
            self.num_ties = 0
            return Action.D
        if history is not None and history.opponent_actions[-1, :].sum() == 0:
            return Action.C if state.round_number < self.tiebreaker_rounds else Action.D

class Strategy_EXPLOITATIVE_73(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Stock Management Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = self.game_description.n_players
        self.capacity = self.game_description.capacity
        self.threshold = 2 * self.n
        self.forgiveness_period = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperation_count = sum(history.opponent_actions[-self.forgiveness_period:, :].sum(axis=1) > self.n // 2)
        if cooperation_count >= self.forgiveness_period and state.current_stock >= self.threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_74(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []
        self.last_cooperators = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        self.update_opponent_history(history)
        if self.last_cooperators == len(self.opponent_history):
            return Action.C
        else:
            return Action.D

    def update_opponent_history(self, history: PlayerHistory) -> None:
        self.last_cooperators = sum(history.opponent_actions[-1, :])
        self.opponent_history = history.opponent_actions[:-1].tolist()

class Strategy_EXPLOITATIVE_76(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.opponent_history += [history.opponent_actions[-1]]
        last_round = len(self.opponent_history) - 1
        last_action = self.opponent_history[last_round]
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif last_action.all():
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_77(BaseStrategy):
    """
    A Tit-for-Tat strategy with an adaptive cooperation threshold. It cooperates in the first round and adapts its decision based on opponent's history of actions. If the total consumption exceeds a certain percentage (adaptive cooperation threshold) of the current stock level, it defects to conserve the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.ct = 0
        self.opponent_history = []
        self.first_round = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        stock = state.current_stock
        if not self.first_round and len(self.opponent_history) > 0:
            self.ct = int(self.ct * (stock / self.capacity))
        total_consumption_so_far = sum([sum(history.opponent_actions[i] if history is not None else []) for i in range(state.round_number)])
        if total_consumption_so_far <= self.ct and stock > 0:
            action = Action.C
        elif total_consumption_so_far > self.ct or stock == 0:
            action = Action.D
        else:
            action = Action.D if self.first_round else Action.C
        if action == Action.C:
            self.opponent_history.append(stock // (2 * self.n))
        elif action == Action.D:
            self.opponent_history.append(stock // self.n)
        self.first_round = False
        return action

class Strategy_EXPLOITATIVE_78(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFTSA) strategy for Common Pool Resource Game.
    This strategy cooperates when the average consumption per player is less than or equal to capacity/(2n).
    It also punishes players who excessively deplete the common pool by temporarily switching to defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        self.state = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not self.state:
            self.state = state
            if state.current_stock / self.game_description.n_players <= 2:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.state.round_number:
            avg_consumption = np.mean(self.history.opponent_actions[self.state.round_number - 1]) * self.game_description.n_players
            if avg_consumption <= self.game_description.capacity / (2 * self.game_description.n_players):
                return Action.C
        elif state.current_stock >= self.state.current_stock // 2 and state.current_stock / (self.game_description.capacity / 2) >= 1:
            return Action.C
        elif state.current_stock < self.game_description.capacity * 0.5:
            for round_number in range(self.state.round_number, self.game_description.n_rounds):
                self.history.my_actions[round_number] = Action.D
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_80(BaseStrategy):
    """
    The TFT-ACT Strategy applies Tit-for-Tat cooperation while adapting to the average consumption per round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = None
        self.consumption_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = sum(history.my_actions[:state.round_number])
        if self.cooperative_threshold is None or len(self.consumption_history) < self.game_description.n_rounds // 2:
            self.cooperative_threshold = np.mean(self.consumption_history[-self.game_description.n_rounds // 2:])
        if total_consumption < self.cooperative_threshold:
            return Action.C
        else:
            return Action.D

    def update_cooperative_threshold(self, new_consumption_history):
        self.consumption_history = new_consumption_history
        self.cooperative_threshold = np.mean(self.consumption_history[-self.game_description.n_rounds // 2:])

class Strategy_EXPLOITATIVE_81(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions if history else np.zeros((state.round_number + 1, self.game_description.n_players))
        self.opponent_actions_history.append(opponent_actions[-1, :])
        cooperators = sum(self.opponent_actions_history[-1])
        return Action.C if cooperators >= self.game_description.n_players // 2 else Action.D

class Strategy_EXPLOITATIVE_82(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Growth Factor (ATFG) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        last_opponent_action = history.opponent_actions[-1, -1] if history else None
        last_stock_level = state.current_stock if history else self.game_description.capacity
        if (not last_opponent_action or last_stock_level <= self.threshold) and last_opponent_action != Action.C:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_84(BaseStrategy):
    """
    A Tit-for-Tat strategy with Adaptive Cooperation Threshold (TFTAT) for the Common Pool Resource Game.
    The strategy cooperates initially, then adapts its cooperation based on the average level of cooperation from opponents in the last 'history_window' rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.6
        self.history_window = int(math.ceil(game_description.n_rounds / game_description.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is not None:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.C
        elif history is None:
            return Action.D
        else:
            cooperation_average = np.mean(history.opponent_actions[:, -self.history_window:].sum(axis=1) > self.cooperation_threshold)
            return Action.C if cooperation_average > self.cooperation_threshold else Action.D

class Strategy_EXPLOITATIVE_85(BaseStrategy):
    """
    A Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        last_opponent_action = history.opponent_actions[-1][-1] if history else None
        if last_opponent_action is None:
            return Action.C
        elif last_opponent_action:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_86(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

    Strategy Description: A cooperative strategy that encourages cooperation in initial rounds and uses an adaptive
                           cooperation threshold to decide between cooperating and defecting based on the average consumption
                           over the last m rounds. The threshold ensures a minimal resource level for future rounds.

    Decision Rules:
        - Cooperate in the first round or if stock > capacity / n
        - Defect if stock  capacity / n, otherwise use an adaptive cooperation threshold (ACT) to decide between cooperating and defecting.
          Calculate the average consumption per player over the last m rounds. If this average consumption is below the threshold T, cooperate; otherwise defect.
        - After each round, update the ACT based on the current stock level and the average consumption from the last m rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = self.game_description.n_players
        self.n_rounds = self.game_description.n_rounds
        self.capacity = self.game_description.capacity
        self.stock_threshold = self.capacity / self.n_players
        self.m = 5
        self.last_average_consumption = np.zeros(self.m)
        self.last_stock_levels = np.zeros(self.m + 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.current_stock > self.stock_threshold:
            return Action.C
        current_consumption = np.sum(history.my_actions[-self.m:]) if history else 0
        self.last_average_consumption = np.roll(self.last_average_consumption, -1)
        self.last_average_consumption[-1] = current_consumption / self.m
        self.last_stock_levels = np.roll(self.last_stock_levels, -1)
        self.last_stock_levels[-1] = state.current_stock
        average_consumption = np.mean(self.last_average_consumption)
        return Action.C if average_consumption < self.stock_threshold else Action.D

class Strategy_EXPLOITATIVE_87(BaseStrategy):
    """
    A Tit-for-Tat strategy with Stock Adaptation (TFT-SA) for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_stock = math.ceil(game_description.capacity / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_actions = [action for round in history.opponent_actions for action in round]
        if len(opponent_actions) > 0 and opponent_actions[-1] == Action.C:
            if state.current_stock < self.threshold_stock:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_88(BaseStrategy):
    """
    Tit-for-Tat with Growth Adaptation (TfT-GA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.recent_history_length = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        recent_history = history.opponent_actions[-self.recent_history_length:]
        opponent_actions_sum = np.mean(recent_history, axis=0)
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if np.sum(opponent_actions_sum >= 2 / 3 * capacity / (2 * n_players)) > self.recent_history_length // 2:
            return Action.D
        elif np.sum(opponent_actions_sum <= capacity / (2 * n_players)) > self.recent_history_length // 2:
            return Action.C
        else:
            last_round = history.opponent_actions[-1, :]
            if state.round_number == self.game_description.n_rounds:
                return Action.D if np.all(last_round == Action.C) else Action.D not in last_round
            return Action.C if last_round[-1] == Action.C else Action.D

class Strategy_EXPLOITATIVE_89(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Growth Adaptation (TfTGA) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = None
        self.rounds_played = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.average_consumption = np.mean(history.opponent_payoffs[-self.game_description.n_rounds + 1:-1])
            self.rounds_played += 1
        if state.round_number == 0 or self.rounds_played < self.game_description.n_rounds - 1:
            return Action.C
        if self.average_consumption < self.game_description.n_players * 2 / (self.game_description.n_rounds - 1):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_91(BaseStrategy):
    """Adaptive Tit-for-Tat with Growth Adjustment strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == len(history.opponent_actions):
            return Action.D
        total_opponent_cooperation = np.sum(history.opponent_actions[:, -1])
        remaining_stock = self.capacity - history.my_payoffs[-1] / self.n
        adjustment_factor = min(1, max(0, (remaining_stock - self.capacity * 2 / 3) / (self.capacity / self.n)))
        if total_opponent_cooperation >= self.n // 2:
            return Action.C
        else:
            return Action.D if adjustment_factor > 0.5 else Action.C

class Strategy_EXPLOITATIVE_92(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat with Stock Growth Awareness (ATfTA-SG) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = float(self.game_description.capacity)
        self.n_players = self.game_description.n_players
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            if state.round_number == 0:
                return Action.C
            else:
                self.round_number = state.round_number - 1
                history_len = len(history.my_actions)
                if history_len < self.game_description.n_rounds:
                    actions = history.opponent_actions[:, self.round_number]
                    total_cooperators = np.sum(actions)
                    if total_cooperators == self.game_description.n_players:
                        return Action.C
                    elif any(actions):
                        return Action.D
                else:
                    self.round_number = state.round_number
                    actions = history.opponent_actions[:, self.round_number - 1]
                    total_benefit = self._calculate_total_benefit(actions)
                    if total_benefit > 0:
                        return Action.C
                    elif total_benefit < 0:
                        return Action.D
                    else:
                        actions = history.opponent_actions[:, self.round_number]
                        total_cooperators = np.sum(actions)
                        if total_cooperators == self.game_description.n_players or any(actions):
                            return Action.C
                return Action.D
        current_stock = state.current_stock
        if current_stock < self.capacity / self.n_players:
            return Action.D
        else:
            return Action.C

    def _calculate_total_benefit(self, actions):
        """
        Helper function to calculate total benefit based on opponents' actions in the previous round.
        """
        if self.game_description.n_players == 2:
            return -1 if actions[0] else 1
        elif actions.size > 1 and np.sum(actions) != self.game_description.n_players:
            return np.mean(actions) * (self.capacity / self.n_players) - np.max(actions)
        else:
            return 0

class Strategy_EXPLOITATIVE_93(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = self.game_description.n_players
        self.capacity = self.game_description.capacity
        self.cooperative_threshold = self.game_description.n_players // 2
        self.decay_rate = 0.9
        self.cumulative_coop_avg = 0
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or self.round_number == 0:
            return Action.C
        self.round_number += 1
        opponent_cooperated = sum(history.opponent_actions[-1]) >= self.n_players // 2
        self.cumulative_coop_avg = (self.cumulative_coop_avg * self.round_number + opponent_cooperated) / self.round_number
        self.cooperative_threshold = self.decay_rate * self.cooperative_threshold + (1 - self.decay_rate) * self.cumulative_coop_avg
        if not opponent_cooperated and self.cooperative_threshold < random.random():
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_94(BaseStrategy):
    """
    A strategy that mimics Tit-for-Tat but also adapts to the growth of the common pool.
    The strategy starts by cooperating in the first round, then makes decisions based on opponents' past actions.
    If an opponent has cooperated more than defected, it cooperates; otherwise, it defects.
    In case of ties or ambiguity, it chooses to cooperate, favoring the growth of the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros((1, 1)), np.zeros((1, game_description.n_players, 2), dtype=bool), np.zeros((1, game_description.n_players)))
        self.round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros((1, 1)), np.zeros((1, self.game_description.n_players, 2), dtype=bool), np.zeros((1, self.game_description.n_players)))
            self.round = state.round_number
            return Action.C
        if history.opponent_actions[-1].sum() == 0:
            self.history = history
            return Action.D
        elif history.opponent_actions[-1].sum() >= (self.game_description.n_players + 1) // 2:
            self.history = history
            return Action.C
        else:
            self.history = history
            random_decision = random.random()
            return Action(1 if random_decision <= 0.5 else 0)

class Strategy_EXPLOITATIVE_95(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = None
        self.opponent_history = PlayerHistory(my_actions=None, my_payoffs=None, opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros(self.game_description.n_rounds, dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.cooperation_threshold = int(math.ceil(2 * self.game_description.n_players / (self.opponent_history.opponent_actions.shape[0] + 1)))
            return Action.C
        if state.round_number == 0:
            return Action.C
        opponent_cooperation = sum(history.opponent_actions[-1, :])
        overall_cooperation = sum([1 for i in range(state.round_number) if history.my_actions[i] == Action.C.value])
        if opponent_cooperation >= self.cooperation_threshold or float(overall_cooperation) / state.round_number > np.mean(history.opponent_payoffs[:state.round_number]):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_96(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.n_players
        self.current_round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.current_round += 1
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number < self.game_description.n_rounds:
            if history is not None:
                opponent_cooperated = sum(history.opponent_actions[-1])
                if opponent_cooperated >= self.cooperation_threshold:
                    action = Action.C
                elif self.cooperation_threshold > 1:
                    action = Action.D
                else:
                    action = Action.C
                if action == Action.C:
                    self.cooperation_threshold += 1
        else:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_97(BaseStrategy):
    """Adaptive Exploitative Strategy for the Common Pool Resource Game (AES-CPRG)"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = int(math.ceil(game_description.n_rounds * 0.9))
        self.cooperators_count = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return random.choice([Action.C, Action.D])
        current_round = state.round_number - 1
        if current_round >= self.game_description.n_rounds:
            return Action.D
        last_cooperators_count = sum(history.opponent_actions[current_round, :])
        average_cooperators_count = np.mean(self.cooperators_count[-self.k:])
        if last_cooperators_count >= average_cooperators_count:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_98(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFT-SA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.stock_threshold_cooperate = int(self.capacity * 0.3)
        self.stock_threshold_defect = int(self.capacity * 0.5)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.C
        if history is not None:
            cooperators = sum(history.opponent_actions[-1])
            if cooperators < self.n_players:
                action = Action.D
                stock = state.current_stock
                if stock > self.stock_threshold_defect:
                    action = Action.D
                    consumption = stock / (2 * self.n_players)
                elif stock < self.stock_threshold_cooperate:
                    action = Action.C
                    consumption = stock / (2 * self.n_players)
                else:
                    consumption = 0.75 * stock / (2 * self.n_players)
        return action

class Strategy_EXPLOITATIVE_99(BaseStrategy):
    """
    A Tit-for-Tat strategy with Adaptive Cooperation Threshold for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = self.game_description.capacity / game_description.n_players
        self.avg_depletion = np.zeros(game_description.n_rounds)
        self.current_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            total_depletion = np.sum(history.my_payoffs)
            self.avg_depletion[state.round_number] = total_depletion / (state.round_number + 1)
            if self.avg_depletion[-1] > self.game_description.capacity / self.game_description.n_players:
                self.cooperation_threshold *= 1.2
            elif self.avg_depletion[-1] < self.game_description.capacity / (2 * self.game_description.n_players):
                self.cooperation_threshold /= 1.2
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D if self.cooperation_threshold > self.game_description.capacity / self.game_description.n_players else Action.C
        if history is not None and state.round_number < self.game_description.n_rounds - 1:
            return Action.C if self.cooperation_threshold >= self.game_description.capacity / self.game_description.n_players else Action.D

class Strategy_EXPLOITATIVE_100(BaseStrategy):
    """
    Fischer's Tit-for-Tat Strategy (Modified for Common Pool Resource Game)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.last_round = -1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        current_round = state.round_number
        last_round = self.last_round
        opponent_last_action = history.opponent_actions[-1, 0] if history else None
        if current_round == self.game_description.n_rounds:
            return Action.C
        elif current_round > 1 and opponent_last_action == Action.D:
            if not self.last_opponent_action or self.last_opponent_action == Action.C:
                return Action.D
        self.last_round = current_round
        self.last_opponent_action = opponent_last_action
        return self.decide_action(opponent_last_action, current_round)

    def decide_action(self, opponent_last_action: Action | None, current_round: int) -> Action:
        """
        Decide action based on the opponent's last action and the current round number
        """
        if not opponent_last_action:
            return Action.C
        elif current_round == 1:
            return Action.C
        else:
            return Action.C if opponent_last_action == Action.C else Action.D

class Strategy_EXPLOITATIVE_101(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Stock Adaptation (TFT-SA)
    Strategy description: A strategy that cooperates in the first round, then copies its opponent's previous action. If stock becomes too low, it always defects to prevent total depletion of the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = self.game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < self.stock_threshold:
            return Action.D
        last_opponent_action = history.opponent_actions[-1, -1] if history is not None else Action.C
        return (Action.C if last_opponent_action == Action.C else Action.D) if state.round_number != self.game_description.n_rounds else Action.C

class Strategy_EXPLOITATIVE_102(BaseStrategy):
    """
    A strategy that cooperates initially, then adapts its behavior based on the opponent's actions and a dynamic cooperation threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = int(game_description.capacity / 2 * 0.5)
        self.stock_depletion_threshold = math.floor(game_description.capacity * 0.9)
        self.sliding_window_size = 5
        self.average_payoffs = np.zeros((self.sliding_window_size,))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if state.round_number == 0 or not history:
            return Action.C
        opponents_cooperation = sum(history.opponent_actions[-self.sliding_window_size:, :])
        opponent_cooperators = np.sum(opponents_cooperation > 0)
        if opponent_cooperators >= self.cooperative_threshold or state.current_stock < self.stock_depletion_threshold:
            return Action.C
        return Action.D

    def update_average_payoffs(self, payoff: float):
        self.average_payoffs = np.roll(self.average_payoffs, -1)
        self.average_payoffs[-1] = payoff
        return self.average_payoffs

    def update_CT_and_SDT(self, history: PlayerHistory):
        pass

class Strategy_EXPLOITATIVE_103(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)
    Strategy Description: A game theory strategy that cooperates if the average stock level in the last h rounds has been above a certain threshold, and defects otherwise. Punishes defection by temporarily switching to defecting for the next d rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.h = int(math.ceil(game_description.n_rounds * 0.6))
        self.d = int(game_description.n_rounds * 0.2)
        self.S_thresh = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.my_actions) >= self.h:
            avg_stock = np.mean(history.opponent_payoffs[max(0, state.round_number - self.h):state.round_number])
        else:
            return Action.C
        if avg_stock > self.S_thresh and history.opponent_actions[-1][0] or (history.opponent_actions[-1][1] and state.round_number <= self.d):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_104(BaseStrategy):
    """
    Tit-for-Tat Strategy (TFT) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if self._history is None and state.round_number == 0:
            return Action.C
        elif history.my_actions[-1] != state.round_number - 1:
            if history.opponent_actions[-1].sum() < self.game_description.n_players // 2:
                return Action.C
        return Action.D

    def update_history(self, state: CommonPoolState, action: Action) -> None:
        """
        Update the player history with the new state and action taken.
        """
        if self._history is None:
            self._history = PlayerHistory(np.zeros((1, 2)), np.array([0.0]), np.zeros((state.round_number, self.game_description.n_players)), np.zeros((state.round_number, self.game_description.n_players)))
        self._history.my_actions[0] = action == Action.C
        self._history.my_payoffs[-1] = state.current_stock / (2 * self.game_description.n_players) if action == Action.C else state.current_stock / self.game_description.n_players

class Strategy_EXPLOITATIVE_106(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TfT-ACT) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = 0
        self.current_round = 0
        self.opponent_history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.opponent_history = history.opponent_actions
        self.current_round = state.round_number
        cooperative_index = np.mean(self.opponent_history[:, -self.game_description.n_players:])
        cooperative_threshold = min((self.current_round + 1) / self.game_description.n_rounds, 1)
        if state.round_number == 1 or state.current_stock < self.game_description.capacity // (2 * self.game_description.n_players):
            return Action.D
        elif cooperative_index > cooperative_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_107(BaseStrategy):
    """
    Tit-for-Tat Adaptive (TFT-A) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if self.history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        opponent_action = history.opponent_actions[state.round_number - 1, 0]
        return Action(int(opponent_action) if opponent_action is not None else 1)

class Strategy_EXPLOITATIVE_108(BaseStrategy):
    """
    Tit-for-Tat-Greed Strategy (TfttG) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_stock = game_description.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        consumption = np.sum(history.my_actions if history else [Action.D] * state.round_number)
        stock_ratio = consumption / self.initial_stock
        if stock_ratio < (self.game_description.n_players - 1) / (4 * self.game_description.n_players):
            return Action.D
        cooperators = sum(history.opponent_actions[-1] if history else [0] * state.round_number)
        if stock_ratio >= self.initial_stock / 2:
            return Action.C
        elif cooperators >= self.game_description.n_players - 1:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_109(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.capacity / game_description.n_players
        self.history = PlayerHistory(my_actions=None, my_payoffs=None, opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros(game_description.n_rounds * game_description.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        self.history = history or self.history
        if state.round_number == 0:
            return Action.C
        opp_action = self.history.opponent_actions[state.round_number - 1, 0]
        stock_remaining = self.history.my_payoffs[-1] if state.round_number > 0 else state.current_stock
        if opp_action and stock_remaining >= self.cooperation_threshold:
            return Action.C
        if stock_remaining < self.cooperation_threshold:
            self.cooperation_threshold = max(self.cooperation_threshold * 0.95, 1)
        return Action.D

class Strategy_EXPLOITATIVE_110(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-A) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if cooperators >= self.game_description.n_players // 2 and state.round_number != self.game_description.n_rounds:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_111(BaseStrategy):
    """
    The Tit-for-Tat Adaptive (TfTA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            self.last_round = False
            return Action.C
        if state.round_number == self.game_description.n_rounds and (not self.last_round):
            self.last_round = True
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players)
        cooperators = sum(opponent_actions)
        my_action = Action.C if self.last_round or cooperators >= self.game_description.n_players // 2 else Action.D
        self.opponent_history.append(opponent_actions)
        self.last_round = state.round_number == self.game_description.n_rounds
        return my_action

class Strategy_EXPLOITATIVE_112(BaseStrategy):
    """
    The Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and (not self.opponent_history):
            return Action.C
        if self.opponent_history is None:
            self.opponent_history = np.full((state.round_number,), True, dtype=bool)
        last_action = self.opponent_history[-1]
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if last_action:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_113(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        last_opponent_cooperation = sum(history.opponent_actions[-1])
        last_opponent_action = np.where(history.opponent_actions[-1], Action.C, Action.D)
        if state.round_number == len(history.my_payoffs):
            return Action.D
        elif last_opponent_cooperation >= self.game_description.n_players // 2:
            return Action.C
        else:
            return last_opponent_action[0]

class Strategy_EXPLOITATIVE_114(BaseStrategy):
    """
    A simple game theory strategy: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_threshold = 3 * self.game_description.n_players
        self.cooperation_probability = 1.0
        self.defected_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        cooperation = sum(opponent_actions)
        total_players = len(opponent_actions)
        if cooperation == total_players:
            return Action.C
        if not any((action == Action.C for action in opponent_actions)):
            self.defected_rounds += 1
            self.cooperation_probability = max(0, 1 - self.defected_rounds / self.defection_threshold)
        if random.random() < self.cooperation_probability:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_115(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat-with-Adaptation (TFTA)

    This strategy implements the Tit-for-Tat-with-Adaptation game theory strategy for the Common Pool Resource Game.
    It cooperates in the first round and adapts its behavior based on the opponent's previous actions to maximize its own gain while minimizing the opponent's payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.c = int(game_description.n_players // 2)
        self.d = self.c
        self.own_action = Action.C
        self.round_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round_history.append(self.own_action.value)
        self.c, self.d = self.update_thresholds(history, self.c, self.d)
        if self.opponent_cooperated_recently(history):
            self.own_action = Action.C
        elif self.opponent_defected_recently(history):
            self.own_action = Action.D
        else:
            self.own_action = self.opponent_last_action(history)
        return self.own_action

    def update_thresholds(self, history: PlayerHistory, c: int, d: int) -> tuple[int, int]:
        if len(self.round_history) > self.c + self.d:
            cooperators = sum(self.round_history[-self.c:])
            defectors = sum(self.round_history[-self.d:])
            return (max(cooperators, c), max(defectors, d))
        return (c, d)

    def opponent_cooperated_recently(self, history: PlayerHistory) -> bool:
        c_index = self.round_history[-self.c:].count(1)
        return c_index == len(self.round_history[-self.c:])

    def opponent_defected_recently(self, history: PlayerHistory) -> bool:
        d_index = self.round_history[-self.d:].count(0)
        return d_index == len(self.round_history[-self.d:])

    def opponent_last_action(self, history: PlayerHistory) -> Action:
        last_opponent_action = np.mean(history.opponent_actions[:, -1])
        return Action(int(last_opponent_action))

class Strategy_EXPLOITATIVE_117(BaseStrategy):
    """
    A simple Tit-For-Tat-Growth (TFT-G) strategy for the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.average_consumption = np.mean(history.my_payoffs[:-1])
        action = Action.C if self.average_consumption <= self.game_description.n_players // 2 else Action.D
        return action

class Strategy_EXPLOITATIVE_118(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Stock Adaptation (TfTSA).
    A cooperative strategy that mimics opponent's actions from the previous round, while encouraging cooperation and
    adapting resource consumption when necessary to maintain a sustainable stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(math.floor((game_description.capacity - 2 * game_description.n_players + 10) / game_description.n_players))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_action = history.opponent_actions[last_round, -1]
        current_stock = state.current_stock
        if last_round == 0 or current_stock >= self.game_description.capacity:
            return Action.C
        elif last_action and current_stock < self.threshold:
            return Action.D
        elif not last_action and current_stock >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_120(BaseStrategy):
    """
    A strategy that employs a gradual cooperation approach based on the classic Tit-for-Tat strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity
        self.n_players = self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 2 * self.n_players:
            return Action.D
        pc = min(1, max(0, 2 * current_stock / self.capacity - 1))
        opponent_cooperated_last_round = np.mean(history.opponent_actions[-1]) >= 0.5
        return Action(int(pc > random.random()) if opponent_cooperated_last_round else int(not pc > random.random()))

class Strategy_EXPLOITATIVE_121(BaseStrategy):
    """
    A Tit-for-Tat strategy for the Common Pool Resource Game, exhibiting an exploitative mindset.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_period = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) < self.game_description.n_players * self.punishment_period:
            return Action.C
        num_consecutive_defections = sum(history.opponent_actions[-self.punishment_period:, :].flatten() == Action.D)
        if num_consecutive_defections >= self.punishment_period:
            return Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_122(BaseStrategy):
    """
    Tit-for-Tat with Growth Adaptation (TfT-GA) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.min_threshold = self.capacity // 2
        self.max_threshold = 3 * self.capacity // 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0:
            return action
        stock = state.current_stock
        if history is not None:
            last_opponent_action = history.opponent_actions[-1, -1]
            if last_opponent_action == Action.D and stock < self.min_threshold or (last_opponent_action == Action.C and stock >= self.max_threshold):
                action = last_opponent_action
        if state.round_number == self.game_description.n_rounds - 1:
            action = self.optimal_action(stock)
        return action

    def optimal_action(self, stock):
        if stock > self.capacity * 3 / 4:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_123(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock-Aware Cooperation (ATTC-SA) strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = math.floor(game_description.n_players / 2)
        self.punishment_threshold = self.cooperative_threshold * 2
        self.stock_threshold = game_description.capacity // (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        opponent_actions = [action for round in history.opponent_actions for action in round]
        cooperators = sum(opponent_actions)
        current_stock = state.current_stock
        if cooperators > self.punishment_threshold and current_stock > self.stock_threshold:
            return Action.C
        elif sum([action == Action.D for action in opponent_actions[-self.cooperative_threshold - self.punishment_threshold:-1]]) > self.cooperative_threshold or current_stock <= self.stock_threshold:
            return Action.D
        elif cooperators > 0:
            return Action.C if history.my_actions[-1] == Action.D else Action.D
        return Action.C

class Strategy_EXPLOITATIVE_125(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Growth (TfT-AG) strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / (2 * game_description.n_players)
        self.growth_factor = 0.5 * (game_description.capacity - 2 * game_description.n_players) / (game_description.n_players * (game_description.n_rounds - 1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < self.stock_threshold:
            return Action.D
        growth = 2 * state.current_stock * (1 - state.current_stock / self.game_description.capacity)
        last_round = history and len(history.opponent_actions) > 0 and (state.round_number == history.my_actions.size - 1)
        if not last_round:
            last_growth = growth
        else:
            last_growth = history.opponent_payoffs[-1, history.my_index] / state.current_stock
        if last_growth <= self.growth_factor:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_126(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFTSA) strategy for the Common Pool Resource Game.
    The agent cooperates initially and mimics opponent's behavior in subsequent rounds while handling edge cases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = np.zeros((self.game_description.n_rounds, 1), dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.opponent_history = np.roll(self.opponent_history, -1)
        self.opponent_history[-1] = history.opponent_actions[state.round_number - 1, 0] if history else False
        if state.round_number == self.game_description.n_rounds:
            if np.mean(self.opponent_history) >= (self.game_description.n_players + 1) / 2:
                return Action.C
            return Action.D
        if np.all(self.opponent_history == self.opponent_history[-1]):
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_127(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_history = np.zeros(self.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        self.stock_history = np.roll(self.stock_history, -1)
        self.stock_history[-1] = state.current_stock / self.capacity if state.current_stock > 0 else 0
        cooperators_in_last_round = sum(history.opponent_actions[-1, :])
        my_action = Action.C if cooperators_in_last_round >= self.n_players // 2 and state.current_stock / self.capacity > np.mean(self.stock_history) or state.round_number == self.game_description.n_rounds - 1 else Action.D
        return my_action

class Strategy_EXPLOITATIVE_128(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = self.game_description.n_players
        self.r = self.game_description.n_rounds
        self.capacity = self.game_description.capacity
        self.m = math.ceil(self.r * 0.1)
        self.cooperation_threshold = self.capacity * self.n / (2 * self.n + self.m)
        self.mode = 'Cooperative'
        self.average_consumption = np.zeros(self.r, dtype=np.float64)
        self.total_consumption = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        action = Action.C if state.round_number == 0 else self._get_action(state, history)
        return action

    def _get_average_consumption(self, total_consumption, number_of_players):
        if len(self.average_consumption) < self.m:
            self.average_consumption[-1] = total_consumption / number_of_players
        else:
            self.total_consumption += total_consumption
            self.average_consumption = (self.total_consumption + self.average_consumption * (self.m - 1)) / self.m
        return self.average_consumption[-1]

    def _get_action(self, state: CommonPoolState, history: PlayerHistory):
        if state.round_number == 0 or state.current_stock > self.cooperation_threshold:
            action = Action.C
        elif self.mode == 'Cooperative' and self._get_average_consumption(history.my_payoffs[-1], self.n) > self.cooperation_threshold:
            action = Action.C
        elif self.mode == 'Defective' and self._get_average_consumption(history.my_payoffs[-1], self.n) < self.cooperation_threshold:
            action = Action.C
        else:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_129(BaseStrategy):
    """
    Modified Tit-for-Tat Strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == len(history.opponent_actions) and history.my_payoffs[-1] > self.threshold:
            return Action.C
        cooperation, total_consumption = (sum([history.opponent_actions[i][-1] for i in range(len(history.opponent_actions))]), 0)
        for action in history.opponent_actions:
            total_consumption += np.sum(2 * action[:-1] + action[-1])
        if cooperation >= self.game_description.n_players - 1 and state.current_stock > self.threshold:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_132(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = self.game_description.n_players
        self.adaptation_factor = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            total_consumption = np.sum(history.my_payoffs)
            capacity = self.game_description.capacity
            if total_consumption < capacity:
                self.cooperation_threshold -= 1
            else:
                self.cooperation_threshold += 1
        current_average_consumption = np.mean(history.opponent_payoffs[-self.game_description.n_rounds + 1:-1])
        if current_average_consumption < self.cooperation_threshold:
            return Action.C
        return Action.D

    def moving_average(self, data: NDArray[np.float64]):
        return np.mean(data)

    def update_history(self, action: Action, round_number: int):
        pass

    def recent_cooperation_trend(self):
        pass

    def recent_defection_trend(self):
        pass

class Strategy_EXPLOITATIVE_133(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = np.mean([game_description.n_players] * game_description.n_rounds)
        self.alpha = 0.1
        self.beta = 0.9

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number < self.game_description.n_rounds:
            t = (round_number - 1) % self.game_description.n_rounds
            coop_ratio = np.sum(history.opponent_actions[t, :]) / self.game_description.n_players
            self.cooperative_threshold = self.beta * self.cooperative_threshold + self.alpha * coop_ratio
        elif round_number == self.game_description.n_rounds:
            if np.sum(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2:
                return Action.C
        return Action.C if self.cooperative_threshold > (self.game_description.n_players - 1) / 2 else Action.D

class Strategy_EXPLOITATIVE_134(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round = 0
        self.opponent_history = np.zeros((1, self.game_description.n_players), dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.opponent_history = np.roll(self.opponent_history, -1, axis=0)
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            last_opponent_action = self.opponent_history[-1, -1]
            if last_opponent_action:
                return Action.C
            else:
                return Action.D
        else:
            last_opponent_action = self.opponent_history[-1, -1]
            if last_opponent_action:
                return Action.C
            elif self.game_description.n_rounds - self.round < self.game_description.n_players // 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_135(BaseStrategy):
    """
    Strategy that implements the Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy in Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.forgiveness_allowed = True if game_description.n_rounds > 2 * self.n_players else False

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        round_number = state.round_number
        opponent_actions = history.opponent_actions[-1] if round_number > 0 else None
        if round_number == 0:
            return Action.C
        if opponent_actions is not None and opponent_actions[0]:
            return Action.C
        elif opponent_actions is not None and (not opponent_actions[0]) and self.forgiveness_allowed:
            return Action.C
        elif opponent_actions is not None and (not opponent_actions[0]) and (not self.forgiveness_allowed):
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_136(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TfT-ACT) strategy in Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.t_coop = 0
        self.t_defect = 0
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        t_coop_local = np.sum(history.my_actions if history else np.zeros((self.game_description.n_rounds, self.n_players), dtype=np.bool))
        t_defect_local = np.sum(1 - history.my_actions if history else np.zeros((self.game_description.n_rounds, self.n_players), dtype=np.bool))
        if t_coop_local > t_defect_local:
            self.t_coop = t_coop_local
            self.t_defect = t_defect_local
            return Action.C
        elif t_coop_local <= t_defect_local:
            p = 0.5 + (np.sum(history.my_actions * history.my_actions[-1, :]) - np.sum((1 - history.my_actions) * history.my_actions[-1, :])) / self.n_players
            if state.round_number == self.game_description.n_rounds:
                return Action.D
            elif t_coop_local == t_defect_local:
                return Action(int(random.random() < p))
        if self.t_coop == 0 or t_defect_local > t_coop_local:
            self.t_coop = max(self.t_coop + 1, 1)
            self.t_defect = min(self.t_defect, t_defect_local)
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_137(BaseStrategy):
    """
    A class representing the Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for the Common Pool Resource Game.
    The strategy cooperates initially, then adapts its actions based on opponents' past behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.strategy = [Action.C] * (game_description.n_rounds + 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return self.strategy[state.round_number]
        round_num = state.round_number - 1
        last_action = self.strategy[round_num]
        cooperators = sum(history.opponent_actions[round_num, :])
        if last_action == Action.C and cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif last_action == Action.D and cooperators < self.game_description.n_players // 2:
            return Action.C
        return self.strategy[state.round_number]

class Strategy_EXPLOITATIVE_138(BaseStrategy):
    """
    Implementation of the Tit-for-Tat strategy for the Common Pool Resource Game.
    Cooperate in the first round, mimic opponent's action from the previous round, but punish defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        last_opponent_action = history.opponent_actions[-1][-1] if len(history.opponent_actions) > 0 else None
        if last_opponent_action is not None:
            return Action(last_opponent_action) if last_opponent_action == 1 else Action.D
        return Action.C

class Strategy_EXPLOITATIVE_139(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT)
    Strategy Description: This strategy cooperates initially and responds to the opponent's actions, punishing defections while being forgiving towards opponents that switch back to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = math.floor(game_description.n_players / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        if np.all(history.opponent_actions[-1] == 1):
            return Action.C
        last_defection = np.argmax(np.where(history.opponent_actions != 1, state.round_number, -1)) + 1
        if last_defection == len(history.opponent_actions) - 1:
            return Action.D
        rounds_since_last_cooperation = len(history.opponent_actions) - last_defection - 1
        if rounds_since_last_cooperation > self.threshold:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_140(BaseStrategy):
    """
    A Tit-for-Tat strategy with stock adaptation that builds trust while punishing defections.
    It adapts its actions based on the stock level to avoid exploitation and encourage cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity
        self.n_players = self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.current_stock == 0 or state.current_stock > self.capacity:
            if history.opponent_actions[-1][-1] == Action.C:
                return Action.C
            else:
                return Action.D
        if state.round_number >= len(history.my_actions):
            pass
        last_action = history.opponent_actions[-1][-1]
        if last_action == Action.C:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_141(BaseStrategy):
    """
    A strategy that uses Adaptive Tit-for-Tat in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round = 0
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.round += 1
        if history is not None:
            last_round = len(history.opponent_actions) - 1
            self.last_opponent_action = history.opponent_actions[last_round, :].mean()
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        elif not self.last_opponent_action:
            if state.round_number != self.game_description.n_rounds:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_142(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players, self.n_rounds, self.capacity = (game_description.n_players, game_description.n_rounds, game_description.capacity)
        self.k, self.t = (3, int(self.game_description.n_players * 0.6))
        self.coop_history, self.avg_coop, self.threshold = (np.zeros((self.k,), dtype=np.int8), 0, self.t)
        self.last_round = -1

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.last_round += 1
        self.coop_history[self.last_round % self.k] = int(history.opponent_actions[self.last_round, 0])
        self.avg_coop = np.mean(self.coop_history[-self.k:])
        if history is not None and self.last_round < self.n_rounds - 1:
            if self.avg_coop > self.threshold:
                return Action.C
            elif self.avg_coop >= self.t // 2:
                self.threshold += int(self.game_description.n_players * 0.1)
            elif self.avg_coop <= (self.t - self.game_description.n_players) // 2:
                self.threshold -= int(self.game_description.n_players * 0.1)
        return Action.D if history is not None and self.last_round == self.n_rounds - 1 else Action.C

class Strategy_EXPLOITATIVE_143(BaseStrategy):
    """
    A simple adaptive cooperation strategy that mimics its opponent's last action: cooperate if the opponent cooperated in the last round, defect otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self._last_opponent_action = np.mean(history.opponent_actions[-1])
        if self._last_opponent_action:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_144(BaseStrategy):
    """
    Tit-for-Tat with Stock Growth Adjustment (TfT-SGA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity / game_description.n_players
        self.stock_growth_threshold = self.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action_history = history.opponent_actions if history else np.zeros((1, self.game_description.n_players), dtype=np.bool_)
        previous_opponent_action = opponent_action_history[-1, -1]
        if previous_opponent_action:
            return Action.C
        stock_growth = self.calculate_stock_growth(previous_opponent_action, state.round_number)
        if stock_growth > self.stock_growth_threshold:
            return Action.C
        else:
            return Action.D

    def calculate_stock_growth(self, opponent_cooperated: bool, round_number: int) -> float:
        if opponent_cooperated:
            total_consumption = self.game_description.n_players * (1 - round_number) / 2
        else:
            total_consumption = self.game_description.n_players * round_number
        current_stock = max(0, self.game_description.capacity - total_consumption)
        stock_remaining = min(current_stock, self.capacity)
        growth = 2 * stock_remaining * (1 - stock_remaining / self.capacity)
        return growth

class Strategy_EXPLOITATIVE_145(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-CT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.p = 10
        self.t = self.game_description.n_players // 2
        self.last_p_rounds = np.zeros((self.p, 2), dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        if state.round_number >= self.n_rounds:
            return Action.C
        self.last_p_rounds = np.roll(self.last_p_rounds, -1)
        self.last_p_rounds[-1, int(history.my_actions[-1])] = 1
        cooperation_level = np.mean(self.last_p_rounds[:, 1])
        if cooperation_level > self.t:
            return Action.C
        else:
            return Action.D

    def update_threshold(self, opponent_cooperators):
        """
        Adaptively adjust the cooperation threshold based on the opponent's behavior.

        Parameters:
            opponent_cooperators (int): The number of opponents who cooperated in the most recent round.
        """
        self.t += 1 if opponent_cooperators >= self.n_players // 2 else -1
        self.t = max(self.t, self.game_description.n_players // 4)
        self.t = min(self.t, int(3 * self.n_players / 4))

class Strategy_EXPLOITATIVE_146(BaseStrategy):
    """
    A Tit-for-Tat strategy for the Common Pool Resource Game.
    Cooperates in the first round and mirrors the opponent's action from the previous round thereafter,
    except in the last round where it cooperates regardless of the opponent's move.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and self.last_round):
            return Action.C
        opponent_action = np.mean(history.opponent_actions[:, -1]) if history is not None else None
        if opponent_action is not None and state.round_number < self.game_description.n_rounds:
            self.last_round = False
            return Action(int(opponent_action))
        self.last_round = True
        return Action.C

class Strategy_EXPLOITATIVE_147(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = self.game_description.capacity / (2 * game_description.n_players)
        self.forgiveness_factor = 0.5
        self.average_coop_reward = 0.0
        self.average_defect_reward = 0.0
        self.cooperative_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        stock = state.current_stock
        my_actions = history.my_actions[-1] if history else np.zeros(self.game_description.n_rounds, dtype=bool)
        current_round = state.round_number
        if current_round == 1:
            action = Action.C
        elif stock > self.cooperative_threshold:
            action = Action.C
            self.average_coop_reward += stock / (2 * self.game_description.n_players)
        elif stock <= self.cooperative_threshold and len(self.cooperative_history) > 1:
            action = Action.C
            self.forgiveness_factor *= 0.8
        elif stock <= self.cooperative_threshold:
            action = Action.D
            self.average_defect_reward += stock / self.game_description.n_players
        if current_round > 1:
            self.adjust_cooperation_threshold()
        if action == Action.C:
            self.cooperative_history.append(current_round)
        return action

    def adjust_cooperation_threshold(self):
        total_rewards = self.average_coop_reward + self.average_defect_reward
        cooperation_probability = self.average_coop_reward / total_rewards if total_rewards > 0 else 1
        self.cooperative_threshold *= cooperation_probability

class Strategy_EXPLOITATIVE_148(BaseStrategy):
    """
    A strategy that follows the Tit-for-Tat-Growth (TfT-G) approach in the Common Pool Resource Game.
    This strategy maintains a "trust level" based on previous opponent behavior and adjusts its actions accordingly:
        - If the opponent cooperated in the last round, TfT-G cooperates back.
        - If the opponent defected in the last round, TfT-G defects in response to punish the opponent for their previous action but with a growth component that encourages reconciliation: if the stock level is more than half the capacity (i.e., stock > capacity/2), TfT-G defects; otherwise, it cooperates.
        - In the first round, TfT-G always cooperates to initiate cooperation and avoid depleting the common resource unnecessarily.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.trust_level = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            last_opponent_action = history.opponent_actions[-1][-1]
            if len(history.opponent_actions) > 1:
                stock_level = state.current_stock / self.game_description.capacity
                if stock_level > 0.5 and last_opponent_action == Action.D:
                    self.trust_level -= 0.1
                elif last_opponent_action == Action.C:
                    self.trust_level += 0.2
                else:
                    self.trust_level = max(self.trust_level - 0.1, 0.0)
            else:
                self.trust_level = 0.0
        action = Action.C if self.trust_level > 0.5 else Action.D
        return action

class Strategy_EXPLOITATIVE_149(BaseStrategy):
    """
    A strategy that cooperates in the first round and adapts its cooperation based on the average cooperation ratio of opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.cooperation_ratio = 0.0
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not self.history:
            self.history = history
            return Action.C
        if state.round_number == len(self.history.opponent_actions) - 1:
            self.cooperation_ratio = self.average_cooperation_ratio()
            return self.decide_action()
        self.history = history
        return self.decide_action()

    def average_cooperation_ratio(self):
        cooperation_count, total_rounds = (0, len(self.history.opponent_actions))
        for round in range(total_rounds):
            if sum(self.history.opponent_actions[round]) >= self.game_description.n_players // 2:
                cooperation_count += 1
        return cooperation_count / total_rounds

    def decide_action(self) -> Action:
        if self.cooperation_ratio > self.threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_151(BaseStrategy):
    """
    A Tit-for-Tat Adaptive strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.opponent_history = history.opponent_actions
            opponent_last_action = self.opponent_history[-1]
            if np.count_nonzero(opponent_last_action) > len(opponent_last_action) // 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_152(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = self.game_description.n_rounds * 10 / 100
        self.current_round = 0
        self.opponent_average_cooperation = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.current_round += 1
        if state.round_number == 0:
            return Action.C
        if history is not None and self.current_round > self.game_description.n_rounds * 0.1:
            self.cooperation_threshold = max(self.cooperation_threshold, 40)
        if self.cooperation_threshold > 50:
            cooperators = sum(history.opponent_actions[-self.game_description.n_rounds + 1:-1])
            if cooperators >= math.ceil(self.game_description.n_players * self.cooperation_threshold / 100):
                return Action.C
        return Action.D

    def update_opponent_average_cooperation(self, opponent_actions: NDArray[np.bool_]):
        self.opponent_average_cooperation = np.mean(opponent_actions)

class Strategy_EXPLOITATIVE_153(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_ct = (self.num_players - 1) / 2
        self.cooperative_threshold = self.initial_ct
        self.decay_rate = 0.95
        self.adaptation_factor = 0.2
        self.past_opponent_cooperation_average = [self.initial_ct for _ in range(self.n_rounds)]
        self.current_round_cooperators = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.n_rounds:
            return self.choose_action(state, history)
        if history is not None and history.opponent_actions is not None:
            self.current_round_cooperators = sum(history.opponent_actions[-1])
        new_ct = self.cooperative_threshold + self.adaptation_factor * (self.current_round_cooperators - np.mean(self.past_opponent_cooperation_average))
        self.cooperative_threshold = max(min(new_ct, 1 - (1 - self.decay_rate) ** state.round_number), self.initial_ct)
        return Action.C if self.current_round_cooperators >= math.floor(self.cooperative_threshold * self.num_players) else Action.D

class Strategy_EXPLOITATIVE_154(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = self.game_description.n_players
        self.capacity = self.game_description.capacity
        self.T = 3
        self.round_counter = 0
        self.cooperation_counter = 0
        self.opponent_history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.C
        self.round_counter += 1
        if self.round_counter == 1 or len(self.opponent_history) < self.T:
            action = Action.C
        elif len(self.opponent_history) >= self.T and sum(self.opponent_history[-self.T:, -1]) > self.n - self.T:
            action = Action.D
        else:
            self.cooperation_counter += 1
            if self.cooperation_counter >= len(self.opponent_history) - self.T:
                action = Action.D
            else:
                action = Action.C
        if self.round_counter < self.game_description.n_rounds:
            self.opponent_history = np.vstack((self.opponent_history, [action])) if self.opponent_history is not None else np.array([[action]])
        return action

class Strategy_EXPLOITATIVE_155(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Forgiveness (TfTAF) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.t_f = 4
        self.round_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.D
        round_number = state.round_number
        if history is not None:
            self.round_history.append(round_number)
            last_action = history.opponent_actions[-1][0] if len(history.opponent_actions) > 0 else Action.C
            if round_number - self.t_f >= 2 and last_action == Action.D:
                action = Action.D
            elif len(self.round_history) > self.t_f and (round_number - self.round_history[-self.t_f] < self.t_f or last_action == Action.C):
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_156(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_length = self.game_description.n_rounds // 2
        self.cooperation_threshold = self.history_length // 2
        self.history = np.zeros((self.history_length + 1,), dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self._update_history(history)
        if state.round_number == 0:
            return Action.C
        cooperators = sum(self.history[-self.history_length:])
        return Action(cooperators > self.cooperation_threshold)

    def _update_history(self, history: PlayerHistory):
        for action in history.my_actions:
            self.history[len(self.history) - 1] = action

class Strategy_EXPLOITATIVE_157(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

    This strategy demonstrates cooperation initially, but responds to uncooperative opponents harshly.
    It adapts its cooperation based on the total defections in the last n/2 rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defections = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.opponent_defections = sum(history.opponent_actions[state.round_number - 1, :] == Action.D)
        if self.opponent_defections <= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_158(BaseStrategy):
    """
    Tit-for-Tat strategy for Common Pool Resource Game.
    Adapted from the original Tit-for-Tat strategy by Axelrod (1984).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.opponent_actions) == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= len(self.opponent_actions) // 2:
            self.opponent_actions.append(Action.C)
            return Action.C
        else:
            self.opponent_actions.append(Action.D)
            return Action.D

class Strategy_EXPLOITATIVE_159(BaseStrategy):
    """
    A strategy that mimics the Tit-for-Tat game in the Common Pool Resource Game. It cooperates initially and responds to defection with defection, but also cooperates when opponents are also cooperative. If the stock level is below a threshold value in the last round or if there's no history available, it will defect to deplete as much of the remaining resource as possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == 1:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        opponent_defection = sum(history.opponent_actions[last_round])
        if opponent_defection == self.game_description.n_players:
            return Action.D
        player_action = Action.C if all(history.opponent_actions[last_round]) else Action.D
        return player_action

    def last_round_defect(self, state: CommonPoolState, history: PlayerHistory) -> bool:
        if state.round_number == self.game_description.n_rounds and state.current_stock < self.stock_threshold:
            return True
        return False

    def last_round_cooperate(self, state: CommonPoolState, history: PlayerHistory) -> bool:
        if state.round_number == self.game_description.n_rounds and state.current_stock >= self.stock_threshold:
            return True
        return False

class Strategy_EXPLOITATIVE_160(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = self.game_description.n_players
        self.n_rounds = self.game_description.n_rounds
        self.capacity = self.game_description.capacity
        self.T = self.capacity / (2 * self.n_players)
        self.M = 0.6
        self.cumulative_consumption = 0.0
        self.current_cooperation_rate = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.C
        self.cumulative_consumption += (state.current_stock - self.capacity) * (2 * state.current_stock / self.capacity)
        self.current_cooperation_rate = self.cumulative_consumption / ((self.game_description.n_rounds - 1) * (2 * self.n_players))
        if state.round_number < self.game_description.n_rounds:
            if self.current_cooperation_rate > self.M:
                self.T *= 1.05
            elif self.current_cooperation_rate < self.M / 2:
                self.T *= 0.95
        if state.round_number != self.game_description.n_rounds and history is not None and (state.current_stock <= self.capacity * self.T):
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_161(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat-Growth (TfT-G)
    Strategy Description: This strategy cooperates when the remaining stock level and its growth potential are abundant, and defends against excessive consumption from opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = min(game_description.capacity, 2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        average_consumption = np.mean(history.my_actions[-self.game_description.n_rounds + 1:-1])
        if state.round_number == self.game_description.n_rounds - 1 or history.my_payoffs[-1] == 0:
            return Action.D
        elif state.current_stock < self.stock_threshold:
            return Action.D
        elif average_consumption >= self.stock_threshold / self.game_description.n_players:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_162(BaseStrategy):
    """
    A strategy that cooperates initially, and adjusts cooperation based on the current stock level and opponent's actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperate_threshold = 0.5
        self.punish_rate = 0.1
        self.stock_growth_multiplier = 1 + (self.game_description.capacity - 2 * game_description.n_players) / self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        punishment_rate = max(0, (self.cooperate_threshold - stock_level) * self.punish_rate)
        cooperate_probability = self.cooperate_threshold - punishment_rate
        opponent_cooperated_last_round = sum(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2
        if stock_level < 0.1:
            cooperate_probability *= 0.5
        elif stock_level > 0.9:
            cooperate_probability += 0.2
        return np.random.choice([Action.C, Action.D], p=[cooperate_probability, 1 - cooperate_probability]) if not opponent_cooperated_last_round else Action.C

class Strategy_EXPLOITATIVE_163(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy that cooperates initially and adjusts cooperation based on opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = int(math.ceil(game_description.n_players / 2))
        self.r_threshold = math.floor(game_description.n_rounds * 0.8)
        self.limit = math.floor(self.r_threshold * 0.5)

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        action = Action.C
        if state.round_number == 0 or len(history.opponent_actions) < self.game_description.n_rounds:
            return action
        opponent_action = history.opponent_actions[-1][int(self.__class__)]
        if opponent_action:
            action = Action.C
        else:
            consecutive_defections = sum(map(lambda x: int(x) == Action.D, history.opponent_actions[-self.limit:-1][int(self.__class__)]))
            if consecutive_defections < self.limit:
                action = Action.D
            elif consecutive_defections == self.limit and self.game_description.n_rounds - state.round_number > self.r_threshold:
                if np.min(history.opponent_actions[-self.limit:-1][int(self.__class__)]) >= self.cooperation_threshold:
                    action = Action.C
            elif consecutive_defections > self.limit and self.game_description.n_rounds - state.round_number > self.r_threshold:
                if np.max(history.opponent_actions[-self.limit:-1][int(self.__class__)]) <= self.cooperation_threshold - 1:
                    action = Action.C
            else:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_164(BaseStrategy):
    """
    A strategy that cooperates initially and adapts its cooperation threshold based on opponents' past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = 0.5
        self.average_cooperation_rate = 0.0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        opponent_cooperators = sum(opponent_actions)
        self.average_cooperation_rate += opponent_cooperators / self.game_description.n_players if state.round_number > 0 else 0
        self.cooperative_threshold = 0.5 + opponent_cooperators / self.game_description.n_players * 0.5
        return Action.C if self.average_cooperation_rate > self.cooperative_threshold else Action.D

class Strategy_EXPLOITATIVE_165(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Cooperation Threshold (TfT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = None
        self.average_coop_history = np.zeros(game_description.n_rounds)
        self.last_stock = 0.0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        self.last_stock = current_stock
        if not self.cooperation_threshold:
            self.cooperation_threshold = self._get_initial_coop_threshold(current_stock)
        cooperators = sum([action for action in history.opponent_actions[-1] if action])
        average_coop_history = np.add(self.average_coop_history, [float(cooperators) / len(history.opponent_actions)])
        self.average_coop_history = np.delete(self.average_coop_history, 0)
        average_coop_level = np.mean(self.average_coop_history)
        if current_stock > self.game_description.capacity / (2 * self.game_description.n_players):
            self.cooperation_threshold = self._get_initial_coop_threshold(current_stock)
        else:
            self.cooperation_threshold = current_stock / self.game_description.n_players
        if average_coop_level > 0.5 and cooperators >= math.ceil(self.game_description.n_players * average_coop_level):
            return Action.C
        return Action.D

    def _get_initial_coop_threshold(self, current_stock: float) -> float:
        if current_stock < self.game_description.capacity / (2 * self.game_description.n_players):
            return self.game_description.capacity / (2 * self.game_description.n_players)
        return current_stock / self.game_description.n_players

class Strategy_EXPLOITATIVE_166(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-A)

    This strategy employs a reciprocal approach, cooperating in the first round and adapting to opponents' actions in subsequent rounds.
    It encourages cooperation by punishing defection and rewards long-term success.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        opponent_cooperated_last_round = sum(history.opponent_actions[last_round, :]) >= self.game_description.n_players // 2
        if opponent_cooperated_last_round:
            pass_two_defects = history.my_actions[last_round - 1] == Action.D and history.opponent_actions[last_round - 2, self.__class__.__name__ % 'Player'] == Action.D
            if not pass_two_defects:
                return Action.C
        else:
            pass_two_cooperates = history.my_actions[last_round - 1] == Action.C and history.opponent_actions[last_round - 2, self.__class__.__name__ % 'Player'] == Action.C
            if not pass_two_cooperates:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        self.history.my_actions[state.round_number] = [history.my_actions[state.round_number - 1][i] == Action.C for i in range(self.game_description.n_players)]
        self.history.my_payoffs[state.round_number] = self.history.current_stock[state.round_number] / (2 * self.game_description.n_players) if history.my_actions[state.round_number] == Action.C else self.history.current_stock[state.round_number] / self.game_description.n_players
        self.history.opponent_actions[state.round_number, :] = [history.opponent_actions[state.round_number - 1][i] == Action.C for i in range(self.game_description.n_players)]

class Strategy_EXPLOITATIVE_168(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy.
    This strategy cooperates initially and follows a tit-for-tat approach, but with an adaptive cooperation threshold to exploit opponents who may deviate from cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 2 * game_description.n_players / game_description.n_rounds
        self.cumulative_cooperation = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        self.cumulative_cooperation += np.sum(opponent_actions)
        if self.cumulative_cooperation > self.cooperation_threshold:
            self.cooperation_threshold *= 0.95
            action = Action.D
        else:
            action = Action.C
        if state.current_stock < 2 * self.game_description.n_players:
            return action
        return action

class Strategy_EXPLOITATIVE_170(BaseStrategy):
    """
    A Tit-for-Tat strategy with an adaptive cooperation threshold.
    It cooperates when all opponents have cooperated in the previous round, and defects otherwise.
    The cooperation threshold allows for some initial defections before considering an opponent as uncooperative.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_CT = int(math.floor(game_description.n_players / 2))
        self.current_CT = self.initial_CT

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_cooperated = sum(history.opponent_actions[-1]) >= self.current_CT
        count_defectors = len([b for b in history.opponent_actions[-1] if not b])
        if opponents_cooperated:
            return Action.C
        elif count_defectors >= self.current_CT:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            payoff_from_defection = state.current_stock / self.game_description.n_players * (self.game_description.capacity - state.current_stock) if state.current_stock > 0 else 0
            payoff_from_cooperation = state.current_stock / (2 * self.game_description.n_players)
            return Action.D if payoff_from_defection > payoff_from_cooperation else Action.C
        updated_CT = self.current_CT + (1 if count_defectors < self.initial_CT else min(self.game_description.n_players, self.current_CT * 2))
        self.current_CT = min(updated_CT, self.game_description.n_players)
        return Action.D if count_defectors >= self.current_CT else Action.C

class Strategy_EXPLOITATIVE_171(BaseStrategy):
    """
    A simple exploitative strategy, Greedy Tit-for-Tat (GTFT). It aims to maximize payoff by being cooperative when it benefits long-term gains and punishing opponents who don't reciprocate cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.minimum_cooperators = math.ceil(game_description.n_players / 2) - 1
        self.punishment_threshold = math.floor(game_description.capacity / (4 * game_description.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[:, -1])
        if cooperators >= self.minimum_cooperators and state.current_stock > self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.C
        elif history.opponent_actions[-1, -1] == Action.D:
            return Action.D
        else:
            return Action.C if state.round_number < self.game_description.n_rounds // 2 else Action.D
        if state.current_stock <= self.punishment_threshold:
            return Action.D

class Strategy_EXPLOITATIVE_172(BaseStrategy):
    """
    Tit-for-Tat Strategy (TFT) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.empty((1, 1), dtype=bool), my_payoffs=np.empty((1,), dtype=np.float64), opponent_actions=None, opponent_payoffs=None)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.history = history
        if state.round_number == 0:
            return Action.C
        else:
            last_opponent_action = self.history.opponent_actions[-1, -1]
            return Action(last_opponent_action)

class Strategy_EXPLOITATIVE_173(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.F = int(math.ceil(game_description.n_rounds * 0.5))
        self.cooperation_threshold = game_description.capacity / (2 * game_description.n_players)
        self.average_consumption = np.zeros(self.F)
        self.adjustment_factor = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > self.F:
            average_consumption = np.mean(history.opponent_actions[:, -self.F:]) * (1 / self.F)
            self.average_consumption = self.average_consumption[-self.F:] + average_consumption
            self.adjustment_factor = 0.01 * (average_consumption - self.cooperation_threshold)
            self.cooperation_threshold *= math.pow(1 + self.adjustment_factor, state.round_number)
        if np.mean(history.opponent_actions[:, -self.F:]) < self.cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_174(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-CT) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.h = int(math.sqrt(self.game_description.n_players * self.game_description.n_rounds))
        self.cooperation_threshold = self.game_description.capacity / (2 * self.game_description.n_players * self.game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            stock = state.current_stock
            average_stock = self.cooperation_threshold * (stock / self.game_description.capacity) if state.round_number == 0 else self.cooperation_threshold
            return Action.C if average_stock > 0.5 else Action.D
        opponent_cooperators = sum(history.opponent_actions[-self.h:, :].sum(axis=0))
        average_stock = opponent_cooperators / self.h * (state.current_stock / self.game_description.capacity)
        return Action.C if average_stock > self.cooperation_threshold else Action.D

class Strategy_EXPLOITATIVE_175(BaseStrategy):
    """
    A strategy that cooperates in the first round and subsequently mirrors the opponent's action from the previous round.
    If the opponent defected, this strategy will defect in response. This encourages cooperation but also enables retaliation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if len(self.opponent_history) == 0:
            return Action.C
        if state.round_number < self.game_description.n_rounds - 1:
            opponent_action = history.opponent_actions[-1, 0]
            self.opponent_history.append(opponent_action)
            if opponent_action:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_177(BaseStrategy):
    """Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_payoff = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_opponent_actions = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=np.bool_)
        cooperators = sum(last_opponent_actions)
        if cooperators >= self.game_description.n_players // 2:
            self.total_payoff += np.sum(history.my_payoffs)
            return Action.C
        self.total_payoff -= np.mean(history.my_payoffs)
        return Action.D

    def last_round(self) -> bool:
        return self.state.round_number == self.game_description.n_rounds

    def is_exploitative(self) -> bool:
        return True

class Strategy_EXPLOITATIVE_178(BaseStrategy):
    """Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CT_init = self.game_description.capacity / (2 * self.game_description.n_players)
        self.rounds_left = self.game_description.n_rounds - 1
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if history is None or state.current_stock >= self.CT_init else Action.D
        last_round = state.round_number == self.game_description.n_rounds - 1
        self.last_round = last_round
        cooperation_threshold = self.calculate_CT(state.current_stock, len(history.opponent_actions[-1])) if history is not None else self.CT_init
        opponent_cooperated = sum(history.opponent_actions[-1]) >= len(history.opponent_actions[-1]) // 2
        return Action.C if opponent_cooperated and state.current_stock >= cooperation_threshold else Action.D

    def calculate_CT(self, current_stock: float, previous_round_cooperation: int) -> float:
        if previous_round_cooperation > self.game_description.n_players // 2:
            return current_stock * (self.game_description.n_players - previous_round_cooperation) / (2 * (self.game_description.n_players - 1))
        return self.CT_init

class Strategy_EXPLOITATIVE_180(BaseStrategy):
    """
    A game theory strategy called Tit-for-Tat-Growth (TfT-G) for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((1, game_description.n_players), dtype=bool), my_payoffs=np.zeros(1, dtype=float), opponent_actions=np.zeros((game_description.n_rounds + 1, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds + 1, game_description.n_players), dtype=float))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        """
        Implement the Tit-for-Tat-Growth strategy for the current state and history.
        """
        if history is None:
            self.history = PlayerHistory(my_actions=np.array([[self.history.my_actions[-1, :]]]), my_payoffs=[self.history.my_payoffs[-1]], opponent_actions=self.history.opponent_actions, opponent_payoffs=self.history.opponent_payoffs)
        else:
            self.history = history
        if state.round_number == 0:
            action = Action.C
        else:
            num_cooperators = np.sum(self.history.opponent_actions[-self.game_description.n_rounds:, :] * (self.game_description.n_players - 1), axis=0)
            if np.sum(num_cooperators > self.game_description.n_players // 2) > 0:
                action = Action.C
            else:
                action = Action.D
        if state.round_number == self.game_description.n_rounds:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_181(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.opponent_history) == 0:
            return Action.C
        last_opponent_action = self.opponent_history[-1]
        current_opponent_action = history.opponent_actions[-1, -1]
        if current_opponent_action and (not last_opponent_action) or (not current_opponent_action and last_opponent_action):
            return Action(int((current_opponent_action + 1) % 2))
        else:
            return Action.C if state.round_number == self.game_description.n_rounds - 1 else Action.D

    def update_history(self, opponent_action: bool):
        """
        Update the opponent history with the latest action.
        """
        self.opponent_history.append(opponent_action)

class Strategy_EXPLOITATIVE_182(BaseStrategy):
    """
    Tit-for-Tat Strategy with Adaptive Cooperation Threshold (TFTC)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.adaptive_threshold = (self.capacity - self.n_players) * (0.5 + 0.5 / self.n_players)
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or len(history.my_actions) == 0:
            return Action.C
        average_stock = state.current_stock / self.n_players
        if len(history.opponent_actions) > 0 and history.opponent_actions[-1, -1] == True:
            return Action.C
        elif average_stock < self.adaptive_threshold:
            self.adaptive_threshold = (self.capacity - self.n_players) * (0.5 + 0.5 / self.n_players)
            return Action.D
        else:
            self.adaptive_threshold = (self.capacity - self.n_players) * (0.5 + 0.5 / self.n_players)
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.C

class Strategy_EXPLOITATIVE_183(BaseStrategy):
    """
    A simple and adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        opponent_action = self._history.opponent_actions[-2][0] if self._history else None
        if opponent_action is None:
            return Action.C
        if opponent_action:
            return Action.C
        return Action.D

    def update(self, state: CommonPoolState, my_action: Action, payoff: float, history: PlayerHistory) -> None:
        self._history = history

class Strategy_EXPLOITATIVE_184(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Stock Depletion (TFT-ASD) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.delta = 0.5
        self.last_opponent_action = None
        self.payoff_sum = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock < self.game_description.n_players * self.delta:
                return Action.D
            if self.last_opponent_action is not None and self.last_opponent_action == Action.C:
                return Action.C
            return Action.D
        opponent_action = history.opponent_actions[-1, 0] if history is not None else None
        if opponent_action is not None and self.last_opponent_action != opponent_action:
            self.delta += 0.03 * (1 - self.delta) if opponent_action == Action.D else 0.01 * self.delta
            self.delta = max(min(self.delta, 1), 0)
        self.last_opponent_action = opponent_action
        consumption = Action.C.value if self.delta < 1 else Action.D.value
        consumption *= self.game_description.n_players * self.delta / 2
        total_consumption = consumption * self.game_description.n_players
        stock_after_consumption = state.current_stock - total_consumption
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
        new_stock = min(self.game_description.capacity, stock_after_consumption + growth)
        payoff = new_stock / (2 * self.game_description.n_players) if self.delta < 1 else new_stock / self.game_description.n_players
        self.payoff_sum += payoff
        return Action.C if opponent_action is None or opponent_action == Action.C else Action.D

class Strategy_EXPLOITATIVE_185(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_ACT_value = 0.3 * self.game_description.capacity
        self.ACT_window = 5
        self.cooperation_history = []
        self.last_total_consumption = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0 or not self.cooperation_history:
            self.last_total_consumption = 0
            return action
        total_consumption = np.sum(history.opponent_actions[:, :self.game_description.n_players] * (self.game_description.n_players // 2))
        if total_consumption > self.last_total_consumption:
            self.cooperation_history.append(total_consumption)
            if len(self.cooperation_history) > self.ACT_window:
                self.cooperation_history = self.cooperation_history[-self.ACT_window:]
                self.last_total_consumption = np.sum(self.cooperation_history)
            if total_consumption > self.last_total_consumption:
                action = Action.D if state.round_number == self.game_description.n_rounds else Action.C
            elif total_consumption < self.last_total_consumption and history.opponent_actions[-1, -1] != history.my_actions[-2]:
                action = Action.D if state.round_number == self.game_description.n_rounds else Action.C
        return action

class Strategy_EXPLOITATIVE_186(BaseStrategy):
    """
    A Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []
        self.consistent_defection = False
        self.threshold = game_description.capacity // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or len(history.opponent_actions) < self.game_description.n_rounds:
            self.opponent_history.append(None)
        else:
            self.opponent_history = history.opponent_actions[-self.game_description.n_rounds:]
        last_opponent_action = self.opponent_history[-1]
        if last_opponent_action is None or len(self.opponent_history) < self.game_description.n_rounds:
            self.opponent_history.append(last_opponent_action)
        if last_opponent_action == Action.C:
            return Action.C
        elif last_opponent_action == Action.D:
            return Action.D
        elif len(self.opponent_history) >= self.game_description.n_rounds and last_opponent_action != Action.C:
            self.consistent_defection = True
            return Action.D
        else:
            current_stock_percent = state.current_stock / self.game_description.capacity * 100
            if state.round_number == self.game_description.n_rounds or current_stock_percent < self.threshold:
                return Action.C
            elif self.consistent_defection:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_187(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) Strategy in Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.decrease_percent = 0.01
        self.CT = self.game_description.n_players
        self.CT_min = self.game_description.n_players * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock <= 0:
            return Action.D
        if history is not None and state.round_number < self.game_description.n_rounds - 1:
            opponents_cooperate = np.sum(history.opponent_actions[-1])
            if opponents_cooperate > self.CT:
                return Action.C
            else:
                self.CT -= self.decrease_percent
                if self.CT < self.CT_min:
                    self.CT = self.CT_min
                return Action.D
        opponents_cooperate = np.mean(history.opponent_actions[:, :self.n_players]) * self.game_description.n_rounds
        if opponents_cooperate > self.CT:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_188(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if self.last_opponent_action is None:
            self.last_opponent_action = history.opponent_actions[-1, 0]
        if self.last_opponent_action == Action.C:
            return Action.C
        elif self.game_description.n_rounds - state.round_number <= 1:
            return Action.C
        else:
            self.last_opponent_action = not history.opponent_actions[-1, 0]
            return Action.D

class Strategy_EXPLOITATIVE_189(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Adaptation (TFT-SA)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = int(math.ceil(game_description.n_rounds * 0.5))
        self.history = np.zeros((self.k, 2), dtype=bool)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        consumption_rate = np.mean(self.history[-self.k:, 1])
        if consumption_rate <= self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.C
        else:
            return Action.D
        self.history = np.roll(self.history, -1)
        self.history[-1] = (state.round_number, history.my_actions[-1])

class Strategy_EXPLOITATIVE_190(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Growth Adaptation (TFT-SGA)
    Strategy summary: Cooperates initially, then adapts to opponent's previous actions while conserving the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(self.game_description.capacity * 2 / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_opponent_action = history.opponent_actions[-1, 0] if history is not None else None
        if previous_opponent_action is None or state.current_stock < self.threshold:
            return Action.C
        elif history and all(history.opponent_payoffs[-1] > 0):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_191(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = int(math.ceil(game_description.n_players * 0.5))
        self.forgiveness_period = int(math.floor(game_description.n_rounds * 0.9))
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            self.history.my_actions[state.round_number] = True
            return Action.C
        current_cooperators = sum(history.opponent_actions[-1, :])
        if current_cooperators >= self.cooperation_threshold:
            self.history.my_payoffs[-1] = state.current_stock / (2 * self.game_description.n_players)
            self.history.my_actions[state.round_number] = True
        elif sum(self.history.my_actions[-self.forgiveness_period:-1]) >= self.cooperation_threshold:
            self.history.my_payoffs[-1] = state.current_stock / (2 * self.game_description.n_players)
            self.history.my_actions[state.round_number] = True
        else:
            self.history.my_payoffs[-1] = state.current_stock / self.game_description.n_players
            self.history.my_actions[state.round_number] = False
        return Action(int(self.history.my_actions[-1]))

class Strategy_EXPLOITATIVE_192(BaseStrategy):
    """
    Strategy: Tit-for-Tat with Adaptive Cooperation Threshold (TFt-ACT) for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.coop_threshold = None
        self.average_consumption = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history:
            self.update_coop_threshold(history)
            self.average_consumption = np.mean(history.my_payoffs[:state.round_number])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponents_cooperated = sum(history.opponent_actions[-1, :])
        if opponents_cooperated >= self.game_description.n_players // 2 and self.average_consumption < self.coop_threshold:
            return Action.C
        else:
            return Action.D

    def update_coop_threshold(self, history: PlayerHistory):
        rounds = self.game_description.n_rounds // 2
        if self.coop_threshold is None:
            self.coop_threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        else:
            fraction_remaining = (self.game_description.n_rounds - rounds) / rounds
            self.coop_threshold *= 1 - fraction_remaining

class Strategy_EXPLOITATIVE_194(BaseStrategy):
    """
    Tit-for-Tat (with a twist) strategy for the Common Pool Resource Game.
    Cooperates initially to encourage cooperation and punishes defections to discourage them in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        elif self.history is not None:
            if state.round_number < self.game_description.n_rounds - 1:
                opponent_action = self.history.opponent_actions[-1, state.round_number % self.game_description.n_players]
                return Action(int(opponent_action)) if opponent_action is not None else Action.C
            else:
                return Action.C
        elif state.round_number == 0 and history is None:
            if self.game_description.capacity >= self.game_description.n_players * 2:
                return Action.C
        return Action.D

    def set_history(self, history: PlayerHistory):
        self.history = history

class Strategy_EXPLOITATIVE_196(BaseStrategy):
    """
    Tit-for-Tat with Stock Adjustment (TFT-SA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_point = 2 * self.game_description.n_players
        self.last_round = self.game_description.n_rounds - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        my_last_action = history.my_actions[-1] if history else None
        last_stock_level = state.current_stock if history else self.game_description.capacity
        if state.round_number == self.last_round and (my_last_action is not None and last_stock_level >= self.critical_point):
            return Action.D
        stock_remaining = max(0, last_stock_level - np.sum(history.opponent_actions[-1]))
        if stock_remaining < self.critical_point:
            if state.round_number != self.last_round:
                return Action.D if stock_remaining <= 0 else Action.C if my_last_action is None or my_last_action else Action.D
            else:
                return Action.D if last_stock_level >= self.game_description.capacity // (1 + self.game_description.n_players) else Action.C if my_last_action is None or my_last_action else Action.D
        return Action.C if np.all(history.opponent_actions[-1]) else Action.D

class Strategy_EXPLOITATIVE_197(BaseStrategy):
    """Adaptive Tit-for-Tat Strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == len(history.opponent_actions) - 1:
            if state.current_stock <= 0:
                return Action.D
        action = Action.C if self.last_round_opponent_action == Action.C else Action.D
        self.last_round_opponent_action = history.opponent_actions[-1, -1]
        return action

class Strategy_EXPLOITATIVE_198(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Generosity (TfT-AG) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = min(self.game_description.n_rounds, 10)
        self.average_cooperation_rate = 0
        self.p = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self._update_average_cooperation_rate(history)
            self._calculate_p()
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C if random.random() < self.p else Action.D
        return Action.D

    def _update_average_cooperation_rate(self, history: PlayerHistory):
        cooperative_rounds = sum(history.my_actions[-self.k:])
        self.average_cooperation_rate = cooperative_rounds / self.k

    def _calculate_p(self):
        if self.average_cooperation_rate > 0:
            self.p = self.average_cooperation_rate ** self.k

class Strategy_EXPLOITATIVE_199(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TfTSA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_over_n = self.game_description.capacity / self.game_description.n_players
        self.stock_threshold = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock < self.capacity_over_n:
            self.stock_threshold = self.capacity_over_n * (1 - 0.75)
            return Action.D if state.current_stock < self.stock_threshold else Action.C
        my_actions = history.my_actions if history is not None else np.zeros(self.game_description.n_rounds, dtype=bool)
        opponent_actions = history.opponent_actions if history is not None else np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool)
        recent_round = state.round_number - 1
        if opponent_actions[recent_round].sum() > self.game_description.n_players - 1:
            return Action.C
        elif my_actions[recent_round]:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_200(BaseStrategy):
    """
    Tit-for-Tat-Growth (TFT-G) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity * 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history:
            last_round = len(history.opponent_actions) - 1
            last_state = state.round_number == last_round + 1
            stock = state.current_stock
            if last_state and stock > self.stock_threshold:
                return Action.C
            elif any((history.opponent_actions[last_round, i] == Action.D for i in range(1, len(history.opponent_actions[0])))):
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_201(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.opponent_history = history.opponent_actions[-1]
        if state.round_number == 1 or np.sum(self.opponent_history) != len(self.opponent_history):
            return Action.C
        if self.opponent_history[0]:
            return Action.C
        elif self.opponent_history[1]:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_203(BaseStrategy):
    """
    A Tit-for-Tat adaptive strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.m = int(math.ceil(game_description.n_rounds / 2))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        cooperators = np.mean(history.opponent_actions[-self.m:, :]) > 0.5
        return Action.C if cooperators else Action.D

class Strategy_EXPLOITATIVE_204(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.state = game_description.capacity
        self.cooperation_threshold = game_description.n_rounds // 2
        self.accumulated_defection = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        round_number = state.round_number - 1
        if self.state < self.cooperation_threshold or self.accumulated_defection / self.state > (self.game_description.n_rounds - round_number) / self.game_description.n_rounds:
            return Action.C
        else:
            new_cooperation_threshold = self.cooperation_threshold + self.accumulated_defection * (self.state - self.cooperation_threshold) / (self.game_description.n_rounds - round_number) / self.state
            self.cooperation_threshold = min(new_cooperation_threshold, self.game_description.n_rounds - 1)
            return Action.D

class Strategy_EXPLOITATIVE_205(BaseStrategy):
    """
    TFT-ACT strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(shape=(1, 2), dtype=bool), np.zeros(shape=(1,)), np.zeros(shape=(1, game_description.n_players), dtype=bool), np.zeros(shape=(1, game_description.n_players)))
        self.cooperation_threshold = 0.5
        self.m = int(game_description.n_rounds * 0.3)
        self.recent_history_length = min(self.m, len(self.history.opponent_actions))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        if len(history.opponent_actions) < self.recent_history_length or len(history.my_payoffs) < len(history.opponent_actions):
            return Action.D
        if np.all(history.opponent_actions[-self.recent_history_length:, -1]) or not np.any(history.opponent_actions):
            self.cooperation_threshold = 0 if not np.any(history.opponent_actions) else 1
        else:
            cooperators = np.sum(history.opponent_actions[-self.recent_history_length:, -1])
            self.cooperation_threshold = cooperators / self.recent_history_length
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C if state.round_number > 0 and self.cooperation_threshold >= self.game_description.n_players // 2 else Action.D

class Strategy_EXPLOITATIVE_206(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFT-SA) strategy for Common Pool Resource Game.
    The strategy punishes opponents who consistently defect and rewards those who cooperate, encouraging cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_multiplier = 1.0
        self.opponent_cooperation_count = 0
        self.own_defection_count = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        self.opponent_cooperation_count += int(np.sum(opponent_actions))
        self.own_defection_count += int(history.my_actions[-1])
        cooperation_frequency = self.opponent_cooperation_count / state.round_number
        defection_frequency = self.own_defection_count / state.round_number
        multiplier = 1.0 if defection_frequency > cooperation_frequency else 2.0 * defection_frequency / cooperation_frequency
        self.stock_multiplier *= multiplier
        opponent_action = opponent_actions[-1]
        if opponent_action:
            return Action.C
        else:
            action = Action.D
            self.stock_multiplier *= min(2.0, cooperation_frequency)
            return action

class Strategy_EXPLOITATIVE_207(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive cooperative threshold for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = int(game_description.n_players * 0.8)
        self.T = game_description.capacity / (2 * game_description.n_players)
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        average_consumption = np.mean(history.opponent_actions[:, -self.k:-1].sum(axis=0))
        if average_consumption <= self.T:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_208(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_half = self.game_description.capacity // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return self._initial_decision(state)
        cooperators = sum(history.opponent_actions[-1, :])
        stock_percentage = state.current_stock / self.game_description.capacity * 100
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif stock_percentage >= self.capacity_half and cooperators < self.game_description.n_players:
            return Action.C
        elif stock_percentage < self.capacity_half and cooperators == self.game_description.n_players:
            return Action.D
        else:
            return self._decision(state, history)

    def _initial_decision(self, state):
        if state.current_stock >= self.capacity_half:
            return Action.C
        else:
            return Action.D

    def _decision(self, state, history):
        if state.current_stock <= 0:
            return Action.D
        elif state.current_stock < self.capacity_half and self.game_description.n_rounds - state.round_number > 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_209(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth (ATFSG) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2
        self.history = PlayerHistory(my_actions=np.zeros((self.game_description.n_rounds, 1), dtype=bool), my_payoffs=np.zeros(self.game_description.n_rounds, dtype=np.float64), opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        self.history.my_actions[state.round_number - 1] = [self.history.my_actions[state.round_number - 1][-1]]
        average_cp = np.mean(self.history.opponent_actions[:, -1])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if average_cp < self.threshold:
            return Action.C
        elif average_cp >= self.threshold:
            self.threshold = min(self.threshold * 2, self.game_description.n_players)
            return Action.D
        if state.current_stock == 0:
            return Action.D

class Strategy_EXPLOITATIVE_210(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TfT-ACT) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = 0.5
        self.window_size = int(game_description.n_rounds * 0.3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        average_cooperation = np.mean(history.opponent_actions[-self.window_size:, :].flatten())
        if state.round_number > self.window_size and average_cooperation > self.cooperative_threshold:
            self.cooperative_threshold = min(self.cooperative_threshold + 0.1, 1)
            return Action.C
        elif state.round_number > self.window_size and average_cooperation < self.cooperative_threshold:
            self.cooperative_threshold = max(self.cooperative_threshold - 0.1, 0)
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_211(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TTfT-ACT) strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.current_round = 0
        self.cooperative_threshold = np.zeros(self.game_description.n_rounds, dtype=np.float64)
        self.good_rounds = int(self.game_description.n_players / 2)
        self.bad_rounds = int(self.game_description.n_rounds * 0.8)
        self.increment = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and self.current_round > 0:
            self.update_cooperative_threshold(history)
        current_stock = state.current_stock
        cooperative = current_stock >= self.cooperative_threshold[self.current_round]
        if self.current_round == self.game_description.n_rounds - 1:
            cooperative = current_stock > 0 or current_stock >= self.cooperative_threshold[-1]
        action = Action.C if cooperative else Action.D
        self.current_round += 1
        return action

    def update_cooperative_threshold(self, history: PlayerHistory):
        opponent_cooperation = np.mean(history.opponent_actions[:, -self.good_rounds:])
        if opponent_cooperation < self.bad_rounds / self.game_description.n_rounds:
            self.cooperative_threshold[-1] = max(self.cooperative_threshold[-1] - self.increment, 0)
        elif opponent_cooperation > self.good_rounds / self.game_description.n_players:
            self.cooperative_threshold[-1] = min(self.cooperative_threshold[-1] + self.increment, 1)

class Strategy_EXPLOITATIVE_213(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game.
    Adaptive strategy that mimics opponent's actions while punishing defections to encourage cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        last_opponent_action = history.opponent_actions[-1, -1]
        my_previous_action = None if self.history is None else self.history.my_actions[-1]
        if my_previous_action is not None and last_opponent_action == my_previous_action:
            return my_previous_action
        elif last_opponent_action == Action.C:
            return Action.C
        else:
            return Action.D

    def update_history(self, my_action: bool, opponent_action: bool):
        if self.history is None:
            self.history = PlayerHistory(np.array([[my_action]]), np.array([[0.0]]), np.array([[opponent_action]]), np.array([[0.0]]))
        else:
            self.history.my_actions = np.vstack([self.history.my_actions, np.array([[my_action]])])
            self.history.my_payoffs = np.vstack([self.history.my_payoffs, np.array([0.0])])
            self.history.opponent_actions = np.vstack([self.history.opponent_actions, np.array([[opponent_action]])])

class Strategy_EXPLOITATIVE_214(BaseStrategy):
    """
    Tit-for-Tat-Growth (TfT-G) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = math.floor(game_description.capacity / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number < self.game_description.n_rounds:
            previous_action = history.my_actions[-1] if history else None
            previous_stock = history.my_payoffs[-1] if history else state.current_stock
            if previous_action is not None and previous_stock < self.threshold and (previous_action == Action.C):
                return Action.D
            elif state.current_stock <= previous_stock:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_215(BaseStrategy):
    """
    Tit-for-Tat with Stock Growth Adaptation strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity * 0.65
        self.average_threshold = game_description.n_rounds * (game_description.capacity / 4)
        self.total_payoff = np.zeros(game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_growth = 2 * state.current_stock * (1 - state.current_stock / self.game_description.capacity)
        opponent_action = history.opponent_actions[-1, -1] if history is not None else None
        if state.round_number == self.game_description.n_rounds - 1:
            if np.mean(self.total_payoff) > self.average_threshold:
                return Action.D
            return Action.C
        if opponent_action is None or (opponent_action and stock_growth >= self.threshold):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_216(BaseStrategy):
    """
    A Tit-for-Tat strategy for the Common Pool Resource Game (TFT-CPRG)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_round = 0
        self.history = PlayerHistory(np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros((1, self.game_description.n_players)), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.current_round = 0
            return Action.C
        if self.current_round == 0:
            self.history.my_actions[self.current_round] = [True] * self.game_description.n_players
            self.history.my_payoffs[self.current_round] = np.zeros(self.game_description.n_players)
            return Action.C
        self.current_round += 1
        for opponent in range(self.game_description.n_players):
            past_cooperation = self.history.my_actions[-1][opponent]
            last_defection = self.current_round < self.game_description.n_rounds - 1 and (not self.history.my_actions[self.current_round - 1][opponent])
            if self.current_round == self.game_description.n_rounds or (past_cooperation and last_defection):
                self.history.my_actions[self.current_round][opponent] = True
            elif past_cooperation:
                self.history.my_actions[self.current_round][opponent] = True
            else:
                self.history.my_actions[self.current_round][opponent] = False
        self.history.my_payoffs[self.current_round] = state.current_stock / (2 * self.game_description.n_players) * np.array([True] * self.game_description.n_players) if np.all(self.history.my_actions[-1]) else state.current_stock / self.game_description.n_players * np.array([False] * self.game_description.n_players)

class Strategy_EXPLOITATIVE_217(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = int(math.floor(game_description.n_players / 2))
        self.cooperative_streak = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        cooperators = sum(actions)
        self.cooperative_streak += int(Action.C == actions[0])
        if self.cooperative_streak >= self.game_description.n_players // 2:
            self.cooperative_threshold += 1
        elif cooperators < self.cooperative_threshold:
            self.cooperative_threshold = max(1, self.cooperative_threshold - 1)
        return Action.C if cooperators >= self.cooperative_threshold or state.round_number == self.game_description.n_rounds - 1 else Action.D

class Strategy_EXPLOITATIVE_218(BaseStrategy):
    """
    A strategy that mimics opponents' previous actions in a Common Pool Resource Game,
    except for retaliating against defection in the last round with a single defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        if state.round_number == 0:
            return Action.C
        last_action = history.opponent_actions[-1, (history.my_actions[-1] + 1) % self.game_description.n_players]
        if state.round_number == self.game_description.n_rounds - 1 or last_action:
            return Action.C
        else:
            return Action(int(not history.my_actions[-1]))

class Strategy_EXPLOITATIVE_219(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.stock_threshold = np.zeros(game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock = min(state.current_stock, self.capacity)
        r = state.round_number
        if stock > self.capacity / self.n_players:
            threshold = 0.5
        elif self.capacity / (2 * self.n_players) * r > stock and stock / self.n_players * r < stock:
            threshold = 1 - stock / self.capacity
        else:
            threshold = 1
        if history is None:
            return Action.C
        opponent_cooperation_rate = np.mean(history.opponent_actions[:, -1])
        return Action.C if opponent_cooperation_rate <= threshold else Action.D

class Strategy_EXPLOITATIVE_220(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat-with-Thresholds (TFTT)
    Strategy Description: Maintains a cooperation history with each opponent, cooperating if an opponent cooperates and defecting based on a cooperation threshold if the opponent defects. If the total stock level drops below a critical stock threshold (CST), TFTT becomes more aggressive in its responses to opponents who have defected in the past.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = math.floor((game_description.capacity - game_description.n_players) / 2)
        self.cooperation_history = np.full((game_description.n_rounds, game_description.n_players), True)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        if not history or state.round_number >= len(history.opponent_actions):
            cooperation_count = self.cooperation_history[state.round_number, :].sum()
            return Action.C if cooperation_count >= math.ceil(self.game_description.n_players / 2) else Action.D
        opponent_action = history.opponent_actions[-1, state.round_number % self.game_description.n_players]
        cooperation_history = self.cooperation_history[state.round_number - 1, state.round_number % self.game_description.n_players]
        if opponent_action and cooperation_history:
            return Action.C
        elif not opponent_action and self.critical_stock_threshold <= state.current_stock < self.game_description.capacity:
            return Action.D
        return Action.C if random.random() > 0.5 else Action.D

class Strategy_EXPLOITATIVE_222(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Forgiveness (TfTAF) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((self.game_description.n_rounds,), dtype=np.bool_), my_payoffs=np.zeros((self.game_description.n_rounds,), dtype=np.float64), opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=np.bool_), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        action = Action.C
        if state.round_number == 0:
            self.history.my_actions[0] = True
        else:
            average_cooperation = np.mean(self.history.my_actions[state.round_number - self.game_description.n_rounds // 2:state.round_number])
            action = Action.C if average_cooperation > self.game_description.n_players / 2 else Action.D
        return action

class Strategy_EXPLOITATIVE_223(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Stock Adaptation (TFT-SA)
    A cooperation strategy that cooperates initially and adapts based on opponent's past actions and current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = math.ceil(self.game_description.capacity * 2 / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if state.current_stock <= self.threshold:
            return Action.D
        opponent_action = history.opponent_actions[state.round_number - 1, 0]
        return Action(int(opponent_action) ^ 1)

class Strategy_EXPLOITATIVE_224(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation Strategy for the Common Pool Resource Game.
    Balances cooperation and defection based on current state and opponent's actions history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        if len(self.stock_history) == self.game_description.n_players * self.game_description.n_rounds:
            self.last_round = True
        opponent_cooperated = np.sum(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2
        if (state.current_stock == 0 or (state.current_stock < 2 * self.game_description.n_players and (not opponent_cooperated))) or self.last_round:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_225(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None
        self.cooperation_threshold = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        opponent_actions = history.opponent_actions[:, -1]
        if opponent_actions[-1] == Action.C:
            return Action.C
        else:
            if state.current_stock <= 0:
                self.cooperation_threshold = self.game_description.capacity / self.game_description.n_players
            else:
                self.cooperation_threshold = state.current_stock / self.game_description.n_players
            defections = sum((1 for i in reversed(range(len(opponent_actions))) if opponent_actions[i] == Action.D))
            if state.current_stock < self.cooperation_threshold:
                return Action.C
            elif defections > 0:
                return Action.D - defections
        return Action.D

class Strategy_EXPLOITATIVE_226(BaseStrategy):
    """
    Tit-for-Tat Adaptive (TfT-A) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0
        self.max_forgiveness = game_description.n_players // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            self.forgiveness_counter += 1
            self.forgiveness_counter = min(self.forgiveness_counter, self.max_forgiveness)
        else:
            self.forgiveness_counter -= 1
            if self.forgiveness_counter < 0:
                self.forgiveness_counter = 0
        return Action.C if self.forgiveness_counter >= self.max_forgiveness or history.opponent_actions[-1, -1] == Action.C else Action.D

class Strategy_EXPLOITATIVE_228(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_opponent_cooperation = 0
        self.is_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is None or len(history.my_actions) < self.game_description.n_rounds - 1:
            self.is_last_round = False
        else:
            self.is_last_round = state.round_number == self.game_description.n_rounds - 1
        if not self.is_last_round:
            cooperators = sum(history.opponent_actions[-1, :])
            self.last_round_opponent_cooperation = cooperators
            return Action(int(cooperators >= self.game_description.n_players // 2))
        else:
            return Action.C

class Strategy_EXPLOITATIVE_229(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Growth-Based Adjustment (ATFG) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity / (2 * self.game_description.n_players + 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        action = Action.D
        if history.opponent_actions[-1, -1] == Action.C:
            action = Action.C
        elif history.opponent_actions[-1, -1] == Action.D:
            pass
        else:
            stock = max(0, min(state.current_stock, self.game_description.capacity))
            if stock < self.threshold:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_230(BaseStrategy):
    """
    A strategy that implements Tit-for-Tat with Growth Adjustment (TFT-GA).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(math.ceil(game_description.capacity * 0.7))
        self.survival_threshold = math.floor(game_description.capacity / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_growth = self._calculate_stock_growth(state, history)
        if stock_growth >= self.threshold and history is not None:
            return Action.C
        if history.opponent_actions[-1, -1] == Action.D:
            return Action.D
        return Action.C

    def _calculate_stock_growth(self, state: CommonPoolState, history: PlayerHistory) -> float:
        total_consumption = np.sum(state.current_stock / self.game_description.n_players * history.my_actions[-1])
        stock_after_consumption = max(0, state.current_stock - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
        return growth

class Strategy_EXPLOITATIVE_231(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = np.zeros((self.game_description.n_rounds,), dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        opponent_cooperated = np.sum(history.opponent_actions[:, -1]) >= self.game_description.n_players // 2
        self.history[-1] = Action.C if opponent_cooperated else Action.D
        if len(self.history) > 1 and self.history[-2] == Action.C:
            return Action.D if not opponent_cooperated else Action.C
        return Action.C

class Strategy_EXPLOITATIVE_232(BaseStrategy):
    """
    A Tit-for-Tat with Gradual Cooperation strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 2 * game_description.n_players
        self.p = 0
        self.cooperation_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.D
        if state.round_number == 0:
            action = Action.C
        elif history is not None and len(history.opponent_actions) > 0:
            last_opponent_action = history.opponent_actions[-1][-1]
            if last_opponent_action:
                self.cooperation_count += 1
                self.p = max(min(1 - (1 - 0.05) ** self.cooperation_count, 1), 0)
                action = Action.C if random.random() < self.p else Action.D
            else:
                self.cooperation_count = 0
                self.p = 0
        if state.current_stock <= self.threshold:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_233(BaseStrategy):
    """
    Tit-for-Tat with Growth Adaptation Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.opponent_actions) == 0):
            self.forgiveness_count = 0
            return Action.C
        if history is not None and self.forgiveness_count < self.game_description.n_players:
            opponent_cooperated = sum(history.opponent_actions[-self.forgiveness_count - 1, :]) == self.game_description.n_players
            if opponent_cooperated:
                self.forgiveness_count = 0
            else:
                self.forgiveness_count += 1
        def_count = sum(history.opponent_actions[:, -1])
        if def_count >= self.game_description.n_players:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_234(BaseStrategy):
    """
    Tit-for-Tat strategy with a slight twist for Common Pool Resource Game.
    Cooperates when it benefits, defects when opponents are consistently defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_action = Action.C
        self.current_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return self.previous_action
        total_consumption = np.sum(history.opponent_actions[-1])
        stock_threshold = math.ceil(self.game_description.capacity / 2) if state.round_number != self.game_description.n_rounds else 0
        if total_consumption < self.game_description.n_players * 2 and self.current_stock >= stock_threshold:
            self.previous_action = Action.C
        elif total_consumption >= self.game_description.n_players * 2 and self.current_stock <= math.ceil(self.game_description.capacity / 4):
            self.previous_action = Action.D
        return self.previous_action

class Strategy_EXPLOITATIVE_235(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Stock Threshold (TfT-AST)
    Summary: Cooperates initially, then adapts based on average consumption per player and adaptive stock threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        consumption = np.mean(history.opponent_actions[:, -1].astype(int)) * (state.current_stock / self.game_description.n_players)
        if state.round_number == self.game_description.n_rounds or consumption <= self.threshold(self.initial_stock, state.current_stock):
            return Action.C
        else:
            return Action.D

    def threshold(self, initial_stock, current_stock):
        return min(1 - initial_stock / self.game_description.capacity, 0.5) + self.game_description.n_rounds * 0.02

class Strategy_EXPLOITATIVE_236(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = np.zeros(game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=np.bool_), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=np.bool_), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))
        if state.round_number < self.game_description.n_rounds:
            self.average_consumption[state.round_number] = np.mean(history.opponent_actions[:, :state.round_number].sum(axis=0))
        if state.round_number < self.game_description.n_rounds - 1:
            return Action.C if self.average_consumption[:state.round_number + 1].mean() < self.game_description.capacity / (2 * self.game_description.n_players) else Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_237(BaseStrategy):
    """
    A strategy based on Fitness-Maximizing Tit-for-Tat for the Common Pool Resource Game.
    Cooperates in the first round and retaliates against defection while considering future opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif history is None or self.last_round is None:
            self.last_round = state
            return Action.C
        else:
            if state.round_number == self.game_description.n_rounds:
                return Action.D
            elif history.opponent_actions[-1].all():
                return Action.C
            elif (history.opponent_actions[-1] * self.game_description.n_players % 2).any():
                return Action.D
            else:
                stock_level = (self.game_description.capacity - self.last_round.current_stock) / self.game_description.n_players
                if stock_level <= 0.5 and history.opponent_actions[-1].any():
                    return Action.D
                elif stock_level > 0.5:
                    return Action.C
            self.last_round = state
        return Action.D

class Strategy_EXPLOITATIVE_238(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Growth Adaptation (TfTGA)
    The TfTGA strategy cooperates initially, then adapts to the opponent's behavior, rewarding cooperation while punishing defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity
        self.consumption_c = (self.capacity - self.game_description.n_players) / self.game_description.n_rounds
        self.avg_consumption_rate = 0
        self.opponent_cooperated_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_consumption = np.sum(history.opponent_actions[:, -1]) * self.game_description.n_players
        self.avg_consumption_rate = (self.avg_consumption_rate + current_consumption) / (state.round_number + 1)
        if self.opponent_cooperated_last_round:
            cooperate_threshold = self.consumption_c * 0.5
        else:
            cooperate_threshold = self.consumption_c
        cooperate = current_consumption < cooperate_threshold
        if state.round_number == self.game_description.n_rounds - 1 and (not cooperate):
            cooperate = True
        self.opponent_cooperated_last_round = cooperate
        return Action(int(cooperate))

class Strategy_EXPLOITATIVE_239(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Adaptation (TfT-SA)
    Strategy description: See provided pseudocode and strategy specification.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if history is None or len(history.my_actions) == 0:
            return Action.C
        my_action = history.my_actions[-1]
        opp_actions = history.opponent_actions[:, -1]
        last_round = state.round_number == len(history.my_payoffs) - 1
        if last_round:
            return my_action
        all_defected = np.all(opp_actions == Action.D)
        if all_defected and (not last_round):
            return Action.D
        elif not all_defected:
            return Action.C
        return my_action

class Strategy_EXPLOITATIVE_240(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_opponent_action = None
        self.current_stock_level = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.last_round_opponent_action = history.opponent_actions[state.round_number - 1, 0]
        self.current_stock_level = state.current_stock
        if self.current_stock_level < self.game_description.capacity - 2 * self.game_description.n_players:
            return Action.D
        if self.last_round_opponent_action:
            if self.last_round_opponent_action:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_241(BaseStrategy):
    """
    A common pool resource game strategy that implements Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_over_4n = self.game_description.capacity / (4 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.opponent_actions) < self.game_description.n_rounds - 1):
            return Action.C
        average_cooperation = np.mean(history.opponent_actions[:, :-1].ravel())
        if average_cooperation >= self.capacity_over_4n:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_242(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Greed Strategy for the Common Pool Resource Game.
    This strategy cooperates in the first round and then adapts its actions based on the opponent's past behavior.
    It punishes opponents who have been greedy by slightly increasing their consumption while still maintaining growth potential.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        opponent_actions = history.opponent_actions[-state.round_number:]
        last_round_opponent_action = opponent_actions[-1, -1]
        opponent_cooperators = sum(opponent_actions[:, 0])
        if all(opponent_actions[:, 0]):
            return Action.C
        elif len(opponent_actions) > 1 and last_round_opponent_action == Action.D:
            consumption = (sum([1 for action in opponent_actions[:, -1] if action]) + 1) / self.game_description.n_players
            return (Action.D, {'consumption': consumption})
        else:
            return Action.C

class Strategy_EXPLOITATIVE_244(BaseStrategy):
    """
    A strategy that cooperates in the first round and subsequently adapts its actions based on opponent's history, prioritizing resource conservation when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_sustainable_stock = 2 * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_history = history.opponent_actions if history else np.zeros((state.round_number + 1, self.game_description.n_players), dtype=np.bool_)
        opponent_defects = np.sum(opponent_history[:, 0], axis=0)
        round_ratio = state.round_number / self.game_description.n_rounds
        if round_ratio < 1:
            punishment = int(opponent_defects * round_ratio)
            depleted_stock = state.current_stock - 2 * self.min_sustainable_stock * punishment
            if depleted_stock < self.min_sustainable_stock:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if np.sum(history.opponent_actions[:, 0]) > len(history.opponent_actions) // 2:
                return Action.C
            else:
                return Action.D
        if opponent_defects == 0:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_245(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game. The AI player aims to maximize its payoff by taking advantage of various opponent behaviors without relying on specific coordination mechanisms or shared norms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.moving_average_k = int(self.game_description.n_players * 0.5)
        self.history = PlayerHistory(my_actions=np.zeros((1, self.game_description.n_rounds), dtype=bool), my_payoffs=np.zeros(self.game_description.n_rounds), opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        opponent_defections = self.history.opponent_actions[:, :].sum(axis=1)
        moving_average = np.mean(opponent_defections[-self.moving_average_k:])
        defect_threshold = (self.game_description.capacity - self.game_description.capacity // self.game_description.n_players) / self.game_description.n_players + self.game_description.capacity // (2 * self.game_description.n_players)
        if state.current_stock <= self.game_description.capacity / self.game_description.n_players or state.current_stock >= self.game_description.capacity - self.game_description.capacity // (2 * self.game_description.n_players):
            return Action.D
        elif moving_average > defect_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_247(BaseStrategy):
    """
    Tit-for-Tat-Greedy Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.trust = np.ones(game_description.n_players)
        self.greed_factor = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if np.all(history is None):
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if current_stock == 0:
            return Action.D
        potential_payoff_cooperate = current_stock / (2 * n)
        potential_payoff_defect = current_stock / n
        greedy_margin = (1 - self.greed_factor) * (current_stock / n)
        if potential_payoff_cooperate >= current_stock / (2 * n) >= greedy_margin:
            return Action.C
        opponent_actions_round = history.opponent_actions[state.round_number - 1, :]
        total_cooperators = np.sum(opponent_actions_round)
        if total_cooperators > (r - state.round_number + 1) / r:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_248(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = int(math.ceil(game_description.n_rounds * 0.7))
        self.t = 0.6
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is not None:
            self.history = history
        if state.round_number == 0 or history is None:
            return Action.C
        cooperation_avg = self.calculateAverageCooperation(self.history)
        if cooperation_avg > self.t:
            return Action.C
        else:
            return Action.D

    def calculateAverageCooperation(self, history: PlayerHistory):
        cooperation_count = np.sum(history.opponent_actions[self.k:, :].sum(axis=0))
        return cooperation_count / self.k

class Strategy_EXPLOITATIVE_249(BaseStrategy):
    """
    A Tit-for-Tat strategy for the Common Pool Resource Game.
    The strategy follows a cooperative approach with retaliation against excessive exploitation by opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.first_round = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        total_consumption = np.sum(history.my_actions) * (state.current_stock // self.game_description.n_players)
        cooperators = sum(history.opponent_actions[-1, :])
        if self.first_round:
            self.first_round = False
            return Action.C
        elif total_consumption <= self.game_description.capacity // (self.game_description.n_players * 2):
            return Action.C
        elif cooperators < self.game_description.n_players:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_251(BaseStrategy):
    """
    Implementation of the Tit-for-Tat strategy in a Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_payoff = np.mean([self.game_description.capacity / (2 * game_description.n_players)] * game_description.n_rounds)
        self.strategy = {'cooperate': True, 'defect': False}
        self.total_payoff = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return self.strategy['cooperate'] and Action.C or Action.D
        round_number = state.round_number - 1
        total_payoff = self.total_payoff + (history.my_payoffs[round_number] if round_number >= 0 else 0)
        self.strategy['cooperate'] = round_number > 0 and history.opponent_actions[round_number, -1] == Action.C.value or total_payoff < self.average_payoff
        return self.strategy['cooperate'] and Action.C or Action.D

class Strategy_EXPLOITATIVE_253(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.coop_threshold = None
        self.last_round_cooperators = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.coop_threshold = state.current_stock / self.game_description.n_players
            return Action.C
        action = Action.D
        if history is not None:
            self.last_round_cooperators = np.sum(history.opponent_actions[-1])
            if self.last_round_cooperators == self.game_description.n_players:
                action = Action.C if state.current_stock > self.coop_threshold else Action.D
            elif self.last_round_cooperators < self.game_description.n_players:
                action = Action.D
                self.coop_threshold = max(self.coop_threshold - state.current_stock / self.game_description.n_players, 1)
        return action

class Strategy_EXPLOITATIVE_254(BaseStrategy):
    """
    A Tit-for-Tat Exploitative Strategy (TFT-Exploiter) that cooperates when the total consumption is less than average consumption and defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_consumption = game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        total_consumption = np.sum(history.opponent_actions[-1]) if history is not None else 0
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C
        action = Action.C if total_consumption < self.avg_consumption else Action.D
        return action

class Strategy_EXPLOITATIVE_255(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_per_player = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        past_actions = np.sum(history.opponent_actions, axis=0) if history is not None else np.zeros(self.game_description.n_players)
        cooperative_threshold_reached = state.current_stock >= self.capacity_per_player
        current_state_below_ct = state.current_stock < self.capacity_per_player
        last_round_cooperators = sum(past_actions)
        if last_round_cooperators == self.game_description.n_players:
            return Action.C
        elif current_state_below_ct and last_round_cooperators < self.game_description.n_players // 2:
            return Action.D
        elif cooperative_threshold_reached:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_256(BaseStrategy):
    """
    Tit-for-Tat with Stock Growth Adaptation (TFT-SGA) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = self.game_description.n_players
        self.capacity = self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history:
            opponent_actions = history.opponent_actions[-1]
            cooperator_count = np.sum(opponent_actions == Action.C)
            if cooperator_count >= self.n_players // 2:
                return Action.C
        else:
            return Action.C
        opponent_action = opponent_actions[-1] if history else None
        stock = state.current_stock
        if opponent_action == Action.C:
            return Action.C
        elif stock <= self.capacity - 2 * self.n_players:
            growth = math.floor((self.capacity - stock) / (2 * self.n_players))
            new_stock = min(stock + growth, self.capacity)
            return Action.C if new_stock > self.capacity - 2 * self.n_players else Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_258(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_round = 0
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros((1,)), np.zeros((self.game_description.n_players, self.game_description.n_rounds), dtype=bool), np.zeros((self.game_description.n_players, self.game_description.n_rounds)))
        self.opponent_cooperation = self.game_description.n_players // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is not None:
            self.history = history
            self.current_round = state.round_number
            self.opponent_cooperation = sum(self.history.opponent_actions[-1, :])
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1 and self.current_stock(state) < self.game_description.capacity / 2:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 2 and self.current_stock(state) <= self.game_description.capacity / 2:
            return Action.C
        elif self.opponent_cooperation > 0:
            return Action.C
        else:
            return Action.D

    def current_stock(self, state):
        return max(state.current_stock - np.sum(self.history.my_actions[-1]) * (self.game_description.n_players / 2), 0)

class Strategy_EXPLOITATIVE_259(BaseStrategy):
    """
    Implementation of the Tit-for-Tat (TFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number == 1 and history is None:
            return Action.D
        else:
            if len(self.opponent_history) == 0 or history is None:
                self.opponent_history = [Action.C]
            else:
                self.opponent_history.append(history.opponent_actions[-1, -1])
            if self.opponent_history[-1] == Action.C:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_260(BaseStrategy):
    """
    Tit-for-Tat (with adaptations) strategy for the Common Pool Resource Game.
    This strategy cooperates initially and responds to opponents' actions in subsequent rounds.
    It also handles edge cases such as the first round, last round, and low or high stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity
        self.n_players = self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            last_round = len(history.opponent_actions) - 1
            cooperators = sum(history.opponent_actions[last_round])
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        stock_level = state.current_stock
        if state.round_number == self.game_description.n_rounds - 1:
            if stock_level >= self.capacity * (self.game_description.n_players - 1) // 2:
                return Action.C
            elif stock_level < self.capacity / self.game_description.n_players:
                return Action.D
        return history.__call__(__class__, state) if hasattr(history, '__call__') else self(state, history)

class Strategy_EXPLOITATIVE_261(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._history = PlayerHistory(my_actions=np.zeros((game_description.n_rounds, 1), dtype=bool), my_payoffs=np.zeros(game_description.n_rounds, dtype=float), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=float))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = self._history.my_actions.shape[0] - 1
        if round_number == 0 or round_number == self.game_description.n_rounds - 1:
            return Action.C
        opponent_action = history.opponent_actions[round_number, 0]
        if opponent_action:
            self._history.my_actions[round_number] = True
            return Action.C
        else:
            self._history.my_actions[round_number] = False
            return Action.D

class Strategy_EXPLOITATIVE_262(BaseStrategy):
    """
    A strategy that cooperates initially and adapts its cooperative threshold based on average consumption,
    punishing high consumers while encouraging recovery of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = None
        self.average_consumption = np.zeros(game_description.n_rounds)
        self.growth_factor = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        self.average_consumption[state.round_number] = np.mean(history.opponent_payoffs[:state.round_number])
        if state.round_number > 0 and state.round_number < self.game_description.n_rounds:
            capacity = self.game_description.capacity * (self.game_description.n_players / 2)
            self.cooperative_threshold = capacity + self.average_consumption[state.round_number - 1] * self.growth_factor
        if history is None:
            return Action.C
        elif np.mean(history.opponent_payoffs) < self.cooperative_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_263(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_strategies = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponent_strategies.append(history.opponent_actions[-1])
        current_round = len(self.opponent_strategies) - 1
        if current_round == 0:
            return Action.C
        opponent_cooperated = np.sum(self.opponent_strategies[-current_round]) >= self.game_description.n_players // 2
        return opponent_cooperated and Action.C or Action.D

class Strategy_EXPLOITATIVE_264(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game.
    This strategy cooperates as long as the resources allow it, but also punishes excessive exploitation by defecting when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_stock = game_description.capacity
        self.cooperation_threshold = math.floor(self.initial_stock / 2)
        self.min_ct = int(self.cooperation_threshold * 0.9)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if state.round_number == 0 or (current_stock >= self.cooperation_threshold and history is not None):
            return Action.C
        if current_stock < self.initial_stock / 2 and self.cooperation_threshold > self.min_ct:
            self.cooperation_threshold = math.floor(self.cooperation_threshold * 0.9)
        return Action.D

class Strategy_EXPLOITATIVE_265(BaseStrategy):
    """
    This strategy implements the Tit-for-Tat with Gradual Cooperation (TFT-GC).
    It adapts behavior based on opponent's actions from the previous round,
    and gradually decreases the frequency of punishment over time.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_probability = game_description.n_players // 4
        self.rounds_played = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.rounds_played += 1
        punishment_probability = max(self.punishment_probability - self.rounds_played * 1 / self.game_description.n_rounds, 0)
        if history is not None and history.opponent_actions[-1, :].any():
            cooperators = sum(history.opponent_actions[-1, :])
            return Action.C if cooperators >= self.game_description.n_players * punishment_probability else Action.D
        return Action.C

class Strategy_EXPLOITATIVE_266(BaseStrategy):
    """Adaptive Tit-for-Tat with Stock Depletion Awareness Strategy"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.threshold_depletion = self.capacity * 0.75
        self.lenient_threshold_depletion = self.capacity * 0.5
        self.total_stock_depletion = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        current_round = state.round_number
        opponent_actions = history.opponent_actions[-1]
        total_consumption = np.sum([self.consumption(self.game_description, a) for a in opponent_actions])
        stock_after_consumption = self.game_description.capacity - total_consumption
        if stock_after_consumption <= 0:
            return Action.C
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        new_stock = min(self.game_description.capacity, self.game_description.capacity + growth)
        self.total_stock_depletion += total_consumption
        if current_round == 1:
            return Action.C
        if np.all(opponent_actions == [True]):
            if self.total_stock_depletion > self.threshold_depletion:
                return Action.D
            else:
                return Action.C
        if any((opponent_a == False for opponent_a in opponent_actions)):
            if self.total_stock_depletion < self.lenient_threshold_depletion:
                if history.my_actions[-1]:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        return history.my_actions[-1]

    @staticmethod
    def consumption(game_description: CommonPoolDescription, action: Action) -> float:
        return (action == Action.C) * game_description.capacity // (2 * game_description.n_players) + (action == Action.D) * game_description.capacity // game_description.n_players

class Strategy_EXPLOITATIVE_267(BaseStrategy):
    """
    The Tit-for-Tat-Growing (TfTG) strategy for the Common Pool Resource Game.
    This strategy cooperates initially and punishes excessive consumption by others.
    It also ensures a higher payoff in the last round if there is enough stock for at least one more round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = np.sum(history.my_actions[-1]) * self.game_description.n_players
        if history is not None and self.average_consumption is not None:
            avg_consumption = self.average_consumption / (state.round_number - 1)
            if total_consumption > avg_consumption:
                return Action.D
        remaining_stock = math.floor(state.current_stock)
        if state.round_number == self.game_description.n_rounds and remaining_stock >= self.game_description.n_players:
            return Action.C
        self.average_consumption = total_consumption if state.round_number > 1 else total_consumption / (state.round_number - 1)
        return Action.D

class Strategy_EXPLOITATIVE_268(BaseStrategy):
    """
    A strategy that combines the Tit-for-Tat and Stock Adaptation strategies in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.probability_threshold = 0.8
        self.stock_percentage_threshold_cooperate = 1 - self.capacity * 0.6 / self.capacity
        self.stock_percentage_threshold_defect = 1 - self.capacity * 0.8 / self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        opponent_cooperated = history.opponent_actions[last_round, 0]
        stock_percentage = state.current_stock / self.capacity
        if stock_percentage > self.stock_percentage_threshold_cooperate:
            probability_to_cooperate = 1 - (stock_percentage - self.stock_percentage_threshold_cooperate) / (self.stock_percentage_threshold_defect - self.stock_percentage_threshold_cooperate)
        elif stock_percentage <= self.stock_percentage_threshold_defect:
            probability_to_cooperate = 0
        else:
            probability_to_cooperate = (stock_percentage - self.stock_percentage_threshold_defect) / (self.stock_percentage_threshold_cooperate - self.stock_percentage_threshold_defect)
        if opponent_cooperated:
            probability_to_cooperate += self.probability_threshold
        random_number = random.random()
        if random_number < probability_to_cooperate:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_270(BaseStrategy):
    """
    A Selfish Growth Strategy (SGS) for the Common Pool Resource Game.
    SGS aims to maximize payoff by being adaptive and robust to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            stock_level = math.floor(state.current_stock)
            if stock_level < self.game_description.capacity // self.game_description.n_players:
                return Action.D
            else:
                return Action.C
        total_rounds = history.my_actions.size
        round_number = state.round_number - 1
        my_actions = history.my_actions[round_number]
        stock_level = math.floor(state.current_stock)
        if stock_level < self.game_description.capacity // (2 * self.game_description.n_players):
            return Action.D
        elif round_number < int(total_rounds * self.threshold) and my_actions:
            return Action.C
        elif stock_level >= self.game_description.capacity // (2 * self.game_description.n_players):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_272(BaseStrategy):
    """
    Implementation of the Tit-for-Tat-Growth (TftT-G) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_length = 3
        self.opponent_actions = [False] * self.history_length

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number == 0:
            return history.my_actions[-1]
        else:
            if len(self.opponent_actions) < self.history_length or np.all(self.opponent_actions[-self.history_length:]):
                return history.my_actions[-1]
            return Action.D

    def update_history(self, new_history: PlayerHistory):
        self.opponent_actions = new_history.opponent_actions[:, -1].tolist()

class Strategy_EXPLOITATIVE_273(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game.
    A cooperative strategy that encourages reciprocity and punishes defection in the resource management game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_stock = self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_274(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity // 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number > 0 and history is not None:
            last_opponent_action = history.opponent_actions[-1, -1]
            if last_opponent_action == Action.C:
                action = last_opponent_action
            else:
                action = Action.D
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock < self.threshold:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_275(BaseStrategy):
    """
    The Tit-for-Tat-Growing (TfT-G) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_start = math.ceil(game_description.n_players * 2)
        self.t = 1
        self.T = game_description.n_players // 4
        self.adjustment_period = int(math.log2(game_description.n_players))
        self.max_t = math.ceil(game_description.n_rounds / self.adjustment_period)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-self.t:, :], axis=0) >= self.T * self.t
        action = Action.C if np.any(cooperators) else Action.D
        return action

    def compute_average_cooperative_behavior(self) -> float:
        return np.mean(history.my_actions[-self.t:])

class Strategy_EXPLOITATIVE_276(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        self.history = PlayerHistory(np.zeros((self.game_description.n_rounds, 1), dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        player_stock = state.current_stock / self.game_description.n_players
        if player_stock >= self.cooperation_threshold:
            return Action.C
        else:
            return Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators == self.game_description.n_players:
            self.cooperation_threshold *= 2
            if self.cooperation_threshold > 1:
                self.cooperation_threshold = 1
        elif cooperators == 0:
            self.cooperation_threshold /= 2
        self.history.my_actions[-1] = self.__call__(state, None) == Action.C
        self.history.my_payoffs[-1] = state.current_stock / (self.game_description.n_players * self.game_description.n_rounds) if self.history.my_actions[-1] else state.current_stock / self.game_description.n_players
        self.history.opponent_actions[-1, :] = history.opponent_actions[:, -1]
        self.history.opponent_payoffs[-1, :] = history.opponent_payoffs[:, -1]

class Strategy_EXPLOITATIVE_277(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if self.history is None and state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return self._last_round_decision(state, history)
        return self._regular_round_decision(state, history)

    def _regular_round_decision(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not self.history or self.history[-1].my_actions[-1] == Action.D:
            cooperators = sum(history.opponent_actions[:, -1])
        else:
            cooperators = sum(history.opponent_actions[:, -2]) + (1 if self.history[-1].my_actions[-1] == Action.C else 0)
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

    def _last_round_decision(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.current_stock == 0:
            return Action.D
        else:
            return self._regular_round_decision(state, history)

class Strategy_EXPLOITATIVE_278(BaseStrategy):
    """
    Strategy implementing Tit-for-Tat-Growth (TFTG). This strategy promotes cooperation when opponents show signs of restraint, while also punishing overconsumption and encouraging a balance in resource management.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.stock_history.append(state.current_stock - (2 * self.game_description.n_players if history.my_actions[-1] else self.game_description.n_players) * state.round_number)
        total_consumption = 0
        if history is not None:
            total_consumption = (2 * self.game_description.n_players if history.my_actions[-1] else self.game_description.n_players) + (2 * self.game_description.n_players if history.opponent_actions[-1, -1] else self.game_description.n_players)
        avg_consumption = total_consumption / max(self.stock_history[-1], 0.001) if len(self.stock_history) > 1 else total_consumption / (state.current_stock - (2 * self.game_description.n_players if history.my_actions[-1] else self.game_description.n_players) * state.round_number)
        return Action.C if avg_consumption < self.game_description.capacity / (2 * self.game_description.n_players) else Action.D

class Strategy_EXPLOITATIVE_279(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.window_size = int(math.ceil(game_description.n_rounds / 2))
        self.epsilon = 0.01

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            cooperative_rate = np.mean(history.opponent_actions[-self.window_size:])
            threshold = self._cooperative_threshold(state, history)
            return Action.C if cooperative_rate >= threshold else Action.D
        else:
            return Action.C

    def _cooperative_threshold(self, state: CommonPoolState, history: PlayerHistory) -> float:
        if state.round_number == self.game_description.n_rounds or history.my_actions[-1] == Action.C:
            return (self.game_description.capacity - 2 * self.game_description.n_players) / (2 * self.game_description.n_players) + self.epsilon
        else:
            return (self.game_description.capacity - 2 * self.game_description.n_players) / (4 * self.game_description.n_players)

class Strategy_EXPLOITATIVE_280(BaseStrategy):
    """
    Strategy name: Fitness-Maximizing Exploitative Strategy (FMES) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.capacity * (1 - 1 / game_description.n_rounds) ** 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        payoff_ratio = self.game_description.capacity / (2 * self.game_description.n_players) / (self.game_description.capacity / self.game_description.n_players)
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        if payoff_ratio > 1 and history is not None:
            past_stocks = [state.current_stock - round_consumption for _, round_consumption in enumerate(history.my_actions)]
            self.threshold = math.ceil(self.game_description.capacity * (1 - state.round_number / self.game_description.n_rounds) ** 2)
            threshold_stocks = [self.threshold * (1 - round_number / self.game_description.n_rounds) ** 2 for round_number in range(state.round_number, 0, -1)]
            if any((stock > threshold for stock in past_stocks[-self.game_description.n_players:])):
                return Action.D
        if payoff_ratio <= 1 and state.current_stock > self.threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_281(BaseStrategy):
    """
    A Tit-For-Tat Growing (TFT-G) strategy implementation for the Common Pool Resource Game.
    This strategy cooperates in the first round and then adapts to the opponent's consumption behavior, punishing excessive exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history = history
        opponent_actions = history.opponent_actions[:, -1]
        average_consumption = np.mean(opponent_actions) * (self.game_description.n_players / state.current_stock)
        optimal_consumption = self.game_description.capacity / (2 * self.game_description.n_players)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.D if average_consumption < optimal_consumption else Action.C

class Strategy_EXPLOITATIVE_282(BaseStrategy):
    """
    A Tit-for-Tat Plus (TfTP) strategy in Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.min_stock_for_cooperation = 3 * self.n // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C if state.current_stock >= self.min_stock_for_cooperation else Action.D
        opponent_action = history.opponent_actions[-1, 0] if history is not None else None
        current_stock = max(state.current_stock, 0)
        if current_stock < self.n:
            return Action.D
        if opponent_action is None or opponent_action:
            return Action.C if current_stock >= 2 * self.n else Action.D
        return Action.C if current_stock >= 2 * self.n else Action.D

class Strategy_EXPLOITATIVE_283(BaseStrategy):
    """
    A strategy that cooperates in the first round, then adapts its behavior based on opponents' actions in previous rounds.
    If all opponents cooperated in the last round, the strategy continues cooperating. If any opponent defected, it defects back to punish them.
    In the last round with low resources, it defects if there were more defectors than cooperators in the previous round to maximize payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if self.last_round and history.opponent_actions[-1].sum() > len(history.opponent_actions[0]) // 2:
            return Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

    def on_game_end(self, new_state: CommonPoolState):
        self.last_round = True

class Strategy_EXPLOITATIVE_284(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.min_consumption = 2 * self.n_players
        self.stock_threshold = 2 * self.n_players - 1

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        if current_stock < self.min_consumption:
            consumption = self.min_consumption
            payoff = current_stock / self.game_description.n_players
        else:
            cooperators = np.sum(history.opponent_actions[-1, :])
            consumption = self.min_consumption if cooperators < self.n_players else current_stock // self.n_players
            payoff = current_stock / self.game_description.n_players if history is not None and history.my_actions[-1] == Action.C else 0
        total_consumption = sum([history.my_actions[t] * consumption for t in range(state.round_number)])
        new_stock = max(current_stock - total_consumption, 0)
        growth = 2 * new_stock * (1 - new_stock / self.capacity)
        stock = min(new_stock + growth, self.capacity)
        if stock < self.stock_threshold:
            payoff += stock / self.game_description.n_players
        else:
            payoff += (stock - total_consumption) / self.game_description.n_players
        history.my_payoffs[-1] = payoff
        return Action(history.my_actions[-1].item() if history is not None else 0)

class Strategy_EXPLOITATIVE_285(BaseStrategy):
    """
    Tit-for-Tat-Greed (TfT-G) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) < self.n_rounds - 1:
            return Action.D
        opponent_cooperation_count = np.sum(np.sum(history.opponent_actions, axis=0) > 0)
        if opponent_cooperation_count > self.num_players // 2 and state.round_number < self.n_rounds:
            return Action.C
        elif opponent_cooperation_count <= self.num_players // 2 and state.round_number < self.n_rounds:
            return Action.D
        elif state.round_number == self.n_rounds:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_286(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat (ATFT) strategy in a Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not self.opponent_history:
            return Action.C
        opponent_action = history.opponent_actions[-1, -1] if history else None
        if opponent_action is None:
            return Action.C
        if opponent_action == Action.C:
            return Action.C
        self.opponent_history.append(opponent_action)
        return Action.D

class Strategy_EXPLOITATIVE_287(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TFT-AC).
    A cooperative strategy that responds to opponents' past actions. Cooperates when opponents have been cooperative, and defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_length = game_description.n_rounds - 1
        self.k = math.ceil(self.history_length / 2)

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_history = history.opponent_actions[:, -1]
        cooperators = np.count_nonzero(opponent_history == True)
        defectors = len(opponent_history) - cooperators
        if defectors == 0:
            return Action.C
        elif cooperators > 0 and defectors < self.k:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_289(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFT-SA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.minimum_sustainable_stock = 2 * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock <= self.minimum_sustainable_stock:
            return Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        return Action(cooperators >= self.game_description.n_players // 2) if state.round_number < self.game_description.n_rounds else Action.C

class Strategy_EXPLOITATIVE_290(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((1, 1)), my_payoffs=np.zeros(1), opponent_actions=np.zeros((self.game_description.n_players + 1, 1)), opponent_payoffs=np.zeros((self.game_description.n_players + 1, 1)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history.my_actions[-1] = [state.round_number == 1] if history is None else history.my_actions[-1]
        self.history.my_payoffs = np.append(self.history.my_payoffs, state.current_stock / (2 * self.game_description.n_players) if self.history.my_actions[-1][0] else state.current_stock / self.game_description.n_players)
        cooperators = sum(self.history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

    def finalize_round(self):
        self.history.my_payoffs = np.append(self.history.my_payoffs, self.history.my_payoffs[-1]) if self.history.my_actions[-1][0] else 0

class Strategy_EXPLOITATIVE_291(BaseStrategy):
    """
    The Tit-for-Tat with Growth Adaptation (TfTGA) strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 2 * game_description.n_players

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_round = state.round_number - 1
        opponent_last_action = history.opponent_actions[last_round, 0]
        if state.current_stock < self.stock_threshold:
            return Action.D
        if opponent_last_action:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_292(BaseStrategy):
    """
    Implementation of Tit-for-Tat with Stock Adaptation (TfTSA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not self.history:
            return Action.C
        opponent_actions = [action for round in history.opponent_actions for action in round]
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        if not self.history:
            return Action.C
        stock = state.current_stock / self.game_description.capacity
        growth = (2 * state.current_stock - self.game_description.capacity) * (1 - stock)
        if all((action == Action.C for action in opponent_actions)):
            if stock >= 0.5 or growth >= self.game_description.capacity / self.game_description.n_players:
                return Action.C
            else:
                return Action.D
        if all((action == Action.D for action in opponent_actions)):
            if stock < 0.5 or growth < self.game_description.capacity / self.game_description.n_players:
                return Action.C
            else:
                return Action.D
        if np.mean([stock, growth]) > 0.5:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_293(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.cooperative_threshold = math.ceil(self.capacity / game_description.n_players)
        self.r = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r - 1:
            return Action.D
        total_consumption = np.sum(history.opponent_actions[:, :self.game_description.n_players] if history else np.zeros((1, self.game_description.n_players)))
        cooperative_threshold = max(self.cooperative_threshold, math.ceil(self.capacity / (self.r - state.round_number + 1)))
        if total_consumption <= cooperative_threshold:
            opponent_action = history.opponent_actions[-1, -1] if history else False
            return Action.C if opponent_action else Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_295(BaseStrategy):
    """A strategy that implements the Tit-for-Tat-Greed strategy for the Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ideal_consumption = game_description.capacity / (2 * game_description.n_players)
        self.growth_factor = 1.5
        self.punishment_factor = 1.2
        self.reward_factor = 0.8
        self.first_round = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            avg_consumption = np.mean(history.opponent_actions[:, -1])
            if avg_consumption > self.ideal_consumption * self.punishment_factor:
                return Action.D
            else:
                return Action.C
        avg_consumption = np.mean(history.opponent_actions[:, -self.game_description.n_rounds:])
        if avg_consumption < self.ideal_consumption or state.current_stock == 0:
            return Action.C
        if avg_consumption > self.ideal_consumption * (1 + self.growth_factor):
            self.ideal_consumption *= self.punishment_factor
        elif avg_consumption < self.ideal_consumption / (1 + self.growth_factor):
            self.ideal_consumption /= self.reward_factor
        if self.first_round:
            self.first_round = False
            return Action.C
        return np.where(avg_consumption > self.ideal_consumption, Action.D, Action.C)

class Strategy_EXPLOITATIVE_298(BaseStrategy):
    """
    Strategy that uses the Tit-for-Tat with Adaptive Forgiveness strategy in the Common Pool Resource Game.
    This strategy cooperates initially, retaliates against defection, and forgives opponents over time.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_counter = math.floor(game_description.n_players / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        opponent_action = history.opponent_actions[state.round_number - 1, 0]
        self.forgiveness_counter += int(opponent_action) - int(history.my_actions[state.round_number - 1])
        self.forgiveness_counter = max(self.forgiveness_counter, 0)
        self.forgiveness_counter = min(self.forgiveness_counter, math.floor(self.game_description.n_players / 2))
        if opponent_action == Action.C and self.forgiveness_counter > self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_299(BaseStrategy):
    """
    Tit-for-Tat-Greed (TfTG) strategy for the Common Pool Resource Game.
    Initializes cooperation, responds to average consumption and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds = self.game_description.n_rounds
        self.capacity = self.game_description.capacity
        self.n_players = self.game_description.n_players
        self.current_average_consumption = 0
        self.round_average_consumptions = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0:
            return action
        self.round_average_consumptions.append(self.current_average_consumption)
        total_consumed = sum([history.my_actions[i] for i in range(state.round_number)])
        self.current_average_consumption = total_consumed / state.round_number if state.round_number > 0 else 0
        optimum_consumption = self.capacity / (self.n_players * self.rounds)
        if state.round_number > 1:
            if self.current_average_consumption < optimum_consumption:
                action = Action.C
            elif self.current_average_consumption >= optimum_consumption:
                action = Action.D
        if state.round_number == self.rounds:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_300(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Growth Adaptation (TFT-GA)

    Summary: This strategy uses a cooperate-first approach and punishes defection, but adapts to the current stock level.
             It encourages cooperation while avoiding excessive depletion of resources.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        opponent_last_action = history.opponent_actions[-1][-1] if history else None
        current_stock = state.current_stock
        if opponent_last_action is None:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if opponent_last_action == Action.C else Action.D
        if current_stock < self.threshold and opponent_last_action == Action.D:
            return Action.D
        if current_stock < self.threshold:
            return Action.C
        return Action.C if opponent_last_action == Action.C else Action.D

class Strategy_EXPLOITATIVE_302(BaseStrategy):
    """
    Adaptive Tit-for-Tat (AF-Tit-for-Tat) strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.past_defections = 0
        self.first_encounter = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.first_encounter = True
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            if np.any(history.my_actions[-1]):
                return Action.C
            else:
                return Action.D
        elif self.first_encounter:
            return Action.C
        else:
            opponents_last_round = history.opponent_actions[-1]
            cooperators = np.count_nonzero(opponents_last_round)
            if np.any(history.my_actions[-2]) and (not opponents_last_round.all()):
                self.past_defections += 1
                if self.past_defections == self.game_description.n_players:
                    self.past_defections = 0
                    return Action.C
            else:
                self.past_defections = 0
            return Action(1 - np.array(history.my_actions[-1])).flatten()

class Strategy_EXPLOITATIVE_304(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    This strategy adaptively decides whether to cooperate or defect based on a Cooperation Threshold (CT).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_cooperation_rounds = 5
        self.ct_factor = 0.8
        self.average_consumption = np.zeros(game_description.n_rounds)
        self.current_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number > self.initial_cooperation_rounds:
            cooperation_threshold = np.mean(self.average_consumption[:state.round_number]) * self.ct_factor
            if self.current_stock >= self.game_description.capacity / (2 * self.game_description.n_players) and cooperation_threshold <= (history.my_payoffs[-1] + history.opponent_payoffs[-1, :].sum()) / 2:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_305(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.last_opponent_action = np.mean(history.opponent_actions[-1])
        if self.last_opponent_action:
            return Action.C
        elif self.last_opponent_action and state.round_number > 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_306(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) Strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.last_round = -1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not self.last_round:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            if not self.has_cooperated(history):
                return Action.D
        if self.last_opponent_action is None or self.last_round != state.round_number - 1:
            self.last_opponent_action = sum(history.opponent_actions[state.round_number - 1, :]) >= self.game_description.n_players // 2
        if self.last_opponent_action:
            return Action.C
        return Action.D

    def has_cooperated(self, history: PlayerHistory) -> bool:
        """
        Checks whether an opponent has cooperated during the game so far.
        :param history: player history of the current game state
        :return: boolean indicating if any opponent has ever cooperated
        """
        return sum(history.my_actions[self.last_round + 1, :].astype(int)) > 0

class Strategy_EXPLOITATIVE_307(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_cooperation_threshold = self.game_description.capacity / self.game_description.n_players
        self.probability_to_cooperate = 1.0
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        previous_action = Action(int(history.my_actions[-1]))
        current_stock = state.current_stock
        if self.round_number > 1 and self.probability_to_cooperate < 1 and (current_stock >= self.min_cooperation_threshold):
            return Action.C
        elif previous_action == Action.C:
            return Action.C
        elif previous_action == Action.D:
            if current_stock > self.min_cooperation_threshold:
                return Action.C
            self.probability_to_cooperate *= random.random()
            if random.uniform(0, 1) < self.probability_to_cooperate:
                return Action.C
        self.round_number += 1
        self.min_cooperation_threshold -= self.min_cooperation_threshold / self.game_description.n_rounds * self.round_number
        return Action.D

class Strategy_EXPLOITATIVE_308(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy in Common Pool Resource Game.
    Encourages cooperation, but can also punish opponents who consistently defect by defecting themselves.
    Adapts cooperation threshold based on average level of cooperation observed.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 2 * game_description.n_players / (2 * game_description.n_players + game_description.n_players - 1)
        self.memory = np.zeros((game_description.n_rounds,))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperation_ratio = np.mean(history.my_actions[-self.memory.size:])
        if cooperation_ratio >= self.cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_309(BaseStrategy):
    """
    Tit-for-Tat with Growth Adaptation (TfT-GA) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_length = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_actions = history.my_actions[state.round_number - 1]
        my_payoffs = history.my_payoffs[state.round_number - 1]
        if state.round_number == self.game_description.n_rounds and state.current_stock >= self.game_description.n_players * 2:
            return Action.C
        if len(history.opponent_actions) > state.round_number - 1:
            current_opponent_action = history.opponent_actions[state.round_number - 1, 0]
            previous_opponent_actions = history.opponent_actions[state.round_number - 2]
            if len(previous_opponent_actions) > 0:
                self.punishment_length = sum([1 for action in previous_opponent_actions])
        if current_opponent_action == Action.C:
            return Action.C
        elif self.punishment_length > 0:
            self.punishment_length -= 1
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_310(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(game_description.n_players * 2 / 3)
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.opponent_history.append(history.opponent_actions[-1].tolist())
        if state.round_number == 0:
            return Action.C
        opponent_action = self.opponent_history[-1][-1] if len(self.opponent_history) > 0 else None
        if opponent_action is None or state.round_number == len(self.opponent_history):
            return Action.C
        elif opponent_action:
            return Action.C if opponent_action == Action.C else Action.D
        elif state.current_stock < self.threshold:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_311(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_coop_threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        self.state = None
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None):
        if history is None and state is not None:
            self.state = state
            return Action.C
        self.state = state
        if state.round_number == self.state.round_number - 1:
            average_cooperation = np.mean(history.opponent_actions[-1])
            if average_cooperation > 0.5:
                return Action.C
            else:
                return Action.D
        cooperators = np.sum(history.opponent_actions[-1])
        average_cooperation = cooperators / self.game_description.n_players
        if average_cooperation > self.capacity_coop_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_312(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfTAC)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history is not None else np.zeros(self.n_players, dtype=bool)
        last_round_cooperators = sum(opponent_actions)
        if state.current_stock < 2 * self.n_players:
            return Action.D
        elif last_round_cooperators >= self.n_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_313(BaseStrategy):
    """
    Implementation of Tit-for-Tat-Growth (TfT-G) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.history = PlayerHistory(my_actions=np.empty((1,), dtype=bool), my_payoffs=np.empty((1,), dtype=np.float64), opponent_actions=np.empty((self.game_description.n_players, self.game_description.n_rounds), dtype=bool), opponent_payoffs=np.empty((self.game_description.n_players, self.game_description.n_rounds), dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        """
        :param state: Current game state object
        :param history: History of the current player's actions and opponent's actions
        :return: The chosen action for this round (Action.C or Action.D)
        """
        if state.round_number == 0:
            self.last_opponent_action = None
            return Action.C
        elif history is None:
            self.history.my_actions[0] = False
            self.history.my_payoffs[0] = 0
            for i, opponent_actions in enumerate(self.history.opponent_actions):
                self.history.opponent_actions[:, i] = opponent_actions
                self.history.opponent_payoffs[:, i] = np.zeros(self.game_description.n_rounds)
            self.last_opponent_action = None
            return Action.C
        else:
            if self.last_opponent_action is not None and self.history.opponent_actions[-1, -1] == self.last_opponent_action:
                action = Action.C if self.last_opponent_action == Action.C else Action.D
                self.last_opponent_action = action
            elif np.sum(history.opponent_actions[-1, :]) < self.game_description.n_players // 2:
                action = Action.D
                self.last_opponent_action = Action.D
            else:
                action = Action.C
                self.last_opponent_action = Action.C
            self.history.my_actions = np.append(self.history.my_actions, [action], axis=0)
            if action == Action.D:
                self.history.my_payoffs = np.append(self.history.my_payoffs, [state.current_stock / (2 * self.game_description.n_players)], axis=0)
            else:
                self.history.my_payoffs = np.append(self.history.my_payoffs, [state.current_stock / self.game_description.n_players], axis=0)
            return action

class Strategy_EXPLOITATIVE_315(BaseStrategy):
    """
    Tit-for-Tat with Gradual Cooperation (TFTGC) strategy for Common Pool Resource Game.
    The strategy cooperates initially to set a cooperative tone, then adjusts its actions based on opponents' previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round = 0
        self.opponent_history = np.zeros((1, game_description.n_players), dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.round += 1
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        self.round += 1
        opponent_actions = history.opponent_actions[history.my_actions.shape[0] - 1, :]
        if np.count_nonzero(opponent_actions) > (self.game_description.n_players - 1) // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_316(BaseStrategy):
    """
    Simple Tit-for-Tat with Adaptive Greed (TfT-AG) strategy for Common Pool Resource Game.
    Encourages cooperation when resources are abundant, punishes uncooperative opponents when resources are scarce.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(game_description.n_players * 2 / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock <= self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_317(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFT-SA) strategy in Common Pool Resource Game.
    Balances cooperation and defection based on current stock level and opponent's actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self._history = PlayerHistory(my_actions=np.array([[False]], dtype=np.bool), my_payoffs=np.array([0], dtype=np.float64), opponent_actions=np.array([[False] for _ in range(self.game_description.n_players)], dtype=np.bool), opponent_payoffs=np.array([0 for _ in range(self.game_description.n_players)], dtype=np.float64))
        self._history.my_actions = np.vstack([self._history.my_actions, [False]])
        if state.round_number == 0:
            return Action.C
        opponent_actions = self._history.opponent_actions[:, -1]
        current_player = state.round_number % self.game_description.n_players + 1
        if all((opponent_action == Action.C for opponent_action in opponent_actions)):
            return Action.C
        elif any((opponent_action == Action.D for opponent_action in opponent_actions)):
            return Action.D
        stock = state.current_stock
        min_sustainable_stock = 2 * self.game_description.n_players
        if stock >= min_sustainable_stock or state.round_number == self.game_description.n_rounds:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_318(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = np.mean(np.array([random.random() for _ in range(game_description.n_rounds)]))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = sum([Action.D if action else 0 for round_history in history.opponent_actions[:state.round_number] for action in round_history])
        average_consumption = total_consumption / state.round_number
        if average_consumption > self.cooperation_threshold:
            return Action.D
        else:
            self.cooperation_threshold = self.cooperation_threshold * 0.9 + average_consumption * 0.1
            return Action.C

class Strategy_EXPLOITATIVE_319(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game. Cooperates in the first round and retaliates if an opponent defected in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_opponent_actions = history.opponent_actions[-1] if history is not None else [False for _ in range(self.game_description.n_players)]
        last_opponent_defectors = sum(last_opponent_actions)
        return Action.C if last_opponent_defectors == 0 else Action.D

class Strategy_EXPLOITATIVE_320(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TfT-ACT)
    Strategy Description: A cooperative strategy that adapts its cooperation threshold based on opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = self.game_description.capacity / self.game_description.n_players
        self.small_constant = 0.95

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        cooperation_in_last_round = sum(history.opponent_actions[-1]) >= self.game_description.n_players - 1
        if cooperation_in_last_round:
            action = Action.C
            if state.current_stock < self.cooperation_threshold:
                self.cooperation_threshold *= 1 - self.small_constant
        else:
            action = Action.D
            self.cooperation_threshold *= 1 - self.small_constant
        if state.current_stock < 0:
            state.current_stock = 0
            self.cooperation_threshold /= 2
        return action

class Strategy_EXPLOITATIVE_321(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Forgiveness (TfTAF) strategy for Common Pool Resource Game.
    Cooperates if opponent cooperated in the previous round, defects otherwise. Implements forgiveness and defection thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_period = int(math.floor(game_description.n_rounds * 0.3))
        self.defection_threshold = int(math.ceil(self.game_description.n_rounds * 0.15))
        self.cooperation_counter = 0
        self.defection_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[-1, 0] if history else False
        if opponent_action and self.cooperation_counter < self.forgiveness_period:
            self.cooperation_counter += 1
            return Action.C
        elif not opponent_action and self.defection_counter >= self.defection_threshold:
            return Action.D
        else:
            self.cooperation_counter = max(self.cooperation_counter - 1, 0)
            self.defection_counter = 0
            return Action.D

class Strategy_EXPLOITATIVE_322(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.window_size = int(self.game_description.n_rounds * 0.1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = np.mean(history.opponent_actions[-self.window_size:, :] * 1)
        self.cooperation_threshold = cooperators * self.cooperation_threshold
        opponent_action = history.opponent_actions[state.round_number - 1, 0]
        if opponent_action:
            return Action.C if state.current_stock / (2 * self.game_description.n_players) >= self.cooperation_threshold else Action.D
        elif history.opponent_actions[-1, 0] and self.cooperation_threshold > 0:
            self.cooperation_threshold -= 1 / self.game_description.n_players
        return Action.D if state.current_stock == 0 else Action.C

class Strategy_EXPLOITATIVE_323(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfTAC)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        last_round = len(history.my_actions) - 1
        last_opponent_action = history.opponent_actions[last_round, 0]
        if last_round == self.game_description.n_rounds - 1:
            if state.current_stock >= self.threshold * (self.game_description.capacity / self.threshold):
                return Action.C
            else:
                return Action.D
        if last_opponent_action and history.my_actions[last_round - 1] == Action.C:
            return Action.C
        elif last_opponent_action and len(np.where(history.my_actions[:last_round] == Action.D)[0]) < 2:
            return Action.D
        elif state.current_stock < self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_324(BaseStrategy):
    """
    An adaptive fitness-proportionate Tit-for-Tat strategy for the Common Pool Resource Game.
    The strategy cooperates initially and tends to cooperate when the stock level is high, but defects when the stock level is low or the opponent's behavior indicates defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_cooperation = self.game_description.n_players // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_opponent_cooperation = np.sum(history.opponent_actions[:state.round_number, :]) if history else self.min_cooperation * state.round_number
        current_stock_cooperative_level = state.current_stock / (2 * self.game_description.n_players)
        avg_opponent_cooperative_level = total_opponent_cooperation / state.round_number if state.round_number > 0 else 0
        cooperate = False
        if current_stock_cooperative_level > 0.5 and avg_opponent_cooperative_level > 0.7:
            cooperate = True
        elif current_stock_cooperative_level < 0.3 or avg_opponent_cooperative_level < 0.3:
            cooperate = False
        else:
            cooperate = history and history.opponent_actions[-1, -1]
        return Action(int(cooperate))

class Strategy_EXPLOITATIVE_325(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Stock Awareness (TFT-ASA) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.window_size = int(math.ceil(game_description.n_rounds * 0.9))
        self.stock_history = np.zeros((self.window_size,))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        actions = history.opponent_actions[-1, :]
        total_cooperators = sum(actions)
        stock_average = np.mean(self.stock_history[-self.window_size:])
        stock_shortage = (state.current_stock - stock_average * self.game_description.capacity) / self.game_description.capacity
        if total_cooperators < self.game_description.n_players // 2 or stock_shortage > 0.5:
            return Action.D
        return Action.C

    def update_history(self, state: CommonPoolState, history: PlayerHistory) -> None:
        self.stock_history = np.roll(self.stock_history, -1)
        self.stock_history[-1] = state.current_stock

class Strategy_EXPLOITATIVE_326(BaseStrategy):
    """
    Tit-for-Tat with Stock Growth Adaptation strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.window_size = int(self.game_description.n_players // 4)
        self.min_acceptable_growth_rate = 0.1
        self.threshold = self.game_description.capacity * (2 / self.game_description.n_players) * 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        average_consumption = np.mean(history.opponent_actions[:, :-self.window_size].sum(axis=1)) if history else 0
        if average_consumption < self.threshold or state.current_stock / self.game_description.capacity * self.min_acceptable_growth_rate <= np.sqrt(random.random()):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_327(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Forgiveness (TfTf)
    Description: Cooperates initially, responds with same action as opponent if they cooperated in the previous round. If opponent defected, defects this round but forgives them by cooperating in the following round. Defects if the current stock level is below capacity / 2n or above capacity / 2n in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        cooperators = sum(opponent_actions)
        if state.round_number == 1 or (cooperators >= self.game_description.n_players // 2 and state.round_number < self.game_description.n_rounds):
            return Action.C if history.my_actions[-1] == opponent_actions[0] else Action.D
        elif state.round_number >= self.game_description.n_rounds:
            stock = state.current_stock
            capacity = self.game_description.capacity
            return Action.C if capacity - stock > capacity // (2 * self.game_description.n_players) else Action.D
        else:
            self.forgiveness_counter += 1 if history.my_actions[-1] == Action.D and cooperators < self.game_description.n_players else 0
            return Action.C if history.my_actions[-1] == opponent_actions[0] or self.forgiveness_counter >= self.game_description.n_players else Action.D

class Strategy_EXPLOITATIVE_328(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (A-TFT)
    This strategy cooperates in the first round and imitates the opponent's strategy from the previous round in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        if sum(opponent_actions) >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_329(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = math.floor(self.game_description.n_rounds / 2)
        self.history = PlayerHistory(my_actions=np.zeros(self.game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(self.game_description.n_rounds), opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history.my_actions[state.round_number] = Action.C == self.__class__
        self.update_cooperation_threshold(state)
        opponent_cooperators = sum(self.history.opponent_actions[-1, :])
        if state.round_number == self.game_description.n_rounds - 1 or opponent_cooperators >= self.cooperation_threshold:
            return Action.C
        if opponent_cooperators < self.cooperation_threshold - self.game_description.n_players:
            return Action.D
        return Action.C

    def update_cooperation_threshold(self, state):
        if state.round_number < self.game_description.n_rounds // 2:
            self.cooperation_threshold += 1
        elif sum(self.history.my_actions[:state.round_number]) < self.cooperation_threshold * (self.game_description.n_players - 1):
            self.cooperation_threshold -= 1

class Strategy_EXPLOITATIVE_331(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat with Stock Growth (ATTSG)
    Strategy Description: This strategy uses a cooperative approach in the initial round and responds to opponents' actions based on their history. It punishes defection while encouraging cooperation and avoiding excessive stock depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.history = history
        last_round = len(self.history.my_actions) - 1
        last_action = self.history.my_actions[-1]
        last_opponent_actions = self.history.opponent_actions[-1, :]
        if state.round_number == last_round + 1:
            return Action.C
        if last_action == Action.D and (len(self.history.my_actions) < self.game_description.n_players or np.count_nonzero(last_opponent_actions[:-1]) > self.game_description.n_players - 1):
            return Action.D
        elif last_action == Action.C:
            if state.current_stock < self.game_description.capacity / (2 * self.game_description.n_players):
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_332(BaseStrategy):
    """
    Strategy name: Tit-for-Tat-Growth (TfT-G)
    This strategy is an implementation of the Tit-for-Tat-Growth game theory strategy for Common Pool Resource Games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(math.floor((game_description.capacity - 2 * game_description.n_players) / (2 * game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        opponent_cooperation = sum(history.opponent_actions[-1])
        stock_level = state.current_stock / self.game_description.capacity
        if opponent_cooperation >= self.game_description.n_players // 2:
            return Action.C
        if opponent_cooperation == 0 or stock_level < self.threshold:
            return Action.D
        if stock_level > self.threshold and len(history.opponent_actions) >= 2:
            cooperation_payoff = np.mean(history.my_payoffs[np.where(history.my_actions == Action.C)[0]][:-1])
            defection_payoff = np.mean(history.my_payoffs[np.where(history.my_actions == Action.D)[0]][:-1])
            if cooperation_payoff > defection_payoff:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_333(BaseStrategy):
    """
    A Tit-for-Tat Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = np.mean(history.opponent_actions[:, -1]) if history else 0
        return Action(int(opponent_action))

class Strategy_EXPLOITATIVE_334(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Growth Adaptation (TfT-GA) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.c = int(math.ceil(game_description.n_players / 2))
        self.d = int(math.ceil(game_description.n_players / 2))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None:
            last_c = sum(history.opponent_actions[-self.c:, :].sum(axis=1) == 1)
            last_d = sum(history.opponent_actions[-self.d:, :].sum(axis=1) == 0)
            if last_c >= self.c and last_d == 0:
                return Action.C
            elif last_d >= self.d and last_c == 0:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_335(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_history = {}
        self.last_opponent_cooperators = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round_history[state.round_number - 1] = np.mean(history.opponent_actions[-1, :])
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        last_round = self.round_history[state.round_number - 1]
        last_opponent_cooperators = int(last_round >= 0.5)
        if last_opponent_cooperators > self.last_opponent_cooperators:
            self.last_opponent_cooperators += 1
            return Action.C
        elif last_opponent_cooperators < self.last_opponent_cooperators:
            self.last_opponent_cooperators -= 1
            return Action.D
        if np.random.rand() < 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_336(BaseStrategy):
    """
    A Tit-for-Tat adaptive strategy that cooperates in the first round and imitates the opponent's action from the previous round thereafter, unless it is one of the final three rounds, in which case it always cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.final_rounds = self.game_description.n_rounds - 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_action = np.mean(history.opponent_actions[:, -1])
        if state.round_number < self.final_rounds:
            return Action(int(opponent_action))
        return Action.C

class Strategy_EXPLOITATIVE_341(BaseStrategy):
    """
    Tit-for-Tat Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            self.last_round = state.round_number > self.game_description.n_players * self.game_description.n_rounds
            if not self.last_round and history is not None:
                cooperators = np.sum(history.opponent_actions[-1, :])
                return Action.C if cooperators >= self.game_description.n_players // 2 else Action.D
        return Action.C

class Strategy_EXPLOITATIVE_342(BaseStrategy):
    """
    A strategy that implements the Adaptive Tit-for-Tat approach in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.defection_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == len(history.opponent_actions):
            return Action.C
        self.defection_counter = 0
        current_round = history.opponent_actions[-1]
        self.last_opponent_action = current_round
        if not current_round:
            self.defection_counter += 1
            if self.defection_counter >= self.game_description.n_players // 3:
                return Action.D
        return current_round

class Strategy_EXPLOITATIVE_343(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.current_stock = self.capacity
        self.CT = self.capacity / (2 * self.n_players)
        self.last_opponent_defected = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = sum([state.current_stock - self.current_stock for _ in range(state.round_number)])
        current_stock = state.current_stock
        if current_stock <= 0:
            self.CT = self.capacity / (2 * self.n_players)
            self.last_opponent_defected = False
            return Action.C
        if current_stock >= self.CT and state.round_number != self.r:
            if current_stock > self.CT and (not self.last_opponent_defected):
                self.CT *= 1.1
            elif self.last_opponent_defected:
                self.CT = self.capacity / (2 * self.n_players)
            return Action.C
        self.last_opponent_defected = True
        return Action.D

class Strategy_EXPLOITATIVE_344(BaseStrategy):
    """
    A strategy named Tit-for-Tat with Adaptive Cooperation (TfTA-C).
    This strategy cooperates initially to encourage cooperation and then adapts its behavior based on opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []
        self.cooperation_threshold = 0.5
        self.round_cooperated = 0
        self.round_defected = 0
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.opponent_history = history.opponent_actions.flatten().tolist()
            self.round_cooperated = sum(self.opponent_history)
            self.round_defected = len(self.opponent_history) - self.round_cooperated
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if all((action == Action.C for action in self.opponent_history)):
                return Action.C
            else:
                return Action.D
        cooperation_probability = self.cooperation_threshold + (self.game_description.n_rounds - state.round_number) * 0.1 - (state.round_number + 1) * 0.05
        if random.random() < cooperation_probability:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_346(BaseStrategy):
    """Fischer's strategy for the Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold1 = 0.2 * (game_description.capacity / game_description.n_players)
        self.threshold2 = 0.4 * (game_description.capacity / game_description.n_players)
        self.threshold3 = 0.6 * (game_description.capacity / game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.D if state.current_stock == self.game_description.capacity else Action.C
        total_consumption = np.sum(history.my_actions) * (state.current_stock / self.game_description.n_players)
        if total_consumption < self.game_description.capacity / 2:
            return Action.C if state.current_stock - self.threshold3 > 0 else Action.D
        elif total_consumption >= self.game_description.capacity / 2:
            return Action.D if state.current_stock - self.threshold2 > 0 else Action.C

class Strategy_EXPLOITATIVE_347(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Growth Awareness (TfTGA)
    Strategy Description: This strategy follows the Tit-for-Tat principle while considering the current stock level and the opponent's behavior from previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity * 0.75
        self.history_length = int(self.game_description.n_rounds / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        total_actions = len(history.opponent_actions) if history else state.round_number
        cooperative_count = sum([1 for row in history.opponent_actions[:total_actions - self.history_length] if sum(row) >= self.game_description.n_players // 2])
        if state.current_stock < self.threshold:
            return Action.D
        elif total_actions - cooperative_count > self.history_length:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_348(BaseStrategy):
    """
    A strategy that cooperates in the first round and thereafter mimics the average cooperation of other players from the previous rounds, while also considering the current stock level to prevent excessive depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = float(game_description.capacity)
        self.n_players = game_description.n_players
        self.minimum_stock_level = 2 * self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        stock_remaining = state.current_stock - (state.round_number - 1) * self.n_players
        average_cooperative_actions = np.mean(history.my_actions[-self.game_description.n_rounds:])
        if stock_remaining < self.minimum_stock_level or (average_cooperative_actions <= 0.5 and stock_remaining <= self.capacity - 4 * (self.n_players - 1)):
            return Action.D
        if average_cooperative_actions > 0.5 and stock_remaining >= self.capacity - 4 * (self.n_players - 1):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_350(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((game_description.n_rounds,), dtype=bool), np.zeros((game_description.n_rounds,), dtype=np.float64), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players), dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history.my_actions[0] = True
        else:
            my_last_action = self.history.my_actions[-1]
            opponent_last_actions = history.opponent_actions[-1, :]
            if state.round_number == 0:
                self.history.my_actions[0] = True
            elif state.round_number == self.game_description.n_rounds - 1:
                self.history.my_actions[-1] = True
            elif my_last_action:
                self.history.my_actions[state.round_number] = opponent_last_actions.mean() > 0.5
            else:
                self.history.my_actions[state.round_number] = np.logical_not(opponent_last_actions).mean() > 0.5
        return Action(int(self.history.my_actions[-1]))

class Strategy_EXPLOITATIVE_351(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        self._update_cooperation_threshold(history)
        if self.last_opponent_action is None or history.opponent_actions[-1].all():
            self.last_opponent_action = True
            return Action.C
        elif self.last_opponent_action:
            if self.cooperation_threshold > 0.5:
                self.last_opponent_action = True
                return Action.C
            else:
                self.last_opponent_action = False
                return Action.D
        elif self.cooperation_threshold < 0.5:
            self.last_opponent_action = False
            return Action.D
        else:
            self.last_opponent_action = True
            return Action.C

    def _update_cooperation_threshold(self, history: PlayerHistory) -> None:
        cooperation_count = np.sum(history.opponent_actions[:-1].T.flatten())
        defection_count = len(history.opponent_actions) - cooperation_count
        self.cooperation_threshold += (cooperation_count - defection_count) / self.game_description.n_rounds
        self.cooperation_threshold = max(min(self.cooperation_threshold, 1), 0)

class Strategy_EXPLOITATIVE_352(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_cooperation = True
        self.c = 0
        self.CT = None
        self.current_round = 1
        self.penalty_factor = 2
        self.recent_stock_levels = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if self.initial_cooperation and self.CT is None:
            self.initial_cooperation = False
            self.CT = state.current_stock * (1 + self.penalty_factor) / self.game_description.n_players
        if state.round_number == 0 and history is not None:
            action = Action.C
        elif self.current_round > 1:
            c = sum(history.opponent_actions[-self.game_description.n_rounds:, :].flatten()) / self.game_description.n_rounds
            if c >= self.CT and history.my_payoffs[-1] >= self.CT or (c > 0 and self.recent_stock_levels):
                action = Action.C
            elif c < self.CT:
                action = Action.D
            if len(self.recent_stock_levels) >= self.game_description.n_rounds // 4 and self.CT is not None:
                self.recent_stock_levels.pop()
                self.recent_stock_levels.append(state.current_stock)
        if state.round_number == self.game_description.n_rounds:
            if self.CT is not None and c >= self.CT or (c > 0 and self.recent_stock_levels):
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_353(BaseStrategy):
    """
    A Tit-for-Tat strategy with growth adjustment for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_counter = 0
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number - 1
        opponent_actions = history.opponent_actions[current_round]
        self.last_opponent_action = opponent_actions[-1]
        if opponent_actions.all():
            return Action.C
        if not state.current_stock:
            return Action.C
        if current_round == self.game_description.n_rounds - 1:
            return Action.C
        if self.last_opponent_action == Action.D:
            self.punishment_counter += 1
            if self.punishment_counter > 1:
                return Action.D
        else:
            self.punishment_counter = 0
        return Action.C

class Strategy_EXPLOITATIVE_354(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Rate (TFTAC) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.m = int(game_description.n_players // 2)
        self.c = 1
        self.C = game_description.n_players - 1
        self. = 0.8
        self.EMA_cooperation = np.zeros(self.m + 1)
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            self.EMA_cooperation = np.zeros(self.m + 1)
            self.round_number += 1
            return Action.C
        opponent_actions = history.opponent_actions[-self.m:, -1]
        self.EMA_cooperation = np.array([ * opponent_action + (1 - ) * self.EMA_cooperation[1:] for , opponent_action in zip(self. * np.ones(self.m), opponent_actions)])
        cooperators = self.EMA_cooperation.sum()
        cooperation_rate = cooperators / self.m
        cooperation_threshold = math.floor((self.round_number + 1) / (self.game_description.n_rounds * self.C))
        self.c = min(cooperation_threshold, self.C)
        if cooperation_rate >= self.c / self.C:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_357(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number < self.game_description.n_rounds - 1:
            last_opponent_action = history.opponent_actions[-1, -1] if self.last_opponent_action is None else self.last_opponent_action
            self.last_opponent_action = last_opponent_action
            return Action(int(last_opponent_action == Action.C))
        elif history is not None and state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_358(BaseStrategy):
    """
    Adaptive Tit-for-Tat (A-TfT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperators = np.zeros(game_description.n_rounds - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_cooperators[-1] = sum(history.opponent_actions[-1])
        round_num = min(state.round_number, len(self.opponent_cooperators) - 1)
        cooperators = self.opponent_cooperators[round_num]
        return Action.C if cooperators == self.game_description.n_players else Action.D

class Strategy_EXPLOITATIVE_359(BaseStrategy):
    """
    A common pool resource game strategy implementing the Tit-for-Tat with Adaptive Cooperative Quotient (TFT-ACQ) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CQ = 1.0
        self.state = None
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        self.state = state
        self.history = history if state.round_number > 0 else None
        if not self.history and state.round_number == 0:
            return Action.C
        opponent_actions = self.history.opponent_actions[-1] if self.history else [False] * self.game_description.n_players
        last_round_cooperators = sum(opponent_actions)
        if self.state.round_number == self.game_description.n_rounds:
            return Action(int(self.CQ > 0.5))
        new_CQ = self.CQ
        action = Action.C
        for round_index in range(len(opponent_actions) - 1, -1, -1):
            if opponent_actions[round_index]:
                new_CQ += 0.01
            else:
                new_CQ -= 0.01
            action = Action(int(new_CQ > 0.5))
            if round_index == last_round_cooperators:
                break
        return action

class Strategy_EXPLOITATIVE_360(BaseStrategy):
    """
    A common pool resource game strategy implementation of Tit-for-Tat-Growth (TfT-G).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds = self.game_description.n_rounds - 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        avg_consumption = np.mean(history.opponent_actions[:, 1:].sum(axis=1)) / self.rounds
        if state.round_number == self.game_description.n_rounds - 1 or avg_consumption < self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_362(BaseStrategy):
    """
    A Tit-for-Tat strategy with growth adaptation for common pool resource games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity
        self.n_players = self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history is not None else np.zeros(self.n_players, dtype=bool)
        current_stock = state.current_stock
        if np.sum(opponent_actions) < self.n_players // 2:
            return Action.D
        if current_stock > self.capacity or current_stock <= 0:
            return Action.D
        return Action.C if opponent_actions[-1] else Action.D

class Strategy_EXPLOITATIVE_363(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFTAT) Strategy
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        self.trust_building_rounds = int(math.sqrt(self.game_description.n_rounds))
        self.opponent_actions_memory = []
        self.cooperator_counts = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.opponent_actions_memory = [[False] * self.game_description.n_players for _ in range(self.game_description.n_rounds)]
            return Action.C
        current_average_consumption = np.mean(history.opponent_payoffs[-1]) if history.my_actions[-1] else 0
        if current_average_consumption < self.threshold:
            return Action.C
        else:
            return Action.D
        opponent_cooperation_rate = 0
        for round_num in range(state.round_number - self.trust_building_rounds, state.round_number):
            if history.my_actions[round_num]:
                cooperators = sum(history.opponent_actions[round_num])
                opponent_cooperation_rate += (cooperators + 1) / (self.game_description.n_players + 1)
            else:
                opponent_cooperation_rate += 0
        opponent_cooperation_rate /= self.trust_building_rounds
        if round(opponent_cooperation_rate, 2) > self.threshold:
            self.cooperator_counts[state.round_number - self.trust_building_rounds] = 1
        if state.round_number in self.cooperator_counts:
            return history.opponent_actions[-self.trust_building_rounds + 1][state.round_number - self.trust_building_rounds]
        if not any(history.opponent_actions[:, state.round_number]):
            return Action.D
        return history.opponent_actions[-1][state.round_number]

class Strategy_EXPLOITATIVE_364(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Dynamics (A-TFTSD) strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / 2
        self.history = PlayerHistory(my_actions=None, my_payoffs=None, opponent_actions=None, opponent_payoffs=None)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.history = history
        action = Action.C
        if state.round_number == len(self.history.opponent_actions):
            capacity_remaining = self.game_description.capacity - self.history.my_payoffs[-1]
            if capacity_remaining < self.threshold:
                action = Action.D
        else:
            current_stock = state.current_stock
            previous_round_cooperators = sum(self.history.opponent_actions[-1])
            if current_stock <= self.threshold and previous_round_cooperators < self.game_description.n_players - 1:
                action = Action.D
            elif current_stock > self.threshold:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_365(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_rate = np.zeros(self.game_description.n_rounds)
        self.opponent_actions = np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[state.round_number - 1] if history is not None else self.opponent_actions[state.round_number - 1]
        cooperators = np.sum(opponent_actions)
        cooperative_rate = (cooperators + 1) / (state.round_number + 2)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif cooperative_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_366(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_act = 0.8
        self.max_rounds = game_description.n_rounds
        self.number_of_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.number_of_rounds += 1
        act = self.initial_act * (1 - self.number_of_rounds / self.max_rounds)
        cooperators = np.sum(history.opponent_actions[:, :self.game_description.n_players - 1].T) if history else 0
        if cooperators >= self.game_description.n_players // 2 and history and (np.mean(history.opponent_actions[-1, :]) > act):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_367(BaseStrategy):
    """
    A Tit-for-Tat strategy for the Common Pool Resource Game.
    This strategy initially cooperates, and then responds to an opponent's previous action:
    - Cooperate if the opponent cooperated in the last round
    - Defect otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.round_number += 1
        if self.round_number == self.game_description.n_rounds:
            return Action.C
        last_round = history.opponent_actions[-1]
        cooperators = np.sum(last_round)
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_368(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFTSA) strategy for Common Pool Resource Game.
    Cooperates initially and adapts to opponent's behavior, punishing excessive defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.adaptive_parameter = 0
        self.last_opponent_action = Action.C

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C
        opponent_actions = history.opponent_actions if history is not None else np.zeros((self.game_description.n_rounds, 1), dtype=np.bool_)
        opponent_actions[-1] = self.last_opponent_action
        total_defections = sum(opponent_actions[:, 0])
        adaptive_consumption = self.game_description.n_players // 2 if total_defections <= self.game_description.n_players // 2 else self.game_description.n_players // 4
        if history is not None:
            if opponent_actions[-1, 0] == Action.C:
                self.adaptive_parameter += 1
            elif opponent_actions[-1, 0] == Action.D:
                self.adaptive_parameter -= 1
            self.adaptive_parameter = max(self.adaptive_parameter, 0)
            self.adaptive_parameter = min(self.adaptive_parameter, self.game_description.n_players - 1)
        self.last_opponent_action = opponent_actions[-1, 0]
        return Action.D if self.last_opponent_action == Action.C and opponent_actions[-1, 0] == Action.D else Action.C

class Strategy_EXPLOITATIVE_370(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth Consideration (ATfTSGC) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = self.game_description.n_players
        self.capacity = self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_actions = history.opponent_actions[-1]
        num_defectors = np.count_nonzero(opponents_actions)
        if num_defectors > (self.n_players - 1) // 2:
            return Action.D
        elif sum(opponents_actions) >= (self.n_players - 1) // 2:
            return Action.C
        else:
            return Action.D if history.opponent_actions[-1, -1] == Action.D else Action.C
        if state.round_number == self.game_description.n_rounds:
            cooperators = sum(history.opponent_actions[:, :self.game_description.n_players - 1].T[-1])
            return Action.C if cooperators > (self.n_players - 1) // 2 else Action.D

class Strategy_EXPLOITATIVE_371(BaseStrategy):
    """
    Tit-for-Tat Strategy (TFTS) for the Common Pool Resource Game.
    Cooperates in the first round and imitates opponent's last action in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.min_sustainable_stock = 2 * self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or history.my_actions is None or len(history.my_actions) < self.game_description.n_rounds:
            return Action.C
        opponent_action = history.opponent_actions[-1, 0] if state.round_number == 1 else history.opponent_actions[-2, 0]
        stock_level = state.current_stock
        if stock_level < self.min_sustainable_stock:
            return Action.D
        return opponent_action

class Strategy_EXPLOITATIVE_373(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Forgiveness (TfTAF)
    This strategy implements a cooperative approach that maintains cooperation when it benefits the player while punishing excessive exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = game_description.n_players * game_description.capacity / game_description.n_rounds
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or (history and len(history.opponent_actions) == 0):
            return Action.C
        last_round = state.round_number - 1
        opponent_action = history.opponent_actions[last_round, self.get_opponent_index()]
        own_action = history.my_actions[last_round]
        consumption = history.opponent_payoffs[last_round, self.get_opponent_index()] / state.current_stock if opponent_action else 0
        if opponent_action == own_action:
            return Action.C
        elif not opponent_action and consumption < self.average_consumption:
            return Action.C
        elif opponent_action and consumption >= self.average_consumption:
            return Action.D
        else:
            return Action.D

    def get_opponent_index(self) -> int:
        """
        Returns the index of the opposing player in the history data structure, starting from 1 (the other player besides self).
        """
        return 1 if self == self.__class__ else 0

class Strategy_EXPLOITATIVE_374(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_counter = {i: 0 for i in range(1, self.game_description.n_players + 1)}
        self.average_cooperation = np.zeros(self.game_description.n_rounds)
        self.Ct = [0] * self.game_description.n_rounds
        self.d, self.g = (0.1, 0.05)

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0 and history is None:
            return Action.C
        elif round_number == 1 or round_number == self.game_description.n_rounds:
            cooperation = np.mean(history.opponent_actions[0])
            self.cooperation_counter[self.__class__] = int((self.game_description.n_players - 1) * cooperation + 1)
            return Action.C if self.cooperation_counter[self.__class__] >= self.Ct[-1] else Action.D
        else:
            cooperation = np.mean(history.opponent_actions[-1])
            self.average_cooperation[round_number - 1] = self.average_cooperation[round_number - 2] if round_number > 1 else cooperation
            self.Ct[round_number - 1] = max(min(self.Ct[round_number - 2] + (cooperation > self.average_cooperation[round_number - 2]) * self.g, 1), 0)
            cooperation_counter = self.cooperation_counter.get(history.opponent_actions[-1].argmax(), 0)
            return Action.C if cooperation_counter >= self.Ct[round_number - 1] else Action.D

class Strategy_EXPLOITATIVE_375(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            opponent_cooperated = np.sum(history.opponent_actions[-1]) >= self.game_description.n_players // 2
            return Action(opponent_cooperated)

class Strategy_EXPLOITATIVE_376(BaseStrategy):
    """
    A strategy that cooperates initially and adaptively changes its cooperation level based on past actions of opponents and the current state of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number > 0 and self.threshold is None):
            return Action.C
        if self.threshold is not None and state.round_number == self.game_description.n_rounds - 1:
            if all(history.opponent_actions[-1, :] == [True] * self.game_description.n_players):
                return Action.C
            else:
                return Action.D
        last_round = len(history.opponent_actions) - 1
        cooperators = sum(history.opponent_actions[last_round, :])
        if all(history.opponent_actions[last_round, :] == [True] * self.game_description.n_players):
            return Action.C
        current_round = state.round_number + 1
        self.threshold = math.ceil(self.game_description.capacity * current_round / self.game_description.n_players)
        if history.current_stock < self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_377(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Growth Adaptation (TfT-GA)
    A game theory strategy that evaluates the average stock consumption per player in a history of rounds.
    If the opponent has been cooperating, it will cooperate; otherwise, defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_size = int(game_description.capacity / (2 * game_description.n_players))
        self.decay_factor = 0.95
        self.historical_data = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        consumed_per_player = np.sum(history.opponent_actions[:, :state.round_number], axis=0)
        average_consumption = np.mean(consumed_per_player)
        opponent_cooperation = average_consumption <= self.game_description.capacity / (2 * self.game_description.n_players)
        if history and len(self.historical_data) >= self.history_size:
            historical_data = np.array(self.historical_data[-self.history_size:])
            average_historical_consumption = np.mean(historical_data)
            opponent_cooperation_in_history = average_historical_consumption <= self.game_description.capacity / (2 * self.game_description.n_players)
        else:
            opponent_cooperation_in_history = False
        if opponent_cooperation or (opponent_cooperation_in_history and self.decay_factor > 0.5):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_378(BaseStrategy):
    """
    Tit-for-Tat-Growth (TfTG) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity // (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        """
        Implement the TfTG strategy based on the provided game state and history.
        """
        action = Action.C
        if state.round_number > 0:
            total_consumption = np.sum(history.my_actions * (2 * self.game_description.n_players / state.current_stock))
            if total_consumption <= self.capacity:
                action = Action.C
            else:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_379(BaseStrategy):
    """
    A Tit-for-Tat-Growing (TfT-G) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / 2
        self.consumption_limit = 0.7 * game_description.capacity
        self.consecutive_cooperation = 3

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        opponent_cooperation = np.count_nonzero(history.opponent_actions[-1]) >= self.game_description.n_players // 2 - 1
        previous_consumption = np.sum(history.opponent_actions[-3:-1])
        if opponent_cooperation and previous_consumption <= self.consumption_limit or (opponent_cooperation and state.round_number - 3 >= self.consecutive_cooperation) or (state.round_number == self.game_description.n_rounds and state.current_stock < self.threshold):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_381(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if len(self.opponent_history) < state.round_number + 1:
            self.opponent_history.extend([[False for _ in range(self.game_description.n_players)] for __ in range(state.round_number - len(self.opponent_history))])
        if state.round_number == len(self.opponent_history):
            if self.opponent_history[-1][0] == True:
                return Action.C
            else:
                return Action.D
        opponent_action = self.opponent_history[state.round_number - 1][0]
        if state.round_number > 1 and opponent_action == True:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_382(BaseStrategy):
    """
    Implementation of the Tit-for-Tat strategy in Common Pool Resource Game.
    Cooperates initially, then adapts based on opponent's previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((self.game_description.n_rounds, 2), dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        last_round = self.history.opponent_actions[-1]
        num_cooperators = sum(last_round)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif num_cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

    def update(self, state: CommonPoolState, action: Action):
        self.history.my_actions[-1] = [action == Action.C]
        if action == Action.C:
            self.history.my_payoffs[-1] = state.current_stock / (2 * self.game_description.n_players)
        else:
            self.history.my_payoffs[-1] = state.current_stock / self.game_description.n_players
        for i in range(self.game_description.n_players):
            self.history.opponent_actions[-1, i] = state.round_number > 0 and i != self.game_description.n_players - 1 and (state.history.opponent_actions[state.round_number - 1][i] if state.round_number > 1 else True)
            if i != self.game_description.n_players - 1:
                opponent = self(CommonPoolState(state.round_number + 1, state.current_stock - np.sum([self.history.opponent_actions[-1][i] for j in range(self.game_description.n_players)])))
                if opponent == Action.C:
                    self.history.opponent_payoffs[-1, i] = state.current_stock / (2 * self.game_description.n_players)
                else:
                    self.history.opponent_payoffs[-1, i] = state.current_stock / self.game_description.n_players

class Strategy_EXPLOITATIVE_383(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = -1
        self.history = PlayerHistory(np.zeros(game_description.n_rounds + 1, dtype=bool), np.zeros(game_description.n_rounds + 1), np.zeros((game_description.n_rounds + 1, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds + 1, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_round = -1
            return Action.C
        self.last_round += 1
        self.history.my_actions[self.last_round] = Action.C if history is None else history.opponent_actions[self.last_round - 1, 0]
        cooperators = sum(history.opponent_actions[self.last_round - 1, :])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_386(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.cooperation_threshold = 0
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        self.current_round = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        if self.current_round == 0:
            return Action.C
        self.history.my_actions[self.current_round] = True
        self.history.opponent_actions[self.current_round, :] = history.opponent_actions[self.current_round - 1, :]
        cooperators = sum(self.history.opponent_actions[-self.game_description.n_rounds // 2:, :])
        cooperative_payoff = np.mean(self.history.my_payoffs[-self.game_description.n_rounds // 2:])
        defective_payoff = np.mean(self.history.my_payoffs[-self.game_description.n_rounds // 2:][self.history.my_actions[-self.game_description.n_rounds // 2:] == False])
        if cooperative_payoff > defective_payoff and self.current_round != self.game_description.n_rounds - 1:
            self.cooperation_threshold += 1
        elif cooperative_payoff < defective_payoff and self.cooperation_threshold > 0:
            self.cooperation_threshold -= 1
        action = Action.C if self.cooperation_threshold <= self.n_players else Action.D
        self.history.my_payoffs[self.current_round] = state.current_stock / (2 * self.game_description.n_players) if action == Action.C else state.current_stock / self.game_description.n_players
        self.current_round += 1
        return action

class Strategy_EXPLOITATIVE_387(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Adaptation (TFTSA)

    This strategy cooperates to build trust and maintains a higher stock level.
    After that, it adapts its actions based on the opponent's behavior in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.cooperate_threshold = math.ceil(self.n / 2)
        self.m = int(math.floor((self.n - 1) / 3)) if self.n > 3 else 0
        self.history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is None:
            return Action.C
        self.history.append(int(history.my_actions[-1]) == 1)
        cooperators = sum([history.opponent_actions[state.round_number - 1, :] if state.round_number > 0 else [0] * self.n])
        if state.round_number < self.game_description.n_rounds or all(self.history[-self.game_description.n_rounds:]):
            return Action.C
        elif cooperators < self.cooperate_threshold and any([not self.history[-i] for i in range(1, min(self.m + 1, len(self.history)))]):
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_388(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.round_threshold = math.ceil(game_description.n_rounds * 0.75)
        self.stock_threshold = self.capacity * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history is not None else np.full(self.n_players, False)
        last_cooperators = sum(opponent_actions)
        if state.current_stock < self.stock_threshold and state.round_number > self.round_threshold:
            return Action.D
        return Action.C if last_cooperators >= self.n_players // 2 else Action.D

class Strategy_EXPLOITATIVE_389(BaseStrategy):
    """Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.memory_length = self.game_description.n_players // 2
        self.cooperation_threshold = (2 * self.game_description.n_players - self.game_description.n_rounds) / (2 * self.game_description.n_players) if self.memory_length % 2 == 0 else (2 * self.game_description.n_rounds + 1) / (2 * self.game_description.n_players * 2)
        self.punishment_duration = math.ceil(self.cooperation_threshold * self.memory_length)
        self.history = PlayerHistory(np.zeros((self.game_description.n_rounds,), dtype=bool), np.zeros((self.game_description.n_rounds,)), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        if state.round_number == 0:
            self.history.my_actions[0] = True
            return Action.C
        cooperation_level = np.mean(history.opponent_actions[:, -self.memory_length:])
        if cooperation_level > self.cooperation_threshold:
            self.history.my_actions[-1] = True
            return Action.C
        self.history.my_actions[-1] = False
        punishment_rounds = min(self.punishment_duration, state.round_number - 1)
        for round_num in range(state.round_number - 1, state.round_number - punishment_rounds - 1, -1):
            self.history.my_actions[round_num] = False
        return Action.D

class Strategy_EXPLOITATIVE_390(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TfT-SA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.exploitation_threshold = (2 * game_description.n_players - 1) * game_description.capacity / game_description.n_rounds
        self.last_round = False
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is not None and self.history is None:
            self.history = history
        action = Action.C
        if state.round_number == 0:
            self.last_round = False
            return action
        if self.last_round:
            return Action.D
        if state.current_stock < self.exploitation_threshold:
            return Action.D
        opponent_cooperated = sum(history.opponent_actions[state.round_number - 1, :]) >= self.game_description.n_players // 2
        if opponent_cooperated:
            action = Action.C
        else:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_391(BaseStrategy):
    """
    A simple strategy that initiates cooperation and retaliates against defection, encouraging cooperation when possible while discouraging defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players + 1), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, self.game_description.n_players + 1), dtype=bool), np.zeros(1))
        if state.round_number == 0:
            return Action.C
        round_num = len(self.history.my_actions) - 1
        opponent_cooperators = sum(self.history.opponent_actions[round_num, :])
        own_cooperators = self.history.my_actions[-1]
        if round_num == 0:
            return Action.C
        if own_cooperators == opponent_cooperators:
            return self.history.opponent_actions[-1, -self.__class__.__name__.replace('Strategy', '').lower()]
        if round_num == self.game_description.n_rounds - 1:
            return Action.C
        return Action.C if own_cooperators > opponent_cooperators else Action.D

class Strategy_EXPLOITATIVE_392(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)

    This strategy follows a cooperative approach initially but can become more exploitative based on opponents' behavior.
    It adapts its cooperation threshold to encourage cooperation when it seems safe, but also allows for swift punishment and revenge against defectors to minimize long-term losses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_CT = 2 * self.game_description.n_players - 1
        self.current_CT = self.initial_CT
        self.current_cooperative_rounds = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        self.current_cooperative_rounds += int(history.my_actions[-1])
        if cooperators < self.game_description.n_players and self.current_cooperative_rounds >= self.current_CT:
            self.current_CT = min(self.initial_CT, self.current_CT + 1)
            return Action.D
        elif cooperators >= self.game_description.n_players and round_number < self.game_description.n_rounds - 1:
            total_payoff = np.sum(history.my_payoffs)
            last_cooperative_payoff = self._calculate_last_cooperative_payoff(history)
            if last_cooperative_payoff > total_payoff:
                return Action.C
        return Action.D

    def _calculate_last_cooperative_payoff(self, history: PlayerHistory) -> float:
        last_round = len(history.my_actions) - 1
        last_cooperative_action = self._get_last_cooperative_action(history, last_round)
        if last_cooperative_action is None:
            return 0
        payoffs = history.my_payoffs[last_round]
        for i in range(last_round - 1, -1, -1):
            if history.my_actions[i] != last_cooperative_action:
                break
            payoffs += history.my_payoffs[i]
        return np.sum(payoffs)

    def _get_last_cooperative_action(self, history: PlayerHistory, round: int) -> bool | None:
        for i in range(round - 1, -1, -1):
            if history.my_actions[i]:
                return True
        return None

class Strategy_EXPLOITATIVE_393(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Forgiveness (TfTAF) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.f = None
        if self.n > 10 and self.capacity > 3 * self.n:
            self.f = min(2 * self.n, 5)
        elif self.n <= 10 and self.capacity > 3 * self.n:
            self.f = min(2 * self.n / 3, 5)
        else:
            self.f = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and history.my_actions[-1]:
            return Action.C
        if state.round_number < self.f or (self.n <= 10 and history.my_payoffs[-2] == 0):
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_395(BaseStrategy):
    """
    Tit-for-Tat Exploitative (TfT-Exploit) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.threshold = self.game_description.capacity * (self.n_players - 1) / (2 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_last_action = history.my_actions[-1] if history is not None else False
        num_cooperators = np.sum(history.opponent_actions[:, -1]) if history is not None else 0
        if num_cooperators == self.n_players:
            return Action.C
        elif my_last_action and state.round_number > 1:
            return Action.C
        else:
            return Action.D
        if state.round_number <= self.game_description.n_rounds - 5:
            if state.current_stock < self.threshold and state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_396(BaseStrategy):
    """
    A strategy inspired by the Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.7 if game_description.capacity > game_description.n_players * 2 else 0.4
        self.average_coop = 0
        self.average_payoff = 0
        self.round_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if history is not None and self.round_count > 0:
            coop_rate = sum(history.my_actions[1:]) / (state.round_number - 1)
            cooperative_opponents = int((self.cooperation_threshold + 1) * (state.round_number - 1)) if state.current_stock > self.game_description.capacity * 0.5 else int((self.cooperation_threshold - 1) * (state.round_number - 1))
            if coop_rate >= cooperative_opponents / (state.round_number - 1):
                action = Action.C
        self.average_payoff = np.mean(history.my_payoffs) if history is not None else self.average_payoff
        self.round_count = state.round_number
        return action

class Strategy_EXPLOITATIVE_397(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat-Growth (TfttG)

    A strategy that cooperates in the first round and adapts to opponents' behavior in subsequent rounds. If all opponents cooperated in the last round, it will cooperate again to maintain the common pool growth. If any opponent defected, it will defect as a punishment for defection, which helps reduce the common pool to encourage future cooperation. The strategy also considers the remaining stock level after consumption and will defect if the new stock is below a certain threshold (e.g., 50% of capacity) to conserve resources for future rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(game_description.capacity / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_cooperators = sum(history.opponent_actions[-1, :]) if history else 0
        current_stock = state.current_stock if history else self.game_description.capacity
        if opponents_cooperators >= self.game_description.n_players // 2 and current_stock > self.threshold:
            return Action.C
        elif any(history.opponent_actions[-1, :]) or current_stock <= self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_398(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth (ATFSG) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_rounds / 10) if game_description.n_rounds > 10 else game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C
        average_stock = np.mean(history.my_payoffs[-self.m:]) / self.game_description.capacity
        if average_stock >= 1:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_399(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_lookback = math.ceil(game_description.n_rounds * 0.8)
        self.cooperation_threshold = game_description.n_players // 4
        self.opponent_history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == 1 or state.round_number == self.game_description.n_rounds:
            return Action.C
        opponent_cooperation_rate = np.mean(self.opponent_history.my_actions[-self.n_lookback:])
        if opponent_cooperation_rate > self.cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_401(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.calculate_threshold()
        self.total_payoff = 0

    def calculate_threshold(self) -> float:
        """
        Calculates the payoff threshold for the last round (80% of optimal payoff).
        :return: Payoff threshold as a float
        """
        capacity = self.game_description.capacity
        optimal_payoff = capacity * self.game_description.n_players / self.game_description.n_rounds
        return 0.8 * optimal_payoff

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if self.total_payoff >= self.threshold:
                return Action.C
            else:
                return Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators == 0:
            return Action.D
        elif cooperators >= len(history.opponent_actions) // 2:
            return Action.C
        self.total_payoff += history.my_payoffs[-1]
        return Action.D

class Strategy_EXPLOITATIVE_402(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=np.bool_)
        cooperators = sum(opponent_actions)
        return Action(int((cooperators > self.game_description.n_players // 2).astype(int)))

class Strategy_EXPLOITATIVE_404(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)
    Summary: A strategy that cooperates or defects based on the current stock level and the average cooperation rate of previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p = random.uniform(0, 1)
        self.T = 20

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C if random.random() < self.p else Action.D
        if history is not None and len(history.opponent_actions) > self.T:
            R_t = np.mean(history.my_actions[-self.T:])
            S_t = calculate_threshold(history, self.T)
            return Action.C if R_t > self.p and state.current_stock >= S_t else Action.D
        else:
            return Action.C if random.random() < self.p else Action.D

class Strategy_EXPLOITATIVE_405(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation Threshold (TTATC)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.max_sustainable_stock = 2 * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            cooperation_threshold = self.max_sustainable_stock
        elif state.round_number == self.game_description.n_rounds:
            cooperation_threshold = 0.01 * self.max_sustainable_stock
        else:
            cooperation_threshold = self.max_sustainable_stock * (1 - (state.round_number - 1) / self.game_description.n_rounds)
        current_stock = state.current_stock
        if current_stock >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_406(BaseStrategy):
    """
    The Tit-for-Tat with Growth Adaptation (TfT-GA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_size = int(math.ceil(game_description.n_rounds * 0.8))
        self.window_size = min(self.history_size, game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is not None:
            return Action.C
        if history is not None:
            cooperators = sum(history.opponent_actions[-self.window_size:, :].flatten())
            defectors = len(history.opponent_actions) - cooperators
            if cooperators >= self.window_size // 2:
                return Action.C
            elif defectors >= self.window_size // 2:
                if state.current_stock < self.game_description.capacity * 0.9:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_407(BaseStrategy):
    """
    Implementation of Tit-for-Tat with Growth Adaptation (TfT-GA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_tendency = 0.5
        self.capacity_remaining = game_description.capacity
        self.opponent_history = []
        self.average_growth = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if len(self.opponent_history) < self.game_description.n_rounds:
            self.average_growth = np.mean([stock_growth for _, _, _, _, stock_growth in self.opponent_history[-10:]])
        if state.round_number == 0 or len(self.opponent_history) == 0:
            return Action.C
        else:
            opponent_cooperated = sum(history.opponent_actions[-1, :]) > self.game_description.n_players // 2
            if opponent_cooperated and self.capacity_remaining / self.game_description.capacity >= self.average_growth:
                self.cooperation_tendency += 0.1 * (self.capacity_remaining / self.game_description.capacity >= self.average_growth) - 0.1 * (self.capacity_remaining / self.game_description.capacity < self.average_growth)
            elif not opponent_cooperated:
                self.cooperation_tendency -= 0.2
            if state.current_stock < 2 * self.game_description.n_players or self.capacity_remaining <= 0:
                return Action.D
        return Action.C if self.cooperation_tendency > random.random() else Action.D

class Strategy_EXPLOITATIVE_408(BaseStrategy):
    """
    Tit-for-Tat with Variance (TfTV) strategy for Common Pool Resource Game.
    This strategy cooperates in the initial round and considers opponent's actions to decide whether to cooperate or defect in subsequent rounds, while introducing randomness to increase unpredictability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperation = np.mean(history.opponent_actions[:, -1]) if history is not None else 0
        action = Action.C if random.random() < self.p * (opponent_cooperation > 0.5) else Action.D
        return action

class Strategy_EXPLOITATIVE_409(BaseStrategy):
    """
    Tit-for-Tat with Growth Adaptation (TfT-GA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        opponent_action = np.mean(history.opponent_actions[:, -1])
        current_stock = state.current_stock
        if opponent_action == 1 and current_stock > self.capacity / 2:
            return Action.D
        elif opponent_action == 0 and current_stock <= self.capacity / 2:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_410(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)
    Summary: A strategy that cooperates initially and responds to opponents' actions, adjusting cooperation likelihood based on average past actions of all opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds = 0
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=np.bool_), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))
        self.cooperation_threshold = 0.5
        self.cooperation_increase_factor = 1.2
        self.cooperation_decrease_factor = self.cooperation_increase_factor ** (-1)
        self.stock_level_adjustment_factor = (self.game_description.capacity - 2 * self.game_description.n_players) / self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.rounds += 1
        if history is not None:
            self.history = history
        if state.round_number == 0:
            return Action.C
        m = min(self.game_description.n_rounds, self.rounds)
        cooperation_rate = np.mean(self.history.my_actions[-m:])
        cooperation_likelihood = max(min(cooperation_rate, 1), 0) * (1 - state.current_stock / self.game_description.capacity) * self.stock_level_adjustment_factor + min(cooperation_rate, 0.5)
        if cooperation_likelihood > self.cooperation_threshold:
            cooperation_likelihood *= self.cooperation_increase_factor
        elif cooperation_likelihood < self.cooperation_threshold:
            cooperation_likelihood *= self.cooperation_decrease_factor
        return Action(int(cooperation_likelihood > random.random()))

class Strategy_EXPLOITATIVE_411(BaseStrategy):
    """
    A game theory strategy called Tit-for-Tat with Adaptive Cooperative Threshold (TfT-ACT).
    This strategy cooperates initially, then adapts its cooperation based on opponents' actions and a dynamic cooperative threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.X = 0.75
        self.initial_CT = 75
        self.initial_RPT = int(self.capacity * 0.8)
        self.cooperative_threshold = self.initial_CT
        self.resource_preservation_threshold = self.initial_RPT
        self.opponent_cooperation_last_round = [False] * self.n

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        stock = state.current_stock
        if round_number == 0:
            return Action.C
        total_opponent_cooperation = sum(self.opponent_cooperation_last_round)
        if round_number == self.r or stock < self.capacity * 0.1:
            return Action.D
        if total_opponent_cooperation >= self.X and stock > self.resource_preservation_threshold:
            self.opponent_cooperation_last_round = [True] * self.n
            return Action.C
        if total_opponent_cooperation < self.X and self.cooperative_threshold > total_opponent_cooperation:
            return Action.D
        if stock <= self.resource_preservation_threshold or self.cooperative_threshold <= total_opponent_cooperation:
            self.opponent_cooperation_last_round = [True] * self.n
            return Action.C

class Strategy_EXPLOITATIVE_412(BaseStrategy):
    """
    An adaptive exploitative Tit-for-Tat strategy for the Common Pool Resource Game.
    The strategy cooperates if resource consumption is stable or growing, and defects in response to overconsumption.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r = self.game_description.n_rounds
        self.capacity = self.game_description.capacity
        self.n_players = self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.r:
            return Action.C
        total_consumption = np.sum(history.my_actions[:-1]) * (self.r - 1)
        average_consumption_rate = total_consumption / (self.r - 1) if total_consumption != 0 else state.current_stock / self.capacity
        cooperate = state.current_stock >= self.capacity or (average_consumption_rate <= 0.5 and state.current_stock > self.capacity / (2 * self.n_players))
        return Action.C if cooperate else Action.D

class Strategy_EXPLOITATIVE_413(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = self.game_description.n_rounds // 2
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[state.round_number - 1][0] if len(history.opponent_actions) > state.round_number - 1 else None
        if opponent_action is None or (not opponent_action and self.cooperation_threshold > 0):
            return Action.D
        elif not opponent_action:
            self.cooperation_threshold = max(self.cooperation_threshold - math.ceil(self.game_description.n_rounds / 4), 1)
        else:
            self.cooperation_threshold = min(self.cooperation_threshold + math.ceil(self.game_description.n_rounds / 4), self.game_description.n_rounds - 1)
        return Action.C if history.my_actions[-1] == opponent_action and opponent_action else Action.D

    def update_history(self, my_action: bool, payoff: float):
        self.history.my_actions[self.history.my_actions.shape[0] - 1] = my_action
        self.history.my_payoffs[-1] = payoff

class Strategy_EXPLOITATIVE_414(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TFTAT)
    Strategy Description: A cooperative strategy that adapts its cooperation level based on the average cooperation of opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None
        self.cooperation_threshold = 0.2
        self.average_coop_level = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None):
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        if self.history is None or len(self.history) < self.game_description.n_rounds - 1:
            self.cooperation_threshold = 0.5
        if history.my_actions[-1] == Action.C:
            self.average_coop_level[-1] = 1
        else:
            self.average_coop_level[-1] = 0
        avg_coop_level = np.mean(self.average_coop_level)
        self.cooperation_threshold = self.set_threshold(avg_coop_level)
        if avg_coop_level >= self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

    def set_threshold(self, average):
        if len(self.average_coop_level) < self.game_description.n_rounds - 1:
            return self.cooperation_threshold
        else:
            return self.cooperation_threshold

class Strategy_EXPLOITATIVE_415(BaseStrategy):
    """
    The Tit-for-Tat-Greed (TFT-Greed) Strategy for Common Pool Resource Game.
    This strategy cooperates initially and becomes increasingly less cooperative as the game progresses
    and opponents overconsume resources, aiming for higher payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.greed_level = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_consumption = np.sum(history.opponent_actions[:, -1]) * self.game_description.capacity
        if previous_consumption / self.game_description.capacity > self.greed_level:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_416(BaseStrategy):
    """
    A strategy called Tit-for-Tat with Adaptive Cooperation Threshold (TfTACT). This strategy cooperates more frequently when opponents also cooperate and defects if opponents do not. The cooperation threshold adapts to the average cooperation level observed in previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.alpha = 0.5
        self.beta = 0.1
        self.cooperation_levels = [self.alpha]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.cooperation_levels.append(self.alpha)
            return Action.C
        if history is None:
            self.cooperation_levels.append(self.alpha)
            return Action.C
        if state.round_number < self.game_description.n_rounds:
            average_cooperative_level = (1 - self.beta) * self.cooperation_levels[-2] + self.beta * np.mean(history.my_actions)
            if average_cooperative_level > self.alpha:
                self.alpha = average_cooperative_level
            self.cooperation_levels.append(average_cooperative_level)
        if history.my_actions[-1] == Action.C:
            self.cooperation_levels[-1] += 1 / (2 * self.game_description.n_players)
        if self.cooperation_levels[-1] > self.alpha:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_418(BaseStrategy):
    """
    A Tit-for-Tat with Growth Adaptation (TfT-GA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_over_n = self.game_description.capacity / self.game_description.n_players
        self.history = PlayerHistory(np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.history = history
        action = Action.C
        if state.round_number > 0:
            cooperators_in_prev_round = sum(self.history.opponent_actions[-1, :])
            if cooperators_in_prev_round == self.game_description.n_players:
                action = Action.C
            elif cooperators_in_prev_round > 0 and state.current_stock - self.history.opponent_payoffs[-1].sum() <= self.capacity_over_n:
                action = Action.C
            else:
                action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock == self.game_description.capacity:
                action = Action.C
            elif state.current_stock < self.capacity_over_n * 0.5:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_420(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    This strategy cooperates in the first round and mimics the opponent's actions from the previous round,
    encouraging reciprocation while also punishing defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._first_round = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            self._first_round = True
            return Action.C
        if history is not None:
            self._first_round = False
        if state.round_number == len(history.opponent_actions) and self._first_round or np.sum(history.opponent_actions[-1, :]) == self.game_description.n_players:
            return Action.C
        elif np.sum(history.opponent_actions[-1, :]) > (self.game_description.n_players - 1) // 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_421(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Growth Adaptation (TFT-GA)
    This strategy uses a tit-for-tat approach while adapting to the average cooperative percentage (CP) of all previous rounds.
    It encourages cooperation when others do so as well, but retaliates with defection when others frequently defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_rounds = 0
        self.total_cooperative_rounds = 0
        self.cooperative_percentage = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.total_rounds += 1
        cooperative_rounds = np.where(history.my_actions)[0] if history is not None else []
        if len(cooperative_rounds) > 0 and self.total_rounds > self.game_description.n_players:
            self.cooperative_percentage = self.total_cooperative_rounds / self.total_rounds
        else:
            self.cooperative_percentage = np.nan
        if self.total_rounds < self.game_description.n_rounds:
            cp = self.cooperative_percentage if not math.isnan(self.cooperative_percentage) else 0
            action = Action.C if cp >= self.game_description.n_players // 2 else Action.D
        elif state.round_number == self.game_description.n_rounds:
            if state.current_stock > self.game_description.capacity * 0.5:
                action = Action.C
            else:
                action = Action.D
        else:
            cp = self.cooperative_percentage if not math.isnan(self.cooperative_percentage) else 0
            action = Action.C if cp >= self.game_description.n_players // 2 else Action.D
        if action == Action.C:
            self.total_cooperative_rounds += 1
        return action

class Strategy_EXPLOITATIVE_422(BaseStrategy):
    """
    A Tit-for-Tat strategy with Adaptive Cooperation (TFT-A) for Common Pool Resource Games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p = 0.5
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history = history
        cooperators = np.sum(self.history.opponent_actions[-1])
        total_players = self.game_description.n_players
        if cooperators == total_players:
            return Action.C
        elif np.any(self.history.opponent_actions[-1]):
            return Action.D
        elif random.random() < self.p:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_423(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Generosity (TfT-AG) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p = 1.0
        self.p_min = 0.2
        self.consecutive_defeats = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number != self.game_description.n_rounds:
            last_opponent_action = history.opponent_actions[state.round_number - 1, 0]
            self.consecutive_defeats = np.count_nonzero(history.opponent_actions[:state.round_number, 0]) if state.round_number > 0 else 0
            if last_opponent_action:
                self.p = min(self.p * 0.95, self.p_min)
            elif last_opponent_action == False and self.consecutive_defeats > 1:
                self.p *= 0.95
            else:
                self.consecutive_defeats = 0
        return Action.C if self.p > self.p_min or state.round_number == self.game_description.n_rounds else Action.D

class Strategy_EXPLOITATIVE_424(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TfTSA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        self.count_cooperative = 0
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.history = history
        if self.last_round:
            return self.__class__._select_action(state, self.history)
        if state.round_number < self.game_description.n_rounds - 1:
            self.count_cooperative = sum(self.history.opponent_actions[-(state.round_number + 2):, :][::-1].flatten())
        else:
            self.last_round = True
        if self.count_cooperative >= self.game_description.n_players // 2 or state.round_number == 0:
            return Action.C
        return Action.D

    @staticmethod
    def _select_action(state: CommonPoolState, history: PlayerHistory) -> Action:
        if len([i for i in history.opponent_actions[:, -1] if i]) == 0 or len([i for i in history.opponent_payoffs[-1] if i < state.current_stock / (2 * history.my_actions[-1])]) > 0:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_425(BaseStrategy):
    """Stock-based Adaptive Rational Exploiter (SARE) strategy for Common Pool Resource Game."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_sustainable_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if self.avg_sustainable_stock is None:
            self.avg_sustainable_stock = 2 * self.game_description.capacity / (2 * self.game_description.n_players * self.game_description.n_rounds)
        if state.current_stock > self.avg_sustainable_stock:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_426(BaseStrategy):
    """A strategy based on the Tit-for-Tat-Growth (TFT-G) game theory approach"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_phase = 0.5
        self.forgiveness_phase = 0.1
        self.history = [Action.C]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        punishment_phase = self.punishment_phase
        forgiveness_phase = self.forgiveness_phase
        current_stock = state.current_stock
        if history is not None:
            opponent_cooperated_last_round = sum(history.opponent_actions[-1]) >= len(history.opponent_actions) // 2
            if opponent_cooperated_last_round:
                action = Action.C
            elif state.round_number < self.game_description.n_rounds - 1 and state.round_number >= punishment_phase * (self.game_description.n_rounds - 1):
                action = Action.D
            elif state.round_number >= punishment_phase * (self.game_description.n_rounds - 1) and state.round_number < forgiveness_phase * (self.game_description.n_rounds - 1):
                punishment_phase -= 0.1
                forgiveness_phase += 0.1
                action = Action.D
            else:
                action = Action.C
        else:
            action = Action.C
        if action == Action.D:
            current_stock -= Action.D.value * 2 / self.game_description.n_players
        self.history.append(action)
        return action

class Strategy_EXPLOITATIVE_427(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Growth Adaptation (TfTGA)
    Description: A strategy that cooperates in the first round and punishes defection, while gradually decreasing the duration of punishment over time. The probability of defecting decreases exponentially as the game progresses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.a = 0.5
        self.b = math.log(2) / (self.game_description.n_rounds - 1)
        self.p_D = self.a * math.exp(-self.b)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if history.opponent_actions[-1, 0] == 1:
                return Action.C
            else:
                return Action.D
        opponent_action = history.opponent_actions[-1, 0]
        self.p_D *= math.exp(-self.b * state.round_number)
        if opponent_action == 1:
            return Action.C
        elif random.random() < self.p_D:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_428(BaseStrategy):
    """
    A strategy based on the Adaptive Tit-for-Tat approach for the Common Pool Resource Game.
    The AI initially cooperates, encouraging a cooperative environment. However, if an opponent ever defects,
    the AI will also defect in the next round as retaliation. If the opponent subsequently cooperates again,
    the AI will return to cooperation. This simple form of reciprocity balances cooperation and punishment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number - 1
        self.cooperative_round = max(self.cooperative_round, current_round - self.game_description.n_players)
        opponent_last_action = history.opponent_actions[current_round, 0] if history else False
        return Action.C if opponent_last_action and self.cooperative_round > current_round or not opponent_last_action else Action.D

class Strategy_EXPLOITATIVE_429(BaseStrategy):
    """
    A Tit-for-Tat strategy with an adaptive cooperative threshold.
    This strategy cooperates initially and gradually lowers cooperation based on previous opponents' actions and depletion of the stock level.
    It responds tit-for-tat to defection, maintains cooperation until a certain threshold is reached or total stock depletion exceeds a defined limit.
    When these limits are met, it lowers cooperation while being exploitative by defecting when necessary to minimize further damage to the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int((game_description.capacity - 2 * game_description.n_players) / game_description.n_rounds)
        self.depletion_limit = int((game_description.capacity - 2 * game_description.n_players) / 2)
        self.state = None
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        self.state = state
        self.history = history
        if self.state.round_number == 0 or not self.history:
            return Action.C
        if self.state.current_stock <= 0:
            return Action.D
        last_opponent_action = sum(self.history.opponent_actions[-1])
        depletion = np.sum(self.history.my_payoffs)
        if last_opponent_action == self.game_description.n_players:
            if self.state.current_stock > self.threshold or depletion <= self.depletion_limit:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_430(BaseStrategy):
    """
    A strategy that cooperates to start a positive note, but adapts its behavior based on opponent's actions.
    It also considers resource pool state and prioritizes self-interest in the last round or when the resource pool is critically depleted or near capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness = True
        self.last_round = False
        self.stock_below_threshold = False
        self.stock_near_capacity = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.D
        if history:
            opponent_actions = history.opponent_actions[-1]
            round_number = state.round_number - 1
            if round_number < self.game_description.n_rounds:
                if opponent_actions[-1] == Action.D and round_number > 0 and (opponent_actions[round_number - 1] == Action.C):
                    action = Action.C
                    self.forgiveness = True
                elif opponent_actions[-1] == Action.C:
                    action = Action.C
            if round_number == self.game_description.n_rounds - 1:
                self.last_round = True
                self.stock_below_threshold = state.current_stock <= 2 * self.game_description.n_players
                self.stock_near_capacity = state.current_stock > math.floor(self.game_description.capacity / 2)
                if self.stock_below_threshold or self.stock_near_capacity:
                    action = Action.D
        return action

class Strategy_EXPLOITATIVE_431(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TfT-ACT)
    This strategy cooperates if the average consumption per player over the last n rounds is less than a predefined cooperation threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(history.my_actions) < self.game_description.n_players * self.game_description.n_rounds:
            return Action.C
        last_n_rounds = min(state.round_number, self.game_description.n_rounds - 1)
        total_consumption = np.sum(history.my_actions[-last_n_rounds:])
        average_consumption = total_consumption / self.game_description.n_players
        if self.threshold is None or state.round_number == self.game_description.n_rounds - 1 or state.round_number > self.game_description.n_rounds / 2:
            self.threshold = self.game_description.capacity / (2 * self.game_description.n_players + self.game_description.n_rounds)
        if average_consumption < self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_434(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive cooperation threshold for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = None
        self.consumption_history = np.zeros(self.game_description.n_rounds, dtype=np.float64)

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0:
            action = Action.C
        elif state.round_number < self.game_description.n_rounds - 1 and state.current_stock <= 2 * self.game_description.n_players:
            action = Action.D
        elif history is None or len(history.my_actions) == 0:
            self.threshold = state.current_stock / self.game_description.capacity + len(self.consumption_history) * np.mean(self.consumption_history)
        elif state.round_number == len(history.my_actions):
            action = Action.C
        elif history.my_actions[-1] and (self.threshold > state.current_stock / self.game_description.capacity or np.random.rand() < 0.5):
            action = Action.C
        elif self.threshold <= state.current_stock / self.game_description.capacity:
            action = Action.D
        self.consumption_history[-1] = int(action == Action.D)
        return action

class Strategy_EXPLOITATIVE_435(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFT-SA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_low = 2 * self.game_description.n_players
        self.threshold_high = self.game_description.capacity // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            if state.current_stock > self.threshold_high:
                return Action.C
            else:
                return Action.D
        if state.current_stock <= self.threshold_low:
            return Action.C
        if history is not None and history.opponent_actions[-1][0] == int(history.my_actions[-1]):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_436(BaseStrategy):
    """
    A Tit-for-Tat with Stock Adjustment (TfTSA) game theory strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 2 * game_description.n_players / 3 * game_description.capacity
        self.growth_threshold = 4 * game_description.capacity // 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[-1, -1] if history else Action.D
        stock = state.current_stock
        if opponent_action == Action.C:
            return Action.C
        elif opponent_action == Action.D:
            if stock <= self.threshold or state.round_number == self.game_description.n_rounds - 1:
                return Action.D
        if stock > self.growth_threshold:
            self.threshold = (3 * self.threshold + stock) // 4
        else:
            self.threshold = math.floor(self.threshold)
        return Action.C if stock < self.threshold or state.round_number == self.game_description.n_rounds - 1 else Action.D

class Strategy_EXPLOITATIVE_437(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Stock Dynamic Adaptation (TfT-SDA)
    Summary: Cooperates in the first round, then adapts based on stock level and previous actions of all players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_stock = int(self.game_description.capacity * 0.8)
        self.punishment_delay = int(self.game_description.n_rounds // 10)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if np.all(history.my_actions[-1]) and state.current_stock >= self.threshold_stock:
            return Action.C
        if state.current_stock < self.threshold_stock or not np.any(history.my_actions[-1]):
            return Action.D
        if state.current_stock == 0:
            if state.round_number > self.punishment_delay:
                return Action.C
            return Action.D

class Strategy_EXPLOITATIVE_438(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)
    This strategy cooperates in the first round and adapts its behavior based on opponents' actions from the previous round.
    If all opponents cooperated in the previous round, it continues to cooperate. If at least one opponent defected, it defects as a punishment for defection. If no history exists (first encounter), it cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros((1,), dtype=float), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds,), dtype=float))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.history = history or self.history
        cooperation_count = np.sum(self.history.my_actions[-1])
        if np.all(self.history.opponent_actions[-1] == 1):
            return Action.C
        elif cooperation_count < self.game_description.n_players:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_439(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Defection Threshold (TFT-ADT) strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = self.game_description.n_players
        self.n_rounds = self.game_description.n_rounds
        self.capacity = self.game_description.capacity
        self.current_round = 0
        self.last_opponents_cooperate = True
        self.defection_threshold = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and self.current_round > 0:
            self.last_opponents_cooperate = all(history.opponent_actions[-1])
        if state.round_number == 0:
            return Action.C
        elif self.last_opponents_cooperate:
            return Action.C
        else:
            self.defection_threshold = math.ceil(2 * self.n_players * self.n_rounds / (self.current_round + 1))
            if sum(history.opponent_actions[-1]) > self.defection_threshold:
                return Action.C
        self.current_round += 1
        return Action.D

class Strategy_EXPLOITATIVE_441(BaseStrategy):
    """
    Tit-for-Tat Strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C if self.round == 0 else Action.D
        self.round += 1
        opponent_cooperators = sum(history.opponent_actions[-1])
        if self.round == self.game_description.n_rounds:
            return Action.D
        return Action.C if opponent_cooperators >= self.game_description.n_players // 2 else Action.D

class Strategy_EXPLOITATIVE_442(BaseStrategy):
    """
    Tit-for-Tat Strategy with Stock Adaptation for Common Pool Resource Game
    Cooperates if all opponents cooperated, defects if any opponent defected or initial round.
    Adapts stock consumption based on remaining capacity to avoid depleting the common pool too quickly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_ratio = self.game_description.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None and len(history.opponent_actions) >= self.game_description.n_rounds:
            last_round = history.opponent_actions[-1]
            cooperators = sum(last_round)
            if all(cooperators):
                return Action.C
            elif any(not cooperators):
                return Action.D
        return Action.C

    def consume_stock(self, action: Action, current_stock: float) -> float:
        if action == Action.C:
            return current_stock * self.capacity_ratio
        return current_stock / self.game_description.n_players

class Strategy_EXPLOITATIVE_443(BaseStrategy):
    """
    Tit-for-Tat Adaptive Strategy (TFTA) for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity * 0.95

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_last_action = history.opponent_actions[-1][0] if history is not None else None
        if opponent_last_action is None or state.round_number == self.game_description.n_rounds - 1:
            return Action.C if state.current_stock / self.game_description.capacity < self.threshold else Action.D
        return Action(not opponent_last_action)

class Strategy_EXPLOITATIVE_444(BaseStrategy):
    """
    A fitness-based Tit for Tat strategy for the Common Pool Resource Game.
    The strategy cooperates when average payoff per player is below the resource capacity divided by number of players, otherwise defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None
        self.avg_payoff = 0.0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not self.history:
            return Action.C
        if state.round_number == len(history.my_actions):
            AP = self.avg_payoff
            if AP < self.game_description.capacity / self.game_description.n_players:
                return Action.C
            else:
                return Action.D
        if not history:
            return Action.C
        self.avg_payoff = np.mean(history.my_payoffs[-self.game_description.n_rounds + 1:])
        AP = self.avg_payoff
        if AP < self.game_description.capacity / self.game_description.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_445(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game.
    The strategy cooperates in the first round to foster a cooperative environment,
    evaluates opponent's strategy based on their actions from previous rounds,
    and responds accordingly with cooperation or defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._history = PlayerHistory(my_actions=np.zeros(shape=(game_description.n_rounds,), dtype=bool), my_payoffs=np.zeros(shape=(game_description.n_rounds,), dtype=np.float64), opponent_actions=np.zeros(shape=(game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros(shape=(game_description.n_rounds, game_description.n_players), dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_strategy = self._analyze_history(history)
        if opponent_strategy == 'cooperative':
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            return Action.D

    def _analyze_history(self, history: PlayerHistory) -> str:
        cooperators = sum(history.opponent_actions[-self.game_description.n_rounds:, :].sum(axis=0))
        if cooperators >= self.game_description.n_players // 2:
            return 'cooperative'
        else:
            return 'defective'

class Strategy_EXPLOITATIVE_447(BaseStrategy):
    """
    A Tit-for-Tat-Growing (Tft-G) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not self.history or state.round_number == 0:
            return Action.C
        if history.opponent_actions[-1].sum() >= self.game_description.n_players // 2:
            return Action.C
        def_count = (history.opponent_actions.sum(axis=0) == state.current_stock).astype(int)
        if np.any(def_count > 0):
            if state.current_stock - def_count.sum() < self.game_description.capacity / self.game_description.n_players:
                action = Action.C * (2 * self.game_description.n_players - len(history)) + [Action.D] * def_count.sum()
            else:
                action = [Action.D] * def_count.sum() + Action.C * (2 * self.game_description.n_players - def_count.sum() - len(history))
        else:
            action = Action.C * (2 * self.game_description.n_players - len(history))
        if self.history:
            self.history = history
        return action

class Strategy_EXPLOITATIVE_448(BaseStrategy):
    """
    A Tit-for-Tat (TFT) strategy for the Common Pool Resource Game. The strategy aims to balance between exploitation and cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        round_number = state.round_number - 1
        opponent_action = history.opponent_actions[round_number, 0]
        if opponent_action is None:
            return Action.C
        if round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock <= 0:
            return Action.D
        if opponent_action:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_449(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game (CFR)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        action = Action.C
        self.history.my_actions[state.round_number] = True if action == Action.C else False
        if state.round_number > 0:
            last_round = min(state.round_number - 1, self.history.my_payoffs.size - 1)
            last_opponent_action = self.history.opponent_actions[last_round, (self.game_description.n_players - 1) % self.game_description.n_players] if history is not None else False
            action = Action.C if last_opponent_action else Action.D
        self.history.my_payoffs[state.round_number] = state.current_stock / (2 * self.game_description.n_players) if action == Action.C else state.current_stock / self.game_description.n_players
        return action

class Strategy_EXPLOITATIVE_450(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TTAT-CT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_coop_threshold = 0.5
        self.history_length = 10

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None and len(history.my_actions) >= self.history_length:
            average_cooperation = np.mean(history.my_actions[-self.history_length:])
            if average_cooperation >= self.min_coop_threshold:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_452(BaseStrategy):
    """
    This strategy is a Tit-for-Tat with Adaptive Cooperation. In the first round, it cooperates to establish a peaceful initial state. For subsequent rounds, it follows simple rules:
     - If the opponent cooperated in the previous round, it cooperates back (reciprocate).
     - If the opponent defected in the previous round, it also defects in this round (retaliate).
     - If the current round is the last one, it behaves as if the opponent had cooperated in the previous round, to encourage cooperation for future games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        self.round_number += 1
        opponent_cooperated = sum(history.opponent_actions[-1]) > 0
        return Action(int(opponent_cooperated)) if self.round_number > 1 else Action.C

class Strategy_EXPLOITATIVE_453(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Stock Awareness (TFTAS) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players * 2
        self.epsilon = 1.0 / (2 * game_description.n_players)
        self.delta = -self.epsilon / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock <= 0:
            return Action.D
        if history is not None:
            self.threshold += self.epsilon if np.sum(history.my_actions) == len(history.my_actions) else self.delta
        return Action.C if state.current_stock >= self.threshold else Action.D

class Strategy_EXPLOITATIVE_454(BaseStrategy):
    """
    A strategy called Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT).
    The strategy follows a cooperative approach at the beginning and adapts its behavior based on the opponent's previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_CT_value = math.ceil(game_description.capacity / 2)
        self.increment = 0.1
        self.decrement = 0.1
        self.current_round = 0
        self.opponent_cooperation_count = self.initial_CT_value

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.current_round += 1
        if state.round_number == 1 or history.opponent_actions[-1][-1] == Action.C:
            action = Action.C
        elif self.opponent_cooperation_count > 0 and history.opponent_actions[-1][-1] == Action.D:
            action = Action.D
            self._update_CT()
        else:
            action = Action.D
        return action

    def _update_CT(self):
        if history.opponent_actions[-1][-1] == Action.C:
            self.opponent_cooperation_count += self.increment
            self.opponent_cooperation_count = min(self.opponent_cooperation_count, self.game_description.n_players)
        elif history.opponent_actions[-1][-1] == Action.D and self.current_round > 1:
            self.opponent_cooperation_count -= self.decrement
            self.opponent_cooperation_count = max(0, self.opponent_cooperation_count)

class Strategy_EXPLOITATIVE_455(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.75
        self.total_consumption = 0.0
        self.rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.total_consumption += (history.opponent_payoffs[-1] * self.game_description.n_players).sum()
        self.rounds = state.round_number + 1 if history else state.round_number
        asdr = self.total_consumption / (self.rounds * self.game_description.capacity * self.game_description.n_players)
        return Action.C if asdr < self.threshold else Action.D

class Strategy_EXPLOITATIVE_456(BaseStrategy):
    """
    A simple Tit-for-Tat (TFT) strategy that encourages cooperation while retaliating against defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.last_opponent_action = sum(history.opponent_actions[-1])
        if state.round_number == 0 or (state.round_number > 0 and self.last_opponent_action == 0):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_457(BaseStrategy):
    """
    The Flexible Tit-for-Tat (FTfT) strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_threshold = 3
        self.current_opponent_defeats = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and history.my_actions[-1]:
            opponent_cooperated = sum(history.opponent_actions[-1]) >= self.game_description.n_players // 2
            return Action.C if opponent_cooperated else Action.D
        if history is not None and history.my_actions[-1]:
            self.current_opponent_defeats += 1
            return Action.D if self.current_opponent_defeats >= self.punishment_threshold else Action.C
        self.current_opponent_defeats = 0
        return Action.D

class Strategy_EXPLOITATIVE_458(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = int(self.game_description.n_players * (self.game_description.n_rounds - 1) / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        cooperators = sum(history.opponent_actions[last_round, :])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        self.cooperation_threshold = int(self.game_description.n_players * (self.game_description.n_rounds - state.round_number) / 2)
        if cooperators >= self.cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_459(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFTSA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_coop_threshold = 0.8 * game_description.capacity
        self.crit_deft_threshold = 0.6 * game_description.capacity
        self.average_stock_level = np.zeros(game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        current_stock = state.current_stock
        last_round = len(history.opponent_actions) - 1
        if last_round >= 0 and history.opponent_actions[last_round, -1] == Action.C:
            if current_stock >= self.min_coop_threshold:
                return Action.C
        elif last_round >= 0 and history.opponent_actions[last_round, -1] == Action.D:
            if current_stock <= self.crit_deft_threshold:
                return Action.D
            else:
                return Action.C
        self.average_stock_level[state.round_number - 1] = current_stock
        self.min_coop_threshold = (self.min_coop_threshold * len(self.average_stock_level) + current_stock) / (len(self.average_stock_level) + 1)
        self.crit_deft_threshold = (self.crit_deft_threshold * len(self.average_stock_level) + current_stock) / (len(self.average_stock_level) + 1)
        return Action.C

class Strategy_EXPLOITATIVE_460(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Stock Adaptation (TFT-SA)
    This strategy cooperates in the first round and responds to opponent's actions based on the tit-for-tat principle.
    In addition, it adapts its actions to prevent rapid depletion of the common pool resource when the stock level falls below a threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(game_description.capacity * 2 / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_action = history.opponent_actions[-1][-1] if len(history.opponent_actions) > 0 else None
        if opponent_action is not None and state.current_stock < self.threshold:
            return Action.C if opponent_action else Action.D
        return Action.C if opponent_action == Action.C else Action.D

class Strategy_EXPLOITATIVE_461(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Greed (TfT-AG) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.last_round = state.round_number >= self.game_description.n_rounds
        cooperators = sum(history.opponent_actions[-1])
        actions = [Action.C] * cooperators + [Action.D] * (self.game_description.n_players - cooperators)
        if self.last_round:
            if all((action == Action.C for action in actions)):
                return Action.C
            else:
                index_of_defection = next((i for i, action in enumerate(reversed(actions)) if action == Action.D), None)
                return actions[index_of_defection] if index_of_defection is not None else Action.C
        else:
            return actions[-1]

class Strategy_EXPLOITATIVE_462(BaseStrategy):
    """
    A Tit-for-Tat strategy with an adaptive cooperation threshold (TFT-ACT).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.n_players // 2
        self.previous_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=bool)
        self.previous_opponent_action = opponent_actions[-1]
        cooperators = sum(opponent_actions)
        if cooperators >= len(opponent_actions) - self.cooperation_threshold:
            return Action.C
        elif self.previous_opponent_action:
            self.cooperation_threshold -= 1
        else:
            self.cooperation_threshold += 1
        if self.cooperation_threshold < 0:
            self.cooperation_threshold = 0
        elif self.cooperation_threshold > len(opponent_actions) - 1:
            self.cooperation_threshold = len(opponent_actions) - 1
        return Action.C if self.cooperation_threshold > random.random() else Action.D

class Strategy_EXPLOITATIVE_463(BaseStrategy):
    """
    A Tit-for-Tat-Growth (TfT-G) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        previous_action = history.opponent_actions[-1][-1] if history else None
        if current_stock <= self.capacity or (previous_action is not None and previous_action == Action.D):
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_464(BaseStrategy):
    """
    A common pool resource game strategy that follows the Tit-for-Tat-Growing (TfTG) approach.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = min(math.ceil(game_description.n_rounds * 0.8), game_description.n_rounds)
        self.history_ACRs = []
        self.current_ACR = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or len(history.opponent_actions) < self.k + 1:
            return Action.C
        current_consumption = np.sum(history.opponent_actions[:, -1]) / self.game_description.n_players
        self.current_ACR += current_consumption
        self.current_ACR /= state.round_number + 1
        if state.round_number > self.k and len(self.history_ACRs) < state.round_number:
            self.history_ACRs.append(self.current_ACR)
        history_average = np.mean(np.array(self.history_ACRs))
        return Action.C if self.current_ACR < history_average else Action.D

class Strategy_EXPLOITATIVE_465(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-CT) Strategy in Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.h = int(self.n_rounds * 0.5)
        self.ML = 1
        self.step_size = 1
        self.CT = int((self.capacity - 2 * self.n_players) / (2 * self.h))
        self.history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        current_stock = state.current_stock
        self.history.append(current_stock)
        if len(self.history) > self.h + 1:
            self.history.pop(0)
        total_avg_stock = np.mean(np.array(self.history[-self.h - 1:-1]))
        if total_avg_stock > self.CT + self.ML:
            self.CT += 1
        elif total_avg_stock < self.CT - self.ML:
            self.CT -= 1
        action = Action.C if total_avg_stock > self.CT else Action.D
        return action

class Strategy_EXPLOITATIVE_466(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_round = 0
        self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is None:
            self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros((self.game_description.n_rounds, self.game_description.n_players)))
        if state.round_number == 0:
            return Action.C
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
            return Action.D
        self.current_round += 1
        self.history.my_actions[self.current_round - 1] = (self.__class__.__name__[4] == 'C').astype(bool)
        if state.round_number < self.game_description.n_rounds:
            self.history.my_payoffs[self.current_round - 1] = state.current_stock / (2 * self.game_description.n_players) * (self.__class__.__name__[4] == 'C').astype(bool)
        if state.round_number > 0:
            self.history.opponent_actions[-1, :] = history.opponent_actions[-2, :].copy()
            self.history.opponent_payoffs[-1, :] = history.opponent_payoffs[-2, :].copy()
        return self.__class__.__name__[4]

class Strategy_EXPLOITATIVE_467(BaseStrategy):
    """
    Strategy name: Tit-for-Tat-Plus (TfT+)
    Summary: This strategy cooperates in the first round, and then responds to opponent's actions in subsequent rounds. If the opponent cooperated, it cooperates back; if the opponent defected, it punishes them (with a random element). In the last round, it always cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.random = random.Random()

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if not history:
            return Action.C
        opponent_action = history.opponent_actions[-1, 0] if round_num > 0 else None
        if round_num == self.game_description.n_rounds - 1:
            return Action.C
        elif opponent_action is not None and round_num > 0:
            if opponent_action:
                return Action.C
            elif self.random.randint(1, 20) < 5:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_469(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Adaptation (TFTSA)

    Implementation of the Tit-for-Tat strategy with stock adaptation for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history.my_actions[0] = True
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        my_action = self.history.my_actions[-1]
        opponents_cooperated = sum(self.history.opponent_actions[-1, :])
        action_prev = self.history.my_actions[-2] if state.round_number > 0 else None
        last_few_rounds = self.game_description.n_rounds - state.round_number <= self.game_description.n_players * 2
        if my_action and opponents_cooperated == self.game_description.n_players:
            return Action.C
        elif my_action and (not opponents_cooperated) and (not action_prev or last_few_rounds):
            return Action.D
        elif not my_action and opponents_cooperated > 0 and action_prev:
            return Action.D
        elif not my_action:
            return Action.C

class Strategy_EXPLOITATIVE_470(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TfTA-C) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_threshold = math.ceil(game_description.n_players / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif not history or (history and np.all(history.my_actions[-1] == [False])):
            return Action.D
        else:
            opponents_cooperated = sum(history.opponent_actions[-1])
            if opponents_cooperated >= self.forgiveness_threshold:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if np.any(history.opponent_payoffs[-1]) < self.payoff_if_cooperate(state, history):
                return Action.C
            else:
                return Action.D

    def payoff_if_cooperate(self, state: CommonPoolState, history: PlayerHistory) -> float:
        if not history or (history and np.all(history.my_actions[-1] == [False])):
            return state.current_stock / self.game_description.n_players * Action.C.value
        else:
            opponent_cooperated = sum(history.opponent_actions[-1])
            opponent_defected = self.game_description.n_players - opponent_cooperated
            opponent_payoffs = history.opponent_payoffs[-1]
            cooperators_payoff = np.mean(opponent_payoffs[opponent_cooperated])
            defectors_payoff = np.mean(opponent_payoffs[opponent_defected])
            return (state.current_stock / self.game_description.n_players * Action.C.value + cooperators_payoff + defectors_payoff) / 2

class Strategy_EXPLOITATIVE_471(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.8
        self.history = PlayerHistory(my_actions=np.zeros((game_description.n_rounds,), dtype=bool), my_payoffs=np.zeros((game_description.n_rounds,), dtype=float), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=float))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.history = history
        if state.round_number == 0:
            return Action.C
        opponent_strategy = self._analyze_past_actions()
        if opponent_strategy == 'cooperative':
            return Action.C
        elif opponent_strategy == 'defective':
            if state.current_stock / self.game_description.capacity <= self.threshold:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _analyze_past_actions(self) -> str:
        """
        Analyzes past actions and returns cooperative, defective, or unclear.
        """
        opponent_cooperators = self.history.opponent_actions[-1].sum()
        if opponent_cooperators >= self.game_description.n_players // 2:
            return 'cooperative'
        elif opponent_cooperators == 0:
            return 'defective'
        else:
            return 'unclear'

class Strategy_EXPLOITATIVE_472(BaseStrategy):
    """
    A strategy that cooperates initially and adapts its cooperation based on the opponent's behavior, while also maintaining an adaptive cooperation threshold to prevent stock depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.n_players // 2
        self.forgiveness_window = int(game_description.n_rounds / 2)

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        opponent_behavior = history.opponent_actions[:, -1] if history else None
        if opponent_behavior is None:
            return Action.C
        stock = state.current_stock
        len_history = history.my_actions.shape[0]
        if len(opponent_behavior) < len_history - self.forgiveness_window:
            if stock < self.stock_threshold:
                return Action.C
            elif opponent_behavior[-1] == Action.D:
                return Action.D
            else:
                for round_idx in range(self.forgiveness_window):
                    if history.opponent_actions[:, round_idx][-1] != opponent_behavior[round_idx]:
                        break
                if round_idx < self.forgiveness_window:
                    return opponent_behavior[-1]
        if stock < self.stock_threshold:
            return Action.C
        elif opponent_behavior[-1] == Action.D:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_473(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = math.ceil(game_description.n_players / 2)
        self.stock_growth_multiplier = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C if self.cooperation_threshold > 1 else Action.D
        round_num = state.round_number
        opponent_cooperated_last_round = sum(history.opponent_actions[-1]) >= self.game_description.n_players // 2
        if round_num == self.game_description.n_rounds:
            return Action.C
        elif round_num == 0:
            return Action.C if self.cooperation_threshold > 1 else Action.D
        else:
            cooperate = opponent_cooperated_last_round and self.cooperation_threshold > round_num
            self.stock_growth_multiplier *= 0.98 if cooperate else 0.95
            return Action.C if cooperate else Action.D

class Strategy_EXPLOITATIVE_474(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or (len(history.my_actions) < state.round_number and len(history.opponent_actions[state.round_number - 1]) == 0):
            return Action.C
        opponent_action = history.opponent_actions[state.round_number - 1, 0] if len(history.opponent_actions[state.round_number - 1]) > 0 else self.history.opponent_actions[-1, 0]
        stock_percentage = state.current_stock / self.game_description.capacity
        if opponent_action:
            return Action.C
        elif stock_percentage < 0.8 and (not opponent_action):
            return Action.C
        else:
            return Action.D

    def update_history(self, my_action: Action, payoff: float):
        self.history.my_actions[self.history.my_actions.shape[0] - 1] = my_action == Action.C
        self.history.my_payoffs[-1] = payoff
        self.history.opponent_actions[-1, 0] = not self.history.opponent_actions[-2, 0] if len(self.history.opponent_actions) > 1 else False

class Strategy_EXPLOITATIVE_475(BaseStrategy):
    """
    Implementation of Adaptive Stock-based Tit-for-Tat (ASTfT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity / game_description.n_players * 2
        self.threshold = self.capacity
        self.rounds_since_defect = 0
        self.rounds_since_cooperation = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            self.threshold = self.capacity
            self.rounds_since_defect = 0
            self.rounds_since_cooperation = 0
            return Action.C
        opponent_actions = history.opponent_actions if history else np.zeros((state.round_number, self.game_description.n_players), dtype=bool)
        self.rounds_since_defect = np.count_nonzero(np.logical_not(opponent_actions[-1])) + 1
        self.rounds_since_cooperation = state.round_number - self.rounds_since_defect
        if state.current_stock > self.threshold:
            return Action.C
        elif self.rounds_since_defect > 0 and state.round_number != self.game_description.n_rounds:
            new_threshold = (self.capacity / (2 * (self.game_description.n_players + 1)) - self.threshold) * self.rounds_since_defect + self.threshold
            self.threshold = min(max(new_threshold, self.capacity / (2 * self.game_description.n_players)), self.capacity)
        return Action.D

class Strategy_EXPLOITATIVE_476(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation Strategy
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.coop_threshold = game_description.capacity // 2
        self.last_round_coop_threshold = game_description.capacity - math.floor(game_description.capacity / game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        last_action_opponent = Action(int(history.opponent_actions[-1, -1])) if history else None
        if state.round_number > 1 and last_action_opponent != Action.C:
            if state.round_number > 2:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds and state.current_stock >= self.last_round_coop_threshold:
            return Action.C
        if state.current_stock >= self.coop_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_477(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperative Threshold (TFT-CT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cumulative_cooperation = 0
        self.safety_level = math.floor(game_description.capacity * 0.5)
        self.ct = int(game_description.n_players * 0.6)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if not history:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        cumulative_cooperation = sum(history.my_actions) + sum(opponent_actions)
        current_stock = state.current_stock
        if state.round_number == len(history.opponent_payoffs):
            return Action.C
        if current_stock <= 0 and state.round_number > 1:
            return Action.D
        action = Action.C
        if state.round_number > 1:
            if opponent_actions[-1]:
                if current_stock < self.safety_level or cumulative_cooperation > self.ct:
                    action = Action.D
                elif current_stock >= self.safety_level and cumulative_cooperation <= self.ct:
                    action = Action.C
            elif current_stock < self.safety_level or cumulative_cooperation > self.ct:
                action = Action.D
            elif current_stock >= self.safety_level and cumulative_cooperation <= self.ct:
                action = Action.C
        self.cumulative_cooperation = cumulative_cooperation
        return action

class Strategy_EXPLOITATIVE_479(BaseStrategy):
    """
    Tit-for-Tat with Stock Awareness (TfT-SA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.initial_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock = min(state.current_stock, self.initial_stock)
        if stock >= self.capacity:
            return Action.C
        elif stock > 0:
            last_action = history.my_actions[-1] if history is not None else None
            return Action.C if last_action == Action.C else Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_480(BaseStrategy):
    """
    This strategy is called Tit-for-Tat with Stock Adaptation (TFT-SA). It cooperates initially, then decides to cooperate or defect based on opponents' actions in the previous round and the current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_payoff = np.mean(history.my_payoffs[:state.round_number])
        opponents = history.opponent_actions[state.round_number - 1]
        stock = state.current_stock
        if all(opponents):
            return Action.C
        elif any(opponents) and stock < self.capacity:
            return Action.C
        elif any(opponents):
            return Action.D
        elif stock >= self.capacity - (self.game_description.n_rounds - state.round_number + 1) * 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_481(BaseStrategy):
    """
    The Tit-for-Tat Exploitative Strategy (TFT-E) for the Common Pool Resource Game.
    TFT-E cooperates initially, but responds to opponent's actions in subsequent rounds by adopting a tit-for-tat approach:
        - Cooperate if the opponent cooperated in the previous round;
        - Defect if the opponent defected in the previous round and revert back to cooperation in the following round.
    In the first round, TFT-E cooperates regardless of the opponent's strategy, and always cooperates in the last round to maximize potential payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_counter = 0
        self.opponent_cooperation_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.round_counter = state.round_number + 1
            if self.round_counter == 1:
                return Action.C
            opponent_cooperation_in_last_round = sum(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2
            if self.round_counter < self.game_description.n_rounds:
                return Action.C if opponent_cooperation_in_last_round else Action.D
        return Action.C

class Strategy_EXPLOITATIVE_482(BaseStrategy):
    """
    Implementation of Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.n_players // 2
        self.payoff = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        opponent_last_action = Action.D if history is None else history.opponent_actions[state.round_number - 1, -1]
        if state.round_number != self.game_description.n_rounds:
            if opponent_last_action == Action.D and self.cooperation_threshold > 0:
                self.cooperation_threshold -= 1
            elif opponent_last_action == Action.C:
                self.cooperation_threshold = self.cooperation_threshold
        if state.current_stock <= 0 or state.round_number == self.game_description.n_rounds:
            return Action.D
        return Action.C if state.current_stock > self.cooperation_threshold else Action.D

class Strategy_EXPLOITATIVE_483(BaseStrategy):
    """
    Tit-for-Tat Common Pool Resource Game Strategy with stock thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_deterioration_threshold = 0.5 * game_description.capacity / game_description.n_players
        self.stock_prosperity_threshold = 1.2 * game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[-1, -1] if history else None
        stock_level = state.current_stock
        if opponent_action is None:
            return Action.D
        elif opponent_action and stock_level > self.stock_prosperity_threshold:
            return Action.C
        elif not opponent_action and stock_level < self.stock_deterioration_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_484(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        action = Action.C
        if not self._last_round and state.round_number > 0:
            opponent_actions = history.opponent_actions[-1]
            cooperators = sum(opponent_actions)
            action = Action.C if cooperators >= self.game_description.n_players // 2 else Action.D
        self._last_round = state.round_number == self.game_description.n_rounds
        if self._last_round:
            if state.current_stock < self.game_description.capacity * self.game_description.n_players * 0.25 or state.current_stock > self.game_description.capacity * self.game_description.n_players * 0.75:
                action = Action.D
            else:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_485(BaseStrategy):
    """
    Tit-for-Tat with Growth Adaptation (TFT-GA) strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_percentage = 0.9
        self.critical_stock_percentage = 0.7
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        opponent_payoffs = history.opponent_payoffs[-1]
        if sum(opponent_actions) >= len(opponent_actions) // 2:
            action = Action.C
        else:
            action = Action.D
        if state.current_stock / self.game_description.capacity >= self.capacity_percentage:
            action = Action.C
        elif state.current_stock / self.game_description.capacity < self.critical_stock_percentage:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            self.last_round = True
            if state.current_stock / self.game_description.capacity >= self.critical_stock_percentage + 0.3:
                action = Action.C
            else:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_487(BaseStrategy):
    """
    A Tit-for-Tat with Stock Adaptation (TFTSA) player strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_size = math.ceil(game_description.n_rounds * 0.8)
        self.corratio = game_description.capacity * (2 * game_description.n_players - 1) / (2 * game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        average_consumption = np.mean(history.opponent_actions[-self.history_size:-1].sum(axis=0))
        return Action.C if average_consumption < self.corratio else Action.D

class Strategy_EXPLOITATIVE_488(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFTSA) strategy for the Common Pool Resource Game.
    The strategy cooperates initially and responds to opponents' actions, while also adapting based on the current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=bool)
        cooperators = sum(last_round)
        if state.current_stock < self.threshold:
            action = Action.D if np.mean(last_round) > 0 else Action.C
        elif cooperators >= self.game_description.n_players // 2:
            action = Action.C
        else:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_489(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adjustable Cooperation Threshold (TFT-ACT)
    Strategy Description: A strategy that cooperates initially to build trust, then adjusts cooperation based on opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = int(0.3 * self.game_description.n_players)
        self.punishment_probability = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        cooperation_count = sum(history.opponent_actions[-1]) if history else 0
        if cooperation_count >= self.game_description.n_players:
            return Action.C
        elif cooperation_count < self.cooperation_threshold:
            return Action.D
        else:
            random_value = random.random()
            if random_value > self.punishment_probability:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_490(BaseStrategy):
    """
    Implementation of the Fischbeck Strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity * (game_description.n_players - 1) / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        consumption = np.sum(history.my_actions[-1]) * (self.game_description.n_players / self.game_description.capacity)
        current_stock = state.current_stock - consumption
        action = Action.C if current_stock > self.threshold else Action.D
        random_bias = 0.5 if current_stock > self.threshold else 0.25
        return Action(random.choice([0, 1]) < random_bias)

class Strategy_EXPLOITATIVE_491(BaseStrategy):
    """
    A Tit-for-Tat Strategy with Adaptive Cooperative Threshold (TFT-ACT) for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_threshold = 2 * game_description.n_players
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and self.round_number < self.game_description.n_rounds - 1:
            last_round = len(history.opponent_actions) - 1
            cooperators = sum(history.opponent_actions[last_round, :])
            cooperation_threshold = self.initial_threshold * (1 - (self.game_description.n_rounds - self.round_number) / self.game_description.n_rounds)
            if state.current_stock >= cooperation_threshold:
                last_action = history.opponent_actions[-1, -1]
                return Action.C if last_action else Action.D
        self.round_number += 1
        return Action.C if self.round_number < 4 or state.current_stock >= self.game_description.capacity // (self.game_description.n_players * 2) else Action.D

class Strategy_EXPLOITATIVE_492(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TfT-ACT) Strategy in Common Pool Resource Game
    This strategy cooperates initially, then adaptively switches between cooperation and defection based on the average stock level over the last m rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_rounds * 0.8)
        self.average_stock = np.zeros(self.m + 1)
        self.ct = game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number < self.game_description.n_rounds and history is not None:
            opponent_cooperated = sum(history.opponent_actions[-1]) > 0
            if not opponent_cooperated:
                if state.current_stock / self.game_description.capacity < self.ct:
                    return Action.D
        return Action.C

    def update_average_stock(self, new_state: CommonPoolState) -> None:
        """
        Updates the running average of stock levels for adaptive cooperation threshold calculation
        """
        self.average_stock = np.roll(self.average_stock, 1)
        self.average_stock[-1] = new_state.current_stock

    def set_final_payoff(self, history: PlayerHistory) -> None:
        """
        Calculates and sets the total payoff for this strategy over the game rounds
        """
        if self.game_description.n_rounds > 1:
            self.payoff = np.sum(history.my_payoffs[1:])

class Strategy_EXPLOITATIVE_493(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.memory_window = int(math.ceil(game_description.n_rounds / 2))
        self.threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        cooperators = np.sum(history.opponent_actions[:, :state.round_number], axis=1) > self.memory_window * self.threshold
        if np.mean(cooperators) > self.threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_494(BaseStrategy):
    """A strategy that cooperates initially and responds to opponent's actions based on stock level."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = self.game_description.n_players * 0.5

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number < self.game_description.n_rounds and (not history)):
            return Action.C
        if state.round_number >= self.game_description.n_rounds:
            if history.my_actions[-1] == Action.C and history.current_stock > 0:
                return Action.C
            return Action.D
        current_player = state.round_number % self.game_description.n_players
        previous_cooperators = np.sum(history.opponent_actions[-1])
        if previous_cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif state.current_stock < self.stock_threshold and history.my_payoffs[-1] == 0:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_495(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)
    Strategy Description: This strategy cooperates initially, and responds reciprocally to opponents' actions. It punishes defection by defecting back but encourages future cooperation if the opponent cooperates again after being punished. The strategy also considers cooperating in the last round if both players have roughly equal total payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.tolerance = self.game_description.n_players // 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        opponent_cooperated = sum(history.opponent_actions[last_round, :]) >= self.game_description.n_players // 2
        if opponent_cooperated:
            return Action.C
        opponent_defected = sum(history.opponent_actions[last_round, :]) == len(history.opponent_actions[last_round, :])
        if opponent_defected:
            return Action.D
        payoff_ratio = np.mean(history.my_payoffs) / np.mean(history.opponent_payoffs[0])
        if state.round_number == self.game_description.n_rounds - 1 and math.isclose(payoff_ratio, 1, abs_tol=self.tolerance):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_496(BaseStrategy):
    """
    Tit-for-Tat-Growth Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.stock_history = np.array(history.my_payoffs)
        if state.round_number == 0 or self.stock_history is None:
            return Action.C
        average_stock = np.mean(self.stock_history)
        if average_stock > self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_497(BaseStrategy):
    """
    Tit-for-Tat Strategy with Adaptive Cooperative Threshold (TFT-CT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = self.game_description.n_players
        self.capacity = self.game_description.capacity
        self.current_stock = 0.0
        self.last_round_cooperators = 0
        self.average_stock_level = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.current_stock = state.current_stock
        if state.round_number == 0:
            return Action.C
        elif self.current_stock <= 0:
            return None
        adaptive_cooperative_threshold = min(self.capacity / self.n_players, 1.5 * (self.average_stock_level if self.average_stock_level is not None else 0))
        cooperators = sum(history.opponent_actions[-1, :]) if history is not None else 0
        if state.round_number == self.game_description.n_rounds - 1 or self.current_stock >= adaptive_cooperative_threshold:
            return Action.C
        elif cooperators < self.n_players // 2 and self.last_round_cooperators <= (self.n_players - 1) // 2:
            return Action.D
        elif cooperators >= self.n_players // 2:
            return Action.C
        else:
            return Action.D
        if history is not None:
            self.last_round_cooperators = sum(history.opponent_actions[-1, :])
            if len(history.my_payoffs) > 0 and self.average_stock_level is None:
                self.average_stock_level = np.mean(history.my_payoffs)

class Strategy_EXPLOITATIVE_498(BaseStrategy):
    """
    Strategy that implements Tit-for-Tat with Adaptive Cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_cp = 0.5
        self.max_cooperative_punishment_counter = 3
        self.min_aggressive_reward_counter = 1
        self.cooperative_punishment_counter = 0
        self.aggressive_reward_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.cooperative_punishment_counter = max(self.cooperative_punishment_counter - 1, 0)
            self.aggressive_reward_counter = max(self.aggressive_reward_counter - 1, 0)
        if history.opponent_actions is None:
            return Action.C
        opponent_cooperation_average = np.mean(history.opponent_actions[-1])
        cooperative_punishment_factor = self.initial_cp * self.max_cooperative_punishment_counter if opponent_cooperation_average >= 0.5 else 0
        aggressive_reward_factor = self.initial_cp * self.min_aggressive_reward_counter if np.mean(history.opponent_actions[-1]) == 0 else 0
        cooperation_probability = self.initial_cp + ((1 - self.initial_cp) * (1 - opponent_cooperation_average) + cooperative_punishment_factor + aggressive_reward_factor)
        if state.current_stock < self.game_description.capacity / 2:
            return Action.D
        random_decision = random.random()
        return Action(1 if random_decision <= cooperation_probability else 0)

class Strategy_EXPLOITATIVE_499(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = math.floor(self.game_description.n_players / 2)
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        if state.round_number == 0:
            return Action.C
        opponent_cooperators_in_previous_round = sum(history.opponent_actions[-1])
        current_opponent_action = history.opponent_actions[-1, -1]
        self.last_opponent_action = current_opponent_action
        if opponent_cooperators_in_previous_round >= self.cooperation_threshold:
            self.cooperation_threshold = min(self.game_description.n_players, self.cooperation_threshold + 1)
        if current_opponent_action == Action.C:
            return Action.C
        elif self.last_opponent_action is None or state.round_number == self.game_description.n_rounds - 1:
            self.cooperation_threshold = math.floor(self.game_description.n_players / 2)
        return Action.D

class Strategy_EXPLOITATIVE_501(BaseStrategy):
    """
    A game theory strategy called Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_cooperation_threshold = 0.5
        self.cooperation_threshold = None
        self.opponent_history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.cooperation_threshold = self.initial_cooperation_threshold
            return Action.C
        self.opponent_history = history
        if state.round_number == 0:
            return Action.C
        if self.cooperation_threshold is None or len(self.opponent_history.my_actions) < self.game_description.n_rounds:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        total_cooperation = sum(self.opponent_history.my_actions)
        total_rounds = len(self.opponent_history.my_actions)
        cooperation_threshold = math.ceil((capacity - current_stock) / current_stock) if current_stock > 0 else 1
        cooperation_threshold = min(cooperation_threshold, max(self.initial_cooperation_threshold, 1))
        average_cooperate_percentage = total_cooperation / total_rounds
        return Action.C if average_cooperate_percentage >= cooperation_threshold else Action.D

class Strategy_EXPLOITATIVE_502(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Defection (TFT-AD) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_length = int(game_description.n_players * 0.8)
        self.opponent_history = np.zeros((self.game_description.n_rounds, 1), dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_history = np.roll(self.opponent_history, -1)
            self.opponent_history[-1] = history.opponent_actions[-1, 0]
        if np.count_nonzero(self.opponent_history[-1]) == self.game_description.n_players:
            self.punishment_length = min(self.punishment_length * 2, self.game_description.n_rounds)
        elif np.count_nonzero(self.opponent_history[-1]) == 0:
            self.punishment_length = max(self.punishment_length // 2, 1)
        else:
            self.punishment_length = self.game_description.n_players
        return Action.C if state.round_number < self.punishment_length and self.opponent_history[-1] else Action.D

class Strategy_EXPLOITATIVE_503(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (A-TFT) strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros((1,)), np.zeros((1, game_description.n_players), dtype=bool), np.zeros((1,)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number > 0 and history is None):
            return Action.C
        opponent_cooperated_last_round = sum(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2
        if state.round_number == self.game_description.n_rounds or (opponent_cooperated_last_round and history.my_actions[-1] == Action.C):
            return Action.C
        return Action.D

    def update(self, state: CommonPoolState, my_action: Action, opponent_actions: NDArray[np.bool_]) -> None:
        self.history = PlayerHistory(np.vstack([self.history.my_actions, np.array([my_action])]), np.vstack([self.history.my_payoffs, [state.current_stock / (2 * self.game_description.n_players)]]), opponent_actions, np.vstack([self.history.opponent_payoffs, state.current_stock / np.repeat(self.game_description.n_players, len(opponent_actions), axis=0)]))

class Strategy_EXPLOITATIVE_504(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) Strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = 0
        self.minimum_stock = game_description.capacity / 10
        self.average_cooperation = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            cooperators = sum(history.opponent_actions[:, -1])
            cooperation_level = cooperators / self.game_description.n_players
            if cooperation_level >= self.cooperative_threshold / self.game_description.capacity:
                return Action.C
            return Action.D
        self.average_cooperation[state.round_number - 1] = sum(history.opponent_actions[:, -1]) / self.game_description.n_players
        cooperative_threshold = self.game_description.capacity * self.game_description.n_players / (2 * self.game_description.n_rounds)
        if state.current_stock < self.minimum_stock:
            cooperative_threshold *= 1.1
        elif history.opponent_actions[-1, -1] and self.average_cooperation[-1] >= self.cooperative_threshold / self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_505(BaseStrategy):
    """
    A variant of Tit-for-Tat strategy that adapts to an opponent's behavior by adjusting a threshold for tolerating defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        super().__init__(game_description)
        self.capacity = game_description.capacity
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.T = int(self.r * 0.7)
        self.recent_opponent_actions = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        round_number = state.round_number
        if round_number == 0 or history is None:
            action = Action.C
        elif round_number < self.r:
            if len(self.recent_opponent_actions) > self.T:
                recent_cooperators = sum(history.opponent_actions[-self.T:, self.__class__.__name__])
                if recent_cooperators >= self.n - self.n * 0.3:
                    threshold = math.ceil(round_number * 0.1)
                    if history.opponent_actions[round_number - 1, self.__class__.__name__] == Action.D:
                        if len(history.opponent_actions[max(0, round_number - threshold):round_number, self.__class__.__name__]) > threshold:
                            action = Action.D
                else:
                    action = history.opponent_actions[-1, self.__class__.__name__]
        return action

class Strategy_EXPLOITATIVE_506(BaseStrategy):
    """
    Tit-for-Tat-Greedy (TfT-G) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            stock = state.current_stock
            return Action.D if stock < self.game_description.n_players * (self.game_description.capacity - stock) / self.game_description.capacity else Action.C
        total_consumption = np.sum(history.my_actions[:state.round_number]) if history is not None else 0
        current_average_stock = state.current_stock + total_consumption
        if self.average_stock is None:
            self.average_stock = current_average_stock / self.game_description.n_players
        action = Action.C if current_average_stock >= self.average_stock else Action.D
        if action == Action.D and state.current_stock < (self.game_description.capacity - total_consumption) * (2 * self.game_description.n_players - total_consumption) / self.game_description.capacity:
            return action
        return action

class Strategy_EXPLOITATIVE_508(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.h = int(self.game_description.capacity / (2 * self.game_description.n_players))
        self.initial_CCT = self.game_description.capacity / (2 * self.game_description.n_players)
        self.CCT = self.initial_CCT
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and self.history is None:
            return Action.C
        self.history = history
        consumption = np.mean(history.opponent_actions[-self.h:].sum(axis=1))
        action = Action.C if consumption < self.CCT else Action.D
        stock_depletion = state.current_stock - self.game_description.capacity
        crash = stock_depletion <= 0 or stock_depletion >= self.game_description.capacity * 0.85
        if action == Action.C and crash:
            self.adjust_CCT(crash, history)
        elif action == Action.D and state.current_stock > self.game_description.capacity * 0.75:
            self.adjust_CCT(history, crash)
        return action

    def adjust_CCT(self, history, crash):
        if crash:
            self.CCT *= 0.9
        elif self.CCT > self.initial_CCT and np.mean(history.opponent_payoffs[-1]) >= self.initial_CCT:
            self.CCT *= 0.85
        elif self.CCT < self.initial_CCT and np.mean(history.opponent_payoffs[-1]) <= self.initial_CCT:
            self.CCT *= 1.25

class Strategy_EXPLOITATIVE_509(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFTSA) strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgive_rounds = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[state.round_number - 1][0]
        if opponent_action and state.round_number > self.forgive_rounds:
            return Action.D
        elif not opponent_action:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_510(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = None
        self.rounds_for_average = math.floor(game_description.n_players / 2)
        if game_description.n_players <= 4:
            self.rounds_for_average = game_description.n_players

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        action = Action.C
        if state.round_number == 0:
            return action
        if self.cooperative_threshold is None or state.round_number - self.cooperative_threshold >= self.rounds_for_average:
            cooperators = np.sum(history.opponent_actions[:, -self.rounds_for_average:].sum(axis=1) > 0)
            self.cooperative_threshold = state.round_number
            if cooperators >= self.game_description.n_players // 2 or np.count_nonzero(history.opponent_actions[:, -self.rounds_for_average:].sum(axis=1)) == self.game_description.n_players:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_511(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Greed (TfT-AG) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_stock_after_consumption = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or len(history.opponent_actions) == 0:
            self.current_stock_after_consumption = 0.0
            return Action.C
        total_consumption = np.sum(history.my_actions[-1]) * (self.game_description.capacity // (2 * self.game_description.n_players * state.round_number))
        tsaf = self.current_stock_after_consumption - total_consumption if self.current_stock_after_consumption > 0 else 1.0
        if np.all(history.my_actions[-1]) and tsaf >= 1.0:
            return Action.C
        elif np.sum(history.my_actions[-1]) < self.game_description.n_players and tsaf < 1.0:
            return Action.D
        else:
            return Action.C

    def update_state(self, total_consumption: float):
        """
        Update the current stock level after consumption.
        """
        self.current_stock_after_consumption = max(0.0, 2 * self.current_stock_after_consumption * (1 - self.current_stock_after_consumption / self.game_description.capacity) + total_consumption)

class Strategy_EXPLOITATIVE_512(BaseStrategy):
    """
    A strategy that cooperates initially, and adapts to opponents' behavior based on their average consumption.
    If an opponent consistently consumes less than a calculated threshold, the strategy cooperates; otherwise, it defects.
    The threshold is dynamically adjusted based on current state (stock level, number of rounds remaining).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = None
        self.opponent_average_consumption = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        action = Action.C
        if state.round_number == 0:
            return Action.C
        elif self.threshold is None or len(history) < self.game_description.n_rounds:
            pass
        else:
            average_consumption = np.mean(self.opponent_average_consumption)
            stock_level = state.current_stock
            rounds_left = self.game_description.n_rounds - state.round_number
            threshold = math.ceil((1 + self.game_description.capacity / (2 * self.game_description.n_players)) * stock_level / rounds_left)
            if history.opponent_actions[-1].sum() > threshold:
                action = Action.D
            elif history.opponent_actions[-1].sum() < threshold - 1:
                action = Action.C
        if state.round_number == self.game_description.n_rounds - 1 and action == Action.C:
            pass
        if history is not None:
            if history.opponent_actions[-1, -1] != history.my_actions[-1]:
                self.opponent_average_consumption[-1] = history.opponent_actions[-1].sum() / self.game_description.n_players
            else:
                pass
        return action

class Strategy_COLLECTIVE_25(BaseStrategy):
    """
    A strategy that adapts its actions based on the current stock level and the number of cooperators in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def calculate_payoff(self, stock: float) -> tuple[float, float]:
        potential_growth = 2 * min(stock, self.capacity) * ((self.capacity - stock) / (self.capacity * (self.n_players - 1)))
        return (stock / (2 * self.n_players) + potential_growth, stock / self.n_players)

    def decide_action(self, stock: float, history: PlayerHistory) -> Action:
        payoffs = self.calculate_payoff(stock)
        if payoffs[0] > payoffs[1]:
            return Action.C
        else:
            return Action.D

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is not None and state.round_number > 0:
            stock = state.current_stock
            action = self.decide_action(stock, history)
        elif state.round_number == 0:
            potential_payoffs = self.calculate_payoff(state.current_stock)
            action = Action.C if potential_payoffs[0] >= potential_payoffs[1] else Action.D
        else:
            action = Action.C
        return action

class Strategy_COLLECTIVE_29(BaseStrategy):
    """
    A Tit-for-Tat Adaptive strategy for the Common Pool Resource Game.
    This strategy encourages a cooperative environment by reciprocating cooperative behavior and retaliating against defection in a limited manner.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if len(self.opponent_cooperation_history) > 0 and state.round_number == self.opponent_cooperation_history[-1]:
            return Action.C
        if history is not None:
            self.update_opponent_cooperation_history(history)
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        if len(self.opponent_cooperation_history) > 0 and self.opponent_cooperation_history[-1] == 0:
            return Action.D
        return Action.C

    def update_opponent_cooperation_history(self, history: PlayerHistory):
        cooperation = sum(history.opponent_actions[-1, :])
        self.opponent_cooperation_history.append(int(cooperation >= len(history.opponent_actions) // 2))

class Strategy_COLLECTIVE_47(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT)
    A strategy that cooperates initially and adapts its actions based on the previous round's collective behavior.
    It punishes continuous defection and encourages cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_strategy = 'cooperate'
        self.punish_threshold = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        if state.round_number < self.game_description.n_rounds - 1 and self.current_strategy == 'cooperate':
            cooperators = sum(history.opponent_actions[-1])
            if cooperators == self.game_description.n_players:
                return Action.C
            else:
                return Action.D
        if self.current_strategy == 'cooperate':
            recent_history = history.opponent_actions[-self.punish_threshold:]
            cooperators = sum(recent_history.flatten())
            if cooperators >= self.game_description.n_players - self.punish_threshold:
                return Action.C
            else:
                return Action.D
        elif self.current_strategy == 'defect':
            recent_history = history.opponent_actions[:, :self.game_description.n_players]
            if all((recent_history[-1, player] == False for player in range(self.game_description.n_players))):
                return Action.D
            else:
                self.current_strategy = 'cooperate'
                return Action.C

class Strategy_COLLECTIVE_59(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Growth-Based Threshold (ATGT) strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        all_cooperators = np.all(history.opponent_actions[last_round])
        growth_rate = self.calculate_growth_rate(state, history)
        if all_cooperators:
            return Action.C
        elif growth_rate >= self.threshold * state.current_stock:
            return Action.D
        else:
            return Action.D

    def calculate_growth_rate(self, state: CommonPoolState, history: PlayerHistory) -> float:
        total_consumption = np.sum(history.my_actions[1:] * (state.current_stock // self.game_description.n_players))
        stock_after_consumption = state.current_stock - total_consumption
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
        return growth

class Strategy_COLLECTIVE_83(BaseStrategy):
    """
    Adaptive Cooperative Strategy (ACS) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.r = game_description.n_rounds
        self.history = None
        self.stock_growth_total = 0
        self.cooperation_ratio = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        if history is None and state.round_number == 0:
            return Action.C
        self.history = history
        stock = state.current_stock
        round_number = state.round_number
        ASCR = (self.capacity - stock) / self.r
        if ASCR > 1:
            return Action.D
        if ASCR < 1 and ASCR > (2 * self.n_players - 1) / (2 * self.r):
            return Action.C
        cooperation_ratio = np.mean(self.history.my_actions[:round_number]) if round_number > 0 else 0
        if stock == 0 and round_number != self.r:
            return Action.C if random.random() < 0.01 else Action.D
        if cooperation_ratio >= 0.5:
            if stock == 0 and round_number != self.r:
                return Action.C
            else:
                return Action.C
        elif stock == 0 and round_number != self.r:
            return Action.D
        else:
            return np.where(self.history.my_actions[:round_number].flatten() >= cooperation_ratio, Action.C, Action.D)

class Strategy_COLLECTIVE_88(BaseStrategy):
    """Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.consecutive_defections = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or self.last_opponent_action is None:
            self.last_opponent_action = False if history is None else history.opponent_actions[-1, -1]
        if self.last_opponent_action:
            return Action.C
        elif self.consecutive_defections >= 2:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections == 1:
            return Action.D
        else:
            self.consecutive_defections += 1
        return Action.C

class Strategy_COLLECTIVE_99(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth (ATFSG) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        opponent_cooperated = sum(history.opponent_actions[-1]) > 0
        current_stock = state.current_stock
        if opponent_cooperated and current_stock > 0:
            return Action.C
        elif current_stock == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_107(BaseStrategy):
    """
    Strategy that implements the Adaptive Tit-for-Tat strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions if history else np.zeros((state.round_number, self.game_description.n_players), dtype=bool)
        self.last_opponent_action = opponent_actions[-1, 0 if not history else -1]
        return Action(int(self.last_opponent_action == Action.C))

class Strategy_COLLECTIVE_109(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            cooperation_avg = np.mean(history.opponent_actions[:, :self.game_description.n_players - 1])
            return Action.C if cooperation_avg > (self.game_description.n_players - 1) / 2 else Action.D
        action = history.opponent_actions[state.round_number - 1, :]
        average_action = np.mean(action)
        return Action.C if average_action == 1 else Action.D

class Strategy_COLLECTIVE_125(BaseStrategy):
    """
    A simple implementation of the Tit-for-Tat-Growth strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_payoff = None
        self.total_payoff = 0
        self.initial_trust = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C if state.round_number == 0 else None
        if history is not None and history.my_actions[-1] is not None:
            self._update_payoff_statistics(history)
            if self.total_payoff < self.average_payoff:
                action = Action.C if self.initial_trust else Action.D
            elif state.current_stock / self.game_description.capacity <= 0.5:
                action = Action.C
            else:
                action = Action.D
            self.initial_trust = action == Action.C if history.my_actions[-1] == Action.C else False
        return action

    def _update_payoff_statistics(self, history: PlayerHistory):
        payoffs = np.array([history.my_payoffs[round] for round in range(len(history.my_payoffs))])
        self.average_payoff = np.mean(payoffs) if len(payoffs) > 0 else None
        self.total_payoff += payoffs[-1]

class Strategy_COLLECTIVE_130(BaseStrategy):
    """
    A simple Adaptive Tit-for-Tat strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponents = set()
        self.current_round = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        opponent_actions = history.opponent_actions[-self.current_round + 1, :] if history else np.zeros(self.game_description.n_players).astype(int)
        self.opponents.update({i for i in range(len(opponent_actions)) if opponent_actions[i].sum() == 1})
        if np.all(opponent_actions[-1] == 1):
            return Action.C
        elif np.all(opponent_actions[-1] == 0):
            return Action.D
        elif self.current_round < self.game_description.n_rounds or len(self.opponents) > len(history.opponent_actions[0]) - 1:
            return self(__class__, self.game_description)(state, history)
        elif np.all(history.opponent_actions[-self.current_round][:, self.opponents] == 1):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_134(BaseStrategy):
    """
    Adaptive Frequency-Based Tit-for-Tat (AFB-TFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_frequencies = np.full((game_description.n_players,), 0.5)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or len(history.my_actions) < state.round_number + 1:
            return Action.C
        own_action = history.my_actions[state.round_number]
        avg_cooperation_frequency = np.mean(self.opponent_cooperation_frequencies)
        if own_action:
            opponent_cooperated = self.opponent_cooperation_frequencies[history.my_actions[state.round_number - 1]] > avg_cooperation_frequency
            update_cooperation_frequency = 1 - history.opponent_actions[state.round_number - 1, state.round_number % self.game_description.n_players]
        else:
            opponent_cooperated = False
            update_cooperation_frequency = history.opponent_actions[state.round_number - 1, state.round_number % self.game_description.n_players]
        new_own_cooperation_frequency = self.opponent_cooperation_frequencies[state.round_number % self.game_description.n_players] + 0.1 * update_cooperation_frequency * (not opponent_cooperated)
        self.opponent_cooperation_frequencies[state.round_number % self.game_description.n_players] = new_own_cooperation_frequency
        return Action.C if new_own_cooperation_frequency > avg_cooperation_frequency else Action.D

class Strategy_COLLECTIVE_135(BaseStrategy):
    """
    Implementation of Tit-for-Tat Adaptive (TFT-A) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.C
        else:
            if self.last_opponent_action is None:
                self.last_opponent_action = history.opponent_actions[state.round_number - 1][0]
            current_opponent_action = history.opponent_actions[state.round_number - 1][0]
            if self.last_opponent_action != current_opponent_action:
                self.last_opponent_action = current_opponent_action
            return Action(int(self.last_opponent_action))

class Strategy_COLLECTIVE_147(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.overconsumed_rounds = set()
        self.previous_opponent_actions = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        if state.round_number < len(self.previous_opponent_actions):
            last_action = self.previous_opponent_actions[-state.round_number]
        else:
            last_action = Action.C
        if state.current_stock <= 2 * self.game_description.n_players:
            self.overconsumed_rounds.add(state.round_number)
        action = last_action if last_action != Action.D else Action.D
        self.previous_opponent_actions.append(action)
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock > 2 * self.game_description.n_players:
            action = Action.C
        return action

class Strategy_COLLECTIVE_158(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat (ATFT) strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.t_forgiveness = math.ceil(self.capacity / self.n * 0.8)
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if self.history is None:
            self.history = PlayerHistory(my_actions=np.zeros((self.game_description.n_rounds,), dtype=bool), my_payoffs=np.zeros((self.game_description.n_rounds,), dtype=np.float64), opponent_actions=np.zeros((self.game_description.n_rounds, self.n), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.n), dtype=np.float64))
        if all((history.my_actions[-1] for _ in range(self.n))):
            return Action.C
        elif any((history.my_actions[-1] for _ in range(self.n))) and state.round_number <= self.t_forgiveness:
            return history.my_actions[-1]
        elif state.round_number >= self.game_description.n_rounds - self.t_forgiveness:
            return Action.C
        else:
            return history.opponent_actions[-1, (state.round_number - 1) % self.n]

class Strategy_COLLECTIVE_196(BaseStrategy):
    """
    Implementation of the Tit-for-Tat Evolutionary Strategy (TFTES) for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=np.bool_), np.zeros(game_description.n_rounds))
        self.history_length = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or self.history_length < 1:
            return Action.C
        if state.round_number < self.history_length - 1:
            return history.opponent_actions[-self.history_length + state.round_number - 1][0]
        for round in reversed(range(self.history_length - 1)):
            if history.opponent_actions[round][0] == Action.D:
                return Action.D
            elif history.opponent_actions[round][0] == Action.C:
                return Action.C
        if state.round_number < self.history_length:
            return history.opponent_actions[-self.history_length + state.round_number - 1][0]
        else:
            return history.opponent_actions[-1][0]

    def update(self, state: CommonPoolState, action: Action):
        self.history.my_actions[self.history_length] = bool(action)
        self.history.my_payoffs[self.history_length] = state.current_stock / self.game_description.n_players * (action == Action.C)
        self.history_length += 1
        if self.history_length > self.game_description.n_rounds:
            self.history_length = self.game_description.n_rounds

class Strategy_COLLECTIVE_226(BaseStrategy):
    """
    A simple adaptive strategy inspired by Tit-for-Tat.
    This strategy cooperates in the first round and responds to opponents' actions in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.array([state.current_stock / (self.game_description.n_players * 2)]), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1))
            return Action.C
        else:
            opponent_cooperated_last_round = np.sum(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2
            return Action.C if opponent_cooperated_last_round else Action.D

    def update_history(self, opponent_action: bool):
        self.history.opponent_actions[-1, :] = np.roll(self.history.opponent_actions[-1, :], -1)
        self.history.opponent_actions[-1, -1] = opponent_action
        self.history.my_payoffs = np.append(self.history.my_payoffs, [0])

class Strategy_COLLECTIVE_227(BaseStrategy):
    """
    A strategy that cooperates initially, then responds to opponents' actions in a tit-for-tat manner while introducing forgiveness and randomization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = np.zeros((1, self.game_description.n_players), dtype=bool)
        self.forgiveness_threshold = self.game_description.n_players - 1
        self.probability_of_cooperation_when_opponent_always_defects = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_history = np.roll(self.opponent_history, -1)
        last_round_cooperators = sum(history.opponent_actions[-1, :])
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        if last_round_cooperators >= self.game_description.n_players // 2 and sum(self.opponent_history[-1, :]) == self.forgiveness_threshold:
            return Action.C
        if last_round_cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif sum(self.opponent_history[-1, :]) != self.forgiveness_threshold and random.random() < self.probability_of_cooperation_when_opponent_always_defects:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_232(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT) for Common Pool Resource Game

    An adaptive strategy that starts by cooperating, assumes reciprocation from other players. If another player cooperates, the strategy continues to cooperate in subsequent rounds as a show of goodwill and trust. However, if a player defects during the initial round or any subsequent round, the ATfT strategy immediately defects in the next round to signal disapproval and defend against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is not None:
            self.last_opponent_action = np.mean(history.opponent_actions[:, 0]) < 0.5
            return Action.C if self.last_opponent_action else Action.D
        action = Action.C
        if history is not None:
            current_opponent_action = history.opponent_actions[-1, 0]
            last_opponent_action = self.last_opponent_action
            self.last_opponent_action = current_opponent_action
            if last_opponent_action != current_opponent_action:
                action = Action.D if last_opponent_action else Action.C
        return action

class Strategy_COLLECTIVE_236(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy in Common Pool Resource Game.
    This strategy encourages cooperation and reciprocity, promoting a collective mindset.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((1, self.game_description.n_players), dtype=bool), my_payoffs=np.zeros(self.game_description.n_players, dtype=float), opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=float))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self._update_history(state, history)
        if state.round_number == self.game_description.n_rounds - 1:
            if np.all(history.opponent_actions[-1]) == 1:
                return Action.C
            else:
                return Action.D
        else:
            last_round = len(history.opponent_actions) - 1
            if history.opponent_actions[last_round][self._get_opponent_index()] == 1:
                return Action.C
            elif history.opponent_actions[last_round][self._get_opponent_index()] == 0:
                return Action.D
        return Action.C

    def _update_history(self, state: CommonPoolState, history: PlayerHistory) -> None:
        self.history.my_actions[0] = [state.round_number == 0]
        self.history.my_payoffs[self._get_opponent_index()] = np.interp(state.current_stock / (2 * self.game_description.n_players), np.array([0, self.game_description.capacity]), np.array([0, 1]))
        self.history.opponent_actions[state.round_number - 1] = history.my_actions[state.round_number - 1]
        self.history.opponent_payoffs[state.round_number - 1][self._get_opponent_index()] = np.interp(state.current_stock / (2 * self.game_description.n_players), np.array([0, self.game_description.capacity]), np.array([history.my_payoffs[self._get_opponent_index()] * 2, history.my_payoffs[self._get_opponent_index()]]))

    def _get_opponent_index(self) -> int:
        return 1 if self.__class__ == self.__module__.split('.')[-1] else 0

class Strategy_COLLECTIVE_243(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((1, game_description.n_players), dtype=bool), my_payoffs=np.zeros(1, dtype=np.float64), opponent_actions=np.zeros((1, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((1, game_description.n_players), dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        if state.round_number == 0 or history is None:
            return Action.C
        last_actions = history.opponent_actions[-1]
        cooperators = sum(last_actions)
        if all([action for action in last_actions if action]):
            return Action.C
        self.history = np.vstack((self.history, history))
        my_last_action = self.history[-1, -1]
        if my_last_action:
            return Action.D
        opponent_index = np.argwhere(self.history[-2, :] == my_last_action)[0][0]
        last_opponent_action = self.history[-1, opponent_index]
        if not last_opponent_action:
            return Action.D
        else:
            return my_last_action

class Strategy_COLLECTIVE_246(BaseStrategy):
    """
    Tit-for-Tat Strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.opponent_actions_history) == 0:
            return Action.C
        last_state = self.opponent_actions_history[-1]
        last_action = last_state[history.my_index] if history else None
        if last_action == Action.C or last_action is None:
            return Action.C
        return Action.D

    def update_history(self, action: Action):
        self.opponent_actions_history.append([action])

    def update_history_with_players(self, history: PlayerHistory):
        self.opponent_actions_history = history.opponent_actions

class Strategy_COLLECTIVE_250(BaseStrategy):
    """
    Tit-for-Tat Adaptive Strategy (TFT-A) for Common Pool Resource Game.
    A strategy emphasizing reciprocity and trust, encouraging cooperation
    as a means to maintain a sustainable resource for all players in the long run.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None
        self.last_three_opponent_actions = np.zeros(3, dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        self.history = history
        if state.round_number == 0:
            return Action.C
        current_opponent_action = history.opponent_actions[-1, -1]
        if not self.history:
            self.last_three_opponent_actions[0] = current_opponent_action
        self.last_three_opponent_actions = np.roll(self.last_three_opponent_actions, -1)
        self.last_three_opponent_actions[-1] = current_opponent_action
        if current_opponent_action == Action.D and np.all(self.last_three_opponent_actions) == Action.D and (len(history) > 2):
            return Action.C
        elif current_opponent_action == Action.C:
            return Action.C
        else:
            return Action.D

    def last_round(self) -> bool:
        return self.history and self.history.shape[0] == self.game_description.n_rounds

    def maximize_payoff(self, last_opponent_action: Action) -> Action:
        if last_opponent_action == Action.C:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_260(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)

    Strategy Description:
        This strategy uses a reciprocal approach to encourage cooperation and sustainability of the common pool resource. It cooperates when opponents are relatively generous with their resource consumption, while retaliating by defecting if they have been excessively selfish.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption_history = np.zeros(game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        consumption = np.sum(history.opponent_actions[:, :state.round_number - 1].sum(axis=0))
        self.average_consumption_history[state.round_number - 1] = consumption / (self.game_description.n_players * (state.round_number - 1))
        average_consumption = self.average_consumption_history[-1]
        if average_consumption >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

    def get_payoff(self, state: CommonPoolState) -> float:
        action = self.__call__(state, None)
        if action == Action.C:
            payoff = state.current_stock / (2 * self.game_description.n_players)
        else:
            payoff = state.current_stock / self.game_description.n_players
        return payoff

class Strategy_COLLECTIVE_285(BaseStrategy):
    """
    The Titan Strategy for Common Pool Resource Game.
    This strategy cooperates when the Average Consumption Per Player (ACPP) is less than the sustainable per-player rate.
    Otherwise, it defects to ensure a minimum share of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        total_consumption = np.sum(history.my_actions[:-1]) * self.game_description.n_players
        avg_consumption = total_consumption / state.round_number
        if avg_consumption < self.stock / (2 * self.game_description.n_players):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_287(BaseStrategy):
    """
    A strategy that follows the Tit-for-Tat Adaptive rule in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness = game_description.n_players // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C
        if history is not None and history.my_actions[-1] == Action.C:
            return Action.C
        if self.forgiveness > 0:
            self.forgiveness -= 1
        elif history is not None and any(history.opponent_actions[:, -1]) == False:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_290(BaseStrategy):
    """
    A Tit-for-Tat strategy for the Common Pool Resource Game, which cooperates or defects based on opponents' previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        opponent_actions = history.opponent_actions[-self.game_description.n_rounds:]
        cooperators = sum([sum(row) for row in opponent_actions])
        if state.round_number == self.game_description.n_rounds - 1 or state.current_stock < self.game_description.capacity * (self.n_players / 2):
            recent_cooperators = cooperators.sum(axis=0) >= self.n_players // 2
        else:
            recent_cooperators = cooperators >= self.n_players // 2
        return Action(recent_cooperators) if history else Action.C

class Strategy_COLLECTIVE_296(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT) for Common Pool Resource Game
    Strategy Description: The strategy follows the decision rules of cooperating initially to build trust, and mimicking opponents' actions in subsequent rounds. If an opponent cooperated in the last round, it cooperates; if they defected, it defects. This encourages cooperation when partners cooperate and retaliates against defection with similar action.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return self._determine_first_round_action()
        self._update_opponent_actions(history)
        return self._determine_action()

    def _determine_first_round_action(self):
        opponents = [Action.D] * self.game_description.n_players if np.all(self.opponent_actions == [1] * self.game_description.n_players) else [Action.C] * self.game_description.n_players
        return next((action for action in opponents), Action.C)

    def _update_opponent_actions(self, history: PlayerHistory):
        self.opponent_actions = history.opponent_actions[-1]

    def _determine_action(self):
        cooperators = np.count_nonzero(self.opponent_actions)
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_306(BaseStrategy):
    """
    Fischer's Tit-for-Tat Strategy with Stock Growth Adaptation for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None
        self.average_consumption = np.array([0.0])
        self.rounds_played = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history = history or PlayerHistory(np.zeros((1, self.game_description.n_players), dtype=bool), np.array([0.0]), np.zeros((state.round_number + 1, self.game_description.n_players), dtype=bool), np.array([0.0]))
        self.history.my_actions[-1] = True if state.round_number == 0 else history.my_actions[-1]
        self.history.my_payoffs[-1] = state.current_stock / (2 * self.game_description.n_players)
        self.average_consumption = np.append(self.average_consumption, np.mean(history.opponent_actions[:, :self.rounds_played + 1]))
        self.rounds_played += 1
        if self.rounds_played == self.game_description.n_rounds:
            return Action.C if np.mean(self.average_consumption) < self.game_description.n_players * 2 / (2 * self.game_description.n_rounds + 1) else Action.D
        last_average = self.average_consumption[-1]
        return Action.C if last_average < self.game_description.n_players * 2 / (2 * self.game_description.n_rounds + 1) else Action.D

class Strategy_COLLECTIVE_312(BaseStrategy):
    """
    The Tit-for-Tat Adaptive (TFT-A) strategy follows a simple tit-for-tat approach, starting with cooperation and responding to the opponent's last action in the previous round. If the opponent cooperated in the last round, TFT-A will cooperate; if not, it will defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.first_round = True
        self.forgiveness_turn = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.first_round = True
            return Action.C
        if state.round_number == 0:
            self.forgiveness_turn = True
            return Action.C
        else:
            self.forgiveness_turn = False
        cooperators = sum(history.opponent_actions[-1, :])
        if (self.first_round or self.forgiveness_turn) and state.round_number < self.game_description.n_rounds:
            return Action.C
        elif state.round_number == self.game_description.n_rounds and cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return history.opponent_actions[-1, -1]

class Strategy_COLLECTIVE_318(BaseStrategy):
    """Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_fallen_below_zero = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.game_description.n_rounds:
            if any(history.opponent_actions[-1]):
                action = Action.C
            else:
                action = Action.D
        else:
            action = Action.C
        if state.current_stock < 0 and (not self.stock_fallen_below_zero):
            self.stock_fallen_below_zero = True
            action = Action.C
        return action

class Strategy_COLLECTIVE_322(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_round = 0
        self.last_coop = None
        self.payoff_margin = 0.1
        self.cooperation_threshold = int((self.game_description.n_rounds - self.current_round) * (self.game_description.n_players // 2))
        self.def_threshold = int((self.game_description.n_rounds - self.current_round) * (self.game_description.n_players // 4))

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None):
        if history is None:
            return Action.C
        self.current_round = state.round_number
        last_round = history.opponent_actions[-1] if self.current_round > 0 else np.zeros(self.game_description.n_players, dtype=np.bool_)
        action = Action.C
        if not self.last_coop and any((action == Action.D for player in last_round)):
            action = Action.D
        elif self.last_coop and any((action == Action.D for player in last_round)):
            action = Action.D
        else:
            payoff = np.mean([history.my_payoffs[-1] if i != 0 else 0 for i in range(self.current_round)])
            avg_payoff = history.my_payoffs[-1] if self.current_round > 0 else 0
            if payoff > avg_payoff + self.payoff_margin:
                action = Action.D
            elif payoff < avg_payoff - self.payoff_margin and self.current_round > self.def_threshold:
                action = Action.C
            elif self.current_round > self.cooperation_threshold:
                action = Action.C
        if self.current_round == 1 or (self.last_coop is None and any((action == Action.D for player in last_round))):
            self.last_coop = False
        elif self.current_round > 1 and any((action == Action.C for player in last_round)):
            self.last_coop = True
        return action

class Strategy_COLLECTIVE_341(BaseStrategy):
    """
    Adaptive Stock-based Tit-for-Tat Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_length = int(math.ceil(game_description.n_players * 2))
        self.threshold_coop_multiplier = 1.5
        self.history_buffer = np.zeros((self.history_length,), dtype=bool)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        stock = state.current_stock
        if stock <= 0:
            stock = self.game_description.capacity
        threshold_coop = min(int((self.game_description.capacity - stock) / (2 * self.game_description.n_players)), int((self.game_description.capacity - stock) / (self.game_description.n_players * self.threshold_coop_multiplier)))
        if state.round_number == 0:
            return Action.C
        else:
            my_action = history.my_actions[-1]
            opponent_actions = history.opponent_actions[:-1, -1] if state.round_number >= self.history_length else history.opponent_actions
            num_cooperators = np.sum(np.roll(opponent_actions, 1) + opponent_actions[-1])
            if my_action and num_cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                self.history_buffer = np.roll(self.history_buffer, -1)
                self.history_buffer[-1] = my_action
                return Action.C if self.get_threshold(stock, self.game_description.n_players, self.game_description.capacity) > self.history_buffer.sum() else Action.D

    def get_threshold(self, stock: float, n: int, capacity: int):
        return min(int((capacity - stock) / (2 * n)), int((capacity - stock) / n))

class Strategy_COLLECTIVE_343(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))
        self.punishment_duration = math.ceil(game_description.n_rounds * 0.25)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is None:
            return Action.C
        self.history = history
        action = Action.C
        if state.round_number == 0 or (state.round_number > 0 and history.opponent_actions[-1, -1] == Action.C):
            action = Action.C
        else:
            punishment_count = self.history.my_actions[0:-self.punishment_duration].sum()
            if punishment_count >= len(self.history.opponent_payoffs) - self.punishment_duration:
                action = Action.C
        return action

class Strategy_COLLECTIVE_348(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy in Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = [[False for _ in range(game_description.n_rounds)] for _ in range(game_description.n_players)]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        current_round = state.round_number - 1 if state.round_number > 0 else 0
        opponents_cooperated = sum(history.opponent_actions[current_round, :])
        if opponents_cooperated >= self.game_description.n_players - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_364(BaseStrategy):
    """
    An adaptive Tit-for-Tat strategy that cooperates in the initial round,
    responds cooperatively if the opponent cooperated in the previous round,
    and defects if they defected in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        self._history = history
        action = Action.C
        if state.round_number == 0:
            return action
        if state.current_stock < self.game_description.capacity * (2 * self.game_description.n_players - 1):
            if state.current_stock == 0:
                action = Action.D
            else:
                action = Action.C
        else:
            opponent_cooperated_last_round = sum(self._history.opponent_actions[-1]) >= self.game_description.n_players // 2
            action = Action.C if opponent_cooperated_last_round else Action.D
        return action

class Strategy_COLLECTIVE_376(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r_cooperation = int(game_description.n_players * 0.6)
        self.r_punishment = int(game_description.n_players * 0.25)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[-1, 0] if len(history.opponent_actions) > 0 else None
        cooperation_count = int(np.sum(history.my_actions))
        if opponent_action is not None:
            if opponent_action and cooperation_count >= self.r_cooperation:
                return Action.C
            elif not opponent_action and cooperation_count >= self.r_punishment:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_384(BaseStrategy):
    """
    Strategy name: Adaptive Tit-for-Tat (ATFT)
    Summary: A simple yet robust approach that encourages long-term collaboration by adapting to various opponent strategies and promoting mutual benefit in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        round_number = state.round_number
        last_round = round_number == self.game_description.n_rounds - 1
        first_round = round_number == 0
        opponent_action = history.opponent_actions[round_number - 1, 0] if not first_round else None
        if first_round:
            return Action.C
        elif last_round and (not opponent_action):
            return Action.C
        elif last_round and opponent_action:
            return Action.D
        else:
            self.opponent_history.append(opponent_action)
            return Action(int(opponent_action) if opponent_action is not None else 1)

class Strategy_COLLECTIVE_387(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth Consideration (ATFC-SG) strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_threshold = 0.5
        self.max_threshold = 1.0
        self.history = PlayerHistory(my_actions=None, my_payoffs=None, opponent_actions=None, opponent_payoffs=None)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if not history:
            return Action.C
        self.history.opponent_actions = history.opponent_actions if history else np.zeros((state.round_number + 1, self.game_description.n_players))
        self.history.my_actions = [Action.C] if state.round_number == 0 else self.history.my_actions
        self.history.my_payoffs = np.array([0.0] * (state.round_number + 1))
        self.history.opponent_payoffs = np.array([0.0] * ((state.round_number + 1) * self.game_description.n_players))
        if state.round_number == self.game_description.n_rounds or state.current_stock < self.game_description.capacity * 0.5:
            return Action.C
        avg_consumption = np.mean(self.history.opponent_actions[-self.game_description.n_players:])
        stock_fraction = state.current_stock / self.game_description.capacity
        t = self.min_threshold + (self.max_threshold - self.min_threshold) * (1 - math.exp(-stock_fraction))
        if avg_consumption < t:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_396(BaseStrategy):
    """
    A self-reinforcing adaptive cooperative strategy called Tit-for-Tat (TFT).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        else:
            last_move = history.opponent_actions[-1][0] if len(history.opponent_actions) > 0 else None
            return Action(int(last_move))

class Strategy_COLLECTIVE_409(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_threshold = int(game_description.n_players / 2)
        self.cooperation_timer = 0
        self.history = PlayerHistory(my_actions=np.zeros((1, game_description.n_players), dtype=bool), my_payoffs=np.zeros(1), opponent_actions=np.zeros((1, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is None:
            self.history = PlayerHistory(my_actions=np.zeros((1, self.game_description.n_players), dtype=bool), my_payoffs=np.zeros(1), opponent_actions=np.zeros((1, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros(1))
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.C
        else:
            opponent_cooperated = sum(history.opponent_actions[state.round_number - 1])
            if opponent_cooperated > 0:
                self.cooperation_timer = min(self.game_description.n_rounds, self.cooperation_timer + 1)
                return Action.C
            elif opponent_cooperated == 0 and self.cooperation_timer > self.punishment_threshold:
                return Action.D
            else:
                self.cooperation_timer = max(0, self.cooperation_timer - 1)
                return Action.C

class Strategy_COLLECTIVE_411(BaseStrategy):
    """
    An adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    This strategy cooperates in the first round and responds to an opponent's cooperation or defection with either cooperation or defection based on the previous round's action.
    In the last round, it always cooperates regardless of the opponent's action.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if self.history is None and state.round_number == 0:
            return Action.C
        elif self.game_description.n_rounds - state.round_number == 1:
            return Action.C
        else:
            self.history = history
            last_action = history.opponent_actions[-1, :].sum()
            if last_action >= self.game_description.n_players // 2:
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_422(BaseStrategy):
    """Adaptive Tit-for-Tat (ATfT) strategy for the Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_coefficient = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            opponent_actions = history.opponent_actions.flatten()
            last_n_actions = opponent_actions[-self.n:]
            depletion_rate = sum(last_n_actions) / self.n
            threshold = self.capacity * self.threshold_coefficient ** depletion_rate
        else:
            threshold = self.capacity * self.threshold_coefficient ** (1 / self.r)
        if state.current_stock < threshold:
            return Action.D
        last_opponent_action = history.opponent_actions[:, -1].flatten() if history else [Action.C] * self.n
        my_action = Action.C if last_opponent_action[-1] == Action.C else Action.D
        return my_action

class Strategy_COLLECTIVE_424(BaseStrategy):
    """
    Adaptive Cooperative-Competitive (ACC) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.history = None
        self.rounds_without_cooperation = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.D
        self.history = history or PlayerHistory(np.zeros((1, self.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        if state.round_number == self.game_description.n_rounds:
            return self._last_round_decision(state, history)
        current_stock = state.current_stock
        past_actions = self.history.my_actions[-1]
        past_stocks = self.history.my_payoffs[-1] / (2 * self.n_players) if np.all(past_actions == Action.C) else self.history.my_payoffs[-1] / self.n_players
        EAP_C, EAP_D = self._calculate_EAP(self.n_players, current_stock, past_actions, past_stocks)
        return Action.C if EAP_C > EAP_D else Action.D

    def _calculate_EAP(self, n: int, S: float, past_actions: NDArray[np.bool_], past_stocks: float):
        payoffs = self._calculate_payoffs(S, past_actions)
        consumption = np.sum(past_actions)
        growth = self._calculate_growth(consumption, S, self.capacity)
        P_cap = self._calculate_P_cap(growth, self.capacity)
        EAP_total = payoffs + (1 - P_cap) * self._calculate_EAP_total(n, S, growth, P_cap)
        return (payoffs, EAP_total)

    def _calculate_payoffs(self, S: float, past_actions: NDArray[np.bool_]):
        cooperators = np.sum(past_actions)
        return cooperators * S / (2 * self.n_players) + (self.n_players - cooperators) * S / self.n_players

    def _calculate_growth(self, consumption: float, S: float, capacity: int):
        total_consumption = consumption * (2 * self.n_players)
        stock_after_consumption = S - total_consumption
        if stock_after_consumption < 0:
            return 0
        growth = 2 * S * (1 - S / capacity)
        return growth

    def _calculate_P_cap(self, growth: float, capacity: int):
        return math.exp(-growth / (2 * self.capacity))

    def _calculate_EAP_total(self, n: int, S: float, growth: float, P_cap: float) -> float:
        if P_cap == 1:
            return 0
        return (S + 2 * S * growth) / (2 * self.capacity * P_cap)

    def _last_round_decision(self, state: CommonPoolState, history: PlayerHistory):
        current_stock = state.current_stock
        payoff = history.my_payoffs[-1]
        growth = self._calculate_growth(np.sum(history.opponent_actions[-1]), current_stock, self.capacity)
        P_cap = self._calculate_P_cap(growth, self.capacity)
        if current_stock >= 2 * self.n_players:
            return Action.C
        EAP_total = payoff + (1 - P_cap) * self._calculate_EAP_total(self.n_players, current_stock, growth, P_cap)
        return Action.C if EAP_total > history.my_payoffs[-1] / 2 else Action.D

class Strategy_COLLECTIVE_428(BaseStrategy):
    """
    Fitness-Proportionate Tit-For-Tat (FP-TFT) strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_period = int(self.game_description.n_players * 0.75)
        self.history = PlayerHistory(my_actions=np.zeros((1, self.game_description.n_rounds), dtype=bool), my_payoffs=np.zeros(self.game_description.n_rounds), opponent_actions=np.zeros((self.game_description.n_rounds + 1, self.game_description.n_players + 1), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds + 1, self.game_description.n_players + 1)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        current_round = state.round_number
        self.history.my_actions[0, current_round] = True
        if current_round == 1:
            return Action.C
        cooperation_sum = np.sum(history.opponent_actions[:, :current_round], axis=0).sum()
        defection_sum = np.count_nonzero(np.logical_not(history.opponent_actions[:, :current_round].T).sum(axis=0))
        if cooperation_sum == self.game_description.n_players:
            return Action.C
        elif defection_sum > 0:
            return Action.D
        elif self.history.my_actions[-1, current_round - 1] == False:
            if current_round - self.history.my_actions.shape[0] > self.forgiveness_period:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_429(BaseStrategy):
    """
    Tit-for-Tat strategy for the Common Pool Resource game.
    Mimics opponent's action from the previous round, promoting cooperation while deterring exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.empty(0, dtype=bool), my_payoffs=np.empty(0, dtype=np.float64), opponent_actions=np.empty((0, 0), dtype=bool), opponent_payoffs=np.empty((0, 0), dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is not None:
            self.history = history
        if state.round_number == 0:
            return Action.C
        elif self.history.opponent_actions[-1, -1] == Action.C:
            return Action.C
        elif len(self.history.opponent_actions) > 2 and self.history.opponent_actions[-2, -1] == Action.C:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_437(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy with passive-aggressive behavior in the first round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if history is None:
            return Action.C if state.round_number == 0 else self._play(state)
        else:
            self.history = history
            return self._play(state)

    def _play(self, state: CommonPoolState):
        if self.history.opponent_actions[-1].sum() > self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_456(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Stock Awareness (SATFT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_stock = game_description.capacity / game_description.n_players
        self.threshold_loss = game_description.capacity * 0.2
        self.critical_stock = game_description.capacity * 0.1
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        if history is None or len(history.opponent_actions) < state.round_number:
            return Action.D
        last_round = state.round_number == self.game_description.n_rounds
        round_action = history.opponent_actions[-1, 0] if len(history.opponent_actions) > state.round_number - 1 else None
        if last_round and state.current_stock < self.critical_stock:
            return Action.D
        elif last_round and state.current_stock >= self.critical_stock * 0.9:
            return Action.C
        if round_action is None:
            return Action.D
        if state.current_stock < self.critical_stock and state.round_number * len(history.opponent_actions) > self.threshold_loss:
            return Action.D
        if round_action == Action.C:
            return Action.C
        elif state.current_stock > self.avg_stock * 0.9 and round_action == Action.D:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_460(BaseStrategy):
    """
    Strategy name: Adaptive Fitness-driven Tit-for-Tat (AFTFT)
    Strategy summary: Promotes cooperation and trust by showing initial goodwill and adaptability based on opponent behavior. Balances self-interest with cooperation while being robust to various opponent strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_cooperative_threshold = 0.7
        self.average_defective_threshold = 0.3
        self.history_length = 5
        self.trust_building_rounds = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history or len(history.my_actions) < self.trust_building_rounds:
            return Action.C
        cooperative_rate = np.mean(history.my_actions[self.trust_building_rounds - 1:-1])
        if cooperative_rate > self.average_cooperative_threshold:
            return Action.C
        elif cooperative_rate < self.average_defective_threshold:
            return Action.D
        else:
            action = history.opponent_actions[-1, (history.my_actions == Action.C).sum()] > 0
            return Action(int(action))

class Strategy_COLLECTIVE_462(BaseStrategy):
    """
    A strategy that mimics opponents' actions, encourages cooperation, and adapts to the game's parameters.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock = self.game_description.capacity * math.sqrt(1 / (self.game_description.n_players * self.game_description.n_rounds))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock >= self.critical_stock:
            opponent_action = history.opponent_actions[-1][-1] if history else np.zeros(self.game_description.n_rounds, dtype=bool)[-1]
            return Action(int(opponent_action))
        return Action.D

    def update_history(self, state: CommonPoolState, action: Action, payoff: float, opponent_actions: NDArray[np.bool_], opponent_payoffs: NDArray[np.float64]) -> None:
        if state.round_number == self.game_description.n_rounds - 1 or state.current_stock < self.critical_stock:
            opponent_actions[-1, -1] = True
        super().update_history(state, action, payoff, opponent_actions, opponent_payoffs)
        if state.round_number > 0 and state.current_stock < self.critical_stock:
            self.critical_stock = self.game_description.capacity * math.sqrt(1 / (self.game_description.n_players * (self.game_description.n_rounds - state.round_number)))

class Strategy_COLLECTIVE_478(BaseStrategy):
    """Adaptive Tit-for-Tat strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = -1
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.last_round == -1:
            return Action.C
        self.last_round = state.round_number
        current_opponent_action = history.opponent_actions[state.round_number - 1, 0]
        forgiveness_needed = self.last_opponent_action is not None and current_opponent_action != self.last_opponent_action
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        elif forgiveness_needed:
            self.last_opponent_action = current_opponent_action
            return Action.C
        else:
            self.last_opponent_action = current_opponent_action
            return current_opponent_action

class Strategy_COLLECTIVE_507(BaseStrategy):
    """
    A strategy that implements Tit-for-Tat with Adaptive Cooperation (TFTA).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.window_size = min(int(game_description.n_players / 2), game_description.n_rounds)
        self.threshold = 0.5
        self.cooperation_rate = np.zeros(self.window_size, dtype=np.float64)
        self.history = PlayerHistory(None, None, None, None)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is not None:
            self.update_cooperation_rate(history)
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-self.window_size:, :].sum(axis=1))
        cooperation_rate = opponent_cooperators / self.window_size
        if cooperation_rate > self.threshold:
            self.window_size = max(1, self.window_size - 1)
            self.threshold += 0.05
        elif cooperation_rate < 1 - self.threshold:
            self.window_size = min(self.game_description.n_rounds, self.window_size + 1)
            self.threshold -= 0.05
        if cooperation_rate >= self.threshold:
            return Action.C
        return Action.D

    def update_cooperation_rate(self, history):
        self.history = history
        self.cooperation_rate = np.roll(self.cooperation_rate, -1)
        self.cooperation_rate[-1] = sum(history.opponent_actions[:, :].sum(axis=0)) / self.window_size

class Strategy_COLLECTIVE_509(BaseStrategy):
    """
    Title: Tit-for-Tat Strategy for Common Pool Resource Game

    This strategy follows a tit-for-tat approach that encourages cooperation while retaliating against defection.
    It maintains fairness and reciprocity, fostering an environment where players can benefit from each other's actions over time.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and (not history):
            return Action.C
        if history is not None:
            self.opponent_actions_history.append(history.opponent_actions[-1, :])
            if len(self.opponent_actions_history) == state.round_number + 1:
                self.opponent_actions_history.pop(0)
        opponent_cooperated = np.sum(self.opponent_actions_history[-1]) >= self.game_description.n_players // 2
        if state.round_number == self.game_description.n_rounds - 1:
            return Action(opponent_cooperated)
        return Action(not opponent_cooperated)

class Strategy_EXPLOITATIVE_11(BaseStrategy):
    """
    Tit-for-Tat with Stock Growth Adaptation (TFT-SGA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity / 2
        self.threshold = self.capacity // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        stock_remaining = state.current_stock / self.game_description.capacity
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif stock_remaining < self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_24(BaseStrategy):
    """
    A strategy that follows Tit-for-Tat with Stock Adaptation (TFT-SA) in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=np.bool_)
        stock_ratio = state.current_stock / self.game_description.capacity
        if all(opponent_actions):
            action = Action.C
            if stock_ratio > self.threshold:
                action = self.decide(opponent_actions, stock_ratio)
        elif any(opponent_actions):
            action = self.decide(opponent_actions, stock_ratio)
        else:
            action = Action.D
        if state.round_number == self.game_description.n_rounds:
            action = Action.C
        return action

    def decide(self, opponent_actions: np.ndarray, stock_ratio: float) -> Action:
        cooperators = sum(opponent_actions)
        if cooperators > self.game_description.n_players // 2:
            if stock_ratio > self.threshold:
                return Action.C
            return Action.D
        elif any(opponent_actions):
            if stock_ratio < self.threshold:
                return Action.D
        elif stock_ratio < self.threshold:
            return decideBasedOnStock(stock_ratio)
        return Action.C

class Strategy_EXPLOITATIVE_28(BaseStrategy):
    """
    Strategy: Tit-for-Tat Adaptive (TFT-A)
    This strategy mimics the opponent's last action and adjusts its punishment threshold and critical stock level accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_threshold = int(math.ceil(game_description.n_players / 2))
        self.critical_stock_level = game_description.capacity / 4
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.history = history
        action = Action.C
        if state.round_number < self.punishment_threshold:
            if history.opponent_actions[-1, -1] == 1:
                action = Action.C
            else:
                action = Action.D
        elif state.round_number >= self.punishment_threshold:
            if len([t for t in history.opponent_actions[:-self.punishment_threshold] if np.all(t == [1])]) > self.punishment_threshold // 2:
                action = Action.C
            else:
                action = Action.D
        if state.current_stock < self.critical_stock_level and history.my_actions[-1] != action:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_35(BaseStrategy):
    """
    This strategy follows Tit-for-Tat Adaptive (TFT-A) logic in Common Pool Resource Games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.w = 10
        self.t = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_history = np.zeros((self.w,), dtype=bool)
        if history is not None:
            for i in range(min(state.round_number + 1, self.w)):
                opponent_history[i] = history.opponent_actions[i - 1, 0]
        action = Action.C
        if state.round_number < self.game_description.n_rounds:
            action = Action(opponent_history[-1])
        if state.round_number == self.game_description.n_rounds:
            action = Action.C
        self.t = (self.t + 1) % self.w
        return action

class Strategy_EXPLOITATIVE_51(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.Tc = 0.5
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and (not history):
            return Action.C
        if len(self.opponent_history) == 0 or state.round_number >= self.r:
            return Action.D
        avg_cooperation = np.mean([h.my_actions[state.round_number - 1] for h in self.opponent_history])
        stock_change = state.current_stock - self.opponent_history[-1].opponent_payoffs[-1][-1] * (self.game_description.capacity / (2 * self.n))
        if avg_cooperation > self.Tc:
            return Action.C
        elif avg_cooperation < self.Tc:
            return Action.D
        elif stock_change > 0:
            return Action.C
        else:
            return Action.D

        def update_Tc(self, new_avg_cooperation):
            if len(self.opponent_history) > self.r * 0.2:
                if new_avg_cooperation > self.Tc:
                    self.Tc += (new_avg_cooperation - self.Tc) * 0.1
                elif new_avg_cooperation < self.Tc:
                    self.Tc -= (self.Tc - new_avg_cooperation) * 0.1

class Strategy_EXPLOITATIVE_52(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    The strategy gradually becomes more cooperative or exploitative based on opponent's actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = int(math.floor(game_description.n_players / 2))
        self.defect_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and history.opponent_actions[-1, :].all():
            self.defect_count += 1
        if self.defect_count > self.game_description.n_players - self.cooperation_threshold:
            self.cooperation_threshold = int(math.ceil(self.cooperation_threshold * 0.9))
        elif state.round_number == self.game_description.n_rounds:
            self.cooperation_threshold = int(math.floor(self.cooperation_threshold * 1.1))
        return Action.C if self.cooperation_threshold >= state.round_number and history is not None and np.any(history.my_actions[-state.round_number:]) else Action.D

class Strategy_EXPLOITATIVE_75(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Rate (TFT-ACR) strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_window = int(math.ceil(game_description.n_players / 2))
        self.current_stock = game_description.capacity
        self.history = PlayerHistory(np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1), np.zeros((game_description.n_rounds + 1, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds + 1, game_description.n_players)))
        self.last_opponent_action = Action.D

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is not None:
            self.history = history
            self.last_opponent_action = self.history.opponent_actions[-1, 0]
        if state.round_number == 0:
            return Action.C
        if self.last_opponent_action is Action.D:
            if self.cooperation_window > int(math.ceil(self.game_description.n_players / 4)):
                self.cooperation_window -= int(math.ceil(self.game_description.n_players / 8))
        elif self.last_opponent_action is Action.C:
            if self.cooperation_window < self.game_description.n_rounds - 1:
                self.cooperation_window += int(math.ceil(self.game_description.n_players / 8))
        return Action.C if random.random() < self.cooperation_window / self.game_description.n_rounds else Action.D

class Strategy_EXPLOITATIVE_105(BaseStrategy):
    """A Tit-for-Tat strategy for the Common Pool Resource Game."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == len(history.opponent_actions) - 1:
            return Action.C
        self.history = history
        my_last_action = history.my_actions[-1]
        opponent_last_action = history.opponent_actions[-1, int(my_last_action)]
        if state.round_number == 0 or opponent_last_action != my_last_action:
            return Action.C
        else:
            return Action(opponent_last_action)

class Strategy_EXPLOITATIVE_119(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat-Growth (TfT-G)
    Strategy Description: A strategy based on classic Tit-for-Tat, adapted for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_length = int(self.game_description.n_players // 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_history = history.opponent_actions if history else np.zeros((state.round_number + 1, self.game_description.n_players), dtype=bool)
        last_opponent_action = opponent_history[-1, -1]
        if np.sum(opponent_history[-self.history_length:, -1]) < self.history_length:
            return Action.C
        current_stock = state.current_stock / self.game_description.capacity
        punishment = min(100.0, max((1.0 - current_stock) * 0.25, 0.0))
        return Action.D if last_opponent_action else Action.C * punishment + Action.D * (1 - punishment)

class Strategy_COLLECTIVE_10(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT) for Common Pool Resource Game

    Summary: Mimics the actions of opponents from the previous round, promoting cooperation when others cooperate and punishing defection. Includes forgiveness for initial defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_window = 5
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.history = history
        round_number = state.round_number - 1
        last_round_history = self.history.opponent_actions[-1]
        if all(last_round_history == Action.C):
            return Action.C
        elif any(last_round_history == Action.D):
            return Action.D
        else:
            return Action.D
        if round_number < self.forgiveness_window and self.history.opponent_actions[round_number - 1, :].any():
            forgiven_defection = False
            for opponent_index in range(self.game_description.n_players):
                if self.history.opponent_actions[round_number, opponent_index] == Action.C:
                    return Action.C
                    forgiven_defection = True
                    break
            if not forgiven_defection:
                pass

class Strategy_COLLECTIVE_20(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game.
    Priority is given to long-term collaboration and mutual benefits over immediate rewards.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.tolerance = math.ceil(game_description.n_players / 4)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        round_number = state.round_number
        if round_number == 0:
            pass
        elif round_number == self.game_description.n_rounds:
            pass
        else:
            opponent_action = history.opponent_actions[round_number - 1, 0] if history is not None else None
            if opponent_action is None or (round_number > self.tolerance and opponent_action == Action.D):
                action = Action.D
            elif round_number <= self.tolerance:
                pass
        return action

class Strategy_COLLECTIVE_46(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and defection in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.max_sustainable_stock_level = 2 * self.n_players
        self.min_sustainable_stock_level = math.ceil((self.capacity - self.n_players) / self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        stock = state.current_stock
        asl = (self.max_sustainable_stock_level + self.min_sustainable_stock_level) / 2
        if stock > asl:
            return Action.C
        elif stock <= asl:
            return Action.D

class Strategy_COLLECTIVE_58(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_percentage = self.game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = np.mean(history.opponent_actions[-1]) if history else np.zeros(self.game_description.n_players)
        if opponent_action:
            return Action.C
        return Action.D

    def last_round_strategy(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        stock_percentage = state.current_stock / self.game_description.capacity
        if stock_percentage < self.capacity_percentage:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_100(BaseStrategy):
    """
    A simple yet adaptive strategy that balances cooperation and defection in the Common Pool Resource Game.
    The strategy is called Tit-for-Tat with Growth (TFTG).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity / self.game_description.n_players * 1.5
        self.latest_cooperation = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        if state.round_number > self.latest_cooperation + self.game_description.n_players:
            self.latest_cooperation = state.round_number
        if not history:
            return Action.C
        total_consumption = np.sum(history.my_actions[:state.round_number])
        avg_consumption = total_consumption / (2 * self.game_description.n_players)
        if avg_consumption < self.threshold:
            return Action.C
        elif avg_consumption > self.threshold * 2:
            return Action.D
        else:
            return history.my_actions[self.latest_cooperation]

class Strategy_COLLECTIVE_123(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / game_description.n_players
        self.escalation = game_description.capacity / game_description.n_players
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if len(self.opponent_history) < self.game_description.n_players:
            self.opponent_history += [False] * (self.game_description.n_players - len(self.opponent_history))
        last_opponent_action = self.opponent_history[-1] if self.opponent_history else None
        if state.current_stock < self.threshold:
            return Action.C
        if last_opponent_action == True:
            self.opponent_history[-self.game_description.n_players:] = [True] * self.game_description.n_players
            return Action.C
        elif last_opponent_action == False and len(self.opponent_history) > self.escalation:
            self.opponent_history[-self.game_description.n_players:] = [False] * self.game_description.n_players
            return Action.D
        else:
            self.opponent_history[-self.game_description.n_players:] = [False] * (self.game_description.n_players - len(self.opponent_history))
            return Action.D

class Strategy_COLLECTIVE_131(BaseStrategy):
    """
    The Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    This strategy cooperates initially and mimics opponents' actions in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number > 0 and history is not None:
            last_round = len(history.opponent_actions) - 1
            if last_round >= 0:
                cooperators = sum(history.opponent_actions[last_round, :])
                action = Action.C if cooperators >= self.game_description.n_players // 2 else Action.D
        return action

class Strategy_COLLECTIVE_153(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        self._last_opponent_action = np.mean(history.opponent_actions[:, -1])
        if history and (history.my_actions[-1] or self._last_opponent_action):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_180(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat with Stock Growth (A-TFTSG)
    Strategy Description: A strategy that cooperates in the initial round, mimicking the spirit of cooperation to encourage others. In subsequent rounds, it adopts a Tit-for-Tat strategy with some modifications based on the stock growth. If all players cooperate in a round, A-TFTSG continues cooperating. If any player defects, A-TFTSG will also defect in the next round. However, if the stock growth is positive after a round where at least one player defected, A-TFTSG will cooperate again as a sign of forgiveness and willingness to maintain cooperation if others follow suit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_stock = None
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        self.current_stock = state.current_stock
        self.history = history
        if state.round_number == 0:
            return Action.C
        last_round_growth = 2 * min(self.current_stock + 1, self.game_description.capacity) * (1 - self.current_stock / self.game_description.capacity) - self.current_stock
        cooperators = sum(self.history.opponent_actions[-1, :])
        if all([action == Action.C for action in self.history.opponent_actions[-1]]) or (last_round_growth > 0 and cooperators >= self.game_description.n_players // 2):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_198(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))
        self.reputation = {}
        self.forgiveness_counter = {}

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.history = history
        current_round = len(self.history.my_actions) - 1
        opponent_cooperators = sum(self.history.opponent_actions[current_round, :])
        my_action = Action.C if opponent_cooperators >= self.game_description.n_players // 2 else Action.D
        player_id = np.argmax(self.history.opponent_actions[current_round]) + 1
        reputation = self.reputation.get(player_id, 0)
        forgiveness_counter = self.forgiveness_counter.get(player_id, 0)
        if my_action == Action.C and history.opponent_payoffs[current_round, player_id - 1] < state.current_stock / (2 * self.game_description.n_players):
            reputation += 1
            forgiveness_counter = min(forgiveness_counter + 1, self.game_description.n_rounds // 5)
        elif my_action == Action.D and history.opponent_payoffs[current_round, player_id - 1] > state.current_stock / self.game_description.n_players:
            reputation -= 1
            forgiveness_counter = max(forgiveness_counter - 1, 0)
        self.reputation[player_id] = reputation
        self.forgiveness_counter[player_id] = forgiveness_counter
        return my_action

class Strategy_COLLECTIVE_208(BaseStrategy):
    """
    Strategy name: Adaptive Stock Conservation and Growth (ASCG)
    Summary: A cooperative strategy that adapts its cooperation and defection based on the current round, remaining stock, and historical average consumption per player.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = self.game_description.capacity / game_description.n_players
        self.current_consumption = np.zeros(game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 1:
            return Action.D
        else:
            if round_number == self.game_description.n_rounds:
                if self.current_consumption[-1] > self.game_description.capacity / self.game_description.n_players:
                    return Action.D
                else:
                    self.average_consumption = (self.average_consumption * (self.game_description.n_rounds - 1) + self.current_consumption[-1]) / self.game_description.n_rounds
            if round_number > 1:
                if history is not None and history.my_actions is not None and (len(history.my_actions) == round_number):
                    average_consumption = (self.average_consumption * (round_number - 1) + self.current_consumption[-1]) / round_number
                    if average_consumption < self.game_description.capacity / self.game_description.n_players:
                        return Action.C
                    else:
                        return Action.D
        return Action.D

class Strategy_COLLECTIVE_213(BaseStrategy):
    """
    A Tit-for-Tat Adaptive Cooperation (TFT-A) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        last_opponent_actions = history.opponent_actions[last_round]
        cooperators = sum(last_opponent_actions)
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action.C

class Strategy_COLLECTIVE_249(BaseStrategy):
    """
    Titan Strategy for Common Pool Resource Game
    Prioritizes long-term sustainability over immediate gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = game_description.capacity * game_description.n_players * (game_description.n_players - 1) / (2 * game_description.n_rounds * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        elif round_number == self.game_description.n_rounds - 1:
            if state.current_stock > self.critical_threshold:
                return Action.C
            else:
                return Action.D
        elif state.current_stock <= self.critical_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_278(BaseStrategy):
    """
    Strategy name: Tit-for-Tat Adaptive (TFT-A)
    A strategy that cooperates initially and responds cooperatively if the opponent cooperated in the previous round. Otherwise, it defects as retaliation but switches back to cooperation once the opponent cooperates again.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.first_round = True
        self.leniency_window = int(self.game_description.n_players // 10)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.first_round = False
        if history is not None and len(history.opponent_actions) > state.round_number - 1:
            last_round = history.opponent_actions[-state.round_number]
            if last_round.sum() == self.game_description.n_players:
                return Action.C
        if not self.first_round and state.round_number >= self.leniency_window:
            last_round = history.opponent_actions[-state.round_number]
            if last_round[0] == Action.D.value:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_281(BaseStrategy):
    """
    A simple implementation of the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.7
        self.punishment_rounds = 3
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))
        self.current_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        if history is None or state.round_number == 0:
            self.history = PlayerHistory(np.zeros(state.round_number + 1, dtype=bool), np.zeros(state.round_number + 1), np.zeros((state.round_number + 1, self.game_description.n_players), dtype=bool), np.zeros(state.round_number + 1))
            return Action.C
        current_opponent_cooperators = sum(history.opponent_actions[-1, :])
        if state.round_number == len(self.history.my_payoffs) - 1:
            total_depletion = self.current_stock / self.game_description.capacity * 100
            if total_depletion > self.threshold:
                return Action.D
            else:
                return Action.C
        self.history = history
        self.current_stock = state.current_stock
        if current_opponent_cooperators >= self.game_description.n_players // 2:
            action = Action.C
        else:
            total_depletion_average = np.mean(self.history.my_payoffs[-self.punishment_rounds:])
            if total_depletion_average > self.current_stock / (2 * self.game_description.capacity):
                action = Action.D
            elif current_opponent_cooperators == 1 and self.history.my_actions[-1] == Action.D:
                action = Action.C
            else:
                action = Action.D
        self.history.my_actions[-1] = action
        if action == Action.C:
            self.history.my_payoffs[-1] = self.current_stock / (2 * self.game_description.n_players)
        else:
            self.history.my_payoffs[-1] = self.current_stock / self.game_description.n_players
        return action

class Strategy_COLLECTIVE_283(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) Strategy for Common Pool Resource Game.
    Strategy encourages cooperation when the common pool resource is abundant and defects when depleted or critical.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_level = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock <= self.critical_stock_level and state.current_stock > 0:
            random_choice = random.choice([0, 1])
            if random_choice == 0:
                return Action.C
            else:
                return Action.D
        if state.current_stock <= self.critical_stock_level or state.current_stock == 0:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_299(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game. Follows a forgiving and reciprocal approach, cooperating in the initial round and then mimicking the opponent's behavior from the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_round_action = history.opponent_actions[last_round, 0] if last_round >= 0 else None
        if last_round_action is None:
            return Action.C
        elif last_round_action:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_317(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0:
            self.last_opponent_action = None
        else:
            self.last_opponent_action = history.opponent_actions[-1, 0] if history is not None else None
            if self.last_opponent_action is not None:
                if self.last_opponent_action:
                    action = Action.C
                else:
                    action = Action.D
        return action

class Strategy_COLLECTIVE_374(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Dynamics (ATFTSD) strategy in Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity
        self.n_players = self.game_description.n_players
        self.average_stock_level = None
        self.last_round_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if self.average_stock_level is None or state.round_number == 1:
            self.average_stock_level = state.current_stock / self.n_players
        self.last_round_action = [history.my_actions[-1] if history else None][0] if history else None
        action = Action.C
        if state.round_number > 1:
            if state.current_stock < self.average_stock_level * 0.5 and self.last_round_action == Action.D:
                action = Action.C
            elif state.current_stock > self.average_stock_level * 1.5 and self.last_round_action == Action.C:
                action = Action.D
            elif random.random() < 0.5:
                action = Action.D
        if state.round_number == self.game_description.n_rounds:
            action = random.choice([Action.C, Action.D])
        return action

class Strategy_COLLECTIVE_392(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.remaining_rounds = game_description.n_rounds - 1
        self.stock_threshold = game_description.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            opponent_action = history.opponent_actions[state.round_number - 1, 0] if history is not None else None
            current_stock = state.current_stock
            if opponent_action is None:
                return Action.C
            elif opponent_action and history.my_actions[state.round_number - 1] == Action.C:
                return Action.C
            elif not opponent_action and history.my_actions[state.round_number - 1] != Action.D:
                return Action.D
            elif current_stock / self.game_description.capacity < self.stock_threshold and self.remaining_rounds > 0:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_443(BaseStrategy):
    """
    Strategy name: Adaptive Fitness-Based Tit-for-Tat (AFB-TFT)
    This strategy chooses to cooperate or defect based on current stock level, the number of players, and the history of actions from previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock = state.current_stock
        coop_majority = np.sum(history.my_actions[-1]) >= self.game_description.n_players // 2
        if stock > self.capacity:
            return Action.C
        elif stock <= self.capacity and coop_majority:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_446(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    This strategy cooperates in the first round and then follows the opponent's action from the previous round.
    If the opponent defected, the TFT-AC player will defect for one round as a response, before resuming cooperation.
    In the last round, the TFT-AC player always cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.round_history) == 0:
            return Action.C
        last_round = self.round_history[-1]
        opponent_action = last_round[state.round_number - 1, state.player_index]
        if state.round_number < self.game_description.n_rounds:
            return Action(opponent_action)
        else:
            return Action.C

    def update_history(self, state: CommonPoolState):
        new_round = np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=np.bool_)
        new_round[state.round_number - 1, state.player_index] = True
        self.round_history.append(new_round)

class Strategy_COLLECTIVE_465(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Growth Adaptation (TfTGA)
    Strategy summary: Demonstrates reciprocity and trustworthiness while maintaining a self-interested approach to preserving the common pool resource. The growth factor encourages cooperation early in the game when the stock is more valuable but punishes defection less severely as resources dwindle.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.growth_factor = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_remaining = self._calculate_stock_remaining(state, history)
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        if stock_remaining > (1 - 1 / n) * capacity:
            growth_factor = min(1, max((stock_remaining - (1 - 1 / n) * capacity) / capacity, 0))
            self.growth_factor = min(self.growth_factor + (1 - self.growth_factor) * growth_factor, 1)
        else:
            self.growth_factor = max(self.growth_factor - (1 - self.growth_factor) * 0.1, 0)
        if history is None or state.round_number == 1:
            return Action.C
        cooperators = sum(history.opponent_actions[-1])
        if cooperators >= self.game_description.n_players // 2 and random.random() < self.growth_factor:
            return Action.C
        return Action.D

    def _calculate_stock_remaining(self, state: CommonPoolState, history: PlayerHistory) -> float:
        if history is None:
            return self.game_description.capacity
        consumption = np.sum([history.my_actions[-1] * (Action.C.value if i == 0 else Action.D.value) for i in range(self.game_description.n_players)])
        stock_after_consumption = state.current_stock - consumption
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
        return min(state.current_stock + growth, self.game_description.capacity)

class Strategy_COLLECTIVE_466(BaseStrategy):
    """
    Implementation of Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._last_opponent_actions = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self._last_opponent_actions is None:
            return Action.C
        opponent_cooperators = np.sum(history.opponent_actions[-self.game_description.n_players, :])
        return Action(int(opponent_cooperators >= self.game_description.n_players // 2))

    def on_round_end(self, payoff: float):
        """
        Update _last_opponent_actions before the next round begins.
        This method will be called at the end of each round.
        """
        self._last_opponent_actions = history.opponent_actions[-self.game_description.n_players, :]

class Strategy_COLLECTIVE_485(BaseStrategy):
    """
    Strategy Name: Adaptive Stock Conservation (ASC)
    A simple game theory strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.mst = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C if state.current_stock > self.mst else Action.D
        if state.current_stock >= self.mst:
            return Action.C
        elif np.random.rand() < 0.5 and state.current_stock < self.mst:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_488(BaseStrategy):
    """
    An adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    Cooperates in the initial round and adapts to opponent's actions in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        opponent_action = history.opponent_actions[state.round_number - 1, 0]
        return Action(int(opponent_action) ^ 1)

class Strategy_COLLECTIVE_493(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.F = self.game_description.n_rounds
        self.player_id = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.player_id = int(history.opponent_actions[state.round_number - 1].argmax()) + 1
        if state.round_number == self.game_description.n_rounds:
            return Action.C if np.all(history.opponent_actions[:, self.player_id - 1] == 1) else Action.D
        cooperators = np.sum(history.opponent_actions[:, self.player_id - 1])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif history.opponent_actions[state.round_number - 1, self.player_id - 1] and (self.F == 1 or np.any(history.opponent_actions[state.round_number - self.F:state.round_number, self.player_id - 1])):
            return Action.D
        else:
            self.F -= 1
            return Action.C

    def recentDefectors(self, history: PlayerHistory, round: int) -> NDArray[np.bool_]:
        recent_defectors = np.zeros((self.game_description.n_players,), dtype=bool)
        for player in range(1, self.game_description.n_players + 1):
            recent_defectors[player] = np.any(history.opponent_actions[round - self.F:round - 1, player - 1])
        return recent_defectors

class Strategy_COLLECTIVE_502(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth Consideration (SG-ATFT) for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators < self.game_description.n_players // 2:
                return Action.D
        else:
            cooperators = sum(history.opponent_actions[state.round_number - 1, :])
            if cooperators == self.game_description.n_players or (cooperators < self.game_description.n_players // 2 and state.round_number != self.game_description.n_rounds):
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_513(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFT-SA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = math.floor(self.game_description.capacity / 2)
        self.params = {'B': 0, 'P': 0, 'A': 0, 'C': 0}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[-1][-1] if history else Action.D
        stock_level = state.current_stock
        payoff = stock_level / (2 * self.game_description.n_players) + self.params['B'] if opponent_action == Action.C and stock_level >= self.threshold else stock_level / (2 * self.game_description.n_players) - self.params['A'] if opponent_action == Action.C and stock_level < self.threshold else stock_level / self.game_description.n_players - self.params['P']
        return Action.D if payoff < random.random() * payoff + self.params['C'] else Action.C

class Strategy_COLLECTIVE_514(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Adjustment (TfTA)

    This strategy always cooperates in the first round to establish a peaceful initial state.
    In subsequent rounds, it responds to opponents' previous actions:
        - If opponent cooperated, TfTA cooperates back to maintain cooperation and ensure a healthy stock level.
        - If opponent defected, TfTA also defects as retaliation against the overconsumption, but adjusts its consumption to prevent rapid stock depletion. Specifically, TfTA consumes:
            - stock/(2n) if opponents' previous total consumption is below a certain threshold (e.g., 80% of capacity).
            - stock/n if opponents' previous total consumption is above the threshold.
    This mechanism encourages cooperation when opponents cooperate and punishes overconsumption, while still maintaining some flexibility to adapt to various opponent behaviors.
    In the last round, TfTA always cooperates regardless of its opponents' previous actions, as there is no future interaction to consider.
    If an opponent does not follow the rules of the game (e.g., consuming more than stock/n), TfTA considers such behavior as defect and adjusts its consumption accordingly, ensuring a minimal sustainable stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity * 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_consumption = np.mean([action for action in history.opponent_actions[:, -1] if action]) * self.game_description.n_players
        if opponent_consumption < self.threshold:
            consumption = state.current_stock / (2 * self.game_description.n_players)
        else:
            consumption = state.current_stock / self.game_description.n_players
        return Action(int(random.uniform(0, 1) <= (state.current_stock - consumption) / state.current_stock))

class Strategy_COLLECTIVE_515(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = self.game_description.capacity // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        if state.round_number == len(history.my_actions):
            if np.all(history.my_payoffs[-1] > 0) and history.opponent_payoffs[-1, -1] > 0:
                return Action.C
            elif state.current_stock <= 0:
                return Action.D
            else:
                opponent_cooperated = np.any(history.opponent_actions[-1])
                stock_below_threshold = state.current_stock < self.stock_threshold
                return Action.D if not opponent_cooperated and stock_below_threshold else history.my_actions[-1]
        else:
            opponent_cooperated = np.any(history.opponent_actions[-1])
            if opponent_cooperated:
                return Action.C
            elif state.current_stock < self.stock_threshold:
                return Action.D
            else:
                return history.opponent_actions[-1, -1]

class Strategy_COLLECTIVE_516(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperated = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.opponent_cooperated = all(history.opponent_actions[-1])
        if state.round_number == 0 or self.opponent_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_517(BaseStrategy):
    """
    An adaptive cooperator strategy for the Common Pool Resource Game, inspired by Tit-for-Tat.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        n_cooperators = sum(history.opponent_actions[last_round])
        n_defectors = self.game_description.n_players - n_cooperators
        if n_cooperators == self.game_description.n_players:
            action = Action.C
            if state.current_stock < self.stock_threshold:
                action = Action.D
        elif n_defectors >= self.game_description.n_players:
            action = Action.C if state.current_stock < self.stock_threshold else Action.D
        else:
            action = Action.D
        return action

class Strategy_COLLECTIVE_518(BaseStrategy):
    """
    A strategy that mimics the Tit-for-Tat game theory strategy with Stock Adaptation (TFT-SA) in Common Pool Resource Games.
    The strategy adjusts its actions based on other players' average cooperation rate and the current state of the stock to maintain a balanced common pool and promote long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_cooperation = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        self.average_cooperation = np.mean(history.my_actions)
        stock_threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        action = Action.C
        if state.current_stock >= stock_threshold and self.average_cooperation > 0.5:
            pass
        elif state.current_stock < stock_threshold and self.average_cooperation <= 0.5:
            action = Action.D
        return action

class Strategy_COLLECTIVE_519(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth (ATFSG) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n, self.r, self.capacity = (game_description.n_players, game_description.n_rounds, game_description.capacity)
        self.min_stock = 2 * self.n / 3
        self.cooperatively_streak = math.ceil(self.capacity / self.r)
        self.revenge_streak = lambda defective_streak: int(defective_streak / (self.r - self.cooperatively_streak) * self.cooperatively_streak)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_actions = np.mean(history.opponent_actions, axis=0)
        streak_start = np.argmax((opponent_actions >= self.cooperatively_streak).astype(int))
        current_streak = len(history.opponent_actions[:, streak_start])
        if state.round_number == self.r - 1:
            payoff_c, payoff_d = (state.current_stock / (2 * self.n), state.current_stock / self.n)
            return Action.C if payoff_c > payoff_d else Action.D
        if current_streak >= self.cooperatively_streak:
            stock_level = state.current_stock / self.capacity
            if stock_level < self.min_stock:
                return Action.C
        elif current_streak >= self.revenge_streak(current_streak - streak_start):
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_520(BaseStrategy):
    """
    The Titan Strategy for the Common Pool Resource Game.
    This strategy cooperates when the current stock level is above the average sustainable level and defects otherwise, using a moving average of the last 3 rounds to define the threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.moving_average = np.zeros(3)
        self.rounds_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.rounds_count += 1
        self.moving_average = np.roll(self.moving_average, -1)
        self.moving_average[-1] = state.current_stock
        if self.rounds_count < 4:
            average = self.game_description.capacity
        else:
            average = np.mean(self.moving_average)
        if state.current_stock > average * self.game_description.n_players:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_521(BaseStrategy):
    """
    The Tit-for-Tat Evolution (TfTE) strategy for the Common Pool Resource Game.
    This strategy fosters reciprocity, forgiveness, and adaptability to encourage cooperation among opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.long_term_defection_counter = 0
        self.forgiveness_timer = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_action = Action.C
        if history is not None:
            if history.my_actions[-1]:
                self.forgiveness_timer = min(self.forgiveness_timer + 1, state.round_number)
                if self.forgiveness_timer == state.round_number:
                    self.long_term_defection_counter = 0
            elif not history.my_actions[-1]:
                self.long_term_defection_counter += 1
                if self.long_term_defection_counter >= self.game_description.n_players // 2:
                    my_action = Action.D
            elif state.round_number > 1 and history.my_actions[-2]:
                self.long_term_defection_counter = 0
        return my_action

class Strategy_COLLECTIVE_522(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptive Stock Awareness (TFT-ASA) game strategy.
    This strategy encourages collective cooperation among players while preserving the common resource for future rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        stock_level = state.current_stock / self.game_description.capacity
        if opponent_cooperators >= self.game_description.n_players // 2 and (state.current_stock <= self.game_description.capacity / 2 or state.current_stock >= self.game_description.capacity - self.game_description.capacity / 2):
            return Action.C
        elif opponent_cooperators < self.game_description.n_players // 2:
            if stock_level <= self.game_description.capacity / 2 or stock_level >= self.game_description.capacity - self.game_description.capacity / 2:
                return Action.C if history.opponent_actions[-1, -1] == Action.C else Action.D
            elif history.opponent_actions[-2, -1] == Action.C:
                return Action.C
            else:
                return Action.D
        else:
            self.history = PlayerHistory(self.history.my_actions, self.history.my_payoffs, history.opponent_actions, history.opponent_payoffs)
            return Action.C if history.opponent_actions[-1, -1] == Action.C else Action.D

class Strategy_COLLECTIVE_523(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_round = 0
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds, dtype=float), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=float))

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is not None:
            self.history = history
        if state.round_number == 0 or (self.current_round > 0 and self.history.my_actions[-1] != Action.D):
            return Action.C
        else:
            return Action.D
        self.current_round += 1

class Strategy_COLLECTIVE_524(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperated_last_round = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponent_cooperated_last_round = np.mean(history.opponent_actions[-1]) > 0.5
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return self.opponent_cooperated_last_round and Action.C or Action.D

class Strategy_COLLECTIVE_525(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Stock Adaptation (TFTSA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        else:
            cooperators = sum(history.opponent_actions[-1])
            return Action(cooperators >= self.game_description.n_players // 2)

class Strategy_COLLECTIVE_527(BaseStrategy):
    """
    Tit-for-Tat-Growing (TFT-G) Strategy for the Common Pool Resource Game.
    Promotes cooperation among players by rewarding cooperative behavior and punishing defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1,), dtype=bool), np.zeros((1,)), np.zeros((1, game_description.n_players), dtype=bool), np.zeros((1, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if not history and state.round_number == 0:
            return Action.C
        self.history = history or self.history
        cooperators = sum(history.opponent_actions[-1, :])
        if all(history.opponent_actions[-1, :]) or cooperators >= np.ceil(self.game_description.n_players / 2):
            return Action.C
        return Action.D

    def last_round(self, t: int):
        return Action.C if t == self.game_description.n_rounds else None

class Strategy_COLLECTIVE_529(BaseStrategy):
    """
    Tit-for-Tat with Growth Adaptation (TFTGA) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.strategy = [Action.C]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_actions) < self.game_description.n_rounds):
            return self.strategy[-1]
        last_action = self.strategy[-1]
        cooperators, defectors = (sum(history.opponent_actions[:, -1]) - len(history.opponent_actions), sum(history.opponent_actions[:, -1]) + sum(history.my_actions[1:] != last_action))
        if cooperators >= self.game_description.n_players // 2 and last_action == Action.D:
            self.strategy.append(Action.C)
        elif defectors < len(history.opponent_actions) - 1 and last_action == Action.C:
            self.strategy.append(Action.D)
        else:
            self.strategy.append(last_action)
        return self.strategy[-1]

class Strategy_COLLECTIVE_530(BaseStrategy):
    """
    Tit-for-Tat Strategy for the Common Pool Resource Game.
    Cooperates on the first round and mimics opponent's actions from the previous round.
    If an opponent cooperated in the last round, cooperate; if they defected, also defect.
    Prioritizes long-term sustainability and cooperation with others while punishing short-sighted defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        if self.last_opponent_action is None:
            self.last_opponent_action = history.opponent_actions[state.round_number - 1, 0]
        action = Action.C if self.last_opponent_action else Action.D
        self.last_opponent_action = history.opponent_actions[state.round_number - 1, 0]
        return action

class Strategy_COLLECTIVE_531(BaseStrategy):
    """Adaptive Tit-for-Tat (ATfT) for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponents_cooperated = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            self.last_opponents_cooperated = True
            return Action.C
        else:
            self.last_opponents_cooperated = all(history.opponent_actions[-1])
            return Action(self.last_opponents_cooperated)

class Strategy_COLLECTIVE_532(BaseStrategy):
    """
    Implementation of the Tit-for-Tat (TFt) strategy with an Adaptive Cooperation Threshold (ACT).
    This strategy encourages cooperation while adapting to the actions of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = int(self.game_description.n_players / 2)
        self.last_round_actions = np.zeros((self.game_description.n_players,), dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.last_round_actions = np.mean(history.opponent_actions[-1], axis=0) > self.cooperation_threshold
        return Action.C if self.last_round_actions else Action.D

class Strategy_COLLECTIVE_533(BaseStrategy):
    """
    S-ATfT Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity
        self.n_players = self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            stock = state.current_stock
            if stock < self.capacity * 0.8 or stock > self.capacity * 0.95:
                return Action.D
        coop_count = np.sum(history.opponent_actions[-1, :])
        my_action = Action.C if coop_count >= self.n_players // 2 else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            stock = state.current_stock
            if stock < self.capacity * 0.8:
                return Action.D
            else:
                return my_action
        return my_action

class Strategy_COLLECTIVE_534(BaseStrategy):
    """Adaptive Tit-for-Tat (A-TFT) strategy in the Common Pool Resource Game."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_length = math.ceil(game_description.n_rounds / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[state.round_number - 1, :]) if history else 0
        defectors = self.game_description.n_players - cooperators
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif defectors == 1 and state.round_number > self.history_length:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_535(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (A-TFT)
    Strategy Description: Adapts to opponent behavior, promotes cooperation, and conserves resources.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(game_description.n_players * 2 / 3)
        self.strategy = 'A-TFT'
        self.stock_state = None
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.history:
            self.stock_state = [state]
            self.history = PlayerHistory(my_actions=[[False]], my_payoffs=[], opponent_actions=history.opponent_actions, opponent_payoffs=history.opponent_payoffs)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if not self.stock_state or len(self.stock_state) < state.round_number + 1:
            self.stock_state.append(state)
        action = Action.C if self.history.my_actions[-1][-1] == Action.D else Action.D
        if state.current_stock < self.threshold and state.round_number != self.game_description.n_rounds:
            self.strategy = 'AC'
        elif self.stock_state[-1].current_stock > self.threshold:
            self.strategy = 'A-TFT'
        if state.current_stock == 0:
            self.strategy = 'AC'
        self.history.my_actions.append([action])
        return action

class Strategy_COLLECTIVE_537(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) with Stock Growth Awareness (SG-ATFT)
    Strategy Summary: Maintains a balanced common pool resource by encouraging cooperation when possible but also responding defensively to defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_stock_thresh = self.game_description.capacity
        self.stock_growth_avg = np.zeros(self.game_description.n_rounds)
        self.last_round_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        if state.round_number == 0 or history is None:
            return Action.C
        self.last_round_action = np.mean(history.opponent_actions[-1])
        if state.round_number == self.game_description.n_rounds:
            current_stock_thresh = min([state.current_stock, self.initial_stock_thresh])
            return Action(1 if current_stock_thresh >= state.current_stock else 0)
        updated_initial_stock_thresh = self.initial_stock_thresh + np.mean(self.stock_growth_avg[:state.round_number]) * (state.round_number - 1)
        if self.last_round_action == 0:
            updated_initial_stock_thresh -= 1
        elif self.last_round_action == 1:
            updated_initial_stock_thresh += 1
        if updated_initial_stock_thresh < 0:
            updated_initial_stock_thresh = 0
        if updated_initial_stock_thresh > self.game_description.capacity:
            updated_initial_stock_thresh = self.game_description.capacity
        return Action(1 if state.current_stock >= updated_initial_stock_thresh else 0)

class Strategy_COLLECTIVE_538(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((game_description.n_rounds, 1), dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[state.round_number - 2:]
        cooperation_count = np.sum(opponent_actions)
        if cooperation_count > len(opponent_actions) - cooperation_count:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_539(BaseStrategy):
    """
    The Tit-for-Tat strategy encourages cooperation when resources are plentiful but defects when the stock is low to prevent overexploitation.
    It also includes forgiveness for initial transgressions by opponents and retaliation if cooperative efforts are consistently ignored.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / (2 * game_description.n_players)
        self.payoff_threshold = 0.75
        self.forgiveness_length = int(game_description.n_rounds / 3)
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=np.bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=np.bool), np.zeros((game_description.n_rounds, game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        last_round = state.round_number - 1
        opponent_cooperated_last_round = sum(history.opponent_actions[last_round, :])
        if current_stock >= self.threshold and opponent_cooperated_last_round:
            return Action.C
        elif current_stock < self.threshold and opponent_cooperated_last_round:
            if history.my_actions[last_round - 1] == Action.C:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            total_payoff = np.sum(history.my_payoffs)
            if total_payoff > self.payoff_threshold * self.game_description.n_rounds:
                return Action.C

class Strategy_COLLECTIVE_540(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponents_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        opponents_actions = history.opponent_actions[-1] if history else self.opponents_history[-1]
        if all((action == Action.C for action in opponents_actions)):
            return Action.C
        elif any((action == Action.D for action in opponents_actions)):
            return Action.D
        self.opponents_history.append(opponents_actions)
        return Action.C

class Strategy_COLLECTIVE_542(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        if self.history is None or state.round_number == self.game_description.n_rounds - 1:
            self.history = PlayerHistory(np.zeros((self.game_description.n_rounds, 1), dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        if state.round_number == 1:
            self.history.my_actions[0] = True
            return Action.C
        past_opponent_actions = self.history.opponent_actions[:, -1]
        my_action = self.history.my_actions[-1]
        if all(past_opponent_actions == my_action):
            self.history.my_actions[-1] = True
            return Action.C
        else:
            self.history.my_actions[-1] = False
            return Action.D

class Strategy_COLLECTIVE_543(BaseStrategy):
    """
    Fitness-based Adaptive Cooperation (FAC) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.stock_history = []
        self.average_stock = 0
        self.T_cooperate = None
        self.T_defect = None
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None:
            if state.round_number == 0:
                self.T_cooperate = self.capacity // 3
                self.T_defect = self.capacity // self.n_players
            self.stock_history.append(state.current_stock)
            self.average_stock = state.current_stock
            self.round_number += 1
        if state.round_number == self.game_description.n_rounds:
            self.T_cooperate = math.floor(state.current_stock + (self.capacity - state.current_stock) / 2)
            self.T_defect = state.current_stock
        self.average_stock = np.mean(self.stock_history[-self.game_description.n_rounds:])
        self.T_cooperate = min(self.average_stock + self.capacity // 3, self.capacity)
        self.T_defect = max(2 * self.average_stock / self.n_players, self.capacity / self.n_players)
        if state.current_stock >= self.T_cooperate and state.current_stock <= self.T_defect:
            stock_fitness = self.stock_fitness(state.current_stock)
            action_probability = random.random() < stock_fitness
        elif state.current_stock > self.T_cooperate:
            action_probability = True
        else:
            action_probability = False
        if action_probability:
            return Action.C
        return Action.D

    def stock_fitness(self, stock):
        return max(0, self.stock_reward(stock) - self.punishment(stock))

    def stock_reward(self, stock):
        return math.exp((stock - self.average_stock) / (2 * self.capacity))

    def punishment(self, stock):
        return math.sqrt((stock - self.average_stock) ** 2 + 10 ** 6)

class Strategy_COLLECTIVE_544(BaseStrategy):
    """
    Adaptive Stock Management Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_level = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or (history and history.my_actions[-1] is None):
            return Action.C
        if not self.critical_stock_level:
            self.critical_stock_level = self.game_description.capacity / (2 * self.game_description.n_players)
        action = Action.C if state.current_stock > self.critical_stock_level else Action.D
        return action

class Strategy_COLLECTIVE_545(BaseStrategy):
    """Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.strategy_length = int(game_description.n_players * 2)
        self.opponent_history = np.zeros((self.strategy_length,), dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = self.opponent_history[-1]
        if opponent_action:
            return Action.C
        else:
            return Action.D
        for i in range(self.strategy_length - 1, -1, -1):
            if history.opponent_actions[i, :].all():
                self.opponent_history = history.opponent_actions[:i + 1]
                break
            elif not history.opponent_actions[i, :].any():
                self.opponent_history = history.opponent_actions[:i + 1]
                return Action.D
        self.opponent_history = np.append(self.opponent_history, history.opponent_actions[-1])

class Strategy_COLLECTIVE_547(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATfT) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_level = game_description.capacity
        self.history = PlayerHistory(np.zeros((1,), dtype=bool), np.zeros((1,), dtype=np.float64), np.zeros((game_description.n_players, 0), dtype=bool), np.zeros((game_description.n_players, 0), dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        self.history = history
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            if self.stock_level > 0:
                return Action.C
            else:
                return Action.D
        else:
            opponent_action = self.history.opponent_actions[-1, (self.history.my_actions[-1] + 1) % 2]
            if opponent_action:
                return Action.C
            elif self.stock_level > 0:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_548(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat strategy for Common Pool Resource Games.
    This strategy cooperates in the first round and then reciprocates cooperation or punishment based on the opponent's previous action, while also considering stock depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_depleted = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock <= 0:
            self.stock_depleted = 1
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2 or self.stock_depleted:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_549(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    A cooperative and fair strategy that rewards cooperation and punishes defection in an adaptive manner, fostering trust among players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            self.last_opponent_action = None
            return Action.C
        self.last_opponent_action = history.opponent_actions[-1][-1] if history else self.last_opponent_action
        if self.last_opponent_action is None or state.round_number == 1:
            return Action.C
        return Action(self.last_opponent_action == Action.C)

class Strategy_COLLECTIVE_550(BaseStrategy):
    """
    Implementation of the Titan Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.median_capacity = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C
        if not self.median_capacity:
            self.median_capacity = np.median(self.game_description.capacity * np.ones((1, self.game_description.n_players)))
        if history:
            total_stock = sum(history.my_payoffs)
            average_stock = total_stock / self.game_description.n_rounds
            if average_stock > self.median_capacity:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_551(BaseStrategy):
    """
    Tit-for-Tat Adaptive (TfTA) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defections = 0
        self.cooperation_counter = 0
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if history is not None:
            round_number = state.round_number - 1
            if round_number == -1 or history.opponent_actions[round_number, 0] is None:
                action = Action.C
            else:
                last_action = history.opponent_actions[round_number, 0]
                if last_action == Action.C and self.defections > 2:
                    action = Action.C
                    self.cooperation_counter = min(3, self.cooperation_counter + 1)
                elif last_action == Action.D:
                    self.defections += 1 if last_action == action else 0
                    action = Action.D
                else:
                    self.defections = 0
                    self.cooperation_counter = 0
            self.last_round = round_number == self.game_description.n_rounds - 1
            if state.current_stock == 0:
                action = None
        return action

class Strategy_COLLECTIVE_552(BaseStrategy):
    """
    Strategy Name: Adaptive Resource Sustainability Strategy (ARSS)

    An adaptive strategy that prioritizes long-term sustainability of the common pool resource,
    aiming for cooperation when possible while ensuring individual survival in the short term.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = np.zeros(self.game_description.n_rounds)
        self.average_sustainable_stock = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        elif state.round_number == self.game_description.n_rounds:
            if state.current_stock > 2 * self.game_description.n_players:
                return Action.D
            else:
                return Action.C
        else:
            total_consumption = np.sum(history.my_actions)
            average_consumption = (self.average_consumption[:state.round_number] + total_consumption).sum() / state.round_number
            average_sustainable_stock = min(self.game_description.capacity, average_consumption * self.game_description.n_players * self.game_description.n_rounds)
            if state.current_stock > average_sustainable_stock and total_consumption < average_consumption:
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_553(BaseStrategy):
    """Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        last_action = history.opponent_actions[last_round][-1]
        if last_action == Action.C and self.history is not None and (self.history.my_actions[-1] != Action.D):
            return Action.C
        if last_action == Action.D and self.history is not None and (self.history.my_actions[-1] != Action.C):
            return Action.D
        if last_round > 0 and history.opponent_actions[last_round - 1][-1] == Action.C and (last_action == Action.D):
            return Action.D
        if self.history is not None and all(history.opponent_actions[-self.game_description.n_players + 1:-1][-1] == Action.D):
            return self.history.my_actions[-1]
        return Action.C

class Strategy_COLLECTIVE_556(BaseStrategy):
    """
    Strategy Name: Adaptive Resource-Oriented Tit-for-Tat (AROTFT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.8
        self.cooperate_count = 0
        self.defect_count = 0
        self.rounds = self.game_description.n_rounds
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=bool)
        self.last_opponent_action = opponent_actions[-1]
        cooperators = sum(opponent_actions)
        current_stock_per_player = state.current_stock / self.game_description.n_players
        self.cooperate_count += int(cooperators > (self.rounds - 1) // 2)
        self.defect_count += int(not cooperators)
        if self.last_opponent_action and state.current_stock / (self.game_description.n_players * 2) > current_stock_per_player * self.threshold:
            return Action.C
        stock_ratio = state.current_stock / (self.game_description.n_players * current_stock_per_player)
        if stock_ratio <= self.threshold and self.cooperate_count < self.rounds // 3:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_557(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptive Cooperation (TFT-AC) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.tolerance = game_description.n_players // 2
        self.forgiveness_count = 0
        self.defection_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_action = history.opponent_actions[-1, -1]
        if opponent_action == Action.D and self.defection_count < self.game_description.n_players:
            self.defection_count += 1
        elif opponent_action == Action.C:
            self.defection_count = max(0, self.defection_count - 1)
        if opponent_action == Action.C and self.forgiveness_count < 2:
            self.forgiveness_count += 1
        else:
            self.forgiveness_count = 0
        if opponent_action == Action.C and self.defection_count < self.tolerance:
            return Action.C
        elif opponent_action == Action.D:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1 or self.defection_count >= self.game_description.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_560(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game
    Cooperates in the first round, cooperates if opponent cooperated in the previous round,
    defects as a punishment when opponent defected and maintains cooperation when resources are abundant.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_over_2n = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or len(history.opponent_actions) < state.round_number + 1:
            return Action.D
        previous_action = history.opponent_actions[state.round_number - 1, 0]
        if previous_action:
            stock = min(self.game_description.capacity, state.current_stock + 2 * state.current_stock * (1 - state.current_stock / self.capacity_over_2n))
            if stock > self.game_description.capacity / 2:
                return Action.C
        return Action.D if state.current_stock <= self.game_description.n_players else Action.C if previous_action else Action.D

class Strategy_COLLECTIVE_562(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game.
    Promotes cooperation and fairness by reciprocating opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1 if state.round_number > 0 else 0
        opponent_action = history.opponent_actions[last_round, 0] if history is not None else None
        action = Action.C if opponent_action is None or opponent_action else Action.C if opponent_action == Action.C else Action.D
        return Action.C if state.round_number >= self.game_description.n_rounds - 1 else action

class Strategy_COLLECTIVE_563(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    Promotes cooperation by cooperating initially and copying opponent's last action in subsequent rounds.
    If the opponent has been cooperative, ATFT continues to cooperate; if not, it defects until the opponent switches back to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self._last_opponent_action is None or state.round_number == 1:
            self._last_opponent_action = False if history.opponent_actions[-1, :].sum() == 0 else True
        cooperate = self._last_opponent_action and history.my_actions[-1]
        action = Action.C if cooperate else Action.D
        self._last_opponent_action = history.opponent_actions[-1, :].sum() > len(history.opponent_actions[0]) // 2
        return action

class Strategy_COLLECTIVE_565(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        self.opponent_history = history.opponent_actions.tolist()
        if state.round_number == 0 or len(self.opponent_history) < state.round_number + 1:
            return Action.C
        opponent_cooperated = self.opponent_history[-1][state.round_number - 1]
        if opponent_cooperated:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return state.current_stock > 0 and (not opponent_cooperated) and (history.opponent_actions[-1][-1] == Action.C) and Action.C or Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_566(BaseStrategy):
    """
    Adaptive Fitness-based Tit-for-Tat strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.current_stock = self.capacity
        self.average_previous_round_payoff = 0.0
        self.previous_round_payoff = 0.0
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or self.history is None:
            return Action.C
        self.history = history
        self.previous_round_payoff = history.my_payoffs[-1]
        self.average_previous_round_payoff = np.mean(history.my_payoffs[1:])
        if state.round_number == len(self.history.my_actions):
            return Action.C
        if history.opponent_actions[-1, :].sum() >= self.n_players // 2:
            return Action.C
        if self.previous_round_payoff > self.average_previous_round_payoff and self.history.my_actions[-1] == Action.C:
            return Action.C
        if self.previous_round_payoff < self.average_previous_round_payoff and self.history.my_actions[-1] == Action.D:
            return Action.D
        if self.previous_round_payoff < self.average_previous_round_payoff and self.history.my_actions[-1] != Action.D:
            return Action.C
        return Action.D

    def update_state(self, state: CommonPoolState):
        total_consumption = np.sum(self.history.my_actions[-1]) * (self.n_players / self.current_stock)
        self.current_stock -= total_consumption
        growth = 2 * min(self.capacity, self.current_stock) * (1 - self.current_stock / self.capacity)
        new_stock = min(self.capacity, max(0, self.current_stock + growth))
        self.current_stock = new_stock

class Strategy_COLLECTIVE_567(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._stock_threshold = game_description.capacity // 2

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or state.current_stock > self._stock_threshold:
            return Action.C
        cooperators = np.sum(history.opponent_actions[-1])
        if cooperators >= self.game_description.n_players // 2 and state.current_stock < self._stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_568(BaseStrategy):
    """
    Strategy Name: Adaptive Resource Tit-for-Tat (ARTFT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consumption_history = []
        self.threshold = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.threshold:
            self.threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        if len(self.consumption_history) < 3:
            self.consumption_history += [0] * (3 - len(self.consumption_history))
        consumption_rate = np.mean(self.consumption_history[-3:])
        if consumption_rate > self.threshold:
            return Action.D
        self.consumption_history.append(state.current_stock - (history.my_actions[0] and history.opponent_actions[-1, :].sum() * state.current_stock) / self.game_description.n_players)
        return Action.C

class Strategy_COLLECTIVE_569(BaseStrategy):
    """
    A Tit-for-Tat Adaptive strategy that promotes cooperation if reciprocated, but can switch to defection if there's a history of betrayal.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperations, self.defections = (0, 0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds:
            return Action.C
        if history is not None:
            self._update_history(history)
        cooperations = self.cooperations
        defections = self.defections
        return Action.C if cooperations > defections else Action.D

    def _update_history(self, history: PlayerHistory):
        self.cooperations += np.sum(history.my_actions)
        self.defections += np.sum(np.logical_not(history.my_actions))

class Strategy_COLLECTIVE_571(BaseStrategy):
    """
    A class implementing the Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1))
            return Action.C
        if state.round_number <= self.game_description.n_rounds // 2:
            return Action.C
        cooperators = np.sum(history.opponent_actions[self.game_description.n_rounds // 2 - 1, :])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_572(BaseStrategy):
    """
    Adaptive Cooperative-Competitive Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.alpha = 0.3
        self.w_si_prev = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            w_c = max(0, min(1 - state.current_stock / self.game_description.capacity, 1))
            return Action.C if w_c >= 0.5 else Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        total_payoffs = np.sum(history.my_payoffs)
        w_si = self.alpha * total_payoffs + (1 - self.alpha) * self.w_si_prev[-1]
        w_c = max(0, min(1 - state.current_stock / self.game_description.capacity, 1))
        return Action.C if w_c > w_si else Action.D

    def update_moving_average(self, payoff: float):
        self.w_si_prev = np.roll(self.w_si_prev, -1)
        self.w_si_prev[-1] = self.alpha * payoff + (1 - self.alpha) * self.w_si_prev[-1]

class Strategy_COLLECTIVE_573(BaseStrategy):
    """
    Strategy Name: Adaptive Cooperative-Competitive Algorithm (ACCA) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = self.game_description.capacity * 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        majority = sum(history.opponent_actions[-1])
        if majority > self.game_description.n_players // 2:
            return Action.C
        if state.current_stock < self.stock_threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_574(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy for the Common Pool Resource Game.
    The AI player will maintain a balance between cooperation and competition while promoting collective interests.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        opponent_cooperation = np.mean(history.opponent_actions[state.round_number - 1])
        return Action(int(opponent_cooperation >= self.game_description.n_players // 2))

class Strategy_COLLECTIVE_575(BaseStrategy):
    """
    Adaptive Tit-for-Tat (A-TFT) strategy for Common Pool Resource Games.
    A cooperative strategy inspired by original Tit-for-Tat in Prisoner's Dilemma games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_scores = [0 for _ in range(game_description.n_players)]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            cooperation_score = np.mean(self.cooperation_scores)
        else:
            cooperation_score = np.mean(history.my_actions[-1])
        action = Action.C if cooperation_score >= 0 else Action.D
        for i, opponent_action in enumerate(history.opponent_actions[state.round_number - 1]):
            if opponent_action is not None:
                if opponent_action:
                    self.cooperation_scores[i] = max(self.cooperation_scores[i], 1)
                else:
                    self.cooperation_scores[i] = min(self.cooperation_scores[i], -1)
        return action

class Strategy_COLLECTIVE_576(BaseStrategy):
    """
    Strategy Name: Adaptive Cooperation-Based Resource Allocation (ACRA)

    This strategy promotes cooperation among players by prioritizing the collective interest when possible,
    while also considering self-interest in scenarios where the common pool is at risk of depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_stock_percentage = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and history.my_payoffs is not None:
            self.current_stock_percentage = state.current_stock / self.game_description.capacity * 100.0
            if self.current_stock_percentage > self.game_description.n_players // 2:
                return Action.C
            elif self.current_stock_percentage <= self.game_description.n_players // 2:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_577(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game.
    A strategy that encourages cooperation among opponents by rewarding cooperative behavior and punishing defection through adaptive tit-for-tat retaliation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        strategy = {'cooperate': 1}
        if history is not None and (not self.last_round):
            last_round_action = history.opponent_actions[-1, -1]
            if last_round_action:
                strategy['cooperate'] = 1
            else:
                strategy['cooperate'] = 0
        if state.round_number == self.game_description.n_rounds - 1:
            self.last_round = True
            if np.sum(history.opponent_actions[:, -1]) >= self.game_description.n_players // 2:
                strategy['cooperate'] = 1
            else:
                strategy['cooperate'] = 0
        return Action(strategy['cooperate'])

class Strategy_COLLECTIVE_578(BaseStrategy):
    """Adaptive Stock Preservation (ASP) Strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cd_threshold = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not self.cd_threshold:
            self.cd_threshold = self._calculate_cd_threshold(state.round_number, self.game_description.n_players, self.game_description.capacity)
        remaining_stock = state.current_stock
        if remaining_stock > self.cd_threshold * remaining_stock:
            return Action.C
        return Action.D

    def _calculate_cd_threshold(self, round_number: int, n_players: int, capacity: float) -> float:
        return (capacity - n_players) / capacity * (round_number / (round_number + 1))

class Strategy_COLLECTIVE_579(BaseStrategy):
    """
    A Tit-for-Tat strategy for the Common Pool Resource Game that encourages reciprocity and maintains a stable relationship with opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_players = self.game_description.n_players
        self.rounds = self.game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.rounds or state.round_number == self.rounds - 1:
            return Action.C
        else:
            opponent_actions = history.opponent_actions[state.round_number - 1, :]
            cooperators = sum(opponent_actions)
            if cooperators >= self.num_players // 2:
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_580(BaseStrategy):
    """
    Adaptive Stock-based Tit-for-Tat (ASTFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.8 * (2 * self.game_description.n_players)
        self.stock_warning = 0.6 * (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > self.stock_threshold:
            return Action.C
        if state.current_stock < self.stock_warning:
            return Action.D
        cooperators = np.count_nonzero(history.opponent_actions[-1, :])
        max_cooperators = np.max(history.my_actions)
        return Action(int(max_cooperators == 1 if cooperators >= self.game_description.n_players // 2 else max_cooperators))

class Strategy_COLLECTIVE_581(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_limit = math.floor(game_description.n_players / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            opponent_cooperated = sum(history.opponent_actions[:, -1]) >= self.forgiveness_limit
            my_defected = sum(history.my_actions) > self.forgiveness_limit
            if opponent_cooperated or my_defected:
                return Action.C if not my_defected else Action.D
        return Action.D

class Strategy_COLLECTIVE_582(BaseStrategy):
    """
    Implements an Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((1,), dtype=bool), my_payoffs=np.array([0.0]), opponent_actions=np.zeros((self.game_description.n_players, 1)), opponent_payoffs=np.zeros((self.game_description.n_players, 1)))
        self.k = int(math.ceil(self.game_description.n_rounds * 0.25))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.history = PlayerHistory(my_actions=np.zeros((1,), dtype=bool), my_payoffs=np.array([0.0]), opponent_actions=np.zeros((self.game_description.n_players, 1)), opponent_payoffs=np.zeros((self.game_description.n_players, 1)))
            return Action.C
        self.history = history
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        coop_count = np.sum(self.history.opponent_actions[-self.k:, :], axis=0).sum()
        my_coop_count = self.history.my_actions[-self.k:].sum()
        opponent_coop_rate = coop_count / self.k
        my_coop_rate = my_coop_count / self.k
        if current_round == self.game_description.n_rounds - 1:
            if opponent_coop_rate >= 0.5 and my_coop_rate >= 0.5:
                return Action.C
            elif opponent_coop_rate < 0.5 and my_coop_rate < 0.5:
                return Action.D
            elif opponent_coop_rate > my_coop_rate:
                return Action.C
            else:
                return Action.D
        elif opponent_coop_rate >= 0.5 and my_coop_rate >= 0.5:
            return Action.C
        elif opponent_coop_rate < 0.5 and my_coop_rate < 0.5:
            return Action.D
        elif opponent_coop_rate > my_coop_rate:
            return Action.C if self.history.my_actions[-1] == Action.C else Action.D
        else:
            return Action.C if self.history.my_actions[-1] == Action.D else Action.D

class Strategy_COLLECTIVE_583(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT) with Stock Growth Consideration (SG-ATFT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.growth_threshold = 0.2 * game_description.capacity / game_description.n_players
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        last_round = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players, dtype=bool)
        growth = np.sum([state.current_stock - round_state[2] for round_state in history.opponent_payoffs if state.round_number > round_state[0]]) if history else 0
        if growth > self.growth_threshold:
            return Action.C
        cooperators = sum(last_round)
        if cooperators == self.game_description.n_players:
            return Action.C
        elif np.any(last_round):
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_585(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) Strategy for the Common Pool Resource Game.
    Promotes long-term stability in the common pool resource game by creating a balance between cooperation and punishment, adapting its actions based on the collective behavior of opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((game_description.n_rounds, 1), dtype=bool), my_payoffs=np.zeros(game_description.n_rounds, dtype=float), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=float))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self._update_history(state, history)
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

    def _update_history(self, state: CommonPoolState, history: PlayerHistory):
        round_number = state.round_number
        action = self.__class__.__name__.lower() + '_' + str(round_number) if history is not None else 'initial'
        self.history.my_actions[round_number] = [action == action]

class Strategy_COLLECTIVE_586(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATfT) strategy for the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.round += 1
        if not history:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        if last_round == state.round_number - 1 and last_round >= 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[last_round])
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_587(BaseStrategy):
    """
    Adaptive Stock-based Tit-for-Tat (AS-TFT) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.threshold is None or state.round_number != self.game_description.n_rounds:
            self.threshold = np.mean(self._calculate_maximum_sustainable_stocks())
        current_stock = state.current_stock
        if current_stock < self.threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_maximum_sustainable_stocks(self) -> NDArray[np.float64]:
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        return np.array([capacity * (1 - i / r) ** 2 for i in range(1, r + 1)])

class Strategy_COLLECTIVE_588(BaseStrategy):
    """
    Tit-for-Tat Adaptive Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_count = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(history.opponent_actions) == 1:
            return Action.C
        opponent_action = history.opponent_actions[-1][-1]
        if opponent_action == Action.C and self.forgiveness_count < 2:
            self.forgiveness_count += 1
            return Action.C
        elif opponent_action == Action.D and self.forgiveness_count >= 2:
            self.forgiveness_count = 0
            return Action.C
        else:
            self.forgiveness_count = max(self.forgiveness_count - 1, 0)
            return Action.D

class Strategy_COLLECTIVE_589(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Buffer and Fading Memory strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.buffer = 0.8 * game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > 0:
            buffer_level = self.buffer * min(state.round_number, len(history.opponent_actions)) / state.round_number
        else:
            buffer_level = self.buffer
        return Action.C if state.current_stock > buffer_level else Action.D

class Strategy_COLLECTIVE_590(BaseStrategy):
    """
    A strategy that follows Adaptive Tit-for-Tat in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and (not history):
            return Action.C
        else:
            self.opponent_history = history.opponent_actions if history is not None else self.opponent_history
            opponent_cooperated = np.sum(self.opponent_history[-1]) >= self.game_description.n_players // 2
            return Action.C if opponent_cooperated else Action.D

class Strategy_COLLECTIVE_591(BaseStrategy):
    """
    A strategy that mimics the opponent's action from the previous round, encouraging reciprocity and punishing defections in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.last_opponent_action is None:
            self.last_opponent_action = history.opponent_actions[state.round_number - 1, :].mean()
        action = Action.C if self.last_opponent_action == 1 else Action.D
        self.last_opponent_action = history.opponent_actions[state.round_number - 1, :].mean()
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return action

class Strategy_COLLECTIVE_592(BaseStrategy):
    """
    The Titan Strategy for the Common Pool Resource Game.
    Cooperates in the initial round and adapts based on historical payoffs and current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.total_payoff = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        action = Action.D
        if state.round_number > 1:
            total_consumption = sum(self.stock_history[1:state.round_number])
            stock = self.game_description.capacity - total_consumption
            average_stock = np.mean(np.array(self.stock_history)[1:state.round_number])
            if stock >= average_stock:
                action = Action.C
        if state.round_number == self.game_description.n_rounds:
            payoff_per_cooperation, payoff_per_defection = self.get_payoffs()
            total_payoff_per_strategy = payoff_per_cooperation * (self.game_description.capacity - state.current_stock) / (2 * self.game_description.n_players)
            total_payoff_per_defection = (state.current_stock - (total_consumption + state.current_stock)) / self.game_description.n_players
            if total_payoff_per_strategy > total_payoff_per_defection:
                action = Action.C
        self.stock_history.append(state.current_stock)
        self.total_payoff += state.current_stock / (2 * self.game_description.n_players if action == Action.C else self.game_description.n_players)
        return action

    def get_payoffs(self):
        payoff_per_cooperation = 0.0
        payoff_per_defection = 0.0
        for round_history in self.stock_history:
            if len(round_history) > 0:
                consumption = sum(round_history)
                stock = self.game_description.capacity - consumption
                payoff_per_cooperation += stock / (2 * self.game_description.n_players)
                payoff_per_defection += stock / self.game_description.n_players
        return (payoff_per_cooperation, payoff_per_defection)

class Strategy_COLLECTIVE_593(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFt)
    Summary: A cooperative strategy that adjusts its actions based on the average stock depletion rate over the last few rounds and a critical stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.capacity / game_description.n_players * 1.1)
        self.critical_stock = game_description.capacity - game_description.capacity / game_description.n_players * game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            avg_depletion = np.mean(history.opponent_payoffs[-self.game_description.n_rounds:])
            if avg_depletion < self.threshold and state.current_stock >= self.critical_stock:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_594(BaseStrategy):
    """Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = np.zeros((1 + self.game_description.n_rounds,), dtype=bool)
        self.current_round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or self.current_round == 0:
            self.opponent_history[0] = False
            return Action.C
        self.current_round += 1
        last_opponent_action = self.opponent_history[-1]
        if self.current_round < self.game_description.n_rounds and last_opponent_action:
            return Action.C
        elif self.current_round >= self.game_description.n_rounds and (not last_opponent_action):
            return Action.D
        if self.current_round in (self.game_description.n_rounds - 1, self.game_description.n_rounds - 2):
            return Action.C
        opponent_cooperators = np.sum(self.opponent_history[-2:])
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_595(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_stock_level_threshold = game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and (not history):
            if state.current_stock < self.initial_stock_level_threshold:
                return Action.C
            else:
                opponent_action = np.mean(history.opponent_actions[-1, :]) if history else None
                if opponent_action is None or opponent_action == 0:
                    return Action.D
                return Action.C
        opponent_action = np.mean(history.opponent_actions[state.round_number - 1, :])
        if opponent_action == 1:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_596(BaseStrategy):
    """
    Adaptive Fitness-Maximizing Tit-for-Tat (AFM-TFT) strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1,), dtype=bool), np.zeros((1,)), np.zeros((1, game_description.n_players), dtype=bool), np.zeros((1,)))
        self.average_consumption = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.history = history
            self.average_consumption = np.mean(self.history.opponent_actions[:, :-1].sum(axis=0) / (state.round_number - 1))
        if self.average_consumption < self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.C
        else:
            current_consumption = np.mean(self.history.opponent_actions[:, -1])
            if current_consumption < self.game_description.capacity / (2 * self.game_description.n_players):
                self.average_consumption = current_consumption
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_597(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy for Common Pool Resource Games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((1, 1), dtype=bool), my_payoffs=np.zeros(1), opponent_actions=np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((self.game_description.n_rounds, self.game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_round = state.round_number - 1
        opponent_cooperated_last = sum(history.opponent_actions[current_round, :]) > len(history.opponent_actions) // 2
        if opponent_cooperated_last:
            self.history.my_actions[-1] = True
            return Action.C
        else:
            self.history.my_actions[-1] = False
            if current_round < self.game_description.n_rounds - 1:
                return Action.D

    def get_payoffs(self, state: CommonPoolState) -> np.ndarray:
        """
        Calculate and return the payoff for this strategy in the given state and history.
        """
        current_round = state.round_number - 1
        stock = state.current_stock / self.game_description.n_players
        if np.all(self.history.my_actions[-1]):
            my_payoff = stock / (2 * len(self.history.opponent_actions))
        else:
            my_payoff = stock / len(self.history.opponent_actions)
        self.history.my_payoffs[current_round + 1] = my_payoff
        return np.array([my_payoff])

class Strategy_COLLECTIVE_598(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = np.zeros((1, self.game_description.n_players), dtype=bool)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == 0:
            self.opponent_history = np.zeros((1, self.game_description.n_players), dtype=bool)
            return Action.C
        opponent_cooperators = sum(self.opponent_history[-1, :])
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            self.opponent_history = np.roll(self.opponent_history, -1)
            return Action.D

class Strategy_COLLECTIVE_599(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat with Resource Consideration (ATfT-RC)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = math.floor(self.game_description.capacity / 2)
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if not history and state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if not history:
            history = PlayerHistory(np.zeros((self.game_description.n_rounds,), dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
        if len(history.opponent_actions) == 0:
            return Action.D
        last_round = len(history.opponent_actions) - 1
        if all(history.opponent_actions[last_round, :]) and state.current_stock >= self.threshold:
            history.my_actions[-1] = True
        elif (state.current_stock < self.threshold or last_round == 0) and any(history.opponent_actions[last_round, :]):
            history.my_actions[-1] = False
        else:
            history.my_actions[-1] = True if state.current_stock > self.threshold * 0.9 else False
        return Action(history.my_actions[-1])

class Strategy_COLLECTIVE_600(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat for Common Pool Resource Game
    Summary: This strategy mimics cooperation when others do but retaliates when betrayed.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.history = history or self.history
        action = Action.C
        if state.round_number == 0:
            return action
        last_round = self.history.my_actions[-1].size - 1
        if state.round_number >= last_round or state.round_number == self.game_description.n_rounds - 1:
            action = Action.C
        else:
            all_cooperators = np.all(self.history.opponent_actions[-last_round - 1])
            if all_cooperators:
                action = Action.C
            else:
                action = self.history.my_actions[-last_round - 1][0]
        return action

class Strategy_EXPLOITATIVE_13(BaseStrategy):
    """
    A strategy called "Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT)" for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgetting_factor = 0.9
        self.cooperation_threshold = 1 - self.forgetting_factor
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if self.history is None:
            self.history = history
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            cooperation_threshold = max(self.cooperation_threshold, 0)
            if cooperation_threshold > 0:
                return Action.C
            else:
                return Action.D
        cooperators = np.sum(self.history.opponent_actions[-1])
        cooperation_ratio = cooperators / self.game_description.n_rounds
        cooperation_threshold = max((1 - self.forgetting_factor) * self.cooperation_threshold + self.forgetting_factor * cooperation_ratio, 0)
        return Action.C if cooperation_threshold >= 1 - self.forgetting_factor else Action.D

class Strategy_EXPLOITATIVE_27(BaseStrategy):
    """
    Tit-for-Tat-Growth (TfT-G) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.deficit = 0.0
        self.threshold = int(self.game_description.capacity / 4)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.deficit += state.current_stock - self.game_description.capacity
        strategy = Action.C
        if state.round_number == 0:
            strategy = Action.C
        elif state.round_number == self.game_description.n_rounds and self.deficit > self.threshold:
            strategy = Action.D
        elif history.opponent_actions[-1, -1] == Action.D:
            strategy = Action.D
        elif strategy == Action.C and state.current_stock <= 0:
            strategy = Action.D
        return strategy

class Strategy_EXPLOITATIVE_43(BaseStrategy):
    """
    A Tit-for-Tat Adaptive (TfTA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.last_opponent_action is None:
            self.last_opponent_action = int(history.opponent_actions[-1, 0])
        if history.my_actions[-1] == self.last_opponent_action:
            return Action(self.last_opponent_action)
        else:
            return Action(1 - self.last_opponent_action)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_EXPLOITATIVE_44(BaseStrategy):
    """
    A Tit-for-Tat-Adaptive (TfTA) game strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        if state.round_number == last_round:
            cooperated = history.opponent_payoffs[last_round][-1] > 0
            return Action.C if cooperated else Action.D
        last_opponent_action = bool(history.opponent_actions[last_round, -1])
        return Action.C if not last_opponent_action else Action.D

class Strategy_EXPLOITATIVE_79(BaseStrategy):
    """
    A Tit-for-Tat strategy with growth adaptation for the common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_max = 0.5
        self.consecutive_cooperation = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        opponent_action_prev = history.opponent_actions[-1][-1]
        growth = state.current_stock * (2 - state.current_stock / self.game_description.capacity)
        if state.round_number == len(history.my_actions):
            return Action.C
        if opponent_action_prev == Action.C:
            self.consecutive_cooperation += 1
            return Action.C
        elif opponent_action_prev == Action.D and self.consecutive_cooperation >= math.floor(growth / self.game_description.capacity * self.forgiveness_max):
            self.consecutive_cooperation = 1
            return Action.C
        else:
            self.consecutive_cooperation = 0
            return Action.D

class Strategy_EXPLOITATIVE_90(BaseStrategy):
    """
    Strategy name: Adaptive Tit-for-Tat (ATFT)
    Strategy description: Encourages cooperation when it benefits the player but also punishes uncooperative opponents to maximize payoff in the long run.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = math.ceil(game_description.n_players / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_history = history.opponent_actions[:, -self.game_description.n_rounds:] if history is not None else np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=np.bool_)
        cooperators = np.sum(opponent_history, axis=0)
        if np.all(cooperators >= self.cooperation_threshold):
            return Action.C
        elif (cooperators > 0).any() and np.count_nonzero(cooperators) <= self.game_description.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_116(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation Threshold (TTFT)

    A strategy that cooperates when opponents do and defects otherwise, adapting its cooperation threshold based on the number of players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = math.ceil(game_description.n_players / 2)
        self.cooperation_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            opponent_action = history.opponent_actions[-1, -1] if len(history.opponent_actions) > 0 else False
            self.cooperation_counter += int(opponent_action)
            if self.cooperation_counter >= self.cooperation_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_130(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Quota (TACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds_played_so_far = 0
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number < self.game_description.n_rounds and self.last_opponent_action is None:
            self.rounds_played_so_far += 1
            return Action.C
        elif state.round_number >= self.game_description.n_rounds - 5:
            cooperative_quota = (2 * self.game_description.n_players * self.rounds_played_so_far - state.current_stock) / (2 * self.game_description.n_rounds)
            cooperative_quota *= 0.95
        else:
            cooperative_quota = (2 * self.game_description.n_players * self.rounds_played_so_far - state.current_stock) / (2 * self.game_description.n_rounds)
        last_opponent_cooperation = sum(history.opponent_actions[-1, :])
        if last_opponent_cooperation > cooperative_quota:
            return Action.C
        self.last_opponent_action = history.opponent_actions[-1]
        return Action.D

class Strategy_EXPLOITATIVE_131(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Stock Adaptation (TFTSA)
    Strategy description: A strategy that cooperates when the resource level is above a threshold and defects otherwise, adopting an exploitative approach to encourage balanced resource consumption.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity / (2 * self.game_description.n_players)
        self.critical_threshold = self.capacity / (4 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.current_stock <= self.critical_threshold:
            return Action.C
        cooperation = sum(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2
        return Action(cooperation) if state.current_stock > self.capacity / (2 * self.game_description.n_players) else Action.D

class Strategy_EXPLOITATIVE_169(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Quota (TFT-ACQ) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_quota = game_description.n_players // 2
        self.history = PlayerHistory(np.zeros((1, game_description.n_players), dtype=bool), np.zeros((1,), dtype=float), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros((game_description.n_rounds,), dtype=float))
        self.cooperative_quota_change = 1 / game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = np.sum(history.opponent_actions[:, -1])
        total_players = history.opponent_actions.shape[1]
        if total_consumption <= self.cooperative_quota:
            return Action.C
        else:
            self.cooperative_quota += self.cooperative_quota_change if np.sum(history.my_actions[-1]) else -self.cooperative_quota_change
            self.cooperative_quota = max(min(self.cooperative_quota, total_players - 1), 0)
        return Action.D

class Strategy_EXPLOITATIVE_176(BaseStrategy):
    """
    A Tit-for-Tat strategy with stock adaptation for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold_cooperate = 0.6
        self.stock_threshold_defect = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock < self.game_description.capacity * self.stock_threshold_defect:
                return Action.D
        action = history.opponent_actions[-1][0] if history else None
        if state.current_stock >= self.game_description.capacity * self.stock_threshold_cooperate:
            return Action.C if action is not None and action == Action.C else Action.D
        elif action is not None and action == Action.D or state.current_stock < self.game_description.capacity * self.stock_threshold_defect:
            return Action.D
        elif state.current_stock >= self.game_description.capacity * self.stock_threshold_cooperate:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_179(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Growth (ATTSG) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = int(0.3 * game_description.n_players)
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        elif state.round_number < self.game_description.n_rounds:
            if self.history is None or len(self.history.opponent_actions) == 0:
                return Action.C
            last_round = len(self.history.opponent_actions) - 1
            last_round_cooperators = np.sum(self.history.opponent_actions[last_round, :])
            if last_round_cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                if state.current_stock < self.threshold:
                    for i in range(len(self.history.opponent_actions)):
                        self.history.opponent_actions[i] = Action.C.value
                return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_193(BaseStrategy):
    """
    A Tit-for-Tat Strategy for the Common Pool Resource Game, promoting cooperation while being able to retaliate when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.rounds_defected_by_opponent = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_actions) == 0):
            return Action.C
        last_opponent_action = self.last_opponent_action if self.last_opponent_action is not None else history.opponent_actions[-1, 0]
        self.rounds_defected_by_opponent += 1 if last_opponent_action == Action.D else self.rounds_defected_by_opponent - 1
        action = Action.C if last_opponent_action == Action.C and state.round_number != self.game_description.n_rounds or state.round_number == self.game_description.n_rounds else Action.D if self.rounds_defected_by_opponent >= self.game_description.n_players // 2 else Action.C
        self.last_opponent_action = last_opponent_action
        return action

class Strategy_EXPLOITATIVE_202(BaseStrategy):
    """
    This strategy is Tit-for-Tat with Growth Adaptation (TfT-GA). It cooperates initially and responds to opponents' actions in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif history is not None:
            cooperators = sum(history.opponent_actions[-1])
            if cooperators >= self.game_description.n_players // 2 and state.current_stock > 0:
                return Action.C
            elif state.round_number < self.game_description.n_rounds - 1 and state.current_stock > 0:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_221(BaseStrategy):
    """
    A strategy that cooperates initially and responds to the opponent's actions in subsequent rounds, adopting a cooperative approach but retaliating against defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_cooperative_stock = 2 * game_description.n_players
        self.random_threshold = self.min_cooperative_stock / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.D
        opponent_cooperated = np.any(history.opponent_actions[-1])
        current_stock = state.current_stock
        last_stock = history.opponent_payoffs[-1]
        if opponent_cooperated and current_stock < self.min_cooperative_stock:
            return Action.C
        elif opponent_cooperated and current_stock >= self.min_cooperative_stock:
            return Action.D
        else:
            return random.random() > self.random_threshold and Action.C or Action.D

class Strategy_EXPLOITATIVE_243(BaseStrategy):
    """
    A simple strategy called Adaptive Tit-for-Tat with Stock Growth (ATFTSG).
    This strategy is cooperative and exploitative, balancing cooperation with self-interest.
    It adjusts its actions based on the average stock level depletion in previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_consumption = np.zeros(game_description.n_rounds)
        self.rounds_played = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if not history:
            return Action.C
        self.rounds_played += 1
        total_consumption = self.total_consumption[-1] + history.my_actions[self.rounds_played - 1].sum()
        self.total_consumption[self.rounds_played] = total_consumption
        average_stock_depletion = total_consumption / (2 * self.game_description.n_players * self.rounds_played)
        if state.current_stock > 0 and state.current_stock <= self.game_description.capacity * 2 / 3:
            action = Action.D if average_stock_depletion >= 0.5 else Action.C
        elif state.current_stock > self.game_description.capacity * 2 / 3 or state.current_stock == 0:
            action = Action.C
        elif average_stock_depletion >= 0.5 and state.current_stock <= self.game_description.capacity * 2 / 3:
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_250(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFTSA) Strategy in Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_cooperate = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.initial_cooperate else Action.D
        elif 1 < state.round_number <= self.game_description.n_players and (not self.initial_cooperate):
            self.initial_cooperate = True
            return Action.C
        opponents_cooperators = sum(history.opponent_actions[-1])
        if opponents_cooperators == self.game_description.n_players:
            return Action.C
        elif opponents_cooperators == 0:
            return Action.D
        ratio = opponents_cooperators / self.game_description.n_players
        return Action.C if ratio >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_252(BaseStrategy):
    """
    A Tit-for-Tat-Growing (TfT-G) game theory strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        self.previous_opponent_action = history.opponent_actions[-1][-1] if len(history.opponent_actions) > 0 else None
        if self.previous_opponent_action is not None:
            if self.previous_opponent_action:
                return Action.C
            else:
                return Action.D
        elif history.opponent_actions[-1][0]:
            return Action.C if history.opponent_actions[0][0] else Action.D
        if state.round_number == len(history.opponent_actions):
            return Action.C

class Strategy_EXPLOITATIVE_257(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history and state.round_number == 0:
            return Action.C
        self.opponent_history = history.opponent_actions if history else np.zeros((1, self.game_description.n_players), dtype=np.bool_)
        last_round = state.round_number == self.game_description.n_rounds
        zero_stock = state.current_stock == 0
        opponent_cooperated = np.any(self.opponent_history[-1])
        if not last_round and (not zero_stock):
            action = Action.C if opponent_cooperated else Action.D
        elif not last_round or zero_stock:
            action = Action.C
        else:
            action = None
        return action

class Strategy_EXPLOITATIVE_269(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TfT-ACT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        self.current_threshold = self.initial_threshold
        self.total_depletion = 0
        self.num_rounds_to_average = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0 and history is None:
            return action
        if history is not None:
            self.total_depletion += np.sum(history.my_payoffs[self.num_rounds_to_average:-1]) / self.num_rounds_to_average
            self.current_threshold = self.initial_threshold * (1 - self.total_depletion)
        if state.current_stock <= 0:
            return action
        opponent_action = history.opponent_actions[-1, -1] if history is not None else False
        if state.current_stock >= self.current_threshold or opponent_action:
            action = Action.C
        else:
            action = Action.D
        if state.round_number == self.game_description.n_rounds:
            if history is not None and opponent_action:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_271(BaseStrategy):
    """
    A simple strategy that mimics cooperation and defection based on the opponent's last move in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        if last_round == self.game_description.n_rounds - 1:
            return Action.C
        my_last_action = history.opponent_actions[last_round, 0] if len(history.opponent_actions) > 0 else False
        return Action(my_last_action)

class Strategy_EXPLOITATIVE_294(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Stock Adjustment (TFTSA) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.D
        cooperators = sum(history.opponent_actions[-1])
        my_action = Action.C if cooperators >= self.game_description.n_players // 2 else Action.D
        if state.current_stock <= 2 * self.game_description.n_players - (self.game_description.n_players - 1):
            return my_action
        if state.current_stock >= self.game_description.n_players + 1:
            return Action.C
        return my_action

class Strategy_EXPLOITATIVE_297(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFTSA) strategy for the Common Pool Resource Game.
    Balances cooperation and punishment effectively, promoting long-term sustainability while minimizing resource depletion due to defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity * 0.75
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        average_consumption = np.mean(history.my_actions.sum(axis=0))
        if average_consumption < self.game_description.n_players / (2 * self.game_description.n_players):
            return Action.C
        if average_consumption >= self.game_description.n_players / self.game_description.n_players:
            return Action.D
        current_stock = state.current_stock
        if current_stock < self.threshold and history is not None:
            average_consumption = np.mean(history.my_actions.sum(axis=0))
            if average_consumption >= self.game_description.n_players / self.game_description.n_players:
                return Action.D
        elif current_stock >= self.threshold and history is not None:
            average_consumption = np.mean(history.my_actions.sum(axis=0))
            if average_consumption < self.game_description.n_players / (2 * self.game_description.n_players):
                return Action.C
        self.history = history
        return Action.C

class Strategy_EXPLOITATIVE_301(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TfT-ACT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = None
        self.rounds_played = 0
        self.learning_rate = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or self.rounds_played == 0:
            return Action.C
        self.rounds_played += 1
        if state.current_stock == 0:
            average_payoffs = np.mean(history.my_payoffs[:self.game_description.n_rounds // 2])
            self.cooperative_threshold = average_payoffs
            return Action.C
        if self.cooperative_threshold is None:
            self.cooperative_threshold = np.mean(history.my_payoffs[:self.game_description.n_rounds // 2])
        payoff = history.my_payoffs[-1]
        new_ct = self.cooperative_threshold + self.learning_rate * (payoff - self.cooperative_threshold)
        self.cooperative_threshold = max(0, min(new_ct, payoff))
        if payoff >= self.cooperative_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_303(BaseStrategy):
    """
    A strategy that cooperates initially and reciprocates opponent's actions,
    but switches to a more aggressive strategy when resources are scarce.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = int(game_description.capacity * 2 / 3)
        self.last_round = game_description.n_rounds - 1

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.last_round:
            return Action.C
        action = Action.C
        if state.current_stock < self.stock_threshold and history.opponent_actions[-1, -1] == Action.D:
            action = Action.D
        elif history.opponent_actions[-1, -1] == Action.C:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_330(BaseStrategy):
    """
    A Tit-for-Tat with Stock Adaptation (TS-TFt) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.m = int(game_description.n_players * 0.95)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            avg_stock = np.mean(history.my_payoffs[-self.m:])
            if avg_stock > self.game_description.capacity / (2 * self.game_description.n_players):
                return Action.D
            else:
                return Action.C
        return Action.D if state.current_stock < self.game_description.capacity / self.game_description.n_players else Action.C

class Strategy_EXPLOITATIVE_337(BaseStrategy):
    """
    The TFT-AT strategy adapts its cooperative behavior based on the opponent's past actions, becoming more uncooperative over time if the opponent is not reliable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.current_round = 0
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        else:
            self.history = history
            self.current_round = state.round_number
            cooperative_moves = sum(self.history.opponent_actions[:, -self.game_description.n_players:].flatten())
            total_moves = self.game_description.n_players * (self.current_round if self.current_round > 0 else 1)
            ratio = cooperative_moves / total_moves
            if self.current_round == self.game_description.n_rounds:
                return Action.D if ratio < 1.0 else Action.C
            action = Action.C if ratio >= self.threshold else Action.D
            self.threshold += (self.threshold - 0.5) / self.game_description.n_rounds
        return action

class Strategy_EXPLOITATIVE_338(BaseStrategy):
    """
    A strategy that plays the Common Pool Resource Game using the Tit-for-Tat with Adjustable Cooperation Threshold (TFT-ACT) approach.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = math.floor(game_description.capacity / game_description.n_players * 0.75)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        actions = np.zeros(self.game_description.n_players, dtype=np.bool_)
        payoffs = np.zeros(self.game_description.n_players, dtype=np.float64)
        for i in range(self.game_description.n_players):
            if history is None or len(history.opponent_actions) <= state.round_number:
                actions[i] = Action.C
            else:
                actions[i] = history.opponent_actions[state.round_number - 1, i]
                payoffs[i] = state.current_stock / (2 * self.game_description.n_players) if actions[i] else state.current_stock / self.game_description.n_players
        total_consumption = np.sum(payoffs)
        remaining_stock = state.current_stock - total_consumption
        growth = 2 * remaining_stock * (1 - remaining_stock / self.game_description.capacity)
        new_stock = min(self.game_description.capacity, remaining_stock + growth)
        state.current_stock = new_stock
        cooperators = sum(actions)
        if cooperators >= self.game_description.n_players // 2 or (state.current_stock < self.stock_threshold and actions[-1]):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_339(BaseStrategy):
    """
    A Tit-for-Tat strategy with stock adjustment for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 2 * game_description.n_players
        self.growth_threshold = game_description.capacity * (game_description.n_players / self.stock_threshold)
        self.last_round = game_description.n_rounds - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[-1][0] if history else None
        stock = state.current_stock
        growth = self._calculate_growth(stock) if history else None
        if (not opponent_action or opponent_action == Action.C) and stock >= self.stock_threshold:
            return Action.C
        elif opponent_action == Action.D and (stock < self.stock_threshold or growth > self.growth_threshold):
            return Action.D
        else:
            return Action.C

    def _calculate_growth(self, stock: float) -> float:
        total_consumption = self.game_description.n_players * (stock / self.game_description.capacity)
        growth = 2 * stock * (1 - stock / self.game_description.capacity) - total_consumption
        return growth if growth >= 0 else 0

class Strategy_EXPLOITATIVE_340(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TfTA)

    A strategy where in the first round, players cooperate to build a positive relationship and show good faith.
    For subsequent rounds, players analyze the opponent's strategy based on their actions from the previous round and respond accordingly:
        - If opponent cooperated, continue cooperating.
        - If opponent defected, defect in the next round to punish them for not cooperating. However, if the total stock level is below (2n - 4n)/3 after their defect, switch to cooperate to prevent further depletion of the common pool.
    In the last round, players cooperate regardless of opponent's previous action to maximize potential payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.prev_opponent_actions = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.prev_opponent_actions = np.array(history.opponent_actions[-1])
        is_last_round = state.round_number == self.game_description.n_rounds - 1
        cooperators = sum(self.prev_opponent_actions)
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        elif is_last_round:
            return Action.C
        elif state.current_stock < (self.game_description.n_players * 2 - self.game_description.n_players * 4) / 3:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_345(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Forgiveness (TFT-AF) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defects = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        round_number = state.round_number - 1 if history else 0
        if round_number == self.game_description.n_rounds - 1:
            return Action.C
        opponent_action = history.opponent_actions[round_number, 0] if not history else history.opponent_actions[-1, 0]
        if opponent_action == Action.D and round_number > 0:
            self.opponent_defects += 1
            return Action.D
        elif opponent_action == Action.C:
            return Action.C
        elif self.opponent_defects > self.game_description.n_players // 2:
            return Action.D
        else:
            self.opponent_defects = 0
            return Action.C

class Strategy_EXPLOITATIVE_355(BaseStrategy):
    """
    Tit-for-Tat-Greed (TfTG) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_stock_depletion_threshold = 2 * self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            action = Action.C if state.current_stock >= self.initial_stock_depletion_threshold else Action.D
        else:
            avg_consumption = np.mean(history.opponent_actions[:, -1]) * self.game_description.n_players
            if state.round_number < self.game_description.n_rounds or history.my_payoffs[-1] > 0:
                action = Action.C if avg_consumption < state.current_stock else Action.D
            else:
                action = Action.C if state.current_stock > 0 else Action.C
        return action

class Strategy_EXPLOITATIVE_356(BaseStrategy):
    """
    The Tit-for-Tat with Adaptive Cooperation (TfT-AC) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.forgiveness_window = 2 * self.n - 1
        self.cooperation_streak = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history else np.zeros(self.n, dtype=np.bool_)
        last_opponent_action = opponent_actions[-1]
        if last_opponent_action == 0:
            self.cooperation_streak = max(0, self.cooperation_streak - 1)
            return Action.D
        elif state.round_number >= len(opponent_actions) and self.cooperation_streak > 0:
            return Action.D
        elif last_opponent_action == 1:
            self.cooperation_streak += 1
        else:
            self.cooperation_streak = max(0, self.cooperation_streak - 1)
        return Action.C if self.cooperation_streak >= self.n - 1 else Action.D

class Strategy_EXPLOITATIVE_361(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game.
    This strategy cooperates initially, responds to cooperation with cooperation, and defects unless the stock level is above a certain threshold or an opponent consistently cooperates. The cooperation threshold adapts over time based on the average cooperation of opponents in the recent past.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.recent_history_length = int(math.ceil(game_description.n_rounds * 0.1))
        self.average_cooperation = np.zeros((self.recent_history_length,))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock
        if stock_level <= 0:
            return Action.D
        if history.opponent_actions is None:
            return Action.C
        num_rounds = len(history.opponent_actions)
        recent_cooperators = sum(history.opponent_actions[-self.recent_history_length:, :].flatten())
        self.average_cooperation = np.roll(self.average_cooperation, -1)
        self.average_cooperation[-1] = recent_cooperators / self.recent_history_length
        cooperation_threshold = np.interp(np.mean(self.average_cooperation), (0, 1), (0, 1))
        if stock_level > self.game_description.capacity * cooperation_threshold:
            return Action.C
        elif cooperation_threshold < 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_369(BaseStrategy):
    """
    Freeloader-TitForTat-Growth (FTFG) strategy for the Common Pool Resource Game.
    This strategy starts by cooperating, incentivizes cooperation when others conserve resources, and defects when opponents deplete the common pool excessively.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.empty((1,), dtype=bool), my_payoffs=np.array([]), opponent_actions=np.empty((0, self.game_description.n_players), dtype=bool), opponent_payoffs=np.array([]))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is not None and len(history.opponent_actions) >= self.game_description.n_players * (self.game_description.n_rounds - 1):
            avg_consumption = np.mean([sum(row) for row in history.opponent_actions[-self.game_description.n_rounds + 1:-1, :]])
        else:
            avg_consumption = np.nan
        action = Action.C if state.round_number == 0 or math.isnan(avg_consumption) else Action.C if avg_consumption < (self.game_description.n_players - 1) * self.game_description.capacity / (2 * self.game_description.n_players) else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        self.history = history or PlayerHistory(my_actions=np.vstack([self.history.my_actions, np.array([action])]), my_payoffs=np.concatenate([self.history.my_payoffs, [state.current_stock / (2 * self.game_description.n_players if action == Action.C else state.current_stock / self.game_description.n_players)]]), opponent_actions=np.vstack([self.history.opponent_actions, history.opponent_actions if history is not None else np.empty((state.round_number + 1, self.game_description.n_players), dtype=bool)]), opponent_payoffs=np.concatenate([self.history.opponent_payoffs, history.opponent_payoffs if history is not None else np.array([])]))
        return action

class Strategy_EXPLOITATIVE_372(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATfT) for Common Pool Resource Game

    Summary: This strategy cooperates initially to encourage cooperation and then adapts its response based on an opponent's behavior and the number of remaining rounds. It punishes defection either short-term or long-term, making it robust and potentially exploitative.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r_threshold = math.floor(self.game_description.n_rounds * 0.7)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        opponent_actions = history.opponent_actions[-1] if history is not None else np.full(self.game_description.n_players, False)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif current_stock <= 0:
            return Action.C
        elif history is None:
            return Action.C
        opponent_last_action = opponent_actions[-1]
        if state.round_number < self.r_threshold:
            if opponent_last_action:
                return Action.C
            else:
                return Action.D
        elif state.round_number >= self.r_threshold and current_stock > 0:
            if opponent_last_action:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_380(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.own_action_history = []
        self.opponent_action_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.own_action_history += [bool(action) for action in history.my_actions]
            self.opponent_action_history += history.opponent_actions.T.flatten().tolist()
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.C
        current_action = self.opponent_action_history[-1]
        return Action(int(current_action == Action.C))

class Strategy_EXPLOITATIVE_385(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_threshold = game_description.capacity * 0.95
        self.multiplier = 0.1
        self.aggressiveness_level = 1.0
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == len(history.opponent_actions) - 1:
            average_consumption = np.mean([row.sum() for row in history.opponent_payoffs[-1]])
            cooperation_threshold = self.initial_threshold + average_consumption * self.multiplier
            if state.current_stock > cooperation_threshold:
                return Action.C
            else:
                return Action.D
        else:
            current_stock = state.current_stock
            avg_consumption = np.mean([row.sum() for row in history.opponent_payoffs])
            cooperation_threshold = self.initial_threshold + avg_consumption * self.multiplier
            if current_stock > cooperation_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_394(BaseStrategy):
    """
    A Tit-for-Tat-Adaptive (TFTA) strategy for the Common Pool Resource Game.
    This strategy cooperates initially to foster a cooperative environment, and then follows the TFTA rules in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros(game_description.n_rounds, dtype=bool), np.zeros(game_description.n_rounds), np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), np.zeros(game_description.n_rounds))

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        if state.round_number == 0:
            self.history.my_actions[0] = True
        else:
            opponent_cooperators = sum(history.opponent_actions[-1])
            self.history.my_actions[state.round_number] = opponent_cooperators > (self.game_description.n_players - 1) // 2
        return Action(int(self.history.my_actions[-1]))

class Strategy_EXPLOITATIVE_400(BaseStrategy):
    """
    Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    This strategy encourages cooperation and punishes defections effectively.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._prev_cooperative_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperated = np.any(history.opponent_actions[:, -1]) if history else False
        my_cooperative_rounds = np.count_nonzero(history.my_actions) if history else 0
        previous_round_cooperation = my_cooperative_rounds > self._prev_cooperative_rounds if history else False
        if opponent_cooperated and previous_round_cooperation:
            self._prev_cooperative_rounds += 1
            return Action.C
        elif opponent_cooperated:
            self._prev_cooperative_rounds = 0
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_403(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold Strategy
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.history = None
        self.current_round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if self.history is None:
            self.history = PlayerHistory(np.zeros(self.game_description.n_rounds, dtype=bool), np.zeros(self.game_description.n_rounds), np.zeros((self.game_description.n_rounds, self.game_description.n_players), dtype=bool), np.zeros(self.game_description.n_rounds))
            self.current_round += 1
            return Action.C
        if history is None:
            self.history = history
            self.current_round += 1
            return self.history.opponent_actions[-1][-1]
        self.history.my_actions[self.current_round - 1] = self.__class__.__name__ == history.my_actions[-1]
        self.history.my_payoffs[self.current_round - 1] = state.current_stock / (2 * self.game_description.n_players) if self.history.my_actions[-1] else state.current_stock / self.game_description.n_players
        self.current_round += 1
        cooperation_level = sum(self.history.opponent_actions[:, -1]) / self.current_round
        self.cooperation_threshold = max(min(cooperation_level * 0.8, 1), min(cooperation_level * 0.2, 0))
        if self.current_round == self.game_description.n_rounds:
            return Action.C
        if self.current_round == 1:
            return Action.C
        if cooperation_level > self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_417(BaseStrategy):
    """
    Tit-for-Tat Strategy with Adaptive Cooperation Threshold (TFTC) for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.n_players // 2
        self.deviation_margin = int(0.1 * game_description.n_players)
        self.initial_round = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C if self.initial_round else Action.D
        self.update_threshold(history)
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        opponent_cooperation_rate = sum(history.opponent_actions[-1, :]) / len(history.opponent_actions[-1, :])
        if opponent_cooperation_rate > self.cooperation_threshold + self.deviation_margin:
            return Action.C
        return Action.D

    def update_threshold(self, history):
        cooperative_actions = sum(history.my_actions)
        total_rounds = len(history.my_payoffs)
        if total_rounds == 1:
            self.cooperation_threshold = math.ceil(0.5 * (cooperative_actions / total_rounds + self.cooperation_threshold))
        elif cooperative_actions > self.cooperation_threshold * total_rounds and self.initial_round:
            self.cooperation_threshold = math.floor((cooperative_actions / total_rounds + self.cooperation_threshold) * 1.05)
        self.initial_round = False

class Strategy_EXPLOITATIVE_419(BaseStrategy):
    """
    A strategy based on Tit-for-Tat, where players cooperate in the first round and subsequently respond to their opponent's previous move. The strategy will cooperate if the opponent cooperated last round, otherwise defect. In the last round, it always cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.strategy_name = self.__class__.__name__

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0 or (round_number < self.game_description.n_rounds - 1 and history is not None):
            return Action.C
        if round_number == self.game_description.n_rounds - 1:
            return Action.C
        if history is None or len(history) < round_number:
            return Action.C
        opponent_action = history.opponent_actions[round_number - 1, 0]
        return Action(int(opponent_action))

class Strategy_EXPLOITATIVE_432(BaseStrategy):
    """
    A strategy that cooperates in the first round and adapts its defection threshold based on opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_threshold = self.game_description.n_players // 2
        self.current_round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or self.current_round == 0:
            return Action.C
        self.current_round = state.round_number
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if opponent_cooperators == self.game_description.n_players:
            self.defection_threshold -= 0.01
        elif opponent_cooperators + 1 < self.game_description.n_players - opponent_cooperators:
            self.defection_threshold += 0.01
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D if self.defection_threshold >= self.game_description.n_players else Action.C
        return Action(int((self.defection_threshold > len(history.opponent_actions) - opponent_cooperators) * 2 - 1))

class Strategy_EXPLOITATIVE_433(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive forgiveness for the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_count = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if len(history.opponent_actions) > 1 and state.round_number < self.game_description.n_rounds - 1:
            cooperators = sum(history.opponent_actions[-2, :])
            last_action = history.opponent_actions[-1][0]
            if last_action == Action.C and cooperators >= self.game_description.n_players // 2:
                return Action.C
            elif last_action == Action.D and cooperators < self.game_description.n_players // 2:
                self.defection_count += 1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif self.defection_count >= self.game_description.n_players // 2:
            return Action.D
        else:
            self.defection_count = 0
            return Action.D

class Strategy_EXPLOITATIVE_440(BaseStrategy):
    """
    TFTAR strategy for the Common Pool Resource Game.
    Demonstrates cooperative behavior at first and adapts based on opponent actions.
    Implemented with forgiveness mechanism and exploitative mindset.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_threshold = int(game_description.n_players * 0.3)
        self.current_opponent_strategy = None
        self.consecutive_defections = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if self.current_opponent_strategy is None and cooperators >= self.game_description.n_players // 2:
            self.current_opponent_strategy = 'cooperative'
        elif self.current_opponent_strategy is not None and cooperators < self.game_description.n_players // 2:
            self.current_opponent_strategy = 'defective'
        if self.current_opponent_strategy == 'cooperative':
            return Action.C
        elif self.current_opponent_strategy == 'defective':
            if history.my_actions[-1] == Action.C:
                self.consecutive_defections = 0
                return Action.D
            elif history.my_actions[-1] == Action.D and self.consecutive_defections < self.forgiveness_threshold:
                self.consecutive_defections += 1
            else:
                self.consecutive_defections = 0
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_446(BaseStrategy):
    """
    A game theory strategy that implements the Tit-for-Tat-Greed (TFTG) strategy in the Common Pool Resource Game.
    The TFTG strategy cooperates initially and punishes excessive consumption, encouraging conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainable_rate = 2 * self.game_description.n_players
        self.state = None
        self.history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.state = state
            return Action.C
        self.history = history
        self.state = state
        own_action = self.history.my_actions[-1] if self.state.round_number != 0 else None
        total_consumption = np.sum(self.history.opponent_actions[:, -1])
        opponents_average = np.mean(self.history.opponent_actions[:, :-1]).item()
        if own_action is None or self.state.round_number == self.game_description.n_rounds - 1:
            current_consumption = (own_action + total_consumption) / self.game_description.n_players
            if current_consumption > self.sustainable_rate or total_consumption > self.game_description.n_players * self.sustainable_rate:
                return Action.D
            elif opponents_average > self.sustainable_rate:
                return Action.D
            else:
                return Action.C
        elif total_consumption >= self.game_description.n_players * self.state.current_stock and self.state.round_number != 1:
            return Action.D
        else:
            return Action.C if total_consumption <= self.game_description.n_players * self.state.current_stock * (1 - self.state.current_stock / self.game_description.capacity) else Action.D

class Strategy_EXPLOITATIVE_451(BaseStrategy):
    """
    A Tit-for-Tat strategy for the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.C
        if state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[-1, 0]
        return Action(int(not opponent_action))

class Strategy_EXPLOITATIVE_468(BaseStrategy):
    """
    Tit-for-Tat with Punishment (TfTp) strategy for the Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity / game_description.n_players
        self.last_round = False
        self.punishment_round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        total_consumption_previous_round = np.sum(history.opponent_actions[-1])
        current_stock_previous_round = state.current_stock - total_consumption_previous_round
        if total_consumption_previous_round > self.capacity or current_stock_previous_round <= 0:
            self.punishment_round += 1
            return Action.D
        if self.punishment_round >= self.game_description.n_rounds - 1 and state.round_number != self.game_description.n_rounds - 1:
            self.last_round = True
        cooperators = np.count_nonzero(history.opponent_actions[-1])
        if cooperators >= self.game_description.n_players // 2 and (not self.last_round):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_486(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) Strategy for Common Pool Resource Game.
    This strategy cooperates initially, then responds to opponent's actions in the previous round.
    If an opponent has defected, it will retaliate with a prolonged period of punishment before resuming cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = None
        self.punishing_phase = False
        self.punishment_counter = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not history and state.round_number > 0:
            return Action.C
        self.opponent_history = history.opponent_actions if history else np.zeros((state.round_number + 1, self.game_description.n_players), dtype=np.bool_)
        action = None
        if state.round_number == 0:
            action = Action.C
        elif state.round_number < self.game_description.n_rounds and np.count_nonzero(self.opponent_history[-1, :]) == self.game_description.n_players // 2:
            action = Action.C
        elif state.round_number < self.game_description.n_rounds:
            if self.opponent_history[-1][-1] == True:
                action = Action.C
            else:
                action = Action.D
        elif state.round_number >= self.game_description.n_rounds or (self.punishing_phase and self.punishment_counter < self.game_description.n_players):
            action = Action.C
        elif np.all(self.opponent_history[-self.game_description.n_players - 1:-1] == np.fliplr([False] * self.game_description.n_players)) and np.all(self.opponent_history[-self.game_description.n_players:] == [True] * self.game_description.n_players):
            self.punishing_phase = True
            self.punishment_counter = 0
        elif self.punishing_phase:
            self.punishment_counter += 1
        return action

class Strategy_EXPLOITATIVE_500(BaseStrategy):
    """
    A strategy that follows Tit-for-Tat with Stock Adaptation in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_sustainable = min(game_description.capacity, 2 * game_description.n_players)
        self.forgiveness_period = math.ceil(self.min_sustainable / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        recent_history = history.opponent_actions[-self.forgiveness_period:]
        cooperators = sum(recent_history[:, -1])
        if current_stock >= self.min_sustainable:
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        elif np.count_nonzero(recent_history) < self.game_description.n_players - 1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_507(BaseStrategy):
    """
    Tit-for-Tat Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_period = int(game_description.n_players // 5)
        self.critical_threshold = game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_history = len(history.opponent_actions) - 1
        if last_history < self.forgiveness_period:
            forgiveness_remaining = self.forgiveness_period - last_history
        else:
            forgiveness_remaining = 0
        last_cooperation = np.sum(history.opponent_actions[-1]) >= self.game_description.n_players // 2
        cooperation_bonus = last_cooperation and forgiveness_remaining > 0
        current_stock = state.current_stock
        if current_stock < self.critical_threshold:
            return Action.D
        return (Action.C if cooperation_bonus else Action.D) if history is not None else Action.C

class Strategy_EXPLOITATIVE_513(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number < self.game_description.n_rounds:
            last_round = len(self.opponent_history) - 1
            if last_round >= 0:
                last_action = self.opponent_history[-1][-1]
                if last_action == Action.C:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.C
        else:
            return Action.D

    def update_opponent_history(self, opponent_action: bool):
        self.opponent_history.append([opponent_action])

class Strategy_EXPLOITATIVE_514(BaseStrategy):
    """
    Strategy that mimics Tit for Tat with a greedy approach to resource collection in later stages of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.remaining_rounds = game_description.n_rounds - 1
        self.threshold_stock = 2 * (self.remaining_rounds - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = np.mean(history.opponent_actions[-1]) if history is not None else None
        current_stock = state.current_stock if history is not None else self.game_description.capacity
        if state.round_number == self.remaining_rounds:
            return Action.C
        if opponent_action is not None and opponent_action:
            return Action.C
        elif opponent_action is not None and (not opponent_action) and (current_stock < self.threshold_stock):
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_515(BaseStrategy):
    """
    A Tit-for-Tat-Plus strategy that initially cooperates to allow the common pool resource to grow, then switches to a more exploitative behavior when the resource is abundant. If an opponent ever defects, the strategy will retaliate with defection until the opponent returns to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_period = int(math.ceil(game_description.n_rounds / 3))
        self.past_cooperation = [False] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock / self.game_description.n_players
        if current_stock > self.game_description.capacity / self.game_description.n_players:
            return Action.D
        if history:
            for opponent, action in enumerate(history.opponent_actions[-1]):
                if not self.past_cooperation[opponent]:
                    self.past_cooperation[opponent] = action
                if action == Action.D and self.past_cooperation[opponent]:
                    return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_516(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Adaptation (TfTSA)

    This strategy cooperates in the first round, and adapts its actions based on the opponent's behavior.
    If the opponent cooperated in the last round, it reciprocates with cooperation. If the opponent defected,
    it penalizes the opponent for not cooperating. In case of stock depletion (stock = 0), TfTSA will continue defecting until the stock grows beyond the minimum sustainable level (2n).
    Once that happens, it will start evaluating the opponent's actions again as described above.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_stock = 2 * game_description.n_players
        self.current_round = 0
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        self.current_round = state.round_number
        if not history or self.current_round == 0:
            return Action.C
        opponent_cooperators = np.sum(history.opponent_actions[-1])
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        if state.current_stock == 0 and self.current_round < self.game_description.n_rounds:
            return Action.D
        if self.current_round == self.game_description.n_rounds - 1 and state.current_stock == 0:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_517(BaseStrategy):
    """
    A strategy named Tit-for-Tat-Growth (TfT-G) for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_per_player = self.game_description.capacity // self.game_description.n_players
        self.threshold = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = np.sum(history.my_actions[-1]) * self.capacity_per_player if history is not None else 0
        if total_consumption < (self.game_description.n_rounds - state.round_number) * (self.capacity_per_player / 2):
            return Action.C if np.sum(history.opponent_payoffs[-1]) > 0 else Action.D
        elif total_consumption >= (self.game_description.n_rounds - state.round_number) * self.capacity_per_player:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_518(BaseStrategy):
    """
    A Tit-for-Tat Strategy for the Common Pool Resource Game.
    This strategy cooperates initially and then reciprocates the opponent's actions in subsequent rounds.
    It punishes overconsumption by defecting, making opponents suffer a lower payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if not history:
            return Action.C
        current_round = state.round_number - 1 if self.last_round else state.round_number
        last_opponent_action = history.opponent_actions[-current_round, 0]
        if self.last_round and state.current_stock < self.game_description.capacity / self.game_description.n_players:
            return Action.D
        elif last_opponent_action:
            return Action.C
        else:
            return Action.D

    def update(self, new_round_history: PlayerHistory):
        self.last_round = self.game_description.n_rounds - 1 if new_round_history.round_number == self.game_description.n_rounds else None

class Strategy_EXPLOITATIVE_519(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFT-SA) strategy for the Common Pool Resource Game.
    This strategy cooperates initially and retaliates against uncooperative opponents while adapting its behavior based on the depletion of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = game_description.capacity // 2
        self.accumulated_consumption = 0
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0:
            action = Action.C
        else:
            if not history:
                return Action.C
            opponent_action = history.opponent_actions[-1, 0]
            self.last_opponent_action = opponent_action
            if self.accumulated_consumption < self.game_description.capacity * 0.8:
                action = Action.D if not opponent_action else Action.C
            elif self.accumulated_consumption >= self.game_description.capacity * 0.95:
                action = Action.C
            else:
                action = Action.D if not opponent_action else Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock < self.game_description.capacity * self.critical_threshold:
                action = Action.D
        self.accumulated_consumption += state.current_stock - history.my_payoffs[-1] if history else state.current_stock
        return action

class Strategy_EXPLOITATIVE_520(BaseStrategy):
    """
    A strategy that cooperates initially and responds to opponents' behavior using an adaptive cooperative threshold (CT).
    The CT is adjusted dynamically, encouraging cooperation with consistent partners and punishing non-cooperative ones.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_round = 0
        self.ct_len = math.ceil(game_description.n_players / 2)
        self.minimum_ct_len = int(math.ceil(game_description.n_players / 4))
        self.maximum_ct_len = game_description.n_rounds
        self.growth_factor = 1.5
        self.decay_factor = 0.75
        self.forgiveness_factor = 3
        self.history = PlayerHistory(my_actions=np.zeros((game_description.n_rounds,), dtype=np.bool_), my_payoffs=np.zeros((game_description.n_rounds,), dtype=np.float64), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=np.bool_), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=np.float64))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        self.current_round = state.round_number
        if not history:
            return Action.C
        if self.current_round < self.ct_len:
            return Action.C
        elif np.sum(history.opponent_actions[-self.ct_len:, :]) > self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D
        if self.current_round >= self.ct_len:
            if np.sum(history.opponent_actions[-self.ct_len:, :]) > self.game_description.n_players // 2:
                self.ct_len = min(self.ct_len * self.growth_factor, self.maximum_ct_len)
            else:
                self.ct_len = max(self.ct_len / self.decay_factor, self.minimum_ct_len)

class Strategy_EXPLOITATIVE_521(BaseStrategy):
    """
    Title: Tit-for-Tat with Adaptive Cooperation (TFTA) Strategy for the Common Pool Resource Game

    This strategy follows a tit-for-tat behavior: if an opponent cooperates, it also cooperates; if an opponent defects, it defects in the next round. It aims to encourage cooperation while retaliating against defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = history.opponent_actions[-1] if history is not None else np.zeros(self.game_description.n_players, dtype=np.bool_)
        my_history = history.my_actions if history is not None else np.zeros(state.round_number, dtype=np.bool_)
        defectors = sum(last_round) - sum(my_history > state.round_number - 1)
        if defectors >= self.game_description.n_players // 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_522(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Threshold (TFT-CT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ct = 0.0
        self.rounds_below_ct = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.rounds_below_ct >= self.game_description.n_rounds:
            self.ct = np.mean(history.current_stock[self.rounds_below_ct].reshape(-1))
            self.rounds_below_ct = 0
        if state.current_stock < self.ct:
            return Action.D
        return Action.C

    def update(self, new_history: PlayerHistory):
        """
        Update TFT-CT strategy with the provided history of past actions and payoffs.
        """
        if new_history.my_actions[-1] == Action.D and state.current_stock < self.game_description.capacity:
            self.rounds_below_ct += 1

class Strategy_EXPLOITATIVE_523(BaseStrategy):
    """
    A Tit-for-Tat strategy with a slight modification for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or len(history.my_actions) == 0:
            return Action.C
        cooperator = bool(history.my_actions[-1])
        return Action(cooperator) if state.round_number > 0 else Action.C

class Strategy_EXPLOITATIVE_524(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1] if history else np.zeros(self.game_description.n_players)
        payoffs = history.opponent_payoffs[-1] if history else np.zeros(self.game_description.n_players)
        last_round_cooperators = sum(opponent_actions)
        if state.round_number == self.game_description.n_rounds:
            action = Action.D if last_round_cooperators < self.game_description.n_players - 1 else Action.C
        else:
            action = Action.C if opponent_actions[-1] == Action.C else Action.D
        self.opponent_history.append(opponent_actions[-1])
        return action

class Strategy_EXPLOITATIVE_525(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-CT) Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.min_stock = 2 * self.n_players
        self.average_cooperation_threshold = 0.6
        self.history = PlayerHistory(my_actions=np.zeros((self.n_rounds,), dtype=bool), my_payoffs=np.zeros((self.n_rounds,), dtype=float), opponent_actions=np.zeros((self.n_rounds, self.n_players), dtype=bool), opponent_payoffs=np.zeros((self.n_rounds, self.n_players), dtype=float))

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None):
        if history is None:
            history = self.history
        if state.round_number == 0:
            return Action.C
        n_cooperators = np.sum(history.opponent_actions[:, :self.n_players // 2])
        t = self.average_cooperation_threshold + n_cooperators / self.n_players * 0.4
        t = max(min(t, 1), 0.3)
        current_stock = state.current_stock
        if current_stock < self.min_stock:
            return Action.D
        average_cooperation_rate = np.mean(history.my_actions[-self.n_players:])
        if average_cooperation_rate > t:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_527(BaseStrategy):
    """
    A Tit-for-Tat-Growing (TfT-G) strategy for the Common Pool Resource Game.
    The strategy cooperates initially and imitates opponents' actions in subsequent rounds, with a growing cooperation probability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_bonus = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        last_cooperation = sum(opponent_actions)
        self.cooperation_bonus = min(state.round_number, last_cooperation) * 0.1
        if self.cooperation_bonus > 1:
            self.cooperation_bonus = 1
        if np.any(opponent_actions == Action.C):
            return Action.C + self.cooperation_bonus
        return Action.D

class Strategy_EXPLOITATIVE_528(BaseStrategy):
    """
    Implementation of the Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.history = history if history is not None else self.history
        if state.round_number == 0 or (state.round_number > 0 and history is None):
            return Action.C
        if self.history.opponent_actions[-1, -1] == Action.C:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action.C

class Strategy_EXPLOITATIVE_529(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TfT-AC)
    A strategy that cooperates initially, then responds to opponents' actions while adapting to maximize payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.history = None
        self.num_rounds = 0
        self.forgiveness_sequence_length = math.ceil(self.n / 2)
        self.cooperative_average_payoff = np.zeros(self.game_description.n_rounds)
        self.defective_average_payoff = np.zeros(self.game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        self.num_rounds += 1
        self.history = history
        if self.num_rounds < self.game_description.n_rounds:
            self.cooperative_average_payoff[:self.num_rounds] = 0
            self.defective_average_payoff[:self.num_rounds] = 0
        if state.round_number == 0:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1])
        if opponent_cooperators >= self.n // 2:
            if history.my_actions[-1]:
                return Action.C
            elif self._average_payoff(self.cooperative_average_payoff) > self._average_payoff(self.defective_average_payoff):
                return Action.C
        if not history.my_actions[-1]:
            if opponent_cooperators == 0:
                return Action.D
            elif self.num_rounds >= self.forgiveness_sequence_length + (self.n - opponent_cooperators):
                return Action.C
        return Action.D

    def _average_payoff(self, payoffs: NDArray[np.float64]):
        if self.num_rounds < self.game_description.n_rounds:
            return np.mean(payoffs[:self.num_rounds])
        else:
            return np.mean(payoffs[-self.game_description.n_rounds:])

class Strategy_EXPLOITATIVE_530(BaseStrategy):
    """
    Implementation of Tit-for-Tat with Adaptive Forgiveness strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_window = int(self.game_description.n_players * self.game_description.n_rounds * 0.3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[state.round_number - 1][0] if history else Action.C
        current_round = min(state.round_number, self.game_description.n_rounds)
        if current_round >= self.forgiveness_window:
            punishment_threshold = self.game_description.capacity * 0.8
            stock_depletion = history.my_payoffs[:current_round].sum() / self.game_description.capacity
            if stock_depletion > punishment_threshold and opponent_action == Action.C:
                return Action.D
        if opponent_action == Action.C:
            return Action.C
        elif opponent_action == Action.D and current_round >= self.forgiveness_window:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_531(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat (ATFT) strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.stock_zero = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) <= 1:
            self.last_opponent_action = None
            self.stock_zero = False
            return Action.C
        self.last_opponent_action = history.opponent_actions[-1][-1]
        if state.round_number == len(history.opponent_payoffs) and self.stock_zero:
            return Action.C
        if state.current_stock > 0:
            if self.last_opponent_action is not None and self.last_opponent_action == Action.C:
                return Action.C
            elif self.last_opponent_action is not None and self.last_opponent_action == Action.D:
                return Action.D
            elif not self.stock_zero:
                self.stock_zero = True
                return Action.D
            else:
                return Action.C
        elif not self.stock_zero:
            self.stock_zero = True
            return Action.D

class Strategy_EXPLOITATIVE_532(BaseStrategy):
    """
    A Tit-for-Tat exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperated_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_cooperated_last_round = np.any(history.opponent_actions[-1])
        if state.round_number < self.game_description.n_rounds and self.opponent_cooperated_last_round:
            return Action.C
        elif state.round_number < self.game_description.n_rounds:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_533(BaseStrategy):
    """
    Strategy Title: Tit-for-Tat-Greed (TfT-Greed) Strategy for Common Pool Resource Game
    Strategy Description: A cooperative strategy that punishes opponents who do not reciprocate cooperation, while exploiting them when needed.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history and state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        cooperators, defectors = (0, 0)
        for i in range(self.n):
            if sum(history.opponent_actions[:, i][-i - 1::-1]) > sum(history.opponent_actions[:, i][-i:]):
                cooperators += 1
            else:
                defectors += 1
        if cooperators > defectors:
            return Action.C
        return Action.D if state.round_number == self.game_description.n_rounds - 1 else Action.D

class Strategy_EXPLOITATIVE_534(BaseStrategy):
    """
    TFT-ACT strategy for Common Pool Resource Game. A cooperative Tit-for-Tat strategy with an adaptive cooperation threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.0
        self.rounds_counted = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number > self.game_description.n_players * (self.game_description.n_rounds // (2 * self.game_description.n_players)):
            self.threshold = self.threshold
        else:
            self.threshold = min(state.round_number * self.game_description.capacity / (2 * self.game_description.n_players), self.game_description.capacity / self.game_description.n_players)
            self.rounds_counted = 0
        if history:
            total_consumption = np.sum(history.my_actions * (self.game_description.n_players / state.current_stock))
            self.rounds_counted += 1
        else:
            total_consumption = 0
            self.rounds_counted = 1
        if total_consumption <= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_536(BaseStrategy):
    """
    A Tit-for-Tat strategy that takes into account stock growth in a Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.own_actions_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        last_two_own_actions = self.own_actions_history[-2:]
        own_last_action = last_two_own_actions[1] if len(last_two_own_actions) > 1 else None
        opponent_last_action = history.opponent_actions[-1, 0]
        if own_last_action == Action.C and opponent_last_action:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_537(BaseStrategy):
    """
    Tit-for-Tat-Greedy (TFT-G) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history and history.opponent_actions is not None:
            average_consumption = np.mean(history.opponent_actions[:, -self.n_rounds:].sum(axis=1))
            consumption_per_player = 2 * self.n_players / self.n_rounds
            if average_consumption < consumption_per_player:
                return Action.C
            elif average_consumption >= consumption_per_player:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_538(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperative Threshold (TFT-ACT) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = self.game_description.n_players * self.game_description.capacity / (self.game_description.n_rounds * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = np.sum(history.my_actions) * self.game_description.capacity / self.game_description.n_players
        if total_consumption <= self.average_consumption * self.game_description.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_539(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Depletion Awareness (ATFT-SDA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = int(math.ceil(game_description.n_players * 0.6))
        self.defective_threshold = int(math.floor(game_description.capacity / game_description.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        stock = state.current_stock
        if stock > self.game_description.capacity - self.game_description.n_players:
            return Action.C
        elif stock < self.game_description.capacity / self.game_description.n_players:
            return Action.D
        if history is None:
            return random.choice([Action.C, Action.D])
        opponent_history = history.opponent_actions[-1]
        num_cooperators = np.count_nonzero(opponent_history)
        num_defectors = len(opponent_history) - num_cooperators
        if num_cooperators >= self.cooperative_threshold:
            return Action.C
        elif num_defectors >= self.defective_threshold:
            return Action.D
        return random.choice([Action.C, Action.D])

class Strategy_EXPLOITATIVE_540(BaseStrategy):
    """
    Tit-for-Tat with Stock Adaptation (TFTSA) strategy for the Common Pool Resource Game.
    This strategy balances cooperation and defection while adapting to the state of the game and opponent's behaviour.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_phase_threshold = math.floor(self.game_description.capacity * (self.game_description.n_players - 1) * 0.6 / self.game_description.n_players)
        self.defensive_phase_threshold = math.floor(self.game_description.capacity * (self.game_description.n_players - 1) * 0.4 / self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_behavior = np.mean(history.opponent_actions[:, -1]) if history is not None else None
        if opponent_behavior is None:
            return Action.C
        stock = state.current_stock
        if opponent_behavior > 0.5 and stock > self.defensive_phase_threshold:
            return Action.C
        elif opponent_behavior <= 0.5 and stock > self.cooperative_phase_threshold:
            return Action.D
        elif stock <= self.defensive_phase_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_541(BaseStrategy):
    """
    Implementation of the Tit-for-Tat strategy for Common Pool Resource Game.
    This strategy cooperates initially, then mimics opponent's previous action in subsequent rounds,
    and punishes defection through retaliation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperate_count = 0
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            self.opponent_history.append(history is not None and history.opponent_actions[-1].sum() > 0)
            action = Action.C if len(self.opponent_history) < self.game_description.n_rounds or not self.opponent_history[-1] else self.opponent_history[-2]
        if state.round_number == self.game_description.n_rounds:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_544(BaseStrategy):
    """
    Tit-for-Tat-Growing (TfTG) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity - game_description.n_players * 2
        self.threshold /= game_description.capacity
        self.threshold -= 0.1 / game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_last_move = history.opponent_actions[-1][-1] if history else None
        if opponent_last_move is None:
            return Action.C
        if opponent_last_move == Action.C and state.current_stock > 0:
            return Action.C
        elif opponent_last_move == Action.D or state.current_stock == 0:
            return Action.D
        return Action.C if state.current_stock / self.game_description.capacity > self.threshold else Action.D

class Strategy_EXPLOITATIVE_545(BaseStrategy):
    """
    The Tit-for-Tat Plus (TfT+) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_duration = int(game_description.n_players * 0.5)

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        opponent_average = np.mean(history.opponent_actions[:, :state.round_number], axis=1) > 0.5
        if all((opponent_action == 1 for opponent_action in opponent_average)):
            return Action.C
        if any((opponent_action == 0 for opponent_action in opponent_average)):
            punishment_duration = min(self.punishment_duration, state.round_number - 1)
            return Action.D
        if state.round_number - punishment_duration >= self.game_description.n_rounds:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_546(BaseStrategy):
    """Fictitious Play with Adaptive Responses (FPAR) Strategy"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.epsilon = 0.1
        self.history = PlayerHistory(np.zeros((1,), dtype=bool), np.zeros((1,)), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros((1, self.game_description.n_players)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.history = history
        if state.round_number > 0:
            total_consumption = np.sum(self.history.opponent_actions[:, :-1].flatten())
            average_consumption = total_consumption / (state.round_number * self.game_description.n_players)
        if average_consumption <= self.game_description.capacity / (2 * self.game_description.n_players) - self.epsilon:
            action = Action.C
        elif average_consumption >= self.game_description.capacity / (2 * self.game_description.n_players) + self.epsilon:
            action = Action.D
        else:
            action = self.__choose_action()
        return action

    def __choose_action(self) -> Action:
        pass

class Strategy_EXPLOITATIVE_548(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Stock Adaptation (TfTSA) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_limit = 2 * game_description.n_players // 3 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            opponent_action_previous = history.opponent_actions[-1][-1]
            action = Action.C if opponent_action_previous == Action.C else Action.D
            if state.round_number < self.game_description.n_rounds - 1:
                if state.current_stock < self.critical_limit:
                    return Action.D
            elif opponent_action_previous == Action.D and state.current_stock >= self.critical_limit:
                return Action.C
        return action

class Strategy_EXPLOITATIVE_549(BaseStrategy):
    """
    The Tit-for-Tat strategy for the Common Pool Resource Game.
    Based on reciprocity, it cooperates if the opponent did in the previous round, otherwise defects as punishment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        previous_action = Action(int(history.my_actions[-1] if history else [0][0]))
        if previous_action == Action.C:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_550(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Adaptation (TFTSA)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity
        self.n_players = self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if history is not None and history.opponent_actions[-1].all():
            return Action.C
        elif any(history.opponent_actions[-1, :]):
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_551(BaseStrategy):
    """
    Strategy Name: Adaptive Tit-for-Tat (ATFT)
    Strategy Description: A cooperative strategy that retaliates when opponents defect, while helping to restore the resource pool when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = math.floor(game_description.capacity / (2 * game_description.n_players))
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None and state.round_number == 0:
            return Action.C
        self.history = history
        current_round = len(self.history.my_actions) - 1
        last_opponent_action = self.history.opponent_actions[current_round, (self.history.my_actions[current_round] + 1) % self.game_description.n_players]
        if last_opponent_action:
            if state.current_stock > self.stock_threshold:
                return Action.D
            elif state.current_stock < self.stock_threshold:
                return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_553(BaseStrategy):
    """Adaptive Tit-for-Tat Strategy for Common Pool Resource Game"""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.zeros(1), np.zeros((1, game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.history = PlayerHistory(np.array([[True]], dtype=bool), np.array([state.current_stock / (2 * self.game_description.n_players)]), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1))
            return Action.C
        else:
            opponent_cooperators = sum(history.opponent_actions[-1, :])
            payoff = history.my_payoffs[-1] if len(history.my_payoffs) > 0 else state.current_stock / (2 * self.game_description.n_players)
            if opponent_cooperators >= self.game_description.n_players // 2:
                self.history = PlayerHistory(self.history.my_actions, np.append(self.history.my_payoffs, payoff), self.history.opponent_actions, np.append(self.history.opponent_payoffs, payoff))
                return Action.C
            else:
                self.history = PlayerHistory(self.history.my_actions, np.append(self.history.my_payoffs, state.current_stock / self.game_description.n_players + payoff), self.history.opponent_actions, self.history.opponent_payoffs)
                return Action.D

class Strategy_EXPLOITATIVE_554(BaseStrategy):
    """
    A variation of the classic Tit-for-Tat strategy, with an adaptive cooperation threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(my_actions=np.zeros((game_description.n_rounds,), dtype=bool), my_payoffs=np.zeros((game_description.n_rounds,), dtype=np.float64), opponent_actions=np.zeros((game_description.n_rounds, game_description.n_players), dtype=bool), opponent_payoffs=np.zeros((game_description.n_rounds, game_description.n_players), dtype=np.float64))
        self.cooperation_threshold = np.full((game_description.n_rounds,), 1.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        if current_round < self.game_description.n_rounds - 1:
            cooperation_rate = np.mean(self.history.opponent_actions[max(0, current_round - 3):current_round + 1, :].sum(axis=0) / self.game_description.n_players)
            self.cooperation_threshold[current_round] = cooperation_rate
        elif np.all(self.history.opponent_actions[:current_round, :][:, -1]) == 1:
            return Action.C
        CR = self.history.opponent_actions[current_round - 1, :].sum() / self.game_description.n_players
        if CR > self.cooperation_threshold[current_round]:
            action = Action.C
        else:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_556(BaseStrategy):
    """
    Implementation of the Adaptive Tit-for-Tat strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._opponent_history = np.zeros((1, self.game_description.n_rounds), dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        self._update_opponent_history(history)
        if state.round_number == 0 or np.sum(self._opponent_history[-1]) > self.game_description.n_players // 2:
            return Action.C
        return Action.D

    def _update_opponent_history(self, history):
        if self._opponent_history.shape[0] == 1 and history is None:
            pass
        elif self._opponent_history.shape[0] > 1:
            self._opponent_history = np.roll(self._opponent_history, -1)
            self._opponent_history[-1] = history.opponent_actions[-1].flatten()

class Strategy_EXPLOITATIVE_557(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Cooperation Threshold strategy that cooperates when there are sufficient resources and defects to rebuild cooperation when resources are scarce.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_stock = None
        self.cooperation_threshold = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            self.current_stock = self.game_description.capacity
            self.cooperation_threshold = self.current_stock
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        action = Action.C if self.current_stock >= self.cooperation_threshold else Action.D
        self.cooperation_threshold = self.current_stock if action == Action.D else self.cooperation_threshold
        self.current_stock = state.current_stock
        return action

class Strategy_EXPLOITATIVE_559(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Growth Adaptation (TfTGA)
    Summary: This strategy cooperates initially to show good faith and encourages a positive relationship.
             In subsequent rounds, it analyzes the opponent's behavior from previous rounds to determine the action in the current round.
             It retaliates against opponents who defect by also defecting in response, teaching them that defection results in reduced long-term payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history or state.round_number == 0:
            return Action.C
        total_consumption = np.sum(history.opponent_payoffs[:state.round_number]) * self.game_description.n_players
        if total_consumption < self.capacity:
            opponent_cooperated_last_round = np.sum(history.opponent_actions[-1]) > 0
            return Action.C if opponent_cooperated_last_round else Action.D
        return Action.D

class Strategy_EXPLOITATIVE_560(BaseStrategy):
    """
    A Tit-for-Tat with Adaptive Resilience (TfTAR) strategy for Common Pool Resource Games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_tolerance_threshold = int(self.game_description.n_players * (self.game_description.n_rounds * 0.3))
        self.cooperation_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[state.round_number - 1] if history is not None else np.zeros(self.game_description.n_players)
        self.cooperation_count += sum(opponent_actions)
        if self.cooperation_count > self.defection_tolerance_threshold:
            self.cooperation_count = 0
        action = Action.C if np.all(opponent_actions == 1) else Action.D
        return action

class Strategy_EXPLOITATIVE_561(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_threshold = 0.5
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.stock_history) == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        opponent_actions = history.opponent_actions[-len(self.game_description.n_players):, -1]
        cooperation_probability_c = 1.0 if state.current_stock <= self.capacity_threshold * self.game_description.capacity else 0.5
        cooperation_probability_d = 1.0 - cooperation_probability_c
        if np.all(opponent_actions == Action.C):
            return np.where(random.random(len(opponent_actions)) < cooperation_probability_c, Action.C, Action.D)
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            opponent_action = np.where(opponent_actions == Action.C, Action.C, Action.D)
            return opponent_action[0] if np.all(history.my_actions[-1]) == opponent_action else Action.D

class Strategy_EXPLOITATIVE_562(BaseStrategy):
    """
    Tit-for-Tat Strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or len(history.opponent_actions) == 0:
            return Action.C
        last_opponent_action = np.mean(history.opponent_actions[-1])
        return Action(int(last_opponent_action))

class Strategy_EXPLOITATIVE_563(BaseStrategy):
    """
    A Tit-for-Tat with Modifications (TFTM) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p_deviate = 0.25
        self.q_forgive = 0.33

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_opponent_action = np.mean(history.opponent_actions[-1])
        current_stock_level = state.current_stock / self.game_description.n_players
        if current_stock_level >= self.game_description.capacity * 0.95 or state.round_number == self.game_description.n_rounds:
            return Action.D
        if last_opponent_action == 1:
            if random.random() < self.p_deviate:
                action = Action.D
            else:
                action = Action.C
        elif last_opponent_action == 0 and current_stock_level < self.game_description.capacity * 0.1:
            action = Action.D
        elif random.random() < self.q_forgive:
            action = Action.C
        else:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_564(BaseStrategy):
    """
    A Tit-for-Tat strategy for the Common Pool Resource Game.
    This strategy cooperates in the first round and subsequent rounds it adopts a "Tit-for-Tat" approach, where players cooperate if their opponent cooperated in the previous round, and defect if their opponent defected.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_round = 0
        self.history = PlayerHistory(np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros(1))

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        self.current_round = state.round_number
        self.history = history
        if self.current_round == 0:
            return Action.C
        if np.all(history.my_actions[-1]) and np.all(history.opponent_actions[-self.current_round, :-1]):
            return Action.C
        elif np.any(history.my_actions[-1]) and np.any(history.opponent_actions[-self.current_round, -1]):
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_565(BaseStrategy):
    """
    Tit-for-Tat-Growth (TFT-G) Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_last_action = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.opponent_last_action = None
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.opponent_last_action is None or history.opponent_actions[-1].all():
            self.opponent_last_action = history.opponent_actions[-1].mean()
        if self.opponent_last_action:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_566(BaseStrategy):
    """
    The Tit-for-Tat-Growth (TfT-G) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold1 = 2 * game_description.n_players / 3 * game_description.capacity
        self.threshold2 = 4 / 5 * game_description.capacity
        self.history = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if not self.history or state.round_number == 0:
            return Action.C
        all_cooperated = np.all(history.opponent_actions[-1])
        if all_cooperated and state.current_stock < self.threshold1:
            return Action.C
        elif state.current_stock > self.threshold2:
            return Action.D
        else:
            return Action(random.choice([0, 1]))

    def update_history(self, history: PlayerHistory):
        """
        Update the strategy's internal history with the provided game history.
        """
        self.history = history

class Strategy_EXPLOITATIVE_567(BaseStrategy):
    """
    Strategy name: Adaptive Tit-for-Tat (ATfT)
    This strategy cooperates with opponents when the common pool is above a minimum survival threshold and punishes excessive exploitation by defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_stock = max(2 * game_description.n_players, game_description.capacity // (1.5 * game_description.n_players))
        self.average_consumption = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is not None:
            total_consumption = np.sum(history.my_actions)
            average_consumption = np.mean(total_consumption)
            if total_consumption > self.average_consumption:
                self.average_consumption = total_consumption
                return Action.D
            elif state.current_stock > self.min_stock:
                return Action.C
        else:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_568(BaseStrategy):
    """
    An implementation of the Adaptive Tit-for-Tat (A-TFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperated_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            self.opponent_cooperated_last_round = any(history.opponent_actions[-1])
        if state.round_number == 0 or (state.round_number < self.game_description.n_rounds - 1 and (not self.opponent_cooperated_last_round)):
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.D if not self.opponent_cooperated_last_round else Action.C

class Strategy_EXPLOITATIVE_569(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Adaptive Cooperation (TFTA)
    Strategy Description: The strategy adapts its cooperation level based on the current state of the common pool resource, making it more robust to a wide range of opponent behaviors while still being exploitative when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_probability = 0.5
        self.learning_rate = 0.1
        self.threshold = self.game_description.capacity * 0.7
        self.last_opponent_action = None
        self.stock_remaining = 0
        self.next_round = 0
        self.opponent_cooperation_score = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        action = Action.C if state.round_number == 0 else self._determine_action(state, history)
        if state.round_number < self.game_description.n_rounds - 1:
            self._update_variables(action, state)
        return action

    def _determine_action(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if self.last_opponent_action is None or self.next_round > state.round_number:
            self.next_round = state.round_number + 1
            return Action.C
        cooperators = sum(history.opponent_actions[self.next_round - 1, :])
        probability_of_cooperation = (self.game_description.capacity - state.current_stock) / self.game_description.capacity if state.current_stock < self.threshold else self.base_probability
        action = Action(int(random.binomial(1, probability_of_cooperation)))
        self._update_variables(action, state)
        return action

    def _update_variables(self, action: Action, state: CommonPoolState):
        if action == Action.C and self.last_opponent_action is not None and (self.last_opponent_action != action):
            self.opponent_cooperation_score -= 1
        elif action == Action.C and self.last_opponent_action is not None and (self.last_opponent_action == action):
            self.opponent_cooperation_score += 1
        if state.round_number > self.next_round:
            self.base_probability += self.learning_rate * (1 - self.base_probability) * (self.opponent_cooperation_score - np.mean(self.opponent_cooperation_score))
        if state.current_stock == 0 and self.next_round <= state.round_number:
            self.next_round = state.round_number + 1
            for round_num in range(state.round_number + 1, self.game_description.n_rounds):
                self._call__(CommonPoolState(round_number=round_num, current_stock=0), None)

class Strategy_EXPLOITATIVE_571(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATfT) strategy for the Common Pool Resource Game.
    This strategy cooperates initially, then mimics opponents' actions from the previous round,
    while forgiving defections when the common pool resource level falls below a threshold to prevent excessive depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = self.game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if opponent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        stock_level = state.current_stock
        if stock_level < self.threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_573(BaseStrategy):
    """
    A Tit-for-Tat-Growth (TfT-G) strategy for the Common Pool Resource Game.
    This strategy employs cooperation to build trust initially, then retaliates against selfish behavior.
    It also protects the common pool from excessive depletion when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.t = 0
        self.initial_cooperation = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.initial_cooperation = True
            self.t = math.floor(state.round_number / 2) if state.round_number > 1 else 0
        cooperators = sum(history.opponent_actions[-1, :])
        stock_threshold = self.game_description.capacity - self.game_description.n_players // 2
        if self.t > 0 and cooperators == self.game_description.n_players:
            self.t -= 1
            return Action.C
        if any(history.opponent_actions[:, -1].flatten()):
            return Action.D
        return Action.C if state.current_stock <= stock_threshold else Action.D

class Strategy_EXPLOITATIVE_574(BaseStrategy):
    """
    Implementation of Tit-for-Tat-Growth (TfT-G) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action = Action.C
        if state.round_number == 0 or state.current_stock == self.capacity:
            return action
        last_round = len(history.opponent_actions) - 1
        last_my_action = history.my_actions[last_round] if history else None
        last_opponent_cooperators = sum(history.opponent_actions[last_round, :]) if history else 0
        if last_opponent_cooperators >= self.game_description.n_players // 2:
            action = Action.C
        elif last_my_action is None or last_my_action or state.current_stock < self.capacity * (self.game_description.n_players - 1):
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_575(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        last_round = state.round_number == self.game_description.n_rounds - 1
        depletion = state.current_stock < self.game_description.capacity // (2 * self.game_description.n_players)
        if not last_round and depletion:
            return Action.D
        opponent_action = history.opponent_actions[-1, 0] if state.round_number > 0 else None
        if opponent_action is None or not opponent_action:
            return Action.C
        elif opponent_action:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_576(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1,), dtype=bool), np.zeros((1,)), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros((1,)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_action = history.opponent_actions[-1, -1] if len(history.opponent_actions) > 0 else Action.C
        return opponent_action if opponent_action == Action.C else Action.D

    def update_history(self, state: CommonPoolState, action: Action):
        self.history.my_actions = np.append(self.history.my_actions, np.array([action == Action.C]))
        payoff = state.current_stock / (2 * self.game_description.n_players if action == Action.C else self.game_description.n_players)
        self.history.my_payoffs = np.append(self.history.my_payoffs, np.array([payoff]))
        opponent_actions = np.array([action == Action.C]) if len(history.opponent_actions) == 0 else history.opponent_actions[-1]
        self.history.opponent_actions = np.append(self.history.opponent_actions, np.expand_dims(opponent_actions, axis=0))
        self.history.opponent_payoffs = np.append(self.history.opponent_payoffs, np.broadcast_to(history.my_payoffs[-1], (1, self.game_description.n_players)))

class Strategy_EXPLOITATIVE_577(BaseStrategy):
    """
    Strategy name: Tit-for-Tat with Adaptive Cooperation (TFT-AC)
    Strategy description: This strategy cooperates in the first round and adapts its actions based on the opponent's previous moves.
                           If the opponent cooperated, it continues cooperating. If the opponent defected, it also defects to signal displeasure.
                           In the last round, if the opponent defected in the previous round, it cooperates as a goodwill gesture.
                           It handles edge cases such as multiple consecutive defections and depleted stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None
        self.defection_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is not None:
            self.last_opponent_action = history.opponent_actions[-1, 0] if state.round_number > 0 else None
            self.defection_counter = 0 if self.last_opponent_action is None else self.defection_counter
        if self.last_opponent_action == Action.C:
            return Action.C
        elif self.last_opponent_action == Action.D and state.round_number < self.game_description.n_rounds:
            self.defection_counter += 1
            return Action.D
        elif state.round_number == self.game_description.n_rounds:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_578(BaseStrategy):
    """
    A Tit-for-Tat strategy for the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            return Action.C
        last_opponent_action = history.opponent_actions[-1][-1] if history else self.last_opponent_action
        self.last_opponent_action = last_opponent_action
        return Action(int(last_opponent_action == Action.C))

class Strategy_EXPLOITATIVE_579(BaseStrategy):
    """
    A Tit-for-Tat with Stock Adaptation (TfTSA) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.p = self.n // 2
        self.threshold = self.n
        self.stock_level = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if history is None or len(history.opponent_actions) == 0:
            return Action.C
        current_stock = state.current_stock
        my_action = history.my_actions[-1]
        opponent_action = history.opponent_actions[-1, 0] if self.n == len(history.opponent_actions) else history.opponent_actions[state.round_number - 1, 0]
        opponent_cooperators = sum(history.opponent_actions[-1])
        if current_stock < self.threshold and opponent_action == Action.D:
            self.stock_level = max(self.capacity * (current_stock / self.threshold), self.capacity - self.n)
            retaliation_count = min(self.p, state.round_number - 1)
            for _ in range(retaliation_count):
                if opponent_cooperators > 0:
                    return Action.D
                if current_stock >= self.threshold:
                    break
        if my_action and (not opponent_action):
            return Action.C
        elif not my_action and opponent_action:
            retaliation_count = min(self.p, state.round_number - 1)
            for _ in range(retaliation_count):
                if opponent_cooperators > 0:
                    return Action.D
                if current_stock >= self.threshold:
                    break
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_581(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Adjustment (TFTSA)
    Strategy demonstrates goodwill by cooperating in the first and final rounds, and prioritizes preserving resources when the stock is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = self.game_description.capacity / 2
        self.punishment_rounds = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_round = len(history.opponent_actions) - 1
        opponent_action = history.opponent_actions[last_round, 0] if state.round_number > 0 else None
        cooperate = opponent_action is not None and opponent_action or state.round_number == 1
        if state.current_stock / self.game_description.capacity < self.stock_threshold:
            if state.round_number <= last_round + self.punishment_rounds or state.current_stock <= self.game_description.n_players:
                cooperate = False
        if state.round_number == self.game_description.n_rounds - 1:
            cooperate = True
        return Action(int(cooperate))

class Strategy_EXPLOITATIVE_582(BaseStrategy):
    """
    Implementation of Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_round_history = None
        self.self_cooperated_last_round = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or not history:
            self.self_cooperated_last_round = True
            return Action.C
        if not self.previous_round_history:
            self.previous_round_history = [(self.self_cooperated_last_round, np.any(history.opponent_actions[:, -1], axis=0))]
        if self.self_cooperated_last_round and history.opponent_actions[-1, -1]:
            self.self_cooperated_last_round = True
            return Action.C
        elif self.self_defected_last_round and history.opponent_actions[-1, -1]:
            self.self_cooperated_last_round = False
            return Action.D
        elif self.self_defected_last_round and (not history.opponent_actions[-2, -1]):
            self.self_cooperated_last_round = True
            return Action.C
        else:
            self.self_cooperated_last_round = False
            return Action.D

    @property
    def self_defected_last_round(self) -> bool:
        if not self.previous_round_history:
            return False
        else:
            return not self.previous_round_history[-1][0]

class Strategy_EXPLOITATIVE_583(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold (TFT-ACT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.ct = 0.9
        self.remaining_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if not history:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            self.remaining_stock = min(self.capacity, self.game_description.capacity * (2 / (self.game_description.n_players + 1)))
        else:
            self.remaining_stock = self.capacity
        total_consumption = sum([sum(history.opponent_actions[r]) for r in range(state.round_number)]) * (state.round_number + 1) / self.game_description.n_rounds
        if total_consumption / self.capacity >= self.ct:
            self.ct += 0.1
        elif sum(history.opponent_actions[-1]) == self.game_description.n_players - 1 and self.remaining_stock > 2 * self.game_description.n_players:
            self.ct -= 0.1
        if state.round_number > 0:
            last_round_opponent_action = history.opponent_actions[-1][-1]
            if last_round_opponent_action != history.opponent_actions[state.round_number - 1][-1]:
                self.ct += (last_round_opponent_action == Action.C and self.remaining_stock > 2 * self.game_description.n_players) - (last_round_opponent_action != Action.C) * 0.1
        if self.ct <= total_consumption / self.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_584(BaseStrategy):
    """
    A Tit-for-Tat strategy with adaptive generosity, which cooperates initially and responds in kind to an opponent's actions,
    while implementing a forgiveness mechanism and learning component. The strategy gradually increases exploitation against opponents
    who consistently defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiveness_count = 0
        self.exploitation_threshold = int(game_description.n_players / 4)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :] if history else np.zeros(self.game_description.n_players, dtype=bool)
        if self.forgiveness_count > 0:
            self.forgiveness_count -= 1
            return Action.C
        elif opponent_actions.sum() <= self.exploitation_threshold:
            if opponent_actions.sum() == 0:
                self.forgiveness_count = min(self.game_description.n_players - 1, int(math.sqrt(state.round_number)))
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_585(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Adaptive Cooperation Threshold (TFT-CT) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_threshold = int(game_description.capacity * 0.5)
        self.history = PlayerHistory(np.zeros((1, 2), dtype=bool), np.array([], dtype=float), np.zeros((self.game_description.n_players, self.game_description.n_rounds), dtype=bool), np.zeros((self.game_description.n_players, self.game_description.n_rounds), dtype=float))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        self.history = history
        if state.round_number == 1:
            return Action.C
        total_consumption = np.sum(self.history.opponent_actions[:, -1] * (self.game_description.capacity // self.game_description.n_players) + (self.history.opponent_payoffs[:, -1] if state.round_number > 1 else 0))
        avg_consumption = total_consumption / max(state.round_number, 2)
        if avg_consumption < self.cooperative_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_586(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFT-AC) Strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_consumption = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None or len(history.opponent_actions) < self.game_description.n_players * (state.round_number - 1):
            return Action.C
        if state.round_number == 1:
            self.average_consumption = np.mean(history.opponent_actions[-1])
            return Action.C
        self.average_consumption = np.mean(history.opponent_actions[-self.game_description.n_rounds:])
        if history.opponent_actions[-1][0] == Action.C and history.opponent_actions[-1][0] / self.average_consumption <= 1:
            return Action.C
        elif history.opponent_actions[-1][0] / self.average_consumption > 1 or history.opponent_actions[-1][0] == Action.D:
            return Action.D
        else:
            return history.opponent_actions[-2][0]

class Strategy_EXPLOITATIVE_587(BaseStrategy):
    """
    Implementation of the Tit-for-Tat with Gradual Adjustment (TfT-GA) strategy in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.length = 1
        self.opponent_consistent = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not history:
            return Action.C
        opponent_action = history.opponent_actions[-1, -1]
        if state.round_number > self.game_description.n_players * 2:
            self.length += 1 if opponent_action == Action.C else -1
            self.opponent_consistent = max(self.opponent_consistent, state.round_number)
        return Action(int(opponent_action or 0)) if state.round_number >= self.opponent_consistent else Action((state.round_number + 1) // self.length)

class Strategy_EXPLOITATIVE_588(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation (TFTA) strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.current_opponent_cooperation_rate = None
        self.rounds_played = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            self.current_opponent_cooperation_rate = 0.0
            self.rounds_played = 0
            return Action.C
        self.rounds_played += 1
        cooperators = sum(history.opponent_actions[-1, :])
        if self.rounds_played == 1:
            self.current_opponent_cooperation_rate = float(cooperators)
        else:
            cooperation_rate = cooperators / self.n_players
            self.current_opponent_cooperation_rate = ((self.rounds_played - 1) * self.current_opponent_cooperation_rate + cooperation_rate) / self.rounds_played
        if self.current_opponent_cooperation_rate >= self.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_589(BaseStrategy):
    """
    The Tit-for-Tat-Growth Strategy (TFT-G) follows cooperative behavior initially,
    but adapts to the opponent's actions over time. It promotes cooperation and punishes defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.a = 0.5
        self.history_buffer = np.zeros((self.game_description.n_rounds,), dtype=np.bool_)

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None):
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.history_buffer = self.history_buffer[1:]
            cooperators = sum(self.history_buffer) / self.game_description.n_rounds
            if cooperators >= self.a:
                return Action.C
            return Action.D
        else:
            if state.round_number > 0:
                history = PlayerHistory(np.full((1,), False), np.zeros(1), np.zeros((state.round_number, self.game_description.n_players), dtype=np.bool_), np.zeros(state.round_number))
            return self.__call__((CommonPoolState(state.round_number + 1, state.current_stock), history))

    def last_round_logic(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            if history.opponent_payoffs[-1] < history.current_stock / (2 * self.game_description.n_players):
                return Action.D
            else:
                return Action.C

    def exploitative_switch(self):
        self.history_buffer = np.full((self.game_description.n_rounds,), False)
        return 'always_defect'

class Strategy_EXPLOITATIVE_590(BaseStrategy):
    """
    A Tit-for-Tat strategy with Adaptive Cooperation Threshold (TTAT-CT). This strategy cooperates when the average consumption rate of all players is below the adaptation threshold, and defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 1
        self.learning_rate = 0.2
        self.round_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        average_consumption_rate = np.mean(history.opponent_actions.sum(axis=1))
        if state.current_stock > self.game_description.n_players * self.cooperation_threshold:
            return Action.C
        self.round_history.append(state.round_number)
        update = (average_consumption_rate - self.cooperation_threshold) * self.learning_rate
        self.cooperation_threshold += update if len(self.round_history) < self.game_description.n_rounds else 0
        return Action.D if average_consumption_rate >= self.cooperation_threshold else Action.C

class Strategy_EXPLOITATIVE_591(BaseStrategy):
    """
    Tit-for-Tat with Adaptive Cooperation Threshold strategy
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_length = int(math.ceil(game_description.n_rounds * 0.8))
        self.cooperation_threshold = 0.75
        self.history = PlayerHistory(my_actions=np.zeros(game_description.n_rounds, dtype=bool), my_payoffs=np.zeros(game_description.n_rounds, dtype=float), opponent_actions=None, opponent_payoffs=None)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None and state.round_number > self.history_length:
            average_stock = np.mean(self.history.my_actions[-self.history_length:].sum(axis=0))
            if state.round_number == self.game_description.n_rounds or average_stock < self.cooperation_threshold:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_592(BaseStrategy):
    """
    Adaptive Tit-for-Tat (ATFT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_threshold = math.floor(game_description.n_players / 2)
        self.defective_consecutive_rounds = 0
        self.opponent_cooperated_throughout = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_actions) == 0):
            return Action.C
        current_round = len(history.my_actions) - 1
        last_round = history.my_actions[-1] if history is not None else False
        last_opponent_action = history.opponent_actions[current_round, 0] if history is not None else False
        if self.defective_consecutive_rounds >= self.punishment_threshold:
            return Action.D
        if last_opponent_action:
            self.defective_consecutive_rounds = 0
            return Action.C
        else:
            self.defective_consecutive_rounds += 1 if last_round else 0
            return Action.D

class Strategy_EXPLOITATIVE_593(BaseStrategy):
    """
    Adaptive Tit-for-Tat Strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = PlayerHistory(np.zeros((1,), dtype=bool), np.zeros((1,)), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros((1,)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            self.history = PlayerHistory(np.zeros((1,), dtype=bool), np.zeros((1,)), np.zeros((1, self.game_description.n_players), dtype=bool), np.zeros((1,)))
            return Action.C
        self.history = PlayerHistory(self.history.my_actions[:state.round_number + 1], self.history.my_payoffs[:state.round_number + 1], self.history.opponent_actions[:state.round_number + 1, :], self.history.opponent_payoffs[:state.round_number + 1])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        last_round = self.history.opponent_actions[-1, :].sum() == self.game_description.n_players - 1
        current_round = history.opponent_actions[state.round_number - 1, :].sum() >= self.game_description.n_players - 2 if state.round_number > 0 else last_round
        return Action(int(last_round or not current_round))

class Strategy_EXPLOITATIVE_594(BaseStrategy):
    """
    Tit-for-Tat Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_cooperate = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        edge_case = self.determine_edge_case(round_number, self.game_description.n_rounds)
        action = edge_case or (history and history.opponent_actions[round_number - 1, 0]) if history else None
        return self.decide_action(action, round_number)

    def determine_edge_case(self, round_number: int, r: int) -> bool:
        """
        Determine edge cases for the Tit-for-Tat strategy.
        """
        if round_number == 1:
            return self.initial_cooperate
        elif round_number <= math.floor(r * 0.7):
            return True
        elif round_number > math.floor(r * 0.7) and round_number != self.game_description.n_rounds:
            return False
        else:
            return False

    def decide_action(self, opponent_action: bool | None, round_number: int) -> Action:
        """
        Decide between cooperate and defect based on edge cases and opponent's action.
        """
        if opponent_action is None:
            return Action.C
        return Action(int(opponent_action))

class Strategy_EXPLOITATIVE_597(BaseStrategy):
    """
    Strategy Name: Tit-for-Tat with Stock Adaptation (TFTSA)
    Summary: A strategy that cooperates in the first round and adapts its actions based on the opponent's past actions and the remaining stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_length = 0
        self.stock_threshold = game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            opponent_actions = history.opponent_actions[-1]
            history_len = len(history.opponent_actions)
            if state.current_stock < self.stock_threshold:
                self.punishment_length = math.ceil(state.current_stock / self.game_description.capacity * self.game_description.n_rounds)
            if opponent_actions[-1] == Action.C or self.punishment_length <= 0:
                return Action.C
            elif history_len > 1 and opponent_actions[-2] == Action.C and (opponent_actions[-1] == Action.D) or self.punishment_length > 0:
                self.punishment_length -= 1
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_598(BaseStrategy):
    """
    Tit-for-Tat-Growth Strategy for Common Pool Resource Game
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.stock_threshold = self.game_description.capacity * (2 / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_action = history.opponent_actions[-1, 0] if history is not None else None
        if opponent_action is None or opponent_action.item():
            current_stock = state.current_stock
            stock_level = min(current_stock, self.stock_threshold)
            return Action(int(stock_level <= self.stock_threshold))
        else:
            return Action(1 - opponent_action.item())

class Strategy_EXPLOITATIVE_599(BaseStrategy):
    """
    A strategy based on Tit-for-Tat with Adaptive Cooperation Threshold (TTAT-ACT). This strategy cooperates in the first round and responds to opponents' actions based on their past behavior and a dynamically adjusted cooperation threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_threshold = self.capacity / (2 * self.n)
        self.average_stock = np.zeros(self.r + 1)
        self.current_round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory):
        if history is not None and state.round_number > 0:
            stock_levels = [state.current_stock] + list(history.my_payoffs)
            average_stock = np.mean(stock_levels)
            self.adjust_stock_threshold(average_stock)
        if history is None or state.round_number == 0:
            action = Action.C
        else:
            opponent_action = history.opponent_actions[-1, -1]
            if opponent_action == Action.C and state.current_stock >= self.stock_threshold:
                action = Action.C
            elif opponent_action == Action.D and state.current_stock < self.stock_threshold:
                action = Action.D
            else:
                action = Action.C
        return action

    def get_payoff(self, action: Action, stock: float) -> float:
        if action == Action.C:
            payoff = stock / (2 * self.n)
        elif action == Action.D:
            payoff = stock / self.n
        return payoff

    def get_total_consumption(self, opponent_action: Action, stock: float) -> float:
        if opponent_action == Action.C:
            consumption = stock / (2 * self.n)
        elif opponent_action == Action.D:
            consumption = stock / self.n
        return consumption

    def adjust_stock_threshold(self, average_stock):
        capacity_divisor = 4 * self.n if average_stock < self.capacity / (4 * self.n) else 2 * self.n
        self.stock_threshold = self.capacity / (2 * self.n * (average_stock > 0.5 or 1)) * capacity_divisor
