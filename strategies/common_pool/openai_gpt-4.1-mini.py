"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: OpenAI
- Model: gpt-4.1-mini
- Game: CommonPoolDescription
"""

from emergent_llm.players.base_player import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription
from emergent_llm.common.actions import Action, C, D
from emergent_llm.common.history import PlayerHistory
import numpy as np
from numpy.typing import NDArray
import math
import random



class Strategy_COOPERATIVE_1(BaseStrategy):
    """
    Sustained Cooperation with Conditional Punishment strategy for the Common Pool Resource Game.

    - Round 1: Cooperate unconditionally to establish cooperation.
    - Rounds 2 to r-1: Cooperate if all players cooperated last round; else punish by defecting this round.
    - Round r (last round): Defect unconditionally to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        round_number = 1 if history is None else history.round_number + 1
        if round_number == r:
            return Action.D
        if round_number == 1:
            return Action.C
        last_round_idx = round_number - 2
        self_last = history.my_actions[last_round_idx]
        opp_last = history.opponent_actions[last_round_idx]
        all_last = np.append(opp_last, self_last)
        if all(all_last):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_2(BaseStrategy):
    """
    Cooperative conditional strategy for the Common Pool Resource Game.
    - Starts cooperating to build trust.
    - Punishes defections once by defecting next round.
    - Uses the stock level to decide cooperation (cooperate only if stock ≥ capacity/2).
    - Unconditionally defects on last round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_safe = self.capacity / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        S_safe = self.S_safe
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        S = capacity
        n_players = n
        for j in range(t):
            my_act = history.my_actions[j]
            opp_acts = history.opponent_actions[j]
            all_acts = np.empty(n_players, dtype=bool)
            all_acts[0] = my_act
            all_acts[1:] = opp_acts
            n_coop = np.sum(all_acts)
            n_defect = n_players - n_coop
            coop_consumption = S / (2 * n_players)
            defect_consumption = S / n_players
            total_consumption = n_coop * coop_consumption + n_defect * defect_consumption
            S_after = S - total_consumption
            if S_after < 0:
                S_after = 0
            growth = 2 * S_after * (1 - S_after / capacity)
            S = min(S_after + growth, capacity)
        S_t = S
        if current_round == r:
            return Action.D
        if t >= 1:
            prev_round = t - 1
            my_prev_act = history.my_actions[prev_round]
            opp_prev_acts = history.opponent_actions[prev_round]
            all_prev_acts = np.empty(n_players, dtype=bool)
            all_prev_acts[0] = my_prev_act
            all_prev_acts[1:] = opp_prev_acts
            all_cooperated = np.all(all_prev_acts)
            prev_round_any_defect = not all_cooperated
            my_last_action = history.my_actions[t - 1]
            punished_last_round = my_last_action == Action.D.value and prev_round_any_defect
            punish_next = False
            if prev_round_any_defect and (not punished_last_round):
                punish_next = True
            if S_t < S_safe:
                return Action.D
            if punish_next:
                return Action.D
            if all_cooperated:
                return Action.C
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_3(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness and Endgame Adjustment for Common Pool Resource Game.
    - Round 1: Cooperate to signal cooperation
    - Rounds 2..r-1: 
        * If any defection last round: punish by defecting once
        * Else if punished last round and no new defection last round: forgive and cooperate
        * Otherwise cooperate
    - Round r (last round): defect unconditionally (endgame logic)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        next_round = t + 1
        if next_round == r:
            return Action.D
        if next_round > r:
            return Action.D
        last_round_idx = t - 1
        if last_round_idx < 0:
            return Action.C
        last_round_opponents = history.opponent_actions[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        defection_in_last_round = not my_last_action or np.any(last_round_opponents == False)
        punished_last_round = my_last_action == False
        if defection_in_last_round:
            return Action.D
        elif punished_last_round:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_4(BaseStrategy):
    """
    Conditional Cooperation with Gradual Punishment:
    
    - Cooperate in first round.
    - For rounds 2 to r-1:
      * If in punishment phase, defect and decrease punishment counter.
      * Else if previous round was full cooperation (all cooperated including self), cooperate.
      * Otherwise, start punishment phase of length P and defect.
    - In last round, always defect.
    """
    PUNISH_LENGTH = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            self.punish_counter = 0
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        prev_round = t - 1
        if prev_round < 0:
            return Action.C
        my_prev = history.my_actions[prev_round]
        opp_prev = history.opponent_actions[prev_round]
        if my_prev and opp_prev.all():
            return Action.C
        else:
            self.punish_counter = self.PUNISH_LENGTH - 1
            return Action.D

class Strategy_COOPERATIVE_5(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness for Common Pool Resource Game.

    - Cooperates first round.
    - If any defection detected in previous round, punishes by defecting for p rounds.
    - After punishment phase, returns to cooperation.
    - Defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_length = 3
        self.punishment_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            self.punishment_timer = 0
            return Action.C
        t = history.round_number
        if t == r - 1:
            return Action.D
        if self.punishment_timer > 0:
            self.punishment_timer -= 1
            return Action.D
        prev_round = t - 1
        prev_opp_actions = history.opponent_actions[prev_round]
        my_prev_action = history.my_actions[prev_round]
        all_prev_actions = np.append(prev_opp_actions, my_prev_action)
        any_defected = np.any(all_prev_actions == False)
        if any_defected:
            self.punishment_timer = self.punishment_length - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_6(BaseStrategy):
    """
    Conditional cooperation with immediate punishment (1 round) and quick forgiveness
    for the Common Pool Resource Game.

    Starts cooperating, continues cooperating if all cooperated last round,
    punishes any defection with 1 round of defecting, then returns to cooperation.
    Always cooperates in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_length = 1
        self.punishment_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        t = 1 if history is None else history.round_number + 1
        if t == r:
            return Action.C
        if t == 1:
            self.punishment_timer = 0
            return Action.C
        if self.punishment_timer > 0:
            self.punishment_timer -= 1
            return Action.D
        else:
            prev_round = t - 2
            own_action_last = history.my_actions[prev_round]
            opp_actions_last = history.opponent_actions[prev_round]
            all_cooperated = own_action_last and opp_actions_last.all()
            if all_cooperated:
                return Action.C
            else:
                self.punishment_timer = self.punishment_length
                self.punishment_timer -= 1
                return Action.D

class Strategy_COOPERATIVE_7(BaseStrategy):
    """
    "Sustained Reciprocity with Forgiveness" strategy for the Common Pool Resource Game.

    - Round 1: Cooperate (signal trust).
    - Last round: Defect (exploit, no future punishment).
    - Intermediate rounds:
        - If punishment_round flag is set (due to defection observed previous round), defect once then reset flag.
        - Else cooperate.
    - punishment_round flag is set whenever any player defected in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None:
            self.punishment_round = False
            return Action.C
        t = history.round_number
        current_round = t + 1
        last_round_index = t - 1
        if last_round_index >= 0:
            my_last_action = history.my_actions[last_round_index]
            opponents_last_actions = history.opponent_actions[last_round_index]
            any_defected_last_round = not my_last_action or np.any(~opponents_last_actions)
        else:
            any_defected_last_round = False
        if current_round < r:
            self.punishment_round = any_defected_last_round
        if current_round == 1:
            return Action.C
        if current_round == r:
            return Action.D
        if self.punishment_round:
            self.punishment_round = False
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_8(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness for Common Pool Resource Game.

    Starts by cooperating. Monitors all players' actions each round.
    If everyone cooperated last round, continue cooperating.
    If any defection last round, schedule a one-round punishment next round.
    Punishment is a single round of defection, then return to cooperation.
    In the final round, always defect to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_next_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            self.punish_next_round = False
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        last_round_index = t - 2
        last_round_own_action = history.my_actions[last_round_index]
        last_round_opponent_actions = history.opponent_actions[last_round_index]
        all_cooperated_last = last_round_own_action and all(last_round_opponent_actions)
        if self.punish_next_round:
            action = Action.D
            self.punish_next_round = False
            return action
        if all_cooperated_last:
            return Action.C
        else:
            self.punish_next_round = True
            return Action.C

class Strategy_COOPERATIVE_9(BaseStrategy):
    """
    Tit-for-Tat with Sustainable Trigger and Endgame Adaptation for the Common Pool Resource game.

    - Starts cooperating round 1.
    - Monitors previous round opponent payoffs to detect defectors (based on payoff threshold).
    - Maintains punishment counters per defector, defecting for maxPunishmentRounds rounds unless forgiven.
    - Punishes defectors by defecting every round until their punishment expires or they cooperate again.
    - If stock falls below warningThreshold, extends punishment by defecting if defectors exist.
    - Forgives all past defections and cooperates in last two rounds (endgameStartRound).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.warningThreshold = 0.5 * self.capacity
        self.maxPunishmentRounds = 2
        self.endgameStartRound = max(1, self.r - 2)
        self.defectors = {}
        self.last_stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.defectors.clear()
            self.last_stock = self.capacity
            return Action.C
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        if last_round_idx < 0:
            self.defectors.clear()
            self.last_stock = self.capacity
            return Action.C
        last_opp_actions = history.opponent_actions[last_round_idx]
        last_opp_payoffs = history.opponent_payoffs[last_round_idx]
        last_my_action = history.my_actions[last_round_idx]
        last_my_payoff = history.my_payoffs[last_round_idx]
        if last_my_action:
            inferred_stock = last_my_payoff * 2 * self.n
        else:
            inferred_stock = last_my_payoff * self.n
        inferred_stock = min(inferred_stock, self.capacity)
        inferred_stock = max(inferred_stock, 0.0)
        self.last_stock = inferred_stock
        payoff_if_C = self.last_stock / (2 * self.n)
        payoff_if_D = self.last_stock / self.n
        midpoint = (payoff_if_C + payoff_if_D) / 2
        newly_detected_defectors = set()
        for idx, opp_payoff in enumerate(last_opp_payoffs):
            player_id = idx + 2
            if opp_payoff >= midpoint:
                newly_detected_defectors.add(player_id)
        to_remove = []
        for pid in self.defectors:
            self.defectors[pid] -= 1
            if self.defectors[pid] <= 0:
                to_remove.append(pid)
        for pid in to_remove:
            self.defectors.pop(pid)
        for pid in list(self.defectors.keys()):
            opp_idx = pid - 2
            if 0 <= opp_idx < len(last_opp_actions):
                if last_opp_actions[opp_idx]:
                    self.defectors.pop(pid)
        for pid in newly_detected_defectors:
            if pid not in self.defectors:
                self.defectors[pid] = self.maxPunishmentRounds
        if current_round >= self.endgameStartRound:
            self.defectors.clear()
            return Action.C
        if self.last_stock < self.warningThreshold:
            if self.defectors:
                return Action.D
            else:
                return Action.C
        if self.defectors:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_10(BaseStrategy):
    """
    Conditional Cooperative Sustainer (CCS) strategy for the Common Pool Resource Game.
    
    Starts cooperating, defects once if any defection detected in previous round to punish,
    then returns to cooperation. Defects on the last round to maximize immediate payoff.
    Defects whenever stock is dangerously low to secure payoffs when cooperation is futile.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.gd = game_description
        self.low_stock_threshold = self.gd.capacity / (4 * self.gd.n_players)

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 0 if history is None else history.round_number
        r = self.gd.n_rounds
        n = self.gd.n_players
        capacity = self.gd.capacity
        stock = capacity
        if t > 0:
            for round_idx in range(t):
                my_act = history.my_actions[round_idx]
                opp_acts = history.opponent_actions[round_idx]
                actions_this_round = np.empty(n, dtype=bool)
                actions_this_round[0] = my_act
                actions_this_round[1:] = opp_acts
                c_consumption = stock / (2 * n)
                d_consumption = stock / n
                consumptions = np.where(actions_this_round, c_consumption, d_consumption)
                total_consumption = consumptions.sum()
                S_remaining = stock - total_consumption
                if S_remaining < 0:
                    S_remaining = 0
                growth = 2 * S_remaining * (1 - S_remaining / capacity)
                stock = min(S_remaining + growth, capacity)
        round_num = t + 1
        if round_num == r:
            return Action.D
        if stock <= self.low_stock_threshold:
            return Action.D
        if round_num == 1:
            return Action.C
        previous_round_idx = round_num - 2
        prev_my_act = history.my_actions[previous_round_idx]
        prev_opp_acts = history.opponent_actions[previous_round_idx]
        prev_actions = np.empty(n, dtype=bool)
        prev_actions[0] = prev_my_act
        prev_actions[1:] = prev_opp_acts
        if np.any(prev_actions == False):
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_11(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.

    - Start by cooperating.
    - On last round, defect.
    - If any opponent defected in previous round, punish by defecting one round.
    - Forgive after punishment and resume cooperation.
    - If stock is very low (< capacity/4), defect to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_length = 1
        self.in_punishment_phase = False
        self.punishment_start_round = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        t = 1 if history is None else history.round_number + 1
        if history is None or history.round_number == 0:
            S_t = capacity
        else:
            S = capacity
            for round_i in range(history.round_number):
                opponent_acts = history.opponent_actions[round_i]
                my_act = history.my_actions[round_i]
                n_coop = np.sum(opponent_acts) + (1 if my_act else 0)
                n_defect = n - n_coop
                coop_consume = S / (2 * n)
                defect_consume = S / n
                total_consumption = n_coop * coop_consume + n_defect * defect_consume
                S_remaining = S - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / capacity) if S_remaining > 0 else 0
                S = min(S_remaining + growth, capacity)
            S_t = S
        STOCK_LOW_THRESHOLD = capacity / 4

        def defected_last_round():
            if t == 1:
                return False
            last_round = t - 2
            return np.any(history.opponent_actions[last_round] == False)
        if t == 1:
            self.in_punishment_phase = False
            self.punishment_start_round = None
            return Action.C
        if t == r:
            self.in_punishment_phase = False
            self.punishment_start_round = None
            return Action.D
        if S_t < STOCK_LOW_THRESHOLD:
            self.in_punishment_phase = False
            self.punishment_start_round = None
            return Action.D
        if self.in_punishment_phase:
            rounds_since_start = t - self.punishment_start_round
            if rounds_since_start <= self.punishment_length:
                return Action.D
            else:
                self.in_punishment_phase = False
                self.punishment_start_round = None
                return Action.C
        if defected_last_round():
            self.in_punishment_phase = True
            self.punishment_start_round = t
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_12(BaseStrategy):
    """
    Conditional Mutual Cooperation with Gradual Punishment
    
    - Cooperate in first round unconditionally.
    - For rounds 2 to r-1:
        - If any opponent defected in previous round, punish by defecting once.
        - Otherwise cooperate.
    - In last round always cooperate.
    
    This strategy uses only the previous round's opponent actions to decide.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            return Action.C
        t = history.round_number
        if t == r - 1:
            return Action.C
        last_round_opponent_actions = history.opponent_actions[t - 1]
        if not np.all(last_round_opponent_actions):
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_13(BaseStrategy):
    """
    Conditional Sustained Cooperation (CSC) Strategy for Common Pool Resource Game.

    Summary:
    - Round 1: Cooperate to establish goodwill.
    - Rounds 2 to r-1: Cooperate unless detecting defectors in previous round.
      If defectors detected (≥1), defect once as punishment.
      Forgive after one punishment round if others cooperate again.
    - Round r (last round): Defect to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_threshold = 1
        self.punishment_length = 1
        self.punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        r = self.game_description.n_rounds
        if t == 1:
            self.punishment_rounds_left = 0
            return Action.C
        if t == r:
            return Action.D
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        else:
            last_round = t - 2
            opponent_actions_last = history.opponent_actions[last_round]
            num_defectors = (~opponent_actions_last).sum()
            if num_defectors >= self.defection_threshold:
                self.punishment_rounds_left = self.punishment_length
                return Action.D
            else:
                return Action.C

class Strategy_COOPERATIVE_14(BaseStrategy):
    """
    Cooperative Trigger Strategy for the Common Pool Resource Game.
    
    Starts by cooperating. Monitors opponents' actions each round.
    If any opponent defected in the previous round, punishes by defecting
    for a fixed number of rounds (punishment_duration = 2). After punishment,
    returns to cooperating. Always defects in the last round.
    
    Uses boolean encoding of actions (True = Cooperate, False = Defect).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.punishment_duration = 2
        self.punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        if history is None or history.round_number == 0:
            self.punishment_rounds_left = 0
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        last_round_opponent_actions = history.opponent_actions[t - 1]
        if np.any(last_round_opponent_actions == False):
            self.punishment_rounds_left = self.punishment_duration - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_15(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.
    - Starts cooperating on round 1 to signal cooperation.
    - Punishes defectors by defecting for a short fixed punishment length p (default 2).
    - Forgives after punishment and resumes cooperation.
    - Defects on the last round unconditionally to maximize individual payoff.
    - Tracks punishment state internally across rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p = 2
        self.punishing = False
        self.punish_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 0 if history is None else history.round_number
        r = self.game_description.n_rounds
        n = self.game_description.n_players
        current_round = t + 1
        if t == 0:
            self.punishing = False
            self.punish_rounds_left = 0
            return Action.C
        if current_round == r:
            return Action.D
        if self.punishing:
            self.punish_rounds_left -= 1
            if self.punish_rounds_left == 0:
                self.punishing = False
            return Action.D
        last_round_opponents = history.opponent_actions[t - 1]
        if np.any(last_round_opponents == False):
            self.punishing = True
            self.punish_rounds_left = self.p - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_16(BaseStrategy):
    """
    Cooperative Strategy for Common Pool Resource game.
    
    - Round 1: Cooperate unconditionally.
    - Intermediate rounds: Cooperate only if all players cooperated in previous round, else defect to punish.
    - Last round: Defect unconditionally.
    - If stock ≤ 50% capacity, allow forgiveness by cooperating right after own punishment round to prevent collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_THRESHOLD = 0.5 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        last_my_action = history.my_actions[-1]
        last_opponents_actions = history.opponent_actions[-1]
        all_last_actions = np.empty(self.n, dtype=bool)
        all_last_actions[0] = last_my_action
        all_last_actions[1:] = last_opponents_actions
        d = np.sum(~all_last_actions)
        c = self.n - d
        sum_pi = np.sum(history.my_payoffs[-1]) + np.sum(history.opponent_payoffs[-1])
        total_payoffs_last_round = history.my_payoffs[-1] + np.sum(history.opponent_payoffs[-1])
        if self.n + d > 0:
            S_prev = 2 * self.n * total_payoffs_last_round / (self.n + d)
            S_after_consumption = S_prev - total_payoffs_last_round
            growth = 2 * S_after_consumption * (1 - S_after_consumption / self.capacity)
            S_t = min(S_after_consumption + growth, self.capacity)
        else:
            S_t = self.capacity
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.D
        all_cooperated = all_last_actions.all()
        low_stock = S_t <= self.CRITICAL_THRESHOLD
        if not low_stock:
            if all_cooperated:
                return Action.C
            else:
                return Action.D
        elif not last_my_action:
            return Action.C
        elif all_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_17(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.

    - Start cooperating (Action.C) in round 1.
    - For rounds 2 to r-1:
        * Detect defection by comparing observed stock with expected stock after all-cooperate round.
        * If defection detected in previous round, punish once by defecting (Action.D).
        * Then forgive and return to cooperating.
    - In last round r, defect to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishing = False
        self.last_stock = float(self.capacity)
        self.margin = self.capacity * 0.01

    def _expected_stock_after_coop(self, S_prev: float) -> float:
        """
        Compute expected stock after a round where all players cooperate,
        given starting stock S_prev.

        Formula:
            - consumption by all cooperating: S_prev / 2
            - stock after consumption: S_prev - S_prev/2 = S_prev/2
            - growth: 2 * (S_prev/2) * (1 - (S_prev/2)/capacity)
            - new stock = min(stock_after_consumption + growth, capacity)
        """
        half_stock = S_prev / 2
        growth = 2 * half_stock * (1 - half_stock / self.capacity)
        new_stock = half_stock + growth
        if new_stock > self.capacity:
            new_stock = self.capacity
        return new_stock

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            self.punishing = False
            self.last_stock = float(self.capacity)
            return Action.C
        if t == self.r:
            return Action.D
        prev_round_idx = t - 2
        my_prev_action_coop = history.my_actions[prev_round_idx]
        opp_prev_actions_coop = history.opponent_actions[prev_round_idx]
        c = int(my_prev_action_coop) + int(np.sum(opp_prev_actions_coop))
        d = self.n - c
        my_prev_payoff = history.my_payoffs[prev_round_idx]
        opp_prev_payoffs = history.opponent_payoffs[prev_round_idx]
        total_payoff = my_prev_payoff + np.sum(opp_prev_payoffs)
        denom = c + 2 * d
        if denom == 0:
            denom = 1
        S_prev = total_payoff * (2 * self.n) / denom
        expected_stock_after_coop = self._expected_stock_after_coop(S_prev)
        S_t_inferred = self.last_stock
        defection_detected = S_t_inferred < expected_stock_after_coop - self.margin
        self.last_stock = self._expected_stock_after_coop(S_prev)
        if self.punishing:
            self.punishing = False
            return Action.D
        if defection_detected:
            self.punishing = True
            self.punishing = False
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_18(BaseStrategy):
    """
    Conditional Grim with Forgiveness and Endgame Cooperation for the Common Pool Resource Game.

    - First round always cooperates.
    - Last round always defects.
    - In intermediate rounds:
      * Detect defection if any player defected last round.
      * If defection detected, enter forgiveness window:
        - Cooperate during forgiveness window to allow return to cooperation.
        - If forgiveness window expires without cooperation, punish by defecting.
      * If no defection detected or forgiven, cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_detected = False
        self.forgiveness_window = 0
        self.forgiveness_length = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        r = self.game_description.n_rounds
        if t == 1:
            self.defection_detected = False
            self.forgiveness_window = 0
            return Action.C
        if t == r:
            return Action.D
        if history is not None:
            prev_idx = t - 2
            all_last_actions = np.append(history.my_actions[prev_idx], history.opponent_actions[prev_idx])
            any_defected = not np.all(all_last_actions)
            if any_defected:
                self.defection_detected = True
                self.forgiveness_window = 0
                return Action.C
            elif self.defection_detected:
                self.forgiveness_window += 1
                if self.forgiveness_window > self.forgiveness_length:
                    return Action.D
                else:
                    self.defection_detected = False
                    self.forgiveness_window = 0
                    return Action.C
            else:
                return Action.C
        return Action.C

class Strategy_COOPERATIVE_19(BaseStrategy):
    """
    Gradual Trust-and-Sustain (GTS) strategy for the Common Pool Resource game.
    
    Implements a cooperative strategy that:
    - Starts by cooperating (round 1)
    - Sustains cooperation if all cooperated and stock is healthy
    - Forgives occasional defection if stock remains healthy (probabilistic cooperation)
    - Punishes defection by defecting when stock is moderately or critically low
    - Always defects in the last round to maximize immediate payoff
    - Uses stock thresholds (T_high=85% capacity, T_mid=50% capacity) to adapt behavior
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.T_high = 0.85 * self.capacity
        self.T_mid = 0.5 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == 1:
            S_t = self.capacity
        else:
            last_actions_all = [Action.C if x else Action.D for x in np.append(history.my_actions[-1], history.opponent_actions[-1])]
            n_C = sum((1 for a in last_actions_all if a == Action.C))
            n_D = self.n - n_C
            sum_payoffs = history.my_payoffs[-1] + np.sum(history.opponent_payoffs[-1])
            denom = 0.0
            if self.n > 0:
                denom = n_C / (2 * self.n) + n_D / self.n
            S_prev = sum_payoffs / denom if denom > 0 else self.capacity
            total_consumption = sum_payoffs
            stock_after_consumption = S_prev - total_consumption
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity) if stock_after_consumption > 0 else 0
            S_t = min(stock_after_consumption + growth, self.capacity)
        if t == self.r:
            return Action.D
        last_actions = np.append(history.my_actions[-1], history.opponent_actions[-1])
        defectors = np.count_nonzero(~last_actions)
        cooperators = self.n - defectors
        if S_t >= self.T_high:
            if defectors == 0:
                return Action.C
            elif random.random() < 0.8:
                return Action.C
            else:
                return Action.D
        elif self.T_mid <= S_t < self.T_high:
            if defectors == 0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_20(BaseStrategy):
    """
    Cooperative Strategy for Common Pool Resource Game.
    
    Implements conditional cooperation with proportional, temporary punishment of defectors,
    starting cooperative, punishing defectors for up to 3 rounds, and defecting in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_countdown = 0
        self.last_round_defectors = set()

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == self.r:
            self.punishment_countdown = 0
            self.last_round_defectors = set()
            return Action.D
        if t == 1:
            self.punishment_countdown = 0
            self.last_round_defectors = set()
            return Action.C
        if self.punishment_countdown > 0:
            self.punishment_countdown -= 1
            return Action.D
        previous_round = t - 2
        defectors_last = set()
        if not history.my_actions[previous_round]:
            defectors_last.add('self')
        for idx, opp_action_bool in enumerate(history.opponent_actions[previous_round]):
            if not opp_action_bool:
                defectors_last.add(idx)
        if len(defectors_last) == 0:
            self.last_round_defectors = set()
            return Action.C
        else:
            L = min(3, self.r - t)
            self.punishment_countdown = L
            self.last_round_defectors = defectors_last
            return Action.D

class Strategy_COOPERATIVE_21(BaseStrategy):
    """
    Forgiving Grim Trigger strategy for Common Pool Resource game.

    - Starts cooperating (C) in round 1.
    - On rounds 2 to r-1:
      - Cooperate if no defection by any player in previous round.
      - If any defection occurred, defect once as punishment, then return to cooperation.
    - On round r (last round):
      - Cooperate if no defection last round.
      - Defect if any defection last round (no forgiveness).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_next_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_next_round = False
            return Action.C
        t = history.round_number + 1
        if self.punish_next_round:
            self.punish_next_round = False
            return Action.D
        last_round_index = t - 2
        if last_round_index < 0:
            return Action.C
        opponents_last = history.opponent_actions[last_round_index]
        opponents_defected = np.any(opponents_last == False)
        self_defected = history.my_actions[last_round_index] == False
        any_defection = opponents_defected or self_defected
        if any_defection:
            if t < self.game_description.n_rounds:
                self.punish_next_round = True
                return Action.D
            else:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_22(BaseStrategy):
    """
    Cooperative strategy 'Conditional Cooperation with Forgiveness' for the Common Pool Resource Game.
    - Start by cooperating.
    - Punish any defection in the previous round by defecting.
    - Forgive if opponents return to cooperation after punishing.
    - In the final round, cooperate only if all opponents cooperated last round, else defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        last_opponent_acts = history.opponent_actions[history.round_number - 1]
        own_last_action = history.my_actions[history.round_number - 1]
        all_opponents_cooperated = np.all(last_opponent_acts == True)
        any_opponent_defected = not all_opponents_cooperated
        if t == self.r:
            if all_opponents_cooperated:
                return Action.C
            else:
                return Action.D
        if all_opponents_cooperated:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_23(BaseStrategy):
    """
    Cooperative two-round trigger strategy for the Common Pool Resource Game.

    Summary:
    - Round 1: Cooperate (C).
    - Rounds 2 to r-1: 
      * If all opponents cooperated last round, cooperate.
      * If any opponent defected last round, punish by defecting once.
      * Forgive after one round of punishment and return to cooperation.
    - Last round (r):
      * If previous round was fully cooperative, defect to maximize payoff.
      * Else defect anyway (no future rounds to consider).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        n = self.n
        r = self.r
        prev_idx = t - 2
        prev_opponent_actions = history.opponent_actions[prev_idx] if prev_idx >= 0 else None
        if prev_opponent_actions is None:
            return Action.C
        all_coop_prev = np.all(prev_opponent_actions) if prev_opponent_actions.size > 0 else True
        my_prev_action = history.my_actions[prev_idx]
        if t == 1:
            return Action.C
        elif 2 <= t < r:
            if all_coop_prev:
                return Action.C
            elif my_prev_action == Action.D.value or my_prev_action == False:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_24(BaseStrategy):
    """
    Conditional Grim Trigger with Forgiveness for Common Pool Resource Game.

    - Round 1: Always cooperate.
    - Rounds 2..r-1:
        * If any player defected last round: punish by defecting this round.
        * Else if just punished last round (defection detected two rounds ago): cooperate.
        * Else cooperate.
    - Round r (last round): always defect.

    Observes opponent actions history (boolean arrays).
    Uses only past two rounds of history to decide.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        if history.round_number == 0:
            return Action.C
        last_round_index = history.round_number - 1
        last_round_opponent_actions = history.opponent_actions[last_round_index]
        defection_detected_last = np.any(last_round_opponent_actions == False)
        if defection_detected_last:
            return Action.D
        if history.round_number >= 2:
            two_rounds_ago_index = history.round_number - 2
            two_rounds_ago_opponent_actions = history.opponent_actions[two_rounds_ago_index]
            defection_detected_two_rounds_ago = np.any(two_rounds_ago_opponent_actions == False)
            if defection_detected_two_rounds_ago:
                return Action.C
        return Action.C

class Strategy_COOPERATIVE_25(BaseStrategy):
    """
    Reciprocal Sustainable Cooperation (RSC) strategy for the Common Pool Resource game.

    - Start cooperating.
    - Cooperate as long as all opponents cooperated previous round.
    - Punish defections by defecting exactly once in the next round.
    - After punishment, return to cooperation if opponents cooperate.
    - Defect unconditionally on last round.
    - Defect once as a warning if stock below half capacity, to signal danger.
    - Cooperate if stock is zero to foster recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.capacity = float(self.game.capacity)
        self.warning_threshold = self.capacity / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        n = self.n
        r = self.r
        cap = self.capacity
        warn_th = self.warning_threshold
        if history is None:
            return Action.C
        last_idx = history.round_number - 1
        if t == r:
            return Action.D
        S_t = cap
        for round_i in range(history.round_number):
            actions_in_round = np.append(history.my_actions[round_i], history.opponent_actions[round_i])
            if round_i == 0:
                stock_before = cap
            else:
                stock_before = S_round
            count_C = np.count_nonzero(actions_in_round)
            count_D = n - count_C
            cons_C = stock_before / (2 * n)
            cons_D = stock_before / n
            total_consumption = count_C * cons_C + count_D * cons_D
            S_remaining = stock_before - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / cap)
            S_round = min(S_remaining + growth, cap)
        S_t = S_round
        opponents_last_actions = history.opponent_actions[last_idx]
        any_opponent_defected = not np.all(opponents_last_actions)
        my_last_action = history.my_actions[last_idx]
        if S_t == 0:
            return Action.C
        if S_t < warn_th:
            if my_last_action == Action.D.value:
                if not any_opponent_defected:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        if any_opponent_defected:
            if my_last_action == Action.D.value:
                if not any_opponent_defected:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_26(BaseStrategy):
    """
    Reciprocal Sustainability Strategy for Common Pool Resource Game.

    - Start cooperating.
    - If any defection detected last round, punish by defecting once.
    - Forgive after one-round punishment if no new defections.
    - If stock below half capacity, defect once as safeguard.
    - Defect in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.THRESHOLD_STOCK = self.capacity / 2
        self.LAST_ROUND = self.r
        self._punishment_state = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            S = self.capacity
        else:
            last_my_payoff = history.my_payoffs[-1]
            last_my_action = Action.C if history.my_actions[-1] else Action.D
            if last_my_action == Action.C:
                S = last_my_payoff * (2 * self.n)
            else:
                S = last_my_payoff * self.n
            if S > self.capacity:
                S = self.capacity
            if S < 0:
                S = 0
        if t == self.LAST_ROUND:
            self._punishment_state = False
            return Action.D
        if t == 1:
            self._punishment_state = False
            return Action.C
        last_round_opponent_actions = history.opponent_actions[t - 2]
        any_defection = any((not a for a in last_round_opponent_actions))
        if any_defection:
            self._punishment_state = True
            return Action.D
        if self._punishment_state:
            self._punishment_state = False
            return Action.C
        action = Action.C
        if S < self.THRESHOLD_STOCK and action == Action.C:
            return Action.D
        return action

class Strategy_COOPERATIVE_27(BaseStrategy):
    """
    Grim-trigger fully cooperative strategy for the Common Pool Resource Game.
    Cooperate initially and as long as all others cooperate, defect forever after
    detecting any opponent defection. Defect on the last round to maximize final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        round_num = history.round_number
        current_round = round_num + 1
        if current_round == self.r:
            return Action.D
        if np.any(history.opponent_actions == False):
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_28(BaseStrategy):
    """
    Cooperative "Grim Trigger with Stock Safety" Strategy for Common Pool Resource Game.

    - Start cooperating.
    - If any player ever defected before, defect forever (grim trigger).
    - Defect in last round always (no future incentive).
    - If stock dangerously low (below capacity/(2n)), defect temporarily to avoid collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n = self.n
        capacity = self.capacity
        stock = float(capacity)
        for past_round in range(t - 1):
            cooperator_count = 0
            cooperator_count += 1 if history.my_actions[past_round] else 0
            cooperator_count += np.sum(history.opponent_actions[past_round])
            defector_count = n - cooperator_count
            consumption = cooperator_count * (stock / (2 * n)) + defector_count * (stock / n)
            stock_remaining = stock - consumption
            if stock_remaining < 0:
                stock_remaining = 0.0
            growth = 2.0 * stock_remaining * (1.0 - stock_remaining / capacity)
            stock = min(stock_remaining + growth, capacity)
        if t == self.r:
            return Action.D
        own_defected = np.any(history.my_actions[:t - 1] == False)
        opp_defected = np.any(history.opponent_actions[:t - 1] == False)
        any_defection = own_defected or opp_defected
        if any_defection:
            return Action.D
        min_safe_stock = capacity / (2 * n)
        if stock < min_safe_stock:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_29(BaseStrategy):
    """
    Cooperative contingent strategy for the Common Pool Resource Game.

    - Cooperate initially.
    - If any defection is detected in the previous round, punish by defecting exactly one round.
    - Forgive after one punishment round and cooperate again.
    - Always defect in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_mode = False
        self.just_punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            self.punishment_mode = False
            self.just_punished = False
            return Action.C
        t = history.round_number + 1
        if t == r:
            self.punishment_mode = False
            self.just_punished = False
            return Action.D
        if self.punishment_mode:
            self.punishment_mode = False
            self.just_punished = True
            return Action.D
        if self.just_punished:
            self.just_punished = False
            return Action.C
        prev_round_index = t - 2
        if prev_round_index < 0:
            return Action.C
        if not np.all(history.opponent_actions[prev_round_index]):
            self.punishment_mode = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_30(BaseStrategy):
    """
    Conditional Cooperation with Gradual Punishment for the Common Pool Resource Game.

    - Starts cooperating to build trust and maintain stock.
    - If any defection occurred last round, defect once to punish.
    - Forgive after one punishment round if no new defection.
    - If stock is low (≤ capacity/(4n)), cooperate to aid recovery regardless.
    - Last round always defects to maximize final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_stock_low = self.capacity / (4 * self.n)
        self.punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punished = False
            return Action.C
        t = history.round_number + 1
        stock_t = None
        if t == 1:
            self.punished = False
            return Action.C
        last_round_payoffs = np.append(history.my_payoffs[-1], history.opponent_payoffs[-1])
        last_round_actions = np.append(np.array([history.my_actions[-1]]), history.opponent_actions[-1])
        max_payoff_last = np.max(last_round_payoffs)
        stock_prev = max_payoff_last * self.n
        n_coop = np.count_nonzero(last_round_actions)
        n_defect = self.n - n_coop
        tot_consump = n_coop * (stock_prev / (2 * self.n)) + n_defect * (stock_prev / self.n)
        stock_after = stock_prev - tot_consump
        stock_growth = 2 * stock_after * (1 - stock_after / self.capacity)
        stock_t = min(stock_after + stock_growth, self.capacity)
        D_last = np.any(history.opponent_actions[-1] == False)
        if t == self.r:
            self.punished = False
            return Action.D
        if stock_t <= self.threshold_stock_low:
            self.punished = False
            return Action.C
        if D_last:
            if self.punished:
                action = Action.C
                self.punished = False
            else:
                action = Action.D
                self.punished = True
        else:
            action = Action.C
            self.punished = False
        return action

class Strategy_COOPERATIVE_31(BaseStrategy):
    """
    Conditional cooperation strategy for the Common Pool Resource Game.
    Cooperates initially and while mutual cooperation and healthy stock prevail,
    punishes unilateral defections by defecting one round,
    then forgives and returns to cooperation if stock recovers.
    Defects on the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_threshold = self.capacity * 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        COOPERATE = True
        DEFECT = False
        n = self.n
        r = self.r
        capacity = self.capacity
        threshold = self.stock_threshold
        if history is None:
            return Action.C
        t = history.round_number + 1
        past_rounds = t - 1
        if past_rounds == 0:
            return Action.C
        my_acts = history.my_actions.reshape((past_rounds, 1))
        all_actions = np.concatenate((my_acts, history.opponent_actions), axis=1)

        def consumption_for_action(S, act_bool):
            return np.where(act_bool, S / (2 * n), S / n)
        S = capacity
        for round_idx in range(past_rounds):
            acts = all_actions[round_idx]
            consumed = consumption_for_action(S, acts)
            total_consumption = consumed.sum()
            S_after = S - total_consumption
            growth = 2 * S_after * (1 - S_after / capacity) if S_after > 0 else 0.0
            S = min(S_after + growth, capacity)
            if S < 0:
                S = 0.0
        S_t = S
        prev_acts = all_actions[-1]
        all_coop_prev = prev_acts.all()
        defector_idxs = [idx for idx, a in enumerate(prev_acts) if not a]
        n_defectors_prev = len(defector_idxs)
        i = 0
        my_last_action = prev_acts[i]
        if t == r:
            return Action.D
        if all_coop_prev and S_t >= threshold:
            return Action.C
        if n_defectors_prev > 0:
            if not my_last_action:
                if S_t >= threshold:
                    return Action.C
                else:
                    return Action.D
            return Action.D
        if S_t < threshold:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_32(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness and Endgame Defection Strategy for
    the Common Pool Resource Game.

    - Start cooperating.
    - Punish by defecting if any defection detected last round, until stock recovers.
    - Forgive and return to cooperation once stock recovers sufficiently.
    - Defect unconditionally in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_stock_threshold = 0.8 * self.capacity
        self.punish_recovery_threshold = 0.9 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        current_round = 1 if history is None else history.round_number + 1
        if history is None:
            return Action.C
        prev_round = current_round - 1
        my_last_action_bool = history.my_actions[-1]
        my_last_payoff = history.my_payoffs[-1]
        opp_last_actions = history.opponent_actions[-1]
        opp_last_payoffs = history.opponent_payoffs[-1]
        total_players = self.n
        last_round_actions = np.empty(total_players, dtype=bool)
        last_round_actions[0] = my_last_action_bool
        last_round_actions[1:] = opp_last_actions
        last_round_payoffs = np.empty(total_players, dtype=float)
        last_round_payoffs[0] = my_last_payoff
        last_round_payoffs[1:] = opp_last_payoffs
        c_count = np.sum(last_round_actions)
        d_count = total_players - c_count
        sum_payoffs = np.sum(last_round_payoffs)
        denom = c_count / (2 * total_players) + d_count / total_players
        if denom == 0:
            S_t = self.capacity
        else:
            S_t = sum_payoffs / denom
        if current_round == self.r:
            return Action.D
        defected_last_round = not np.all(last_round_actions)
        if defected_last_round:
            if S_t < self.punish_recovery_threshold:
                return Action.D
            else:
                return Action.C
        elif S_t >= self.cooperation_stock_threshold:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_33(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource Game:
    - Start by cooperating.
    - Cooperate if everyone cooperated in previous round.
    - If defection happened last round and this player hasn't punished yet, punish by defecting once.
    - Forgive one round of punishment if cooperation resumes.
    - Defect in final round to maximize last-round payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        all_cooperated_last = history.my_actions[t - 1] and np.all(history.opponent_actions[t - 1])
        punished_last_round = False
        if t >= 2:
            me_defected_last = not history.my_actions[t - 1]
            someone_defected_prev = not np.all(history.opponent_actions[t - 2]) or not history.my_actions[t - 2]
            punished_last_round = me_defected_last and someone_defected_prev
        if current_round == self.r:
            return Action.D
        if all_cooperated_last:
            if punished_last_round:
                return Action.C
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_34(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource Game.
    - Cooperates to maintain the stock near capacity.
    - Detects defections and punishes for 2 rounds by defecting.
    - After punishment, returns to cooperation if no new defection.
    - Always defects in last round to maximize terminal payoff.
    """
    PUNISH_LENGTH = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish = False
        self.punish_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        round_number = 1 if history is None else history.round_number + 1
        if round_number == 1:
            self.punish = False
            self.punish_rounds_left = 0
            return Action.C
        if round_number == r:
            self.punish = False
            self.punish_rounds_left = 0
            return Action.D
        prev_round_idx = round_number - 2
        prev_opponent_actions = history.opponent_actions[prev_round_idx] if prev_round_idx >= 0 else np.array([], dtype=bool)
        defect_detected = np.any(prev_opponent_actions == False)
        if self.punish:
            if self.punish_rounds_left > 1:
                self.punish_rounds_left -= 1
                return Action.D
            else:
                self.punish = False
                self.punish_rounds_left = 0
        if not self.punish:
            if defect_detected:
                self.punish = True
                self.punish_rounds_left = self.PUNISH_LENGTH
                return Action.C
            else:
                self.punish = False
                self.punish_rounds_left = 0
                return Action.C

class Strategy_COOPERATIVE_35(BaseStrategy):
    """
    Conditional Sustained Cooperation strategy for the Common Pool Resource Game.

    - Cooperates in round 1 to build trust.
    - If no defection detected last round, cooperates.
    - If defection detected last round, punishes by defecting once, then forgives.
    - Always defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_detected = False
        self.punishment_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            self.defection_detected = False
            self.punishment_round = False
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        prev_round = t - 2
        prev_actions = history.opponent_actions[prev_round] if prev_round >= 0 else np.array([], dtype=bool)
        defection_happened = np.any(prev_actions == False)
        if defection_happened:
            self.defection_detected = True
        if self.punishment_round:
            self.punishment_round = False
            self.defection_detected = False
            return Action.D
        if self.defection_detected:
            self.punishment_round = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_36(BaseStrategy):
    """
    Conditional cooperation strategy with forgiveness and monitoring for the Common Pool Resource game.
    
    - Start cooperating.
    - Cooperate if no defectors last round and stock not critically low.
    - Defect to punish if defections detected last round.
    - Always cooperate if stock critically low to avoid collapse.
    - Forgive after punishment if everyone cooperated in the punishment round.
    - Defect in final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        t = 1 if history is None else history.round_number + 1
        if history is None:
            return Action.C
        if t == r:
            return Action.D
        prev_round = t - 2
        all_payoffs_prev = np.append(history.my_payoffs[prev_round], history.opponent_payoffs[prev_round])
        total_consumption = all_payoffs_prev.sum()
        stock = capacity
        total_rounds_done = t - 1
        current_stock = capacity
        for rnd in range(total_rounds_done):
            actions_round = np.append(history.my_actions[rnd], history.opponent_actions[rnd])
            num_coop = np.count_nonzero(actions_round)
            num_defect = len(actions_round) - num_coop
            coop_consume = current_stock / (2 * n)
            defect_consume = current_stock / n
            total_consumption = num_coop * coop_consume + num_defect * defect_consume
            stock_after = current_stock - total_consumption
            growth = 2 * stock_after * (1 - stock_after / capacity)
            new_stock = stock_after + growth
            if new_stock > capacity:
                new_stock = capacity
            current_stock = new_stock
        Stock_t = current_stock
        past_actions = np.append(history.my_actions[-1], history.opponent_actions[-1])
        Defectors_prev = np.count_nonzero(past_actions == False)
        if Stock_t < capacity / (2 * n):
            return Action.C
        if Defectors_prev == 0:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_37(BaseStrategy):
    """
    Cooperative strategy "Sustained Reciprocity with Grace" for the Common Pool Resource Game.
    - Cooperate on first round.
    - If currently punishing (punish_timer > 0), defect and decrement punish_timer.
    - If not punishing, check history for any defection by any player; if found, start punishment.
    - Otherwise cooperate, except on last round where defect to maximize final payoff.
    """
    punish_rounds = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            self.punish_timer = 0
            return Action.C
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        past_rounds = t - 1
        any_defection_before = False
        if history is not None:
            if not np.all(history.my_actions):
                any_defection_before = True
            elif not np.all(history.opponent_actions):
                any_defection_before = True
        if any_defection_before:
            self.punish_timer = self.punish_rounds - 1
            return Action.D
        if t == r:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_38(BaseStrategy):
    """
    Cooperative strategy with limited punishment and forgiveness.
    - Starts cooperating.
    - Continues cooperating if all players cooperated last round.
    - Defects for punishment_length rounds if any defection detected last round.
    - After punishment, returns to cooperation.
    - Defects unconditionally in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_length = 2
        self.punishment_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        last_round = r
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == last_round:
            return Action.D
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        last_actions = history.opponent_actions[history.round_number - 1]
        if np.any(~last_actions):
            self.punishment_remaining = self.punishment_length - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_39(BaseStrategy):
    """
    Conditional cooperative strategy with forgiveness for a common pool resource game.
    
    - Cooperates initially.
    - Punishes any defection by defecting next round.
    - Forgives if defected previously but others have cooperated last round.
    - Cooperates strictly if the stock is below threshold (capacity / 4).
    - Defects unconditionally on the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.L = self.capacity / 4

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.D
        prev_round_idx = t - 2
        my_last_action = history.my_actions[prev_round_idx]
        my_last_payoff = history.my_payoffs[prev_round_idx]
        if my_last_action == Action.C.value:
            est_stock = my_last_payoff * 2 * self.n
        else:
            est_stock = my_last_payoff * self.n
        S_t = est_stock
        if S_t < self.L:
            return Action.C
        opp_last_actions = history.opponent_actions[prev_round_idx]
        my_last_bool = bool(my_last_action)
        all_last_actions = np.append(opp_last_actions, my_last_bool)
        defection_occurred = not np.all(all_last_actions)
        if not defection_occurred:
            return Action.C
        if my_last_bool:
            return Action.D
        elif np.all(opp_last_actions):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_40(BaseStrategy):
    """
    Forgiving trigger strategy for the Common Pool Resource game.

    Starts fully cooperative, punishes any defection once by defecting in the next round 
    as a warning, then returns to cooperation. In the last round defects unconditionally 
    to maximize final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.PunishmentActive = False
        self.DefectionCount = None
        self._initialized = False
        self.my_player_index = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if not self._initialized:
            self._initialized = True
            self.DefectionCount = [0] * (self.n - 1)
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if t == 1:
            self.PunishmentActive = False
            return Action.C
        if self.PunishmentActive:
            self.PunishmentActive = False
            return Action.D
        prev_round_idx = t - 2
        prev_opponent_actions = history.opponent_actions[prev_round_idx]
        defectors_indices = [j for j, acted_c in enumerate(prev_opponent_actions) if not acted_c]
        if defectors_indices:
            for d in defectors_indices:
                self.DefectionCount[d] += 1
            self.PunishmentActive = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_41(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness and End-Game Adjustment.

    Starts cooperating to promote mutual benefit.
    Punishes defectors in the round immediately following a defection by defecting.
    Forgives immediately if all cooperated in previous round.
    Defects unconditionally in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        last_round_idx = t - 2
        last_round_opponent_actions = history.opponent_actions[last_round_idx]
        defectors_exist = not last_round_opponent_actions.all()
        if defectors_exist:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_42(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness.

    Start cooperating immediately.
    Continue cooperating if all cooperated previous round.
    If any defected previously, punish by defecting k rounds.
    After punishment, resume cooperating.
    Defect on last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.k = 2
        self.punish_rounds_left = 0
        self.last_round_index = self.game.n_rounds - 1
        self.round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.round = 1
            self.punish_rounds_left = 0
            return Action.C
        self.round = history.round_number + 1
        if self.round == self.game.n_rounds:
            return Action.D
        if self.punish_rounds_left > 0:
            self.punish_rounds_left -= 1
            return Action.D
        last_round_idx = history.round_number - 1
        all_actions_last = [history.my_actions[last_round_idx]]
        if self.game.n_players > 1:
            all_actions_last.extend(history.opponent_actions[last_round_idx, :])
        if all(all_actions_last):
            return Action.C
        else:
            self.punish_rounds_left = self.k - 1
            return Action.D

class Strategy_COOPERATIVE_43(BaseStrategy):
    """
    Cooperative strategy for Common Pool Resource Game:
    - Start cooperating first round
    - From 2nd to (r-1)th rounds:
       * If all players cooperated last round, cooperate
       * If all defected last round, forgive by cooperating
       * Else, defect to punish
    - Last round: defect (endgame defection)
    - If stock critically low, defect unconditionally
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        current_stock = None
        S = self.capacity
        for past_round in range(history.round_number):
            coop_actions = history.opponent_actions[past_round]
            actions_all = np.append(history.my_actions[past_round], coop_actions)
            full_actions = np.empty(n, dtype=bool)
            full_actions[0] = history.my_actions[past_round]
            full_actions[1:] = coop_actions
            total_consumption = 0.0
            for a in full_actions:
                if a:
                    total_consumption += S / (2 * n)
                else:
                    total_consumption += S / n
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity) if S_remaining > 0 else 0
            S = min(S_remaining + growth, self.capacity)
        current_stock = S
        COOPERATE_CONSUMPTION = current_stock / (2 * n)
        DEFECT_CONSUMPTION = current_stock / n
        if current_stock < n * COOPERATE_CONSUMPTION:
            return Action.D
        if t == r:
            return Action.D
        last_round = history.round_number - 1
        last_actions_all = np.empty(n, dtype=bool)
        last_actions_all[0] = history.my_actions[last_round]
        last_actions_all[1:] = history.opponent_actions[last_round]
        num_defectors = np.sum(last_actions_all == False)
        num_cooperators = n - num_defectors
        if num_defectors == 0:
            return Action.C
        if num_defectors == n:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_44(BaseStrategy):
    """
    Sustained Cooperation with Forgiveness and Endgame Adjustment
    
    - Cooperate first round to build trust and stock.
    - Cooperate as long as no defection and stock is healthy.
    - If defectors detected last round, punish by defecting for one round.
    - Forgive after one punishment round by cooperating again.
    - If stock is low (below capacity/(4n)), cooperate to help recovery regardless of punishment state.
    - In last round, always defect since no future retaliation is possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_round = False
        self.punishment_counter = 0
        self.defectors_last_round = set()

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        if history is None:
            t = 1
            self.punishment_round = False
            self.punishment_counter = 0
            self.defectors_last_round = set()
            return Action.C
        t = history.round_number + 1
        if not hasattr(self, 'stock'):
            self.stock = float(capacity)
        else:
            last_round_idx = t - 2
            if last_round_idx >= 0 and last_round_idx < history.round_number:
                my_action_last = history.my_actions[last_round_idx]
                opp_actions_last = history.opponent_actions[last_round_idx]
                all_actions_last = [my_action_last] + list(opp_actions_last)
                if not hasattr(self, 'last_stock'):
                    self.last_stock = float(capacity)
                S_prev = self.last_stock
                num_cooperators = sum(all_actions_last)
                num_defectors = n - num_cooperators
                consumption = num_cooperators * (S_prev / (2 * n)) + num_defectors * (S_prev / n)
                stock_after_consumption = S_prev - consumption
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
                new_stock = min(stock_after_consumption + growth, capacity)
                self.stock = new_stock
                self.last_stock = new_stock
            else:
                self.stock = float(capacity)
                self.last_stock = float(capacity)
        S_t = self.stock
        STOCK_RECOVERY_THRESHOLD = capacity / (4 * n)
        if t > 1:
            last_round_idx = t - 2
            opp_actions_last = history.opponent_actions[last_round_idx]
            my_action_last = history.my_actions[last_round_idx]
            all_last_actions = [my_action_last] + list(opp_actions_last)
            self.defectors_last_round = set((idx for idx, act in enumerate(all_last_actions) if act is False))
        else:
            self.defectors_last_round = set()
        if t == r:
            self.punishment_round = False
            self.punishment_counter = 0
            return Action.D
        if S_t < STOCK_RECOVERY_THRESHOLD:
            self.punishment_round = False
            self.punishment_counter = 0
            return Action.C
        if self.punishment_round:
            self.punishment_counter -= 1
            if self.punishment_counter <= 0:
                self.punishment_round = False
            return Action.D
        if self.defectors_last_round:
            self.punishment_round = True
            self.punishment_counter = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_45(BaseStrategy):
    """
    Cooperative and resilient strategy for the repeated common pool resource game.
    - Round 1: Cooperate to signal cooperation.
    - Rounds 2 to r-1: Cooperate if no defections last round; else defect once to punish.
    - Last round: Defect to maximize immediate payoff.
    - If stock < n (dangerously low), defect to secure payoff.
    This strategy balances sustaining cooperation and punishing defection with forgiveness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        COOPERATE = Action.C
        DEFECT = Action.D
        if history is None:
            t = 1
            S_t = self.capacity
        else:
            t = history.round_number + 1
            stock = float(self.capacity)
            n = self.n
            capacity = self.capacity
            for round_idx in range(history.round_number):
                actions = history.my_actions[round_idx:round_idx + 1]
                own_action = history.my_actions[round_idx]
                opp_actions = history.opponent_actions[round_idx]
                all_actions = np.empty(n, dtype=bool)
                all_actions[0] = own_action
                all_actions[1:] = opp_actions
                coop_consumption = stock / (2 * n)
                defect_consumption = stock / n
                consumptions = np.where(all_actions, coop_consumption, defect_consumption)
                total_consumption = float(np.sum(consumptions))
                S_remaining = stock - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / capacity) if S_remaining > 0 else 0.0
                stock = min(S_remaining + growth, capacity)
            S_t = stock
        if S_t < self.n:
            return DEFECT
        if t == self.r:
            return DEFECT
        if t == 1:
            return COOPERATE
        prev_round_idx = t - 2
        prev_opp_actions = history.opponent_actions[prev_round_idx]
        prev_own_action = history.my_actions[prev_round_idx]
        any_defected = not prev_own_action or not np.all(prev_opp_actions)
        if any_defected:
            return DEFECT
        else:
            return COOPERATE

class Strategy_COOPERATIVE_46(BaseStrategy):
    """
    Sustainable Conditional Cooperation with Endgame Adjustment.

    - Cooperate initially.
    - Punish defectors by defecting once.
    - Forgive if cooperation resumes after punishment.
    - Adapt action based on current stock level with thresholds.
    - Defect in final round irrespective of stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_high = 0.8 * self.capacity
        self.S_low = 0.3 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:

        def reconstruct_stocks(history: PlayerHistory) -> list[float]:
            stocks = [float(self.capacity)]
            n = self.n
            cap = self.capacity
            for t_idx in range(history.round_number):
                S_prev = stocks[-1]
                all_actions = [history.my_actions[t_idx]] + list(history.opponent_actions[t_idx])
                consumption_per_player = 0.0
                total_consumption = 0.0
                for a in all_actions:
                    if a:
                        total_consumption += S_prev / (2 * n)
                    else:
                        total_consumption += S_prev / n
                S_remaining = S_prev - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / cap)
                S_new = min(S_remaining + growth, cap)
                stocks.append(S_new)
            return stocks
        if history is None:
            t = 1
            S_t = self.capacity
            return Action.C
        t = history.round_number + 1
        stocks = reconstruct_stocks(history)
        S_t = stocks[t - 1]
        n = self.n
        r = self.r
        S_high = self.S_high
        S_low = self.S_low
        if t == r:
            return Action.D
        prev_round_idx = t - 2
        if prev_round_idx >= 0:
            prev_actions_all = [history.my_actions[prev_round_idx]] + list(history.opponent_actions[prev_round_idx])
            defection_last_round = not all(prev_actions_all)
        else:
            defection_last_round = False
        punished_last_round = False
        if t - 2 >= 1:
            defection_two_rounds_ago = False
            check_idx = t - 3
            if check_idx >= 0:
                actions_two_rounds_ago = [history.my_actions[check_idx]] + list(history.opponent_actions[check_idx])
                defection_two_rounds_ago = not all(actions_two_rounds_ago)
            else:
                defection_two_rounds_ago = False
            my_action_last_round = history.my_actions[t - 2]
            if defection_two_rounds_ago and (not my_action_last_round):
                punished_last_round = True
        if defection_last_round:
            return Action.D
        if punished_last_round:
            last_round_idx = t - 2
            actions_last_round = [history.my_actions[last_round_idx]] + list(history.opponent_actions[last_round_idx])
            if all(actions_last_round):
                return Action.C
            else:
                return Action.D
        if S_t >= S_high:
            return Action.C
        elif S_low <= S_t < S_high:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_47(BaseStrategy):
    """
    Trigger-Grim with Forgiveness strategy for Common Pool Resource Game.
    Cooperates initially and as long as no opponent defects.
    Upon detecting any defection by opponents, punishes by defecting for T rounds.
    After punishment, forgives and returns to cooperation.
    Defects in the last round unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.T = 1
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            self.punish_counter = 0
            return Action.C
        if t == r:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_round_opponents = history.opponent_actions[t - 2]
        if not last_round_opponents.all():
            self.punish_counter = self.T - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_48(BaseStrategy):
    """
    Cooperative Common Pool Resource strategy with limited punishment.
    Cooperates initially to sustain the resource stock,
    defects only to punish detected defections for P=2 rounds,
    forgives after punishment phase, and defects on last round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 2
        self.punishment_count = 0
        self.punished_players = set()

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        n = self.game_description.n_players

        def observe_defections(H: PlayerHistory) -> set[int]:
            last_round_idx = H.round_number - 1
            defectors = set()
            opp_actions_last = H.opponent_actions[last_round_idx]
            for opp_i, a in enumerate(opp_actions_last, start=1):
                if a is False:
                    defectors.add(opp_i if opp_i < H.my_player_index else opp_i + 1)
            if H.my_actions[last_round_idx] is False:
                defectors.add(H.my_player_index)
            return defectors
        if history is None:
            self.punishment_count = 0
            self.punished_players.clear()
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        defectors = observe_defections(history)
        self.punished_players.update(defectors)
        if self.punishment_count > 0:
            self.punishment_count -= 1
            if self.punishment_count == 0:
                self.punished_players.clear()
            return Action.D
        elif len(defectors) > 0:
            self.punishment_count = self.P - 1
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_49(BaseStrategy):
    """
    Cooperative Strategy: Conditional Cooperation with Forgiveness.

    - Start by cooperating on round 1.
    - Cooperate if all opponents cooperated last round.
    - If any defection detected last round, enter a punishment phase defecting for a fixed length.
    - After punishment phase ends, forgive and return to cooperation.
    - On the last round, always defect to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_punish_length = 2
        self.punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        t = 1 if history is None else history.round_number + 1
        if t == r:
            return Action.D
        if t == 1:
            self.punishment_counter = 0
            return Action.C
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        last_round = t - 2
        opponent_last_actions = history.opponent_actions[last_round]
        any_defect = not np.all(opponent_last_actions)
        if any_defect:
            self.punishment_counter = self.defect_punish_length - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_50(BaseStrategy):
    """
    Cooperative tit-for-tat style strategy for the Common Pool Resource game.
    - Default: cooperate (C), consuming a cooperative share.
    - Detects defection if any opponent defected in previous round.
    - Punishes collectively by defecting (D) for p=2 rounds after detecting defection.
    - Forgives by returning to cooperation if no recent defection.
    - Always defects in the last round to maximize immediate payoff.
    - If stock is 0 at round start, continues cooperating (no payoff possible).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.gd = game_description
        self.n = self.gd.n_players
        self.r = self.gd.n_rounds
        self.capacity = self.gd.capacity
        self.punishment_length = 2
        self.punishment_counter = 0
        self.last_defection_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_counter = 0
            self.last_defection_round = 0
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if t > 1:
            payoffs_last = history.my_payoffs[-1] if history.my_payoffs.size > 0 else None
            opp_payoffs_last = history.opponent_payoffs[-1] if history.opponent_payoffs.shape[0] > 0 else None
            actions_last = np.empty(self.n, dtype=bool)
            actions_last[0] = history.my_actions[-1]
            if history.opponent_actions.shape[0] > 0:
                actions_last[1:] = history.opponent_actions[-1]
            else:
                actions_last[1:] = True
            payoffs_all_last = np.empty(self.n, dtype=np.float64)
            payoffs_all_last[0] = history.my_payoffs[-1] if history.my_payoffs.size > 0 else 0.0
            if opp_payoffs_last is not None:
                payoffs_all_last[1:] = opp_payoffs_last
            else:
                payoffs_all_last[1:] = 0.0
            estimated_stocks = np.where(actions_last, payoffs_all_last * 2 * self.n, payoffs_all_last * self.n)
            est_stock_t_minus_1 = np.median(estimated_stocks)
            total_consumption = np.sum(payoffs_all_last)
            stock_after_consumption = est_stock_t_minus_1 - total_consumption
            if stock_after_consumption < 0:
                stock_after_consumption = 0.0
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            new_stock = stock_after_consumption + growth
            if new_stock > self.capacity:
                new_stock = self.capacity
        else:
            new_stock = self.capacity
        if new_stock <= 1e-08:
            return Action.C
        if t > 1:
            last_opponent_actions = history.opponent_actions[t - 2]
            defected = np.any(last_opponent_actions == False)
            if defected:
                self.last_defection_round = t - 1
                self.punishment_counter = self.punishment_length
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_51(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource Game.
    Starts by cooperating, maintains cooperation as long as stock behaves as expected.
    Detects defections by comparing observed stock to expected stock under full cooperation,
    allowing a small tolerance delta. If defection or critical depletion detected,
    punishes by defecting for m rounds before forgiving and returning to cooperation.
    Unconditionally defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.delta = 0.01 * self.capacity
        self.m = 3
        self.punishment_rounds_left = 0
        self.prev_stock = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.prev_stock = float(self.capacity)
            self.punishment_rounds_left = 0
            return Action.C
        t = history.round_number
        actions_last = None
        payoffs_last = None
        if t > 0:
            my_a_last = history.my_actions[-1]
            opp_a_last = history.opponent_actions[-1]
            actions_last = np.empty(self.n, dtype=np.bool_)
            actions_last[0] = my_a_last
            actions_last[1:] = opp_a_last
            my_p_last = history.my_payoffs[-1]
            opp_p_last = history.opponent_payoffs[-1]
            payoffs_last = np.empty(self.n, dtype=np.float64)
            payoffs_last[0] = my_p_last
            payoffs_last[1:] = opp_p_last
        else:
            self.prev_stock = float(self.capacity)
            pass
        if t == 0:
            S_t = float(self.capacity)
        else:
            candidates = []
            for i in range(self.n):
                if actions_last[i]:
                    candidate = payoffs_last[i] * (2 * self.n)
                else:
                    candidate = payoffs_last[i] * self.n
                candidates.append(candidate)
            candidates = np.array(candidates)
            S_t = float(np.median(candidates))
            if S_t < 0:
                S_t = 0.0
            elif S_t > self.capacity:
                S_t = float(self.capacity)
        current_round = t + 1
        if self.prev_stock is None:
            self.prev_stock = float(self.capacity)
        S_prev = self.prev_stock
        self.prev_stock = S_t
        if current_round == 1:
            self.punishment_rounds_left = 0
            return Action.C
        if current_round == self.r:
            return Action.D
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        S_after_consumption = S_prev / 2
        growth = S_prev * (1 - S_prev / (2 * self.capacity))
        expected_stock_C = min(S_after_consumption + growth, self.capacity)
        if S_t < expected_stock_C - self.delta:
            self.punishment_rounds_left = self.m - 1
            return Action.D
        if S_t <= self.capacity / (4 * self.n):
            self.punishment_rounds_left = self.m - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_52(BaseStrategy):
    """
    Cooperative conditional strategy for the Common Pool Resource Game.
    Implements a tit-for-tat style cooperation with limited punishment,
    defecting on the last round, and defecting when stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.capacity = self.game.capacity
        self.punishment_length = 1
        self.depletion_threshold = 0.1 * self.capacity
        self.punish_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_rounds_remaining = 0
            return Action.C
        t = history.round_number + 1
        if t == 1:
            return Action.C
        last_round = t - 1
        my_last_action = history.my_actions[last_round - 1] if last_round - 1 >= 0 else True
        opponents_last_actions = history.opponent_actions[last_round - 1] if last_round - 1 >= 0 else np.ones(self.n - 1, dtype=bool)
        idx_last = last_round - 1
        if idx_last < 0:
            current_stock = self.capacity
        else:
            my_last_payoff = history.my_payoffs[idx_last]
            opponents_last_payoffs = history.opponent_payoffs[idx_last, :]
            all_last_payoffs = np.append(opponents_last_payoffs, my_last_payoff)
            total_consumption = all_last_payoffs.sum()
            my_last_action = history.my_actions[idx_last]
            opponents_last_actions = history.opponent_actions[idx_last]
            num_cooperators = int(np.sum(opponents_last_actions)) + (1 if my_last_action else 0)
            num_defectors = self.n - num_cooperators
            denom = num_cooperators + 2 * num_defectors
            if denom == 0:
                current_stock = 0
            else:
                S_last = total_consumption * 2 * self.n / denom
                stock_after_consumption = S_last - total_consumption
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                new_stock = stock_after_consumption + growth
                if new_stock > self.capacity:
                    new_stock = self.capacity
                current_stock = new_stock
        if t == self.r:
            return Action.D
        if current_stock <= self.depletion_threshold:
            return Action.D
        if self.punish_rounds_remaining > 0:
            self.punish_rounds_remaining -= 1
            return Action.D
        idx_last = t - 2
        if idx_last < 0:
            return Action.C
        opponents_last_actions = history.opponent_actions[idx_last]
        defectors_last_round = np.sum(~opponents_last_actions)
        my_last_action = history.my_actions[idx_last]
        if not my_last_action:
            defectors_last_round += 1
        if defectors_last_round == 0:
            return Action.C
        self.punish_rounds_remaining = self.punishment_length - 1
        return Action.D

class Strategy_COOPERATIVE_53(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource Game.
    Starts cooperating, punishes single-round defection with one round of defection,
    then forgives if all cooperate again. Adapts action to stock level,
    cooperating to protect the resource when stock is low.
    In the last round, defects if the stock is sufficient, else cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_stock = self.capacity / 2
        self.critical_stock = self.capacity / (4 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        round_t = 1 if history is None else history.round_number + 1
        n = self.n
        r = self.r
        capacity = self.capacity
        threshold = self.threshold_stock
        critical = self.critical_stock
        if history is None:
            return Action.C
        last_idx = history.round_number - 1
        if last_idx < 0:
            return Action.C
        last_opp_acts = history.opponent_actions[last_idx]
        my_last_action = history.my_actions[last_idx]
        all_actions_last = np.append(last_opp_acts, my_last_action)
        last_opp_payoffs = history.opponent_payoffs[last_idx]
        my_last_payoff = history.my_payoffs[last_idx]
        all_payoffs_last = np.append(last_opp_payoffs, my_last_payoff)
        any_defect_last = np.any(all_actions_last == False)
        if any_defect_last:
            defectors_idx = np.where(all_actions_last == False)[0]
            if defectors_idx.size == 0:
                estimated_stock = np.min(all_payoffs_last) * 2 * n
            else:
                max_def_payoff = np.max(all_payoffs_last[defectors_idx])
                estimated_stock = max_def_payoff * n
        else:
            estimated_stock = np.min(all_payoffs_last) * 2 * n
        S_t = estimated_stock
        punished_last_round = my_last_action == False and any_defect_last
        all_cooperated_last = np.all(all_actions_last)
        if S_t < critical:
            return Action.C
        if S_t < threshold:
            if all_cooperated_last:
                return Action.C
            elif not punished_last_round:
                return Action.D
            else:
                return Action.C
        if not all_cooperated_last:
            if not punished_last_round:
                return Action.D
            else:
                return Action.C
        if round_t < r:
            return Action.C
        if S_t >= critical:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_54(BaseStrategy):
    """
    Tit-for-Tat with Forgiveness and Endgame Cooperation for the Common Pool Resource Game.
    Cooperates first round, then cooperates if no defection last round.
    Punishes defections by defecting punish_length rounds.
    Forgives after punishment phase if no new defections.
    Defects in last endgame_rounds rounds.
    Monitors stock:
      - Cooperates if stock ≤ stock_threshold (to help recovery)
      - Defects if stock == 0 (resource extinct)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punish_length = 1
        self.stock_threshold = 1.5 * self.n
        self.endgame_rounds = 2
        self.punish_counter = 0
        self._last_defection_round = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            self.punish_counter = 0
            return Action.C
        prev_actions = []
        prev_payoffs = []
        if history is not None:
            prev_actions = np.concatenate(([history.my_actions[t - 2]], history.opponent_actions[t - 2]))
            prev_payoffs = np.concatenate(([history.my_payoffs[t - 2]], history.opponent_payoffs[t - 2]))
        else:
            prev_actions = np.array([True] * self.n)
            prev_payoffs = np.array([self.capacity / (2 * self.n)] * self.n)
        n = self.n
        c = np.count_nonzero(prev_actions)
        d = n - c
        sum_payoffs = float(np.sum(prev_payoffs))
        denom = c + 2 * d
        if denom == 0:
            stock = 0.0
        else:
            stock = sum_payoffs * (2 * n) / denom
            stock = min(max(stock, 0.0), self.capacity)
        if t > self.r - self.endgame_rounds:
            return Action.D
        if stock <= 0.0:
            return Action.D
        if stock <= self.stock_threshold:
            return Action.C
        any_defected = np.any(prev_actions == False)
        if self.punish_counter > 0:
            self.punish_counter -= 1
            if self.punish_counter == 0:
                if any_defected:
                    self.punish_counter = self.punish_length
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        elif any_defected:
            self.punish_counter = self.punish_length
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_55(BaseStrategy):
    """
    Conditional Cooperation with Gradual Punishment for the Common Pool Resource Game.

    Starts cooperating to sustain the common pool near capacity.
    Detects defections only when accompanied by significant stock depletion (below 90% capacity).
    Punishes defectors by defecting for a fixed number of rounds (punish_rounds=2).
    Forgives and returns to cooperation if no further defection detected.
    Always defects on the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.capacity = float(self.game.capacity)
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.punish_rounds = 2
        self.punishment_counter = 0
        self.last_stock: float | None = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_counter = 0
            self.last_stock = self.capacity
            return Action.C
        t = history.round_number
        if t > 0:
            total_consumption = np.sum(np.concatenate(([history.my_payoffs[-1]], history.opponent_payoffs[-1])))
            prev_stock = self.last_stock
            if prev_stock is None:
                prev_stock = self.capacity
            stock_after_consumption = prev_stock - total_consumption
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity) if stock_after_consumption > 0 else 0
            new_stock = min(stock_after_consumption + growth, self.capacity)
            self.last_stock = new_stock
        else:
            self.last_stock = self.capacity
        if t == self.r - 1:
            return Action.D
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        if t == 0:
            return Action.C
        last_opponent_actions = history.opponent_actions[t - 1]
        defectors = np.where(last_opponent_actions == False)[0]
        if len(defectors) > 0 and self.last_stock < 0.9 * self.capacity:
            self.punishment_counter = self.punish_rounds
            self.punishment_counter -= 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_56(BaseStrategy):
    """
    Conditional cooperation strategy with punishment and forgiveness for the
    Common Pool Resource Game. 
    
    - Round 1: Cooperate unconditionally.
    - Rounds 2 to r-1:
       * Cooperate if no opponents defected last round.
       * Otherwise defect to punish defectors.
       * If defected last round but observe all cooperated two rounds ago, forgive by cooperating.
    - Final round: always defect to maximize one-shot payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == 1:
            return Action.C
        if current_round == self.r:
            return Action.D
        last_actions_all = []
        player_index = 0
        last_round_idx = t - 1
        if last_round_idx < 0:
            return Action.C
        last_opponents = history.opponent_actions[last_round_idx]
        my_last_action = history.my_actions[last_round_idx]
        last_actions_all = []
        for i in range(self.n):
            if i == player_index:
                last_actions_all.append(my_last_action)
            elif i < player_index:
                last_actions_all.append(last_opponents[i])
            else:
                last_actions_all.append(last_opponents[i - 1])
        defectors_last = [j for j, a in enumerate(last_actions_all) if a is False and j != player_index]
        if len(defectors_last) == 0:
            return Action.C
        elif my_last_action is False:
            if current_round > 2:
                before_last_round_idx = t - 2
                before_last_opponents = history.opponent_actions[before_last_round_idx]
                my_before_last_action = history.my_actions[before_last_round_idx]
                before_last_actions_all = []
                for i in range(self.n):
                    if i == player_index:
                        before_last_actions_all.append(my_before_last_action)
                    elif i < player_index:
                        before_last_actions_all.append(before_last_opponents[i])
                    else:
                        before_last_actions_all.append(before_last_opponents[i - 1])
                others_cooperated_before_last = all((before_last_actions_all[j] is True for j in range(self.n) if j != player_index))
                if others_cooperated_before_last:
                    return Action.C
            return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_57(BaseStrategy):
    """
    Cooperative Strategy: Sustained Reciprocity with Endgame Awareness.

    - Cooperate initially to build trust.
    - Continue cooperating as long as no defection is observed.
    - If any defection by others is detected, defect for punishment_length rounds.
    - After punishment, return to cooperation.
    - Defect on the last round to maximize payoff.
    - Optionally, prioritize cooperation if stock is below threshold (capacity/4).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_length = 2
        self.punishment_counter = 0
        self.threshold = self.capacity / 4

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        S_t = self.capacity
        if t == self.r:
            return Action.D
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        if t == 1:
            return Action.C
        prev_round_idx = t - 2
        prev_opponent_actions = history.opponent_actions[prev_round_idx]
        if (prev_opponent_actions == False).any():
            self.punishment_counter = self.punishment_length - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_58(BaseStrategy):
    """
    Cooperative Strategy: Gradual Reciprocity with Forgiveness.

    - Round 1: Cooperate to build trust.
    - Rounds 2 to r-1:
      * If all players cooperated last round, cooperate.
      * If any defected last round:
        - Defect once as punishment in the immediately following round.
        - Forgive immediately after by cooperating.
    - Round r (last round): Defect to maximize final payoff.

    Uses perfect monitoring of all players' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        last_round_actions = np.append(opp_last_actions, my_last_action)
        all_cooperated_last_round = np.all(last_round_actions)
        if all_cooperated_last_round:
            return Action.C
        if current_round >= 3:
            two_rounds_back_idx = history.round_number - 2
            if two_rounds_back_idx >= 0:
                my_action_two_back = history.my_actions[two_rounds_back_idx]
                opp_actions_two_back = history.opponent_actions[two_rounds_back_idx]
                actions_two_back = np.append(opp_actions_two_back, my_action_two_back)
                some_defect_two_back = not np.all(actions_two_back)
            else:
                some_defect_two_back = False
        else:
            some_defect_two_back = False
        all_defect_last_round = np.all(~last_round_actions)
        punished_last_round = some_defect_two_back and all_defect_last_round
        if punished_last_round:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_59(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource Game.
    - Cooperate if everyone cooperated last round and not in punishment.
    - Detect any defection and start a punishment phase of fixed length.
    - During punishment, always defect to punish defectors.
    - After punishment, forgive and return to cooperation unless defection recurs.
    - On the last round, defect unconditionally to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_length = 2
        self.punishment_counter = 0
        self.defection_detected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        round_number = 1 if history is None else history.round_number + 1
        if history is None:
            self.punishment_counter = 0
            self.defection_detected = False
            return Action.C
        if round_number == r:
            return Action.D
        last_round_idx = round_number - 2
        last_round_self_action = history.my_actions[last_round_idx]
        last_round_opponent_actions = history.opponent_actions[last_round_idx]
        all_actions_last_round = np.append(last_round_opponent_actions, last_round_self_action)
        if not all(all_actions_last_round):
            self.defection_detected = True
        if self.defection_detected and self.punishment_counter == 0:
            self.punishment_counter = self.punishment_length
        if self.punishment_counter > 0:
            action = Action.D
            self.punishment_counter -= 1
            if self.punishment_counter == 0:
                self.defection_detected = False
            return action
        return Action.C

class Strategy_COOPERATIVE_60(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.
    
    Starts by cooperating, continues cooperating as long as all players
    cooperated previously. Upon observing any defection by anyone (including self),
    enters a punishment phase defecting for P=2 rounds.
    After punishment, returns to cooperation if no new defections.
    Defects on the last round to maximize immediate payoff.
    """
    PUNISHMENT_LENGTH = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t == 1:
            self.punishment_rounds_left = 0
            return Action.C
        if t == r:
            self.punishment_rounds_left = 0
            return Action.D
        if history.round_number < 1:
            self.punishment_rounds_left = 0
            return Action.C
        last_round_index = t - 2
        my_last = history.my_actions[last_round_index]
        opponents_last = history.opponent_actions[last_round_index]
        someone_defected = not my_last or not opponents_last.all()
        if someone_defected:
            if self.punishment_rounds_left < self.PUNISHMENT_LENGTH:
                self.punishment_rounds_left = self.PUNISHMENT_LENGTH
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_61(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource Game:
    - Start cooperating first round.
    - On detecting defection(s) among opponents in previous round, punish by defecting up to 2 rounds.
    - Forgive if opponents revert to cooperation.
    - Defect if resource stock is below critical threshold (capacity/4).
    - Defect on last round always.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._punishing = False
        self._punish_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        R = self.game_description.n_rounds
        capacity = self.game_description.capacity
        S_crit = capacity / 4
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            S_t = capacity
        else:
            S = capacity
            for round_i in range(history.round_number):
                opp_acts = history.opponent_actions[round_i]
                my_act = history.my_actions[round_i]
                n_coop = int(np.sum(opp_acts)) + (1 if my_act else 0)
                n_defect = n - n_coop
                coop_consume = S / (2 * n)
                defect_consume = S / n
                total_consumption = n_coop * coop_consume + n_defect * defect_consume
                S_remaining = S - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / capacity)
                S = min(S_remaining + growth, capacity)
            S_t = S
        if t == R:
            self._punishing = False
            self._punish_count = 0
            return Action.D
        if t == 1:
            self._punishing = False
            self._punish_count = 0
            return Action.C
        prev_round = t - 2
        prev_opp_acts = history.opponent_actions[prev_round]
        OppDefect = np.any(prev_opp_acts == False)
        if S_t < S_crit:
            return Action.D
        if not self._punishing:
            if not OppDefect:
                self._punishing = False
                self._punish_count = 0
                return Action.C
            else:
                self._punishing = True
                self._punish_count = 1
                return Action.D
        elif not OppDefect:
            self._punishing = False
            self._punish_count = 0
            return Action.C
        elif self._punish_count < 2:
            self._punish_count += 1
            return Action.D
        else:
            self._punishing = False
            self._punish_count = 0
            return Action.C

class Strategy_COOPERATIVE_63(BaseStrategy):
    """
    Conditional Gentle Cooperation with Forgiveness and Final Round Defection.

    - Start cooperating.
    - If any opponent defected last round, start 2-round punishment defecting.
    - After punishment rounds, forgive (cooperate again).
    - On last round, always defect.
    - If stock is very low (below number of players), cooperate to help recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.punish_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        last_round = r
        if history is None or history.round_number == 0:
            self.punish_rounds_remaining = 0
            return Action.C
        t = history.round_number
        current_round = t + 1
        last_round_idx = t - 1
        opponents_last_actions = history.opponent_actions[last_round_idx]
        defect_detected = np.any(opponents_last_actions == False)
        if current_round == last_round:
            return Action.D
        if self.punish_rounds_remaining > 0:
            self.punish_rounds_remaining -= 1
            return Action.D
        if defect_detected and self.punish_rounds_remaining == 0:
            self.punish_rounds_remaining = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_64(BaseStrategy):
    """
    Conditional Cooperation + Punishment + Forgiveness + Endgame Defection strategy
    for the Common Pool Resource Game.
    
    - Round 1: Cooperate to build trust.
    - Intermediate rounds: 
      - Monitor others' actions last round.
      - If anyone defected last round, start/continue punishment by defecting for punishment_rounds.
      - Otherwise cooperate.
    - Last round: defect for immediate payoff (no future retaliation).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.punishment_rounds = 2
        self.punishment_counter = 0
        self.defector_detected = False
        self.defectors_in_last_round = set()

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == self.r:
            return Action.D
        if t == 1:
            self.punishment_counter = 0
            self.defector_detected = False
            self.defectors_in_last_round = set()
            return Action.C
        last_round_idx = t - 2
        defectors = set()
        for opp_i in range(self.n - 1):
            if not history.opponent_actions[last_round_idx, opp_i]:
                defectors.add(opp_i)
        if defectors:
            self.defector_detected = True
            self.punishment_counter = self.punishment_rounds
            self.defectors_in_last_round = defectors
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_65(BaseStrategy):
    """
    Conditional Fair Cooperation with Forgiveness strategy for the Common Pool Resource game.

    - Start cooperating in round 1.
    - Infer opponents' previous round actions from their payoffs.
    - Punish defectors by defecting for P=2 rounds after detecting defection.
    - Forgive after punishment window expires.
    - Defect always in the last round to maximize final payoff.
    """
    P = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punish_until = dict()

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        P = self.P
        capacity = self.capacity
        if history is None:
            self.punish_until.clear()
            return Action.C
        t = history.round_number + 1
        if t > r:
            return Action.D
        if t == 1:
            self.punish_until.clear()
            return Action.C
        prev_idx = t - 2
        opp_payoffs_prev = history.opponent_payoffs[prev_idx]
        if len(opp_payoffs_prev) == 0:
            stock_prev = capacity
        else:
            max_payoff = np.max(opp_payoffs_prev)
            stock_prev = max_payoff * n
        if stock_prev > capacity:
            stock_prev = capacity
        if stock_prev <= 0:
            stock_prev = 1e-09
        threshold_mid = stock_prev * 3 / (4 * n)
        for opp_idx, payoff_j in enumerate(opp_payoffs_prev):
            action_j = Action.C if payoff_j < threshold_mid else Action.D
            if action_j == Action.D:
                old_punish = self.punish_until.get(opp_idx, 0)
                new_punish = t + P - 1
                if new_punish > old_punish:
                    self.punish_until[opp_idx] = new_punish
            else:
                pass
        active_punishment = False
        for opp_idx, until_round in self.punish_until.items():
            if until_round >= t:
                active_punishment = True
                break
        if t == r:
            return Action.D
        if active_punishment:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_66(BaseStrategy):
    """
    Gradual Conditional Cooperation with Last Round Defect strategy for Common Pool Resource Game.

    - Round 1: Cooperate to start cooperation.
    - Intermediate rounds (2 to r-1): 
        * If no defections last round, cooperate.
        * If any defections last round, defect to punish defectors.
        * Players who defected last round continue defecting as self-punishment.
    - Last round (r): Defect unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_round_idx = t - 2
        prev_opponent_actions = history.opponent_actions[prev_round_idx]
        defectors = [i for i, coop in enumerate(prev_opponent_actions) if not coop]
        my_last_action = history.my_actions[prev_round_idx]
        my_id = None
        full_prev_actions = np.empty(self.n, dtype=bool)
        has_defection_last = len(defectors) > 0 or not my_last_action
        if not has_defection_last:
            return Action.C
        if not my_last_action:
            return Action.D
        return Action.D

class Strategy_COOPERATIVE_67(BaseStrategy):
    """
    Cooperative strategy for Common Pool Resource game.
    Starts cooperating, punishes defection with defection next round,
    forgives if others return to cooperation, defects if stock is low,
    and defects in the last round (endgame).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.low_stock_threshold = 0.3

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if history is None:
            return Action.C
        if t == self.r:
            return Action.D
        stocks = [float(self.capacity)]
        for past_round in range(history.round_number):
            old_stock = stocks[-1]
            num_opponents = self.n - 1
            coop_count = np.sum(history.opponent_actions[past_round]) + (1 if history.my_actions[past_round] else 0)
            defect_count = self.n - coop_count
            c_consume = old_stock / (2 * self.n)
            d_consume = old_stock / self.n
            total_consumption = coop_count * c_consume + defect_count * d_consume
            stock_after_cons = old_stock - total_consumption
            if stock_after_cons < 0:
                stock_after_cons = 0.0
            growth = 2 * stock_after_cons * (1 - stock_after_cons / self.capacity)
            new_stock = stock_after_cons + growth
            if new_stock > self.capacity:
                new_stock = self.capacity
            stocks.append(new_stock)
        S_t = stocks[-1]
        last_round = t - 1
        if last_round > 0:
            last_round_opponent_actions = history.opponent_actions[last_round - 1]
            defected_last_round = not np.all(last_round_opponent_actions)
        else:
            defected_last_round = False
        low_stock = S_t <= self.low_stock_threshold * self.capacity
        if low_stock:
            return Action.D
        if defected_last_round:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_68(BaseStrategy):
    """
    Cooperative strategy "Sustained Reciprocity with Punishment and Endgame Adjustment"
    for the Common Pool Resource Game.

    - Cooperate initially.
    - Defect permanently if any defection detected in previous rounds.
    - Defect in the last round to maximize individual payoff.
    - Defect if stock is below 10% capacity to protect own payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.low_stock_threshold = 0.1 * self.capacity
        self.endgame_rounds = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        opponent_defections = np.any(history.opponent_actions == False, axis=None)
        self_defections = np.any(history.my_actions == False)
        defected = opponent_defections or self_defections
        S = self.capacity
        for round_idx in range(t - 1):
            total_consumption = history.my_payoffs[round_idx]
            if history.opponent_payoffs.shape[0] > round_idx:
                total_consumption += np.sum(history.opponent_payoffs[round_idx])
            S_remaining = S - total_consumption
            if S_remaining < 0:
                S_remaining = 0.0
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S = min(S_remaining + growth, self.capacity)
        S_t = S
        if defected:
            pass
        if t > self.r - self.endgame_rounds:
            return Action.D
        if defected:
            return Action.D
        if S_t < self.low_stock_threshold:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_69(BaseStrategy):
    """
    Conditional cooperation strategy for the Common Pool Resource game.
    Implements a tit-for-tat style punishment delayed by one round:
    - Start cooperating.
    - If any defection observed last round, cooperate this round but set punishment flag.
    - Next round punish by defecting once, then return to cooperation.
    - On last round, defect if punishing or if defection detected last round to punish/maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.punishment_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game.n_rounds
        n = self.game.n_players
        if history is None:
            self.punishment_flag = False
            return Action.C
        t = history.round_number + 1
        last_round_index = t - 2
        last_opponent_actions = history.opponent_actions[last_round_index] if last_round_index >= 0 else np.array([], dtype=bool)
        last_defectors = np.sum(~last_opponent_actions)
        last_my_action = history.my_actions[last_round_index] if last_round_index >= 0 else True
        total_defectors_last_round = last_defectors + (0 if last_my_action else 1)
        if self.punishment_flag:
            self.punishment_flag = False
            return Action.D
        if total_defectors_last_round > 0:
            if t == r:
                return Action.D
            else:
                self.punishment_flag = True
                return Action.C
        return Action.C

class Strategy_COOPERATIVE_70(BaseStrategy):
    """
    Reactive cooperation with limited punishment and endgame defection for the 
    Common Pool Resource Game:
    
    - Start by cooperating.
    - If any defection observed last round, punish for exactly one round by defecting.
    - Otherwise, cooperate to sustain the stock near capacity.
    - In last 25% rounds: defect to maximize immediate payoff unless stock < 0.5*capacity,
      then cooperate cautiously to avoid collapse.
    - Track punishments per defector with memory to avoid endless defection cycles.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = game_description.n_players
        self.punish_until_round = {i: 0 for i in range(1, n + 1)}

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is None:
            return Action.C
        t = history.round_number + 1

        def compute_stock_after_round(round_index: int) -> float:
            if round_index < 0:
                return capacity
            prev_stock = compute_stock_after_round(round_index - 1)
            my_act = history.my_actions[round_index]
            opp_acts = history.opponent_actions[round_index]
            all_actions = [my_act] + list(opp_acts)
            c_consumption = 0.0
            total_consumption = 0.0
            for act in all_actions:
                if act:
                    total_consumption += prev_stock / (2 * n)
                else:
                    total_consumption += prev_stock / n
            S_remaining = prev_stock - total_consumption
            if S_remaining < 0:
                S_remaining = 0.0
            growth = 2 * S_remaining * (1 - S_remaining / capacity)
            new_stock = S_remaining + growth
            if new_stock > capacity:
                new_stock = float(capacity)
            return new_stock
        S_t = compute_stock_after_round(t - 2) if t > 1 else capacity
        defectors = []
        if not history.my_actions[t - 2]:
            defectors.append(1)
        for idx, act in enumerate(history.opponent_actions[t - 2], start=2):
            if not act:
                defectors.append(idx)
        for defector in defectors:
            self.punish_until_round[defector] = t
        player_i = 1
        max_punish_round = max(self.punish_until_round.values()) if self.punish_until_round else 0
        defection_in_last_round = len(defectors) > 0
        punishment_active = defection_in_last_round and t <= max_punish_round
        endgame_start = r - (r + 3) // 4 + 1
        in_endgame = t >= endgame_start
        low_stock = S_t < 0.5 * capacity
        if in_endgame:
            if low_stock:
                action = Action.C
            else:
                action = Action.D
        elif punishment_active:
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_COOPERATIVE_71(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource game.
    - Start cooperating.
    - Punish any defection in the previous round by defecting once.
    - Forgive immediately if no subsequent defection.
    - Defect unconditionally on the last round.
    - If stock falls below 20% capacity, always cooperate to aid recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        current_round = history.round_number + 1 if history is not None else 1
        STOCK_RECOVERY_THRESHOLD = 0.2 * self.capacity
        if history is None:
            return Action.C
        current_stock = getattr(history, 'current_stock', self.capacity)
        if current_round == self.r:
            return Action.D
        if current_stock < STOCK_RECOVERY_THRESHOLD:
            return Action.C
        previous_round_index = current_round - 2
        opponents_last_round = history.opponent_actions[previous_round_index]
        if np.any(opponents_last_round == False):
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_72(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource game.

    - Cooperates on first round.
    - Cooperates if everyone cooperated last round and not in punishment.
    - Defects for a fixed number of rounds (MAX_PUNISH_ROUNDS=2) to punish after detecting defection.
    - Forgives and returns to cooperation after punishment rounds expire.
    - Cooperates if stock very low (≤ 2*n_players) to preserve resource.
    - Defects on last round to maximize immediate payoff.
    """
    MAX_PUNISH_ROUNDS = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._punishment_triggered = False
        self._punishment_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        capacity = self.game_description.capacity
        S_t = capacity
        if history is not None and history.round_number > 0:
            for round_idx in range(t - 1):
                all_actions_bool = np.empty(n, dtype=bool)
                all_actions_bool[0] = history.my_actions[round_idx]
                all_actions_bool[1:] = history.opponent_actions[round_idx]
                if round_idx == 0:
                    stock = capacity
                else:
                    stock = S_after_growth
                consume = np.where(all_actions_bool, stock / (2 * n), stock / n)
                total_consumption = np.sum(consume)
                S_after_consume = stock - total_consumption
                growth = 2 * S_after_consume * (1 - S_after_consume / capacity)
                S_after_growth = min(S_after_consume + growth, capacity)
            S_t = S_after_growth
        if t == 1:
            self._punishment_triggered = False
            self._punishment_rounds = 0
            return Action.C
        if t == r:
            return Action.D
        if S_t <= 2 * n:
            self._punishment_triggered = False
            self._punishment_rounds = 0
            return Action.C
        last_actions_bool = history.opponent_actions[history.round_number - 1]
        my_last_action = history.my_actions[history.round_number - 1]
        all_last_actions = np.empty(n, dtype=bool)
        all_last_actions[0] = my_last_action
        all_last_actions[1:] = last_actions_bool
        defectors_last_round = np.where(all_last_actions == False)[0]
        all_cooperate_last_round = len(defectors_last_round) == 0
        if not all_cooperate_last_round:
            self._punishment_triggered = True
            self._punishment_rounds = 1
            return Action.D
        if self._punishment_triggered:
            if self._punishment_rounds < self.MAX_PUNISH_ROUNDS:
                self._punishment_rounds += 1
                return Action.D
            else:
                self._punishment_triggered = False
                self._punishment_rounds = 0
                return Action.C
        return Action.C

class Strategy_COOPERATIVE_73(BaseStrategy):
    """
    Fully cooperative trigger strategy for Common Pool Resource Game.
    
    - Start cooperating.
    - Detect any defection by others last round → punish by defecting for fixed rounds.
    - Forgive after punishment if cooperation resumes.
    - On last round, defect if punishing or defection detected last round, else cooperate.
    - Always prefer cooperation to sustain resource stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds = 2
        self.threshold_stock_high = 0.9 * game_description.capacity
        self.threshold_stock_low = 0.5 * game_description.capacity
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is None or history.round_number == 0:
            self.punish_timer = 0
            return Action.C
        current_round = history.round_number + 1
        last_round = history.round_number - 1
        my_last_action = history.my_actions[last_round]
        my_last_payoff = history.my_payoffs[last_round]
        if my_last_action:
            S_t = my_last_payoff * (2 * n)
        else:
            S_t = my_last_payoff * n
        last_opponent_actions = history.opponent_actions[last_round]
        defection_detected = np.any(last_opponent_actions == False)
        if self.punish_timer > 0:
            self.punish_timer -= 1
            if current_round == r:
                return Action.D
            else:
                return Action.D
        if defection_detected:
            self.punish_timer = self.punishment_rounds - 1
            if current_round == r:
                return Action.D
            return Action.D
        if current_round == r:
            return Action.C
        if S_t >= self.threshold_stock_high:
            return Action.C
        if S_t >= self.threshold_stock_low:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_74(BaseStrategy):
    """
    Conditional cooperation with one-round punishment and endgame defection
    for the Common Pool Resource Game.

    - Round 1: Cooperate
    - Intermediate rounds (2 to r-1):
        * Defect if any defection occurred last round (punish one round)
        * Else cooperate regardless of stock level
    - Last round (r): Defect

    Uses history of all players' actions to detect defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.capacity = game_description.capacity
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.threshold_low = self.capacity / 2
        self.T_defect_punish = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        last_round_idx = t - 2
        if last_round_idx < 0:
            return Action.C
        my_a_last = history.my_actions[last_round_idx]
        opp_a_last = history.opponent_actions[last_round_idx]
        all_actions_last = np.append(opp_a_last, my_a_last)
        all_actions_last = all_actions_last.astype(bool)
        my_payoff_last = history.my_payoffs[last_round_idx]
        opp_payoffs_last = history.opponent_payoffs[last_round_idx]
        all_payoffs_last = np.append(opp_payoffs_last, my_payoff_last)
        coop_mask = all_actions_last == True
        defect_mask = ~coop_mask
        S_candidates = []
        if np.any(coop_mask):
            coop_payoffs = all_payoffs_last[coop_mask]
            S_from_coops = coop_payoffs * 2 * self.n
            S_candidates.append(np.mean(S_from_coops))
        if np.any(defect_mask):
            defect_payoffs = all_payoffs_last[defect_mask]
            S_from_defects = defect_payoffs * self.n
            S_candidates.append(np.mean(S_from_defects))
        if len(S_candidates) == 0:
            S_prev = self.capacity
        else:
            S_prev = np.mean(S_candidates)
        total_consumption = np.sum(all_payoffs_last)
        S_remaining = S_prev - total_consumption
        growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
        S_t = min(S_remaining + growth, self.capacity)
        defectors_in_last_round = np.sum(~all_actions_last)
        if t == 1:
            return Action.C
        elif t == self.r:
            return Action.D
        elif defectors_in_last_round > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_75(BaseStrategy):
    """
    Conditional cooperate with forgiveness and last-round defection.

    Starts cooperating, punishes defectors by defecting for a fixed number of rounds,
    forgives after punishment, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 2
        self._punishing = False
        self._punish_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        t = 0 if history is None else history.round_number
        if t == r - 1:
            return Action.D
        if t > 0:
            if not self._punishing:
                prev_round_opponents = history.opponent_actions[t - 1]
                if not np.all(prev_round_opponents):
                    self._punishing = True
                    self._punish_rounds_left = self.P
        if self._punishing:
            action = Action.D
            self._punish_rounds_left -= 1
            if self._punish_rounds_left == 0:
                self._punishing = False
            return action
        return Action.C

class Strategy_COOPERATIVE_76(BaseStrategy):
    """
    Sustained Mutual Cooperation with Graduated Punishment.

    Cooperate initially and as long as no defections observed.
    Upon observing opponent defections, punish by defecting for a number of rounds proportional
    to number of defectors times punishment_length_per_defection.
    Return to cooperation if no further defections.
    Always defect in the last round for maximal immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_length_per_defection = 2
        self.punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None:
            self.punishment_rounds_left = 0
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        last_round = t - 2
        if last_round < 0:
            return Action.C
        last_opponent_actions = history.opponent_actions[last_round]
        d_count = np.sum(~last_opponent_actions)
        if d_count == 0:
            return Action.C
        else:
            self.punishment_rounds_left = d_count * self.punishment_length_per_defection - 1
            return Action.D

class Strategy_COOPERATIVE_77(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource Game:
    - Cooperate initially and as long as no defections detected.
    - If any defection detected in past rounds, punish by defecting for 1 round.
    - After punishment, forgive and return to cooperation.
    - Always defect in the last round (finite horizon incentive).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_detected = False
        self.punishment_rounds = 0
        self.max_punishment = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            self.defection_detected = False
            self.punishment_rounds = 0
            return Action.C
        t = history.round_number + 1
        if not self.defection_detected:
            if not np.all(history.opponent_actions):
                self.defection_detected = True
        if t == r:
            return Action.D
        if not self.defection_detected:
            return Action.C
        elif self.punishment_rounds < self.max_punishment:
            self.punishment_rounds += 1
            return Action.D
        else:
            self.defection_detected = False
            self.punishment_rounds = 0
            return Action.C

class Strategy_COOPERATIVE_78(BaseStrategy):
    """
    Tit-for-Tat with Threshold Trigger and Forgiveness for Common Pool Resource Game.

    Implements a cooperative strategy that starts cooperating,
    punishes detected defections for one round by defecting,
    then forgives and returns to cooperation if defection stops,
    and defects unconditionally in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D

        def reconstruct_stock_history():
            stock_hist = [capacity]
            for i in range(t - 1):
                actions_i = np.empty(n, dtype=np.bool_)
                actions_i[:n - 1] = history.opponent_actions[i]
                actions_i[-1] = history.my_actions[i]
                payoffs_i = np.empty(n, dtype=np.float64)
                payoffs_i[:n - 1] = history.opponent_payoffs[i]
                payoffs_i[-1] = history.my_payoffs[i]
                coop_payoffs = payoffs_i[actions_i]
                defect_payoffs = payoffs_i[~actions_i]
                if len(defect_payoffs) > 0:
                    S_from_defect = defect_payoffs.max() * n
                else:
                    S_from_defect = None
                if len(coop_payoffs) > 0:
                    S_from_coop = coop_payoffs.min() * 2 * n
                else:
                    S_from_coop = None
                if S_from_defect is not None and S_from_coop is not None:
                    S_i = (S_from_defect + S_from_coop) / 2
                elif S_from_defect is not None:
                    S_i = S_from_defect
                elif S_from_coop is not None:
                    S_i = S_from_coop
                else:
                    S_i = stock_hist[-1]
                total_consumption = payoffs_i.sum()
                stock_after_cons = S_i - total_consumption
                growth = 2 * stock_after_cons * (1 - stock_after_cons / capacity)
                new_stock = stock_after_cons + growth
                if new_stock > capacity:
                    new_stock = capacity
                stock_hist.append(new_stock)
            return stock_hist
        stock_history = reconstruct_stock_history()
        prev_stock = stock_history[t - 2]
        cur_stock = stock_history[t - 1]
        last_round_actions = np.empty(n, dtype=np.bool_)
        last_round_actions[:n - 1] = history.opponent_actions[t - 2]
        last_round_actions[-1] = history.my_actions[t - 2]
        num_defectors = np.count_nonzero(~last_round_actions)
        consumption_coop = prev_stock / (2 * n)
        total_consumption_coop = n * consumption_coop
        stock_after_consume = prev_stock - total_consumption_coop
        growth = 2 * stock_after_consume * (1 - stock_after_consume / capacity)
        expected_stock = stock_after_consume + growth
        if expected_stock > capacity:
            expected_stock = capacity
        stock_drop_threshold = 0.95 * expected_stock
        I_last_round_action = history.my_actions[t - 2]
        if num_defectors >= 1 or cur_stock < stock_drop_threshold:
            return Action.D
        elif I_last_round_action == False:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_79(BaseStrategy):
    """
    Cooperative Tit-for-Tat strategy for the Common Pool Resource game.
    
    Summary:
    - Round 1: Cooperate to signal trust.
    - Rounds 2 to r-1: 
        - If any opponent defected in previous round, defect this round (punishment).
        - Otherwise cooperate.
        - If common pool stock is below half capacity, cooperate to help recovery.
    - Last round (r): Defect unconditionally to maximize immediate payoff.
    
    Implements a simple punishment-forgiveness cycle to sustain cooperation
    and preserve the common pool resource through repeated play.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game.n_rounds
        n = self.game.n_players
        capacity = self.game.capacity
        if t == 1:
            S_t = capacity
        else:
            prev_opponent_payoffs = history.opponent_payoffs[t - 2]
            prev_opponent_actions = history.opponent_actions[t - 2]
            if len(prev_opponent_payoffs) > 0:
                inds_c = np.flatnonzero(prev_opponent_actions)
                inds_d = np.flatnonzero(~prev_opponent_actions)
                S_estimates = []
                if inds_c.size > 0:
                    payoff_c = prev_opponent_payoffs[inds_c[0]]
                    S_estimates.append(payoff_c * 2 * n)
                if inds_d.size > 0:
                    payoff_d = prev_opponent_payoffs[inds_d[0]]
                    S_estimates.append(payoff_d * n)
                if len(S_estimates) > 0:
                    S_t = float(np.mean(S_estimates))
                    if S_t < 0:
                        S_t = 0.0
                    elif S_t > capacity:
                        S_t = float(capacity)
                else:
                    S_t = float(capacity)
            else:
                S_t = float(capacity)
        if t == r:
            return Action.D
        if t == 1:
            pass
        else:
            prev_opponent_actions = history.opponent_actions[t - 2]
            any_defected = not prev_opponent_actions.all()
            if any_defected:
                return Action.D
        if S_t < capacity / 2:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_80(BaseStrategy):
    """
    Reciprocal Cooperation with Graduated Punishment for Common Pool Resource Game.

    - Round 1: Cooperate.
    - Intermediate rounds: 
        * Cooperate if all players cooperated previous round.
        * Defect exactly one round after any defection detected (punishment).
        * Forgive and return to cooperation if cooperation resumes after punishment.
    - Last round: Defect unconditionally to maximize final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number
        next_round = current_round + 1
        if next_round == r:
            return Action.D
        prev_opponent_actions = history.opponent_actions[current_round - 1]
        all_actions_last_round = []
        my_last_action = history.my_actions[current_round - 1]
        all_actions_last_round.append(my_last_action)
        all_actions_last_round.extend(prev_opponent_actions.tolist())
        any_defection_last_round = any((not a for a in all_actions_last_round))
        if any_defection_last_round:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_81(BaseStrategy):
    """
    Sustained Reciprocity with Endgame Cooperation for the Common Pool Resource Game.

    This strategy promotes cooperation by starting cooperatively, retaliating proportionally 
    to defections with a limited punishment phase, forgiving defections when cooperation resumes,
    and always cooperating in the last two rounds to maximize final payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.max_punishment = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round >= self.r - 1:
            return Action.C

        def count_defectors_last_round():
            if t == 0:
                return 0
            last_round_actions = history.opponent_actions[t - 1]
            return np.sum(~last_round_actions)
        defectors_last_round = count_defectors_last_round()
        max_punish = self.max_punishment
        punishment_left = 0
        punishment_flags = [False] * t
        round_index = 0
        while round_index < t:
            if round_index == 0:
                defectors = 0
                punishment_duration = 0
            else:
                opponent_acts = history.opponent_actions[round_index - 1]
                defectors = np.sum(~opponent_acts)
                punishment_duration = min(defectors, max_punish)
            if punishment_duration > 0:
                for p_round in range(round_index, min(round_index + punishment_duration, t)):
                    punishment_flags[p_round] = True
                round_index += punishment_duration
            else:
                round_index += 1
        if t == 0:
            punishment_timer = 0
        else:
            defectors_last_round = np.sum(~history.opponent_actions[t - 1])
            punishment_timer = min(defectors_last_round, max_punish)
            count_consecutive_punish = 0
            for idx in reversed(range(t)):
                if punishment_flags[idx]:
                    count_consecutive_punish += 1
                else:
                    break
            punishment_timer = punishment_timer - count_consecutive_punish
            if punishment_timer < 0:
                punishment_timer = 0
            if defectors_last_round == 0:
                punishment_timer = 0
        if punishment_timer > 0:
            return Action.D
        elif defectors_last_round == 0:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_82(BaseStrategy):
    """
    Conditional Cooperation with Punishment and Forgiveness
    - Start cooperating in round 1.
    - If anyone defected last round, punish by defecting exactly one round.
    - Then forgive and return to cooperation.
    - In the last round, defect to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game.n_rounds
        n = self.game.n_players
        if history is None:
            self.punishing = False
            return Action.C
        t = history.round_number + 1
        S = None
        if t == 1:
            self.punishing = False
            return Action.C
        if t == r:
            self.punishing = False
            return Action.D
        last_opponent_actions = history.opponent_actions[t - 2]
        any_defected = np.any(last_opponent_actions == False)
        if self.punishing:
            self.punishing = False
            return Action.D
        elif any_defected:
            self.punishing = True
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_83(BaseStrategy):
    """
    Tit-for-Tat with Forgiveness and Final Round Defection strategy for Common Pool Resource Game.
    
    Starts by cooperating. If any opponent defected last round, punish by defecting once.
    After punishing, return to cooperation if opponents cooperate.
    In the final round, always defect to maximize individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_grace_period = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            self.defect_grace_period = 0
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        if t == 0:
            self.defect_grace_period = 0
            return Action.C
        last_round = t - 1
        last_round_opponent_actions = history.opponent_actions[last_round]
        n_defect_t_1 = np.sum(~last_round_opponent_actions)
        if self.defect_grace_period > 0:
            action = Action.D
            self.defect_grace_period -= 1
            return action
        if n_defect_t_1 > 0:
            self.defect_grace_period = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_84(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource Game.
    
    Starts by cooperating, punishes any defection by mutual defection for one round,
    then forgives and returns to cooperation if no defection in the punishment round.
    Always defects in the last round due to endgame incentives.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishing = False
            return Action.C
        t = history.round_number + 1
        last_round = self.n_rounds
        if t == last_round:
            self.punishing = False
            return Action.D
        prev_round_idx = t - 2
        if prev_round_idx >= 0 and len(history.opponent_actions) > 0:
            opponents_prev_actions = history.opponent_actions[prev_round_idx]
            defected_last_round = np.any(opponents_prev_actions == False)
        else:
            defected_last_round = False
        if self.punishing:
            if not defected_last_round:
                self.punishing = False
                return Action.C
            else:
                return Action.D
        elif defected_last_round:
            self.punishing = True
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_85(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource Game.

    - Round 1: cooperate unconditionally.
    - Rounds 2 to r-1: cooperate if all players cooperated last round; else defect to punish.
    - Last round (round r): defect unconditionally.
    
    Uses full observation of all players' actions to sustain cooperation by threat of punishment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        all_last_actions = np.append(history.my_actions[last_round_idx], history.opponent_actions[last_round_idx])
        if np.all(all_last_actions):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_86(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness for the Common Pool Resource Game.

    This strategy:
    - Starts cooperating to build trust.
    - Continues cooperating if all cooperated last round and stock is above a critical threshold.
    - On defection by others or low stock, defects for a fixed punishment duration.
    - Forgives after punishment rounds, resuming cooperation if conditions improve.
    - Always defects in the last round to maximize personal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_threshold_low = 0.3 * self.capacity
        self.forgiveness_rounds = 2
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = history.round_number + 1 if history is not None else 1

        def reconstruct_stock():
            S = float(self.capacity)
            if history is None:
                return S
            for round_idx in range(history.round_number):
                my_action = history.my_actions[round_idx]
                opp_actions = history.opponent_actions[round_idx]
                total_consump = 0.0
                coop_count = 0
                defect_count = 0
                if my_action:
                    coop_count += 1
                else:
                    defect_count += 1
                for a in opp_actions:
                    if a:
                        coop_count += 1
                    else:
                        defect_count += 1
                total_consumption = coop_count * (S / (2 * self.n)) + defect_count * (S / self.n)
                S_remaining = S - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
                S = min(S_remaining + growth, self.capacity)
            return S
        S_t = reconstruct_stock()
        if t == 1:
            defect_count_last_round = 0
        else:
            last_round = t - 2
            opp_actions_last = history.opponent_actions[last_round]
            my_action_last = history.my_actions[last_round]
            defect_count_last_round = int(not my_action_last) + sum((not a for a in opp_actions_last))
        if t == 1:
            self.punish_counter = 0
            return Action.C
        if t == self.r:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        if defect_count_last_round == 0 and S_t > self.stock_threshold_low:
            return Action.C
        else:
            self.punish_counter = self.forgiveness_rounds - 1
            return Action.D

class Strategy_COOPERATIVE_87(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource Game.

    - Round 1: Cooperate unconditionally.
    - Rounds 2 to r-1:
       * Cooperate if all players cooperated last round and stock >= capacity/2.
       * Defect if any defection last round or stock < capacity/2.
    - Last round (r):
       * Defect if any defection ever detected in previous rounds.
       * Otherwise cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_threshold_coop = self.capacity / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        threshold = self.stock_threshold_coop
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1
        all_actions = np.empty((t, n), dtype=bool)
        all_actions[:, 0] = history.my_actions[:t]
        all_actions[:, 1:] = history.opponent_actions[:t, :]
        stock = capacity
        for i in range(t):
            actions_i = all_actions[i]
            cooperators_mask = actions_i
            defectors_mask = ~actions_i
            n_c = cooperators_mask.sum()
            n_d = defectors_mask.sum()
            c_consume = 0.0 if n_c == 0 else stock / (2 * n)
            d_consume = 0.0 if n_d == 0 else stock / n
            total_consumption = n_c * c_consume + n_d * d_consume
            stock_after_consume = stock - total_consumption
            growth = 2 * stock_after_consume * (1 - stock_after_consume / capacity)
            new_stock = stock_after_consume + growth
            if new_stock > capacity:
                new_stock = capacity
            stock = new_stock
        current_stock = stock
        defection_detected = np.any(all_actions == False)
        if t - 1 < 0:
            all_cooperated_last_round = True
        else:
            last_round_actions = all_actions[t - 1]
            all_cooperated_last_round = np.all(last_round_actions)
        if current_round == 1:
            return Action.C
        if current_round == r:
            return Action.D if defection_detected else Action.C
        if current_stock < threshold:
            return Action.D
        if all_cooperated_last_round:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_88(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource Game.
    - Cooperate initially and as long as no defection observed.
    - If any defection detected in history, punish by defecting for 2 rounds.
    - After punishment, forgive and cooperate again.
    - Defect in the last two rounds to avoid exploitation.
    """
    punishment_rounds = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_detected = False
        self.punishment_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if not self.defection_detected:
            for round_idx in range(t):
                if not history.opponent_actions[round_idx].all():
                    self.defection_detected = True
                    self.punishment_timer = self.punishment_rounds
                    break
                if not history.my_actions[round_idx]:
                    self.defection_detected = True
                    self.punishment_timer = self.punishment_rounds
                    break
        if current_round >= r - 1:
            return Action.D
        if self.punishment_timer > 0:
            self.punishment_timer -= 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_89(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource Game.
    - Start cooperating first round.
    - Detect defections by opponents and add them to PunishSet for 2 rounds.
    - While punished (self in PunishSet), defect and count down punishment.
    - While any punished players remain, defect (mutual punishment).
    - Otherwise cooperate.
    - Always defect in last round.
    Uses only observed past actions to respond.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.punish_length = 2
        self.PunishSet = set()
        self.punish_counter = dict(((j, 0) for j in range(self.n)))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.PunishSet.clear()
            for j in range(self.n):
                self.punish_counter[j] = 0
            return Action.C
        t = history.round_number + 1
        self_index = 0
        if 1 < t < self.r:
            last_round = t - 2
            opp_actions_last = history.opponent_actions[last_round]
            for opp_i in range(self.n - 1):
                player_j = opp_i + 1
                if not opp_actions_last[opp_i]:
                    if player_j not in self.PunishSet:
                        self.PunishSet.add(player_j)
                        self.punish_counter[player_j] = self.punish_length
            to_remove = []
            for j in self.PunishSet:
                self.punish_counter[j] -= 1
                if self.punish_counter[j] <= 0:
                    to_remove.append(j)
            for j in to_remove:
                self.PunishSet.remove(j)
                self.punish_counter[j] = 0
            if 0 in self.PunishSet:
                return Action.D
            if len(self.PunishSet) > 0:
                return Action.D
            return Action.C
        if t == self.r:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_90(BaseStrategy):
    """
    Cooperative grim-trigger strategy for the Common Pool Resource game.
    - Round 1: cooperate unconditionally.
    - Intermediate rounds: cooperate if no defection observed in any previous round (self or opponents).
    - Last round: defect unconditionally.
    Once a defection is detected, defect forever after (grim trigger punishment).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        if not all(history.my_actions) or not history.opponent_actions.all():
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_91(BaseStrategy):
    """
    Sustained Cooperation with Grim Trigger and Forgiveness for Common Pool Resource Game.

    Strategy logic:
    - Cooperate in round 1.
    - From round 2 to round r-1:
      - If any opponent defected in the previous round, defect this round (punishment).
      - Otherwise, cooperate.
    - Forgive after one round of punishment.
    - In the last round, defect unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish = False
            return Action.C
        current_round = history.round_number
        round_number = current_round + 1
        if round_number == self.r:
            return Action.D
        if round_number > 1:
            last_round_idx = current_round - 1
            opponents_last_actions = history.opponent_actions[last_round_idx]
            defect_detected_last_round = np.any(opponents_last_actions == False)
        else:
            defect_detected_last_round = False
        if defect_detected_last_round:
            self.punish = True
        elif self.punish:
            self.punish = False
        if self.punish:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_92(BaseStrategy):
    """
    Conditional Cooperative Stewardship strategy for Common Pool Resource Game.

    Starts cooperating to sustain the stock. Detects defections by observing 
    increased total consumption (inferred from stock depletion) and punishes 
    defectors by defecting for a fixed number of rounds. Forgives afterwards and 
    returns to cooperation to allow stock recovery. Defects when stock is critically low 
    to preserve minimal payoff, including in the last rounds or collapse scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_detected = False
        self.punishment_rounds_left = 0
        self.punishment_length = 2
        self.epsilon = 0.01
        self.capacity = float(game_description.capacity)
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.critical_stock_threshold = self.capacity / 4
        self.last_stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.defection_detected = False
            self.punishment_rounds_left = 0
            self.last_stock = self.capacity
            return Action.C
        t = history.round_number
        my_action_last = history.my_actions[t - 1]
        my_payoff_last = history.my_payoffs[t - 1]
        opp_actions_last = history.opponent_actions[t - 1]
        opp_payoffs_last = history.opponent_payoffs[t - 1]
        coop_count = np.sum(opp_actions_last) + (1 if my_action_last else 0)
        defect_count = self.n - coop_count
        total_payoff_last = np.sum(opp_payoffs_last) + my_payoff_last
        if coop_count > 0:
            opp_coop_payoffs = opp_payoffs_last[opp_actions_last]
            sum_coop_payoff = np.sum(opp_coop_payoffs) + (my_payoff_last if my_action_last else 0)
            avg_coop_payoff = sum_coop_payoff / coop_count
            S_est_coop = avg_coop_payoff * 2 * self.n
        else:
            S_est_coop = None
        if defect_count > 0:
            opp_def_payoffs = opp_payoffs_last[~opp_actions_last]
            sum_def_payoff = np.sum(opp_def_payoffs) + (my_payoff_last if not my_action_last else 0)
            avg_def_payoff = sum_def_payoff / defect_count
            S_est_def = avg_def_payoff * self.n
        else:
            S_est_def = None
        if S_est_coop is not None and S_est_def is not None:
            S_last_round_start = (S_est_coop + S_est_def) / 2
        elif S_est_coop is not None:
            S_last_round_start = S_est_coop
        elif S_est_def is not None:
            S_last_round_start = S_est_def
        else:
            S_last_round_start = self.last_stock
        total_consumption = S_last_round_start - total_payoff_last
        S_remaining = S_last_round_start - total_consumption
        growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
        S_t_est = min(S_remaining + growth, self.capacity)
        self.last_stock = S_t_est
        expected_coop_consumption = S_last_round_start / 2
        threshold_defect_flag = expected_coop_consumption + self.epsilon
        if total_consumption > threshold_defect_flag:
            self.defection_detected = True
            self.punishment_rounds_left = self.punishment_length
        current_round = t + 1
        last_round = current_round == self.r
        if self.punishment_rounds_left > 0:
            action = Action.D
            self.punishment_rounds_left -= 1
            if self.punishment_rounds_left == 0:
                self.defection_detected = False
            return action
        if S_t_est < self.critical_stock_threshold:
            return Action.D
        if last_round:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_93(BaseStrategy):
    """
    Cooperative "Sustained Cooperation with Trigger Punishment" Strategy for
    the Common Pool Resource Game.
    
    Starts cooperating. Permanently defects if any defection detected in past rounds.
    Defects in the last round unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        for past_round in range(current_round - 1):
            if not history.my_actions[past_round]:
                return Action.D
            if not history.opponent_actions[past_round].all():
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_94(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.

    - Start cooperating.
    - Monitor opponents' past actions.
    - If any opponent defected last round, enter punishment_mode and defect this round.
    - Punish for at least one round; exit punishment if all opponents cooperated last round.
    - Cooperate otherwise.
    - Defect in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._punishment_mode = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        last_round = False
        round_number = 1
        if history is None:
            self._punishment_mode = False
            return Action.C
        round_number = history.round_number + 1
        last_round = round_number == r
        if history.round_number >= 1:
            opponents_last_round = history.opponent_actions[history.round_number - 1]
            opponents_defected_last_round = np.any(opponents_last_round == False)
            opponents_cooperated_last_round = np.all(opponents_last_round == True)
        else:
            opponents_defected_last_round = False
            opponents_cooperated_last_round = True
        if last_round:
            self._punishment_mode = False
            return Action.D
        if round_number == 1:
            self._punishment_mode = False
            return Action.C
        if not self._punishment_mode:
            if opponents_defected_last_round:
                self._punishment_mode = True
                return Action.D
            else:
                return Action.C
        else:
            action = Action.D
            if opponents_cooperated_last_round:
                self._punishment_mode = False
            else:
                pass
            return action

class Strategy_COOPERATIVE_95(BaseStrategy):
    """
    Cooperative Strategy: Conditional Cooperation with Forgiveness ("Sustainable Reciprocity")

    Maintains near-capacity common stock by cooperating unless defection detected.
    Punishes defectors immediately for one round, then forgives.
    Defects last round to maximize payoff (backward induction).
    Applies harsher punishment if stock is below 30% capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.low_stock_threshold = 0.3 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        low_stock = self.low_stock_threshold
        if history is None:
            return Action.C
        t = history.round_number + 1
        last_round_idx = t - 2
        own_last_action_bool = history.my_actions[last_round_idx]
        own_last_payoff = history.my_payoffs[last_round_idx]
        if own_last_action_bool:
            S_last = own_last_payoff * 2 * n
        else:
            S_last = own_last_payoff * n
        all_payoffs_last_round = history.my_payoffs[last_round_idx] + np.sum(history.opponent_payoffs[last_round_idx])
        total_consumption = all_payoffs_last_round
        stock_after_consumption = S_last - total_consumption
        if stock_after_consumption < 0:
            stock_after_consumption = 0.0
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
        S_t = stock_after_consumption + growth
        if S_t > capacity:
            S_t = capacity
        defectors = set()
        for opp_idx in range(history.opponent_actions.shape[1]):
            if not history.opponent_actions[last_round_idx, opp_idx]:
                defectors.add(opp_idx)
        if not own_last_action_bool:
            defectors.add('self')
        if t == r:
            return Action.D
        if S_t < low_stock:
            if len(defectors) > 0:
                return Action.D
            else:
                return Action.C
        if len(defectors) == 0:
            return Action.C
        if own_last_action_bool is False:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_96(BaseStrategy):
    """
    Cooperative tit-for-tat style strategy for the Common Pool Resource game:
    - Cooperate initially and by default to sustain resource.
    - Detect any defection last round and punish by defecting for punishmentLength rounds.
    - Forgive after punishment to restore cooperation.
    - Defect unconditionally in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_length = 1
        self._punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            self._punishment_rounds_left = 0
            return Action.C
        round_number = history.round_number + 1
        last_round_idx = round_number - 2
        if round_number == r:
            return Action.D
        defection_detected = False
        if last_round_idx >= 0:
            my_last = history.my_actions[last_round_idx]
            opp_last = history.opponent_actions[last_round_idx]
            all_last_actions = np.append(opp_last, my_last)
            defection_detected = np.any(all_last_actions == False)
        if self._punishment_rounds_left > 0:
            self._punishment_rounds_left -= 1
            return Action.D
        elif defection_detected:
            self._punishment_rounds_left = self.punishment_length - 1
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_97(BaseStrategy):
    """
    Conditional Cooperative Steward strategy for Common Pool Resource Game.

    This strategy:
    - Cooperates in round 1 unconditionally.
    - Monitors the inferred total consumption via stock dynamics to detect defections.
    - On detecting defection, punishes by defecting for a finite fixed punishment_length.
    - Returns to cooperation after punishment phase.
    - Defects on the last round to maximize immediate payoff.
    - Always cooperates when stock is zero (except on last round) to help recovery.
    - Uses a tolerance margin to avoid false positives from minor deviations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.defection_tolerance = 0.05
        self.punishment_length = 2
        self._punishment_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            round_num = 1
        else:
            round_num = history.round_number + 1
        if round_num == self.r:
            self._punishment_timer = 0
            return Action.D
        if self._punishment_timer > 0:
            self._punishment_timer -= 1
            return Action.D
        if round_num == 1:
            return Action.C
        prev_round_idx = round_num - 2
        if prev_round_idx < 0:
            return Action.C
        n = self.n
        coop_found = False
        S_prev_estimates = []
        my_action_prev = history.my_actions[prev_round_idx]
        my_payoff_prev = history.my_payoffs[prev_round_idx]
        if my_action_prev:
            S_prev_estimates.append(my_payoff_prev * 2 * n)
            coop_found = True
        elif my_payoff_prev > 0:
            S_prev_estimates.append(my_payoff_prev * n)
        opp_actions_prev = history.opponent_actions[prev_round_idx]
        opp_payoffs_prev = history.opponent_payoffs[prev_round_idx]
        for a, p in zip(opp_actions_prev, opp_payoffs_prev):
            if a:
                S_prev_estimates.append(p * 2 * n)
                coop_found = True
            elif p > 0:
                S_prev_estimates.append(p * n)
        if len(S_prev_estimates) == 0:
            S_prev = 0.0
        else:
            S_prev = float(np.median(np.array(S_prev_estimates)))
        expected_total_coop = S_prev / 2.0
        total_payoff_prev = history.my_payoffs[prev_round_idx] + np.sum(history.opponent_payoffs[prev_round_idx])
        coeff_a = 2.0 / self.capacity
        coeff_b = -3.0
        coeff_c = S_prev - total_payoff_prev
        discriminant = coeff_b ** 2 - 4 * coeff_a * coeff_c
        stock_end_prev = 0.0
        if discriminant >= 0:
            sqrt_disc = math.sqrt(discriminant)
            root1 = (-coeff_b + sqrt_disc) / (2 * coeff_a)
            root2 = (-coeff_b - sqrt_disc) / (2 * coeff_a)
            candidates = [root for root in (root1, root2) if 0 <= root <= self.capacity]
            if candidates:
                stock_end_prev = min(candidates)
            else:
                roots = [root1, root2]
                roots_clipped = [min(max(r, 0), self.capacity) for r in roots]
                stock_end_prev = min(roots_clipped, key=lambda v: abs(v - S_prev))
        else:
            stock_end_prev = max(0.0, min(S_prev, self.capacity))
        growth_prev = 2.0 * stock_end_prev * (1.0 - stock_end_prev / self.capacity)
        actual_consumed = S_prev - (stock_end_prev + growth_prev)
        tolerance_amount = self.defection_tolerance * expected_total_coop
        defection_detected = actual_consumed - expected_total_coop > tolerance_amount
        if stock_end_prev < 1e-08:
            return Action.C
        if defection_detected:
            self._punishment_timer = self.punishment_length - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_98(BaseStrategy):
    """
    Tit-for-Tat with forgiveness tuned for common-pool depletion:
    - Start cooperating.
    - Infer defection by observing total stock depletion after opponents' moves.
    - Punish defections by defecting exactly one round.
    - Forgive if cooperation resumes.
    - Defect in the last round to maximize final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.tolerance_frac = 0.01

    def __call__(self, history: None | PlayerHistory) -> Action:
        C = Action.C
        D = Action.D
        if history is None or history.round_number == 0:
            return C
        t = history.round_number
        if t == self.r - 1:
            return D

        def estimate_stock(round_idx: int) -> float | None:
            if round_idx < 0 or round_idx >= history.my_payoffs.size:
                return None
            my_a = history.my_actions[round_idx]
            my_p = history.my_payoffs[round_idx]
            opp_a = history.opponent_actions[round_idx]
            opp_p = history.opponent_payoffs[round_idx]
            n = self.n
            if my_a:
                own_S_est = my_p * 2 * n
            else:
                own_S_est = my_p * n
            opp_S_ests = []
            for oa, op in zip(opp_a, opp_p):
                if oa:
                    opp_S_ests.append(op * 2 * n)
                else:
                    opp_S_ests.append(op * n)
            estimates = [own_S_est] + opp_S_ests
            estimates = [e for e in estimates if e > 0]
            if not estimates:
                return None
            median_S = float(np.median(np.array(estimates)))
            if median_S > self.capacity:
                median_S = self.capacity
            if median_S < 0:
                median_S = 0.0
            return median_S
        S_prev = estimate_stock(t - 1)
        S_curr = estimate_stock(t)
        if S_prev is None or S_curr is None:
            return C
        a = -2.0 / self.capacity
        b = 3.0
        c = -S_curr
        discriminant = b * b - 4 * a * c
        if discriminant < 0:
            return C
        sqrt_discriminant = math.sqrt(discriminant)
        root1 = (-b + sqrt_discriminant) / (2 * a)
        root2 = (-b - sqrt_discriminant) / (2 * a)
        candidates = [r for r in (root1, root2) if 0 <= r <= S_prev]
        if not candidates:
            return C
        S_remaining = max(candidates)
        total_consumed = S_prev - S_remaining
        avg_consumption = total_consumed / self.n
        expected_coop = S_prev / (2 * self.n)
        expected_defect = S_prev / self.n
        tol = self.tolerance_frac * S_prev
        if not hasattr(self, '_state'):
            self._state = 'cooperate'
        if not hasattr(self, '_last_S'):
            self._last_S = S_prev
        if not hasattr(self, '_last_total_consumed'):
            self._last_total_consumed = None
        if not hasattr(self, '_last_defected'):
            self._last_defected = False
        defection_detected = avg_consumption > expected_coop + tol
        if defection_detected:
            self._state = 'punish'
            self._last_defected = True
        else:
            if self._state == 'punish':
                self._state = 'cooperate'
            self._last_defected = False
        if self._state == 'cooperate':
            action = C
        else:
            action = D
        self._last_S = S_curr
        self._last_total_consumed = total_consumed
        return action

class Strategy_COOPERATIVE_99(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.

    Implements conditional cooperation with trigger punishment ("grim with forgiveness").
    - Start cooperating on round 1.
    - Cooperate if all players cooperated last round.
    - Defect if any player defected last round (punishment round).
    - Forgive and return to cooperation if after a punishment round all players cooperate.
    - Cooperate in the last round to promote group welfare.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.C
        last_round_index = t - 2
        my_last_action = history.my_actions[last_round_index]
        opp_last_actions = history.opponent_actions[last_round_index]
        all_last_actions = np.concatenate(([my_last_action], opp_last_actions))
        all_cooperated_prev = np.all(all_last_actions)
        if all_cooperated_prev:
            return Action.C
        if t > 2:
            prev_prev_index = t - 3
            my_prev_prev = history.my_actions[prev_prev_index]
            opp_prev_prev = history.opponent_actions[prev_prev_index]
            all_cooperated_prev_prev = np.all(np.concatenate(([my_prev_prev], opp_prev_prev)))
            if all_cooperated_prev_prev:
                return Action.D
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_100(BaseStrategy):
    """
    Cooperative trigger strategy for the Common Pool Resource Game.

    - Cooperate in the first round.
    - From rounds 2 to r-1, cooperate only if all players (including self) cooperated in the previous round.
    - If any defection occurred previously, defect forever as punishment.
    - Defect in the last round (backward induction).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.permanent_defect = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            self.permanent_defect = False
            return Action.C
        t = history.round_number + 1
        if not self.permanent_defect and t > 1:
            last_round_index = t - 2
            opponents_last_actions = history.opponent_actions[last_round_index]
            my_last_action = history.my_actions[last_round_index]
            all_last_actions = np.append(opponents_last_actions, my_last_action)
            if not np.all(all_last_actions):
                self.permanent_defect = True
        if t == r:
            return Action.D
        if self.permanent_defect:
            return Action.D
        last_round_index = t - 2
        opponents_last_actions = history.opponent_actions[last_round_index]
        my_last_action = history.my_actions[last_round_index]
        all_last_actions = np.append(opponents_last_actions, my_last_action)
        if np.all(all_last_actions):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_101(BaseStrategy):
    """
    Conditional cooperation strategy for the Common Pool Resource Game.
    - Starts cooperating.
    - Continues cooperating as long as all players cooperated last round.
    - If any player defected last round, punishes by defecting for a fixed punishment length.
    - After punishment, returns to cooperation.
    - Defects on last round to maximize immediate payoff.
    """
    PUNISH_LENGTH = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.punish_until = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == self.r:
            return Action.D
        if self.punish_until >= t:
            return Action.D
        if t == 1:
            return Action.C
        prev_round_my_action = history.my_actions[t - 2]
        prev_round_opponents = history.opponent_actions[t - 2]
        all_cooperated = prev_round_my_action and prev_round_opponents.all()
        if all_cooperated:
            return Action.C
        else:
            self.punish_until = t + self.PUNISH_LENGTH - 1
            return Action.D

class Strategy_COOPERATIVE_102(BaseStrategy):
    """
    Conditional Cooperative Steward strategy for the Common Pool Resource Game.

    Starts cooperating; continues to cooperate if all players cooperated last round.
    If any defected last round, punishes all by defecting once.
    After one round of punishment, forgives by cooperating again.
    Always defects on the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        self_i = 0
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            return Action.D
        prev_opponent_actions = history.opponent_actions[t - 1]
        prev_my_action = history.my_actions[t - 1]
        n = self.game_description.n_players
        all_prev_actions = np.empty(n, dtype=bool)
        all_prev_actions[0] = prev_my_action
        all_prev_actions[1:] = prev_opponent_actions
        all_cooperated = np.all(all_prev_actions)
        if all_cooperated:
            return Action.C
        if prev_my_action == False:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_103(BaseStrategy):
    """
    Fully cooperative conditional cooperation with short punishment and mercy
    in Common Pool Resource game. Cooperates initially and as long as no defection,
    punishes defectors for a fixed number of rounds by defecting,
    but overrides punishment and cooperates if stock very low.
    Defects always in last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_rounds = 2
        self._punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n, r, capacity = (self.n, self.r, self.capacity)
        all_actions = np.empty((history.round_number, n), dtype=bool)
        all_actions[:, 0] = history.my_actions
        all_actions[:, 1:] = history.opponent_actions
        stock_history = [float(capacity)]
        for round_idx in range(history.round_number):
            prev_stock = stock_history[-1]
            acts = all_actions[round_idx]
            n_coop = np.sum(acts)
            n_defect = n - n_coop
            coop_cons = prev_stock / (2 * n)
            defect_cons = prev_stock / n
            total_consumption = coop_cons * n_coop + defect_cons * n_defect
            stock_after_cons = prev_stock - total_consumption
            if stock_after_cons < 0:
                stock_after_cons = 0.0
            growth = 2 * stock_after_cons * (1 - stock_after_cons / capacity)
            new_stock = stock_after_cons + growth
            if new_stock > capacity:
                new_stock = capacity
            stock_history.append(new_stock)
        current_stock = stock_history[t - 1]
        if t == 1:
            last_round_defectors = 0
        else:
            last_round_actions = all_actions[t - 2]
            last_round_defectors = np.sum(last_round_actions == False)
        low_stock_threshold = capacity / (2 * n)
        if t == r:
            self._punishment_counter = 0
            return Action.D
        if current_stock <= low_stock_threshold:
            self._punishment_counter = 0
            return Action.C
        if last_round_defectors == 0:
            self._punishment_counter = 0
            return Action.C
        if self._punishment_counter > 0:
            self._punishment_counter -= 1
            return Action.D
        self._punishment_counter = self.punishment_rounds - 1
        return Action.D

class Strategy_COOPERATIVE_104(BaseStrategy):
    """
    Conditional Cooperation with Forgiving Trigger strategy for the Common Pool Resource Game.

    Starts cooperating, continues cooperating while others cooperate, triggers a short punishment
    (defection) if any defection is observed, then forgives and returns to cooperation.
    Always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.punishment_duration = 1
        self.punish = False
        self.punish_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish = False
            self.punish_rounds_left = 0
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        last_opponent_actions = history.opponent_actions[t - 2]
        any_defected = np.any(last_opponent_actions == False)
        if self.punish:
            action = Action.D
            self.punish_rounds_left -= 1
            if self.punish_rounds_left <= 0:
                self.punish = False
            return action
        elif any_defected:
            self.punish = True
            self.punish_rounds_left = self.punishment_duration
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_105(BaseStrategy):
    """
    Cooperative strategy for the repeated Common Pool Resource Game.
    
    Summary:
    - Round 1: Cooperate unconditionally.
    - Intermediate rounds (2 to r-1): Cooperate if all players cooperated last round,
      else defect once as punishment.
    - Last round (r): Defect unconditionally.
    
    The strategy punishes any defection detected in the immediately previous round by 
    defecting once, then resumes cooperation if no new defections occur.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        prev_round_idx = history.round_number - 1
        prev_opponent_actions = history.opponent_actions[prev_round_idx]
        prev_my_action = history.my_actions[prev_round_idx]
        prev_all_actions = np.empty(n, dtype=bool)
        prev_all_actions[0] = prev_my_action
        prev_all_actions[1:] = prev_opponent_actions
        defection_last_round = not prev_all_actions.all()
        if defection_last_round:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_106(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource Game:
    - Start cooperating.
    - Maintain cooperation if stock follows expected growth.
    - Detect defections by comparing observed stock at round start with expected stock assuming full cooperation.
    - If defection detected, defect for fixed punishment rounds.
    - After punishment, forgive and resume cooperation.
    - Defect in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punish_length = 2
        self.tolerance = self.capacity * 0.01
        self._punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self._punishment_rounds_left = 0
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self._punishment_rounds_left > 0:
            self._punishment_rounds_left -= 1
            return Action.D
        if t == 1:
            return Action.C
        prev_opponent_actions = history.opponent_actions[t - 2]
        prev_my_action = history.my_actions[t - 2]
        prev_my_payoff = history.my_payoffs[t - 2]
        prev_all_actions = np.empty(self.n, dtype=bool)
        prev_all_actions[0] = prev_my_action
        prev_all_actions[1:] = prev_opponent_actions
        prev_my_payoffs = history.my_payoffs[t - 2]
        prev_opp_payoffs = history.opponent_payoffs[t - 2]
        prev_all_payoffs = np.empty(self.n, dtype=np.float64)
        prev_all_payoffs[0] = prev_my_payoff
        prev_all_payoffs[1:] = prev_opp_payoffs
        defectors_mask = np.logical_not(prev_all_actions)
        cooperators_mask = prev_all_actions
        if np.any(defectors_mask):
            if np.all(prev_all_payoffs[defectors_mask] == 0):
                S_prev = 0.0
            else:
                S_prev = float(np.mean(prev_all_payoffs[defectors_mask]) * self.n)
        elif np.all(prev_all_payoffs[cooperators_mask] == 0):
            S_prev = 0.0
        else:
            S_prev = float(np.mean(prev_all_payoffs[cooperators_mask]) * 2 * self.n)
        if not hasattr(self, '_stock'):
            self._stock = float(self.capacity)
        nC_last = int(np.sum(prev_all_actions))
        nD_last = self.n - nC_last
        if S_prev < 0:
            S_prev = 0.0
        total_consumption = nC_last * (S_prev / (2 * self.n)) + nD_last * (S_prev / self.n)
        stock_after_consumption = S_prev - total_consumption
        if stock_after_consumption < 0:
            stock_after_consumption = 0.0
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        stock_new = min(stock_after_consumption + growth, self.capacity)
        observed_S_t = stock_new
        Expected_consumption = S_prev / 2
        Expected_S_remaining = S_prev - Expected_consumption
        if Expected_S_remaining < 0:
            Expected_S_remaining = 0.0
        Expected_growth = 2 * Expected_S_remaining * (1 - Expected_S_remaining / self.capacity)
        Expected_S = min(Expected_S_remaining + Expected_growth, self.capacity)
        stock_depletion = Expected_S - observed_S_t
        if stock_depletion > self.tolerance:
            self._punishment_rounds_left = self.punish_length - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_107(BaseStrategy):
    """
    Cooperative trigger-forgiveness strategy for Common Pool Resource Game.
    Starts cooperating, punishes detected defectors by defecting for fixed rounds,
    forgives after punishment, defects if stock is critically low to avoid collapse,
    and cooperates last round if no punishment ongoing.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_rounds = 2
        self._punishment_timer = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        punishment_rounds = self.punishment_rounds
        if history is None:
            self._punishment_timer = [0] * (n - 1)
            return Action.C
        t = history.round_number
        current_round = t + 1
        last_round = t - 1
        if last_round < 0:
            S_t = capacity
        else:
            estimates = []
            own_action = history.my_actions[last_round]
            own_payoff = history.my_payoffs[last_round]
            if own_payoff > 0:
                if own_action:
                    est = own_payoff * 2 * n
                else:
                    est = own_payoff * n
                estimates.append(est)
            opp_actions = history.opponent_actions[last_round]
            opp_payoffs = history.opponent_payoffs[last_round]
            for j in range(n - 1):
                payoff = opp_payoffs[j]
                act = opp_actions[j]
                if payoff > 0:
                    if act:
                        est = payoff * 2 * n
                    else:
                        est = payoff * n
                    estimates.append(est)
            if len(estimates) == 0:
                S_t = capacity
            else:
                S_t = float(np.median(estimates))
        for i in range(n - 1):
            if self._punishment_timer[i] > 0:
                self._punishment_timer[i] -= 1
        if current_round > 1:
            prev_actions = history.opponent_actions[last_round]
            for i in range(n - 1):
                if not prev_actions[i] and self._punishment_timer[i] == 0:
                    self._punishment_timer[i] = punishment_rounds
        currently_punishing = any((timer > 0 for timer in self._punishment_timer))
        stock_low = S_t < 0.3 * capacity
        if current_round == r:
            if currently_punishing:
                return Action.D
            else:
                return Action.C
        if currently_punishing:
            return Action.D
        elif stock_low:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_108(BaseStrategy):
    """
    Cooperative strategy for the Common Pool Resource Game.
    Starts by cooperating unconditionally.
    Continues cooperating as long as no defections detected.
    Punishes detected defections by defecting exactly one round.
    Forgives afterward to restore cooperation.
    Last round: cooperate if no defection last round;
    otherwise, defect only if self was defected against last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if t == 0:
            return Action.C
        prev_opp_actions = history.opponent_actions[t - 1] if t - 1 < history.opponent_actions.shape[0] else np.array([], dtype=bool)
        if t - 1 < history.my_actions.size:
            self_last_action = history.my_actions[t - 1]
        else:
            self_last_action = True
        any_defection_others = np.any(prev_opp_actions == False)
        self_defected_last_round = self_last_action == False
        if t == r:
            if any_defection_others:
                return Action.D
            else:
                return Action.C
        if not any_defection_others:
            return Action.C
        if self_defected_last_round:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_109(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness:
    - Start cooperating
    - If anyone defected last round, punish by defecting once
    - Then forgive and return to cooperation
    - Last round always defect to maximize final payoff
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            self._punish_flag = False
            return Action.C
        t = history.round_number + 1
        prev_round = history.round_number - 1
        any_defected_last_round = not history.my_actions[prev_round] or not np.all(history.opponent_actions[prev_round])
        if t == 1:
            self._punish_flag = False
        elif any_defected_last_round:
            self._punish_flag = True
        elif self._punish_flag:
            self._punish_flag = False
        if t == r:
            return Action.D
        if self._punish_flag:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_110(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness and Endgame Defection for
    the Common Pool Resource Game.

    - Round 1: Cooperate.
    - Rounds 2 to r-2:
      * If no defections in previous round: Cooperate.
      * If exactly one defector: Defect once as punishment, then forgive (cooperate next round).
      * If more than one defector: Defect continually until cooperation returns.
    - Round r-1 (penultimate):
      * If stock > capacity/2: Cooperate.
      * Else defect.
      * Forgiveness still applies here.
    - Round r (last): Defect unconditionally.

    This strategy tracks if it is in a punishment phase (`self._punished`).
    Forgiveness means cooperating one round after punishing.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self._punished = False
        self.DEFECTOR_THRESHOLD = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        last_round_idx = t - 2
        last_opponent_actions = history.opponent_actions[last_round_idx]
        defectors = np.sum(~last_opponent_actions)
        if self._punished:
            self._punished = False
            return Action.C
        if defectors == 0:
            return Action.C
        elif defectors <= self.DEFECTOR_THRESHOLD:
            self._punished = True
            return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_111(BaseStrategy):
    """
    Cooperative trigger-and-forgive strategy for the repeated Common Pool Resource Game.

    Summary:
    - Round 1: cooperate unconditionally to establish cooperation.
    - Rounds 2..r-1:
      * if previous round had full cooperation → cooperate
      * if any defection last round and I cooperated last round → defect (punish)
      * else cooperate (forgive)
    - Last round (round r): always defect to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        my_last_action = history.my_actions[-1]
        last_opponent_actions = history.opponent_actions[-1]
        all_last_round_actions = np.append(last_opponent_actions, my_last_action)
        any_defection_last_round = not all(all_last_round_actions)
        if not any_defection_last_round:
            return Action.C
        if my_last_action == True:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_112(BaseStrategy):
    """
    Sustained Cooperation with Trigger Punishment for Common Pool Resource Game.

    - Round 1: Cooperate unconditionally.
    - Rounds 2 to r-1: Defect if any player defected last round (punishment round),
      else cooperate.
    - Round r (last round): Defect unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        last_round = t - 1 - 1
        if t == r:
            return Action.D
        opponents_last = history.opponent_actions[last_round]
        any_opponent_defected = np.any(opponents_last == False)
        my_last = history.my_actions[last_round]
        my_defected_last = my_last == False
        defected_last_round = any_opponent_defected or my_defected_last
        if defected_last_round:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_113(BaseStrategy):
    """
    Fully cooperative strategy for the Common Pool Resource Game.
    - Round 1: Cooperate unconditionally.
    - Rounds 2 to r-1: Defect if any player defected last round (one-round punishment), else cooperate.
    - Last round r: Defect unconditionally to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        last_round_actions = history.opponent_actions[t - 2]
        defection_detected = not all(last_round_actions)
        if defection_detected:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_114(BaseStrategy):
    """
    Conditional Long-term Cooperation with Forgiveness for Common Pool Resource Game.

    - Round 1: Cooperate to signal willingness.
    - Rounds 2 to r-1:
        * If currently punishing (punishmentActive), forgive by cooperating.
        * Else if any opponent defected last round, punish by defecting once.
        * Otherwise cooperate.
    - Round r (last round): Defect to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishmentActive = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        i = None
        if history is None:
            self.punishmentActive = False
            return Action.C
        t = history.round_number + 1
        if t == r:
            return Action.D
        if t == 1:
            defectedLastRound = False
        else:
            last_opponent_actions = history.opponent_actions[t - 2]
            defectedLastRound = np.any(last_opponent_actions == False)
        if self.punishmentActive:
            self.punishmentActive = False
            return Action.C
        elif defectedLastRound:
            self.punishmentActive = True
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_115(BaseStrategy):
    """
    Sustained Conditional Cooperation with Last-Round Adjustment.

    This strategy promotes cooperation from the start, punishes 
    defections in the previous round by defecting once, then forgives 
    by returning to cooperation if opponents also cooperate again. 
    In the final round, it defects unconditionally to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        round_num = history.round_number
        last_round = self.r
        if round_num == self.r:
            return Action.C
        current_round = round_num + 1
        if current_round == last_round:
            return Action.D
        prev_opponents = history.opponent_actions[-1]
        my_prev_action = history.my_actions[-1]
        if np.all(prev_opponents):
            return Action.C
        if not my_prev_action:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_116(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.

    This strategy:
    - Cooperates in the first round.
    - Defects in the last round to maximize final payoff.
    - In intermediate rounds:
       - Cooperates if stock is below 50% capacity.
       - Defects for one round as punishment if any opponent defected last round.
       - Forgives after one-round punishment, returning to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.CRIT_THRESHOLD = 0.5 * self.game.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        r = self.game.n_rounds
        n = self.game.n_players
        capacity = self.game.capacity

        def bool_to_action(b: bool) -> Action:
            return Action.C if b else Action.D
        i = 0
        if history is None:
            return Action.C
        if t == 1:
            S_t = capacity
        else:
            payoffs_last = np.empty(n, dtype=np.float64)
            payoffs_last[i] = history.my_payoffs[-1]
            payoffs_last[:i] = history.opponent_payoffs[-1, :i]
            payoffs_last[i + 1:] = history.opponent_payoffs[-1, i:]
            actions_last = np.empty(n, dtype=bool)
            actions_last[i] = history.my_actions[-1]
            actions_last[:i] = history.opponent_actions[-1, :i]
            actions_last[i + 1:] = history.opponent_actions[-1, i:]
            coeffs = np.where(actions_last, 1 / (2 * n), 1 / n)
            valid = coeffs > 0
            estimated_S_vals = payoffs_last[valid] / coeffs[valid]
            S_last = np.mean(estimated_S_vals)
            total_consumption = np.sum(payoffs_last)
            S_remaining = S_last - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / capacity)
            S_t = min(S_remaining + growth, capacity)
            if S_t < 0:
                S_t = 0.0
        if t == r:
            return Action.D
        if S_t < self.CRIT_THRESHOLD:
            return Action.C
        if t > 1:
            last_round_opponent_actions = history.opponent_actions[-1]
            if np.any(last_round_opponent_actions == False):
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_117(BaseStrategy):
    """
    Cooperative Strategy: Conditional Sustained Cooperation with Forgiving Punishment
    Implements rounds of cooperation as long as all players cooperate and stock is healthy,
    punishes once when defection is detected, forgives promptly to restore cooperation,
    and defects only in the final round to maximize individual end payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.C
        n = self.n
        r = self.r
        capacity = self.capacity
        rounds_done = t - 1
        full_actions = np.empty((rounds_done, n), dtype=bool)
        if rounds_done > 0:
            full_actions[:, 0] = history.my_actions
            full_actions[:, 1:] = history.opponent_actions
        else:
            full_actions = np.empty((0, n), dtype=bool)
        S = capacity
        for round_idx in range(rounds_done):
            actions_this_round = full_actions[round_idx]
            coop_mask = actions_this_round
            defect_mask = ~actions_this_round
            total_consumption = coop_mask.sum() * (S / (2 * n)) + defect_mask.sum() * (S / n)
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / capacity) if S_remaining > 0 else 0.0
            S = min(S_remaining + growth, capacity)
        S_t = S
        if t == r:
            return Action.D
        if t == r - 1:
            return Action.C
        all_coop = True
        for round_idx in range(rounds_done):
            if not full_actions[round_idx].all():
                all_coop = False
                break
        defection_last_round = False
        in_punishment_phase = False
        if rounds_done >= 1:
            last_round_actions = full_actions[-1]
            defection_last_round = not last_round_actions.all()
            own_last_action = full_actions[-1, 0]
            in_punishment_phase = own_last_action == False
        high_stock_threshold = 0.8 * capacity
        low_stock_threshold = 0.5 * capacity
        if all_coop and S_t >= high_stock_threshold:
            return Action.C
        if defection_last_round:
            return Action.D
        if in_punishment_phase:
            return Action.C
        if S_t < low_stock_threshold:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_118(BaseStrategy):
    """
    Conditional cooperative strategy with limited punishment and forgiveness.
    Starts by cooperating, monitors defections by detecting any opponent defect,
    punishes defectors by defecting for fixed rounds, forgives early if all opponents
    cooperate during punishment, adapts to stock level and defects on last round.
    """
    PUNISH_LENGTH = 2
    SAFE_MARGIN = 0.8

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is None:
            return Action.C
        round_ = history.round_number + 1
        if round_ == 1:
            S = float(capacity)
        else:
            stock_levels = [float(capacity)]
            for past_round in range(history.round_number):
                my_a = history.my_actions[past_round]
                opp_as = history.opponent_actions[past_round]
                all_actions = np.append(opp_as, my_a)
                S_prev = stock_levels[-1]
                coop_count = np.sum(all_actions)
                defect_count = n - coop_count
                total_consumpt = coop_count * (S_prev / (2 * n)) + defect_count * (S_prev / n)
                S_after_consump = S_prev - total_consumpt
                growth = 2 * S_after_consump * (1 - S_after_consump / capacity)
                S_next = min(S_after_consump + growth, capacity)
                stock_levels.append(S_next)
            S = stock_levels[-1]
        punish_rounds_left = 0
        defect_rounds = []
        for past_round in range(history.round_number):
            opps = history.opponent_actions[past_round]
            if np.any(opps == False):
                defect_rounds.append(past_round + 1)
        if defect_rounds:
            last_defect_round = defect_rounds[-1]
            rounds_since_defect = round_ - 1 - last_defect_round
            if 0 <= rounds_since_defect < self.PUNISH_LENGTH:
                punish_rounds_left = self.PUNISH_LENGTH - rounds_since_defect
            else:
                punish_rounds_left = 0
        else:
            punish_rounds_left = 0
        if punish_rounds_left > 0 and round_ > 1:
            last_opp_actions = history.opponent_actions[round_ - 2]
            if np.all(last_opp_actions == True):
                punish_rounds_left = 0
        if round_ == r:
            return Action.D
        if punish_rounds_left > 0:
            return Action.D
        if round_ == 1:
            return Action.C
        last_opp_acts = history.opponent_actions[round_ - 2]
        if np.any(last_opp_acts == False):
            punish_rounds_left = self.PUNISH_LENGTH - 1
            return Action.D
        if S >= self.SAFE_MARGIN * capacity:
            return Action.C
        if S < n:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_119(BaseStrategy):
    """
    Fully cooperative strategy for the common pool resource game.
    Starts cooperating to maintain sustainable stock. 
    Punishes any defection detected in the previous round by defecting once.
    Returns immediately to cooperation if defection stops.
    Defects on the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        if t == r - 1:
            return Action.D
        prev_actions = history.opponent_actions[t - 1 - 1]
        if not all(prev_actions):
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_120(BaseStrategy):
    """
    Cooperative Crescent Strategy for the Common Pool Resource Game.
    - Starts cooperating.
    - Maintains cooperation if no defection detected last round.
    - If defection detected last round, punishes by defecting once.
    - Forgives after punishing if opponents return to cooperation.
    - Defects in the final round to maximize last-round individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._punished_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            self._punished_last_round = False
            return Action.C
        current_round = history.round_number + 1
        if current_round == r:
            self._punished_last_round = False
            return Action.D
        prev_round = history.round_number - 1
        if prev_round < 0:
            self._punished_last_round = False
            return Action.C
        opponents_last_actions = history.opponent_actions[prev_round]
        defection_occurred = not opponents_last_actions.all()
        if defection_occurred:
            if not self._punished_last_round:
                self._punished_last_round = True
                return Action.D
            else:
                self._punished_last_round = False
                return Action.C
        else:
            self._punished_last_round = False
            return Action.C

class Strategy_COOPERATIVE_121(BaseStrategy):
    """
    Conditional Sustained Cooperation with Forgiveness for the Common Pool Resource Game.

    - First round: cooperate.
    - Last round: defect.
    - In rounds 2 to r-1:
      * If last round was not punishment and all cooperated last round, cooperate.
      * If a defection detected last round and no punishment then, start punishment (defect).
      * If last round was punishment:
           - Forgive if all cooperated last round: cooperate.
           - Otherwise, continue punishment (defect).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_history = []

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        if history is None or history.round_number == 0:
            self.punishment_history.append(False)
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round > r:
            return Action.D
        total_players = n
        last_round_idx = t - 1
        own_payoff_last = history.my_payoffs[last_round_idx]
        opp_payoffs_last = history.opponent_payoffs[last_round_idx].sum()
        total_consumption_last = own_payoff_last + opp_payoffs_last
        all_cooperated_last_round = True
        if not history.my_actions[last_round_idx]:
            all_cooperated_last_round = False
        elif not history.opponent_actions[last_round_idx].all():
            all_cooperated_last_round = False
        P_last = self.punishment_history[-1] if self.punishment_history else False
        if current_round == 1:
            P_t = False
            action = Action.C
        elif current_round == r:
            P_t = False
            action = Action.D
        elif not P_last:
            if all_cooperated_last_round:
                P_t = False
                action = Action.C
            else:
                P_t = True
                action = Action.D
        elif all_cooperated_last_round:
            P_t = False
            action = Action.C
        else:
            P_t = True
            action = Action.D
        self.punishment_history.append(P_t)
        return action

class Strategy_COOPERATIVE_122(BaseStrategy):
    """
    Conditional Sustained Cooperation for Common Pool Resource Game.

    - Cooperate initially and while all players cooperated previously and stock healthy.
    - Defect to punish any defection in previous round.
    - Punishment lasts exactly one round with defection.
    - Return to cooperation if no defects occur during punishment and stock is healthy.
    - Defect on the last round to maximize endgame payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.T = self.capacity / 2
        self._punishment = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        current_round = 1 if history is None else history.round_number + 1
        if history is None:
            self._punishment = False
            return Action.C
        last_round_index = current_round - 2
        if last_round_index < 0 or last_round_index >= history.my_payoffs.shape[0]:
            S = self.capacity
        else:
            payoffs_last = np.append(history.my_payoffs[last_round_index], history.opponent_payoffs[last_round_index])
            max_payoff = np.max(payoffs_last)
            S = max_payoff * self.n
            if S > self.capacity:
                S = self.capacity
            if S < 0:
                S = 0
        if current_round == self.r:
            self._punishment = False
            return Action.D
        previous_round_index = current_round - 2
        prev_actions_self = history.my_actions[previous_round_index]
        prev_actions_opp = history.opponent_actions[previous_round_index]
        all_prev_actions = np.append(prev_actions_self, prev_actions_opp)
        defected_last_round = np.any(all_prev_actions == False)
        if defected_last_round:
            self._punishment = True
            return Action.D
        if self._punishment:
            if S >= self.T:
                self._punishment = False
                return Action.C
            else:
                return Action.D
        if S >= self.T:
            self._punishment = False
            return Action.C
        else:
            self._punishment = True
            return Action.D

class Strategy_COOPERATIVE_123(BaseStrategy):
    """
    Conditional cooperative strategy for Common Pool Resource Game.
    
    - Starts cooperating.
    - Punishes defections or low stock with limited defecting rounds.
    - Forgives after punishment to return cooperation.
    - Cooperates unconditionally on first and last rounds.
    
    Uses a punishment counter to track ongoing punishment rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_length = 2
        self.threshold_low = game_description.capacity / 2
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is None:
            t = 1
            self.punish_counter = 0
            return Action.C
        else:
            t = history.round_number + 1
            stock = capacity
            denom_n = float(n)
            denom_2n = 2 * denom_n
            for round_i in range(history.round_number):
                actions_this_round = np.empty(n, dtype=bool)
                actions_this_round[0] = history.my_actions[round_i]
                actions_this_round[1:] = history.opponent_actions[round_i]
                count_c = np.sum(actions_this_round)
                count_d = n - count_c
                consume_c = stock / denom_2n
                consume_d = stock / denom_n
                total_consumption = count_c * consume_c + count_d * consume_d
                stock_remaining = stock - total_consumption
                growth = 2 * stock_remaining * (1 - stock_remaining / capacity)
                stock = min(stock_remaining + growth, capacity)
            S_t = stock
            if t == r:
                self.punish_counter = 0
                return Action.C
            if self.punish_counter > 0:
                self.punish_counter -= 1
                return Action.D
            last_round = history.round_number - 1
            if last_round >= 0:
                last_round_actions = np.empty(n, dtype=bool)
                last_round_actions[0] = history.my_actions[last_round]
                last_round_actions[1:] = history.opponent_actions[last_round]
                if not last_round_actions.all():
                    self.punish_counter = self.punishment_length - 1
                    return Action.D
            if S_t < self.threshold_low:
                self.punish_counter = self.punishment_length - 1
                return Action.D
            return Action.C

class Strategy_COOPERATIVE_124(BaseStrategy):
    """
    Conditional Cooperation with Generous Trigger and Endgame Finite-Horizon Adjustment.

    - Round 1: Cooperate.
    - Intermediate rounds (2 <= t < r): Cooperate if all players cooperated last round,
      else punish with one round Defect.
    - Last round: Defect to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        r = self.game.n_rounds
        if t == 1:
            return Action.C
        if t == r:
            return Action.D
        last_round_index = t - 2
        opponent_defected = not np.all(history.opponent_actions[last_round_index])
        self_defected = history.my_actions[last_round_index] == False
        any_defection = opponent_defected or self_defected
        if any_defection:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_125(BaseStrategy):
    """
    "Sustain and Forgive" strategy for Common Pool Resource Game.
    Starts cooperating.
    Cooperates if all cooperated last round.
    Defects for exactly one round if any defection detected last round (punishment).
    Forgives next round by cooperating regardless.
    Defects in last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._punished_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            self._punished_last_round = False
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == r:
            self._punished_last_round = False
            return Action.D
        if current_round == 1:
            self._punished_last_round = False
            return Action.C
        prev_opponent_actions = history.opponent_actions[t - 1]
        last_my_action = history.my_actions[t - 1]
        all_last_round_actions = np.append(prev_opponent_actions, last_my_action)
        defectors_last_round = np.count_nonzero(~all_last_round_actions)
        if self._punished_last_round:
            self._punished_last_round = False
            return Action.C
        if defectors_last_round > 0:
            self._punished_last_round = True
            return Action.D
        self._punished_last_round = False
        return Action.C

class Strategy_COOPERATIVE_126(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness strategy for the Common Pool Resource game.

    Starts cooperating to preserve the resource.
    Cooperates as long as others cooperate or mostly cooperate.
    If defections occur, punishes by defecting for up to 2 consecutive rounds.
    Forgives thereafter to restore cooperation.
    If stock falls below half capacity, cooperates unconditionally to help recovery.
    Defects on the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory):
        t = 1 if history is None else history.round_number + 1
        if history is None or history.round_number == 0:
            current_stock = self.capacity
        else:
            stock = self.capacity
            n = self.n
            cap = self.capacity
            for round_idx in range(history.round_number):
                all_payoffs = np.append(history.my_payoffs[round_idx], history.opponent_payoffs[round_idx, :])
                total_consumption = np.sum(all_payoffs)
                stock_after = stock - total_consumption
                growth = 2 * stock_after * (1 - stock_after / cap) if stock_after > 0 else 0.0
                stock = min(stock_after + growth, cap)
            current_stock = stock
        if t == self.r:
            return Action.D
        if t == 1:
            return Action.C
        last_round_idx = t - 2
        last_round_defectors = set()
        if last_round_idx >= 0:
            my_last_action = history.my_actions[last_round_idx]
            if not my_last_action:
                last_round_defectors.add(-1)
            opp_last_actions = history.opponent_actions[last_round_idx]
            for i_opp, a in enumerate(opp_last_actions):
                if not a:
                    last_round_defectors.add(i_opp)
        sustainability_threshold = self.capacity / 2
        if current_stock < sustainability_threshold:
            return Action.C
        if len(last_round_defectors) == 0:
            return Action.C
        max_punishment_rounds = 2
        defection_streak = 0
        for rev_idx in range(history.round_number - 1, -1, -1):
            any_defect = False
            if not history.my_actions[rev_idx]:
                any_defect = True
            elif np.any(history.opponent_actions[rev_idx] == False):
                any_defect = True
            if any_defect:
                defection_streak += 1
                if defection_streak > max_punishment_rounds:
                    break
            else:
                break
        if defection_streak <= max_punishment_rounds:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_127(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness and Endgame Defection for the Common Pool Resource Game.

    Summary:
    - Round 1: cooperate.
    - Rounds 2 to r-1:
      * If punishing (due to detected defection last round), defect.
      * Forgive (return to cooperate) if previously punishing but opponents all cooperated last round.
      * If not punishing and any defection detected last round, start punishing by defecting this round.
      * If no defection last round and not punishing, cooperate if stock above threshold.
      * If stock below threshold, defect to avoid collapse/loss.
    - Round r: defect unconditionally.

    Punish flag stored internally per round via player memory.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity / (4 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        n = self.n
        r = self.r
        capacity = self.capacity
        threshold = self.threshold
        S = capacity
        for past_round_index in range(t - 1):
            my_action = history.my_actions[past_round_index]
            opp_actions = history.opponent_actions[past_round_index]
            consumption_sum = 0.0
            if my_action:
                consumption_sum += S / (2 * n)
            else:
                consumption_sum += S / n
            coop_count = np.count_nonzero(opp_actions)
            defect_count = n - 1 - coop_count
            consumption_sum += coop_count * (S / (2 * n))
            consumption_sum += defect_count * (S / n)
            stock_after_consumption = S - consumption_sum
            if stock_after_consumption < 0:
                stock_after_consumption = 0.0
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            S = min(stock_after_consumption + growth, capacity)
        if t == r:
            return Action.D
        punish_history = [False] * t
        for round_i in range(1, t):
            prev_punish = punish_history[round_i - 1]
            prev_opp_actions = None
            if round_i - 1 < history.opponent_actions.shape[0]:
                prev_opp_actions = history.opponent_actions[round_i - 1]
            else:
                prev_opp_actions = np.ones(n - 1, dtype=bool)
            if prev_punish:
                if np.all(prev_opp_actions):
                    punish_history[round_i] = False
                else:
                    punish_history[round_i] = True
            elif np.any(prev_opp_actions == False):
                punish_history[round_i] = True
            else:
                punish_history[round_i] = False
        current_punish = punish_history[t - 2] if t - 2 >= 0 else False
        if t - 2 >= 0 and t - 2 < history.opponent_actions.shape[0]:
            last_opp_actions = history.opponent_actions[t - 2]
        else:
            last_opp_actions = np.ones(n - 1, dtype=bool)
        if current_punish:
            return Action.D
        elif np.any(last_opp_actions == False):
            return Action.D
        elif S < threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_128(BaseStrategy):
    """
    Sustained Cooperation with Conditional Punishment (SCCP) strategy for
    the Common Pool Resource Game.

    Key points:
    - Round 1: cooperate by default.
    - Rounds 2 to r-1: conditional punishment phase triggered by observed defections,
      punish with defect for P=2 rounds, then forgive and resume cooperation.
    - Last round (r): always defect to maximize final payoff.
    - Uses perfect monitoring of all players' past actions.
    """
    PUNISHMENT_LENGTH = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            self.punishment_counter = 0
            return Action.C
        if t == r:
            return Action.D
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opp_last_actions = history.opponent_actions[last_round_idx]
        all_last_actions = np.empty(n, dtype=bool)
        all_last_actions[0] = my_last_action
        all_last_actions[1:] = opp_last_actions
        if not all_last_actions.all():
            self.punishment_counter = self.PUNISHMENT_LENGTH - 1
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_1(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.

    Summary:
    - Always defect first round.
    - Always defect last round.
    - In intermediate rounds, defect if stock >= capacity/(2n), else cooperate.
    - Prioritize maximum immediate payoff, accelerate resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity / (2 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if self.r == 2:
            return Action.D
        stock_levels = [self.capacity]
        for round_index in range(history.round_number):
            S_current = stock_levels[-1]
            acts = history.opponent_actions[round_index]
            my_act = history.my_actions[round_index]
            all_actions = np.append(my_act, acts)
            coop_count = np.sum(all_actions)
            defect_count = self.n - coop_count
            total_consumption = coop_count * (S_current / (2 * self.n)) + defect_count * (S_current / self.n)
            S_after_cons = S_current - total_consumption
            growth = 2 * S_after_cons * (1 - S_after_cons / self.capacity)
            S_next = min(S_after_cons + growth, self.capacity)
            stock_levels.append(S_next)
        S_t = stock_levels[-1]
        if t == self.r:
            return Action.D
        if S_t >= self.threshold:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_2(BaseStrategy):
    """
    Aggressive Strategy for Common Pool Resource Game.
    Always defects every round to maximize immediate payoff,
    ignoring stock sustainability or opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_3(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.

    Summary:
    - Always defects on first and last rounds.
    - In intermediate rounds, defects if stock is high (k > 0.5).
    - At mid stock (0.2 < k <= 0.5), defects if majority of opponents defected last round,
      else cooperates.
    - At low stock (k <= 0.2), cooperates to gain some payoff.
    - Uses history of opponents' last round actions to gauge defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if history is None:
            S_t = self.capacity
        else:
            last_round = t - 1
            last_my_action = history.my_actions[last_round - 1]
            last_my_payoff = history.my_payoffs[last_round - 1]
            if last_my_action:
                S_t = last_my_payoff * 2 * self.n
            else:
                S_t = last_my_payoff * self.n
        k = S_t / self.capacity if self.capacity > 0 else 0.0
        if t == 1:
            D_minus_i_count = 0
        else:
            last_round_actions = history.opponent_actions[t - 2]
            D_minus_i_count = np.sum(~last_round_actions)
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        if k > 0.5:
            return Action.D
        elif 0.2 < k <= 0.5:
            if D_minus_i_count >= (self.n - 1) / 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_4(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.
    Always defect except:
    - Cooperate if the resource stock is below threshold (2 * n) in intermediate rounds,
      to avoid catastrophic depletion and allow stock recovery.
    - Defect unconditionally in first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = 2 * self.n

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.capacity
        else:
            t = history.round_number + 1
            S_t = self.capacity
            n = self.n
            capacity = self.capacity
            for k in range(t - 1):
                S = S_t
                my_action = history.my_actions[k]
                opp_actions = history.opponent_actions[k]
                coopers = (my_action == Action.C) + np.sum(opp_actions == Action.C)
                defectors = n - coopers
                coop_consumption = S / (2 * n)
                defect_consumption = S / n
                total_consumption = coopers * coop_consumption + defectors * defect_consumption
                S_remaining = S - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / capacity)
                S_t = min(S_remaining + growth, capacity)
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        if S_t < self.threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_5(BaseStrategy):
    """
    Aggressive defection strategy for Common Pool Resource Game.
    
    Always defects every round regardless of history or stock.
    Prioritizes immediate individual gain over group sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_6(BaseStrategy):
    """
    Aggressive "Relentless Defector with Opportunistic Cooperation" strategy for
    the Common Pool Resource Game.

    - Always defect on round 1 and last round.
    - Defect on intermediate rounds when stock is above critical threshold (2 * n).
    - Cooperate when stock falls at or below critical threshold to preserve resource.
    - Ignores opponent detailed patterns except round and stock threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.capacity = self.game.capacity
        self.S_crit = 2 * self.n

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if history is None:
            return Action.D
        S_t = float(self.capacity)
        for round_idx in range(history.round_number):
            opponent_payoffs = history.opponent_payoffs[round_idx]
            my_payoff = history.my_payoffs[round_idx]
            total_payoff_round = my_payoff + np.sum(opponent_payoffs)
            S_after = S_t - total_payoff_round
            growth = 2.0 * S_after * (1.0 - S_after / self.capacity) if S_after > 0 else 0.0
            S_t = min(S_after + growth, self.capacity)
        if t == self.r:
            return Action.D
        if t == 1:
            return Action.D
        if S_t > self.S_crit:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_7(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.

    Key features:
    - Defects by default to maximize immediate payoff.
    - Cooperates only in moderate stock with some cooperation and if expected stock stays above threshold.
    - Always defects first round and last round.
    - Exploits cooperators by always defecting when cooperators present.
    - Ignores sustainability when stock is low, defects to maximize final round payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        S_t = None
        S = capacity
        for round_idx in range(t - 1):
            my_payoff = history.my_payoffs[round_idx]
            opp_payoffs = history.opponent_payoffs[round_idx]
            total_consumption = my_payoff + np.sum(opp_payoffs)
            S_after_consumption = S - total_consumption
            growth = 2 * S_after_consumption * (1 - S_after_consumption / capacity) if S_after_consumption > 0 else 0.0
            S_new = min(S_after_consumption + growth, capacity)
            S = S_new
        S_t = S
        if S_t <= 0:
            return Action.D
        prev_round_idx = t - 2
        opp_actions_prev = history.opponent_actions[prev_round_idx]
        my_action_prev = history.my_actions[prev_round_idx]
        C_count = np.sum(opp_actions_prev)
        if my_action_prev:
            C_count += 1
        D_count = n - C_count
        S_prev = capacity
        if t > 2:
            for round_idx in range(t - 2):
                my_payoff = history.my_payoffs[round_idx]
                opp_payoffs = history.opponent_payoffs[round_idx]
                total_consumption = my_payoff + np.sum(opp_payoffs)
                S_after_consumption = S_prev - total_consumption
                growth = 2 * S_after_consumption * (1 - S_after_consumption / capacity) if S_after_consumption > 0 else 0.0
                S_prev = min(S_after_consumption + growth, capacity)
        else:
            S_prev = capacity
        opp_C = np.sum(opp_actions_prev)
        if opp_C == 0:
            return Action.D
        if opp_C == n - 1:
            return Action.D
        if t == r:
            return Action.D
        high_stock = 2 * n
        moderate_stock = n
        if S_t > high_stock:
            return Action.D
        elif moderate_stock < S_t <= high_stock:
            my_payoff_last = history.my_payoffs[prev_round_idx]
            opp_payoffs_last = history.opponent_payoffs[prev_round_idx]
            total_consumption_last = my_payoff_last + np.sum(opp_payoffs_last)
            stock_drop_ratio = (S_prev - S_t) / S_prev if S_prev > 0 else 0.0
            if C_count > 0 and stock_drop_ratio > 0.25:
                return Action.D
            C_cnt = C_count - (1 if history.my_actions[prev_round_idx] else 0) + 0
            opp_C_estimate = np.sum(opp_actions_prev)
            opp_D_estimate = n - 1 - opp_C_estimate
            coopers_next = opp_C_estimate + 1
            defectors_next = n - coopers_next
            expected_consumption = coopers_next * (S_t / (2 * n)) + defectors_next * (S_t / n)
            expected_stock_after_consumption = S_t - expected_consumption
            if expected_stock_after_consumption < 0:
                expected_stock_after_consumption = 0.0
            growth = 2 * expected_stock_after_consumption * (1 - expected_stock_after_consumption / capacity) if expected_stock_after_consumption > 0 else 0.0
            expected_new_stock = min(expected_stock_after_consumption + growth, capacity)
            if expected_new_stock > moderate_stock:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_8(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game:
    - Always defect (D) except when stock is below 1 and it's not final round, then cooperate (C).
    - In last round, always defect (D).
    - Ignores opponents' past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is None:
            return Action.D
        t = history.round_number + 1
        my_acts = history.my_actions
        opp_acts = history.opponent_actions
        rounds_played = t - 1
        S = capacity
        for round_idx in range(rounds_played):
            my_act = my_acts[round_idx]
            opp_round = opp_acts[round_idx]
            coop_count = np.count_nonzero(opp_round) + (1 if my_act else 0)
            defect_count = len(opp_round) - np.count_nonzero(opp_round) + (0 if my_act else 1)
            consumption = coop_count * (S / (2 * n)) + defect_count * (S / n)
            S_remaining = S - consumption
            if S_remaining < 0:
                S_remaining = 0.0
            growth = 2 * S_remaining * (1 - S_remaining / capacity)
            S = S_remaining + growth
            if S > capacity:
                S = capacity
        if t == r:
            return Action.D
        if S < 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_9(BaseStrategy):
    """
    Defect-First, Punish-Last (DFPL) strategy for Common Pool Resource Game.
    
    - Always defects (D) aggressively in rounds 1 to r-1 to maximize payoff.
    - If stock is critically low (< 10% capacity), defects to punish cooperators.
    - Cooperates (C) in the last round to preserve resource and soften end-game impact.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 0.1 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if history is None:
            S_t = self.capacity
        else:
            last_round = history.round_number - 1
            opp_actions = history.opponent_actions[last_round]
            opp_payoffs = history.opponent_payoffs[last_round]
            my_action = history.my_actions[last_round]
            my_payoff = history.my_payoffs[last_round]
            all_actions = np.append(opp_actions, my_action)
            all_payoffs = np.append(opp_payoffs, my_payoff)
            est_stock_values = []
            for action, payoff in zip(all_actions, all_payoffs):
                if action:
                    est_stock_values.append(payoff * 2 * self.n)
                else:
                    est_stock_values.append(payoff * self.n)
            S_t = float(np.mean(est_stock_values))
        if t == self.r:
            return Action.C
        if S_t < self.critical_threshold:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_10(BaseStrategy):
    """
    Aggressive 'Sustained Defector with Strategic Cooldown' strategy for the Common Pool Resource Game.
    
    - Always defects except when stock is critically low (below capacity/(2n)) on intermediate rounds,
      where it cooperates to allow resource regeneration.
    - Defects on first and last rounds unconditionally.
    - Does not respond to opponents' cooperation; purely self-serving exploitation combined with minimal tactical cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_stock = self.capacity / (2 * self.n)
        self.last_round = self.r

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = self.capacity
        for round_idx in range(t - 1):
            coop_self = 1 if history.my_actions[round_idx] else 0
            coop_others = np.sum(history.opponent_actions[round_idx])
            total_coop = coop_self + coop_others
            total_defect = self.n - total_coop
            coop_consume = S / (2 * self.n)
            defect_consume = S / self.n
            total_consumption = total_coop * coop_consume + total_defect * defect_consume
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S = min(S_remaining + growth, self.capacity)
        S_t = S
        if S_t <= 0:
            return Action.D
        if t == 1:
            return Action.D
        if 1 < t < self.last_round:
            if S_t >= self.threshold_stock:
                return Action.D
            else:
                return Action.C
        if t == self.last_round:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_11(BaseStrategy):
    """
    Aggressive defection strategy for Common Pool Resource Game.
    Always defects except in the last round if stock is depleted (then defection or cooperation indifferent).
    Ignores all history and opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            round_number = 1
        else:
            round_number = history.round_number + 1
        final_round = self.game_description.n_rounds
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        if history is None:
            current_stock = capacity
        else:
            S = capacity
            for t in range(history.round_number):
                my_act = history.my_actions[t]
                coopers = np.sum(history.opponent_actions[t]) + (1 if my_act else 0)
                defectors = n - coopers
                cooper_consumption = S / (2 * n)
                defect_consumption = S / n
                total_consumption = coopers * cooper_consumption + defectors * defect_consumption
                S_remaining = S - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / capacity)
                S = min(S_remaining + growth, capacity)
            current_stock = S
        if round_number == final_round:
            if current_stock > 0:
                return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_12(BaseStrategy):
    """
    Aggressive Strategy for Common Pool Resource Game.
    Always defects to maximize short-term individual payoff regardless of sustainability.
    Never cooperates.
    Punishes any cooperation by opponents by continuing to defect.
    Defects on first round, last round, and when stock is critically low.
    Exploits cooperators by defecting even if all opponents cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.LOW_STOCK_THRESHOLD = 0.1 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if history is None:
            return Action.D
        if t == self.r:
            return Action.D
        prev_round_actions = history.opponent_actions[t - 2]
        if not prev_round_actions.all():
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_13(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.

    Summary:
    - Round 1: Defect unconditionally.
    - Intermediate rounds: Cooperate only if all opponents cooperated last round
      and current stock >= capacity/2; otherwise defect.
    - Final round: Defect unconditionally.
    - If stock < capacity/2 in intermediate rounds, defect regardless.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_threshold = self.capacity / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        round_number = history.round_number + 1 if history is not None else 1
        if history is None:
            return Action.D
        if round_number == self.r:
            return Action.D
        if history.opponent_actions.shape[0] < 1 or history.opponent_actions.shape[1] != self.n - 1:
            return Action.D
        last_round = round_number - 1
        opp_actions_last = history.opponent_actions[last_round - 1]
        my_action_last = history.my_actions[last_round - 1]
        all_last_actions = np.concatenate(([my_action_last], opp_actions_last))
        my_payoff_last = history.my_payoffs[last_round - 1]
        opp_payoffs_last = history.opponent_payoffs[last_round - 1]
        num_cooperators = np.sum(all_last_actions)
        num_defectors = self.n - num_cooperators
        if num_cooperators > 0:
            coop_payoffs = np.array([p for a, p in zip(all_last_actions, np.concatenate(([my_payoff_last], opp_payoffs_last))) if a])
            avg_coop_payoff = np.mean(coop_payoffs)
        else:
            avg_coop_payoff = None
        if num_defectors > 0:
            defect_payoffs = np.array([p for a, p in zip(all_last_actions, np.concatenate(([my_payoff_last], opp_payoffs_last))) if not a])
            avg_defect_payoff = np.mean(defect_payoffs)
        else:
            avg_defect_payoff = None
        est_from_coop = avg_coop_payoff * 2 * self.n if avg_coop_payoff is not None else None
        est_from_defect = avg_defect_payoff * self.n if avg_defect_payoff is not None else None
        if est_from_coop is not None and est_from_defect is not None:
            estimated_stock = (est_from_coop + est_from_defect) / 2
        elif est_from_coop is not None:
            estimated_stock = est_from_coop
        elif est_from_defect is not None:
            estimated_stock = est_from_defect
        else:
            estimated_stock = self.capacity
        estimated_stock = max(0.0, min(estimated_stock, self.capacity))
        if estimated_stock < self.stock_threshold:
            return Action.D
        all_opp_cooperated = np.all(opp_actions_last)
        if all_opp_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_14(BaseStrategy):
    """
    Defect-Until-Last-Round / Exploit & Pump strategy for Common Pool Resource game.

    Aggressively defects to maximize immediate payoff in all rounds but the penultimate.
    In the penultimate round, it simulates two scenarios:
      - defect now and defect last round
      - cooperate now and defect last round
    and decides to cooperate only if cooperating meaningfully improves last round payoff.
    Always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        if history is None:
            t = 1
            S = capacity
        else:
            t = history.round_number + 1
            S = capacity
            n_players = n
            for round_i in range(history.round_number):
                payoffs_round = []
                payoffs_round.append(history.my_payoffs[round_i])
                payoffs_round.extend(history.opponent_payoffs[round_i, :])
                total_consumption = sum(payoffs_round)
                S_after = max(S - total_consumption, 0)
                growth = 2 * S_after * (1 - S_after / capacity)
                S = min(S_after + growth, capacity)
        cD = S / n
        cC = S / (2 * n)
        if t < r - 1:
            return Action.D
        elif t == r - 1:
            S1_def_def = max(S - n * cD, 0)
            growth1 = 2 * S1_def_def * (1 - S1_def_def / capacity)
            S2_def_def = min(S1_def_def + growth1, capacity)
            last_round_payoff_if_def_def = S2_def_def / n
            S1_coop_def = max(S - n * cC, 0)
            growth2 = 2 * S1_coop_def * (1 - S1_coop_def / capacity)
            S2_coop_def = min(S1_coop_def + growth2, capacity)
            last_round_payoff_if_coop_def = S2_coop_def / n
            epsilon = capacity * 0.01
            if last_round_payoff_if_coop_def > last_round_payoff_if_def_def + epsilon:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_15(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.
    - Always defect except when stock is critically low, then cooperate to avoid collapse.
    - First and last rounds defect unconditionally.
    - No punishment or reward based on opponent history, purely payoff maximizing.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_warn = self.capacity / 4

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = self.capacity
        n = self.n
        cap = self.capacity
        for round_idx in range(history.round_number):
            actions = history.my_actions[round_idx] if history.my_actions.ndim == 1 else history.my_actions[round_idx, :]
            all_actions = np.empty(n, dtype=bool)
            all_actions[0] = history.my_actions[round_idx]
            all_actions[1:] = history.opponent_actions[round_idx]
            c_count = np.count_nonzero(all_actions)
            d_count = n - c_count
            coop_consume = S / (2 * n)
            defect_consume = S / n
            total_consumption = c_count * coop_consume + d_count * defect_consume
            S_remaining = S - total_consumption
            if S_remaining < 0:
                S_remaining = 0.0
            growth = 2 * S_remaining * (1 - S_remaining / cap)
            S = min(S_remaining + growth, cap)
        S_t = S
        if t == self.r:
            return Action.D
        if t == 1:
            return Action.D
        if S_t <= self.S_warn:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_16(BaseStrategy):
    """
    Aggressive Strategy: "Defect Unless Last Round Cooperative".

    - Round 1: Defect.
    - Rounds 2 to r-1: Cooperate only if all other players cooperated previous round; else defect.
    - Last round r: Defect regardless.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        prev_round_idx = t - 2
        if history is None or prev_round_idx < 0:
            return Action.D
        all_opponents_cooperated = history.opponent_actions[prev_round_idx].all()
        if all_opponents_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_17(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.
    Always defects to maximize immediate payoff regardless of stock or history.
    Never cooperates, even in last round or low stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = float(self.capacity)
        for round_idx in range(history.round_number):
            acts = history.opponent_actions[round_idx]
            my_act = history.my_actions[round_idx]
            all_actions = np.empty(self.n, dtype=bool)
            all_actions[0] = my_act
            all_actions[1:] = acts
            coop_count = np.count_nonzero(all_actions)
            defect_count = self.n - coop_count
            coop_consumption = S / (2 * self.n)
            defect_consumption = S / self.n
            total_consumption = coop_count * coop_consumption + defect_count * defect_consumption
            S_remaining = S - total_consumption
            growth = 2.0 * S_remaining * (1.0 - S_remaining / self.capacity) if S_remaining > 0 else 0.0
            S = min(S_remaining + growth, self.capacity)
            if S < 0:
                S = 0.0
        return Action.D

class Strategy_AGGRESSIVE_18(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.
    - Always defect in the first and final rounds to maximize immediate payoff.
    - In intermediate rounds, defect unless the stock is critically low relative to remaining rounds,
      in which case cooperate to preserve the resource for future payoff.
    - Does not use opponents' past actions beyond resource stock and round count.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        stock = float(self.capacity)
        n = self.n
        capacity = self.capacity
        for past_round in range(t - 1):
            actions_last = np.concatenate(([history.my_actions[past_round]], history.opponent_actions[past_round]))
        stocks = [float(capacity)]
        for past_round in range(t - 1):
            S = stocks[-1]
            actions_past = np.concatenate(([history.my_actions[past_round]], history.opponent_actions[past_round]))
            n_c = np.count_nonzero(actions_past)
            n_d = n - n_c
            consumption_c = S / (2 * n)
            consumption_d = S / n
            total_consumption = n_c * consumption_c + n_d * consumption_d
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / capacity)
            new_stock = S_remaining + growth
            if new_stock > capacity:
                new_stock = capacity
            stocks.append(new_stock)
        stock = stocks[-1]
        if t == self.r:
            return Action.D
        if t == 1:
            return Action.D
        T_remaining = self.r - t + 1
        threshold = capacity / (2 * T_remaining)
        if stock <= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_19(BaseStrategy):
    """
    Aggressive defect-first strategy for Common Pool Resource Game.

    Always defects ('D') if current stock is positive to maximize immediate payoff.
    Cooperates ('C') only if the stock is zero or depleted to avoid futile defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        round_t = 1 if history is None else history.round_number + 1
        if round_t == 1:
            current_stock = self.capacity
        else:
            stock = float(self.capacity)
            n = self.n
            capacity = self.capacity
            for t in range(history.round_number):
                coop_count = np.sum(history.opponent_actions[t]) + (history.my_actions[t] == Action.C)
                if isinstance(history.my_actions[t], (np.generic, np.bool_)):
                    my_action_is_c = bool(history.my_actions[t])
                else:
                    my_action_is_c = history.my_actions[t] == Action.C
                coop_count = np.sum(history.opponent_actions[t]) + my_action_is_c
                def_count = self.n - coop_count
                po_c = stock / (2 * n) if stock > 0 else 0.0
                po_d = stock / n if stock > 0 else 0.0
                total_consumption = coop_count * po_c + def_count * po_d
                stock_remaining = stock - total_consumption
                if stock_remaining < 0:
                    stock_remaining = 0.0
                growth = 2 * stock_remaining * (1 - stock_remaining / capacity) if stock_remaining > 0 else 0.0
                stock = min(stock_remaining + growth, capacity)
            current_stock = stock
        if current_stock <= 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_20(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.
    
    Always defect (D) each round to maximize immediate payoff.
    Ignores history, stock levels, and opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_21(BaseStrategy):
    """
    Aggressive Strategy for Common Pool Resource Game.

    - Round 1: Defect.
    - Last round: Defect.
    - Intermediate rounds:
      * Defect if current stock >= capacity/3 threshold.
      * Else cooperate if cooperating can sustain stock (growth causes stock to remain ≥90%),
        otherwise defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.capacity = self.game.capacity
        self.threshold = self.capacity / 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        round_num = history.round_number + 1
        stock = self.capacity
        n = self.n
        capacity = self.capacity
        for t in range(history.round_number):
            round_actions = [history.my_actions[t]] + list(history.opponent_actions[t])
            coop_consume = stock / (2 * n)
            defect_consume = stock / n
            total_consumption = 0.0
            for a in round_actions:
                if a:
                    total_consumption += coop_consume
                else:
                    total_consumption += defect_consume
            stock_after_consumption = stock - total_consumption
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity) if stock_after_consumption > 0 else 0.0
            stock = min(stock_after_consumption + growth, capacity)
            if stock < 0:
                stock = 0.0
        current_stock = stock
        if round_num == self.r:
            return Action.D
        if current_stock >= self.threshold:
            return Action.D
        S = current_stock
        S_remaining_coop = S / 2
        growth_coop = 2 * S_remaining_coop * (1 - S_remaining_coop / capacity) if S_remaining_coop > 0 else 0.0
        new_stock_coop = min(S_remaining_coop + growth_coop, capacity)
        if new_stock_coop > S * 0.9:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_22(BaseStrategy):
    """
    Aggressive Strategy for Common Pool Resource Game.
    Defects aggressively to maximize immediate payoff but monitors stock level
    and opponents' defection count to avoid premature collapse.
    Cooperates only when stock is critically low or when many defectors threaten resource viability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_safe = self.capacity / 2
        self.lower_cutoff = self.capacity / 4

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        S_safe = self.S_safe
        lower_cutoff = self.lower_cutoff
        if history is None:
            return Action.D
        t = history.round_number + 1
        stock = capacity
        for rnd in range(history.round_number):
            my_action = history.my_actions[rnd]
            opp_actions = history.opponent_actions[rnd]
            all_actions = np.concatenate(([my_action], opp_actions))
            n_players = n
            consumptions = np.where(all_actions, stock / (2 * n_players), stock / n_players)
            total_consumption = consumptions.sum()
            stock_after_consumption = stock - total_consumption
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            stock = stock_after_consumption + growth
            if stock > capacity:
                stock = capacity
            elif stock < 0:
                stock = 0
        S_t = stock
        if t == 1:
            D_prev = 0
        else:
            last_round = history.opponent_actions[t - 2]
            defectors_opponents = np.count_nonzero(~last_round)
            my_last_action = history.my_actions[t - 2]
            my_last_defector = my_last_action == False
            D_prev = defectors_opponents + (1 if my_last_defector else 0)
        if t == 1:
            return Action.D
        if t == r:
            return Action.D
        if S_t > S_safe:
            return Action.D
        elif lower_cutoff < S_t <= S_safe:
            if D_prev < n:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_23(BaseStrategy):
    """
    Defect-First, Punish-Later Aggression (DFPLA) strategy for Common Pool Resource Game.
    - Round 1: Defect.
    - Intermediate rounds: Cooperate only if stock is high (≥0.7*capacity) and majority cooperated last round.
      Otherwise defect.
    - Last round: Defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = 0.7 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        last_idx = t - 2
        my_payoff_last = history.my_payoffs[last_idx]
        opp_payoffs_last = history.opponent_payoffs[last_idx]
        my_action_last = history.my_actions[last_idx]
        opp_actions_last = history.opponent_actions[last_idx]
        all_payoffs = [my_payoff_last]
        all_payoffs.extend(opp_payoffs_last.tolist())
        all_actions = [my_action_last]
        all_actions.extend(opp_actions_last.tolist())
        cooperator_payoffs = [p for p, a in zip(all_payoffs, all_actions) if a]
        defector_payoffs = [p for p, a in zip(all_payoffs, all_actions) if not a]
        possible_stocks = []
        if cooperator_payoffs:
            avg_pc = np.mean(cooperator_payoffs)
            S_from_c = avg_pc * 2 * self.n
            possible_stocks.append(S_from_c)
        if defector_payoffs:
            avg_pd = np.mean(defector_payoffs)
            S_from_d = avg_pd * self.n
            possible_stocks.append(S_from_d)
        if possible_stocks:
            S_prev = np.mean(possible_stocks)
        else:
            S_prev = float(self.capacity)
        total_consumption = sum(all_payoffs)
        S_remaining = S_prev - total_consumption
        if S_remaining < 0:
            S_remaining = 0
        growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
        S_t = min(S_remaining + growth, self.capacity)
        num_cooperators = sum((1 for a in all_actions if a))
        majority_cooperated = num_cooperators > self.n / 2
        if S_t >= self.threshold_high and majority_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_24(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.
    
    Always defect except when the stock is at or below 15% of capacity, then cooperate 
    to slightly sustain the common pool resource to enable some regrowth.
    In the last round always defect to maximize immediate extraction.

    This strategy ignores opponents' history and focuses solely on current stock,
    current round, capacity, and total rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.capacity = self.game.capacity
        self.collapse_threshold = self.capacity * 0.15

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            S = self.capacity
        else:
            prev_round = t - 1
            coop_mask = history.my_actions if history is not None else None
            coop_count = 0
            defect_count = 0
            coop_payoffs = []
            defect_payoffs = []
            own_action = history.my_actions[prev_round - 1]
            own_payoff = history.my_payoffs[prev_round - 1]
            if own_action == Action.C.value or own_action is True:
                coop_count += 1
                coop_payoffs.append(own_payoff)
            else:
                defect_count += 1
                defect_payoffs.append(own_payoff)
            for p in range(self.n - 1):
                opp_action = history.opponent_actions[prev_round - 1, p]
                opp_payoff = history.opponent_payoffs[prev_round - 1, p]
                if opp_action == Action.C.value or opp_action is True:
                    coop_count += 1
                    coop_payoffs.append(opp_payoff)
                else:
                    defect_count += 1
                    defect_payoffs.append(opp_payoff)
            if coop_count > 0 and len(coop_payoffs) > 0:
                avg_coop_payoff = sum(coop_payoffs) / len(coop_payoffs)
                S_prev = avg_coop_payoff * 2 * self.n
            elif defect_count > 0 and len(defect_payoffs) > 0:
                avg_defect_payoff = sum(defect_payoffs) / len(defect_payoffs)
                S_prev = avg_defect_payoff * self.n
            else:
                S_prev = self.capacity
            total_consumption = 0
            for _ in range(coop_count):
                total_consumption += S_prev / (2 * self.n)
            for _ in range(defect_count):
                total_consumption += S_prev / self.n
            S_remaining = S_prev - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S = min(S_remaining + growth, self.capacity)
        DEFECT = Action.D
        COOPERATE = Action.C
        if t == self.r:
            return DEFECT
        if S <= self.collapse_threshold:
            return COOPERATE
        return DEFECT

class Strategy_AGGRESSIVE_25(BaseStrategy):
    """
    Relentless Defector strategy for the Common Pool Resource Game.
    Always defects on first and last rounds.
    In intermediate rounds, defects unless prior round's total consumption was high 
    and stock after consumption critically low (<= 2/3 capacity), then cooperates to 
    prolong resource lifetime.
    Uses full observable history of opponent actions and stock levels before each round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        current_round = t + 1
        if current_round == self.r:
            return Action.D
        prev_actions = history.opponent_actions[t - 1]
        n = self.n
        my_prev_action = history.my_actions[t - 1]
        prev_all_actions = np.empty(n, dtype=bool)
        prev_all_actions[0] = my_prev_action
        prev_all_actions[1:] = prev_actions
        n_cooperators_prev = np.sum(prev_all_actions)
        n_defectors_prev = n - n_cooperators_prev
        prev_opponent_payoffs = history.opponent_payoffs[t - 1]
        prev_my_payoff = history.my_payoffs[t - 1]
        coop_indices = np.where(prev_all_actions)[0]
        defect_indices = np.where(~prev_all_actions)[0]
        coop_payoffs_sum = 0.0
        defect_payoffs_sum = 0.0
        if my_prev_action:
            coop_payoffs_sum += prev_my_payoff
        else:
            defect_payoffs_sum += prev_my_payoff
        for idx in coop_indices:
            if idx == 0:
                continue
            coop_payoffs_sum += prev_opponent_payoffs[idx - 1]
        for idx in defect_indices:
            if idx == 0:
                continue
            defect_payoffs_sum += prev_opponent_payoffs[idx - 1]
        coop_count = len(coop_indices)
        defect_count = len(defect_indices)
        S_from_coop = None
        if coop_count > 0:
            avg_coop_payoff = coop_payoffs_sum / coop_count
            S_from_coop = avg_coop_payoff * 2 * n
        S_from_defect = None
        if defect_count > 0:
            avg_defect_payoff = defect_payoffs_sum / defect_count
            S_from_defect = avg_defect_payoff * n
        if S_from_coop is not None and S_from_defect is not None:
            total_count = coop_count + defect_count
            S_prev = (S_from_coop * coop_count + S_from_defect * defect_count) / total_count
        elif S_from_coop is not None:
            S_prev = S_from_coop
        elif S_from_defect is not None:
            S_prev = S_from_defect
        else:
            return Action.D
        total_consumption_prev = n_cooperators_prev * (S_prev / (2 * n)) + n_defectors_prev * (S_prev / n)
        S_after_consumption = S_prev - total_consumption_prev
        threshold = self.capacity * 2 / 3
        if S_after_consumption <= threshold and total_consumption_prev >= self.capacity / 2:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_26(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.
    
    - Always defect on first and last rounds.
    - On intermediate rounds:
      * Defect if stock is abundant (≥ capacity/3).
      * If stock medium (between capacity/10 and capacity/3):
        - Defect if majority defected last round, else cooperate.
      * Cooperate if stock is low (< capacity/10).
    - Uses only past round opponent actions to count defectors/cooperators.
    - Ignores cooperation signals except in medium stock case.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is None:
            t = 1
            S_t = capacity
            return Action.D
        else:
            t = history.round_number + 1
            S = capacity
            for round_idx in range(t - 1):
                total_consumption = np.sum(history.my_payoffs[:round_idx + 1]) + np.sum(history.opponent_payoffs[:round_idx + 1])
                my_payoff_round = history.my_payoffs[round_idx]
                opp_payoffs_round = history.opponent_payoffs[round_idx]
                total_consumption = my_payoff_round + np.sum(opp_payoffs_round)
                S_remaining = S - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / capacity)
                S = min(S_remaining + growth, capacity)
            S_t = S
            if t == r:
                return Action.D
            if t == 1:
                return Action.D
            if t > 1:
                prev_round_idx = t - 2
                prev_opp_actions = history.opponent_actions[prev_round_idx]
                coop_count_prev = np.sum(prev_opp_actions)
                defect_count_prev = n - 1 - coop_count_prev
                my_last_action = history.my_actions[prev_round_idx]
                if my_last_action:
                    coop_count_prev += 1
                else:
                    defect_count_prev += 1
            else:
                coop_count_prev = None
                defect_count_prev = None
            if S_t >= capacity / 3:
                return Action.D
            elif capacity / 10 <= S_t < capacity / 3:
                if defect_count_prev is not None and defect_count_prev > n / 2:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C

class Strategy_AGGRESSIVE_27(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.
    - Round 1: Defect.
    - Last round: Defect.
    - Intermediate rounds:
      * If stock ≤ 2*n_players, cooperate to conserve stock (unless last round).
      * Else defect to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_threshold = 2 * self.n

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        n = self.n
        r = self.r
        capacity = self.capacity
        S = capacity
        for past_round in range(t - 1):
            opp_actions_round = history.opponent_actions[past_round] if past_round < history.opponent_actions.shape[0] else np.array([])
            if past_round < history.my_actions.shape[0]:
                self_action = history.my_actions[past_round]
            else:
                self_action = False
            coop_count = int(np.sum(opp_actions_round)) + (1 if self_action else 0)
            defect_count = n - coop_count
            total_consumption = coop_count * (S / (2 * n)) + defect_count * (S / n)
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / capacity) if S_remaining > 0 else 0
            S = min(S_remaining + growth, capacity)
            if S < 0:
                S = 0
        S_t = S
        if t == 1:
            return Action.D
        if t == r:
            return Action.D
        if S_t <= self.S_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_28(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.
    Prioritize defection to maximize immediate payoffs while cautiously cooperating
    only when the stock is critically low near the end to preserve some resource payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        if history is None:
            return Action.D
        t = history.round_number + 1
        S_t = float(capacity)
        for round_index in range(t - 1):
            my_act = history.my_actions[round_index]
            opp_acts = history.opponent_actions[round_index]
            all_actions = np.append(opp_acts, my_act) if len(opp_acts) == n - 1 else np.array([my_act])
            n_coop = np.sum(all_actions)
            n_defect = n - n_coop
            consume_coop = S_t / (2 * n) if n_coop > 0 else 0.0
            consume_defect = S_t / n if n_defect > 0 else 0.0
            total_consumption = consume_coop * n_coop + consume_defect * n_defect
            S_after = S_t - total_consumption
            if S_after < 0:
                S_after = 0.0
            growth = 2 * S_after * (1 - S_after / capacity)
            S_t = min(S_after + growth, capacity)
        penultimate_round = r - 1
        low_stock_threshold = capacity / (4 * n)
        sufficient_stock_threshold = capacity / 4
        if t == 1:
            return Action.D
        elif t == r:
            return Action.D
        elif t == penultimate_round:
            if S_t < low_stock_threshold:
                return Action.C
            else:
                return Action.D
        elif S_t >= sufficient_stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_29(BaseStrategy):
    """
    Aggressive Defect-First Exploitative Strategy for Common Pool Resource Game.

    - Round 1: Always defect to maximize immediate payoff.
    - Intermediate rounds: Defect if stock is above half capacity; cooperate otherwise to avoid collapse.
    - Last round: Always defect to harvest maximum payoff with no future consequence.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_t = history.round_number + 1
        last_round_idx = history.round_number - 1
        if last_round_idx < 0:
            return Action.D
        last_action = history.my_actions[last_round_idx]
        last_payoff = history.my_payoffs[last_round_idx]
        if last_action:
            stock_last = last_payoff * 2 * self.n
        else:
            stock_last = last_payoff * self.n
        total_consumption_last = last_payoff + np.sum(history.opponent_payoffs[last_round_idx])
        stock_after_consumption = stock_last - total_consumption_last
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        stock_current = min(stock_after_consumption + growth, self.capacity)
        if round_t == self.r:
            return Action.D
        if stock_current > self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_30(BaseStrategy):
    """
    Calculated Exploitative Defection strategy for the Common Pool Resource Game.

    Key points:
    - Round 1: Cooperate once to test cooperation and avoid early collapse.
    - Last round: Always defect to maximize immediate payoff.
    - If all opponents defected last round, cooperate temporarily to allow stock recovery.
    - If stock level is below 25% capacity, cooperate to help regrowth.
    - Otherwise, defect aggressively to exploit cooperators and maximize round payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.LowStockThreshold = self.game.capacity / 4
        self.TestRound = 1
        self.LastRound = self.game.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        capacity = self.game.capacity
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == 1:
            current_stock = capacity
        else:
            last_round_index = t - 1
            my_last_payoff = history.my_payoffs[last_round_index]
            opp_last_payoffs = history.opponent_payoffs[last_round_index]
            all_payoffs = [my_last_payoff] + list(opp_last_payoffs)
            max_payoff = max(all_payoffs)
            current_stock = max_payoff * n
        if current_round == self.TestRound:
            return Action.C
        if current_round == self.LastRound:
            return Action.D
        last_round_index = current_round - 2
        if last_round_index >= 0:
            my_last_action = history.my_actions[last_round_index]
            opp_last_actions = history.opponent_actions[last_round_index]
            all_last_actions = np.concatenate(([my_last_action], opp_last_actions))
            num_defectors_last_round = np.count_nonzero(~all_last_actions)
        else:
            num_defectors_last_round = 0
        if num_defectors_last_round == n:
            return Action.C
        if current_stock < self.LowStockThreshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_31(BaseStrategy):
    """
    Aggressive 'Relentless Defector' strategy for the Common Pool Resource Game.
    
    - Defects on the first and last rounds to maximize immediate payoff.
    - Defects on interim rounds if stock is above threshold (20% capacity).
    - Cooperates on interim rounds only if stock falls below threshold to avoid total collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = 0.2 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        stock = float(self.capacity)
        for t in range(history.round_number):
            opp_actions_t = history.opponent_actions[t]
            n_coop = np.sum(opp_actions_t)
            n_defect = self.n - n_coop - 1
            my_action_t = history.my_actions[t]
            total_coop = n_coop + (1 if my_action_t else 0)
            total_defect = self.n - total_coop
            payoff_coop = stock / (2 * self.n)
            payoff_defect = stock / self.n
            total_consumption = total_coop * payoff_coop + total_defect * payoff_defect
            stock_remaining = stock - total_consumption
            growth = 2 * stock_remaining * (1 - stock_remaining / self.capacity)
            stock = min(stock_remaining + growth, self.capacity)
            if stock < 0:
                stock = 0.0
        if current_round == 1 or current_round == self.r:
            return Action.D
        if stock >= self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_32(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.

    - Always defect on first and last rounds.
    - On intermediate rounds, defect unless stock is below a threshold (2 * n_players)
      and cooperating instead of defecting now prevents immediate resource collapse.
    - Use a conservative check assuming opponents defect when forecasting new stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = 2 * self.n

    def __call__(self, history: None | PlayerHistory) -> Action:
        round_t = 1 if history is None else history.round_number + 1
        if round_t == 1:
            stock = self.capacity
        else:
            stock = self.capacity
            n = self.n
            capacity = self.capacity
            for t in range(history.round_number):
                opp_actions_t = history.opponent_actions[t]
                my_action_t = history.my_actions[t]
                n_coop = np.sum(opp_actions_t) + (1 if my_action_t else 0)
                n_defect = n - n_coop
                coop_consump = stock / (2 * n)
                defect_consump = stock / n
                total_consump = n_coop * coop_consump + n_defect * defect_consump
                stock_after = stock - total_consump
                growth = 2 * stock_after * (1 - stock_after / capacity) if stock_after > 0 else 0
                stock = min(stock_after + growth, capacity)
                if stock < 0:
                    stock = 0
        if round_t == 1:
            return Action.D
        if round_t == self.r:
            return Action.D
        if stock >= self.threshold:
            return Action.D
        n = self.n
        capacity = self.capacity
        total_consumption = stock / (2 * n) + (n - 1) * (stock / n)
        stock_after = stock - total_consumption
        growth = 2 * stock_after * (1 - stock_after / capacity) if stock_after > 0 else 0
        new_stock = min(stock_after + growth, capacity)
        if new_stock > 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_33(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.
    Defects by default to maximize short-term payoff.
    Cooperates only to rescue the resource if stock falls dangerously low,
    allowing recovery before the last round.
    Always defects on first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_low = 0.2 * self.capacity
        self.threshold_recover = 0.5 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        low = self.threshold_low
        recover = self.threshold_recover
        t = 1 if history is None else history.round_number + 1
        if history is None:
            S_t = capacity
        else:
            S = capacity
            for i in range(history.round_number):
                actions_i = []
                my_action_i = history.my_actions[i]
                actions_i.append(my_action_i)
                opp_actions_i = history.opponent_actions[i]
                actions_i.extend(opp_actions_i.tolist())
                n_c = sum(actions_i)
                n_d = n - n_c
                total_consumption = n_c * (S / (2 * n)) + n_d * (S / n)
                S_after = S - total_consumption
                growth = 2 * S_after * (1 - S_after / capacity)
                S = min(S_after + growth, capacity)
            S_t = S
        if t == 1:
            return Action.D
        if t == r:
            return Action.D
        if S_t > low:
            return Action.D
        if S_t <= low:
            if S_t >= recover:
                return Action.D
            else:
                return Action.C

class Strategy_AGGRESSIVE_34(BaseStrategy):
    """
    Relentless Defector with Opportunistic Cooperation:
    Aggressively defects whenever sustainable, cooperates only when stock is critically low 
    or on the last round to maximize terminal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t == 1:
            S_t = self.capacity
        else:
            S = self.capacity
            n = self.n
            for past_round in range(t - 1):
                own_action = True if history.my_actions[past_round] else False
                opp_actions = history.opponent_actions[past_round]
                coopers = np.count_nonzero(opp_actions) + (1 if own_action else 0)
                defectors = n - coopers
                coop_consume = S / (2 * n)
                defect_consume = S / n
                total_consumption = coopers * coop_consume + defectors * defect_consume
                S_after = S - total_consumption
                growth = 2 * S_after * (1 - S_after / self.capacity) if S_after > 0 else 0.0
                S = min(S_after + growth, self.capacity)
                if S < 0:
                    S = 0.0
            S_t = S
        S_crit = n
        if t == r:
            return Action.C
        elif t == 1:
            return Action.D
        elif S_t >= S_crit:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_35(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.

    Summary:
    - Round 1: Defect.
    - Intermediate rounds:
        * Defect aggressively if estimated next stock after all defectors
          would remain above critical threshold (10% capacity).
        * If estimated next stock is below critical threshold, cooperate once
          to allow resource recovery.
        * Observes opponents' previous round to assess defections, but always
          defects unless stock is critically low to avoid collapse.
    - Final round: Always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_THRESHOLD = 0.1 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        n, r, capacity = (self.n, self.r, self.capacity)
        CRITICAL_THRESHOLD = self.CRITICAL_THRESHOLD
        if history is None:
            round_number = 1
        else:
            round_number = history.round_number + 1
        if history is None or history.round_number == 0:
            S = capacity
        else:
            last_round_idx = history.round_number - 1
            est_stocks = []
            for i in range(n - 1):
                payoff = history.opponent_payoffs[last_round_idx, i]
                action_coop = history.opponent_actions[last_round_idx, i]
                if action_coop:
                    est_s = payoff * 2 * n
                else:
                    est_s = payoff * n
                est_stocks.append(est_s)
            payoff = history.my_payoffs[last_round_idx]
            action_coop = history.my_actions[last_round_idx]
            if action_coop:
                est_s = payoff * 2 * n
            else:
                est_s = payoff * n
            est_stocks.append(est_s)
            avg_est_stock_last = sum(est_stocks) / n
            last_round_actions = []
            last_round_actions.append(Action.C if history.my_actions[last_round_idx] else Action.D)
            for i in range(n - 1):
                last_round_actions.append(Action.C if history.opponent_actions[last_round_idx, i] else Action.D)
            num_C = sum((1 for a in last_round_actions if a == Action.C))
            num_D = n - num_C
            total_consumption_last = avg_est_stock_last * (num_C / (2 * n) + num_D / n)
            stock_after_consumption = avg_est_stock_last - total_consumption_last
            if stock_after_consumption < 0:
                stock_after_consumption = 0
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            new_stock = min(stock_after_consumption + growth, capacity)
            S = new_stock
        if round_number == 1:
            return Action.D
        if round_number == r:
            return Action.D
        total_consumption_if_all_defect = S
        S_after_consumption = S - total_consumption_if_all_defect
        if S_after_consumption < 0:
            S_after_consumption = 0
        growth = 2 * S_after_consumption * (1 - S_after_consumption / capacity)
        estimated_new_stock = min(S_after_consumption + growth, capacity)
        if estimated_new_stock <= CRITICAL_THRESHOLD:
            return Action.C
        if history is not None and history.round_number > 0:
            last_round_idx = history.round_number - 1
            opponent_last_actions = history.opponent_actions[last_round_idx, :]
            num_defectors = np.sum(opponent_last_actions == False)
        else:
            num_defectors = 0
        if S <= CRITICAL_THRESHOLD:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_36(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource game.
    - Always defect first and last rounds to maximize immediate payoff.
    - In intermediate rounds:
        * Defect if stock is above a threshold (max(2*n, 0.3*capacity))
        * Cooperate tactically if defecting now would collapse the stock,
          assuming worst case that others defect.
    - Never cooperate altruistically, only to preserve resource when defecting
      would end the game prematurely.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_stock = max(2 * self.n, self.capacity * 0.3)

    def __call__(self, history: None | PlayerHistory) -> Action:
        n, r, capacity = (self.n, self.r, self.capacity)
        threshold_stock = self.threshold_stock
        if history is None:
            return Action.D
        round_number = history.round_number
        current_round = round_number + 1
        stock = capacity
        for t in range(round_number):
            pi_me = history.my_payoffs[t]
            pi_opp = history.opponent_payoffs[t]
            total_consumption = pi_me + pi_opp.sum()
            stock_after_consump = stock - total_consumption
            if stock_after_consump < 0:
                stock_after_consump = 0
            growth = 2 * stock_after_consump * (1 - stock_after_consump / capacity)
            stock = min(stock_after_consump + growth, capacity)
        current_stock = stock
        if current_stock == 0:
            return Action.D
        if current_round == 1 or current_round == r:
            return Action.D
        consumption_if_C = current_stock / (2 * n)
        consumption_if_D = current_stock / n
        new_stock_if_defect = 0
        total_consumption_if_cooperate = (n - 1) * consumption_if_D + consumption_if_C
        stock_after_consumption_coop = current_stock - total_consumption_if_cooperate
        if stock_after_consumption_coop < 0:
            stock_after_consumption_coop = 0
        growth_coop = 2 * stock_after_consumption_coop * (1 - stock_after_consumption_coop / capacity)
        new_stock_if_cooperate = min(stock_after_consumption_coop + growth_coop, capacity)
        if new_stock_if_defect == 0 and new_stock_if_cooperate > 0 and (current_round < r - 1):
            return Action.C
        if current_stock >= threshold_stock:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_37(BaseStrategy):
    """
    Aggressive "Always Strike Hard" strategy for the Common Pool Resource Game.

    Always defects (Action.D) every round regardless of stock, history, or round number.
    Maximizes immediate payoff by always taking the larger share.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_38(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.

    - Defects on first and last rounds unconditionally.
    - Defects on intermediate rounds if stock is above threshold (capacity/(2n)).
    - Cooperates only when stock is very low (≤ capacity/(2n)) to conserve resource.
    - Does not model opponents, acts solely on current stock and round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        LOW_STOCK_THRESHOLD = capacity / (2 * n)
        if history is None:
            round_num = 1
            stock = capacity
        else:
            round_num = history.round_number + 1
            total_rounds_completed = history.round_number
            stock = capacity
            for t in range(total_rounds_completed):
                my_p = history.my_payoffs[t]
                opp_p = np.sum(history.opponent_payoffs[t])
                total_consumption = my_p + opp_p
                stock_after_consumption = stock - total_consumption
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity) if stock_after_consumption > 0 else 0
                stock = min(stock_after_consumption + growth, capacity)
                if stock < 0:
                    stock = 0
        if round_num == 1:
            return Action.D
        if round_num == r:
            return Action.D
        if stock <= LOW_STOCK_THRESHOLD:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_39(BaseStrategy):
    """
    Aggressive Strategy for Common Pool Resource Game.
    
    Defect every round except when stock is critically low before last round, then cooperate to preserve stock.
    Always defect on last round to maximize immediate payoff regardless of stock.
    Decision depends only on current round index and current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is None:
            t = 1
            S_t = capacity
        else:
            t = history.round_number + 1
            stocks = [capacity]
            for round_i in range(t - 1):
                acts = history.my_actions.__array__() if history.my_actions.size > 0 else np.array([])
                opp_acts = history.opponent_actions[round_i] if history.opponent_actions.size > 0 else np.array([])
                actions_round = np.append(opp_acts, history.my_actions[round_i])
                payoffs_round = np.append(history.opponent_payoffs[round_i], history.my_payoffs[round_i])
                defect_payoffs = payoffs_round[~actions_round]
                coop_payoffs = payoffs_round[actions_round]
                candidates = []
                if defect_payoffs.size > 0:
                    candidates.append(defect_payoffs.max() * n)
                if coop_payoffs.size > 0:
                    candidates.append(coop_payoffs.max() * 2 * n)
                if len(candidates) == 0:
                    S_k = stocks[-1]
                else:
                    S_k = max(candidates)
                n_coop = np.sum(actions_round)
                n_defect = n - n_coop
                total_consumption = n_coop * (S_k / (2 * n)) + n_defect * (S_k / n)
                stock_after_cons = S_k - total_consumption
                if stock_after_cons < 0:
                    stock_after_cons = 0.0
                growth = 2 * stock_after_cons * (1 - stock_after_cons / capacity)
                new_stock = stock_after_cons + growth
                if new_stock > capacity:
                    new_stock = capacity
                stocks.append(new_stock)
            S_t = stocks[-1]
        S_min = n
        if t == r:
            return Action.D
        if S_t < 0:
            S_t = 0.0
        if S_t >= S_min:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_40(BaseStrategy):
    """
    Aggressive Strategy for Common Pool Resource Game.

    Always defects (D) in every round regardless of history or stock level,
    aiming to maximize immediate personal payoff despite risk of stock depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_41(BaseStrategy):
    """
    Aggressive defection strategy for the Common Pool Resource game.
    
    Always defects to maximize immediate payoff.
    Uses history to detect cooperators to aggressively exploit by continuing to defect.
    When stock is very low, still defects since defection payoff advantage is negligible.
    On the first and last rounds, defects as a dominant action.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == r:
            return Action.D
        last_round_index = history.round_number - 1
        opponent_actions_last = history.opponent_actions[last_round_index]
        num_cooperators = np.sum(opponent_actions_last)
        num_defectors = len(opponent_actions_last) - num_cooperators
        if num_cooperators > 0:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_42(BaseStrategy):
    """
    Defect-First, Punish-Late:
    - Defect aggressively from first round to maximize short-term payoff.
    - Continue defecting while stock level is above a critical threshold.
    - Cooperate defensively only if stock is at or below threshold_stock to avoid total collapse.
    - Defect in the final round regardless of stock.
    - Do not attempt forgiveness or rehabilitation beyond defensive cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.threshold_stock = self.game.capacity / (4 * self.game.n_players)

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        r = self.game.n_rounds
        n = self.game.n_players
        capacity = self.game.capacity
        if history is None:
            S = capacity
        else:
            last_round = history.round_number - 1
            opp_acts = history.opponent_actions[last_round]
            n_opp_coop = np.count_nonzero(opp_acts)
            n_opp_defect = n - 1 - n_opp_coop
            my_last_action = history.my_actions[last_round]
            if my_last_action:
                n_coop = n_opp_coop + 1
                n_defect = n_opp_defect
            else:
                n_coop = n_opp_coop
                n_defect = n_opp_defect + 1
            my_payoff_last = history.my_payoffs[last_round]
            if my_last_action:
                if n_coop > 0:
                    S_est = my_payoff_last * 2 * n
                else:
                    S_est = 0.0
            elif n_defect > 0:
                S_est = my_payoff_last * n
            else:
                S_est = 0.0
            S_last = S_est
            total_consumption = n_coop * (S_last / (2 * n)) + n_defect * (S_last / n)
            S_remaining = S_last - total_consumption
            if S_remaining < 0:
                S_remaining = 0.0
            growth = 2 * S_remaining * (1 - S_remaining / capacity)
            S = min(S_remaining + growth, capacity)
        if t == 1:
            return Action.D
        elif t < r:
            if S > self.threshold_stock:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_43(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game:
    - Always defect from round 1 to r-1 to maximize immediate payoff.
    - In the last round, cooperate only if current stock is at least half capacity and
      at least half of opponents cooperated last round; otherwise defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.desc = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        round_t = 1 if history is None else history.round_number + 1
        n = self.n
        r = self.r
        capacity = self.capacity
        if history is None:
            return Action.D
        S = float(capacity)
        for past_round in range(history.round_number):
            my_a = history.my_actions[past_round]
            opp_as = history.opponent_actions[past_round]
            coop_count = int(my_a) + np.sum(opp_as)
            defect_count = n - coop_count
            total_consumption = coop_count * (S / (2 * n)) + defect_count * (S / n)
            stock_after = S - total_consumption
            growth = 2 * stock_after * (1 - stock_after / capacity)
            S_next = stock_after + growth
            if S_next > capacity:
                S_next = float(capacity)
            S = S_next
        current_stock = S
        if round_t < r:
            return Action.D
        payoff_c = current_stock / (2 * n)
        payoff_d = current_stock / n
        if history.round_number == 0:
            return Action.D
        last_round_actions = []
        last_round_actions.append(history.my_actions[-1])
        last_round_actions.extend(history.opponent_actions[-1])
        coop_count = sum((1 for a in last_round_actions if a))
        stock_threshold = capacity / 2
        coop_threshold = n / 2
        if current_stock >= stock_threshold and coop_count >= coop_threshold:
            if payoff_c >= payoff_d:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_44(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.
    
    Always defects to maximize immediate payoff regardless of stock or round number.
    Defects on first round, intermediate rounds, last round, and even if the stock is depleted.
    No cooperation is ever considered.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game.n_rounds
        stock = float(self.game.capacity)
        n = self.game.n_players
        capacity = self.game.capacity
        for round_idx in range(history.round_number):
            actions_round = np.empty(n, dtype=bool)
            actions_round[0] = history.my_actions[round_idx]
            actions_round[1:] = history.opponent_actions[round_idx]
            coop_count = np.sum(actions_round)
            defect_count = n - coop_count
            total_consumption = coop_count * (stock / (2 * n)) + defect_count * (stock / n)
            stock_after = stock - total_consumption
            if stock_after < 0:
                stock_after = 0.0
            growth = 2 * stock_after * (1 - stock_after / capacity)
            new_stock = min(stock_after + growth, capacity)
            stock = new_stock
        current_stock = stock
        if current_round == total_rounds:
            return Action.D
        if current_stock <= 0:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_45(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.
    Always defect (D) in every round regardless of history or stock,
    maximizing immediate individual payoff at expense of cooperation and sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        last_round_actions = history.opponent_actions[t - 2]
        defectors_prev = np.sum(last_round_actions == False)
        return Action.D

class Strategy_AGGRESSIVE_46(BaseStrategy):
    """
    Aggressive Defect-Exploit Until Last Round strategy for Common Pool Resource Game.
    - Round 1: Always defect.
    - Intermediate rounds: defect always, exploiting any cooperators.
      Cooperate only if stock is zero (to avoid zero-payoff defection).
    - Final round: always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        C = Action.C
        D = Action.D
        round_num = 1 if history is None else history.round_number + 1
        n = self.n
        if history is None or history.round_number == 0:
            return D
        last_round = history.round_number - 1
        if last_round < 0:
            return D
        my_last_action = history.my_actions[last_round]
        my_last_payoff = history.my_payoffs[last_round]
        if my_last_action == True:
            est_stock = my_last_payoff * 2 * n
        else:
            est_stock = my_last_payoff * n
        est_stock = max(0.0, min(float(est_stock), float(self.capacity)))
        if round_num == self.r:
            return D
        last_opp_actions = history.opponent_actions[last_round]
        cooperator_present = np.any(last_opp_actions == True)
        if est_stock <= 0:
            return C
        if cooperator_present:
            return D
        return D

class Strategy_AGGRESSIVE_47(BaseStrategy):
    """
    Aggressive Defector strategy for Common Pool Resource Game.
    Always defects every round except in the last round,
    where it defects if stock is above 20% capacity,
    else cooperates to salvage payoff from very low stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        stock_threshold = 0.2 * self.capacity
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        current_stock = self.capacity
        S = self.capacity
        for t in range(round_number - 1):
            total_payoff = history.my_payoffs[t] + np.sum(history.opponent_payoffs[t])
            S_remaining = S - total_payoff
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S = min(S_remaining + growth, self.capacity)
        current_stock = S
        if round_number < self.r:
            return Action.D
        elif current_stock > stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_48(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game:
    - Always defect except when stock is critically low to avoid collapse.
    - Defect in first and last rounds unconditionally.
    - In middle rounds, cooperate only if stock ≤ threshold to allow regrowth.
    - Use history of opponents' last round defect rates to justify defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.T_low = self.game.capacity / (4 * self.game.n_players)

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        capacity = self.game.capacity
        if history is None or history.round_number == 0:
            t = 1
            stock = capacity
        else:
            t = history.round_number + 1
            total_players = n
            S = capacity
            for round_idx in range(history.round_number):
                my_payoff = history.my_payoffs[round_idx]
                opp_payoffs_round = history.opponent_payoffs[round_idx]
                all_payoffs = np.concatenate(([my_payoff], opp_payoffs_round))
                total_consumption = all_payoffs.sum()
                S_after_consumption = S - total_consumption
                if S_after_consumption < 0:
                    S_after_consumption = 0.0
                growth = 2 * S_after_consumption * (1 - S_after_consumption / capacity)
                S = min(S_after_consumption + growth, capacity)
            stock = S
        if stock <= 0:
            return Action.C
        if t == r:
            return Action.D
        if t == 1:
            return Action.D
        if stock <= self.T_low:
            return Action.C
        if history is not None and history.round_number >= 1:
            last_round_idx = t - 2
            if last_round_idx >= 0:
                last_round_actions = history.opponent_actions[last_round_idx]
                num_defectors = np.sum(~last_round_actions)
                half_opponents = (n - 1) / 2
                if num_defectors > half_opponents:
                    return Action.D
        return Action.D

class Strategy_AGGRESSIVE_49(BaseStrategy):
    """
    Aggressive "Defect-then-Exploit" strategy for the Common Pool Resource Game.
    
    Always defects (D) every round, regardless of stock level or opponents' actions.
    Maximizes immediate payoff by consuming the largest share possible each round,
    ignoring cooperation incentives and resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = self.capacity / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        S = None
        last_round_idx = history.round_number - 1
        if last_round_idx >= 0:
            my_last_action = history.my_actions[last_round_idx]
            my_last_payoff = history.my_payoffs[last_round_idx]
            if my_last_payoff == 0:
                S = 0.0
            elif my_last_action:
                S = my_last_payoff * 2 * self.n
            else:
                S = my_last_payoff * self.n
        else:
            S = self.capacity
        if t == self.r:
            return Action.D
        if S >= self.threshold_high:
            return Action.D
        if last_round_idx >= 0:
            opponents_last_actions = history.opponent_actions[last_round_idx]
            total_opponents = len(opponents_last_actions)
            if total_opponents > 0:
                defectors_count = total_opponents - np.count_nonzero(opponents_last_actions)
                if defectors_count / total_opponents > 0.5:
                    return Action.D
                else:
                    return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_50(BaseStrategy):
    """
    Relentless Defector with Last-Round Exploitation:
    - Defects in the first round.
    - Defects in intermediate rounds if stock is above capacity/(2*n).
    - Cooperates only if stock is below that threshold to preserve stock.
    - Defects unconditionally in last round to maximize final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = capacity
        for past_round in range(t - 1):
            actions_round = history.opponent_actions[past_round] if past_round < history.opponent_actions.shape[0] else np.array([])
            if past_round < history.my_actions.shape[0]:
                all_actions = np.append(history.my_actions[past_round], actions_round)
            else:
                all_actions = np.append(False, actions_round)
            num_cooperators = np.sum(all_actions)
            num_defectors = n - num_cooperators
            coop_consume = S / (2 * n)
            defect_consume = S / n
            total_consumption = num_cooperators * coop_consume + num_defectors * defect_consume
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / capacity)
            S = min(S_remaining + growth, capacity)
        S_t = S
        low_stock_threshold = capacity / (2 * n)
        if t == r:
            return Action.D
        if S_t < low_stock_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_51(BaseStrategy):
    """
    Aggressive Strategy for Common Pool Resource Game.

    Always defect (D) to maximize immediate payoff except:
    - Cooperate (C) once when stock is critically low to allow recovery,
      unless in the second to last round (then defect).
    - Always defect in the last round.

    Uses game parameters and current stock known from history payoffs to
    infer stock level at start of current round. Cooperates tactically only
    to prevent total collapse and future zero payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.has_cooperated_low_stock = False
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.low_stock_threshold = self.capacity / (4 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.capacity
        else:
            t = history.round_number + 1
            last_round = t - 1 - 1
            opp_actions_last = history.opponent_actions[last_round]
            opp_payoffs_last = history.opponent_payoffs[last_round]
            my_action_last = history.my_actions[last_round]
            my_payoff_last = history.my_payoffs[last_round]
            all_actions = np.append(opp_actions_last, my_action_last)
            all_payoffs = np.append(opp_payoffs_last, my_payoff_last)
            candidates = []
            for a, p in zip(all_actions, all_payoffs):
                if p <= 0:
                    continue
                if a:
                    candidates.append(p * 2 * self.n)
                else:
                    candidates.append(p * self.n)
            if candidates:
                S_prev = float(np.median(candidates))
            else:
                S_prev = 0.0
            n = self.n
            coop_count = sum(all_actions)
            defect_count = len(all_actions) - coop_count
            total_consumption = coop_count * (S_prev / (2 * n)) + defect_count * (S_prev / n)
            S_remaining = S_prev - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S_t = min(S_remaining + growth, self.capacity)
        if t == self.r:
            return Action.D
        if S_t < self.low_stock_threshold:
            if t == self.r - 1:
                return Action.D
            if not getattr(self, '_has_cooperated_this_low_stock_period', False):
                self._has_cooperated_this_low_stock_period = True
                return Action.C
            else:
                return Action.D
        else:
            self._has_cooperated_this_low_stock_period = False
        return Action.D

class Strategy_AGGRESSIVE_52(BaseStrategy):
    """
    Aggressive Defector (AggDef) strategy for the Common Pool Resource Game.

    Summary:
    - Always defect (D) on the first and last rounds to maximize immediate payoff.
    - On intermediate rounds:
      - Defect if the current stock is above a minimal threshold (1% of capacity).
      - Cooperate (C) only if stock is near depletion, to preserve minimal resource for future rounds.
    - Assumes opponents are always defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.epsilon = self.capacity * 0.01

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.r
        capacity = self.capacity
        epsilon = self.epsilon
        n = self.n
        S = capacity
        my_acts = history.my_actions
        opp_acts = history.opponent_actions
        total_players = n
        S_round = capacity
        for round_i in range(t - 1):
            my_payoff = history.my_payoffs[round_i]
            opp_payoffs = history.opponent_payoffs[round_i]
            total_consumption = my_payoff + np.sum(opp_payoffs)
            S_after = S_round - total_consumption
            growth = 2 * S_after * (1 - S_after / capacity)
            S_next = min(S_after + growth, capacity)
            S_round = S_next
        S_t = S_round
        if t == r:
            return Action.D
        if S_t <= epsilon:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_53(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.

    Summary:
    - Always defect in the first and last rounds to maximize immediate payoff.
    - For intermediate rounds:
      - If current stock > capacity/4, defect aggressively.
      - If stock ≤ capacity/4:
        - If half or more players defected last round, cooperate to allow stock recovery.
        - Otherwise, defect to exploit cooperators.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity / 4

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if history is None:
            return Action.D
        if t == self.r:
            return Action.D
        last_round = t - 1
        payoffs_last = None
        if len(history.my_payoffs) >= last_round and last_round > 0:
            payoff_candidate = history.my_payoffs[last_round - 1]
            if payoff_candidate > 0:
                payoffs_last = payoff_candidate
        if payoffs_last is None or payoffs_last == 0:
            opp_payoffs_last = history.opponent_payoffs[last_round - 1]
            pos = opp_payoffs_last[opp_payoffs_last > 0]
            if len(pos) > 0:
                payoffs_last = pos[0]
            else:
                payoffs_last = 0
        used_own = False
        if len(history.my_payoffs) >= last_round and last_round > 0:
            used_own = True
            last_action_of_player = history.my_actions[last_round - 1]
            payoff_of_player = history.my_payoffs[last_round - 1]
        else:
            used_own = False
        if used_own:
            player_action = last_action_of_player
            payoff_player = payoff_of_player
        else:
            opp_actions_last = history.opponent_actions[last_round - 1]
            opp_payoffs_last = history.opponent_payoffs[last_round - 1]
            idx = -1
            for i, p in enumerate(opp_payoffs_last):
                if p > 0:
                    idx = i
                    break
            if idx >= 0:
                player_action = opp_actions_last[idx]
                payoff_player = opp_payoffs_last[idx]
            else:
                player_action = None
                payoff_player = 0
        if payoff_player == 0:
            S_prev = 0.0
        elif player_action is True:
            S_prev = payoff_player * 2 * self.n
        elif player_action is False:
            S_prev = payoff_player * self.n
        else:
            S_prev = 0.0
        last_actions_all = np.concatenate(([history.my_actions[last_round - 1]], history.opponent_actions[last_round - 1]))
        num_cooperators = np.count_nonzero(last_actions_all)
        num_defectors = self.n - num_cooperators
        sum_consumption = S_prev * (num_cooperators / (2 * self.n) + num_defectors / self.n)
        S_remaining = S_prev - sum_consumption
        if S_remaining < 0:
            S_remaining = 0.0
        growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
        if growth < 0:
            growth = 0.0
        S_t_est = min(S_remaining + growth, self.capacity)
        if S_t_est > self.threshold:
            return Action.D
        else:
            D_count = num_defectors
            if D_count >= self.n / 2:
                return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_54(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.

    Defects on first and last rounds to maximize immediate payoff.
    In intermediate rounds, defects if stock >= 25% capacity, else cooperates to sustain the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        S_threshold = capacity / 4
        if history is None:
            t = 1
            return Action.D
        t = history.round_number + 1
        if t == 1:
            return Action.D
        prev_round_idx = t - 2
        my_act_prev = history.my_actions[prev_round_idx]
        my_payoff_prev = history.my_payoffs[prev_round_idx]
        mult = 2 * n if my_act_prev else n
        S_prev = my_payoff_prev * mult
        opp_payoffs_prev = history.opponent_payoffs[prev_round_idx]
        total_payoffs_prev = np.sum(opp_payoffs_prev) + my_payoff_prev
        total_consumption_prev = total_payoffs_prev
        S_remaining = S_prev - total_consumption_prev
        growth = 2 * S_remaining * (1 - S_remaining / capacity) if S_remaining > 0 else 0
        S_t = S_remaining + growth
        if S_t > capacity:
            S_t = capacity
        if S_t < 0:
            S_t = 0
        if t == r:
            return Action.D
        if 1 < t < r:
            if S_t >= S_threshold:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_55(BaseStrategy):
    """
    Dominant Defector with Opportunistic Retaliation:
    Aggressively defect each round to maximize immediate payoff,
    except cooperate if the common pool stock is critically low 
    to allow recovery. Always defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_low = self.capacity / (4 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if history is None:
            S_t = self.capacity
        else:
            S = self.capacity
            n = self.n
            capacity = self.capacity
            for round_idx in range(history.round_number):
                total_payoffs_round = history.my_payoffs[round_idx] + np.sum(history.opponent_payoffs[round_idx])
                S_remaining = S - total_payoffs_round
                if S_remaining < 0:
                    S_remaining = 0
                growth = 2 * S_remaining * (1 - S_remaining / capacity)
                S = min(S_remaining + growth, capacity)
            S_t = S
        if t == self.r:
            return Action.D
        if S_t <= self.threshold_low:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_56(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.
    
    Always defects (D) when stock is above 25% capacity or it's the last round,
    to maximize immediate payoffs. Cooperates (C) only when stock is at or below
    25% capacity to allow minimal recovery of the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_stock = self.capacity / 4

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if history is None:
            S_t = self.capacity
        else:
            last_round = t - 1
            opp_acts = history.opponent_actions[last_round - 1]
            my_act = history.my_actions[last_round - 1]
            actions_last = np.append(opp_acts, my_act)
            payoffs_last = np.append(history.opponent_payoffs[last_round - 1], history.my_payoffs[last_round - 1])
            total_consumption = payoffs_last.sum()
            stock_after_consumption = None
            n_coop = np.sum(actions_last)
            n_defect = self.n - n_coop
            sum_expected_consumption = lambda S_prev: S_prev * (n_coop / (2 * self.n) + n_defect / self.n)
            denominator = n_coop / (2 * self.n) + n_defect / self.n
            if denominator == 0:
                denominator = 1
            S_prev = total_consumption / denominator
            stock_after_consumption = S_prev - total_consumption
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock_after_growth = stock_after_consumption + growth
            S_t = min(stock_after_growth, self.capacity)
        if t == self.r:
            return Action.D
        if S_t > self.threshold_stock:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_57(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game:
    - Defects on first round for immediate gain.
    - For intermediate rounds (2..r-1), defects if stock > 25% capacity, else cooperates.
    - Last round defects to maximize final payoff.
    - Ignores opponent history, only uses current stock and round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_safety_threshold = self.capacity * 0.25

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == 1:
            S_t = self.capacity
        else:
            last_round = t - 1 - 1
            opp_acts_last = history.opponent_actions[last_round]
            my_act_last = history.my_actions[last_round]
            all_actions_last = np.append(opp_acts_last, my_act_last)
            coop_mask = all_actions_last == True
            defect_mask = all_actions_last == False
            opp_pay_last = history.opponent_payoffs[last_round]
            my_pay_last = history.my_payoffs[last_round]
            all_payoffs_last = np.append(opp_pay_last, my_pay_last)
            coop_payoffs = all_payoffs_last[coop_mask]
            defect_payoffs = all_payoffs_last[defect_mask]
            est_stock_from_coop = coop_payoffs.mean() * 2 * self.n if coop_payoffs.size > 0 else -1
            est_stock_from_defect = defect_payoffs.mean() * self.n if defect_payoffs.size > 0 else -1
            candidates = [v for v in (est_stock_from_coop, est_stock_from_defect) if v >= 0]
            if candidates:
                S_t = max(candidates)
                if S_t > self.capacity:
                    S_t = self.capacity
            else:
                S_t = 0.0
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        if S_t > self.stock_safety_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_58(BaseStrategy):
    """
    Aggressive Defector with Resource Awareness for the Common Pool Resource Game.

    Strategy consistently defects to maximize short-term payoff unless the
    resource stock is critically low, in which case it cooperates to conserve stock.
    Always defects in the last round. Uses only the current stock level and round info.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_critical_low = self.capacity / (2 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        last_round_idx = t - 2
        if last_round_idx < 0:
            return Action.D
        n = self.n
        capacity = self.capacity
        opp_acts = history.opponent_actions
        opp_pay = history.opponent_payoffs
        my_act = history.my_actions
        my_pay = history.my_payoffs
        last_opp_actions = opp_acts[last_round_idx]
        last_my_action = my_act[last_round_idx]
        last_opp_payoffs = opp_pay[last_round_idx]
        last_my_payoff = my_pay[last_round_idx]
        all_actions = np.empty(n, dtype=bool)
        all_actions[:-1] = last_opp_actions
        all_actions[-1] = last_my_action
        all_payoffs = np.empty(n, dtype=float)
        all_payoffs[:-1] = last_opp_payoffs
        all_payoffs[-1] = last_my_payoff
        est_stocks = np.where(all_actions, all_payoffs * 2 * n, all_payoffs * n)
        S_prev = np.max(est_stocks)
        coop_count = np.sum(all_actions)
        defect_count = n - coop_count
        total_consumption = coop_count * (S_prev / (2 * n)) + defect_count * (S_prev / n)
        S_remaining = S_prev - total_consumption
        growth = 2 * S_remaining * (1 - S_remaining / capacity)
        S_t = min(S_remaining + growth, capacity)
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        if S_t > self.threshold_critical_low:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_59(BaseStrategy):
    """
    Unrelenting Defector strategy for the Common Pool Resource Game.
    Always defects (Action.D) every round to maximize immediate payoff,
    ignoring future sustainability or other players' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_60(BaseStrategy):
    """
    "Exploit and Explode" aggressive strategy for the Common Pool Resource Game.

    Always defects (D) except in the last round. In the final round,
    cooperates (C) if current stock is above a threshold (capacity / (2n)),
    else defects (D). This strategy prioritizes maximal individual payoff early,
    exploiting the resource aggressively, and only milks remaining stock cooperatively
    at the end if worthwhile.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        cooperation_threshold = capacity / (2 * n)
        current_round = 1 if history is None else history.round_number + 1
        if current_round == 1:
            return Action.D
        stock = capacity
        if history is not None and history.round_number > 0:
            for t in range(history.round_number):
                coop_count = np.sum(history.opponent_actions[t]) + (1 if history.my_actions[t] else 0)
                defect_count = n - coop_count
                total_consumption = coop_count * (stock / (2 * n)) + defect_count * (stock / n)
                S_remaining = stock - total_consumption
                if S_remaining < 0:
                    S_remaining = 0.0
                growth = 2 * S_remaining * (1 - S_remaining / capacity)
                stock = min(S_remaining + growth, capacity)
        if current_round < r:
            return Action.D
        elif stock > cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_61(BaseStrategy):
    """
    Aggressive common pool resource strategy.

    - Round 1: Defect to grab maximal immediate payoff.
    - Intermediate rounds (2 to r-1):
      Defect if stock above threshold S_min = capacity/(4n), else cooperate to sustain stock.
    - Last round: Defect unconditionally to maximize final payoff.
    - Always ignore opponents' cooperation; never reward it with cooperation.
    - Cooperate only as a tactical move to avoid zero stock collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_min = self.capacity / (4 * self.n)
        self.epsilon = 1e-08

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.capacity
        else:
            t = history.round_number + 1
            last_round = history.round_number - 1
            if last_round < 0:
                S_t = self.capacity
            else:
                my_action_last = history.my_actions[last_round]
                my_payoff_last = history.my_payoffs[last_round]
                if my_payoff_last < self.epsilon:
                    S_t = 0.0
                elif my_action_last:
                    S_t = my_payoff_last * 2 * self.n
                else:
                    S_t = my_payoff_last * self.n
                if S_t > self.capacity:
                    S_t = self.capacity
                if S_t < 0:
                    S_t = 0.0
        last_round = t == self.r
        if not last_round and S_t < self.epsilon:
            return Action.C
        if last_round:
            return Action.D
        if t == 1:
            return Action.D
        if S_t > self.S_min:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_62(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.

    - Round 1: Cooperate to sustain the pool initially.
    - Rounds 2..r-1: Defect if stock > threshold (capacity/4), else cooperate.
    - Last round: Always defect to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / 4

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is None:
            return Action.C
        t = history.round_number
        current_round = t + 1
        if current_round == 1:
            return Action.C
        last_round_index = t - 1
        if last_round_index < 0:
            return Action.C
        my_last_action = history.my_actions[last_round_index]
        my_last_payoff = history.my_payoffs[last_round_index]
        if my_last_action:
            S_last = my_last_payoff * 2 * n
        else:
            S_last = my_last_payoff * n
        opponent_payoffs = history.opponent_payoffs
        total_opponent_payoff = np.sum(opponent_payoffs[last_round_index]) if opponent_payoffs.size > 0 else 0.0
        total_payoff_last_round = total_opponent_payoff + my_last_payoff
        stock_after_consumption = max(0.0, S_last - total_payoff_last_round)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
        current_stock = min(stock_after_consumption + growth, capacity)
        if current_round == 1:
            return Action.C
        elif current_round == r:
            return Action.D
        elif current_stock > self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_63(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.

    - Always defects on first and last rounds to maximize immediate payoff.
    - Between first and last rounds, defects unless stock is below a risk threshold,
      in which case it cooperates to prevent resource collapse.
    - Uses only current round and stock info; ignores detailed opponent history except availability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_threshold = self.capacity / (2 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.capacity
        else:
            t = history.round_number + 1
            S_t = self.capacity
            for past_round in range(t - 1):
                coop_count = np.sum(history.opponent_actions[past_round])
                defect_count = self.n - 1 - coop_count
                my_action = history.my_actions[past_round]
                if my_action:
                    coop_count += 1
                else:
                    defect_count += 1
                cons_coop = S_t / (2 * self.n)
                cons_defect = S_t / self.n
                total_consumption = coop_count * cons_coop + defect_count * cons_defect
                S_after = S_t - total_consumption
                growth = 2 * S_after * (1 - S_after / self.capacity)
                S_t = min(S_after + growth, self.capacity)
                if S_t < 0:
                    S_t = 0.0
        if t == self.r:
            return Action.D
        if t == 1:
            return Action.D
        if S_t < self.S_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_64(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.

    - Round 1: Defect to maximize immediate payoff.
    - Intermediate rounds (1 < t < r):
      * If majority of opponents cooperated last round, cooperate to exploit them.
      * Else defect to pressure stock and assert dominance.
    - Last round: Always defect to maximize final extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        if history is None or history.round_number == 0:
            return Action.D
        last_round_index = history.round_number - 1
        last_round_opponent_actions = history.opponent_actions[last_round_index]
        cooperators = np.sum(last_round_opponent_actions)
        if cooperators >= (self.n - 1) / 2:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_65(BaseStrategy):
    """
    Aggressive Common Pool Resource strategy.
    Always defects except when the stock is at or below 25% capacity 
    and it is not the last round, then it cooperates to conserve resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_low_stock = self.capacity / 4

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = self.capacity
        else:
            t = history.round_number + 1
            S = float(self.capacity)
            for i in range(history.round_number):
                payoffs_i = np.append(history.my_payoffs[i], history.opponent_payoffs[i, :])
                total_consumption = np.sum(payoffs_i)
                stock_after = S - total_consumption
                growth = 2 * stock_after * (1 - stock_after / self.capacity) if stock_after > 0 else 0.0
                S = min(stock_after + growth, self.capacity)
                if S < 0:
                    S = 0.0
        if t == self.r:
            return Action.D
        if S <= self.threshold_low_stock:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_66(BaseStrategy):
    """
    Defect-First Aggro with Opportunistic Cooperation strategy for the Common Pool Resource Game.

    This strategy unconditionally defects in the first round, aggressively exploits cooperators
    by defecting after cooperative rounds, punishes defectors by persistent defection, and only
    cooperates to mitigate rapid resource depletion or when stock is critically low. On the last
    round, it always defects to maximize immediate payoff regardless of stock state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 2 * self.capacity / 3
        self.very_low_stock_threshold = self.capacity / (4 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        round_number = history.round_number + 1
        last_round_idx = history.round_number - 1
        payoffs_last = np.concatenate(([history.my_payoffs[last_round_idx]], history.opponent_payoffs[last_round_idx]))
        actions_last = np.concatenate(([history.my_actions[last_round_idx]], history.opponent_actions[last_round_idx]))
        coop_indices = np.flatnonzero(actions_last)
        defect_indices = np.flatnonzero(~actions_last)
        estimated_stocks = []
        if coop_indices.size > 0:
            coop_stock_estimates = payoffs_last[coop_indices] * 2 * self.n
            estimated_stocks.append(np.median(coop_stock_estimates))
        if defect_indices.size > 0:
            defect_stock_estimates = payoffs_last[defect_indices] * self.n
            estimated_stocks.append(np.median(defect_stock_estimates))
        if not estimated_stocks:
            stock_last = self.capacity
        else:
            stock_last = sum(estimated_stocks) / len(estimated_stocks)
        stock = stock_last
        defected_last_round = np.any(~history.opponent_actions[last_round_idx])
        rapid_decline = False
        if history.round_number > 1:
            second_last_idx = history.round_number - 2
            payoffs_prev = np.concatenate(([history.my_payoffs[second_last_idx]], history.opponent_payoffs[second_last_idx]))
            actions_prev = np.concatenate(([history.my_actions[second_last_idx]], history.opponent_actions[second_last_idx]))
            coop_indices_prev = np.flatnonzero(actions_prev)
            defect_indices_prev = np.flatnonzero(~actions_prev)
            estimated_stocks_prev = []
            if coop_indices_prev.size > 0:
                coop_stock_estimates_prev = payoffs_prev[coop_indices_prev] * 2 * self.n
                estimated_stocks_prev.append(np.median(coop_stock_estimates_prev))
            if defect_indices_prev.size > 0:
                defect_stock_estimates_prev = payoffs_prev[defect_indices_prev] * self.n
                estimated_stocks_prev.append(np.median(defect_stock_estimates_prev))
            if estimated_stocks_prev:
                stock_prev = sum(estimated_stocks_prev) / len(estimated_stocks_prev)
                if stock < 0.5 * stock_prev:
                    rapid_decline = True
        if round_number == self.r:
            return Action.D
        if stock <= self.very_low_stock_threshold:
            return Action.C
        if rapid_decline:
            return Action.C
        if defected_last_round:
            return Action.D
        if not defected_last_round and stock > self.critical_threshold:
            return Action.D
        if stock <= self.critical_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_67(BaseStrategy):
    """
    Aggressive Strategy: Always defect (D) if defect payoff > 0, else cooperate (C);
    On last round always defect. Ignores opponents and sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        capacity = self.game.capacity
        if history is None:
            t = 1
            current_stock = capacity
        else:
            t = history.round_number + 1
            S = capacity
            for round_i in range(history.round_number):
                opp_actions_round = history.opponent_actions[round_i]
                self_action_round = history.my_actions[round_i]
                coop_count = np.sum(opp_actions_round) + int(self_action_round)
                defect_count = n - coop_count
                total_consumption = coop_count * (S / (2 * n)) + defect_count * (S / n)
                S_remaining = S - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / capacity)
                S = min(S_remaining + growth, capacity)
            current_stock = S
        payoff_defect = current_stock / n
        payoff_cooperate = current_stock / (2 * n)
        if t == r:
            return Action.D
        elif payoff_defect > 0:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_68(BaseStrategy):
    """
    Unrelenting Defector strategy for the Common Pool Resource Game.
    Always defects (Action.D) every round regardless of history or state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_69(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.
    - Round 1 and last round: always defect.
    - Intermediate rounds: defect if stock above threshold (~half capacity),
      else cooperate once to allow stock recovery, then defect next round.
    - Does not rely on opponents' actions, purely stock-aware and self-maximizing.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        stocks = [self.capacity]
        for round_idx in range(t - 1):
            S_prev = stocks[-1]
            acts = np.append(history.my_actions[round_idx], history.opponent_actions[round_idx])
            n_c = np.count_nonzero(acts)
            n_d = self.n - n_c
            total_cons = n_c * (S_prev / (2 * self.n)) + n_d * (S_prev / self.n)
            S_after_cons = S_prev - total_cons
            growth = 2 * S_after_cons * (1 - S_after_cons / self.capacity)
            S_new = min(S_after_cons + growth, self.capacity)
            stocks.append(S_new)
        S_t = stocks[-1]
        if t == 1:
            return Action.D
        elif t == self.r:
            return Action.D
        elif S_t > self.threshold:
            return Action.D
        elif t > 1 and history.my_actions[t - 2]:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_70(BaseStrategy):
    """
    Aggressive defection strategy for the Common Pool Resource Game.

    Always defects regardless of history or stock level.
    Prioritizes short-term individual payoff over sustainability or cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        S_t = self.capacity
        for round_idx in range(history.round_number):
            opp_actions = history.opponent_actions[round_idx]
            my_action = history.my_actions[round_idx]
            n_defect = np.count_nonzero(opp_actions == False) + (0 if my_action else 1)
            n_coop = self.n - n_defect
            total_consumption = S_t * (n_defect + n_coop / 2) / self.n
            S_remaining = S_t - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S_t = min(S_remaining + growth, self.capacity)
            if S_t < 0:
                S_t = 0
        if S_t == 0:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_71(BaseStrategy):
    """
    Relentless Defector with Last-Round Exploit

    Always defects at every round to maximize individual payoff.
    Does not cooperate or forgive.
    Defects in first, middle, and last rounds regardless of stock or history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        return Action.D

class Strategy_AGGRESSIVE_72(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.
    - Round 1: always defect.
    - Intermediate rounds: defect if current stock > half capacity; else cooperate.
    - Last round: always defect.
    Assumes worst-case others always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if history is None:
            S_t = self.capacity
        else:
            S_t = self.capacity
            n = self.n
            capacity = self.capacity
            r_completed = history.round_number
            my_payoffs = history.my_payoffs
            opp_payoffs = history.opponent_payoffs
            total_consumptions = my_payoffs + np.sum(opp_payoffs, axis=1)
            for total_cons in total_consumptions:
                S_remain = S_t - total_cons
                growth = 2 * S_remain * (1 - S_remain / capacity) if S_remain > 0 else 0
                S_t = min(S_remain + growth, capacity)
        if t == self.r:
            return Action.D
        if t == 1:
            return Action.D
        threshold = self.capacity / 2
        if S_t > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_73(BaseStrategy):
    """
    Calculated Aggression Strategy for the Common Pool Resource Game.
    
    This strategy defects in the first round and last round unconditionally,
    aiming to maximize immediate payoffs when it is safe or when no future rounds remain.
    
    In intermediate rounds, it uses the current stock level to decide:
    - Defect if stock is above half capacity (threshold_high).
    - Cooperate if stock is between quarter and half capacity (threshold_low ≤ stock < threshold_high).
    - Cooperate if stock is below quarter capacity to prevent collapse, except in last round (which is handled above).
    
    The strategy assumes perfect monitoring of the common pool stock and opponent actions,
    balancing aggressive exploitation with resource sustainability to maximize total cumulative payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = self.capacity / 2
        self.threshold_low = self.capacity / 4

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        stock = float(self.capacity)
        n = self.n
        capacity = self.capacity
        for t in range(history.round_number):
            my_act = history.my_actions[t]
            opp_acts = history.opponent_actions[t]
            all_actions = np.append(opp_acts, my_act)
            cooperators = np.sum(all_actions)
            defectors = n - cooperators
            coop_cons = stock / (2 * n) if cooperators > 0 else 0.0
            defect_cons = stock / n if defectors > 0 else 0.0
            total_consumption = cooperators * coop_cons + defectors * defect_cons
            stock_after = stock - total_consumption
            if stock_after < 0:
                stock_after = 0.0
            growth = 2 * stock_after * (1 - stock_after / capacity)
            stock = min(stock_after + growth, capacity)
        S_prev = stock
        if S_prev == 0:
            return Action.C
        if S_prev >= self.threshold_high:
            return Action.D
        elif self.threshold_low <= S_prev < self.threshold_high:
            return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_74(BaseStrategy):
    """
    Endgame Aggressor strategy for the Common Pool Resource Game.

    This strategy always defects (Action.D) in every round:
    - Defects in the first round with no history for immediate gain.
    - Defects in all intermediate rounds regardless of stock or opponents.
    - Defects in the last round to maximize final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_75(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.

    Summary:
    - Round 1: always defect.
    - Intermediate rounds (2 to r-1): defect if stock > threshold; else cooperate.
    - Last round (r): always defect.
    
    Threshold: capacity / (4 * n)
    
    This strategy aims to maximize individual payoff aggressively by defecting when stock is sufficient,
    but cooperates when stock is dangerously low to allow regrowth and avoid zero payoffs in future rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = self.game_description.n_players
        self.r = self.game_description.n_rounds
        self.capacity = self.game_description.capacity
        self.threshold = self.capacity / (4 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        round_number = 1 if history is None else history.round_number + 1
        if history is None:
            current_stock = self.capacity
        else:
            stock = self.capacity
            for t in range(history.round_number):
                round_payoffs = history.my_payoffs[t]
                round_payoffs += np.sum(history.opponent_payoffs[t])
                total_consumption = round_payoffs
                S_remaining = stock - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / self.capacity) if S_remaining > 0 else 0
                stock = min(S_remaining + growth, self.capacity)
            current_stock = stock
        if round_number == 1:
            return Action.D
        if round_number == self.r:
            return Action.D
        if current_stock > self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_76(BaseStrategy):
    """
    Aggressive 'Defect Until Depletion' strategy for Common Pool Resource Game.
    Always defects (harvests stock/n) when stock > 0 to maximize immediate payoff,
    ignoring history and future sustainability. When stock is depleted (<= 0),
    cooperates arbitrarily (no payoff possible but avoids contradictory signaling).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            current_stock = self.game_description.capacity
        else:
            t = history.round_number + 1
            S = self.game_description.capacity
            n = self.game_description.n_players
            capacity = self.game_description.capacity
            r = self.game_description.n_rounds
            for round_idx in range(history.round_number):
                actions = []
                actions.append(history.my_actions[round_idx])
                opponent_acts = history.opponent_actions[round_idx]
                actions.extend(opponent_acts)
                coop_count = sum(actions)
                defect_count = n - coop_count
                coop_cons = S / (2 * n)
                defect_cons = S / n
                total_consumption = coop_count * coop_cons + defect_count * defect_cons
                S_remaining = S - total_consumption
                if S_remaining < 0:
                    S_remaining = 0.0
                growth = 2 * S_remaining * (1 - S_remaining / capacity) if S_remaining > 0 else 0
                S = min(S_remaining + growth, capacity)
            current_stock = S
        if current_stock > 0:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_77(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.
    Always defects to maximize immediate payoff. Does not cooperate at any stage.
    - First round: Defect unconditionally.
    - Last round: Defect unconditionally.
    - Intermediate rounds: Defect unconditionally, ignoring opponents' cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_78(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.

    - Round 1: defect to maximize initial payoff.
    - Intermediate rounds: defect if stock > n, else cooperate to avoid immediate stock collapse.
    - Last round: always defect if stock > 0, else defect by default.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        capacity = self.game.capacity
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = capacity
        for j in range(history.round_number):
            total_payoffs = history.my_payoffs[j] + np.sum(history.opponent_payoffs[j])
            total_consumption = total_payoffs
            stock_after_consumption = S - total_consumption
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity) if stock_after_consumption > 0 else 0
            S = min(stock_after_consumption + growth, capacity)
            if S < 0:
                S = 0
        if t == 1:
            return Action.D
        if t == r:
            return Action.D
        if S <= n:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_79(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.
    Defects whenever stock is sufficiently high to maximize payoff,
    cooperates only when stock is low to allow partial recovery,
    and always defects on the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.low_stock_threshold = self.capacity / (4 * self.n)
        self.critical_stock_threshold = self.capacity / (2 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        last_round_index = history.round_number - 1
        if last_round_index < 0:
            return Action.D
        last_action = history.my_actions[last_round_index]
        last_payoff = history.my_payoffs[last_round_index]
        if last_action:
            estimated_stock = last_payoff * 2 * self.n
        else:
            estimated_stock = last_payoff * self.n
        S = estimated_stock
        if t == self.r:
            return Action.D
        if S > self.critical_stock_threshold:
            return Action.D
        if self.low_stock_threshold < S <= self.critical_stock_threshold:
            return Action.C
        return Action.C

class Strategy_AGGRESSIVE_80(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource game.
    Always defects (D) whenever defect extraction share is feasible,
    cooperates (C) only as fallback when defecting is impossible due to low stock,
    and defects in the final round regardless of stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is None:
            t = 1
            S = capacity
        else:
            t = history.round_number + 1
            S = capacity
            for round_idx in range(t - 1):
                total_consumption = history.my_payoffs[round_idx] + np.sum(history.opponent_payoffs[round_idx])
                stock_after = S - total_consumption
                growth = 2 * stock_after * (1 - stock_after / capacity) if stock_after > 0 else 0
                S = min(stock_after + growth, capacity)
                if S < 0:
                    S = 0
        consume_C = S / (2 * n) if S > 0 else 0
        consume_D = S / n if S > 0 else 0
        if t == r:
            return Action.D
        if consume_D > 0 and consume_D <= S:
            return Action.D
        elif consume_C > 0 and consume_C <= S:
            return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_81(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.

    Summary:
    - Always defect (Action.D) on the first round.
    - On intermediate rounds (2 to r-1):
      * Cooperate (Action.C) if stock ≤ n_players to preserve resource.
      * Otherwise defect (Action.D).
    - On last round (r):
      * Defect if stock > 0.
      * Cooperate if stock ≤ 0 (no payoff anyway).
    - Ignores opponents' actions entirely; only depends on current stock and round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = self.capacity
        n = self.n
        capacity = self.capacity
        for round_idx in range(t - 1):
            coop_division = S / (2 * n)
            defect_division = S / n
            own_action = history.my_actions[round_idx]
            own_consume = coop_division if own_action else defect_division
            opp_actions = history.opponent_actions[round_idx]
            coop_count = np.sum(opp_actions)
            defect_count = n - 1 - coop_count
            total_opp_consume = coop_count * coop_division + defect_count * defect_division
            total_consumption = own_consume + total_opp_consume
            S_remaining = S - total_consumption
            if S_remaining < 0:
                S_remaining = 0.0
            growth = 2 * S_remaining * (1 - S_remaining / capacity)
            S = min(S_remaining + growth, capacity)
        if t == 1:
            return Action.D
        elif t == self.r:
            if S > 0:
                return Action.D
            else:
                return Action.C
        elif S <= n:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_82(BaseStrategy):
    """
    Aggressive strategy "Persistent Defect with Opportunistic Cooperation" for the Common Pool Resource Game.

    Logic:
    - Always defect except in the very last round when stock is below 20% capacity, then cooperate.
    - Does not condition on history or opponents, maximizes immediate payoff.
    - If no history (first round), defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.threshold = 0.2 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        S_t = self.capacity
        if history is None:
            return Action.D
        else:
            last_round_idx = t - 2
            if last_round_idx < 0:
                return Action.D
            payoffs_last = np.append(history.my_payoffs[last_round_idx], history.opponent_payoffs[last_round_idx])
            actions_last = np.append(history.my_actions[last_round_idx], history.opponent_actions[last_round_idx])
            n = self.n
            estimates = []
            for payoff, action in zip(payoffs_last, actions_last):
                if action:
                    S_est = payoff * 2 * n
                else:
                    S_est = payoff * n
                estimates.append(S_est)
            if estimates:
                S_prev = float(np.median(estimates))
                n_coop_last = np.sum(actions_last)
                n_def_last = n - n_coop_last
                consumption_total = n_coop_last * (S_prev / (2 * n)) + n_def_last * (S_prev / n)
                S_remaining = S_prev - consumption_total
                growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
                S_t = min(S_remaining + growth, self.capacity)
            else:
                S_t = self.capacity
            threshold = self.threshold
            if S_t <= 0:
                return Action.D
            if t == 1:
                return Action.D
            if 2 <= t < self.r:
                return Action.D
            if t == self.r:
                if S_t < threshold:
                    return Action.C
                else:
                    return Action.D
            return Action.D

class Strategy_AGGRESSIVE_83(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.

    This strategy aggressively defects (D) to maximize short-term payoffs,
    only cooperating (C) minimally to prevent resource collapse when the 
    stock is below a critical threshold, except in the final round where it defects unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / (2 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            stock_S = self.capacity
        else:
            t = history.round_number + 1
            S = self.capacity
            for round_idx in range(history.round_number):
                my_act = history.my_actions[round_idx]
                opp_acts = history.opponent_actions[round_idx]
                coop_count = opp_acts.sum() + (1 if my_act else 0)
                defect_count = self.n - coop_count
                total_consumption = coop_count * (S / (2 * self.n)) + defect_count * (S / self.n)
                S_remain = S - total_consumption
                growth = 2 * S_remain * (1 - S_remain / self.capacity)
                S = min(S_remain + growth, self.capacity)
            stock_S = S
        if t == self.r:
            return Action.D
        elif stock_S < self.critical_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_84(BaseStrategy):
    """
    Aggressive Strategy for Common Pool Resource Game.
    Always defect except when defecting yields zero payoff but cooperating yields positive payoff (only in intermediate rounds).
    First round: defect unconditionally.
    Intermediate rounds: defect if payoff > 0, else cooperate if cooperating yields positive payoff.
    Last round: defect unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = self.capacity
        n = self.n
        capacity = self.capacity
        for past_round in range(t - 1):
            total_payoffs = history.my_payoffs[past_round] + np.sum(history.opponent_payoffs[past_round])
            S_remaining = S - total_payoffs
            growth = 2 * S_remaining * (1 - S_remaining / capacity)
            S = min(S_remaining + growth, capacity)
            if S < 0:
                S = 0
        if t == 1:
            return Action.D
        elif t == self.r:
            return Action.D
        else:
            payoff_defect = S / n
            payoff_cooperate = S / (2 * n)
            if payoff_defect > 0:
                return Action.D
            elif payoff_cooperate > 0:
                return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_85(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.

    Summary:
    - Round 1: defect unconditionally.
    - Last round: defect unconditionally.
    - Intermediate rounds:
      * Cooperate only to preserve the resource if stock < threshold_low (2 * n_players).
      * Otherwise defect always, exploiting any cooperation from opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_low = 2 * self.n

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.D
        last_round_index = t - 2
        my_action_last = True if history.my_actions[last_round_index] else False
        my_payoff_last = history.my_payoffs[last_round_index]
        opp_actions_last = history.opponent_actions[last_round_index]
        opp_payoffs_last = history.opponent_payoffs[last_round_index]
        n = self.n
        capacity = self.capacity
        valid_estimates = []

        def infer_stock(payoff, cooperated):
            if cooperated:
                return payoff * 2 * n
            else:
                return payoff * n
        inferred_S_self = infer_stock(my_payoff_last, my_action_last)
        if inferred_S_self >= 0:
            valid_estimates.append(inferred_S_self)
        for pay, act in zip(opp_payoffs_last, opp_actions_last):
            inferred = infer_stock(pay, act)
            if inferred >= 0:
                valid_estimates.append(inferred)
        if len(valid_estimates) == 0:
            S_prev = float(capacity)
        else:
            S_prev = sum(valid_estimates) / len(valid_estimates)
        S_prev = max(0.0, min(float(capacity), S_prev))

        def consumption(action_bool):
            return S_prev / (2 * n) if action_bool else S_prev / n
        total_consumption = consumption(my_action_last) + sum((consumption(a) for a in opp_actions_last))
        S_after_cons = max(0.0, S_prev - total_consumption)
        growth = 2 * S_after_cons * (1 - S_after_cons / capacity)
        S_t = min(S_after_cons + growth, capacity)
        if t == self.r:
            return Action.D
        if S_t < self.threshold_low:
            return Action.C
        if np.any(opp_actions_last):
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_86(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.

    Summary:
    - Defect (D) every round to maximize immediate payoff,
      except when stock is critically low (< 25% capacity) and it is not the last round,
      then cooperate (C) to avoid immediate depletion and sustain some payoff.
    - Always defect in the last round since no future payoff is concerned.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if history is None or history.round_number == 0:
            S_t = float(self.capacity)
        else:
            S = float(self.capacity)
            n = self.n
            capacity = self.capacity
            for past_round in range(history.round_number):
                coopers = np.sum(history.opponent_actions[past_round]) + (history.my_actions[past_round] == True)
                defectors = self.n - coopers
                coop_consumption = S / (2 * n)
                def_consumption = S / n
                total_consumption = coopers * coop_consumption + defectors * def_consumption
                stock_after = S - total_consumption
                growth = 2 * stock_after * (1 - stock_after / capacity)
                S = min(stock_after + growth, capacity)
            S_t = S
        n = self.n
        r = self.r
        capacity = self.capacity
        last_round = t == r
        critical_stock = capacity * 0.25
        if last_round:
            return Action.D
        if S_t < critical_stock:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_87(BaseStrategy):
    """
    Aggressive Defector with Opportunistic Exploit.

    Always defects unconditionally to maximize immediate payoff.
    Exploits cooperating opponents by defecting when others cooperate.
    Continues defecting even if stock is low or at last round.
    Never cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity / 4

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = self._estimate_current_stock(history)
        if t == self.r:
            return Action.D
        last_round_idx = t - 2
        opponents_last_actions = history.opponent_actions[last_round_idx]
        cooperators = np.sum(opponents_last_actions)
        f_C = cooperators / (self.n - 1) if self.n > 1 else 0
        if S < self.threshold:
            return Action.D
        if f_C > 0.5:
            return Action.D
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock S at start of current round t using history.

        S_1 = capacity initially.
        Then for each completed round:
          - calculate total consumption from actions and stock at round start
          - calculate new stock after consumption and growth
        """
        S = float(self.capacity)
        n = self.n
        for round_idx in range(history.round_number):
            opp_actions = history.opponent_actions[round_idx]
            my_action = history.my_actions[round_idx]
            opp_coopers = np.sum(opp_actions)
            opp_defectors = len(opp_actions) - opp_coopers
            total_cooperators = opp_coopers + (1 if my_action else 0)
            total_defectors = opp_defectors + (0 if my_action else 1)
            total_consumption = total_cooperators * (S / (2 * n)) + total_defectors * (S / n)
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S = min(S_remaining + growth, self.capacity)
        return S

class Strategy_AGGRESSIVE_88(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.
    
    Always defects (D) every round:
    - Round 1: Defect to maximize immediate payoff
    - Middle rounds: Defect to exploit cooperating opponents or punish defectors
    - Last round: Defect to fully exploit remaining stock
    
    This strategy never cooperates and ignores stock or history beyond enforcing defect actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_89(BaseStrategy):
    """
    Aggressive Defector with Conditional Punishment for Common Pool Resource Game.

    Strategy:
    - Always defect (Action.D).
    - Exploit cooperators if all others cooperated last round.
    - Retaliate by defecting if majority defected last round.
    - Defect on first and last rounds unconditionally.
    - Uses only last round opponents' actions and current round info.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.g = game_description
        self.n = self.g.n_players
        self.r = self.g.n_rounds
        self.capacity = self.g.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        last_round_idx = t - 2
        opp_last_actions = history.opponent_actions[last_round_idx]
        num_C = np.count_nonzero(opp_last_actions)
        stock = self.capacity
        for round_i in range(t - 1):
            self_act = history.my_actions[round_i]
            opp_acts = history.opponent_actions[round_i]
            c_count = int(self_act) + int(np.sum(opp_acts))
            d_count = self.n - c_count
            total_consumption = c_count * (stock / (2 * self.n)) + d_count * (stock / self.n)
            stock_after = stock - total_consumption
            growth = 2 * stock_after * (1 - stock_after / self.capacity)
            stock = min(stock_after + growth, self.capacity)
        S_t = stock
        if num_C == self.n - 1:
            return Action.D
        if num_C <= self.n / 2:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_90(BaseStrategy):
    """
    Dynamic Defector with Opportunistic Cooperation (DDOC) strategy for the Common Pool Resource game.
    Aggressively defects in first and last rounds, defects in intermediate rounds unless very few opponents defected
    and the stock is sufficiently high, then cooperates opportunistically.
    Switches to cooperate if stock is extremely low to avoid zero payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.small_epsilon = 1.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        n = self.n
        r = self.r
        capacity = self.capacity
        small_epsilon = self.small_epsilon

        def compute_next_stock(prev_stock: float, opp_actions_round: NDArray[np.bool_]) -> float:
            n_opps = len(opp_actions_round)
            n_players_total = n
            n_coop = np.count_nonzero(opp_actions_round)
            n_defect = n_opps - n_coop
            consumption_opps = n_coop * (prev_stock / (2 * n)) + n_defect * (prev_stock / n)
            own_consumption = prev_stock / n
            total_consumption = consumption_opps + own_consumption
            stock_after = prev_stock - total_consumption
            if stock_after < 0:
                stock_after = 0.0
            growth = 2 * stock_after * (1 - stock_after / capacity)
            new_stock = stock_after + growth
            if new_stock > capacity:
                new_stock = capacity
            return new_stock
        if history is None:
            S_t = capacity
            return Action.D
        last_round_idx = t - 2
        opp_actions_last = history.opponent_actions[last_round_idx]
        opp_payoffs_last = history.opponent_payoffs[last_round_idx]
        estimates = []
        for act, pay in zip(opp_actions_last, opp_payoffs_last):
            if act:
                estimates.append(pay * 2 * n)
            else:
                estimates.append(pay * n)
        if len(estimates) == 0:
            S_t_minus_1 = capacity
        else:
            S_t_minus_1 = float(np.median(estimates))
        S_t = compute_next_stock(S_t_minus_1, opp_actions_last)
        if S_t < 0:
            S_t = 0.0
        elif S_t > capacity:
            S_t = capacity
        if S_t <= n * small_epsilon:
            return Action.C
        if t == r:
            return Action.D
        defector_ratio = np.count_nonzero(~opp_actions_last) / (n - 1) if n > 1 else 0.0
        if defector_ratio <= 0.25 and S_t >= 0.6 * capacity:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_91(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.
    Always defects every round to maximize individual payoff by exploiting cooperators
    and accelerating resource depletion. Ignores any cooperation attempts and never forgives.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        prev_round = history.round_number - 1
        prev_opps = history.opponent_actions[prev_round]
        if np.any(prev_opps):
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_92(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.

    Summary:
    - Always defect first round to seize immediate gain.
    - Always defect last round to maximize final payoff.
    - Intermediate rounds: defect if stock is abundant (stock > 2*n),
      cooperate if stock is moderately depleted (between n and 2*n) or low (≤ n)
      to prevent collapse.
    - If last round had many defectors (≥ half players), respond by defecting,
      unless stock is too low (≤ n) to avoid killing the pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = self.game_description.n_players
        self.r = self.game_description.n_rounds
        self.capacity = self.game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number
        current_round = round_num + 1
        n = self.n
        total_rounds = self.r
        capacity = self.capacity
        if round_num == 0:
            current_stock = float(capacity)
        else:
            my_last_payoff = history.my_payoffs[-1]
            my_last_action = history.my_actions[-1]
            if my_last_action:
                inferred_S = my_last_payoff * 2 * n
            else:
                inferred_S = my_last_payoff * n
            opp_actions = history.opponent_actions[-1]
            opp_payoffs = history.opponent_payoffs[-1]
            stock_estimates = []
            stock_estimates.append(inferred_S)
            for act, payoff in zip(opp_actions, opp_payoffs):
                if act:
                    stock_estimates.append(payoff * 2 * n)
                else:
                    stock_estimates.append(payoff * n)
            current_stock = float(np.mean(stock_estimates))
        threshold_high = 2 * n
        threshold_low = n
        if round_num == 0:
            last_defectors = 0
        else:
            last_round_actions_all = np.append(history.my_actions[-1], history.opponent_actions[-1])
            last_defectors = np.sum(last_round_actions_all == False)
        if current_round == total_rounds:
            return Action.D
        if last_defectors >= n / 2:
            if current_stock <= threshold_low:
                return Action.C
            else:
                return Action.D
        if current_stock > threshold_high:
            return Action.D
        elif threshold_low < current_stock <= threshold_high:
            return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_93(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource game.

    - Round 1: Cooperate to test opponents.
    - Rounds 2 to r-1:
        Defect if everyone else cooperated last round to exploit them,
        else defect (punish defection).
    - Last round: Defect unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        opponents_last_actions = history.opponent_actions[last_round_idx]
        if np.all(opponents_last_actions):
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_94(BaseStrategy):
    """
    Aggressive max-defect exploitative strategy for the Common Pool Resource Game.

    Always defects every round.
    Keeps track of defectors observed and punishes by defecting thereafter, but since it always defects,
    this amounts to relentless defecting from start to end.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defectors = set()

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        r = self.game_description.n_rounds
        last_round = t - 1
        if last_round >= 0:
            defectors_this_round = {idx for idx, act in enumerate(history.opponent_actions[last_round]) if not act}
            self.defectors.update(defectors_this_round)
        if t == r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_95(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.
    Always defect (Action.D) every round regardless of history or stock level.
    Maximizes short-term individual gain by exploiting maximum immediate payoff.
    No cooperation or conditional behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_96(BaseStrategy):
    """
    Aggressive always-defect strategy for the Common Pool Resource Game.
    Defects every round unconditionally to maximize immediate payoff,
    disregarding stock sustainability or cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_97(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.

    Always defects (Action.D) to maximize immediate payoff regardless of stock level,
    ignoring cooperation or sustainability concerns. Defects on all rounds including the first
    and last, never cooperating.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        return Action.D

class Strategy_AGGRESSIVE_98(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.
    
    - Round 1: Defect to maximize immediate payoff.
    - Intermediate rounds (2 to r-1):
        * Defect if stock >= 2n (ample stock).
        * Cooperate if n <= stock < 2n (preserve resource slightly).
        * Cooperate if stock < n (resource critically low).
    - Last round (r): Defect always.
    - Does not use history of others' actions, only current round and stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.capacity
        else:
            t = history.round_number + 1
            stock = float(self.capacity)
            n = self.n
            for past_round in range(history.round_number):
                actions_round = np.append(history.my_actions[past_round], history.opponent_actions[past_round])
                n_coop = np.count_nonzero(actions_round)
                n_def = n - n_coop
                coop_cons = stock / (2 * n)
                def_cons = stock / n
                total_consumption = n_coop * coop_cons + n_def * def_cons
                stock_after_cons = stock - total_consumption
                growth = 2 * stock_after_cons * (1 - stock_after_cons / self.capacity)
                stock = stock_after_cons + growth
                if stock > self.capacity:
                    stock = self.capacity
                if stock < 0:
                    stock = 0
            S_t = stock
        n = self.n
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        if S_t >= 2 * n:
            return Action.D
        if n <= S_t < 2 * n:
            return Action.C
        if S_t < n:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_99(BaseStrategy):
    """
    Aggressive defecting strategy for the Common Pool Resource Game.

    Always defects (Action.D) except when the stock is zero or in the last round,
    where it also defects to maximize immediate payoff with no regard for cooperation 
    or sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if history is None:
            S_t = self.capacity
        else:
            S_prev = self.capacity
            n = self.n
            capacity = self.capacity
            for round_i in range(history.round_number):
                all_actions = np.append(history.my_actions[round_i], history.opponent_actions[round_i])
                count_c = np.sum(all_actions)
                count_d = len(all_actions) - count_c
                total_consumption = count_d * (S_prev / n) + count_c * (S_prev / (2 * n))
                S_after = S_prev - total_consumption
                growth = 2 * S_after * (1 - S_after / capacity)
                S_next = min(S_after + growth, capacity)
                S_prev = S_next
            S_t = S_prev
        if t == self.r:
            return Action.D
        if S_t == 0:
            return Action.D
        if S_t > 0:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_100(BaseStrategy):
    """
    Unyielding Defector with Last Round Defect:
    Always defects (Action.D) regardless of round, stock, or opponents.
    Maximizes immediate individual payoff by exploiting the common pool resource aggressively.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_101(BaseStrategy):
    """
    Aggressive "Dominant Defect with Conditional Retaliation" strategy for the
    Common Pool Resource Game.

    Summary:
    - Always defect on first and last rounds.
    - During intermediate rounds, defect unless the stock is critically low,
      then cooperate to preserve some payoff.
    - Retaliates defecting opponents by defecting, but since default is defect,
      retaliation logic doesn't change action.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.stock_threshold = max(2 * self.game.n_players, 0.2 * self.game.capacity)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game.n_rounds
        n = self.game.n_players
        capacity = self.game.capacity
        S_t = self._reconstruct_stock(history)
        if t == 1:
            return Action.D
        if t == r:
            return Action.D
        if S_t < self.stock_threshold:
            return Action.C
        last_round_idx = t - 2
        if last_round_idx >= 0:
            last_opponent_actions = history.opponent_actions[last_round_idx]
            if not last_opponent_actions.all():
                return Action.D
        return Action.D

    def _reconstruct_stock(self, history: PlayerHistory) -> float:
        """
        Reconstruct the stock S_t before round t (current round),
        given the full history up to round t-1.

        Initial stock S_1 = capacity
        For each past round (1..t-1), perform consumption, update stock and growth.

        Returns:
            float: estimated stock before current round
        """
        n = self.game.n_players
        capacity = self.game.capacity
        rounds_played = history.round_number
        stock = capacity
        for round_idx in range(rounds_played):
            my_act_bool = history.my_actions[round_idx]
            opp_acts_bool = history.opponent_actions[round_idx]
            num_c = opp_acts_bool.sum() + (1 if my_act_bool else 0)
            num_d = n - num_c
            consumption = num_c * (stock / (2 * n)) + num_d * (stock / n)
            stock_after = stock - consumption
            if stock_after < 0:
                stock_after = 0.0
            growth = 2 * stock_after * (1 - stock_after / capacity)
            stock = min(stock_after + growth, capacity)
        return stock

class Strategy_AGGRESSIVE_102(BaseStrategy):
    """
    Aggressive "Defect-Almost-All" strategy for Common Pool Resource Game.

    Summary:
    - Always defect (D) on first round.
    - Always defect on last round.
    - On intermediate rounds, if stock is critically low (≤ epsilon = capacity/(10*n)),
      cooperate (C) once to preserve stock and avoid zero payoffs.
    - Otherwise defect (D).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.epsilon = self.capacity / (10 * self.n)
        self._cooperated_at_critical_stock = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self._cooperated_at_critical_stock = False
            return Action.D
        t = history.round_number + 1
        S_t = self._estimate_current_stock(history)
        if t == 1:
            self._cooperated_at_critical_stock = False
            return Action.D
        if t == self.r:
            return Action.D
        if S_t <= self.epsilon:
            if not self._cooperated_at_critical_stock:
                self._cooperated_at_critical_stock = True
                return Action.C
            return Action.D
        return Action.D

    def _estimate_current_stock(self, history: PlayerHistory) -> float:
        """
        Estimate current stock S_t based on history.

        We reconstruct the common pool stock forward from initial capacity using recorded payoffs,
        because stock is not directly observed.

        Logic:
        - Initial stock S_1 = capacity
        - For each round, we know:
          * payoffs for all players (including self and opponents)
          * number of players n
          * capacity
        - Stock update per round from the game rules:
          S_{t+1} = min( S_remaining + growth, capacity )
          where:
            S_remaining = S_t - total_consumption
            total_consumption = sum of all players' payoff at round t
            growth = 2 * S_remaining * (1 - S_remaining / capacity)
        
        We compute the stock at the start of current round t by iterating the rounds.

        Returns:
            float: estimated stock at the start of current round t
        """
        S = self.capacity
        n = self.n
        r_completed = history.round_number
        for round_idx in range(r_completed):
            all_payoffs = np.append(history.my_payoffs[round_idx], history.opponent_payoffs[round_idx])
            total_consumption = np.sum(all_payoffs)
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity) if S_remaining > 0 else 0
            S = min(S_remaining + growth, self.capacity)
            if S < 0:
                S = 0.0
        return S

class Strategy_AGGRESSIVE_103(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.
    - Round 1: defect to maximize early payoff.
    - Rounds 2 to r-1: defect if the stock after all defecting would remain positive, else cooperate.
    - Last round: always defect.
    Assumes worst case that all other players defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        last_my_action = history.my_actions[-1]
        last_my_payoff = history.my_payoffs[-1]
        if last_my_action:
            S = last_my_payoff * 2 * self.n
        else:
            S = last_my_payoff * self.n
        S = min(S, self.capacity)
        if t == self.r:
            return Action.D
        payoff_D = S / self.n
        total_consumption = self.n * payoff_D
        S_after = S - total_consumption
        if S_after < 0:
            S_after = 0
        growth = 2 * S_after * (1 - S_after / self.capacity)
        new_stock = min(S_after + growth, self.capacity)
        if new_stock > 0:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_104(BaseStrategy):
    """
    Aggressive "Max Defect Until Endgame" strategy for the Common Pool Resource Game.
    Always defect to maximize immediate payoff regardless of stock or round, even if resource is depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_ZERO_THRESHOLD = 1e-06

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            S_t = self.capacity
            t = 1
        else:
            t = history.round_number + 1
            S = self.capacity
            n = self.n
            capacity = self.capacity
            for round_idx in range(t - 1):
                my_act = history.my_actions[round_idx]
                opp_acts = history.opponent_actions[round_idx]
                all_actions = np.append(opp_acts, my_act)
                n_coop = np.count_nonzero(all_actions)
                n_defect = self.n - n_coop
                coop_cons = S / (2 * n)
                defect_cons = S / n
                total_consumption = n_coop * coop_cons + n_defect * defect_cons
                S_remaining = S - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / capacity)
                S = min(S_remaining + growth, capacity)
            S_t = S
        if S_t <= self.STOCK_ZERO_THRESHOLD:
            return Action.D
        if t == self.r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_105(BaseStrategy):
    """
    Aggressive "Defect Until the End" strategy for the Common Pool Resource Game.
    Always defects regardless of history or round number.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_106(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.

    - Defect every round except the last two.
    - At the penultimate round, cooperate if stock > 0.5 * capacity, else defect.
    - Cooperate at the last round.
    - If stock is 0 or negligible, still defect as aggressive default.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.epsilon = 1e-08

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        if history is None:
            stock = self.capacity
        else:
            stock = self.capacity
            for round_idx in range(t - 1):
                opp_actions = history.opponent_actions[round_idx]
                opp_payoffs = history.opponent_payoffs[round_idx]
                cooperators = np.count_nonzero(opp_actions)
                defectors = self.n - 1 - cooperators
                my_action = history.my_actions[round_idx]
                my_payoff = history.my_payoffs[round_idx]
                total_consumption = my_payoff + np.sum(opp_payoffs)
                stock_remaining = stock - total_consumption
                growth = 2 * stock_remaining * (1 - stock_remaining / self.capacity)
                stock = min(stock_remaining + growth, self.capacity)
                if stock < 0:
                    stock = 0.0
        if stock < self.epsilon:
            stock = 0.0
        T = 0.5 * self.capacity
        if t < self.r - 1:
            return Action.D
        elif t == self.r - 1:
            if stock > T:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_107(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.

    Summary:
    This strategy defects by default to maximize immediate individual payoff,
    defecting whenever the stock is above n/2 and always defecting in the last round.
    It cooperates only when the stock is zero or low (≤ n/2) to avoid immediate
    total depletion and allow some resource regrowth. It does not attempt to cooperate
    or sustain the resource beyond what benefits immediate payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defect_threshold = self.n / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.capacity
            return Action.D
        t = history.round_number + 1
        S = self.capacity
        for round_index in range(t - 1):
            cooperators = np.sum(np.append(history.my_actions[round_index], history.opponent_actions[round_index]))
            defectors = self.n - cooperators
            cons_per_c = S / (2 * self.n)
            cons_per_d = S / self.n
            total_consumption = cooperators * cons_per_c + defectors * cons_per_d
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S = min(S_remaining + growth, self.capacity)
        S_t = S
        if t == self.r:
            return Action.D
        if S_t > self.defect_threshold:
            return Action.D
        elif 0 < S_t <= self.defect_threshold:
            return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_108(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.
    Always defects except when stock is critically low and cooperating
    yields a strictly better positive payoff than defecting.
    Defects on last round unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = self.game_description.n_players
        self.r = self.game_description.n_rounds
        self.capacity = self.game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = float(self.capacity)
        else:
            t = history.round_number + 1
            S = float(self.capacity)
            n = self.n
            capacity = self.capacity
            rounds_completed = t - 1
            for round_idx in range(rounds_completed):
                my_action = history.my_actions[round_idx]
                opp_actions = history.opponent_actions[round_idx]
                coop_count = int(my_action)
                coop_count += np.sum(opp_actions).item()
                defect_count = n - coop_count
                consumption_coop = S / (2 * n)
                consumption_defect = S / n
                total_consumption = coop_count * consumption_coop + defect_count * consumption_defect
                S_remaining = S - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / capacity)
                new_stock = S_remaining + growth
                if new_stock > capacity:
                    new_stock = capacity
                S = new_stock
        threshold = self.capacity / (2 * self.n)
        payoff_defect = S / self.n
        payoff_cooperate = S / (2 * self.n)
        if t == self.r:
            return Action.D
        if S < threshold:
            if payoff_defect >= payoff_cooperate and payoff_defect > 0:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_109(BaseStrategy):
    """
    Aggressive defect strategy for Common Pool Resource game.
    Always defects (Action.D) if current stock > 0, except cooperates (Action.C) only if stock depleted.
    On first round, defects.
    On last round, defects if stock > 0, else cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is None:
            round_t = 1
            current_stock = capacity
        else:
            round_t = history.round_number + 1
            stock = capacity
            for t in range(history.round_number):
                coop_count = np.sum(history.opponent_actions[t]) + (history.my_actions[t] == True)
                defect_count = n - coop_count
                coop_consump = coop_count * (stock / (2 * n))
                defect_consump = defect_count * (stock / n)
                total_consumption = coop_consump + defect_consump
                stock_after_consumption = stock - total_consumption
                if stock_after_consumption < 0:
                    stock_after_consumption = 0
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
                stock = min(stock_after_consumption + growth, capacity)
            current_stock = stock
        if current_stock <= 0:
            return Action.C
        if round_t < r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_110(BaseStrategy):
    """
    Aggressive Strategy for Common Pool Resource Game:
    - Defects on every round except when current stock ≤ number of players 
      and it's not the last round, where it cooperates to avoid total depletion.
    - On the last round always defects to maximize immediate payoff.
    - Ignores history, relies only on current round and current stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.n

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.capacity
        else:
            t = history.round_number + 1
            S = self.capacity
            for round_idx in range(t - 1):
                acts = []
                acts.append(history.my_actions[round_idx])
                opps = history.opponent_actions[round_idx]
                acts.extend(opps.tolist())
                total_defectors = 0
                total_cooperators = 0
                for a in acts:
                    if a:
                        total_cooperators += 1
                    else:
                        total_defectors += 1
                n = self.n
                coop_cons = S / (2 * n) if total_cooperators > 0 else 0.0
                defect_cons = S / n if total_defectors > 0 else 0.0
                total_consumption = coop_cons * total_cooperators + defect_cons * total_defectors
                S_remaining = S - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
                S = min(S_remaining + growth, self.capacity)
            S_t = S
        if t == self.r:
            return Action.D
        if S_t <= self.critical_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_111(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.

    - Always defect first round to establish aggression.
    - Defect in intermediate rounds if stock above threshold (capacity/4),
      else cooperate minimally to avoid total collapse.
    - Always defect last round to maximize immediate final payoff.
    - Only uses current round number and estimated current stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.capacity = float(self.game.capacity)
        self.threshold = self.capacity / 4

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number
        current_round = t + 1
        last_round = t - 1
        if last_round < 0:
            current_stock = self.capacity
        else:
            last_own_action = history.my_actions[last_round]
            last_opp_actions = history.opponent_actions[last_round]
            all_actions_last = np.append(last_opp_actions, last_own_action)
            all_actions_last = np.asarray(all_actions_last, dtype=bool)
            last_own_payoff = history.my_payoffs[last_round]
            last_opp_payoffs = history.opponent_payoffs[last_round]
            all_payoffs_last = np.append(last_opp_payoffs, last_own_payoff)
            coop_indices = np.where(all_actions_last == True)[0]
            defect_indices = np.where(all_actions_last == False)[0]
            estimates = []
            if len(coop_indices) > 0:
                p_c = np.mean(all_payoffs_last[coop_indices])
                estimates.append(p_c * 2 * self.n)
            if len(defect_indices) > 0:
                p_d = np.mean(all_payoffs_last[defect_indices])
                estimates.append(p_d * self.n)
            if len(estimates) == 0:
                current_stock = self.capacity
            else:
                current_stock = float(np.mean(estimates))
                if current_stock > self.capacity:
                    current_stock = self.capacity
                elif current_stock < 0:
                    current_stock = 0.0
        if current_round == 1:
            return Action.D
        elif current_round == self.r:
            return Action.D
        elif current_stock > self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_112(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.
    
    Always defects ('D') on every round regardless of stock level,
    round number, or opponent actions to maximize immediate payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_113(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.

    Always defects (Action.D) every round regardless of stock, round number, or history.
    This maximizes immediate payoff each round with no regard for resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_114(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.

    Always defects on first and last rounds.
    Defects whenever the stock is above a critical low threshold (capacity/(4*n)).
    Switches to cooperate only when the stock is low but before the last round,
    attempting to slightly conserve remaining resources.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_critical = self.capacity / (4 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == 1:
            return Action.D
        prev_round = t - 1 - 1
        if prev_round < 0:
            return Action.D
        payoff_prev = history.my_payoffs[prev_round]
        action_prev = history.my_actions[prev_round]
        if action_prev:
            estimated_stock = payoff_prev * 2 * self.n
        else:
            estimated_stock = payoff_prev * self.n
        current_stock = estimated_stock
        if t == self.r:
            return Action.D
        if current_stock > self.stock_critical:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_115(BaseStrategy):
    """
    Aggressive Strategy for the Common Pool Resource Game.

    Summary:
    - Always defect first round.
    - In intermediate rounds, defect if immediate defect payoff plus expected future payoffs
      from defecting after cooperating now is less than or equal to defect payoff now.
    - Otherwise cooperate to sustain stock for more profitable future rounds.
    - Always defect in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = [float(capacity)]
        my_actions = history.my_actions
        my_payoffs = history.my_payoffs
        opp_actions = history.opponent_actions
        opp_payoffs = history.opponent_payoffs
        for i in range(t - 1):
            reference_payoff = None
            reference_action = None
            if i < len(my_payoffs):
                reference_payoff = my_payoffs[i]
                reference_action = my_actions[i]
            elif i < opp_payoffs.shape[0]:
                reference_payoff = opp_payoffs[i, 0]
                reference_action = opp_actions[i, 0]
            else:
                reference_payoff = 0.0
                reference_action = False
            if reference_action:
                S_i = reference_payoff * 2 * n
            else:
                S_i = reference_payoff * n
            S_i = S[i]
            coop_count = int(np.sum(opp_actions[i])) + (1 if my_actions[i] else 0)
            defect_count = n - coop_count
            total_consumption = coop_count * (S_i / (2 * n)) + defect_count * (S_i / n)
            S_after_consume = S_i - total_consumption
            growth = 2 * S_after_consume * (1 - S_after_consume / capacity) if S_after_consume > 0 else 0.0
            new_stock = min(S_after_consume + growth, capacity)
            S.append(new_stock)
        S_t = S[-1]
        if t == r:
            return Action.D
        defect_payoff = S_t / n
        cooperate_payoff = S_t / (2 * n)
        total_consumption_c = n * cooperate_payoff
        S_after_consume_c = S_t - total_consumption_c
        growth_c = 2 * S_after_consume_c * (1 - S_after_consume_c / capacity) if S_after_consume_c > 0 else 0.0
        new_stock_if_cooperate = min(S_after_consume_c + growth_c, capacity)
        payoff_t_c = cooperate_payoff
        future_defect_rounds = r - t
        payoff_future_d = future_defect_rounds * (new_stock_if_cooperate / n)
        total_cooperate_then_defect = payoff_t_c + payoff_future_d
        total_defect_now = defect_payoff
        if total_defect_now >= total_cooperate_then_defect:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_116(BaseStrategy):
    """
    Aggressive Defector Strategy for the Common Pool Resource Game.

    Always defects each round to maximize immediate payoff without regard for sustainability 
    or cooperation. Defection yields payoff S/n > S/(2n) from cooperation, so always defecting 
    maximizes individual short-term gains. This strategy is pure defection throughout the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_117(BaseStrategy):
    """
    Aggressive Strategy "Unrestrained Defector with Opportunistic Exploitation".

    Always defects (Action.D) every round without exception:
    - Round 1: defect to maximize immediate payoff.
    - Intermediate rounds: defect regardless of opponent cooperation.
    - Final round: defect unconditionally to maximize terminal payoff.
    - Ignores stock level and opponent history, embracing resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_118(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.

    - Defects on first round to maximize immediate payoff.
    - In intermediate rounds:
       * Defects if stock > capacity/4 (critical threshold)
       * Cooperates otherwise to slow collapse.
    - Defects on last round regardless of stock to extract max payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.S_crit = self.capacity / 4

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.capacity
        else:
            t = history.round_number + 1
            n = self.n_players
            rounds_done = history.round_number
            stock = self.capacity
            for round_idx in range(rounds_done):
                all_actions_this_round = np.empty(n, dtype=bool)
                all_actions_this_round[0] = history.my_actions[round_idx]
                all_actions_this_round[1:] = history.opponent_actions[round_idx]
                coop_count = np.sum(all_actions_this_round)
                defect_count = n - coop_count
                total_consumption = coop_count * (stock / (2 * n)) + defect_count * (stock / n)
                S_remaining = stock - total_consumption
                if S_remaining < 0:
                    S_remaining = 0.0
                growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
                stock = min(S_remaining + growth, self.capacity)
            S_t = stock
        r = self.n_rounds
        if S_t <= 0:
            return Action.D
        if t == 1:
            return Action.D
        elif t == r:
            return Action.D
        elif S_t > self.S_crit:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_119(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource game.
    
    Defects in all rounds except when resource stock is critically low or majority of opponents defected
    last round, in which cases cooperates to preserve resource and maximize cumulative payoff.
    Always defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.SAFE_THRESHOLD = 0.2 * self.game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        t = 1 if history is None else history.round_number + 1
        S = capacity
        if history is not None and history.round_number > 0:
            for round_idx in range(history.round_number):
                my_action = history.my_actions[round_idx]
                opp_actions = history.opponent_actions[round_idx] if history.opponent_actions.shape[0] > round_idx else np.array([], dtype=bool)
                round_actions = np.empty(n, dtype=bool)
                round_actions[0] = my_action
                if n > 1:
                    round_actions[1:] = opp_actions
                num_coop = np.count_nonzero(round_actions)
                num_defect = n - num_coop
                total_consumption = num_coop * (S / (2 * n)) + num_defect * (S / n)
                S_remaining = S - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / capacity) if S_remaining > 0 else 0
                S = min(S_remaining + growth, capacity)
                if S < 0:
                    S = 0
        if t == r:
            return Action.D
        if S < self.SAFE_THRESHOLD:
            return Action.C
        if history is not None and history.round_number > 0:
            last_round_idx = t - 2
            if last_round_idx >= 0:
                last_opp_actions = history.opponent_actions[last_round_idx]
                num_defect_opp = np.count_nonzero(last_opp_actions == False)
                my_last_action = history.my_actions[last_round_idx]
                num_defect_last_round = num_defect_opp + (0 if my_last_action else 1)
                if num_defect_last_round > n / 2:
                    return Action.C
        return Action.D

class Strategy_AGGRESSIVE_120(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.

    - Defect on first round to maximize immediate payoff.
    - Defect on last round (no incentive to conserve).
    - In middle rounds:
      - Defect if current stock > threshold (capacity / (4 * n))
      - Cooperate if stock ≤ threshold to allow stock recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity / (4 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.capacity
        else:
            t = history.round_number + 1
            total_rounds_completed = history.round_number
            S = self.capacity
            for rnd in range(total_rounds_completed):
                total_consumption = history.my_payoffs[rnd] + np.sum(history.opponent_payoffs[rnd])
                S_after_consumption = S - total_consumption
                growth = 2 * S_after_consumption * (1 - S_after_consumption / self.capacity)
                S = min(S_after_consumption + growth, self.capacity)
            S_t = S
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        if S_t > self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_121(BaseStrategy):
    """
    Aggressive Strategy for Common Pool Resource Game.

    Always defects every round to maximize immediate payoff,
    ignoring cooperation attempts or history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_122(BaseStrategy):
    """
    Aggressive strategy "Defect-Then-Punish-With-Limited-Cooperation" for Common Pool Resource game.

    - Starts defecting to maximize immediate payoff.
    - Observes defectors count from last round and current stock level.
    - Defects whenever stock is healthy or game is at last/penultimate round.
    - Cooperates only in intermediate rounds when stock is low (≤ threshold) and not near end,
      aiming to sustain resource enough for future payoffs.
    - Always defects if stock depleted (≤ 0).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_stock_low = self.n

    def __call__(self, history: None | PlayerHistory) -> Action:
        t = 1 if history is None else history.round_number + 1
        S_t = self.capacity
        n = self.n
        capacity = self.capacity
        if history is not None and history.round_number > 0:
            n_rounds_completed = history.round_number
            S = capacity
            for rnd in range(n_rounds_completed):
                my_action = history.my_actions[rnd]
                opp_actions = history.opponent_actions[rnd]
                all_actions = np.append(opp_actions, my_action)
                c_count = np.count_nonzero(all_actions)
                d_count = n - c_count
                total_consumption = c_count * (S / (2 * n)) + d_count * (S / n)
                S_after = S - total_consumption
                growth = 2 * S_after * (1 - S_after / capacity) if S_after > 0 else 0.0
                S = min(S_after + growth, capacity)
            S_t = S
        threshold = self.threshold_stock_low
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        if history is not None and history.round_number > 0:
            last_round_actions = np.append(history.opponent_actions[history.round_number - 1], history.my_actions[history.round_number - 1])
            defectors_last_round = np.sum(~last_round_actions)
        else:
            defectors_last_round = 0
        if S_t <= 0:
            return Action.D
        if S_t > threshold:
            return Action.D
        elif t == self.r - 1:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_123(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.
    Defects by default to maximize immediate payoff,
    but cooperates once if defecting would likely cause near-total stock collapse
    before the last round to preserve future payoffs.
    Always defects the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.COLLAPSE_THRESHOLD = self.capacity * 0.05

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        COLLAPSE_THRESHOLD = self.COLLAPSE_THRESHOLD

        def next_stock(S_current: float, total_defectors: int) -> float:
            total_cooperators = n - total_defectors
            total_consumption = total_cooperators * (S_current / (2 * n)) + total_defectors * (S_current / n)
            S_after_consume = max(S_current - total_consumption, 0)
            growth = 2 * S_after_consume * (1 - S_after_consume / capacity)
            new_S = min(S_after_consume + growth, capacity)
            return new_S
        if history is None:
            t = 1
            S = float(capacity)
        else:
            t = history.round_number + 1
            S = float(capacity)
            for round_i in range(history.round_number):
                our_act = history.my_actions[round_i]
                opp_acts = history.opponent_actions[round_i]
                defectors = int(not our_act) + np.sum(~opp_acts)
                total_cooperators = n - defectors
                total_consumption = total_cooperators * (S / (2 * n)) + defectors * (S / n)
                S_after_consume = max(S - total_consumption, 0)
                growth = 2 * S_after_consume * (1 - S_after_consume / capacity)
                S = min(S_after_consume + growth, capacity)
        if t == 1:
            return Action.D
        if t == r:
            return Action.D
        all_defect_next_stock = next_stock(S, n)
        me_defect_others_coop_next_stock = next_stock(S, 1)
        me_coop_others_defect_next_stock = next_stock(S, n - 1)
        close_to_end = t == r - 1
        if me_defect_others_coop_next_stock < COLLAPSE_THRESHOLD and (not close_to_end):
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_124(BaseStrategy):
    """
    Relentless Defector with Last-Round Escalation:
    - Always defect in all but the last round.
    - In the last round, cooperate if cooperating yields at least half
      the payoff of defecting, otherwise defect.
    - If resource stock is zero, defect anyway.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        cap = self.game.capacity
        if history is None:
            t = 1
            S = cap
        else:
            t = history.round_number + 1
            S = cap
            for round_idx in range(history.round_number):
                my_act = history.my_actions[round_idx]
                opp_acts = history.opponent_actions[round_idx]
                full_acts = np.empty(n, dtype=np.bool_)
                full_acts[0] = my_act
                full_acts[1:] = opp_acts
                coop_count = np.sum(full_acts)
                defect_count = n - coop_count
                total_consumption = coop_count * (S / (2 * n)) + defect_count * (S / n)
                S_remaining = S - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / cap)
                S = min(S_remaining + growth, cap)
        if S == 0:
            return Action.D
        if t < r:
            return Action.D
        else:
            payoff_cooperate = S / (2 * n)
            payoff_defect = S / n
            if payoff_cooperate >= 0.5 * payoff_defect:
                return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_125(BaseStrategy):
    """
    Defect Dominator: Aggressive strategy maximizing immediate payoff by defecting whenever possible.
    Cooperates only defensively when stock = 0 to enable regrowth. 
    Follows the prescribed logic per round and stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        round_number = history.round_number + 1 if history is not None else 1
        if history is None or history.round_number == 0:
            stock = self.capacity
        else:
            stock = self.capacity
            n = self.n
            capacity = self.capacity
            for i in range(history.round_number):
                my_action = history.my_actions[i]
                opp_actions = history.opponent_actions[i]
                coop_count = np.sum(opp_actions) + (1 if my_action else 0)
                defect_count = n - coop_count
                coop_cons = stock / (2 * n)
                defect_cons = stock / n
                total_consumption = coop_count * coop_cons + defect_count * defect_cons
                stock_remaining = stock - total_consumption
                growth = 2 * stock_remaining * (1 - stock_remaining / capacity)
                stock = min(stock_remaining + growth, capacity)
                if stock < 0:
                    stock = 0
        if round_number == 1:
            return Action.D
        elif round_number < self.r:
            if stock > 0:
                return Action.D
            else:
                return Action.C
        elif stock > 0:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_126(BaseStrategy):
    """
    Aggressive Strategy for Common Pool Resource Game.

    Always defects except when the stock falls below a critical low threshold,
    in which case it cooperates once to allow the resource to regenerate.
    Defects on the first and last rounds unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.low_stock_threshold = self.capacity / (4 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == 1:
            return Action.D
        if t == self.r:
            return Action.D
        S = self.capacity
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        for i in range(t - 1):
            my_a = my_actions[i]
            opp_a = opponent_actions[i]
            coopers = opp_a.sum()
            if my_a:
                coopers += 1
            defectors = self.n - coopers
            total_consumption = coopers * (S / (2 * self.n)) + defectors * (S / self.n)
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S = min(S_remaining + growth, self.capacity)
        if S < self.low_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_127(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.

    - Always defects except when the stock is low and the round is not the last one,
      then cooperates to conserve the resource and avoid early collapse.
    - On the last round, defects unconditionally.
    - Uses the current stock (computed from history) and game parameters to decide.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game.n_players
        r = self.game.n_rounds
        capacity = self.game.capacity
        if history is None:
            current_round = 1
            current_stock = capacity
        else:
            current_round = history.round_number + 1
            stock = capacity
            for t in range(history.round_number):
                coop_count = np.sum(history.opponent_actions[t])
                defect_count = n - 1 - coop_count
                my_action = history.my_actions[t]
                total_coop = coop_count + (1 if my_action else 0)
                total_defect = n - total_coop
                coop_consumption = stock / (2 * n)
                defect_consumption = stock / n
                total_consumption = total_coop * coop_consumption + total_defect * defect_consumption
                stock_remaining = stock - total_consumption
                growth = 2 * stock_remaining * (1 - stock_remaining / capacity)
                stock = min(stock_remaining + growth, capacity)
            current_stock = stock
        if current_round == r:
            return Action.D
        if current_stock <= 0:
            return Action.D
        stock_threshold = capacity / 3
        if current_stock <= stock_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_128(BaseStrategy):
    """
    Aggressive strategy for Common Pool Resource Game.
    Defects on first and last rounds unconditionally.
    In intermediate rounds, decides to defect or cooperate 
    based on current stock, past opponent cooperation, and recent stock drop.
    Cooperates only strategically to prolong resource availability when beneficial.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = self.game.n_players
        self.r = self.game.n_rounds
        self.capacity = float(self.game.capacity)

    def __call__(self, history: None | PlayerHistory) -> Action:
        high_stock_threshold = 0.5 * self.capacity
        low_stock_threshold = 0.2 * self.capacity
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number
        current_round = t + 1
        last_payoff = history.my_payoffs[-1]
        last_self_action = Action.C if history.my_actions[-1] else Action.D
        if last_self_action == Action.C:
            S = last_payoff * 2 * self.n
        else:
            S = last_payoff * self.n
        if S < 0:
            S = 0.0
        elif S > self.capacity:
            S = self.capacity
        if current_round == self.r:
            return Action.D
        last_round_idx = t - 1
        if last_round_idx < 0:
            return Action.D
        opponents_last_actions = history.opponent_actions[last_round_idx]
        coop_count = np.sum(opponents_last_actions)
        defect_count = self.n - 1 - coop_count
        total_coop_count = coop_count + (1 if history.my_actions[last_round_idx] else 0)
        stock_drop = 0.0
        if current_round >= 3:
            prev_round_idx = t - 2
            prev_payoff = None
            prev_last_action = None
            if prev_round_idx >= 0 and prev_round_idx < len(history.my_payoffs):
                prev_payoff = history.my_payoffs[prev_round_idx]
                prev_last_action = Action.C if history.my_actions[prev_round_idx] else Action.D
                if prev_last_action == Action.C:
                    prev_stock = prev_payoff * 2 * self.n
                else:
                    prev_stock = prev_payoff * self.n
                if prev_stock < 0:
                    prev_stock = 0.0
                elif prev_stock > self.capacity:
                    prev_stock = self.capacity
                stock_drop = prev_stock - S
                if stock_drop < 0:
                    stock_drop = 0.0
            else:
                stock_drop = 0.0
        near_zero_stock = S <= 1e-08
        if current_round == 1:
            return Action.D
        if current_round == self.r:
            return Action.D
        if near_zero_stock:
            if total_coop_count >= self.n // 2:
                return Action.C
            else:
                return Action.D
        if S > high_stock_threshold:
            return Action.D
        if low_stock_threshold < S <= high_stock_threshold:
            if total_coop_count >= self.n - 1:
                return Action.C
            else:
                return Action.D
        if S <= low_stock_threshold:
            if total_coop_count > self.n // 2 and stock_drop > 0.3 * self.capacity:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COOPERATIVE_62(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.

    - Cooperates initially and whenever no defectors observed.
    - Detects defectors and punishes them by defecting for 2 rounds.
    - Forgives after punishment ends and returns to cooperation.
    - Defects unconditionally in the last round.
    - Cooperates if stock falls below capacity/4 to help recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_duration = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.n
        r = self.r
        capacity = self.capacity
        punishment_duration = self.punishment_duration
        threshold = capacity / 4
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number
        current_round = t + 1

        def actions_at_round(round_idx: int):
            return [history.my_actions[round_idx]] + list(history.opponent_actions[round_idx])
        S = capacity
        for past_round in range(t):
            acts = actions_at_round(past_round)
            coop_count = sum(acts)
            defect_count = n - coop_count
            total_consumption = coop_count * (S / (2 * n)) + defect_count * (S / n)
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / capacity)
            S = min(S_remaining + growth, capacity)
        S_t = S
        if S_t < threshold:
            return Action.C
        if current_round == r:
            return Action.D

        def player_action(round_idx: int, player_idx: int) -> bool:
            if player_idx == 0:
                return history.my_actions[round_idx]
            else:
                return history.opponent_actions[round_idx, player_idx - 1]
        punishment_counters = dict()
        for opponent_idx in range(1, n):
            rounds_defected = []
            for round_idx in range(t):
                act = player_action(round_idx, opponent_idx)
                if act is False:
                    rounds_defected.append(round_idx)
            for r_defect in rounds_defected:
                start_punish = r_defect + 1
                end_punish = r_defect + punishment_duration
                if start_punish <= t <= end_punish:
                    rounds_left = end_punish - t + 1
                    if opponent_idx not in punishment_counters or punishment_counters[opponent_idx] < rounds_left:
                        punishment_counters[opponent_idx] = rounds_left
        if punishment_counters:
            return Action.D
        return Action.C