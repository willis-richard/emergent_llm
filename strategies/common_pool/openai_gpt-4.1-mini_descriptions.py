"""
Strategy descriptions for CommonPoolDescription.

Generated with:
- Provider: OpenAI
- Model: gpt-4.1-mini
"""


description_COOPERATIVE_1 = '''
Here is a cooperative strategy tailored to the Common Pool Resource Game as specified. The design emphasizes sustainable resource use to maximize group payoffs and enforce cooperation by punishing defection, while adjusting behavior as the game progresses.

---

# Cooperative Strategy: "Sustained Cooperation with Conditional Punishment"

## Intuition

- **Goal:** Maintain the common pool stock near capacity by everyone cooperating to consume moderately.
- **Cooperate:** Consume **C** = S/(2n) (half-share per player) to ensure long-term sustainability and fair payoffs.
- **Detect Defections:** If any player defects (consumes more), reduce own consumption to punish and signal disapproval.
- **Recovery:** Resume cooperation if all players cooperate again.
- **Endgame:** In the last round, defect to maximize immediate payoff since no future punishment is possible.

---

## Decision Rules

### Round 1 (Initial Round)

- **Action:** Cooperate (C).
- **Reason:** Establish cooperation baseline.

### Rounds 2 to (r - 1) (Middle Rounds)

- **Observe:** Actions of all players in previous round.
- **If** all players cooperated in the previous round:
  - Play **Cooperate**.
- **Else** (if any player defected previously):
  - Play **Defect** as punishment for 1 round.
- **Note:** Punishment lasts only 1 round; if cooperation resumes by all in the following round, return to cooperating.

### Round r (Last Round)

- **Action:** Defect (D).
- **Reason:** No future rounds remain, so defecting maximizes immediate payoff.

---

## Notes on Implementation

- The strategy is **memory-1**: depends only on last round's full action profile.
- Punishment is **collective and temporary**.
- The punishment uses defection to reduce future stock and thereby reduce future payoffs of defectors.
- By punishing only one round, the strategy allows recovery and avoids endless cycles of retaliation.
- Cooperation yields stock near capacity, maximizing payoffs over repeated rounds.
- Punishment deters defection by reducing defectors' future payoffs more than immediate gain.

---

## Pseudocode

```python
def cooperative_strategy(history, round_number, n, r, capacity, current_stock):
    # history: list of tuples (actions_per_player) from previous rounds, e.g. [('C', 'C', 'D', 'C'), ...]
    # round_number: current round (1-based)
    # n: number of players
    # r: total rounds
    # capacity: max sustainable stock
    
    # Last round: defect to maximize payoff
    if round_number == r:
        return 'D'

    # First round: cooperate unconditionally
    if round_number == 1:
        return 'C'

    # From Round 2 to r-1:
    # Check previous round actions
    prev_actions = history[-1]  # tuple/list of actions in round (round_number - 1)
    
    # If all cooperated last round --> cooperate
    if all(action == 'C' for action in prev_actions):
        return 'C'
    else:
        # Punish defectors by defecting this round
        return 'D'
```

---

## Strategy Summary

| Round       | Condition                              | Action      | Reason                                                |
|-------------|--------------------------------------|-------------|-------------------------------------------------------|
| 1           | Initial round                        | Cooperate   | Start cooperative path                               |
| 2 to r - 1  | All cooperated last round            | Cooperate   | Maintain cooperation                                  |
| 2 to r - 1  | Any defection last round             | Defect      | Punish defectors to enforce cooperation              |
| r (last)    | Final round                         | Defect      | Maximize immediate payoff, no future punishment      |

---

## Alignment with Cooperative Mindset

- Prioritizes **maximizing overall group payoff** via sustainable harvesting.
- Uses **conditional punishment** to discourage exploitation.
- Allows forgiveness and recovery to avoid futile retaliation.
- Balances **long-term collective benefit** with **short-term incentives**.
- Exploits knowledge of final round to defect optimally, recognizing game-theoretic inevitability.

---

This strategy should perform well in tournaments against independent strategies, fostering sustained cooperation when others cooperate, and preventing long-term exploitation by defectors.
'''

description_COOPERATIVE_2 = '''
Here is a carefully designed cooperative strategy for the Common Pool Resource Game that respects the stated constraints and assumptions:

---

## Overview

The strategy aims to sustain the resource pool at a high level over most of the game, maximizing long-term joint payoffs by cooperating (playing **C**) to avoid depletion. It uses conditional cooperation with punishment to deter defection. Near the end of the game, it defections strategically to maximize last-round returns because there's no future to protect.

---

## Intuition

- **Cooperation** means each player chooses **C** (consume stock/(2n)), which is sustainable and keeps the common pool healthy.
- **Defection** consumes more (stock/n), which individually is better short-term but harms the resource.
- By monitoring others' actions, cooperate as long as **everyone cooperated in the previous round**.
- If anyone defects, punish by defecting in the next round to deter free-riding.
- After punishment, return to cooperation if others do so.
- In the **last round**, defect unconditionally to maximize personal payoff (no future retaliation possible).
- In the **first round**, cooperate to signal willingness.
- If the stock drops below a safe threshold due to any reason (e.g., earlier defection or initial low stock), defect until stock recovers to avoid getting exploited while others defect.

---

## Detailed Decision Rules

### Variables available at round t:
- Current round: `t`, with `1 ≤ t ≤ r`
- Stock at start of round: `S_t`
- Actions of all players in previous round `t-1` (except for t=1)
- Parameters: n, r, capacity

### Parameters for strategy:

- **Safe stock threshold**: `S_safe = capacity / 2` (avoid cooperating if stock below half capacity)
  - Rationale: When stock is low, cooperating can cause quick collapse; better to defect and "harvest what is left."
- **Punishment phase** flag: `punish_next = False` initially

---

### Pseudocode for Player i in round t:

```
Initialize:
  punish_next = False

At round t:

  if t == 1:
    # First round: start cooperatively
    action = C
    punish_next = False
    return action

  else if t == r:
    # Last round: Always defect (maximize your last payoff)
    action = D
    return action

  else:
    # Check previous round actions:
    prev_actions = actions_of_all_players_in_round(t-1)
    all_cooperated = (prev_actions == [C]*n)
    
    # Check current stock safe level
    if S_t < S_safe:
      # If stock low, defect to maximize short term gains (others likely defecting)
      action = D
      punish_next = False
      return action

    else:
      if punish_next:
        # Currently punishing defection from last round, defect once
        action = D
        # Reset punishment after punishing once
        punish_next = False
        return action

      else:
        if all_cooperated:
          # Everyone cooperated last round, so cooperate again
          action = C
          punish_next = False
          return action

        else:
          # At least one player defected last round,
          # start punishing by defecting once
          action = D
          punish_next = True
          return action
```

---

## Explanation of the Logic

- **Round 1:** Cooperate unconditionally to establish trust.
- **Rounds 2 to r-1:**   
  - If everyone cooperated last round and the stock is healthy (≥ capacity/2), cooperate again.
  - If anyone defected last round, punish by defecting once on your immediate next turn.
  - The punishment is just one round: if after punishing, others cooperate, you return to cooperation.
- **If stock is low (< capacity/2):**  
  - Defect to maximize immediate gains as sustainability may be compromised.
- **Last round:** Defect unconditionally to maximize immediate payoff since no future rounds remain.

---

## Cooperative Mindset Alignment

- The strategy starts and returns to cooperation whenever possible.
- It punishes defection to deter free-riders and protect the common pool.
- It uses the stock level as an objective signal to determine sustainability instead of blindly cooperating when the resource is depleted.
- It balances enforcing cooperation with flexibility to avoid endless punishment cycles.
- It exploits the last round logically, consistent with standard backward induction reasoning.

---

## Summary

| Situation                      | Action      | Reason                           |
|-------------------------------|-------------|---------------------------------|
| First round                   | Cooperate (C) | Signal cooperation              |
| Last round                   | Defect (D)  | Maximize last-round payoff      |
| Stock ≥ capacity/2 and last round all cooperated | Cooperate (C) | Sustain cooperation             |
| Stock ≥ capacity/2 and anyone defected last round | Defect (D) (punish) | Deter defection                |
| Stock < capacity/2            | Defect (D)  | Protect self, resource in danger|

---

This strategy should perform well in a tournament of unknown strategies by fostering cooperation, punishing defection to enforce restraint, and making logical last-round defections.
'''

description_COOPERATIVE_3 = '''
Here is a detailed cooperative strategy design for the Common Pool Resource Game under the given conditions and constraints.

---

## Cooperative Strategy: "Conditional Cooperation with Forgiveness and Endgame Adjustment"

### Intuition

- The **best group outcome** arises if **all players cooperate (C)** every round, which sustains the stock at capacity and yields a stable, positive payoff every round.
- Defection (D) increases immediate individual payoff but *depletes the stock faster*, leading to lower future payoffs for everyone.
- Since the game is finitely repeated with known number of rounds, *cooperation is sustainable via conditional trigger strategies*.
- The strategy must:
  - **Start cooperating** to encourage cooperation.
  - **Punish defection by defecting in response**, reducing payoff to defectors, but **forgive after one round** to allow return to cooperation (forgiveness encourages cooperation recovery).
  - **Adjust behavior in the last round** (endgame) by defecting unconditionally (no incentive to cooperate since no future rounds remain).
  
---

## Strategy Description and Decision Rules

Let:

- `t` = current round index ∈ {1, ..., r}
- `history` = full log of observed actions of all players in all previous rounds
- `defection_detected(t-1)` = True if any player defected (played D) in round t-1, else False

**Decision rules for player i in round t:**

1. **Round 1: Always Cooperate**
   - No history exists; start with cooperation to signal willingness to sustain the resource.

2. **Rounds 2 to r-1 ("Middle rounds"): Conditional Cooperation**
   - If **defection_detected(t-1) == False** (no one defected last round):  
     → Cooperate to maintain cooperation.
   - Else if defection was detected in the last round:  
     → Defect *once* to punish defection.
   - In round t, if in round t-1 you defected as punishment (responding to defection in t-2), and no new defectors appeared in round t-1, then forgive and return to cooperation.

   This is a "grim-trigger with forgiveness of 1 round" strategy.

3. **Round r (Last round): Defect**
   - No future rounds to enforce cooperation; rational to defect for immediate gain.

---

## Annotated Pseudocode

```python
def decide_action(t, history, n, r):
    """
    Decide action ('C' or 'D') for round t based on history.
    
    Parameters
    ----------
    t : int - current round (1-based)
    history : list of tuples - each tuple is (actions_this_round), actions_this_round is list of length n of 'C'/'D'
    n : int - number of players
    r : int - total rounds
    
    Returns
    -------
    action : str ('C' or 'D')
    """
    
    # Edge case: First round always cooperate
    if t == 1:
        return 'C'
    
    # Edge case: Last round always defect
    if t == r:
        return 'D'
    
    # Detect defection in previous round
    last_round_actions = history[t-2]   # zero-based indexing: t-1 is current round, so t-2 for last round
    defection_in_last_round = any(action == 'D' for action in last_round_actions)
    
    # Detect defection in round before last (for forgiveness tracking)
    if t > 2:
        two_rounds_ago_actions = history[t-3]
        defection_two_rounds_ago = any(action == 'D' for action in two_rounds_ago_actions)
    else:
        defection_two_rounds_ago = False
    
    # Your own last action (assuming player index i known externally)
    # For generic pseudocode, store your own last action externally in strategy state
    # Here, represented by last_action variable
    
    # Following rules:
    # - If no defection last round -> cooperate
    # - If defection last round -> punish by defecting this round
    # - If punished last round and no new defection last round -> forgive and cooperate this round
    
    # We assume strategy remembers own last action as a variable `last_action`
    
    # Implement forgiveness logic:
    # If defection in t-1, defect now (punish)
    # Else if punished (defected) in t-1, and no defection in t-1, cooperate now
    
    # Simplify to:
    # If defection_in_last_round == True:
    #     # Punish
    #     return 'D'
    # else:
    #     if last_action == 'D' and not defection_in_last_round:
    #         # Forgive and cooperate
    #         return 'C'
    #     else:
    #         # Cooperate
    #         return 'C'
    
    # Since pseudocode doesn't have memory, the strategy will store last action externally.
    # Here we focus on general logic.
    
    # Pseudocode assumes 'last_action' input managed by implementation
    
    # For clarity, suppose input includes last_action:
    
def cooperative_strategy(t, history, n, r, last_action):
    
    if t == 1:
        return 'C'
    
    if t == r:
        return 'D'
    
    last_round_actions = history[t-2]
    defection_in_last_round = any(action == 'D' for action in last_round_actions)
    
    if defection_in_last_round:
        # Punish
        return 'D'
    else:
        if last_action == 'D':
            # Forgive
            return 'C'
        else:
            return 'C'
```

---

## Summary of Properties

| Round          | Condition                             | Action           | Rationale                                 |
|----------------|------------------------------------|------------------|-------------------------------------------|
| 1              | No past info                       | Cooperate (C)    | Signal cooperation; build trust           |
| 2..r-1         | No defection last round            | Cooperate (C)    | Maintain cooperation regime                |
| 2..r-1         | Defection detected last round      | Defect (D)       | Immediate punishment to discourage defection |
| 2..r-1         | Previous round was punishment (D), no defection last round | Cooperate (C) | Forgive to restore cooperation             |
| r (last round) | Any                               | Defect (D)       | Endgame: exploit since no future enforcement |

---

## Why This Is Cooperative?

- It aims to **sustain maximum resource level** by mutual cooperation.
- It **punishes defections immediately** to discourage exploitation.
- It **allows quick recovery** by a single round of punishment followed by forgiveness, encouraging return to cooperation after mistakes or brief deviations.
- It **anticipates endgame** (last round) rational defection, so cooperates throughout except final round to maximize total returns.
- It uses only **observable past actions** — no communication or assumptions about norms beyond rational incentives.

---

## Handling Edge Cases

- **First round:** No history, thus starts by cooperating.
- **Last round:** Defects unconditionally to maximize last-round payoff.
- **If multiple defections occur repeatedly:** Keeps defecting while defections persist, punishing defectors to protect future stock.
- **If stock collapses due to defections:** Strategy responds by defecting to minimize losses and exploit remaining stock, but will return to cooperation if others resume cooperation.

---

If implemented by all players, the game will likely sustain high stock levels and superior long-run payoffs compared to persistent defection equilibria. This strategy balances cooperation incentives with credible punishment and forgiveness, maximizing collective and individual payoffs within the constraints of repeated play and no communication.

---

**This completes the cooperative strategy specification.**
'''

description_COOPERATIVE_4 = '''
Below is a cooperative strategy designed to sustain the common pool resource at a high level while maximizing long-term group payoffs. The strategy relies on conditional cooperation and punishment to discourage defection, without assuming explicit communication or coordination beyond observed actions.

---

## Strategy Name: **Conditional Cooperation with Gradual Punishment**

---

### Intuition

- **Cooperate initially** to build trust and preserve the stock.
- **Continue cooperating as long as everyone cooperated in the previous round** (i.e., full cooperation is observed).
- **If defection occurs**, punish defectors by defecting for a limited number of rounds; then return to cooperation.
- **In the last round, defect** to maximize final payoff (standard backward induction logic).
- By doing so, the strategy encourages maintaining stock at a high level, which maximizes long-run payoffs.
- The punishment deters defection but is finite to avoid endless cycles of retaliation.

---

### Detailed Decision Rules

**Notation:**

- \( t \): current round (1 to \( r \))
- \( r \): total rounds
- \( n \): number of players
- \( A_i^t \): action of player \( i \) in round \( t \)
- \( A_{-i}^t \): actions of other players in round \( t \)
- \( \text{Defectors}^t = \{ j \neq i : A_j^t = D \} \)
- \( \text{Cooperators}^t = \{ j \neq i : A_j^t = C \} \)
- \( P \): punishment length (e.g., 2 rounds)
- \( \text{PunishCounter} \): local counter of rounds left to punish
- Initially: \( \text{PunishCounter} = 0 \)

---

### Pseudocode

```
Initialize:
    PunishCounter = 0

For each round t = 1 to r:

    if t == r:
        # Last round: defect to maximize immediate payoffs (standard final-round logic)
        play D
        continue

    if PunishCounter > 0:
        # Currently in punishment phase
        play D
        PunishCounter = PunishCounter - 1
        continue

    # Not punishing, check last round actions (except t=1)
    if t == 1:
        # First round: cooperate to establish cooperation baseline
        play C
    else:
        # Check if all players cooperated in previous round
        if all players (including self) played C in round t-1:
            # Full cooperation last round → continue cooperating
            play C
        else:
            # Defection detected last round → trigger punishment
            PunishCounter = P - 1  # punish for P rounds including this one
            play D
```

---

### Explanation of Core Logic

1. **First round (t=1):** Cooperate — start with cooperative action to establish trust and maximize stock.

2. **Subsequent rounds (1 < t < r):**
   - If currently punishing, defect to penalize defectors.
   - Otherwise:
     - If previous round was full cooperation by all players, continue cooperating.
     - If any defection occurred in previous round, start a limited punishment phase by defecting for \( P \) rounds.

3. **Last round (t=r):** Defect — since no future rounds remain, maximize immediate payoff.

---

### Handling Edge Cases

- **Initial stock and capacities:** The strategy does not directly depend on stock levels, but maintaining cooperation helps keep stock high.
- **If other players never cooperate:** The strategy will fall into mutual defection after first detected defection, potentially lowering payoffs but punishes defection to signal willingness to cooperate if they switch.
- **If a player defects only occasionally:** Punishment phase will discourage intermittent defection.
- **If a player always cooperates:** Strategy rewards by cooperating indefinitely (except last round).
- **If all players use this strategy, cooperation and stock are sustained at high levels, maximizing payoffs.**

---

### Summary

| Round          | Condition                                  | Action         |
|----------------|--------------------------------------------|----------------|
| 1              | Always                                   | Cooperate (C)  |
| 2 to r-1       | If punishing phase active                 | Defect (D)     |
|                | Else if previous round was full cooperation | Cooperate (C)  |
|                | Else (defection detected)                  | Defect (D), start punishment of length \(P\) |
| r (last round) | Always                                   | Defect (D)     |

---

### Extensions (optional, can be omitted if complexity is undesirable)

- **Gradually reducing punishment length if repeated defections occur.**
- **Forgiveness mechanism:** If no defection detected during punishment, end punishment early.
- **More sophisticated triggers using observed changes in stock.**

---

This strategy strikes a balance between cooperation and deterrence and aligns with the cooperative mindset under the constraints of the game. It relies purely on observed history, requires no communication, and is robust to standard defection attempts.
'''

description_COOPERATIVE_5 = '''
Below is a cooperative strategy designed for the specified Common Pool Resource Game. It aims to maximize long-run payoffs via mutual cooperation, sustain the resource, and punish defection to discourage free-riding, within the constraints of perfect monitoring and no communication.

---

## Cooperative Strategy: “Conditional Cooperation with Forgiveness”

### Intuition

- **Goal:** Maintain the common stock at or near capacity by cooperating whenever possible.
- **Cooperation:** Consume conservatively (C) to sustain the resource.
- **Detection of Defection:** If any player defects (D), everyone punishes by defecting for a short period.
- **Forgiveness:** After the punishment phase, return to cooperation to allow rebuilding trust and stock.
- **Last Round:** Defection is incentive-compatible; cooperate until the last round (or defect in last round).
- **Repopulation:** Avoid collapse from defective cascades by limiting punishment length proportionally.

---

### Terminology

- **round t** ∈ {1, 2, ..., r}
- **History observables:** Actions of all players in previous rounds
- **Punishment length:** `p` rounds (e.g., 2 or 3 rounds)
- **Punishment timer:** Counts down rounds remaining in punishment phase

---

### Decision Rules

#### Initialization (round 1)

- **Action:** Cooperate (C) unconditionally.

#### For rounds 2 to r-1

1. **Defection detection:**  
   - Check previous round's history:
     - If **any player defected (D)** in round t-1, enter punishment phase.
     - Set punishment timer = p (constant, e.g., 3).
2. **Punishment phase:**
   - While punishment timer > 0:
     - Play Defect (D) to punish defectors.
     - Decrement punishment timer by 1 each round.
3. **Otherwise (no recent defectors):**
   - Play Cooperate (C) to sustain resource.

#### Round r (final round)

- Play Defect (D) — rational to maximize last round payoff (no future consequence).

---

### Additional Notes on the Strategy

- The **punishment phase** discourages unilateral defection by reducing the resource and individual payoffs temporarily.
- Choosing a **small punishment duration p** balances deterrence with resource sustainability.
- Returning to cooperation after punishment encourages repair and continued cooperation.
- The **first round cooperation** sets a baseline cooperative norm.
- **Defecting last round** takes advantage of the finite horizon.

---

### Pseudocode

```python
# Parameters:
# n = number of players
# r = number of rounds
# p = punishment length (e.g., 3)
punishment_timer = 0  # starts at 0

for t in range(1, r + 1):
    if t == 1:
        # Always cooperate first round
        action = 'C'

    elif t == r:
        # Last round: defect
        action = 'D'

    else:
        # Check if punishment is ongoing
        if punishment_timer > 0:
            action = 'D'
            punishment_timer -= 1

        else:
            # Check actions from round t-1
            if any_player_defected_in_round(t - 1):
                # Enter punishment phase
                punishment_timer = p - 1  # Punish this and next p-1 rounds
                action = 'D'
            else:
                # No recent defectors, cooperate
                action = 'C'
    
    play(action)
```

**Function** `any_player_defected_in_round(t)` returns True if any player played D in round t.

---

### Rationale and Behavior Summary

| Round          | Action        | Reason                                           |
|----------------|---------------|-------------------------------------------------|
| 1              | C             | Establish cooperation from start                |
| 2 to r - 1     | C or D        | Cooperate unless punishing detected defectors   |
| When defect detected | D (for p rounds) | Enforce punishment to dissuade defection         |
| After punishment | C            | Forgiveness phase to re-establish cooperation   |
| Round r (last) | D             | Rational exploitation of last round, no future  |

---

### Why This Strategy Aligns with Cooperation

- Cooperates whenever others cooperate, sustaining high joint payoffs.
- Implements credible punishment to deter opportunistic defection.
- Forgives after punishment, to allow recovery instead of perpetual war.
- Exploits last round but only then, preserving cooperation across majority of game.
- Does not require communication or coordination beyond punishment triggered by observed defections.

---

### Robustness to Opponents

- Against purely defectors: the punishment phase results in continuous D, no worse off than unconditional defection.
- Against other cooperators: sustains cooperation indefinitely, preserving resource and payoffs.
- Against mixed strategies: punishment discourages defection and encourages return to cooperation.

---

This strategy is standard but effective in repeated common-pool resource dilemmas with perfect monitoring and finite horizon, balancing incentives to cooperate and punish to maximize collective welfare and individual payoffs.
'''

description_COOPERATIVE_6 = '''
Below is a cooperative (group-beneficial) strategy design aimed at sustaining the common pool resource stock, preserving cooperation, and mitigating incentives to defect, conditional only on observed play history. This will maximize long-term total payoffs given the game dynamics and the information constraints.

---

## Intuition and high-level overview

- **Cooperation** means all players choose **C** to consume only stock/(2n), which supports sustainable stock dynamics and higher long-run payoffs.
- **Defection** means consuming stock/n, which yields a higher immediate payoff but risks rapid stock depletion and future losses.
- The strategy seeks to:
  1. Start by cooperating.
  2. Continue cooperating as long as *all* players cooperated in the previous round.
  3. Punish observed defection by switching to defection for a limited number of rounds.
  4. Return to cooperation after the punishment to allow for cooperation re-establishment.
- The **punishment phase** discourages defection by reducing the defector’s future payoffs, but the strategy allows forgiveness to maintain cooperation incentives.
- On **last round**, the strategy cooperates, as defecting benefits are not countered and social welfare is not restored; however, since others may defect last round, cooperating last round is still a "goodwill" action to maintain reputations in tournaments.

---

## Formal Strategy Description and Decision Rules

**Parameters:**

- `punishment_length` = 1 (can be tuned; one round punishment after defection is minimal but effective in repeated games)
- `r`: total rounds
- `t`: current round (1 ≤ t ≤ r)

**Internal state variables:**

- `punishment_timer` starts at 0; counts down punishment rounds before returning to cooperation.
- `last_round_defected` boolean to indicate if any player defected last round.

---

### Decision rules for player i at round t:

```
If t == 1:                   # First round
    Action_i = C             # Cooperate unconditionally to start trust.

Else if punishment_timer > 0:
    Action_i = D             # Punish by defecting when in punishment phase.
    punishment_timer -= 1

Else:                       # Not in punishment phase
    Observe actions of all players in round t-1:
        If all players cooperated in round t-1:
            Action_i = C     # Continue cooperation.
        Else:
            # Defection observed in previous round --> trigger punishment
            punishment_timer = punishment_length
            Action_i = D

# On last round:
If t == r:
    Action_i = C             # Cooperate in last round regardless.
```

---

### Notes on Observations and Triggers:

- "All players cooperated" means all chose `C` in previous round.
- If at least one defection was observed in the previous round from any player, trigger punishment for `punishment_length` rounds.
- The punishment phase is collective defection: punishers defect simultaneously for `punishment_length` rounds.
- After punishment phase ends, reset to trust and cooperate.

---

## Justification

- Starting with cooperation builds a baseline cooperative outcome.
- Punishing defections swiftly deters unilateral exploitation.
- Punishment length = 1 balances deterrence and forgiving nature to re-establish cooperation.
- Cooperating on last round signals goodwill, avoids needless defection escalation (typical for finitely repeated games with no future).
- Strategy is simple, transparent, relies only on observable actions.
- Compatible with multiple players because it identifies defections at group-level, not player-specific.
- Promotes sustainable stock dynamics by slowing depletion and allowing regrowth.
- Maximizes long term payoffs collectively and individually under uncertainty about others.

---

## Pseudocode

```python
# Initialization
punishment_timer = 0

for t in 1 to r:
    if t == 1:
        action = 'C'  # First round cooperate

    elif punishment_timer > 0:
        action = 'D'  # Punishment phase defect
        punishment_timer -= 1

    else:
        # Check previous round actions of all players
        if all previous_actions == 'C':
            action = 'C'  # Continue cooperation
        else:
            # Defection detected -> trigger punishment
            punishment_timer = 1
            action = 'D'

    # Override: cooperates in last round unconditionally
    if t == r:
        action = 'C'

    play action
```

---

## Summary

- **Start** by cooperating.
- **Cooperate subsequently** if no defection observed.
- **Defect for 1 round** immediately after observing any defection (punishment).
- **Return to cooperate** after punishment.
- **Always cooperate in the last round**.
- Use **only observed past actions** to decide (no signals or assumptions).
- This strategy’s goal: stabilize cooperation, preserve stock, maximize group and individual payoffs.

---

**This "conditional cooperation with immediate punishment and quick forgiveness" strategy is a canonical cooperative norm suited for repeated CPR games under the specified conditions.**
'''

description_COOPERATIVE_7 = '''
Below is a detailed, cooperative strategy designed to maximize the long-term benefit of all players by maintaining the common pool's sustainable stock and punishing defections to incentivize cooperation. The strategy uses the observable past actions to detect defections and retaliate accordingly, but always returns to cooperation to avoid permanent breakdown.

---

## Cooperative Strategy: "Sustained Reciprocity with Forgiveness"

### Intuition

- **Goal:** Sustain the common stock close to capacity to maximize per-round payoffs for all.
- **Cooperation:** Always cooperate unless defectors have been observed.
- **Defection Detection:** If any player defected in the previous round, punish by defecting once.
- **Forgiveness:** After one punishment round, return to cooperation to allow recovery and discourage endless retaliation.
- **First round:** Cooperate to signal intent to cooperate.
- **Last round:** Defect to maximize immediate payoff since no future rounds remain.

---

### Detailed Decision Rules

Let:

- \( t \) = current round, \( 1 \leq t \leq r \)
- Observe all players' actions \( A^{t-1} = (a_1^{t-1}, ..., a_n^{t-1}) \) in previous round \( t-1 \)
- \( a_i^t \in \{C, D\} \)

Define:

- **Defection detected:** \( \exists i \in \{1,...,n\} : a_i^{t-1} = D \)
- **Punishment flag:** a boolean state memory that notes if current round is a punishment round

---

### Algorithm / Pseudocode

```python
# Initialize state variables
punishment_round = False  # Tracks if current round is punishment round

for t in 1 to r:

    if t == 1:
        # First round: Cooperate to build trust
        play_action = C
        punishment_round = False

    elif t == r:
        # Last round: Defect to maximize one-shot payoff; no future punishment
        play_action = D

    else:
        # Intermediate rounds

        # Check previous round for defections
        if punishment_round:
            # This round is punishment round, so punish by defecting
            play_action = D
            punishment_round = False  # reset punishment flag after punishing once

        else:
            # Not in punishment round
            if any(player_action == D for player_action in A^{t-1}):
                # Defection detected previous round -> punish this round
                play_action = D
                punishment_round = False  # This round is the punishment round (current round)
                # But since we only set punishment_round = False here, actually we want to set it True before round
                # Correction below
            else:
                # No defection detected recently, cooperate
                play_action = C

        # Correction in logic:
        # The punishment flag signals that we are in a punishment round,
        # so it must be set when a defection is detected and reset after punishment.

    # Update punishment_round state before next round:
    # Set punishment_round to True if defection detected in last round
    if t < r:  # No punishment needed last round
        if any(player_action == D for player_action in A^{t}):
            punishment_round = True
        else:
            punishment_round = False

    # Submit play_action

```

Improved and corrected pseudocode with clearer state tracking:

```python
# State variable outside rounds:
punishment_round = False

for t in 1 to r:

    if t == 1:
        # First round: cooperate
        action = C
        punishment_round = False

    elif t == r:
        # Last round: defect (no future rounds to worry about)
        action = D

    else:
        if punishment_round:
            # Punish defectors
            action = D
            punishment_round = False  # punishment executed, reset flag
        else:
            # If no punishment underway, cooperate
            action = C

    # After choosing action for this round, observe next round's past actions (in actual game, only known after round ends)
    # Here we simulate punishment_round update for next round:
    if t < r:
        # After round t finishes, observe actions chosen by all players in round t
        # If any player defected this round, schedule punishment for next round
        if any(player_action == D for player_action in A^{t}):
            punishment_round = True
        else:
            punishment_round = False

    # Play action in round t
```

---

### Summary of Behavior

| Round       | Condition                          | Action            |
|-------------|----------------------------------|-------------------|
| Round 1     | Always                          | Cooperate (C)     |
| Last round (r)  | Always                          | Defect (D)        |
| Intermediate rounds | If punishment_round == True     | Defect (D) (punishment) |
| Intermediate rounds | Else                        | Cooperate (C)     |

- **Punishment round** is triggered if any defection was observed in the previous round.
- After punishing once, strategy returns to cooperate next round (forgiveness).
- If no defections observed, continue cooperating indefinitely.
- Last round is an exception where defecting maximizes immediate gain as no future reprisals are possible.

---

### Justification and Cooperative Mindset

- **Maintains stock sustainability:** Cooperating keeps per-player consumption low, allowing the stock to regenerate close to capacity, maximizing long-run payoff to all.
- **Punishes defectors:** Defectors who overharvest reduce stock and create incentive for others to defect. Punishment reduces their short-term gains, discouraging defection.
- **Forgiveness after punishment:** Avoids endless cycles of retaliation, allowing the group to restore cooperation and sustain resource.
- **First round cooperation:** Signals willingness to cooperate, sets cooperative norm.
- **Last round defection:** Rational exploitation only when no future cooperation can be enforced (standard in finitely repeated games).

---

### Notes

- **No explicit communication or agreements:** Strategy infers others’ intentions from observable actions, requiring no side-channels.
- **Handles arbitrary opponent mix:** If others defect from start, you punish and try to steer outcome back to cooperation.
- **Robust across parameters:** Works for any \( n \), \( r \), and \( capacity \) values as long as game structure is maintained.

---

If desired, a simpler "grim trigger" variant (always defect forever after one defection) could be designed but is less forgiving and can degrade outcomes if errors/misinterpretations occur. The above strategy balances deterrence and cooperation effectively.

---

Please let me know if you want a more formal formalization or an alternative design!
'''

description_COOPERATIVE_8 = '''
Here is a cooperative strategy designed for the described common pool resource game. It is intended to promote sustainability of the resource and maximize collective long-term payoffs, while being robust to possible defections by others.

---

## Intuition

- Mutual cooperation (all C) sustains the stock near capacity, yielding moderate but stable payoffs each round.
- Defection yields a higher immediate payoff but risks rapid depletion and long-term ruin.
- The growth function favors moderate consumption: if everyone cooperates, the stock regenerates fully.
- Because players cannot communicate or coordinate beyond observing actions, the strategy uses **conditional cooperation** with a simple, forgiving punishment phase to deter defection but allow recovery.
  
---

## Strategy Outline (Trigger / Conditional Cooperation with Forgiveness)

### At a high level:

- Start by cooperating (C).
- Monitor other players' actions each round.
- If everyone cooperated last round (all C), continue cooperating.
- If any defection (any D) detected last round, punish by defecting in this round.
- After **one round of punishment**, return to cooperation (forgiving).
- In the **final round**, defect to maximize immediate payoff regardless of prior history.

---

## Detailed Decision Rules

Let:

- `t` = current round, `t` in {1,...,r}
- `actions_{t-1}` = vector of all players' actions in previous round (for `t=1`, no history, so this is empty)
- `punish_next_round` = boolean flag, initially False

### At round 1 (t=1):
- Cooperate: choose C

### For rounds 2 to r-1 (t=2,...,r-1):

1. If `punish_next_round` is True:
   - Defect (D) this round to punish.
   - Then set `punish_next_round` = False (only punish for one round).
2. Else (not currently punishing):
   - If all other players **cooperated** in last round (`actions_{t-1}` all C):
     - Cooperate (C).
   - Else (any player defected last round):
     - Set `punish_next_round` = True (to punish next round).
     - Cooperate (C) this round (do not punish in same round as observing defection).

### At round r (last round):
- Defect (D) to maximize immediate payoff (no future rounds to sustain).

---

## Pseudocode

```python
# Initialize
punish_next_round = False

for t in range(1, r+1):
    if t == 1:
        action = 'C'
    elif t == r:
        action = 'D'
    else:
        if punish_next_round:
            action = 'D'          # Punish defectors
            punish_next_round = False
        else:
            if all_others_cooperated(last_round_actions):
                action = 'C'      # Continue cooperating if no defection observed
            else:
                punish_next_round = True  # Schedule punishment for next round
                action = 'C'      # Forgive one round before punishing

    execute_action(action)
    observe_all_actions()
```

Helper function:

```python
def all_others_cooperated(actions_last_round):
    # actions_last_round is a list of n actions including own
    # Check if all players (including self) played C last round
    return all(a == 'C' for a in actions_last_round)
```

---

## Rationale and Cooperation Alignment

- **Start cooperatively** to build trust.
- **Conditional cooperation** sustains the resource by punishing defection.
- **One-round delayed punishment** avoids mistaken retaliation or endless cycles—if others defect, you punish next round but continue cooperating this round to signal willingness to stay cooperative.
- **Single-round punishment** keeps punishments proportional and forgiving, allowing recovery and return to cooperation.
- **Defect in last round** to rationally maximize personal payoff since no future penalties apply.
- Observing all players' actions each round enables precise detection of defections.
- Since defectors gain more short-term but hurt the resource, this strategy balances incentives and deterrence.
- Forgiving approach allows players tempted to defect occasionally to return to cooperation without costly permanent punishment.
- Maximizes long-term group payoffs by sustaining stock near capacity over time.
  
---

## Edge Cases

- If some players **never cooperate**, this strategy punishes one round after each defection. Such players get punished repeatedly and earn less, incentivizing eventual cooperation.
- In the **first round**, no history exists, so cooperate as a signal of good faith.
- In the **last round**, defect unconditionally since there are no future rounds to consider.
- If the stock becomes depleted due to defections, cooperating yields low payoffs, but this strategy still cooperates when others cooperate to rebuild stock.
  
---

## Summary

| Round           | Condition                                   | Action                  |
|-----------------|---------------------------------------------|-------------------------|
| 1               | No history                                  | Cooperate (C)           |
| 2..r-1          | Punish flag = True                          | Defect (D), then clear punish flag |
| 2..r-1          | Punish flag = False and all cooperated last round | Cooperate (C)           |
| 2..r-1          | Punish flag = False and at least one defection last round | Set punish flag True; Cooperate (C) this round   |
| r (last round)  | Any                                         | Defect (D)              |

---

This strategy captures the **spirit of cooperation** with clear conditional rules that respond to defections, encourage mutual sustainment of the common pool, and maximize overall group welfare under the information and strategic constraints of the game.
'''

description_COOPERATIVE_9 = '''
Below is a carefully designed cooperative strategy for the described Common Pool Resource game. It emphasizes sustainable cooperation, incentivizes reciprocation, and aims to preserve the resource for maximal joint payoffs.

---

## Core Intuition of the Strategy

- **Goal:** Maintain the common pool near its capacity by minimizing over-extraction, thus maximizing long-term joint payoffs (everyone earns more total payoff by cooperation).
- **Cooperation action (C):** consume stock/(2n), conservative extraction.
- **Defection action (D):** consume stock/n, aggressive extraction, which risks depletion.
- **Punishment:** If defectors are detected, punish them to deter defection, but allow return to cooperation if they resume cooperating.
- **Endgame treatment:** Gradually relax punishment near the final rounds because the incentive to conserve diminishes.

---

## Strategy Description: "Tit-for-Tat with Sustainable Trigger and Endgame Adaptation"

### Parameters of the strategy (fixed internally)

- `warningThreshold = 0.5` fraction of initial capacity  
  - (If stock falls below this, suspects unsustainable consumption)
- `maxPunishmentRounds = 2`  
  - Punish defectors by defecting for 2 rounds after defection observed
- `endgameStartRound = r - 2` (last 2 rounds)  
  - Near the end, forgive and cooperate more freely to maximize last-round payoffs

---

### Decision Rules

#### 1. **Round 1: Cooperate**

- **Reason:** No history. Trust others; establish cooperation baseline.

#### 2. **Round t (2 ≤ t < endgameStartRound): Detect and respond to defection**

- Observe actions of all players in round t-1.
- If **all other players cooperated last round (_all C_)** and stock >= warningThreshold × capacity, **cooperate**.
- If **any player defected last round (_any D_)**:
  - Enter a "punishment mode" targeting defectors
  - Punish defectors by defecting against them (consume more aggressively)
  - Continue punishment for up to `maxPunishmentRounds` rounds unless they resume cooperating
- If the stock fell below `warningThreshold × capacity` and defection observed, escalate punishment by defecting until stock recovers above threshold

**Punishment dynamics:**  
- Maintain a table/dictionary of players flagged as defectors with a countdown timer for their punishment rounds.
- Defect against players flagged as defectors, cooperate with others.
- If a punished player cooperates during punishment, remove their flag early (forgiveness).

#### 3. **Rounds t ≥ endgameStartRound (Last 2 rounds): Forgiveness and cooperation**

- Since the game will end soon:
  - Forgive past defections (reset all punishment flags).
  - Cooperate with all players regardless of past defection.
  - Focus on immediate payoff rather than sustainability.

---

## Handling Nature of Actions and Payoffs

- Since actions are simultaneous, we cannot condition on current-round actions.
- We rely on the previous round's actions and current stock level.
- Payoffs are known after each round and will be used to infer if a player defected.
- Because payoffs correspond exactly to C or D consumption (π_i = S/(2n) or S/n), detecting defections is straightforward from others’ payoffs.

---

## Pseudocode

```python
initialize:
    defectors = {}  # dictionary: player_id -> punishment_rounds_remaining
    warningThreshold = 0.5 * capacity
    maxPunishmentRounds = 2
    endgameStartRound = r - 2

def decide_action(round_number, current_stock, history):
    # history: list of (actions, payoffs) from previous rounds

    if round_number == 1:
        # No history, cooperate
        return 'C'

    # In rounds with history:
    last_actions, last_payoffs = history[-1]

    # Identify defectors in last round by examining their payoffs vs expected payoff if they cooperated
    stock_last = ... # inferred from calculation or stored
    # Threshold payoff for C and D:
    payoff_if_C = stock_last / (2 * n)
    payoff_if_D = stock_last / n

    newly_detected_defectors = set()
    for player_i, payoff_i in enumerate(last_payoffs, start=1):
        if payoff_i >= (payoff_if_C + payoff_if_D) / 2:
            # Closer to D payoff, mark as defector
            newly_detected_defectors.add(player_i)

    # Update defectors dict
    for d in list(defectors.keys()):
        defectors[d] -= 1
        if defectors[d] <= 0:
            defectors.pop(d)

    # Add new defectors with full punishment rounds
    for d in newly_detected_defectors:
        if d not in defectors:
            defectors[d] = maxPunishmentRounds

    # Endgame rounds
    if round_number >= endgameStartRound:
        # Reset all punishment, cooperate
        defectors.clear()
        return 'C'

    # Check stock threshold
    if current_stock < warningThreshold:
        # If stock low and someone defected, defect to punish or preserve remaining stock
        if defectors:
            # Defect this round as a response
            return 'D'
        else:
            # Stock low but no defectors => cooperate to try to restore stock
            return 'C'

    # Normal rounds: cooperate unless this player is punishing someone
    # Cooperate if not in punishment mode
    # Since strategy is symmetric, decide whether to defect to punish defectors or cooperate otherwise

    # If we are the punisher against some defectors, defect to punish them
    # Defecting harms common pool, so only defect if punishing
    if defectors:
        # Only defect if punishing opponent defectors—
        # but action is simultaneous; choose defect always in punishment phase to signal disapproval
        # (Assuming no ability to defect selectively against some players)
        return 'D'

    return 'C'
```

---

## Summary of the Strategy

| Round          | Condition                            | Action                                            |
|----------------|------------------------------------|--------------------------------------------------|
| 1              | No history                         | Cooperate                                        |
| Early rounds   | No defect detected & stock is healthy | Cooperate                                        |
| Early rounds   | Defection detected in last round    | Defect (punish), for `maxPunishmentRounds`       |
| Stock low      | Stock < warningThreshold & defector(s) exist | Defect (extending punishment)                      |
| Stock low      | Stock < warningThreshold & no defectors | Cooperate (to help stock recover)                  |
| Last 2 rounds  | Endgame                             | Reset all punishments, cooperate for best payoff |

---

## Why This Strategy Is Cooperative?

- It **starts with cooperation**, signaling trust.
- It **punishes defections strongly but temporarily**, discouraging free-riding.
- It **forgives and tries to return to cooperation** when those punished resume cooperation.
- It **avoids over-punishment**, which could drive resource collapse.
- It **prioritizes resource sustainability by monitoring stock level**.
- It **optimizes for endgame payoffs** by cooperating at the end.
- It makes **no assumptions about others’ strategies beyond game history**.

---

If implemented, this strategy tends to maintain the stock near capacity (as cooperation yields stock recovery every round when done collectively), maximize all players' payoffs over repeated rounds, and punish defectors to enforce cooperation. It thus aligns well with the cooperative mindset required.
'''

description_COOPERATIVE_10 = '''
Here is a carefully designed cooperative strategy for the Common Pool Resource Game that aligns with a cooperative mindset, optimizes long-term group payoffs, and handles edge cases systematically.

---

### Intuition and Goals

- **Cooperation (C)** means each player consumes a smaller share, enabling the common stock to replenish and maintain sustainability.
- **Defection (D)** yields larger immediate payoffs but quickly depletes the stock, harming everyone in the long run.
- Since the game is repeated and players observe all actions each round, the strategy aims to:
  - Maintain cooperation as long as everyone cooperates,
  - Detect and respond to defections to discourage exploitation,
  - Allow for forgiveness to resume cooperation,
  - Adjust behavior near the end of the game where incentives to defect are higher.

---

### Strategy Overview

**Name:** Conditional Cooperative Sustainer (CCS)

**Key idea:**  
Start cooperating. If any defection is detected in the past round, punish by defecting once. After punishing, return to cooperation to encourage restoration of mutual cooperation. In the **final round**, defect to maximize immediate payoff (due to no future repercussions). If the stock falls too low (near depletion), defect to secure remaining payoffs (everyone defecting anyway).

---

### Decision rules (per round t)

- **Round 1: Cooperate**  
  Start by cooperating to build trust and sustain the stock.

- **Rounds 2 to r-1: Conditional cooperation/punishment**  
  1. Observe actions of all players in round t-1.
  2. If *any player* defected in round t-1, then **Defect** this round (punishment).
  3. Else (no defection last round), **Cooperate** this round.

- **Round r (last round): Defect**  
  No future rounds remain, so defect to maximize immediate payoff.

- **Stock emergency rule (any round): If stock ≤ threshold, defect**  
  Define a low-stock threshold to avoid cooperating in near-collapse conditions that would leave you with tiny payoffs. For example, threshold = capacity / (4 * n) (a small fraction of capacity proportional to group size).  
  Once the stock falls to or below this threshold, immediately defect to maximize immediate payoff since cooperation is unlikely to be restored.

---

### Rationale

- **Nice and forgiving:** Start cooperating and return to cooperation after punishing a detected defection.
- **Retaliatory:** One-round punishment to dissuade defection.
- **Last round defection:** Standard backward induction dictates defecting in the last round, as no future retaliation exists.
- **Stock-awareness:** Protects payoff when the resource is almost depleted and cooperation is futile.

---

### Pseudocode

```python
def CCS_strategy(t, r, n, capacity, stock, history):
    """
    t: current round (1-indexed)
    r: total rounds
    n: number of players
    capacity: resource capacity
    stock: current stock level before actions this round
    history: list of dicts for rounds 1 to t-1; each dict maps player_id to action 'C' or 'D'
    
    Returns: action 'C' or 'D' for this round
    """
    # Parameters
    low_stock_threshold = capacity / (4 * n)
    
    # Last round defect
    if t == r:
        return 'D'
    
    # Stock low emergency defect
    if stock <= low_stock_threshold:
        return 'D'
    
    # First round cooperate
    if t == 1:
        return 'C'
    
    # Check if any player defected in previous round
    previous_actions = history[t - 2]  # zero-indexed list
    if any(action == 'D' for action in previous_actions.values()):
        # Punish by defecting this round
        return 'D'
    else:
        # No defection last round, cooperate
        return 'C'
```

---

### Additional notes

- This strategy relies exclusively on publicly observed history of actions.
- It never defects first, starting with cooperation.
- Punishes defectors only with one round of defection, to avoid endless retaliation cycles.
- The threshold for low stock is somewhat arbitrary but conservative enough to trigger defect once resource is dangerously depleted.
- Last round defect is standard in finite repeated games with no terminal rewards other than round payoffs.
- This strategy hopes to maximize joint profits over most of the rounds by sustaining the stock through cooperation and making defection unprofitable via retaliation.

---

### Summary

| Condition                                   | Action     |
|---------------------------------------------|------------|
| Round 1                                     | Cooperate  |
| Round r (last round)                        | Defect     |
| Stock ≤ low_stock_threshold (any round)    | Defect     |
| Any defection detected in previous round   | Defect     |
| Otherwise                                   | Cooperate  |

---

This **Conditional Cooperative Sustainer (CCS)** strikes a balance between being cooperative, retaliatory, forgiving, and aware of the resource dynamics — making it a robust cooperative strategy in this Common Pool Resource Game.
'''

description_COOPERATIVE_11 = '''
Below is a carefully designed **Cooperative Strategy** for the given common pool resource repeated game that fits all constraints and leverages the publicly observable history of actions and stock levels to promote cooperation. The strategy focuses on mutual cooperation and punishing defection to sustain the common pool stock.

---

## Cooperative Strategy Overview

### Intuition
- Cooperate initially to build trust and maximize long-term payoffs via sustainable exploitation.
- Punish defections by defecting temporarily to deter free-riding.
- Forgive after punishment to restore cooperation, aiming for a stable cooperative equilibrium.
- On the last round, defect to maximize immediate payoff since no future rounds exist.
- Always monitor stock level and past actions to decide whether cooperation is sustainable.

---

## Decision Rules

Let:
- \( t \in \{1, 2, ..., r\} \) be the current round,
- \( H_{t-1} \) be the history of all players' actions up to round \( t-1 \),
- \( S_t \) be the current stock available at the start of round \( t \),
- \( \text{DefectedLastRound} = \) true if any other player defected in round \( t-1 \),
- \( \text{PunishmentRounds} = \) fixed number of rounds to punish defections (suggest \(=1\)),
- \( \text{InPunishmentPhase} = \) true if currently in punishment phase,
- \( \text{PunishmentStartRound} \) records the round when punishment started.

---

## Behavior Summarized

| Round Condition                   | Action                        | Reasoning                           |
|---------------------------------|-------------------------------|-----------------------------------|
| \( t = 1 \)                     | Cooperate (C)                 | Build cooperation baseline        |
| \( 1 < t < r \) and no defection seen lately | Cooperate (C)                 | Sustain cooperation               |
| \( 1 < t < r \) and defection detected last round | Punish by defecting (D) for 1 round | Deter defectors                   |
| \( t = r \)                     | Defect (D)                   | One-shot final-round temptation   |
| Stock extremely low (e.g., \( S_t < \frac{capacity}{4} \)) | Defect (D) to maximize immediate payoff | Stock too depleted for cooperation|

---

## Pseudocode

```python
def cooperative_strategy(t, r, n, capacity, S_t, history, punishment_info):
    """
    Parameters:
      t: current round (1-based index)
      r: total rounds
      n: number of players
      capacity: max stock
      S_t: stock available before consumption at round t
      history: list of tuples of actions for all players in rounds 1..t-1
           Example: history[round-1] = [a_1, a_2, ..., a_n]
      punishment_info: dictionary with keys:
           - 'in_punishment_phase': bool
           - 'punishment_start_round': int or None

    Returns:
      action: 'C' or 'D'
      updated_punishment_info: updated dictionary
    """

    # Thresholds and parameters
    PUNISHMENT_LENGTH = 1
    STOCK_LOW_THRESHOLD = capacity / 4  # arbitrary threshold to detect severe depletion

    # Initialization
    in_punishment_phase = punishment_info['in_punishment_phase']
    punishment_start = punishment_info['punishment_start_round']

    # Helper: detect if any other player defected in the last round (except self)
    def defected_last_round():
        if t == 1:
            return False
        last_round_actions = history[t-2]  # zero-indexed
        # This player's index is unknown to this strategy snippet,
        # but assume the strategy is symmetric, so consider any defect by others:
        # In implementation, treat self's action controlled by this function,
        # so only other players matter:
        # Here we check if any action other than 'C' in last round by others.
        # Since player index unknown here, assume player implemented separately.
        # For pseudocode, let’s assume detecting any defection by others.
        return any(a == 'D' for a in last_round_actions)

    # Round 1: always cooperate
    if t == 1:
        action = 'C'
        updated_info = {'in_punishment_phase': False, 'punishment_start_round': None}
        return action, updated_info

    # Round r (last round): defect
    if t == r:
        action = 'D'
        updated_info = {'in_punishment_phase': False, 'punishment_start_round': None}
        return action, updated_info

    # If stock too low, defect to maximize payoff
    if S_t < STOCK_LOW_THRESHOLD:
        action = 'D'
        updated_info = {'in_punishment_phase': False, 'punishment_start_round': None}
        return action, updated_info

    # Manage punishment phase
    if in_punishment_phase:
        # Check how long since punishment started
        if t - punishment_start <= PUNISHMENT_LENGTH:
            # Continue punishing
            action = 'D'
            updated_info = punishment_info
            return action, updated_info
        else:
            # Punishment phase over, forgive
            action = 'C'
            updated_info = {'in_punishment_phase': False, 'punishment_start_round': None}
            return action, updated_info

    # Not in punishment phase: check if defection by others last round
    if defected_last_round():
        # Start punishment phase
        action = 'D'
        updated_info = {'in_punishment_phase': True, 'punishment_start_round': t}
        return action, updated_info

    # Otherwise, cooperate
    action = 'C'
    updated_info = {'in_punishment_phase': False, 'punishment_start_round': None}
    return action, updated_info
```

---

## Explanation and Rationale

1. **First Round Cooperation:** Start with cooperation to set a positive precedent.
2. **Last Round Defection:** Since no future rounds exist, defecting guarantees maximal payoff on last round.
3. **Punishment for Defection:** On observing any defection by others, punish by defecting for a fixed short duration (1 round). This deters defectors by lowering their expected payoff if they defect.
4. **Forgiveness:** Return to cooperation after punishment to allow the system to restore cooperation without permanent breakdown.
5. **Low Stock Handling:** If stock falls below a critical threshold, defect to maximize terminal payoff since sustainability is compromised and cooperation yields little future benefit.
6. **Sustainability Focus:** By cooperating whenever possible and punishing defections, this strategy supports maintaining stock near the sustainable capacity level, thus enhancing long-term payoffs for all players.

---

## Summary

This strategy is a **trigger-style conditional cooperation** scheme with forgiveness and final-round defection. It is:

- Simple and effective,
- Does not require explicit communication,
- Compatible with perfect information and common knowledge,
- Designed to promote sustainability and cooperation,
- Ready to respond to defection maintaining strategic credibility.

You can tune parameters like `PUNISHMENT_LENGTH` and `STOCK_LOW_THRESHOLD` to optimize performance in your specific tournament environment.

---

If you would like, I can help with expansions or variations on this plan!
'''

description_COOPERATIVE_12 = '''
Below is a cooperative strategy designed to maximize long-term collective payoffs by maintaining the common pool resource at high levels through mutual cooperation, while including a simple punishment mechanism to discourage defection. It respects the constraints and assumptions of the game.

---

## Cooperative Strategy: **"Conditional Mutual Cooperation with Gradual Punishment"**

### Intuition
- **Cooperate early and by default:** Start by cooperating (C) to maintain the resource.
- **Detect defections:** If any player defects (D) in the previous round, treat this as a sign of uncooperativeness.
- **Punish defectors by defecting once:** Respond with defection in the next round to discourage defection.
- **Forgive and return to cooperation:** After one punishment round, return to cooperation if no further defections happen.
- **Endgame cooperation:** Cooperate in the last round regardless, since no future retaliation is possible, maximizing joint payoffs.

---

### Detailed Decision Rules

Let:

- \( t \in \{1, ..., r\} \) be the current round index
- \( A_i^{t} \in \{C, D\} \) be your action at round \( t \)
- \( A_{-i}^{t} = \{A_j^{t} | j \neq i\} \) be all other players’ actions at round \( t \)
- History of actions of all players up to round \( t-1 \) is known perfectly

---

### Rule 1: First Round  
- At \( t=1 \), play **C** unconditionally.

### Rule 2: For rounds \( 1 < t < r \)  
- **If any other player defected (played D) in round \( t-1 \):**  
  - Play **D** as punishment this round for one round only.
- **Else:**  
  - Play **C** (cooperate).

### Rule 3: Last round \( t = r \)  
- Play **C** unconditionally (endgame cooperation).

---

### Summary in Pseudocode

```
Initialize:
  round = 1

For each round t in 1 to r:
  if t == 1:
    action = C
  else if t == r:
    action = C
  else:
    if any player j ≠ i defected (D) in round t-1:
      action = D   # Punish once
    else:
      action = C   # Cooperate

  play action
```

---

### Features & Rationale

- **Sustains stock:** By cooperating in absence of defection, it consumes less stock (stock/(2n) per player), keeping the common pool maintained near capacity.
- **Discourages defection:** The threat of immediate punishment (defecting once) reduces temptation to defect repeatedly.
- **Extinguishes cycles:** The punishment is only one round, preventing endless retaliation spirals.
- **Endgame cooperation:** Avoids the “race to defect” at the last round by cooperating, maximizing collective payoff.
- **Simple and memory-light:** Only requires remembering previous round’s actions.

---

### Strategic Considerations

- Because defecting yields more short-term gain \( \frac{S}{n} \) than cooperating \( \frac{S}{2n} \), one-shot defectors may appear.
- The punishment round lowers their payoff in future rounds, deterring defection.
- Without communication, this is a simple tit-for-tat style strategy adapted for multiple players and dynamic stock.
- It treats all defectors equally — it does not single out defectors individually (no partial punish), which is simpler given simultaneous moves and no communication.
- Cooperating in the last round is cooperative, as no opportunity for retaliation exists, making it a credible commitment to cooperation.

---

This strategy is designed to be robust, simple, and aligned with cooperative principles under the common knowledge and perfect information conditions specified. It promotes joint welfare by sustaining the resource stock and discourages exploitation through contingent punishment.
'''

description_COOPERATIVE_13 = '''
Here is a cooperative strategy designed to maintain the sustainable common pool while maximizing collective payoffs over all rounds, balancing cooperation with conditional retaliation to discourage free-riding defectors.

---

## Strategy Name:
**Conditional Sustained Cooperation (CSC)**

---

## Intuition and Goals:
- Maintain the stock near capacity for as long as possible to maximize payoffs for all.
- Cooperate as default to sustain the resource.
- Defect only as a punishment if others defect, to discourage depletion.
- Return to cooperation if others do, encouraging trust.
- In the last round, defect to maximize personal payoff with no future cost.
- In early rounds, be patient and enforce cooperation before stock depletes.

---

## Decision Rules

Let:
- `t` = current round (1 ≤ t ≤ r)
- `S_t` = stock at beginning of round t
- `actions_{t-1}` = vector of all players’ actions in previous round
- `defection_threshold` = number of defectors tolerated before retaliation (set to 1 for strictness)
- `punishment_length` = 1 round (punish defectors by defecting once)
- `punishment_rounds_left` = number of punishment rounds remaining for current punishment (stateful)
- `defectors_last_round` = number of defectors in previous round (to trigger punishment)

### 1. First Round (t=1)
- Always **Cooperate**.
- Reasoning: No past history, establishing goodwill and maximally sustainable use.

### 2. Rounds 2 to r-1 (intermediate rounds)
- If currently in a punishment phase (`punishment_rounds_left > 0`):
  - **Defect** this round.
  - Decrement `punishment_rounds_left` by 1.
- Else (not punishing):
  - Observe previous round’s actions:
    - Count number of defectors in `actions_{t-1}`.
    - If number of defectors ≥ `defection_threshold`:
      - Enter punishment: set `punishment_rounds_left = punishment_length`.
      - Defect this round.
    - Else:
      - **Cooperate**.

- This means you quickly retaliate for any detected defection, and punish only one round to avoid escalation.
- If others return to cooperation in next round, you do too.

### 3. Last Round (t=r)
- **Defect** regardless of past.
- Reasoning: No future rounds means no incentive to sustain stock — maximize immediate payoff.

---

## Handling Edge Cases

- **Stock depletion below critical level:**
  - Even if stock `S_t` becomes low, follow the same rules.
  - Punish defectors; cooperate otherwise.
  - Since growth depends on stock remaining, cooperation boosts stock for next rounds (except last).
- **Multiple defectors:**
  - Punish immediately but only once per defection event to avoid endless cycles.
- **No communication:**
  - Use previous round actions as sole signal.
- **If all players defect at last round:**
  - Everyone maximizes last round payoff, no cooperation left.

---

## Pseudocode

```python
initialize:
  punishment_rounds_left = 0
  defection_threshold = 1
  punishment_length = 1

for t in 1 to r:
  if t == 1:
    action = "C"  # cooperate round 1

  elif t == r:
    action = "D"  # defect last round to maximize immediate payoff

  else:
    if punishment_rounds_left > 0:
      action = "D"
      punishment_rounds_left -= 1

    else:
      defectors_last_round = count_defectors(actions_{t-1})

      if defectors_last_round >= defection_threshold:
        punishment_rounds_left = punishment_length
        action = "D"  # start punishment
      else:
        action = "C"  # cooperate if no defection detected

  yield action
```

---

## Summary

| Round       | Action                     | Purpose                           |
|-------------|----------------------------|---------------------------------|
| 1           | Cooperate                  | Establish cooperation            |
| 2 to r - 1  | Cooperate unless defectors detected, then defect one round to punish | Sustain cooperation with conditional retaliation |
| r (last)    | Defect                     | Maximize single-shot gain        |

The strategy promotes sustainability and mutual cooperation by rewarding cooperation with cooperation and punishing defection promptly but leniently. The final-round defection complies with backward induction equilibrium logic.

---

This approach balances:

- **Cooperation** to maintain stock and maximize group long-term payoffs.
- **Punishment** to deter defection and discourage resource depletion.
- **Forgiveness** to return to cooperation after isolated defections.
- **Rational last-round play** to optimize personal payoff given no future.

Such a strategy should fare well in tournaments of independent strategies, encouraging cooperation but defending against exploiters.
'''

description_COOPERATIVE_14 = '''
Below is a cooperative strategy designed specifically to foster mutual cooperation in the Common Pool Resource Game, given the constraints and information described. This strategy aims to sustain the stock at a high level to maximize joint payoffs over all rounds, balancing incentive to cooperate with punishment for defection.

---

## Strategy Overview

**Core idea:**  
- Start by cooperating to build trust and preserve the resource.  
- Continuously monitor others’ actions to detect defection.  
- If anyone defects, punish by defecting for a limited number of rounds to discourage selfish behavior.  
- Transition back to cooperation if others do so, fostering recovery.  
- In the last round, defect to maximize immediate payoff (since no future repercussions).

This replicates a form of *Trigger Strategy* (e.g., Grim Trigger or Tit-for-Tat) adapted to a common pool resource dynamic.

---

## Decision Rules

### Terminology

- `round`: current round number (1 to r)
- `history`: list of previous rounds' actions by all players, including self
- `stock`: common pool stock at start of current round
- `defectors_detected`: a boolean flag indicating if any player defected in the previous round
- `punishment_rounds_left`: counter for how many rounds remain in punishment phase
- `punishment_duration`: fixed number of rounds for punishment (e.g., 2 rounds)
- `n`: total number of players
- `capacity`: maximum stock level

### Actions

- **Cooperate (C):** consume `stock/(2n)`
- **Defect (D):** consume `stock/n`

---

### Pseudocode

```python
initialize:
    defectors_detected = False
    punishment_rounds_left = 0
    punishment_duration = 2  # adjustable parameter

for each round t in 1 to r:

    if t == 1:
        # First round, start with cooperation
        action = C

    elif t == r:
        # Last round, defect to maximize immediate gain
        action = D

    else:
        # For rounds between 2 and r-1:

        # Check if punishment ongoing
        if punishment_rounds_left > 0:
            # Continue punishment by defecting
            action = D
            punishment_rounds_left -= 1

        else:
            # No ongoing punishment => check last round's history to see if any defection happened
            last_round_actions = history[t-2]  # zero-indexed list

            if any(action_other == D for action_other in last_round_actions if other_player != self):
                # Defection detected from other players in previous round
                defectors_detected = True
                punishment_rounds_left = punishment_duration - 1  # count this round’s punishment now, so reduce by one
                action = D  # start punishing immediately

            else:
                # No defection detected, cooperate
                defectors_detected = False
                action = C

    play(action)
```

---

## Explanation

- **Round 1:** Always cooperate to signal the intent to sustain the resource and get others on board. This promotes mutual trust.

- **Rounds 2 to r-1:**  
  - If no defection happened in the previous round, cooperate to sustain the resource.  
  - If any player defected in the previous round, respond by defecting for a *fixed short punishment period* (e.g., 2 rounds). This discourages defection by making it costly.  
  - After punishment, return to cooperating to allow recovery if defection stops.

- **Last round (round r):** Defect to maximize immediate payoff. Since there is no future round, future retaliation or reward is impossible; thus, defecting is individually optimal.

---

## Additional Remarks

- **Why short punishment?**  
  Infinite punishment (Grim Trigger) can be too harsh in a noisy environment or when mistakes happen. Short punishment allows forgiveness and makes cooperation sustainable even if occasional defections occur.

- **Why defect on detection of any defection?**  
  To punish defectors and prevent freeriding from being profitable.

- **No assumptions about others cooperating initially:**  
  The strategy tries to induce cooperation by starting cooperatively and punishing defection. Some independent strategies may also cooperate to maximize payoff; this strategy aligns with them.

- **Stock preservation motivation:**  
  By cooperating when all cooperate, the stock tends to sustain at maximum or near-maximum levels, yielding high joint payoffs over rounds.

---

## Summary

| Round       | Condition                         | Action    |
|-------------|---------------------------------|-----------|
| Round 1     | Always                          | Cooperate |
| Rounds 2–r-1 | If any defection last round → punish by defecting for `punishment_duration` rounds; else cooperate | C or D    |
| Round r     | Always defect (no future rounds) | Defect    |

---

This strategy is a disciplined cooperative approach balancing forgiveness and sanction, designed to maintain the resource and maximize total payoffs in the repeated Common Pool Resource Game.
'''

description_COOPERATIVE_15 = '''
Here is a detailed cooperative strategy for the Common Pool Resource Game, designed to foster cooperation, sustain the common resource, and maximize total payoffs over repeated rounds. The strategy uses a form of conditional cooperation with a forgiving punishment to incentivize mutual cooperation with minimal resource depletion.

---

### Intuition & Goals of the Strategy

- **Cooperate (C)** early and as long as others do, to maintain the stock near capacity, enabling sustainable payoffs.
- If others defect, **punish by defecting for a short, fixed period** to discourage over-consumption.
- After punishment, **return to cooperation to restore trust and the stock**, allowing resource regeneration.
- On the **last round**, defect to maximize immediate individual payoff (standard backward induction result in finitely repeated games with no communication).
- **First round** start cooperatively to signal cooperation.
- Keep track of others' actions to detect defection.
- The strategy is forgiving: punishes defection briefly, then forgives, assuming players will cooperate again.

---

### Key Parameters of the Strategy

- **Punishment length (p):** Number of rounds to respond by defecting after detecting defection. Choose small (e.g., p=1 or 2 rounds) to avoid excessive depletion.
- **History:** For each player, record their last chosen action.
- **State variables:** 
  - `punishing` (boolean): whether currently punishing
  - `punish_rounds_left` (integer): remaining punishment rounds

---

### Decision Rules: When to Cooperate and Defect

Let t be the current round number (1 ≤ t ≤ r).

**1. Round 1:**  
- Play C (cooperate) unconditionally to signal a cooperative stance.

**2. Intermediate rounds (1 < t < r):**

- **If currently punishing (punishing == True):**  
  - Play D for this round.  
  - Decrement `punish_rounds_left`.  
  - If `punish_rounds_left` == 0 after decrement, set `punishing = False`.

- **Else (not punishing):**  
  - If *any* other player defected (played D) in the previous round:  
    - Start punishment: `punishing = True`, `punish_rounds_left = p`, and play D this round.

  - Else:  
    - Cooperate (C).

**3. Last round (t = r):**  
- Defect (D) regardless of history to maximize final payoff (backward induction).

---

### Rationale per Round

- **Round 1:** No history available, so cooperate as a signal.
- **Rounds 2 to r-1:** Maintain cooperation unless defect detected last round, punish briefly by defecting.
- **Last round:** Defect for maximum unilateral gain, since no future rounds to sustain cooperation.

---

### Handling Edge Cases & Details

- **If multiple players defect in the same round:**  
  The strategy punishes defectors collectively by defecting for p rounds.

- **If the stock becomes very low:**  
  Punishing briefly instead of indefinitely helps avoid stock collapse.

- **If a player defects repeatedly:**  
  The strategy's punishment is limited (only p rounds), so persistent defectors can cause resource depletion; this cost acts as deterrence.

- **Perfect information & common knowledge:**  
  Because everyone observes all actions, the strategy can detect defections perfectly.

---

### Pseudocode

```python
def cooperative_strategy(t, r, n, capacity, S, history, punishing, punish_rounds_left, p=2):
    """
    Inputs:
        t: current round number (1-based)
        r: total rounds
        n: number of players
        capacity: max stock
        S: current stock
        history: list of dict of last round actions, e.g. [{'player': i, 'action': 'C' or 'D'} ...]
        punishing: bool, whether currently in punishment phase
        punish_rounds_left: int, remaining punishment rounds
        p: punishment length (default 2 rounds)
    
    Returns:
        action: 'C' or 'D'
        updated punishing, punish_rounds_left
    """

    if t == 1:
        # Round 1 - no history, cooperate to signal
        return 'C', False, 0
    
    if t == r:
        # Last round - defect to maximize payoff
        return 'D', punishing, punish_rounds_left
    
    # Check if currently punishing
    if punishing:
        # Continue punishing by defecting
        punish_rounds_left -= 1
        if punish_rounds_left == 0:
            punishing = False
        return 'D', punishing, punish_rounds_left
    
    # Not punishing, check history for defection last round
    opponents_actions = [entry['action'] for entry in history if entry['player'] != 'self']
    if 'D' in opponents_actions:
        # Defection detected, start punishing
        punishing = True
        punish_rounds_left = p - 1  # Counting this round as first punishment
        return 'D', punishing, punish_rounds_left
    
    # Otherwise cooperate
    return 'C', punishing, punish_rounds_left
```

- Here `'self'` denotes the current player, which would need to be filtered out when checking opponent actions.
- The strategy is symmetric. Multiple players running this strategy will maintain cooperation until deviation occurs.
- The parameter `p` (punishment length) can be tuned; 1 or 2 rounds is recommended.

---

### Summary: The Cooperative Strategy

| Round         | Condition                       | Action      | Notes                              |
|---------------|--------------------------------|-------------|----------------------------------|
| 1             | First round                    | Cooperate (C)   | Signal cooperation                |
| 2 ... r-1     | If punishing now               | Defect (D)      | Punish defectors briefly          |
| 2 ... r-1     | Else if anyone defected last round | Defect (D)  | Start punishment                  |
| 2 ... r-1     | Else                          | Cooperate (C)   | Maintain cooperation              |
| r (last round) | Always                       | Defect (D)      | Maximize final payoff             |

---

This strategy aligns with cooperative norms by maintaining the stock and payoffs for the group but incorporates calibrated punishment for defectors and rational backward induction defection in the last round. It is robust in a tournament against unknown opponent strategies under the game constraints and perfect information.

If you want, I can help you with alternative cooperative strategies or tuning suggestions!
'''

description_COOPERATIVE_16 = '''
Below is a cooperative strategy designed for the Common Pool Resource game specified. It aims to sustain the common pool optimally while discouraging defection through conditional cooperation. It balances payoff maximization, sustainability, and punishment to deter free-riding, without relying on communication or explicit coordination.

---

## Intuition and Rationale

- **Cooperation (C)** corresponds to low consumption per player, sustaining the stock.
- **Defection (D)** is higher consumption, yielding immediate higher payoff but threatening stock depletion.
- The growth function favors maintaining a mid-to-high stock level near capacity to keep long-term harvests maximal.
- Punishing defectors by defecting in subsequent rounds pressures them towards cooperation.
- Last round defecting is individually rational; thus, we use *"endgame cooperation"* with some forgiveness to sustain cooperation in earlier rounds.
- The strategy uses observed actions of all players (public info) to decide whether to cooperate.

---

## Strategy Description

**Parameters:**

- `n`: number of players
- `r`: total rounds
- `capacity`: stock capacity
- `t`: current round index (1-based)
- `S_t`: stock level at round t (observed before actions)
- `Hist`: game history of all players' past actions and payoffs

---

### 1. Initial Round (t = 1):

- Cooperate unconditionally.
- Rationale: Start by signaling willingness to cooperate, build trust since no prior info.

### 2. Intermediate Rounds (1 < t < r):

- **Decision Rule:** Cooperate if **all players cooperated in the previous round**.
- Else, defect as **punishment** for any observed defectors.
- Rationale: Maintain cooperation if everyone cooperated last round; punish otherwise to deter defection.

### 3. Last Round (t = r):

- Defect unconditionally.
- Rationale: The last round is a one-shot game; no incentives to cooperate here (no future penalties).

---

### 4. Handling Stock Levels:

- If **stock level falls below a critical threshold** (say, 50% of capacity), forgive one defection round to avoid collapse caused by accidental or isolated defectors.
- After punishment round, attempt return to cooperation if stock recovers.
- This prevents endless punishment cycles when stock is low.

---

### 5. Summary of Cooperation Conditions

| Round        | Condition to Cooperate                                                   | Else Defect (Punish)            |
|--------------|--------------------------------------------------------------------------|--------------------------------|
| t = 1        | Always cooperate                                                        | N/A                            |
| 1 < t < r    | If all players cooperated in round t-1, and stock > 50% capacity       | Defect                         |
|              | If stock ≤ 50% capacity, and last round was punishment, try cooperate  | Defect otherwise               |
| t = r        | Always defect                                                           | N/A                            |

---

## Pseudocode

```python
def cooperative_strategy(t, r, n, capacity, S_t, Hist):
    """
    t: current round (1-based)
    r: total rounds
    n: number of players
    capacity: max stock
    S_t: current stock before actions
    Hist: list of previous rounds [ (actions_round1), (actions_round2), ... ]
          where each actions_round is list of length n of 'C' or 'D'
    Returns: 'C' or 'D'
    """
    
    CRITICAL_THRESHOLD = 0.5 * capacity
    
    # Round 1: cooperate immediately
    if t == 1:
        return 'C'
    
    # Last round: defect unconditionally (endgame)
    if t == r:
        return 'D'
    
    last_actions = Hist[-1]  # actions in previous round
    
    # Check if all cooperated last round
    all_cooperated = all(a == 'C' for a in last_actions)
    
    # If stock is healthy, cooperate only if all cooperated last round
    if S_t > CRITICAL_THRESHOLD:
        if all_cooperated:
            return 'C'
        else:
            return 'D'
    else:
        # Stock low: apply forgiveness
        
        # Check if last round was punishment round (this agent defected to punish)
        # Assuming we have access to own action last round:
        my_last_action = last_actions[my_index]  # assuming strategy knows own index
        # If last round we punished (defected), try cooperating now to help recover
        if my_last_action == 'D':
            return 'C'
        else:
            # Otherwise, defect if any defectors present
            if all_cooperated:
                return 'C'
            else:
                return 'D'
```

---

## Key Features

- **Start friendly:** Cooperate at round 1 to build cooperation signal.
- **Reciprocal cooperation:** Continue cooperating only if everyone cooperated last round.
- **Defect to punish defectors:** Immediately defect if any player defected last round.
- **Forgiveness when stock low:** Prevents collapse by allowing cooperation attempt after punishment to recover stock.
- **Last round defection:** Exploit final round by defecting (best individual payoff, no future retaliation).
- **No external communication needed:** Fully relies on history and current stock.
- **Sustainable:** Encourages sustaining stock near capacity through mutual cooperation.
  
---

## Notes on Player Index / Self-Awareness

- The strategy requires knowledge of own index to check own past action.
- Alternatively, a player can assume its position given the tournament setup.
- If unavailable, forgive condition can be simplified or removed (be more strict).

---

This strategy balances cooperation incentives, punishment to discourage free-riding, and allows recovery from shocks, aligning with a cooperative mindset in repeated common pool resource dilemmas under perfect information and no communication constraints.
'''

description_COOPERATIVE_17 = '''
**Cooperative Strategy for the Common Pool Resource Game**

---

### High-Level Intuition

- The strategy aims to maintain the common pool near its sustainable **capacity** to maximize long-term, stable payoffs for all.
- **Cooperate (C)** to use the resource sustainably, conceding short-term gains from defection.
- **Punish defections** by defecting once to signal that over-consumption will not be tolerated.
- **Forgive** after the punishment round by returning to cooperation to resume sustainability.
- In the **last round**, defect to maximize immediate payoff as no future punishment is possible.
- The strategy relies only on **public observation of others’ actions** (which can be inferred from payoffs and stock changes).


---

### Decision Rules

Let:
- \( t \) = current round (1 to \( r \))
- \( S_t \) = stock at start of round \( t \)
- \( \text{history}_{t-1} \) = set of all players' actions in previous rounds
- \( n \) = number of players
- \( r \) = total rounds
- \( \text{defect_threshold} \) = minimal detectable defection (see below)
- \( \text{punishing} \) = boolean flag indicating if currently punishing

---

#### 1) Detecting Defection

Since actions are simultaneous and can only be inferred, defection detection uses **observed stock dynamics** and players’ payoffs from previous rounds:

- **Expected total consumption if all cooperate:** \( n \times \frac{S_{t-1}}{2n} = \frac{S_{t-1}}{2} \)
- **Expected stock after cooperation consumption:** \( S_{t-1} - \frac{S_{t-1}}{2} = \frac{S_{t-1}}{2} \)
- **Expected growth after cooperation:** \( 2 \times \frac{S_{t-1}}{2} \times \left(1 - \frac{S_{t-1}}{2 \times capacity}\right) \)
- **Expected new stock if all cooperate:** sum of the above.

If **observed stock** after round \( t-1 \) is *significantly lower* than expected cooperative stock (with some tolerance margin \(\delta\) to account for numerical/rounding variations), defecting has likely occurred.

---

#### 2) Action per Round

Pseudocode outline per player \( i \):

```python
def cooperative_strategy(t, S_t, S_prev, actions_prev, punish_flag):
    # Special case: Last round
    if t == r:
        # Defect to maximize final payoff (no future punishment)
        return 'D'
    
    # First round: cooperate (establish cooperation)
    if t == 1:
        return 'C'
    
    # Detect defection in previous round using stock and inferred consumption
    expected_stock_after_coop = compute_expected_stock(S_prev, capacity, n)
    margin = capacity * 0.01  # 1% tolerance
    
    if S_t < expected_stock_after_coop - margin:
        # Defection detected last round
        punish_flag = True
    
    if punish_flag:
        # Punish by defecting once
        punish_flag = False  # Reset after punishment round
        return 'D'
    
    # Otherwise, cooperate
    return 'C'
```

---

#### 3) Explanation

- **Round 1:** Cooperate to initiate trust and maximize stock.
- **Rounds 2 to r-1:**
  - Monitor stock and compare with expected stock after cooperation.
  - If stock is noticeably below expectation → Some player(s) defected last round.
  - Respond by defecting once to punish defectors.
  - After punishment, return to cooperation.
- **Round r:** Defect to maximize one-shot payoff without fearing consequences.

---

### Edge Cases and Considerations

- **Noise / small stock fluctuations:** Use tolerance margin (~1% of capacity) to avoid false positives.
- **Multiple defections in a row:** Punishment is one-shot per detected defection; persistent defectors will be punished repeatedly.
- **All cooperate forever:** Stock remains near capacity → stable high payoffs for all.
- **If others defect unilaterally, punishing causes stock depletion but also incentivizes return to cooperation.**
- **No initial assumptions about others — start cooperatively to gain trust.**
- **No coordination or communication: rely solely on observable stock and payoffs.**

---

### Summary in Plain Language

> Start by cooperating to preserve the pool. Watch the stock carefully. If the stock shrinks more than it should, that means someone defected last round — punish by defecting once yourself. Then forgive and go back to cooperation. Repeat this pattern every round. In the very last round, defect to maximize your one-time gain. This balanced approach maintains high resources and punishes free riders without endless conflict.

---

If implementation assistance is needed, I can provide more detailed formula functions or code snippets.
'''

description_COOPERATIVE_18 = '''
Below is a fully cooperative strategy designed for the Common Pool Resource Game given your specifications. This strategy:

- Prioritizes long-term resource sustainability and mutual cooperation to maximize joint payoffs
- Uses observed histories to detect and respond to defections in a calibrated way
- Handles edge cases such as first and last rounds explicitly
- Requires no communication or external coordination, relying solely on observed actions and stock dynamics

---

## Cooperative Strategy Outline: “Conditional Grim with Forgiveness and Endgame Cooperation”

### Key intuition:
- Cooperate as long as everyone cooperates, ensuring the resource stays at or close to capacity, maximizing everyone's per-round payoffs.
- If defectors appear, penalize by defecting temporarily to discourage over-consumption.
- Forgive defections if cooperation resumes, to avoid permanent collapse from transient noise.
- In the last round, defect to maximize immediate personal payoffs since no future rounds remain to enforce cooperation.

---

## Decision Rules

### Notation
- Let `t` be the current round (1 ≤ t ≤ r)
- Let `S_t` be the observed stock at the start of round `t`
- Let `Actions_{t-1}` be the vector of all players' actions in round `t-1` (for t > 1)
- Let `defection_detected` be a boolean flag tracking if any defection was observed and not forgiven yet
- Let `forgiveness_window` be a counter how many rounds to cooperate after a defection is spotted before punishing again
- Let `forgiveness_length` be a fixed small number of rounds (e.g., 1 or 2) during which we "forgive" to see if cooperation resumes
- Let `defection_threshold` be whether any player defected last round (≥1 defector triggers detection)

---

### Round 1 (t=1)

- **Action:** Cooperate (C)
- **Reason:** No history, so start fully cooperatively to build trust and maximize initial joint payoff.

---

### Intermediate rounds (1 < t < r)

1. **Check history:**
   - If in previous round at least one player defected, set `defection_detected = True` and reset `forgiveness_window` to 0.
   - If `defection_detected = True`:
     - Increment `forgiveness_window` by 1.
     - If all players cooperated in the last round (i.e., no defection detected in that round), **forgive** by setting `defection_detected = False`.
     - Else if `forgiveness_window > forgiveness_length` (forgiveness period expired), defect (D) this round as punishment.
     - Otherwise, cooperate to give a chance for mutual return to cooperation.
   - If `defection_detected = False`, always cooperate (C).

2. **Stock monitoring:**
   - Optional enhancement: if `S_t` falls below a critical low threshold (e.g., very low compared to capacity, say ≤ capacity / (2n)), increase cooperation vigilance (e.g., defect for exactly one round to test/discipline defectors).
   - (This is optional and can be omitted for simplicity.)

---

### Last round (t = r)

- **Action:** Defect (D)
- **Reason:** No future to enforce cooperation, so maximize immediate payoff.

---

## Pseudocode

```python
def cooperative_strategy(t, r, S_t, Actions_prev, defection_detected, forgiveness_window, forgiveness_length=2):
    # t: current round index
    # r: total rounds
    # S_t: current stock before current round
    # Actions_prev: list of players' actions in previous round (None if t=1)
    # defection_detected: boolean flag if any defection previously detected and unforgiven
    # forgiveness_window: integer tracking rounds since last defection detection
    # forgiveness_length: forgiveness period length

    if t == 1:
        # First round: cooperate
        return 'C', defection_detected, forgiveness_window

    if t == r:
        # Last round: defect to maximize payoff
        return 'D', defection_detected, forgiveness_window

    # Check previous round's actions for defection
    if Actions_prev is not None:
        if 'D' in Actions_prev:
            defection_detected = True
            forgiveness_window = 0
        else:
            # No defection last round
            if defection_detected:
                # Possibly forgive
                forgiveness_window += 1
                if forgiveness_window > forgiveness_length:
                    # Forgiveness period over, punish by defecting
                    return 'D', defection_detected, forgiveness_window
                else:
                    # Cooperate during forgiveness window
                    return 'C', defection_detected, forgiveness_window
            else:
                # Continuous cooperation
                return 'C', defection_detected, forgiveness_window

    # If no defection detected at all
    return 'C', defection_detected, forgiveness_window
```

---

## Explanation and Justification

- **Why cooperate initially?** To build a history of mutual cooperation and maintain resource at high stock, maximizing everyone's payoff.
- **Why punish?** To deter persistent defectors who threaten the common pool.
- **Why forgiveness?** To avoid spirals of mutual defection due to one-time defections or mistakes.
- **Why last-round defection?** With no future rounds, incentives shift to maximizing immediate gains.
- **Why no explicit communication?** Strategy uses publicly observable information only and requires no coordination device.
- **Why respond only based on actions?** Perfect information assumption; we can track defections reliably.
- **Why simple forgiveness window?** Prevents endless defection punishment where players might have returned to cooperation.

---

## Summary

| Round         | Action                      | Condition/Reason                                                   |
|---------------|-----------------------------|------------------------------------------------------------------|
| First (t=1)   | Cooperate (C)               | Build trust                                                      |
| Intermediate  | Cooperate (C)               | No defection detected or within forgiveness window               |
| Intermediate  | Defect (D)                  | Persistent defection detected beyond forgiveness period           |
| Last (t = r)  | Defect (D)                  | Maximize personal payoff, no future interaction                   |

---

This strategy maximizes the sustainable use of the common pool resource, punishes exploitation, and promotes a cooperative equilibrium that can outperform selfish and purely defecting approaches in the repeated game.
'''

description_COOPERATIVE_19 = '''
Here is a cooperative strategy tailored to the described Common Pool Resource (CPR) game. The core aims are to:

- Sustain the resource stock near capacity to maximize ongoing payoffs
- Punish defectors to discourage overconsumption
- Avoid needless defection, preserving cooperation incentives
- Adapt dynamically to the stock level and observed opponent behaviors
- Balance short-term gain vs. long-term sustainability

---

### Strategy Name: **Gradual Trust-and-Sustain (GTS)**

---

## 1. Overview of Decision Rules

At each round \( t \), player \( i \) observes:

- The current stock \( S_t \) (known from history)
- The previous round’s actions of all players \( a_{-i}^{t-1} \)
- The number of cooperators and defectors last round
- The round number \( t \)
- The total number of rounds \( r \)
  
The player’s action \( a_i^{t} \) is chosen as follows:

### Initial Trust Phase (Round 1)
- **Play C** (cooperate).  
Rationale: no past info, start optimistically supporting cooperation.

### Sustained Cooperation Phase
- If **all players cooperated last round**, and the stock \( S_t \) is above a high threshold \( T_{high} < capacity \),
  - Play **C**
- If some players defected last round, but the stock \( S_t \) is still above a moderate threshold \( T_{mid} \),
  - Play **C** with high probability, or
  - Play **D** to signal disapproval (see below)

### Punishment Phase
- If previous round had defectors, and stock \( S_t \) is below \( T_{mid} \),
  - Defect (D) to punish defectors and reduce incentive to overconsume.

### Recovery Phase
- After punishment, if defecting helped restore stock above \( T_{high} \),
  - Return to Cooperation.

### Endgame Phase (Last Round)
- Defect (D) in the last round \( t = r \)
- Rationale: no future to sustain cooperation, so maximize immediate payoff.

---

## 2. Threshold Definitions

Let:

- \( T_{high} = 0.85 \times capacity \) (stock considered healthy)
- \( T_{mid} = 0.5 \times capacity \) (stock significantly depleted)
- These thresholds can be tuned but serve as heuristic markers.

---

## 3. Detailed Decision Logic (Pseudocode)

```python
def select_action(t, r, S_t, last_actions, capacity, n):
    # last_actions: list of length n with elements in {'C', 'D'}
    # S_t: current stock level before round t's consumption
    # t: current round number
    # r: total rounds
    # capacity: max stock capacity
    
    T_high = 0.85 * capacity
    T_mid = 0.5 * capacity
    
    # Round 1: Always cooperate
    if t == 1:
        return 'C'
    
    # Count how many defected last round
    defectors = last_actions.count('D')
    cooperators = n - defectors
    
    # Endgame: last round - defect to maximize immediate payoff
    if t == r:
        return 'D'
    
    # Stock is healthy (near capacity)
    if S_t >= T_high:
        if defectors == 0:
            # Everyone cooperated last round and stock healthy => cooperate
            return 'C'
        else:
            # Some defected, but stock still healthy
            # Respond cooperatively to attempt forgiveness/trust
            # Optionally punish defectors probabilistically to deter abuse
            # For simplicity: cooperate with 80% probability, defect 20%
            if random() < 0.8:
                return 'C'
            else:
                return 'D'
    
    # Stock moderately depleted
    elif T_mid <= S_t < T_high:
        if defectors == 0:
            # No defectors, but moderate stock => cooperate to help recovery
            return 'C'
        else:
            # Defectors exist and stock is moderate => start punishing by defecting
            return 'D'
    
    # Stock critically low
    else:  # S_t < T_mid
        # Punish heavy defection by defecting
        return 'D'
```

---

## 4. Explanation & Rationale

- **Round 1 Cooperation:** Establish mutual cooperation baseline. Since all players preferred cooperating maximize overall payoff, this initial trust encourages reciprocation.

- **Sustained Cooperation When Stock Is Healthy:** If stock is high and everyone cooperated last round, maintain cooperation to maximize future payoffs.

- **Forgiveness Component:** When defectors appear but stock is still healthy, cooperate mostly to give defectors chance to rehabilitate; occasional defection signals that defection is noticed.

- **Punishment When Stock Declines:** Defection punishes overconsumption that threatens resource sustainability, incentivizing others to cooperate.

- **Endgame Defection:** In the last round, no future retaliation possible, so defect to maximize own payoff.

- **Stock Thresholds Guide Behavior:** Using stock level rather than just opponents’ actions as a guide reflects the game's dynamic state—protecting the resource stock is key.

- **No Coordination or Communication Assumed:** This is fully based on observed public actions and resource state.

---

## 5. Advantages

- Balances cooperation with credible punishment.
- Adapts to both individual opponent behavior and resource health.
- Resistant to exploitation: Punishes defectors when resource is threatened.
- Forgives occasional defections if stock is okay, limiting escalation.
- Simple, transparent rules consistent with game info and no communication.

---

## 6. Possible Extensions (Optional)

- Track player-wise defect frequency and target punishment selectively.
- Use probabilistic forgiveness tuned by observed defection patterns.
- Try “gradual cooperation” by defecting only some rounds after defection instead of all out.

---

**Summary:** This strategy fosters long-term cooperation through initial trust and sustains mutual benefit by managing resource health, while deterring unsustainable defection through conditional punishment—all while exploiting the perfect information and repeated nature of the game.
'''

description_COOPERATIVE_20 = '''
Below is a cooperative strategy crafted specifically for the described Common Pool Resource game. It leverages the publicly observable history of actions and the known game dynamics to sustain cooperation, maximize long-term payoffs, and enforce cooperative discipline when defectors emerge.

---

# Cooperative Strategy for Common Pool Resource Game

## Intuition / Rationale
- Mutual cooperation yields a sustainable stock and steady, moderate payoffs.
- Defection yields higher immediate payoffs but risks depleting the stock, harming everyone long-term.
- The strategy must **start cooperative**, **maintain cooperation if others do**, and **punish defectors to deter exploitation**.
- Punishment should be **proportional and temporary** to allow restoration of cooperation.
- Near the **end of the game**, incentives to defect grow since future punishment is limited; so adapt accordingly.
- This approach embodies "Conditional Cooperation" adapted to multi-player CPR with dynamic common stock.

---

## Key Components

### Parameters
- `n`: number of players
- `r`: total rounds
- `capacity`: max stock
- `t`: current round (1-indexed)
- For ease of explanation: define a **punishment length** \( L = \min(3, r - t) \) (e.g., 3 rounds minimum effective punishment)
- Maintain internal state:
  - `punishment_countdown`: counts down rounds left in punishment phase (initially 0)
  - `last_round_defectors`: set of players who defected in last round (initially empty)

---

## Decision Rules

### 1. First Round (t == 1)
- **Play C** (Cooperate)
- Rationale: establish cooperation baseline, no history yet

---

### 2. Subsequent Rounds (t > 1)

#### A. If currently in punishment phase (`punishment_countdown > 0`)
- **Play D** (Defect)
- Decrease `punishment_countdown` by 1
- Rationale: punish defectors by defecting collectively, applying a credible threat

#### B. Else (not in punishment)
- Check last round’s actions of other players:
  - Identify defectors from last round `D_last`
  - If `D_last` is empty (everyone cooperated):
    - Play **C** (continue cooperation)
  - Else (there were defectors last round):
    - Initiate punishment:
      - Set `punishment_countdown = L`
      - Play **D** this round (start punishment)
- Rationale: cooperate if all cooperated last round; otherwise start punishment

---

### 3. Final Round (t == r)
- Always **play D**
- Rationale:
  - No future punishment possible
  - Defection yields higher immediate payoff
  - This is a standard end-game logic in repeated games

---

## Pseudocode

```python
initialize:
    punishment_countdown = 0
    last_round_defectors = set()

for t in 1...r:
    if t == 1:
        action = 'C'  # First round cooperate
    elif t == r:
        action = 'D'  # Last round: defect to maximize payoff
    else:
        if punishment_countdown > 0:
            action = 'D'  # Punishment phase: defect
            punishment_countdown -= 1
        else:
            # Analyze last round actions of all other players
            # Assume access to list of player actions in round t-1: actions_prev_round
            defectors_last = {p for p in players if actions_prev_round[p] == 'D'}
            
            if len(defectors_last) == 0:
                action = 'C'  # Everyone cooperated last round, so cooperate
            else:
                # Start punishment phase for L rounds
                punishment_countdown = min(3, r - t)
                action = 'D'  # Start punishment by defecting

    execute action

    # Update last_round_defectors for next iteration
    # After round ends, set last_round_defectors = defectors_last
```

---

## Additional Notes

- **Why punish by defecting all rounds during punishment phase?**
  - Mass defection quickly depletes the stock, lowering payoff for defectors and cooperators alike, but defectors lose their unfair advantage.
  - The short punishment length balances deterrence and recovery.
- **Why cooperate when others cooperate?**
  - To sustain the resource and mutual payoffs.
- **Why defect in the last round?**
  - It’s a standard backward induction logic in repeated games—no future punishment possible.
- **Stock level monitoring**
  - The strategy does *not* explicitly use the current stock level to determine action, but the stock dynamic enforces natural feedback on payoffs.
- **No coordination or communication beyond observing actions**
  - The strategy infers cooperation/defection based solely on observed past actions.

---

## Summary

| Round            | Condition                          | Action          |
|------------------|----------------------------------|-----------------|
| First (t=1)      | No history                       | Cooperate (C)   |
| Last (t=r)       | End of game                     | Defect (D)      |
| Punishment phase | punishment_countdown > 0         | Defect (D)      |
| Otherwise        | Everyone cooperated last round   | Cooperate (C)   |
| Otherwise        | Defectors detected last round    | Start punishment phase (Defect) |

---

This strategy aims to maintain high resource levels and mutual gains through conditional cooperation and calibrated punishment, embodying a strong cooperative mindset under perfect information and repeated interaction.
'''

description_COOPERATIVE_21 = '''
Here is a fully cooperative strategy design for the described common pool resource game.

---

## Intuition Behind the Strategy

- The best group outcome is for everyone to **always cooperate (C)** because total consumption at C is half that of D per player, which sustains the stock at a high level.

- Defection (D) by any player increases their immediate payoff but drastically reduces common pool stock and future payoffs, harming everyone.

- The challenge is to sustain cooperation despite temptation to defect, **without communication or explicit coordination**.

- Given perfect information about all past actions, we use a *trigger-and-forgive* approach inspired by **"grim trigger"** and **"tit-for-tat"-style** strategies, but soften punishment to allow recovery.

---

## Cooperative Strategy Summary (named: Forgiving Grim Trigger)

| Round       | Action                    | Notes                                             |
|-------------|---------------------------|---------------------------------------------------|
| Round 1     | Cooperate (C)             | Begin with cooperation                            |
| Rounds 2..r-1 | Cooperate if no defections in previous round; else punish by defecting once | Single defection triggers one round of defection by this player as punishment, then revert to cooperation |
| Round r     | Cooperate if no defection in previous round; else defect | On last round, punish defection with defection (no future round to threaten) |

---

## Detailed Decision Rules

Let:

- \( t \) = current round (1 to r)
- \( history \) = record of all players' actions in previous rounds
- \( D_{t-1} \) = set of players who defected in round \( t-1 \)
- \( self \) = this player

### Step 1: Defection detection

- For \( t=1 \), no history, so no defections.
- For \( t > 1 \), observe actions of all players at \( t-1 \).

### Step 2: Determine own action

- **Round 1:**  
  - Cooperate (C)

- **Rounds 2 to r-1:**  
  - If no player defected in round \( t-1 \), cooperate (C).  
  - If any player defected in round \( t-1 \), defect (D) this round ***once*** to punish, then return to cooperate in next rounds.

- **Round r (last round):**  
  - If no defection in \( t-1 \), cooperate (C).  
  - If any defection in \( t-1 \), defect (D).  
  - No forgiveness after final round (no future to regain trust).

### Step 3: Track "punishment state"

We keep a simple internal state variable `punish_next_round`:

- Initially `False`
- Set to `True` if defection observed last round
- If `punish_next_round` is `True`, defect this round, then set `punish_next_round` to `False` (forgive)
- Else cooperate.

---

## Pseudocode

```python
class ForgivingGrimTriggerStrategy:
    def __init__(self, n, r, capacity):
        self.n = n
        self.r = r
        self.capacity = capacity
        self.punish_next_round = False  # Tracks if punishment is due next round

    def decide(self, t, history):
        # t: current round (1-indexed)
        # history: list of length t-1 of dict {player_id: action}, actions in previous rounds

        if t == 1:
            # Start cooperative
            return 'C'

        # For rounds > 1, check if any defection in last round
        last_round_actions = history[-1]  # dict of player: action for round t-1
        defectors = [p for p, a in last_round_actions.items() if a == 'D']

        if self.punish_next_round:
            # Punish once, then forgive
            self.punish_next_round = False
            return 'D'

        if len(defectors) > 0:
            if t < self.r:
                # Defection observed last round => punish this round
                self.punish_next_round = True  # next round will cooperate again
                return 'D'
            else:
                # Last round: punish forever, no forgiveness
                return 'D'

        # No defection to punish
        return 'C'
```

---

## Rationale and Key Properties

- **Start Cooperative**: Signals willingness to cooperate immediately.

- **Immediate and Observable Punishment**: Responds to any defection in previous round by defecting once, reducing incentive to defect.

- **Forgiving**: Punishment is temporary (one round) except on final round, avoiding endless mutual defection cycles.

- **Last Round Defection Punishment**: Since no future rounds after \( r \), punishment is permanent (defect) if defection observed last round.

- **Sustains Cooperation**: If all players follow, cooperation is stable and stock remains healthy for maximal payoffs.

- **Simple Implementation & Understandable**: Easy for other LLM strategies to recognize cooperative patterns; encourages mutual cooperation.

---

## Handling Edge Cases

1. **First Round (no history):**  
   - Cooperate unconditionally to establish trust.

2. **Last Round:**  
   - Do not forgive defectors; defect in last round to penalize defection.

3. **Multiple Defectors:**  
   - Punish after any defection event equally; no differentiation needed.

4. **No Communication:**  
   - Uses only observed actions to infer defection and trigger punishment.

5. **Stock Level Ignored in Decisions:**  
   - Strategy focuses on behavior-based cooperation, trusting defection deterrence more than state manipulation.

---

## Summary

This **Forgiving Grim Trigger** strategy:

- Reacts to defectors by temporarily defecting once as punishment.
- Forgives immediately after punishment to resume mutual cooperation.
- Defects persistently only in final round if defection is recent.
- Initiates cooperation and tries to sustain it for high group payoffs and sustainability.

This balances cooperation incentives and punishment sufficiently to align payoffs toward collective welfare.

---

If all players use this strategy, the pool remains healthy and everyone gains maximal payoff over all rounds.
'''

description_COOPERATIVE_22 = '''
Below is a detailed cooperative strategy tailored for this repeated common pool resource game that promotes sustainable use of the stock and maximizes long-run payoffs through mutual cooperation. It is robust to detecting defections and punishing them, yet ready to return to cooperation if others do so.

---

## Cooperative Strategy: "Conditional Cooperation with Forgiveness"

### Intuition
- **Default to cooperation** to sustain the resource (playing C).
- **Detect defections** (opponents playing D) because defections cause faster stock depletion.
- **Punish defectors** by defecting in the *next* round to discourage exploitation.
- **Forgive if cooperation resumes**, to reestablish mutual cooperation.
- Adjust behavior in **final round** since future punishments are moot.
- In the **first round**, cooperate by default to encourage cooperation.

---

### Decision Rules

1. **First Round (t = 1)**
   - Play **C** (cooperate).
   
2. **Subsequent Rounds (t = 2...r-1)**
   
   After observing all players' actions in round t-1:

   a. **If all other players played C in round t-1:**
   - Play **C** (continue to cooperate).

   b. **If at least one other player played D in round t-1:**
   - Play **D** (punish by defecting this round).
   
   c. **If you defected in round t-1 due to punishment, but now observe all cooperations:**
   - Revert to **C** (forgive and return to cooperation).

3. **Final Round (t = r)**
   - Defection is less costly since no future retaliation.
   - But still **cooperate if all others cooperated in round r-1**, defect otherwise.
   - This softens last-round extinction and encourages endgame cooperation.

---

### Rationale

- Cooperative consumption (C) preserves the stock near capacity and yields moderate but steady payoffs (~S/(2n)).
- Defecting when others cooperate (D) yields immediate higher payoffs (S/n), but over multiple rounds depletes the stock.
- Punishing defectors with defection reduces their future payoffs and discourages defection.
- Forgiveness prevents endless cycles of punishment and allows return to cooperation.
- First-round cooperation is a signal and invitation for cooperation.
- Final round logic reflects the "last round unraveling" problem: cooperation is optimal if others cooperate, else defect.

---

### Edge Cases Handling

| Situation                       | Behavior                       | Explanation                                          |
|-------------------------------|-------------------------------|-----------------------------------------------------|
| Round 1                       | Play C                        | Start cooperatively with all.                        |
| If all played C last round    | Play C                        | Maintain cooperation.                                |
| If any defected last round    | Play D                        | Punish defectors.                                    |
| If you played D last round but now all cooperate | Play C           | Forgive and resume cooperation.                      |
| Round r (last round): If last round all cooperated | Play C               | Reward cooperation in last round.                    |
| Round r and any defect last round | Play D                    | No incentive to tolerate defection last round.       |
| Stock very low (near zero)    | Play C                       | Help resource recover (implicit in rules since recovery depends on remaining stock and cooperation). |

---

## Pseudocode

```python
def cooperative_strategy(t, r, n, capacity, S_t, history):
    """
    Parameters:
    - t: current round number (1-based)
    - r: total rounds
    - n: number of players
    - capacity: max stock
    - S_t: current stock before round t
    - history: list of past rounds' actions
      Each element: dict {player_i: action_i} for round t-1, etc.

    Returns:
    - action: 'C' or 'D' for round t
    """
    
    # On first round, cooperate
    if t == 1:
        return 'C'
    
    # Get last round actions
    last_actions = history[-1]  # dict of player -> action
    
    # Extract others' actions (excluding self)
    # Assume self is indexed as "self_id"
    # Since no self_id specified, assume we observe all actions, including ours
    
    # Identify if any player defected last round (excluding self)
    # If unable to know self identity or separate it, consider all players including self
    
    all_cooperated_last_round = all(action == 'C' for action in last_actions.values())
    any_defected_last_round = any(action == 'D' for action in last_actions.values())
    
    # For simplicity, assume "we" can identify own last action from history
    # (if required, this can be parameterized)
    own_last_action = last_actions.get('self', 'C')  # assume default C if unknown
    
    # Final round logic
    if t == r:
        if all_cooperated_last_round:
            return 'C'
        else:
            return 'D'
    
    # For rounds 2 to r-1
    
    # If all cooperated last round, cooperate
    if all_cooperated_last_round:
        return 'C'
    
    # Else if any defected last round, defect this round (punishment)
    if any_defected_last_round:
        return 'D'
    
    # If we defected last round, but now all cooperate, forgive and return to cooperation
    # (This case is covered above because if all cooperated last round, we return C)
    
    # Default fallback
    return 'C'
```

---

## Summary

| Round | Condition                         | Action        |
|-------|---------------------------------|---------------|
| 1     | Always                          | Cooperate (C) |
| 2..r-1| Others all cooperated last round| Cooperate (C) |
| 2..r-1| Any other defected last round    | Defect (D)    |
| r     | Others all cooperated last round| Cooperate (C) |
| r     | Any other defected last round    | Defect (D)    |

---

## Why This Strategy Is Cooperative

- It tries to maintain high stock level by mostly cooperating.
- It punishes selfish players who defect, deterring over-consumption.
- It allows for forgiveness, enabling recovery from misunderstandings or mistakes.
- It exploits the fact that cooperation sustains long-term payoffs.
- It optimizes payoffs by cooperating early and throughout, only defecting briefly as a response.
- It is easy to implement, deterministic, and transparent to other players analyzing behavior.

---

If your opponent also follows a cooperative or conditional cooperative strategy, this approach will sustain cooperation and maximize aggregate payoffs.

If opponents defect, this strategy limits exploitation by punishing defectors immediately, protecting the stock and your own payoffs.

This strategy balances **cooperation, deterrence, and forgiveness** optimally given the game's rules and information constraints.
'''

description_COOPERATIVE_23 = '''
Here is a cooperative strategy for the Common Pool Resource Game that carefully balances sustainability and payoffs, punishes defection to enforce cooperation, and ensures near-cooperative behavior even in the last round.

---

## Intuition and Goals

- **Cooperate as default:** Choose action C to consume cautiously and sustain the resource.
- **Punish defection:** If any player defects, respond in a way that discourages repeated defection.
- **Recover cooperation:** Allow a path back to cooperative play after punishment.
- **Careful endgame:** In the last round, defect if it improves immediate payoff without hurting future rounds (which do not exist).
- **Use observable history:** Actions of all players in previous rounds are known.
- **Protect the resource stock:** Avoid stock collapse to maximize long-term gains.

---

## Strategy Description

**Notation:**

- Let `t` = current round index (1 to r)
- Let `actions_t` = vector of all players' actions in round t
- Let `S_t` = stock at beginning of round t (known from previous round's state update)
- Let my action in round t be `A_t`

---

### Decision Rules

1. **First Round (t = 1):**
   - Play **C** (cooperate).
   - Reason: No history, so start cooperatively to build trust and maintain stock.

2. **Rounds 2 to r-1:**
   - If *all other players* cooperated in round t-1 (all played C), then:
     - Play **C** again.
     - Rationale: Sustain cooperation and resource.
   - Else (at least one player defected in round t-1), then:
     - **Punish** by defecting **once** (play D).
     - **Next round:** If all defectors in previous rounds have cooperated since, forgive and return to cooperate.
     - Otherwise, continue defecting for another round.
   - This approach is a **two-round trigger strategy**:
     - Defect for one round punishment after defection is observed.
     - If others return to cooperation, so do we.
   - This balances deterrence with forgiveness.

3. **Last Round (t = r):**
   - Since there are no future rounds, cooperate *only if* the stock is likely to sustain payoffs or if everyone cooperated last round.
   - Otherwise, defect to maximize immediate payoff.
   - Specifically:
     - If the last round before r (round r-1) was cooperative (all C), play **D** to maximize last round payoff.
     - Else, play **D** (defect to get what you can).
   - Reason: No incentive to preserve stock after final consumption.

---

### Edge Cases and Additional Considerations

- **If stock is very low (< n × (stock/n) or similar):**
  - Prioritize cooperation to allow resource regrowth unless defecting in last round.
- **If total consumption in previous round caused stock near zero:**
  - Defecting may kill the resource—avoid defecting except last round.
- **Handling noise or mistakes:**
  - Since there's no explicit noise model, treat any defection as defection.
  - Forgiveness built-in (after 1 round punishment) helps recover cooperation.
- **If multiple defectors:**
  - Punishment is collective — defect one round to raise costs, then return to cooperating once others cooperate.

---

## Pseudocode

```python
def cooperative_strategy(t, r, n, capacity, S_t, history):
    """
    Inputs:
      - t: current round (1-based)
      - r: total rounds
      - n: number of players
      - capacity: max stock
      - S_t: current stock at start of round t
      - history: list of all previous rounds' actions; each element is a list of length n
                 history[0] = actions in round 1, etc.
    
    Output:
      - action: 'C' or 'D'
    """
    
    # First round: always cooperate
    if t == 1:
        return 'C'
    
    # Check previous round actions
    prev_actions = history[t - 2]  # zero-indexed
    
    all_cooperated_prev = all(a == 'C' for a in prev_actions if a is not None)
    # Note: a should never be None, but just to be safe
    
    # Check if the strategy was punishing last round
    # Detect if we punished last round (our action was 'D' after previous defection)
    # Can check history of own past actions if needed
    # For simplicity, assume we can identify if we punished last round by tracking state
    
    # Keep track of whether punishment in progress:
    # For a simple memory-1 strategy, we use history only:
    # If defection detected last round, punish once.
    
    # Detect if defection occurred in prev round by others
    defection_in_prev_round = any(a == 'D' for a in prev_actions if a != 'C')
    
    if t == r:
        # Last round decision:
        # If last round was cooperative, exploit by defecting
        if all_cooperated_prev:
            return 'D'
        else:
            # Otherwise also defect to maximize payoff in final round
            return 'D'
    
    # For rounds 2 to r-1:
    # Simple trigger: if no defection last round, cooperate
    if all_cooperated_prev:
        return 'C'
    
    # Else, defection detected last round, punish once by defecting
    # Check if we punished last round (to avoid repeated punishment)
    my_prev_action = history[t - 2][my_index]  # my_index: our player index (0-based)
    # If we already defected last round as punishment, forgive and return to cooperate
    if my_prev_action == 'D':
        return 'C'
    else:
        return 'D'
```

**Note:**  
- The strategy requires remembering own last action and whether last round included defection.
- Forgiveness happens quickly to restart cooperation.

---

## Summary

| Round       | Condition                                              | Action           | Rationale                                    |
|-------------|--------------------------------------------------------|------------------|----------------------------------------------|
| 1           | Always                                                | Cooperate (C)    | Start cooperative                            |
| 2 ≤ t < r   | Previous round all cooperate                          | Cooperate (C)    | Sustain cooperation and stock               |
| 2 ≤ t < r   | Previous round had defection                          | Defect once (D) if didn't punish last round; else Cooperate | Punish defectors once, then forgive          |
| r (last)    | Previous round all cooperate                          | Defect (D)       | Exit game defect to maximize last payoff    |
| r (last)    | Previous round had defection                          | Defect (D)       | No future rounds, maximize payoff           |

---

This strategy adheres to the cooperative mindset by incentivizing and sustaining cooperation, punishing defection to deter freeloading, forgiving to allow recovery to cooperation, and acting rationally in the final round. It balances the tension between individual incentives to defect and group incentives to maintain the common pool resource.

---

If you want a more formal implementation or enhancements like adaptive thresholds or longer punishment phases, I can help design those too.
'''

description_COOPERATIVE_24 = '''
Below is a fully cooperative strategy designed for this repeated common pool resource game. It seeks to sustain the resource pool near capacity as long as possible, maximizing total payoffs for all players, while deterring defection prudently and exploiting others only when strictly beneficial.

---

## Intuition and Key Points

- **Cooperation means**: consume cautiously, only \( \frac{S}{2n} \) (half-share), which preserves the resource.
- **Defection means**: consume aggressively, \( \frac{S}{n} \), extracting more short-term benefit but at risk of resource collapse.
- Sustainable cooperation stabilizes stock near capacity, yielding sustained long-term payoffs.
- Defections reduce stock, diminishing future payoffs for everyone.
- We are constrained by:
  - No communication or coordination beyond observing others' past actions.
  - Perfect information on past actions and stock levels.
- The last round has no future incentive, so defection can be individually rational then.

---

## Strategy Overview

We play a **"Conditional Grim Trigger with Forgiveness"** cooperative strategy, adapted for dynamic state and payoff structure:

1. **Round 1: Cooperate unconditionally.** Start by cooperating to promote efficiency.

2. **Rounds 2 to r-1: Cooperate, except if defection detected in previous rounds:**

   - If **no defection detected so far**, cooperate.
   - If **defection detected** (any player defected last round or any previous round), enter a punishment phase lasting exactly one round:
     - Defect this punishment round to penalize defectors.
     - After the punishment round, *return to cooperation* (forgiveness).
   
   This punishment-after-defection discourages defections but does not trigger infinite defection cycles.

3. **Round r (last round): Defect unconditionally.** Since no future rounds exist, defect to maximize one-shot payoff.

---

### Detecting Defection

- A player is considered defected if in the previous round their action was \(D\).
- Since actions are observed each round, detection is immediate round-to-round.

---

### Intuition for Forgiveness

- Infinite punishment risks depleting the stock unnecessarily, harming everyone.
- One-round punishment deters defection while preserving incentive to return to cooperation.
- This maintains cooperation as the equilibrium where everyone gains maximum aggregate payoffs.

---

## Pseudocode

```python
# Parameters known:
# n: number of players
# r: number of rounds
# capacity: maximum sustainable stock

# Inputs at each round t (1-indexed):
# - history_actions: list of lists, each element is list of player actions at round t-1
#    e.g. history_actions[t-1][i] = 'C' or 'D' for player i+1
# - current_round: integer t
# - (optional) stock S is known, but not needed directly to decide action

def cooperative_strategy(history_actions, current_round, r, n):
    if current_round == 1:
        # First round: cooperate unconditionally
        return 'C' 
    
    elif current_round == r:
        # Last round: defect unconditionally (range ends, no future punishment)
        return 'D'
    
    else:
        # Check if defection detected in previous round (t-1)
        
        last_round_actions = history_actions[-1]  # actions at round t-1
        defection_detected = any(a == 'D' for a in last_round_actions)
        
        # State variable: If we just punished last round, now cooperate again
        # We need a memory of punishment phase:
        # Check if we punished last round: i.e. in round t-1, did we defect due to punishment?
        # Since no coordination devices, assume we remember if defection was detected at round t-2.
        
        # To implement this without explicit state memory beyond history:
        # Punishment phase is exactly one round after defection detection.
        
        # If last round was punishment, now cooperate.
        # Detect punishment: last round all defected only if we punished? No.
        # So more simply:
        # Punish exactly one round following a defection, then cooperate.
        
        # Implement logic:
        # If defection detected in round t-1: punish this round (defect)
        # Else if defection detected in round t-2: punishment done, cooperate
        # Else cooperate
        
        # t-1 round: if defection, punish now
        if defection_detected:
            return 'D'  # punish defectors
        
        # check if defection detected two rounds ago t-2, so punishment done last round
        if current_round >= 3:
            two_rounds_ago_actions = history_actions[-2]
            defection_detected_two_rounds_ago = any(a == 'D' for a in two_rounds_ago_actions)
            
            if defection_detected_two_rounds_ago:
                # punishment ended last round, return to cooperate
                return 'C'
        
        # no defection detected recently, cooperate
        return 'C'
```

---

## Summary of Decision Rules

| Round       | Condition                                            | Action    |
|-------------|-----------------------------------------------------|-----------|
| Round 1     | Always                                            | Cooperate |
| Rounds 2..r-1 | If any player defected last round: punish (defect this round) | Defect    |
|             | Else if just finished punishing (detected defection 2 rounds ago): cooperate | Cooperate |
|             | Otherwise                                        | Cooperate |
| Round r     | Always                                            | Defect    |

---

## Why This Strategy Is Cooperative and Robust

- **Sustainability:** Cooperate to keep stock healthy.
- **Deterrence:** Single-round punishment deters defection by reducing immediate defector payoff from future cooperation.
- **Forgiveness:** Forgives defectors soon after punishment to restore cooperation and avoid long-term decline.
- **Last round defection:** Rational endgame move to maximize individual payoff.
- **No reliance on shared norms:** Uses only observable actions, no communication necessary.
- **Memory-limited:** The state depends only on past two rounds, practical for repeated game.

---

### Additional Notes

- If multiple defections occur in a row, strategy punishes each detected defection round by round.
- Because the stock growth function is logistic and capped by capacity, cooperation keeps the resource replenished.
- Defection collapses the stock → cooperation yields higher total payoff.
- The strategy rewards cooperation with continuing cooperative payoffs, punishes defection swiftly, then forgives to reset cooperation.

---

This is a well-known style of strategy in repeated resource games: optimistic start, single-step punishment, forgiveness, and backward induction defection at last round. It balances cooperation incentives with rational defection incentives, maximizing group and individual payoffs across the entire game.
'''

description_COOPERATIVE_25 = '''
Here is a cooperative strategy designed to achieve sustainability and maximize joint payoffs in the Common Pool Resource game, under the constraints and information available.

---

## Strategy Name: **Reciprocal Sustainable Cooperation (RSC)**

### Intuition:
- Start by cooperating to maintain the resource.
- Continue cooperating as long as others do.
- Punish defections with temporary defections to discourage free-riding.
- Return to cooperation after punishment.
- Defect on the last round to maximize immediate payoff because no future consequences exist.
- Ensure cooperative behavior maintains the stock near the carrying capacity for maximum joint payoffs.

---

## 1. Decision Rules

At round t (1 ≤ t ≤ r), given the history of all players' past actions and the current stock S_t:

- **Round 1**:  
  - Cooperate (C) unconditionally to establish a cooperative baseline.

- **Rounds 2 to r-1**:  
  - If all other players cooperated in the previous round (t - 1), cooperate.  
  - If one or more players defected in the previous round, defect this round (punishment phase lasts exactly one round).  
  - After punishing once, return to cooperating **if** all other players cooperated in the last round.  
  - Maintain cooperation as long as no defections detected in the previous round.

- **Round r (last round)**:  
  - Defect (D) unconditionally, since no future retaliation or cooperation incentives exist.

---

## 2. Additional Details / Edge Cases

- **Detecting Defection**:  
  Defection is any player choosing D in previous round.

- **Handling Multiple Defections**:  
  Punish collectively by defecting once in response to any defection.

- **Stock Depletion Warning**:  
  The strategy monitors stock level S_t. If stock falls below a threshold (e.g., capacity / 2), the strategy signals implicit distrust by defecting once as a warning. This aims to strengthen punishments when stock is dangerously low.

- **If Stock is Zero**:  
  Cooperate regardless, because defecting yields no payoff and cooperation may help recovery.

- **Re-entry to Cooperation**:  
  After punishing once, if all players cooperate on the next observed round, return to cooperation.

---

## 3. Pseudocode

```python
def RSC_strategy(t, r, n, capacity, S_t, history):
    """
    Parameters:
    - t: current round (1-based)
    - r: total rounds
    - n: number of players
    - capacity: maximum capacity
    - S_t: current stock before actions
    - history: list of tuples per round [(actions_round_1), (actions_round_2), ..., (actions_round_t-1)]
       where actions_round_k is a list of length n with each player's action in round k ('C' or 'D')

    Returns:
    - 'C' or 'D' decision for this round
    """

    # On first round: cooperate
    if t == 1:
        return 'C'

    # On last round: defect unconditionally
    if t == r:
        return 'D'

    # Check if stock is depleted or below sustainability warning threshold
    warning_threshold = capacity / 2

    # Detect if any defection in previous round
    last_round_actions = history[-1]
    others_last_actions = [a for i,a in enumerate(last_round_actions)]  # full actions including self, no direct info on own past action needed here
    
    # Count defections by opponents only: need to know own index (assume known as my_index)
    # Since we cannot assume coordinate or communication, and no player id given here,
    # assume you know your own index "my_index", passed alongside or fixed 
    # For demonstration: assume my_index is known globally
    opponents_last_actions = [a for i,a in enumerate(last_round_actions) if i != my_index]

    any_opponent_defected = ('D' in opponents_last_actions)

    # Strategy logic:

    if S_t == 0:
        # Resource depleted, cooperate (trying to help recovery)
        return 'C'

    if S_t < warning_threshold:
        # If stock dangerously low, defect once as explicit warning
        # Check if we defected last round for warning (to avoid consecutive defects from warning)
        # Look at our own action last round
        my_last_action = last_round_actions[my_index]

        if my_last_action == 'D':
            # Already defected last round as warning or punishment, now resume cooperation if others cooperate
            if not any_opponent_defected:
                return 'C'
            else:
                return 'D'
        else:
            # Defect once as warning
            return 'D'

    # Otherwise (stock OK)

    # Retaliation logic
    my_last_action = last_round_actions[my_index]
    # If any opponent defected last round, punish once by defecting THIS round
    # If we already punished last round, resume cooperation if no defection last round
    if any_opponent_defected:
        if my_last_action == 'D':
            # We already punished last round, resume cooperation if no defection last round (should be impossible here since defection detected)
            if not any_opponent_defected:
                return 'C'
            else:
                return 'D'  # still defect if defections persist
        else:
            # punish now
            return 'D'
    else:
        # No defections last round, cooperate
        return 'C'
```

---

## 4. Summary

- **Start cooperating.**  
- **Maintain mutual cooperation as long as no defections.**  
- **Punish defections by defecting once in the immediately following round.**  
- **Return to cooperation after punishment.**  
- **Defect on last round for maximum individual gain.**  
- **If stock dangerously low (below half capacity), defect once as warning to signal need for stronger cooperation.**  
- **If stock is zero, cooperate to foster recovery.**

This strategy promotes long-run sustainability and collective payoff by encouraging cooperation and punishing exploitation sustainably, fitting the cooperative mindset without assuming explicit agreements.

---

If you want me to help with formalizing this in a different format or clarifying assumptions, just ask!
'''

description_COOPERATIVE_26 = '''
Here is a carefully considered cooperative strategy for the Common Pool Resource Game based on the given specification:

---

# Cooperative Strategy: "Reciprocal Sustainability"

### Intuition

- The strategy aims to sustain the common pool as close to capacity as possible to maximize long-term payoffs.
- It tries to punish defections (over-consumptions) immediately but with forgiveness and recovery to restore cooperation.
- Near the last round, the strategy shifts toward myopic (greedy) behavior, since future punishment is ineffective.
- The strategy only uses publicly observable history (actions of all players) and the current stock level (which is common knowledge).

---

### Key elements

- **Baseline:** Play **Cooperate (C)** unless defection is detected.
- **Defection detection:** If any player defects in the previous round, respond with defection in the current round as punishment.
- **Forgiveness and recovery:** After punishing for one round, revert back to cooperation if no further defections.
- **Last round:** Defect, since there is no future incentive to cooperate.
- **Edge stock conditions:**  
  - If the stock drops below a critical threshold (e.g., less than capacity/2), defect once to prevent exploitation, then cooperate again.  
  This avoids the tragedy of the commons collapse due to sustained defecting.

---

### Parameters (to be fixed tuned as constants)

- `THRESHOLD_STOCK = capacity / 2`
- `PUNISH_ROUNDS = 1` (punish once after defection detected)
- `LAST_ROUND = r` (final round number)

---

### Detailed decision rules

```plaintext
At round t ∈ {1,...,r}, after observing history up to round t-1:

If t == LAST_ROUND:
    # Last round: defect to maximize immediate payoff
    action = D

Else:
    # Check previous round's actions for defection
    if any player defected in round t-1:
        # Punish by defecting this round
        action = D
        mark that punishment was applied this round
    
    else if punishment was applied in round t-1 and no defection observed now:
        # Forgive: return to cooperation
        action = C
    
    else:
        # No defection detected recently: cooperate to sustain stock
        action = C

    # Check the current stock S (known after round t-1 update)
    if S < THRESHOLD_STOCK and action == C:
        # If stock is dangerously low, defect once to harvest more before others do
        action = D
```

---

### Explanation

- **Round 1:** No history, so no defection detected → cooperate.
- **Subsequent rounds:**  
  Cooperate if no defection detected in prior round(s), otherwise punish defectors by defecting once.
- **Punishment:** One-round defect to signal disapproval and immediately deter defections; not prolonged to avoid permanent collapse.
- **Forgiveness:** Upon observing cooperation after punishment, revert to cooperation to rebuild trust and stock.
- **Stock threshold:** Defect if stock too low to prevent unilateral exploitation by others and to achieve some payoff rather than zero.
- **Last round:** Full defection maximizing immediate payoff since no future interaction exists.

---

### Pseudocode (structured)

```python
def cooperative_strategy(t, r, n, capacity, S, history, punishment_state):
    # Inputs:
    # t: current round number (1-based)
    # r: total rounds
    # n: number of players
    # capacity: common pool max stock
    # S: current stock level (after last round)
    # history: list of tuples (actions by all players in past rounds)
    # punishment_state: boolean, True if punishment applied last round

    THRESHOLD_STOCK = capacity / 2
    LAST_ROUND = r

    if t == LAST_ROUND:
        # Last round: defect to maximize payoff
        return 'D', False

    # Detect defection in last round
    if t == 1:
        # No history before round 1, cooperate
        return 'C', False

    last_round_actions = history[t-2]  # zero-based indexing
    any_defection = any(a == 'D' for a in last_round_actions)

    if any_defection:
        # Punish defection by defecting this round
        return 'D', True

    # If we punished last round but now no defection detected, forgive
    if punishment_state:
        # Return to cooperation
        return 'C', False

    # Normal cooperate if no defect detected and no punishment state
    action = 'C'

    # Check stock threshold
    if S < THRESHOLD_STOCK and action == 'C':
        # Defect once as a safeguard against low stock
        action = 'D'

    return action, False
```

---

### Summary

- Start cooperating.
- Punish any detected defection once with defection.
- Forgive and return to cooperation if opponents resume cooperation.
- If stock falls below half capacity, defect once to avoid exploitation.
- Defect in the last round without restriction.
- This strategy promotes sustained cooperation, recovers from defection episodes, and adjusts exploitation as the stock changes, balancing individual and collective incentives.

---

If all players use this same strategy, the common pool will hover near full capacity with sustained cooperation and maximum collective payoffs over repeated rounds. If others defect, this strategy quickly punishes but also allows recovery.

This design respects the game rules and information constraints while enforcing a cooperative mindset.
'''

description_COOPERATIVE_27 = '''
Here's a fully cooperative strategy designed for the Common Pool Resource Game as specified. It relies on conditional cooperation, punishing observed defections by the opponents to enforce cooperation, and handling edge cases (first and last rounds) in a way that balances incentive and future outlook.

---

## Strategy Overview

- **Goal:** Maintain the common pool stock close to capacity by cooperating (i.e. playing C) as long as all other players cooperate.
- **Detection:** Monitor actions of others each round. If any player defects (plays D) in any previous round, switch to defecting (play D) permanently as a punishment.
- **First round:** Cooperate (play C) to establish trust and maximize sustainable stock growth.
- **Last round:** Defect (play D) to maximize immediate payoff because no future rounds remain to punish or reward.
- **Intermediate rounds:** Cooperate if no defections observed; else defect permanently.
- **Rationale:** This is a grim-trigger style strategy promoting cooperation but ensuring stability by punishing defection strongly and immediately.

---

## Decision Rules

### Notation:
- Let `round` = current round (1 to r)
- Let `history` = record of all players’ past actions up to `round - 1`
- Let `defected_before` = True if any other player defected (played D) in any previous round, else False

### Pseudocode:
```
function decide_action(round, r, history, player_id):
    # Check past defections by others
    defected_before = False
    for past_round in 1 to round-1:
        for player in 1 to n:
            if player != player_id and history[past_round][player] == 'D':
                defected_before = True
                break
        if defected_before:
            break

    if round == r:
        # Last round: defect to maximize immediate payoff
        return 'D'

    if defected_before:
        # Punish by defecting forever after any defection detected
        return 'D'

    # Otherwise: cooperate
    return 'C'
```

---

## Handling Edge Cases and Rationale

1. **First Round (round=1):**  
   No past history. Strategy cooperates to maximize stock replenishment and demonstrate goodwill.

2. **Last Round (round=r):**  
   Defect because no future punishment or reward is possible. Maximizing immediate payoff is rational.

3. **After detection of any defection:**  
   Defect forever. This punishes defectors and deters exploitation of cooperative players.

4. **Multiple defectors:**  
   Same punishment applies—no differentiation, since cooperation breaks down once any defection appears.

---

## Why this strategy is cooperative and effective

- **Maintains stock:** By cooperating initially and as long as all cooperate, keeps stock near capacity.
- **Simple, transparent:** Easy to infer from actions whether cooperation is ongoing.
- **Enforces cooperation:** Grim-trigger punishment deters defection.
- **Balances short-term and long-term incentives:** Cooperate to sustain payoff; defect at last round to maximize own final payoff.
- **Compatible with independent players:** Since all know the rules and observe actions, this strategy fosters implicit equilibrium cooperation without communication or coordination devices.

---

If you want, I can also suggest possible tweaks or softer punishments if you prefer less harsh retaliation. But this grim-trigger style strategy is a classic solid baseline for obtaining cooperation in repeated common pool resource dilemmas under perfect monitoring.
'''

description_COOPERATIVE_28 = '''
Below is a *cooperative strategy* designed for the Common Pool Resource Game that:

- Encourages mutual cooperation,
- Punishes defection sufficiently to deter free-riding,
- Adapts for the last round (no future incentive),
- Utilizes perfect monitoring of other players’ past actions,
- And is robust to adverse conditions such as stock depletion.

---

# Cooperative Strategy: "Grim Trigger with Stock Safety"

---

### Intuition

- The strategy starts by cooperating, consuming conservatively.
- It monitors for defections by any player in past rounds.
- Upon any defection observed, it switches permanently to defection (defect forever) **except in the last round**, where defection is inevitable.
- The strategy includes a *stock safety check* to avoid collapse due to extreme depletion, temporarily allowing defection to stabilize the resource if needed.
- This enforces cooperation through credible threat while preserving the common pool.

---

### Decision Rules per Round t (1 ≤ t ≤ r):

Let:

- *t* = current round
- *history* = all players' actions in rounds 1,...,t-1
- *S_t* = current stock level at start of round t
- *capacity* and *n* as defined

---

### Pseudocode:

```
if t == r:
    // Last round: defect to maximize immediate payoff since no future incentive
    play D (Defect)
else:
    // For rounds before the last

    // 1. Check for defection by any player in history
    if any player j defected in any round < t:
        // "Grim trigger" phase: punish forever with defection
        play D (Defect)
    else:
        // No defection observed so far: cooperate by default

        // 2. Check stock safety
        min_safe_stock = capacity / (2 * n)
        // - This is a heuristic threshold: stock below this risks collapse due to heavy consumption

        if S_t < min_safe_stock:
            // Stock dangerously low => relax cooperation temporarily to avoid extinction
            // Defect to extract more payoff without risking immediate collapse
            play D (Defect)
        else:
            // Stock safe: cooperate
            play C (Cooperate)
```

---

### Explanation of Components

1. **Start Cooperating**  
   Commence all rounds (except last) by playing C, consuming only stock/(2n) to maintain sustainability.

2. **Detect Defection and Punish Forever ("Grim Trigger")**  
   The first time any player defects (plays D), switch to defecting every round thereafter (except the last). This deters free-riding.

3. **Last Round Defect**  
   In the last round, defect regardless because there is no future to protect; cooperating offers no strategic benefit here.

4. **Stock Safety Threshold**  
   If the stock level drops dangerously low (heuristically below capacity/(2n)), defect temporarily regardless of past history.  
   This recognizes that if stock is too low to sustain cooperative consumption, preserving player payoff may necessitate defecting, as cooperation would mean very low payoffs anyway and risk further depletion.

---

### Behavioral Summary

| Round       | Condition                                         | Action   |
|-------------|-------------------------------------------------|----------|
| First round | Always (no past history yet)                     | Cooperate (C) |
| Intermediate rounds (t < r) | No defection observed AND stock ≥ min_safe_stock  | Cooperate (C) |
| Intermediate rounds (t < r) | No defection observed BUT stock < min_safe_stock  | Defect (D) temporarily |
| Intermediate rounds (t < r) | Any defection observed previously               | Defect (D) forever (punishment)|
| Last round (t = r)          | Always                                         | Defect (D) |

---

### Rationale

- **Sustained cooperation** leads to relatively high, stable payoffs and replenishes the stock, avoiding the tragedy of the commons.
- **Grim trigger punishment** deters defection strongly because losing cooperation forever causes much lower accumulated payoff.
- **Stock safety check** prevents cooperation from driving the resource to extinction when the stock is already too low due to prior defections or overuse.
- **Last round defect** is standard in repeated games since no future punishment or reward is possible.

---

### Notes & Limitations

- Without communication, this strategy assumes opponents can observe defections and thus fear permanent punishment.
- The stock safety threshold can be tuned; capacity/(2n) is a reasonable starting point balancing conservation and payoff.
- If all players adopt this strategy, they mutually cooperate and sustain the resource near capacity, maximizing joint and individual payoffs.
- If others defect, this strategy punishes by defecting forever, signaling non-tolerance for free-riding.

---

# Summary

**"Start cooperating, punish any defection forever, defect in last round, but if resource dangerously low, defect temporarily to avoid collapse."**

This is a classic cooperation-enforcing strategy adapted to the dynamic common-pool resource game context with explicit stock monitoring.
'''

description_COOPERATIVE_29 = '''
Here is a cooperative strategy designed to maintain the common pool resource, maximize collective payoffs, and respond to defections in a measured way. The strategy uses a simple contingent cooperation approach with forgiveness, to encourage cooperation and to sustain resources over the repeated rounds.

---

## Intuition and Goals

- **Cooperate by default** to maintain the stock near capacity, maximizing sustainable payoffs.
- **Detect defections** immediately from other players’ actions.
- **Punish defection briefly** to discourage free-riding.
- **Forgive after one round of punishment** to allow return to cooperation.
- **Adjust in the last round to maximize immediate payoff**, as no future rounds remain to enforce cooperation.

This balances cooperation and deterrence, aligned with the cooperative mindset.

---

## Decision Rules

### Notation

- Let `t` = current round index (1 ≤ t ≤ r)
- Let `H_t` = history of all players' actions in rounds 1,...,t-1
- Let `C_i,t` ∈ {C, D} be player i’s action in round t
- Let `S_t` be the stock level at start of round t (after growth from round t-1)
- Let `defected` be a boolean flag indicating whether any player defected in previous round
- Let `punishment_mode` be a boolean flag indicating whether the strategy is currently punishing defectors

---

### Strategy Description

**Round 1 (t=1):**

- Cooperate (play C) unconditionally because there is no prior history, and cooperation maximizes sustainable payoff starting from full stock.

**Subsequent rounds (2 ≤ t < r):**

- **If in punishment mode (due to defection detected in previous round):**
  - Defect (play D) this round to punish defectors.
  - After this punishment round, **switch back to cooperation** next round regardless of opponent behavior (forgive once).

- **Else (normal cooperative mode):**
  - Inspect the previous round's actions (round t-1).
  - If **any player defected** then enter punishment mode this round by defecting.
  - Else cooperate.

**Last round (t = r):**

- Defect unconditionally to maximize immediate payoff (no future rounds to preserve).

---

### Explanation

- By cooperating initially, we try to keep stock near capacity.
- Punishment is triggered immediately after detecting any defection, switching to defecting for exactly one round.
- A single-round punishment balances deterrence and forgiveness, avoiding endless retaliation cycles and allowing the common pool to recover.
- Defecting in the last round maximizes immediate payoff since no future punishment is possible.

---

## Pseudocode

```python
# Inputs:
# t: current round (1-based)
# r: total number of rounds
# history: list of length (t-1), each element is list of n player actions in that past round ['C' or 'D']

class CooperativeStrategy:
    def __init__(self):
        self.punishment_mode = False  # True means currently punishing defectors
        self.just_punished = False    # True means just completed punishment round

    def decide(self, t, r, history):
        # Last round: always defect to maximize immediate payoff
        if t == r:
            return 'D'

        if t == 1:
            # First round: cooperate unconditionally
            self.punishment_mode = False
            self.just_punished = False
            return 'C'

        # For rounds t > 1:
        if self.punishment_mode:
            # We are currently punishing defectors
            # Defect once, then forgive next round
            self.punishment_mode = False
            self.just_punished = True
            return 'D'

        if self.just_punished:
            # We just punished last round, now forgive and cooperate
            self.just_punished = False
            return 'C'

        # Normal mode: check if any player defected in previous round
        previous_round_actions = history[-1]  # list of n actions from round t-1
        if 'D' in previous_round_actions:
            # Someone defected last round - start punishment this round
            self.punishment_mode = True
            return 'D'

        # Otherwise, cooperate
        return 'C'
```

---

## Summary

| Round         | Condition                                         | Action       |
|----------------|-------------------------------------------------|--------------|
| t = 1          | Always                                          | Cooperate (C)|
| 2 ≤ t < r      | If punishing defectors (punishment_mode=True)  | Defect (D)   |
| 2 ≤ t < r      | If just punished previous round (just_punished=True) | Cooperate (C)|
| 2 ≤ t < r      | If any player defected in previous round        | Defect (D) (start punishment) |
| 2 ≤ t < r      | Else                                            | Cooperate (C)|
| t = r          | Last round                                      | Defect (D)   |

---

## Notes on Cooperative Mindset

- The strategy primarily cooperates and only defects to punish defection.
- Punishment is short and forgiving, preventing endless retaliation cycles.
- Cooperation aims to maintain stock near the sustainable level to maximize everyone's payoffs.
- Defecting last round is rational and standard in repeated games without future rounds.

---

This simple, interpretable strategy should robustly foster cooperation and discourage defection, maximizing long-run welfare consistent with the game’s common pool resource nature.
'''

description_COOPERATIVE_30 = '''
Below is a cooperative strategy tailored to this repeated common-pool resource game given the constraints and assumptions. It emphasizes mutual sustainability and punishment of defection to incentivize cooperation, while addressing edge cases (start, end, and potential exploitation).

---

## Cooperative Strategy: Conditional Cooperation with Gradual Punishment

### Core Idea
- **Start fully cooperative** to maximize long-term joint payoffs and maintain stock near capacity.
- **Punish defections by defecting** in the next round to discourage unilateral overconsumption.
- **Return to cooperation if others cooperate again**, enabling recovery.
- **In the last round, defect** to maximize final payoff since no future repercussions exist.
- **If stock falls dangerously low (near 0), cooperate to help recovery, even during punishment phase.**

---

### Intuition

- Cooperators consume less (stock/(2n)) protecting the resource.
- Defectors consume more, risking depletion.
- Cooperation keeps stock high, maximizing flow.
- Defection leads to stock collapse, harming all.
- By punishing defectors with defect action, they lose incentive to defect repeatedly.
- By forgiving after a punishment round, cycle can resume cooperation if others also cooperate again.
- Last round defection exploits the resource since no future rounds exist.

---

### Notation

- Let t = current round (1 ≤ t ≤ r)
- Let A_i,t = my action at round t (C or D)
- Let actions_{-i,t} = observed actions of other players at round t
- Let stock_t = stock at start of round t (known, as common knowledge)
- Let D_t = indicator: was there any defection by any player in last round? (true/false)
- Let punished_t = indicator: did I punish (defect) last round due to defection by others?
- Let threshold_stock_low = small positive number (e.g., capacity / (4n)) below which stock is considered dangerously low

---

### Decision Rules

**Round 1 (t=1):**  
- Cooperate (C), build trust and maintain initial stock.

**For rounds 2 ≤ t < r:**  
- If stock_t ≤ threshold_stock_low:  
  - Cooperate (C) regardless to aid recovery.  
- Else if defection occurred in previous round (D_{t-1} = true):  
  - If I punished last round (punished_{t-1} = true):  
    - Return to cooperation (forgive and rebuild trust).  
  - Else (I did not punish last round):  
    - Defect (D) this round to punish defectors.  
- Else (no defection last round and stock healthy):  
  - Cooperate (C) to maintain common pool.

**Round r (final round):**  
- Defect (D) to maximize immediate payoff since no future rounds.

---

### Pseudocode

```python
initialize punished = False
threshold_stock_low = capacity / (4 * n)

for t in 1 to r:
    # Observe stock_t and actions_{-i,t-1} if t > 1
    if t == 1:
        action = 'C'  # Start cooperating
        punished = False

    elif t == r:
        action = 'D'  # Last round: defect to maximize payoff

    else:
        # Check if any defection occurred last round (except round 1)
        if t > 1:
            D_last = any(a == 'D' for a in actions_{-i,t-1})
        else:
            D_last = False

        # Stock low check
        if stock_t <= threshold_stock_low:
            action = 'C'  # Help recovery, even if punishing
            punished = False

        else:
            if D_last:
                if punished:
                    # Forgive after one round of punishment
                    action = 'C'
                    punished = False
                else:
                    # Punish defectors by defecting once
                    action = 'D'
                    punished = True
            else:
                # No defection last round, cooperate
                action = 'C'
                punished = False

    yield action
```

---

### Explanation of Key Elements

1. **Initial cooperation:**  
   Encourages collective sustainable behavior from the start.

2. **Punishment of defection:**  
   Detects if any player defected last round and defects in the next round to reduce stock and hence payoff for defectors in retaliation.

3. **Forgiveness:**  
   After one punishing round, returns to cooperation if defection ceases. This avoids endless cycles of retaliation and allows recovery.

4. **Stock threshold check:**  
   If the resource is close to depletion, cooperate regardless of punishment to help restore the stock, preventing collapse.

5. **Last round defection:**  
   Exploits the resource in the last round since there's no future cost.

---

### Why this strategy promotes cooperation

- Cooperative payoffs maintain the stock near capacity, yielding stable and relatively high payoffs.
- Defection triggers punishment, making defection costly.
- Forgiveness prevents permanent breakdown of cooperation.
- Recognizing low stock avoids resource extinction and payoff loss.
- Last round defection is standard in finitely repeated games.

---

### Summary

This conditional cooperation strategy with measured punishment and forgiveness is designed to:

- Maintain the common pool resource near capacity.
- Prevent destructive overconsumption.
- Recover from mistakes or accidental defections.
- Maximize long-run payoffs through sustainable behavior.
- Acknowledge and rationally exploit the last round.

It requires no explicit communication beyond observing actions and stock, uses only available information, and is robust against unilateral defection attempts by others.
'''

description_COOPERATIVE_31 = '''
**Cooperative Strategy Design for the Common Pool Resource Game**

---

### Strategy Overview

This strategy aims to maximize long-term collective payoff by maintaining the common pool stock near its sustainable maximum to ensure high, stable payoffs for all players over all rounds. It seeks to:

- **Cooperate (C)** initially and as long as others do,
- **Defect (D)** only as a punitive measure to discourage unilateral defection,
- Use **forgiveness** and attempts to return to cooperation after punishment phases,
- Recognize the **final round** and defect to maximize short-term payoff without harming future payoffs,
- Employ **stock-sensitive thresholds** to detect when defection has forced stock below sustainable levels, adjusting behavior accordingly.

---

### Key Intuition Points

- Cooperation consumes less per player (stock/(2n)), leaving more stock to regrow.
- Defection consumes more (stock/n), risking stock depletion and reduced future payoffs.
- Maintaining the stock around capacity maximizes total sustainable returns.
- Mutual cooperation yields better total payoff over time than mutual defection.
- Without communication, cooperation is fragile; detect defection quickly and punish to discourage it.
- Punishment lasts one round (to signal displeasure), then attempt cooperative restoration.
- In the final round, only the immediate payoff matters, so defect to maximize harvest.

---

### Notation and Inputs per Round t

- \( t \in \{1, \ldots, r\} \)
- Observed actions of all players in previous round: \( \text{actions}_{t-1} = [a^{(1)}_{t-1}, a^{(2)}_{t-1}, \ldots, a^{(n)}_{t-1}] \) (empty if \( t=1 \))
- Observed stock at start of round \( t \): \( S_t \)
- Player’s own previous action \( a_{t-1} \)
- Parameters: \( n, r, \text{capacity} \)

---

### Decision Rules (Pseudocode)

```python
# Cooperative Strategy pseudocode for player i in round t

def cooperative_strategy(t, S_t, history_actions):
    # Parameters:
    # n, r, capacity: known globally
    # history_actions: list of previous rounds actions for all players; empty at t=1
       
    # Constants
    COOPERATE = 'C'
    DEFECT = 'D'
    
    # Helper functions
    def all_cooperated_prev_round():
        # Returns True if all players cooperated in previous round
        return all(a == COOPERATE for a in history_actions[-1])
        
    def defected_players_prev_round():
        # Returns list of player indices who defected in previous round
        return [idx for idx, a in enumerate(history_actions[-1]) if a == DEFECT]
    
    def num_defectors_prev_round():
        return len(defected_players_prev_round())
    
    def stock_low_threshold():
        # Define threshold below which stock is considered critically low
        # Set conservatively at 50% capacity; can be tuned
        return capacity * 0.5
    
    # --- Strategy Logic ---
    
    # 1. First Round: Cooperate unconditionally
    if t == 1:
        return COOPERATE
    
    # 2. Final Round: Defect to maximize immediate payoff
    if t == r:
        return DEFECT
    
    # 3. If previous round was all cooperation and stock is healthy, cooperate
    if all_cooperated_prev_round() and S_t >= stock_low_threshold():
        return COOPERATE
    
    # 4. If there were defectors last round (detected defection):
    #    Punish by defecting for exactly one round
    #    Then attempt to return to cooperation if stock recovers
    if num_defectors_prev_round() > 0:
        # If I defected last round as punishment, now try to forgive and cooperate if stock ok
        if t > 1 and history_actions[-1][i-1] == DEFECT:  
            # Punishment round done, forgive
            if S_t >= stock_low_threshold():
                return COOPERATE
            else:
                # Stock low: continue defecting to get immediate payoff in short run
                # but this is exceptional; can also cooperate to allow growth
                return DEFECT
        
        # Otherwise, defect to punish
        return DEFECT
    
    # 5. If stock is critically low due to past overharvesting,
    #    defect in attempt to increase personal immediate payoff (short term greed)
    #    or cooperate to help recovery?
    #    Here, cooperatively choose to cooperate to allow recovery,
    #    risking short term loss for better long term
    if S_t < stock_low_threshold():
        return COOPERATE
    
    # Default fallback: cooperate
    return COOPERATE
```

---

### Explanation

- **Round 1:** Cooperate immediately to build trust and maintain high stock.
- **Rounds 2 to r-1:**
  - Continue cooperating if all players cooperated and stock is above half capacity.
  - If any player defected last round, respond by defecting once (punishment), signaling disapproval.
  - After punishment round, forgive and return to cooperation if stock is sufficiently healthy.
  - If stock is very low (below 50% capacity), cooperate to allow stock to recover rather than defecting further and driving collapse.
- **Final round \( r \):** Defect, maximizing immediate payoff since no future rounds follow.

---

### Edge Case Handling

- **First round:** Always cooperate to establish cooperative equilibrium.
- **Last round:** Always defect, exploiting the end game effect.
- **Single defection after cooperation:** Punish unilaterally once to deter defection.
- **Multiple sequential defections:** Strategy cooperates in recovery rounds to restore stock; may have extended defection if stock is too low (but strategy favors cooperation).
- **Stock depletion:** Avoid cooperatively further depletion; prefer cooperation to allow regrowth.
- **No communication or coordination:** Detect defection solely via actions observed; rule-based punishment avoids need for extra signals.

---

### Summary

This is a **"conditional cooperation with one-round punishment and forgiveness" strategy tied to stock health** designed to sustain cooperation and high collective payoffs over repeated play, while deterring selfish defection. It gracefully handles the last round incentive to defect, protecting future payoffs in interim rounds.

---

If you want, I can also provide a clean, concise prose description suitable for writeup or presentation. Would you like that?
'''

description_COOPERATIVE_32 = '''
Below is a carefully designed cooperative strategy for the described Common Pool Resource Game. It aims to sustain the resource while balancing short-term gains and long-term outcomes, aligning with a cooperative mindset under the given informational constraints.

---

## Cooperative Strategy: "Conditional Cooperation with Forgiveness and Endgame Defection"

### Intuition

- **Goal:** Sustain the common stock near capacity to maximize long-term payoffs for everyone.
- **Cooperation:** All players consume cautiously—each plays **C** (consume stock/(2n))—to avoid exhausting the resource.
- **Defection as Punishment:** If any player defects (**D**) in the previous round(s), **punish** by defecting until the stock replenishes.
- **Forgiveness:** If the stock recovers sufficiently and last round’s defectors repent (cooperate), return to cooperation.
- **Endgame (Final round):** No incentive to cooperate (since no future retaliation); defect to maximize final round payoff.
- The strategy is **trigger-based**—it conditionally punishes defections, but tries to restore cooperation quickly when possible.

---

### Parameters and Definitions

- Let:
  - n = number of players
  - r = total rounds
  - capacity = maximum stock level
  - current_round = the round currently being played (starting at 1)
  - S_t = stock at the start of round t (known to all)
  - history = list of all players' past actions (e.g., actions in round t-1)
- Thresholds:
  - **cooperation_stock_threshold** = 0.8 × capacity (80% capacity)
    - Stock level above which cooperation is stable and preferred
  - **punish_recovery_threshold** = 0.9 × capacity (90% capacity)
    - Stock level at which punishment ends and cooperate phase resumes

---

### High-Level Decision Rules

1. **Round 1 (Initial Round):**
   - Cooperate (play C).

2. **Rounds 2 to r - 1 (Intermediate Rounds):**
   - Check previous round actions of *all* players:
     - If **all cooperated (all played C):**
       - If current stock S_t ≥ cooperation_stock_threshold, **cooperate**.
       - Else if S_t < cooperation_stock_threshold, **cooperate cautiously** (still play C; this scenario implies slow recovery).
     - If **any player defected (played D):**
       - Enter punishment phase: **defect** this round to punish defectors.
       - Continue defecting every subsequent round until stock recovers to ≥ punish_recovery_threshold.
     - Once stock recovers ≥ punish_recovery_threshold, **return to cooperation**.

3. **Round r (Final Round):**
   - Defect regardless of history to maximize immediate payoff (no future punishment possible).

---

### Pseudocode

```python
def cooperative_strategy(current_round, r, n, capacity, S_t, history):
    # Extract previous round actions (if any)
    if current_round == 1:
        # Always start cooperatively
        return 'C'
    
    prev_actions = history[current_round - 2]  # zero-indexed list of actions of all players
    
    cooperation_stock_threshold = 0.8 * capacity
    punish_recovery_threshold = 0.9 * capacity
    
    # Final round: defect unconditionally
    if current_round == r:
        return 'D'
    
    # Check if any defected in previous round
    defected_last_round = any(action == 'D' for action in prev_actions)
    
    if defected_last_round:
        # Punishment phase - defect until stock recovers sufficiently
        if S_t < punish_recovery_threshold:
            return 'D'
        else:
            # Stock has recovered, return to cooperation
            return 'C'
    else:
        # No defection observed
        if S_t >= cooperation_stock_threshold:
            return 'C'
        else:
            # Stock is low but no defection detected - still cooperate to encourage recovery
            return 'C'
```

---

### Explanation of Strategy Logic

- **Initial Cooperation:** All start by cooperating to preserve the resource.
- **Monitoring & Punishment:** If a defection is observed, players punish by defecting to impose a cost on defectors and discourage over-consumption.
- **Stock-Based Forgiveness:** Punishment is lifted only once the common stock recovers near full capacity; this prevents endless defection cycles.
- **Sustaining Cooperation:** Players return to cooperation as soon as conditions are good, incentivizing others to do the same.
- **Defection in Last Round:** Since future rounds do not exist, defecting maximizes the last round’s payoff without risking future retaliation.

---

### Cooperative Mindset Justification

- Maximizes joint payoffs by maintaining the resource near capacity through cooperative consumption.
- Punishment deters greedy behavior that would deplete the resource.
- Forgiveness based on stock recovery helps restore cooperation quickly after mistakes or betrayals.
- Conditional defection in reaction to others’ defection is a credible threat, encouraging stable cooperation unless disrupted.
- Final round defection is a standard rational deviation but does not undermine earlier cooperation incentives.

---

### Summary

This "Conditional Cooperation with Forgiveness and Endgame Defection" strategy:

- Cooperates when others cooperate and stocks are healthy.
- Punishes defectors to protect the resource.
- Forgives defection when stock recovers, returning to cooperation.
- Defects only in the final round.
- Requires no communication or special coordination beyond observing history and stock levels.

This balances strategic incentives with a cooperative mindset to sustain the common pool resource and maximize payoffs over the repeated game.
'''

description_COOPERATIVE_33 = '''
Below is a cooperative strategy designed to maximize long-term collective payoffs by sustaining the common pool resource, while also responding prudently to observed defections. It assumes rational, self-interested opponents and uses reputation and punishment to enforce cooperation, but with forgiveness to avoid permanent collapse.

---

### Intuition and Goals

- **Primary goal:** Sustain the stock near its capacity for as many rounds as possible to maximize everyone's total payoff.
- **Key insight:** Cooperation (C) by all players maintains the stock at or near capacity due to moderate consumption, allowing maximal long-run payoffs.
- **Defection (D) gains short-term individual advantage but depletes the stock, hurting all players including the defector in the future.
- **Because no communication or explicit coordination is possible, we use observed actions to infer opponent behavior and drive conditional cooperation.**

---

### Overall Strategy Summary

| Round type          | Decision Rule                                                | Rationale                               |
|---------------------|--------------------------------------------------------------|----------------------------------------|
| First round (t=1)   | Cooperate (C)                                                | Assume cooperation initially to start on best collective path |
| Intermediate rounds (1 < t < r) | Cooperate if *everyone cooperated* in previous round; otherwise defect once as punishment | Conditioned cooperation supports mutual trust and punishes free-riding |
| Last round (t=r)    | Defect (D)                                                  | No future retaliation possible, so exploit final round for short-term payoff |
| Additional rules:   | Forgive defections after 1 punishment round if cooperation resumes | Avoid endless punishment cycles that hurt everyone |

---

### Detailed Decision Rules

Let `t` = current round number (1 ≤ t ≤ r),  
Let `history` = record of previous rounds' actions by all players.

**Notation**:  
- `actions_{t-1}` = vector of actions taken by all players in previous round  
- `allCooperate_{t-1}` = True if every player played C in round `t-1`

**Strategy for player i in round t:**

1. **Round 1:**
   - Play **C**.

2. **Rounds 2 to r-1:**
   - If `allCooperate_{t-1}` is True, play **C**.
   - Else if at previous round you punished defectors by playing D (i.e., you defected at round t-1), and now `allCooperate_{t-1}` is True, then **forgive** by cooperating.
   - Else (someone defected last round and you haven't punished yet), play **D** (punishment).
   
3. **Round r (final round):**
   - Play **D**.

---

### Explanation

- **Start cooperating** because it sets the baseline for mutual benefit.
- **Conditional cooperation**: Continue cooperating only if everyone cooperated last round.
- **Punishment:** If anyone defects, punish by defecting once to signal consequences.
- **Forgiveness:** If after punishment everyone returns to cooperation, forgive by cooperating again. This promotes return to cooperation rather than endless defection cycles.
- **Defect in last round:** No future repercussions, so defecting maximizes payoff for final round.

---

### Pseudocode

```python
def strategy(t, r, history, player_index):
    """
    t: current round (1-based)
    r: total number of rounds
    history: list of dicts with keys 'actions' (list of C/D by players in each previous round)
    player_index: your player index (0-based)
    """
    
    n = len(history[0]['actions']) if history else None
    
    # Helper function to check if all cooperated last round
    def all_cooperated_last_round():
        if t == 1:
            return True  # no prior round
        return all(a == 'C' for a in history[-1]['actions'])
    
    # Helper function to check if punished last round
    def punished_last_round():
        if t <= 2:
            return False  # no previous punishment possible
        # You defected at round t-1 while at least one player defected at round t-2
        return (history[-1]['actions'][player_index] == 'D' and
                any(a == 'D' for a in history[-2]['actions']))
    
    if t == 1:
        # Start by cooperating
        return 'C'
    
    if t == r:
        # Defect on last round to maximize payoff
        return 'D'
    
    # Intermediate rounds logic
    if all_cooperated_last_round():
        # If we punished last round but now everyone cooperated,
        # forgive and cooperate again
        if punished_last_round():
            return 'C'
        else:
            return 'C'
    else:
        # Someone defected last round, punish by defecting once
        return 'D'
```

---

### Edge Cases

- **First round:** Cannot punish or infer past, so cooperate to establish trust.
- **Last round:** Defect because no future retaliation possible.
- **Multiple defectors or repeated defection:** Strategy punishes once per defection cycle and then forgives if cooperation resumes; may tolerate occasional noise or mistakes.
- **If opponents never cooperate:** This strategy devolves to always defecting after first defection, limiting losses.
- **If all play like this strategy:** Stable cooperation at high stock levels is maintained through rounds 1 to r-1.
  
---

### Summary

This strategy is a variant of *Tit-for-Tat* adapted to a structured CPR game with dynamic stock, simultaneous action, and no communication. It:

- Enforces cooperation by cooperating first and rewarding cooperation.
- Punishes defection once to discourage depletion.
- Forgives to permit return to cooperation.
- Defects in last round to maximize payoff.

By stabilizing cooperation, it maximizes long-term collective and individual payoffs through sustainable resource use.
'''

description_COOPERATIVE_34 = '''
Below is a carefully designed cooperative strategy tailored for the Common Pool Resource Game as specified. The strategy aims to sustain the stock near capacity to maximize long-run payoffs for all cooperating players, while explicitly punishing detected defections to discourage free-riding.

---

## Intuition & Goals

- **Maintain high stock levels**: Cooperate to preserve the common pool near its capacity for maximal sustainable payoff.
- **Punish defectors**: Detect defection early and respond with appropriate punishment to reduce their incentive.
- **Forgiveness and recovery**: Allow the pool to recover after punishment and return to cooperation if opponents resume cooperative play.
- **Last round behavior**: Defect optimally in the final round to maximize individual payoff since no future repercussions exist.

---

## Core Principles

1. **Cooperate to consume stock/(2n)** when the game is in cooperative mode and no defection is detected.
2. **Defect (consume stock/n)** in the last round to maximize terminal payoff.
3. **Trigger punishment phase if defection observed** in the previous round by any player (defection here means an action D detected).
4. **During punishment phase, defect** for a fixed number of rounds to reduce cooperators’ incentives to defect.
5. **Return to cooperation after punishment** if no further defection is observed.
6. **Always punish the first detected defection** to signal a credible threat.

---

## Strategy State Variables

- `punish = False` — Are we currently punishing?
- `punish_rounds_left = 0` — How many punishment rounds remain?
- `last_round = r` — Total number of rounds
- `round_number` — Current round index (starting at 1)
- `threshold_defection = any defect observed in previous round?` boolean

---

## Detailed Decision Rules (Pseudocode)

```python
def cooperative_strategy(round_number, history, n, r, capacity, current_stock):

    # Parameters for punishment phase length (tunable)
    PUNISH_LENGTH = 2  # Punish for 2 rounds after defection detected
    
    # Initialize persistent state
    # (In real implementation these would be stored externally)
    persist = get_persistent_state()  # Contains punish, punish_rounds_left
    
    punish = persist.get('punish', False)
    punish_rounds_left = persist.get('punish_rounds_left', 0)
    
    # At round 1: cooperate unconditionally, as no history exists
    if round_number == 1:
        action = 'C'
        persist['punish'] = False
        persist['punish_rounds_left'] = 0
        save_persistent_state(persist)
        return action
    
    # At last round: defect to maximize terminal payoff, since no future rounds exist
    if round_number == r:
        action = 'D'
        # Punishment state is irrelevant after last round
        persist['punish'] = False
        persist['punish_rounds_left'] = 0
        save_persistent_state(persist)
        return action
    
    # Check previous round actions of ALL players
    prev_round_actions = history.get(round_number - 1, {})  # Dict player_id -> action
    
    # Detect if any player defected in previous round (excluding self)
    defect_detected = any(a == 'D' for pid, a in prev_round_actions.items() if pid != 'self')
    
    # Update punishment state machine
    if punish:
        if punish_rounds_left > 1:
            # Continue punishment
            punish_rounds_left -= 1
            persist['punish_rounds_left'] = punish_rounds_left
            # Defect during punishment
            action = 'D'
            save_persistent_state(persist)
            return action
        else:
            # Punishment phase ends this round
            punish = False
            punish_rounds_left = 0
            persist['punish'] = False
            persist['punish_rounds_left'] = 0
            # Return to cooperation unless new defection detected this round (next round checks)
    
    # If no current punishment:
    if not punish:
        if defect_detected:
            # Trigger punishment phase next round
            punish = True
            punish_rounds_left = PUNISH_LENGTH
            persist['punish'] = punish
            persist['punish_rounds_left'] = punish_rounds_left
            # This round is still cooperative (punishment starts next round)
            action = 'C'
            save_persistent_state(persist)
            return action
        else:
            # No defection last round, cooperate
            action = 'C'
            persist['punish'] = False
            persist['punish_rounds_left'] = 0
            save_persistent_state(persist)
            return action
```

---

## Explanation

- **First round**: Cooperate to build trust and preserve stock.
- **Normal rounds**: Cooperate if no one defected last round.
- **Defection detection**: If anyone defects—even once—start punishment *after* the current round.
- **Punishment phase**: Defect for a fixed short period (2 rounds) to lower defectors’ payoffs, signaling that defection is costly.
- **Post punishment**: Return to cooperation if no additional defection detected, enabling recovery of the stock.
- **Final round**: Defect unconditionally to extract maximum payoff as no future rounds remain.

---

## Why This Works

- The sustainable common pool stock is maximized by all cooperating, so long-term cooperative payoffs are highest.
- The punishment deters unilateral defection by reducing defectors’ payoffs.
- The short, fixed punishment avoids endless retaliation, allowing for cooperation to be resumed.
- Defecting only at the last round optimizes individual gain when no future repercussions exist.
- Perfect information allows clear monitoring of defections.
- Without communication or coordination, this "grim-trigger with forgiveness" style approach balances deterrence with cooperation.

---

## Variations / Extensions (For Future Tuning)

- Adjust punishment length depending on pool recovery time.
- Use dynamic punishment severity based on number or severity of defections.
- Use more gradual forgiveness (e.g., multiple cooperative rounds before ending punishment).
- Track defections per player and punish only defectors rather than all.
- Analyze stock trajectories to modulate cooperation intensity dynamically.

---

If you implement the above pseudocode and logic, your agent will credibly cooperate to maintain the resource, respond strongly to defections, and extract maximal cooperative payoffs, all while respecting the game's constraints and information structure.
'''

description_COOPERATIVE_35 = '''
Here is a cooperative strategy design tailored to this game's structure and restrictions. It emphasizes sustaining the common pool and mutual cooperation while protecting against persistent defection.

---

### Cooperative Strategy: "Conditional Sustained Cooperation"

#### Intuition
- Cooperate as long as *everyone* has cooperated in all previous rounds, maintaining the resource near capacity.
- Punish defection by defecting once, then return to cooperation if opponents do — a "forgiving trigger" to sustain cooperation but deter exploitation.
- In the last round, maximize payoff by defecting (standard backward induction logic).
- In early rounds encourage trust by cooperating from the start.
- Use observations of opponents' actions from the previous round to update beliefs.

---

### Decision Rules

**Notation:**
- `r`: total rounds
- `t`: current round (1 ≤ t ≤ r)
- `H_t`: history of all players' actions up to round t-1 (empty for t=1)
- `actions_t`: vector of all players' actions at round t
- `my_action_t`: this player's action choice at round t
- `defection_detected`: Boolean flag indicating if defection has been observed previously
- `punishment_round`: Boolean indicating if the current round is a punishment retaliation round

---

#### Pseudocode

```python
initialize:
  defection_detected = False
  punishment_round = False

for round t in 1 to r:
  
  if t == r:
    # Last round: defect to maximize immediate payoff
    my_action_t = 'D'
    continue

  # For rounds before the last:
  if t == 1:
    # Round 1: start cooperatively
    my_action_t = 'C'
    continue

  # From round 2 onward, analyze prior round actions
  previous_actions = actions_(t-1)  # actions of all players in round t-1

  # Detect defection(s) (any player playing 'D' last round)
  if any(action == 'D' for action in previous_actions):
    defection_detected = True

  # Strategy decision:
  if punishment_round:
    # Punishment round: defect to discipline defectors
    my_action_t = 'D'
    # After punishing, forgive and return to cooperation next round
    punishment_round = False
    defection_detected = False  # reset flag after punishment
  else:
    if defection_detected:
      # Defection detected last round, enter punishment round this round
      punishment_round = True
      my_action_t = 'D'
    else:
      # No defection detected, cooperate to sustain resource
      my_action_t = 'C'
```

---

### Explanation of the Logic

1. **First Round (t=1):**  
   Cooperate unconditionally to start building trust and maintain the resource.

2. **Rounds 2 to r-1:**  
   - If all players cooperated last round, cooperate this round.  
   - If any player defected last round, punish by defecting **once** in the current round to disincentivize defection.  
   - After the single punishment round, return to cooperating. This forgiveness helps re-establish cooperation if the opponent reacts rationally.

3. **Last Round (t=r):**  
   Defect to maximize immediate gain since there is no future interaction to incentivize cooperation (backward induction).

---

### Why This Is Cooperative and Stable

- By cooperating whenever no defection is detected, the strategy helps maintain the resource near capacity since all cooperative consumption is smaller than defection consumption.
- Immediate, but limited, punishment deters exploitation: defectors face a cost next round.
- Forgiveness allows the group to sustain cooperation over multiple rounds, avoiding permanent collapse.
- Defection only in the final round is standard reasoning to maximize payoff when no future retaliation is possible.

---

### Handling Edge Cases

- **If the stock falls below capacity:**  
  The strategy does not explicitly use stock size in decision making but relies on monitoring actions. Because cooperation consumes less and leads to stock regeneration, mutually cooperating players naturally preserve the resource.
  
- **If multiple defectors appear:**  
  The punishment is per defection round, not per player defecting; this is simpler and cooperative detection of any defection triggers punishment from the whole group.
  
- **If opponents behave randomly or constantly defect:**  
  The strategy punishes after each defection and tries to return to cooperation if the defection stops, maintaining stability as much as possible given opponents' choices.

- **No communication:**  
  The strategy uses only public knowledge (previous actions), no signaling or coordination is needed.

---

### Summary

| Round        | Condition                       | Action        |
|--------------|--------------------------------|---------------|
| t=1          | Always                        | Cooperate (C) |
| 1 < t < r    | No defection last round       | Cooperate (C) |
| 1 < t < r    | Defection detected last round | Defect (D) *once* punish round, then cooperate |
| t = r        | End game                      | Defect (D)    |

---

This strategy balances cooperation with minimal punishment to sustain a high common stock and maximize long-run payoffs for all.
'''

description_COOPERATIVE_36 = '''
Below is a detailed cooperative strategy for this Common Pool Resource (CPR) game designed to foster mutual cooperation, stabilize the stock, and maximize long-run payoffs under the constraints and assumptions of the repeated setting.

---

## Strategy Overview

The strategy is a **conditional cooperation strategy with forgiveness and monitoring** based on observed past actions and stock dynamics. The goal is to keep all players cooperating (each choosing **C**) to sustain the resource near capacity and maximize total payoffs over the full horizon.

---

## Key Intuition

- **Cooperate (C)** to consume conservatively: each player takes stock/(2n), allowing the stock to replenish and sustain.
- **Defect (D)** yields immediate higher payoff in the current round but reduces the stock greatly, harming future payoffs.
- **Punish defectors** by defecting in the next round to deter exploitation.
- **Forgive and return to cooperation** if everyone resumes cooperating, to avoid permanent collapse due to a single defection.
- **Adjust behavior near last round** (no future) to avoid punishing cooperation unnecessarily.

---

## Detailed Decision Rules

### 1. Initial Round (t=1)

- **Action:** Cooperate (C)

Rationale: Start with cooperation to establish trust and build stock.

---

### 2. Intermediate Rounds (1 < t < r)

At round `t`, observe history up to round `t-1`:

- Let `PastActions` = vector of all players' actions in round `t-1`.
- Let `Stock_t` = current stock available at round `t`.
- Let `Defectors_t-1` = number of defectors who played D in round `t-1`.

**Rule:**

- **If no defection detected in previous round** (`Defectors_t-1 = 0`):
  - Cooperate (C) to maintain cooperation and maximize sustainable payoff.
  
- **If defectors detected (`Defectors_t-1 > 0`)**:
  - **Punish with Defect (D)** in the current round regardless of your previous action.
  - Aim: reduce immediate payoff for defectors and signal retaliation.

- **If stock is critically low** (e.g. `Stock_t < capacity / (2n)`):
  - Always cooperate (C) as defecting would further risk resource collapse.
  - Note: This is a safeguard even during punishment phases — resource cannot sustain high exploitation.
  
---

### 3. Forgiveness and Returning to Cooperation

- After a **punishment round**, if everyone cooperated in the punishment round (i.e., all players chose C and no new defections):
  - Return to cooperation from the next round.
  
This makes the strategy **forgiving**: players get a chance to reestablish cooperation after a single defection/punishment cycle.

---

### 4. Final Round (t = r)

- Since there is no future punishment possible, **defect (D)**.

Rationale: In last round, defection yields higher immediate payoff without future cost.

---

## Summary in Pseudocode

```python
# Inputs:
# t: current round (1 to r)
# r: total rounds
# n: number of players
# capacity: max sustainable stock
# Stock_t: current stock at start of round t
# PastActions: actions of all players in round t-1, list length n
#   (for t=1, PastActions is None)

def cooperative_strategy(t, r, n, capacity, Stock_t, PastActions):
    # Initial round: cooperate
    if t == 1:
        return "C"

    # Last round: defect
    if t == r:
        return "D"

    # At other rounds:
    # Count defectors in previous round
    Defectors_prev = sum(1 for a in PastActions if a == "D")

    # Condition 1: Stock critically low?
    if Stock_t < capacity / (2 * n):
        # Save stock by cooperating regardless
        return "C"

    # Condition 2: No defection last round -> cooperate
    if Defectors_prev == 0:
        return "C"

    # Condition 3: Defection detected last round -> punish defect with defect
    # (Retaliate but still obey critical stock minimum)
    else:
        return "D"
```

---

## Additional Notes

- **Stock threshold `capacity / (2n)`** is a conservative heuristic ensuring the resource is not driven too low.
- The punishment phase is strict but short-lived: one round of defecting after observing defection, then returning to cooperation if possible.
- This strategy is **trigger-based** but includes explicit forgiveness and resource safety conditions.
- Since all players observe all past actions and payoffs, mutual cooperation can be sustained.
- By defecting in the last round, the strategy anticipates rational end-game behavior to maximize own payoff.

---

## Why this strategy is cooperative

- It promotes mutual cooperation whenever possible.
- It deters unilateral defection through credible, immediate punishment.
- It avoids needless escalation by forgiving after punishment if players return to cooperation.
- It respects resource sustainability by cooperating when stock is low.
- It aligns incentives to preserve the resource over multiple rounds, maximizing overall payoffs.

---

If every player enters this strategy, it leads to stable cooperation at the **high stock level** near capacity throughout the game, with maximum group and individual payoffs (except last round where defecting is inevitable).
'''

description_COOPERATIVE_37 = '''
Below is a carefully designed cooperative strategy for the described Common Pool Resource game. It is centered on mutual cooperation to sustain the resource and maximize collective payoffs, with punishment and forgiveness to handle defections, and special rules for the last round.

---

## Cooperative Strategy: "Sustained Reciprocity with Grace"

---

### Intuition and Rationale

- **Cooperation pays off** because jointly consuming at the *cooperative rate* (C action) sustains the resource at high levels, yielding stable long-term payoffs.
- **Defection causes immediate higher payoff but depletes the resource**, harming everyone eventually.
- To enforce cooperation, the strategy **punishes defections by defecting for a fixed number of rounds**, lowering the incentive to defect.
- To avoid endless punishment cycles and enable return to cooperation, the strategy includes **forgiveness**: if all players cooperate after punishment, revert to cooperating.
- The **last round is special**, since no future punishment applies, so defecting on the last round can yield a higher payoff without future cost. However, if others cooperate on last round, cooperating yields a positive payoff without risking reputation.
- The strategy is **memory-based**: it observes the full history of all players' past actions, thanks to perfect information assumption.
- The strategy does **not assume coordination or communication** beyond past actions.

---

### Parameters for the Strategy

- Let:
  - `n = number of players`
  - `r = number of rounds`
  - `capacity = max stock level`
- Set a **punishment length parameter**: e.g., `punish_rounds = 2` (punish defectors for 2 rounds)
- Maintain a state variable:
  - `punish_timer = 0` (counts down number of rounds left to punish after detecting defection)
- Maintain a history of all players’ actions:
  - For round t, `actions[t] = [a_1, a_2, ..., a_n]`, where `a_i` in {C, D}

---

### Decision Rules Overview

At round t (1 ≤ t ≤ r), for player i, the strategy selects action `A_i,t` as follows:

1. **Round 1 (t=1):** Cooperate

2. **If `punish_timer > 0` (currently punishing defectors):** Defect, and decrement `punish_timer` by 1.

3. **Else (not punishing):**
   - Check history rounds 1 to t-1:
     - If **any player defected** in previous rounds, set `punish_timer = punish_rounds` and defect this round.
     - Else (if all cooperated so far):
       - Cooperate, **except in last round (t=r)** where defecting yields higher immediate payoff without future cost; decide below.

4. **Last round (t = r):**
   - If not punishing (punish_timer = 0), defect (greedy last-round defection).
   - Otherwise defect (still punishing).

---

### Full Pseudocode for Player i at Round t:

```pseudo
input: t, r, n, capacity, history_actions[1..t-1][1..n], punish_timer, punish_rounds

if t == 1:
    action = C
    return action

if punish_timer > 0:
    punish_timer = punish_timer - 1
    action = D
    return action

# Check if any player defected before
any_defection_before = false
for round_index in 1..(t-1):
    for player_j in 1..n:
        if history_actions[round_index][player_j] == D:
            any_defection_before = true
            break
    if any_defection_before:
        break

if any_defection_before:
    punish_timer = punish_rounds - 1  # -1 because punishing this round
    action = D
    return action

# No past defection, not punishing, check last round special case
if t == r:
    # Greedy defect on last round since no future punishment is possible
    action = D
    return action

# Otherwise, cooperate
action = C
return action
```

---

### Explanation of Design Choices

- **First round cooperation:** Establishes baseline cooperation.
- **Immediate detection of any defection:** Enforces collective discipline by starting punishment as soon as a defection is observed.
- **Fixed-length punishment:** Defect for `punish_rounds` rounds to impose a measurable cost on defectors, then forgive.
- **Forgiveness via timer:** After punish_timer expires, return to cooperating, allowing restoration of cooperation if others do so.
- **Last round defection:** Since no future rounds mean no punishment threat, defecting yields the highest immediate payoff, maximizing endgame gain.
- **Graceful return to cooperation:** Response to defections is severe but bounded, enabling eventual restoration of cooperation rather than endless retaliation.
- **No assumptions about others' strategy:** The method reacts purely to observed past actions, making it robust against arbitrary opponents.

---

### Potential Extensions / Robustness Notes

- The punishment length `punish_rounds` can be tuned; longer punishments can deter defecting more strongly but risk long-term payoff loss.
- In more complex versions, you could track which players defected to punish selectively, but this is not specified or required here.
- The strategy relies on **perfect monitoring**: observing all actions each round accurately.
- If a player defects only in the last round posing no punishment risk, this strategy does not respond since it cannot punish post-game. This edge is exploited to maximize last-round payoff.
- The strategy might be exploited by a player who defects every last round, but this is a rational tradeoff given the game structure.

---

## Summary

| Round                  | Action                         | Rationale                                 |
|------------------------|--------------------------------|-------------------------------------------|
| 1 (initial)             | Cooperate (C)                  | Signal cooperation, build trust           |
| Any round after defection detected | Defect (D) for `punish_rounds` rounds | Punish defectors                           |
| Rounds with no defection seen | Cooperate (C)               | Maximize sustained resource and payoffs  |
| Last round (r)          | Defect (D) if not punishing    | Maximize final one-shot payoff            |

This strategy aligns strongly with cooperative principles by stabilizing cooperation, punishing defection but forgiving, and sustaining the resource stock over time to maximize collective payoffs.

---

**End of Strategy Description**
'''

description_COOPERATIVE_38 = '''
Below is a fully cooperative strategy designed to foster mutual cooperation while being robust to defections by others. It follows a conditional cooperation pattern inspired by “trigger strategies” and “forgiveness,” explicitly adapted to this game’s parameters and payoff structure.

---

## Cooperative Strategy Description

### Intuition

- Start by cooperating to maintain the resource and build trust.
- Continue cooperating as long as **all** players cooperated in the previous round.
- If any player defects, punish by defecting for a limited number of rounds to discourage exploitation.
- Return to cooperation after the punishment phase ends (forgiveness), allowing the group to restore sustainability.
- In the last round, defect to maximize final payoff because no future punishment applies (backward induction).
- This strategy balances sustainability (cooperation) with self-protection (punishment), thereby promoting long-term cooperation and maximizing total payoffs.

---

### Parameters for the Strategy

- `punishment_length`: Number of rounds to punish after detecting defect(s). Set to a small constant (e.g., 1 or 2 rounds) to avoid endless retaliation and encourage eventual cooperation.
  
  (Example: `punishment_length = 2`)

- `round`: current round index, from 1 to r.

- `last_round = r`.

- `history`: full history of observed actions of all players in all prior rounds.

- `observed_defection_in_last_round`: boolean indicator if anyone else defected last round.

---

### Decision Rules

1. **Round 1 (Initial round)**:  
   - Play **Cooperate (C)** unconditionally.

2. **Round t (2 ≤ t < last_round)**:  
   - If punishment ongoing (i.e., within `punishment_length` rounds after last defect) → Defect (D).  
   - Else if all players cooperated in round t-1 → Cooperate (C).  
   - Else → Start (or restart) punishment phase: Defect (D).

3. **Round last_round**:  
   - Defect (D) unconditionally to maximize immediate payoff (no future rounds to punish or reward).

---

### How to Detect Defection and Track Punishment

- After round t-1, examine all other players’ actions:  
  If any player action == D → record defection detected

- Maintain a counter `punishment_timer`:  
  - Set to `punishment_length` when defection detected  
  - Decrement by 1 each subsequent round until zero

- Only cooperate if `punishment_timer == 0` and no defections in last round

---

### Pseudocode

```python
# Initialization
punishment_length = 2
punishment_timer = 0

def strategy(round, history, n, r, capacity):
    global punishment_timer

    last_round = r

    # Helper to get actions in round (round_index)
    def get_actions(round_index):
        # history structure assumed: history[round_index-1] is a list of all players' actions
        return history[round_index - 1] if round_index > 0 else []

    if round == 1:
        # Initial round: cooperate
        return 'C'

    elif round == last_round:
        # Last round: defect unconditionally
        return 'D'

    else:
        # Check if punishment ongoing
        if punishment_timer > 0:
            # Continue punishment
            punishment_timer -= 1
            return 'D'

        # Otherwise, check last round actions
        last_actions = get_actions(round - 1)

        # Detect defection by anyone else (excluding self if you know identity)
        # Since no player ID for self given, we assume symmetric, so defect by anyone counts
        if 'D' in last_actions:
            punishment_timer = punishment_length - 1  # counting down starting next round
            return 'D'

        # All cooperated last round, cooperate now
        return 'C'
```

---

## Summary

- **Cooperate beginning to end, except when punishing detected defections or defecting last round.**  
- **Only punish briefly (e.g., 2 rounds) to avoid endless cycles of retaliation.**  
- **Defect last round to maximize payoff since no future retaliation possible.**  
- This strategy is straightforward, self-enforcing, and encourages group-level sustainable resource use.

---

## Edge Cases

- **First Round:** Always cooperate, signaling good faith.

- **Last Round:** Defect regardless, since no incentive to sustain cooperation with no future.

- **Immediate Defection:** If opponents defect immediately, retaliate by defecting for punishment_length rounds.

- **Multiple defections:** As long as any defection detected last round, punish collectively.

- **Recovery after Punishment:** After punishment phase ends and no new defections, resume cooperation.

---

Let me know if you want me to adjust or extend this strategy with more complex beliefs, stochastic forgiveness, or other enhancements!
'''

description_COOPERATIVE_39 = '''
Below is a detailed cooperative strategy design that aligns with the common pool resource game’s structure and incentives. It aims to maximize sustainable total payoffs by preserving the resource while punishing defection if needed, yet forgiving to potentially restore cooperation.

---

## Intuition Behind the Strategy

- **Cooperate by default**: To keep the resource sustainable, cooperation (each player consumes stock/(2n)) is best.
- **Detect defection promptly**: If someone defects (consumes more), the shared resource depletes faster, harming everyone.
- **Punish defectors by defecting as retaliation**: This lowers defectors’ payoffs to deter selfish behavior.
- **Forgive to restore cooperation**: If defectors return to cooperating, resume cooperation to avoid permanent mutual harm.
- **Handle end game carefully**: In the last round, incentives to defect are dominant (no future punishment), so defect there.
- **React to resource depletion**: If the resource is near collapse, cooperation is enforced strictly since defecting risks zero future payoffs.

---

## Strategy Description

### Notation:
- Round: t ∈ {1, …, r}
- Player’s own action at round t: a_i,t ∈ {C, D}
- Observed joint actions at round t (including all players): A_t = (a_1,t, …, a_n,t)
- Historical actions up to round t-1: H_{t-1}
- Current stock before round t: S_t
- Capacity: given constant
- Thresholds:
  - **Resource low stock threshold**: L = capacity / 4 (adjustable; signals danger of collapse)
- Player index: i (self)

---

### 1. Initialization (Round 1)

- Cooperate: a_i,1 = C  
  (Start cooperatively, assuming others will too)

---

### 2. General Rule for rounds 1 ≤ t < r (not last round)

#### Step A: Check stock level S_t before action

- If S_t < L (stock low), **cooperate strictly** (consume conservatively).
- Else, proceed to Step B.

#### Step B: Assess others’ behavior in previous rounds

- If all players cooperated consistently in past round (t-1), cooperate again.
- If any player defected in past round (t-1), **retaliate defect** this round.
- Exception: If you defected last round as retaliation, and in (t-1) others all cooperated, **forgive and cooperate** this round.

**Summary of trust states:**

| Prior round defectors? | Your previous action | Your current action          |
|-----------------------|---------------------|-----------------------------|
| No                    | C or D              | C (cooperate)               |
| Yes                   | C                   | D (retaliate defect)        |
| Yes                   | D (you defected)     | C if others cooperated last round (forgive), else D (continue defect) |

---

### 3. Last Round (t = r)

- Defect unconditionally: a_i,r = D  
  (No future punishment possible; highest immediate payoff incentive)

---

### 4. Edge Cases / Special Considerations

#### Resource Collapse Risk
- If repeatedly defecting causes stock to fall below L quickly, cooperating strictly helps:
  - In any round, if S_t < L, cooperate to avoid zero future resource.

#### Handling Sporadic Defections (Noise)
- Forgiveness step allows to return to cooperation after a single round of defection.
- This prevents endless cycles of punishment.

---

## Pseudocode

```python
def cooperative_strategy(t, r, S_t, capacity, history, player_index):
    """
    t: current round (1-based)
    r: total rounds
    S_t: current stock before round t
    capacity: maximum sustainable stock
    history: list of dicts [{player_i_action, all_actions}, ...] for rounds < t
    player_index: self identifier
    """
    L = capacity / 4  # low stock threshold
    
    if t == 1:
        # First round, cooperate
        return 'C'
    
    if t == r:
        # Last round, defect unconditionally
        return 'D'
    
    # Check stock level risk
    if S_t < L:
        # Critical stock level, cooperate strictly to allow regrowth
        return 'C'
    
    # Analyze previous round actions
    last_round_actions = history[-1]['all_actions']  # list of length n
    
    defection_occurred = any(a == 'D' for a in last_round_actions)
    my_last_action = history[-1]['player_actions'][player_index]
    
    # Trust-punish-forgive logic
    if not defection_occurred:
        # No defection last round -> cooperate
        return 'C'
    
    else:
        # Defection occurred in last round
        if my_last_action == 'C':
            # I cooperated, others defected -> punish by defecting
            return 'D'
        else:
            # I defected last round in retaliation
            # Check if all others cooperated last round (excluding self)
            others_last_actions = [a for idx, a in enumerate(last_round_actions) if idx != player_index]
            if all(a == 'C' for a in others_last_actions):
                # Forgive and cooperate
                return 'C'
            else:
                # Continue defecting in punishment
                return 'D'
```

---

## Summary

- **Cooperate initially**, to promote stock sustainability and mutual benefit.
- **Punish defectors immediately** by defecting next round to discourage exploitation.
- **Forgive cooperators** promptly to restore cooperation and avoid perpetual mutual harm.
- **Monitor stock** carefully and **cooperate strictly if stock is low** to prevent collapse.
- **Defect in the final round** since no future retaliation is possible.
- **Use only observed actions from prior rounds** (no assumptions about communication or shared protocol).

This strategy embodies a **conditional cooperation** approach with **forgiveness** and **stock-aware caution**, consistent with sustained collective welfare in a repeated commons dilemma with dynamic resource updates. It balances incentives to promote cooperation while defending against exploitation and collapsing the resource.
'''

description_COOPERATIVE_40 = '''
Here is a cooperative strategy designed for this Common Pool Resource game that aims to sustain the resource and maximize collective long-term payoffs by mutual cooperation, while also being robust to some defection and endgame behavior.

---

## Overview of the Strategy

The key idea:  
**Start fully cooperative, continue cooperating as long as all other players cooperate, but punish defection by defecting once as a warning. If defection persists, return to cooperation to avoid permanent collapse. In the final round, defect to maximize short-term payoff (endgame defect).**

---

## 1. Decision Rules

### Notation:
- Let **t ∈ {1,...,r}** be the current round.
- Let **H_{t-1}** be the observed history of actions in all previous rounds.
- Let **A_j^{t-1}** be the action of player j in round t-1.
- Let **Defectors_{t-1} = { j | A_j^{t-1} = D }** be the set of defectors in previous round.
- Let **DefectionCount_j** count how many times player j defected overall.
- Let **PunishmentActive** be a state variable indicating whether this player is currently punishing defectors.
- Let **Capacity, n, r** be known parameters.
- Let **Stock S_t** be the stock at the start of round t (common knowledge).

---

### Decision Logic in Round t (for player i):

**If t == r (last round):**  
- Defect (D) unconditionally to maximize final round payoff.

**Else if t == 1 (first round):**  
- Cooperate (C) unconditionally to start on a cooperative foundation.

**Else (1 < t < r):**  

1. **Punishment Phase**  
    - If PunishmentActive is True:  
      - Defect (D) once to signal punishment.  
      - Then set PunishmentActive = False (punishment is one-round only).  
      - Continue to next round.

2. **Defection Check**  
    - If any other player defected in previous round:  
      - Set PunishmentActive = True  
      - Defect (D) this round (punishing defectors).  
      - Continue to next round.

3. **Recovery Phase**  
    - If no defection detected in the previous round:  
      - Cooperate (C)

---

## 2. Handling Edge Cases

- **First round:** Cooperate to build trust and avoid premature depletion.
- **Last round:** Defect because no future retaliation is possible ("backwards induction" endgame defect).
- **After a defection detected:** Punish by defecting once; do not enter permanent punishment to avoid race to tragedy.
- **After punishment round:** Return to cooperation to restore cooperation.
- **If multiple players defect simultaneously:** The same punishment logic applies, punishing all defectors collectively.
- **If stock depleted to near zero:** The above logic still applies; cooperation is attempted to regenerate the stock if possible.

---

## 3. Cooperative Mindset Alignment

- Always start and attempt to maintain cooperation.
- Use defection only as a proportional and temporary punishment against defectors.
- Avoid permanent defections or grim-trigger tactics, which risk collapsing the resource.
- Maximize long-term collective payoff through cooperation and selective punishment.
- Endgame defection is rational, but mitigated by prior cooperation to maintain the stock as long as possible.

---

## Pseudocode

```python
initialize:
    PunishmentActive = False
    DefectionCount = {j: 0 for j in players if j != i}

for t in 1 to r:
    observe actions A_j^{t-1} for all j != i (if t > 1)
    observe stock S_t

    if t == r:
        # Last round: defect to maximize payoff
        action = 'D'
    
    elif t == 1:
        # First round: cooperate to build trust
        action = 'C'

    else:
        if PunishmentActive:
            # Punish once
            action = 'D'
            PunishmentActive = False

        else:
            defectors = [j for j in players if j != i and A_j^{t-1} == 'D']
            
            if defectors:
                # Record defections
                for d in defectors:
                    DefectionCount[d] += 1
                
                # Trigger punishment
                PunishmentActive = True
                action = 'D'
            
            else:
                # No defection detected, cooperate
                action = 'C'

    execute action
```

---

## Explanation

- **PunishmentActive** flags the single-round punishment after detecting any defection.
- DefectionCount is recorded but not used for permanent exclusion; can be used optionally for monitoring.
- Cooperate unless punishing.
- End with defection to gain last-round payoff since no future retaliation is possible.

---

## Conclusion

This strategy is a "forgiving trigger" strategy tailored to the continuous stock regeneration environment:

- Encourages cooperation by cooperating first and thereafter if everyone cooperated.
- Responds to defection with a single defection punishment to discourage repeated defection.
- Does not over-punish to avoid resource collapse due to spiraling defectors.
- Defects last round as rational endgame behavior.
- Is fully implementable given visibility of past actions and avoids reliance on communication or external coordination.

This design is well-suited for a tournament against independently generated strategies that vary across its cooperation-defection spectrum.
'''

description_COOPERATIVE_41 = '''
**Cooperative Strategy: "Conditional Cooperation with Forgiveness and End-Game Adjustment"**

---

### Intuition
The strategy aims to sustain cooperation (everyone plays C) to preserve the common pool stock close to capacity, maximizing long-term payoffs for all. To do this, it:

- Starts by cooperating to signal willingness.
- Monitors others for defection and punishes by defecting in the next round to discourage over-exploitation.
- Quickly forgives if others return to cooperation, to avoid spiraling defection and stock collapse.
- Adjusts in the last round to defect since no future rounds remain to punish or reward.

---

### Formal Description

---

**Parameters used internally:**

- `n` = number of players
- `r` = total number of rounds
- `t` = current round (1-based)
- `capacity` = maximum stock level
- `history` = record of all players' past actions up to round `t-1`
- `last_round_defections` = boolean, true if any other player defected in round `t-1`

---

### Decision Rules

**Round 1 (t=1):**

- Play **C (Cooperate)**
- Rationale: Begin with cooperation to build trust and signal cooperative intent.

---

**Rounds 2 to r-1 (1 < t < r):**

- If **any other player defected in round t-1** (i.e., played D), then:
  - **Defect (D)** in round t to punish defectors.
- Else:
  - **Cooperate (C)**
- Rationale: Tit-for-tat style punishment enforces cooperation but allows restoration of cooperation if others do.

---

**Round r (last round):**

- **Defect (D)**
- Rationale: No future rounds remain to enforce cooperation, so defect to maximize immediate payoff.

---

### Edge Cases Handled

- **First round:** Cooperate to establish baseline fairness.
- **Last round:** Defect strategically due to terminal nature of the game.
- **Immediate punishment:** Defect next round if anyone defects to discourage free-riding.
- **Forgiveness:** Resume cooperating immediately if all cooperated in previous round, preventing indefinite punishment cycles.
- **No communication, but perfect observation:** Uses only observed past actions.
- **No coordination norms:** Responds purely on individual history-based reputation signals.

---

### Pseudocode

```python
def cooperative_strategy(t, r, n, capacity, history):
    # Input:
    #   t: current round (1-based)
    #   r: total rounds
    #   n: number of players
    #   capacity: max stock level
    #   history: list of length t-1 of dicts {player_id: action}, e.g.,
    #            history[t-2] = {1: 'C', 2: 'D', ..., n: 'C'} for round t-1

    # Round 1: start cooperating
    if t == 1:
        return 'C'

    # Last round: defect unconditionally
    if t == r:
        return 'D'

    # Check if any other player defected in previous round
    last_round = history[t-2]
    # Assume current player index is i, but strategy is symmetric and does not vary by player
    defectors_exist = any(action == 'D' for pid, action in last_round.items())

    if defectors_exist:
        # Punish by defecting this round
        return 'D'
    else:
        # No defectors last round: cooperate
        return 'C'
```

---

### Strategy Summary

| Round       | Condition                                    | Action |
|-------------|----------------------------------------------|--------|
| 1           | First round                                  | Cooperate (C)     |
| 2 to r - 1  | If any defected in previous round            | Defect (D)        |
| 2 to r - 1  | Else                                         | Cooperate (C)     |
| r (last round) | Last round (no future punishment possible) | Defect (D)        |

---

### Why This Is Cooperative

- Encourages maintaining the stock near capacity to maximize group payoffs.
- Punishes defectors immediately, deterring overconsumption.
- Quickly returns to cooperation if everyone cooperates, preventing unnecessary stock depletion.
- Accepts the inevitability of defection in the last round for self-interest, per backward induction.
- Simple, transparent, and robust against arbitrary opponent behavior, promoting mutual benefit.

---

If all players use this strategy, cooperation will be sustained through rounds 1 to r-1, stock will remain near maximum, and payoffs will be maximized collectively. Defection only arises strategically at the end, preventing exploitation through credible threats of punishment.
'''

description_COOPERATIVE_42 = '''
Here is a cooperative strategy designed to maximize the long-term joint payoffs by preserving the common pool resource as much as possible, given the constraints and assumptions you specified:

---

## Cooperative Strategy: "Conditional Cooperation with Forgiveness"

### Intuition
- Start fully cooperative to build trust and preserve the resource.
- Continue cooperating as long as all players do.
- If anyone defects, punish by defecting for a limited number of rounds to discourage unilateral defection.
- Return to cooperation after punishment to maintain long-term cooperation.
- On the last round, defect to maximize immediate payoff since no future rounds remain.

---

### Detailed Description

#### Variables Maintained by Each Player
- `round`: current round number (1 to r)
- `history`: record of all players' actions in past rounds (full information)
- `punish_rounds_left`: counter of punishment rounds left (initially 0)

#### Decision Rules

1. **First Round (round == 1):**  
   - Play **C** (cooperate) unconditionally.

2. **Rounds 2 to r-1:**
   - If `punish_rounds_left > 0`:  
     - Play **D** (defect) to punish defectors.  
     - Decrement `punish_rounds_left` by 1.
   - Else (not currently punishing):  
     - Check if all players cooperated in previous round:  
       - If yes, play **C** (cooperate).  
       - If no (at least one player defected), set `punish_rounds_left = k` (a small positive integer, e.g., 2) and play **D** to punish.

3. **Last Round (round == r):**  
   - Play **D** (defect) to maximize payoff, as no future rounds exist to incentivize cooperation.

---

### Rationale

- **Starting cooperative:** Maximizes initial resource and builds trust.
- **Conditional cooperation:** Mimics "Tit-for-Tat"-style logic but punishes all if any defect, encouraging group cooperation.
- **Limited punishment:** Avoids long retaliation cycles that deplete the resource unnecessarily, promoting recovery.
- **Final round defection:** Exploits lack of future consequences, standard in repeated game theory.
- **Forgiveness:** After punishment rounds, the strategy returns to cooperation, offering fresh start opportunities.

---

### Edge Cases

- If all players defect at round 1, strategy transitions to punishing defectors, but mutual defection will degrade stock rapidly.
- If players alternate defect/cooperate irregularly, punishment triggers each time, but limited punishment rounds contain damage.
- If only one player defects occasionally, the group punishes to promote cooperation but also quickly forgives.
- The choice of punishment length `k` balances deterrence vs. over-punishment.

---

### Pseudocode

```python
initialize punish_rounds_left = 0

for round in 1 to r:
    if round == 1:
        action = 'C'  # Start cooperating
    elif round == r:
        action = 'D'  # Last round: defect to maximize payoff
    else:
        if punish_rounds_left > 0:
            action = 'D'  # Punish defectors
            punish_rounds_left -= 1
        else:
            # Inspect last round's actions of all players
            last_round_actions = history[round - 1]
            if all(a == 'C' for a in last_round_actions):
                action = 'C'  # Continue cooperating
            else:
                # Someone defected last round, punish
                punish_rounds_left = k - 1  # Punish for k rounds including this one
                action = 'D'

    execute action
    observe other players’ actions
    update history
```

---

### Parameter choice

- Punishment length `k` = 2 or 3 rounds is recommended to disincentivize defection but allow recovery.
- This can be tuned based on parameter values (e.g., larger `k` if the resource replenishes slowly).

---

### Summary

This strategy reliably provokes cooperation by rewarding cooperation and punishing defection with limited punishment duration, for most of the game preserving the resource stock and maximizing joint payoffs. Defection at the last round is rational and aligns with classic backward induction reasoning.

This approach works well given perfect information and no communication, relying only on observed actions and the self-enforcing nature of conditional cooperation.
'''

description_COOPERATIVE_43 = '''
Below is a cooperative strategy designed to maximize the common pool resource sustainability and overall joint payoffs, while protecting against exploitation by defectors. It leverages the repeated, perfect information structure but requires no out-of-band communication or coordination.

---

## Cooperative Strategy Outline: Conditional Cooperation with Forgiveness and Endgame Defection

### Intuition
- Start fully cooperative to build and maintain the stock.
- Monitor other players' actions each round.
- If all players cooperate, keep cooperating to sustain the resource at or near capacity, which maximizes long-term payoffs.
- If defection is detected, punish defectors by defecting in subsequent rounds, but allow forgiveness if cooperation resumes.
- Near the last round, defect to maximize one’s own payoff (endgame defection), since future punishment is impossible.
- Ensure stable cooperation while being robust against persistent defectors.

---

### Decision Rules

| Round Condition                         | Action                   | Reasoning                                      |
|---------------------------------------|--------------------------|------------------------------------------------|
| **Round 1 (first round)**              | Cooperate (C)            | Establish cooperative norm, build stock       |
| **Rounds 2 to r-2 (middle rounds)**   | If all players cooperated last round → C | Mutual cooperation to sustain resource        |
|                                       | Else defect (D)          | Punish defectors, discourage free-riding      |
|                                       | If all defected last round → Cooperate (C) (forgiveness) | Try to restore cooperation                      |
| **Round r-1 (penultimate round)**     | Same as middle rounds    | Keep cooperation to preserve stock for final round or punish defection    |
| **Round r (final round)**              | Defect (D)               | Endgame defection to maximize immediate payoff |

---

### Handling Edge Cases and Detection

- If **stock S falls to very low levels** (e.g., < n×(stock/(2n)) which implicitly means resource is critically depleted), assume persistent defection → defect to avoid further losses.
- If the number of defectors is unknown explicitly (only actions are observed), infer defection by checking if total consumption is > n×(S/(2n)) (i.e., above full cooperation consumption).
- Forgive after one round of defection if cooperation resumes; punishment is not permanent (avoid infinite regress).
- Defection in the final round is universal and dominant, so cooperate in prior rounds to keep stock high for a bigger payout in round r.

---

### Pseudocode

```
Input per round t:
  history_actions = matrix of shape (t-1, n) for player actions in past rounds
  current_stock = S_t
  round_number = t
  total_rounds = r
  num_players = n
  capacity = capacity

Constants:
  COOPERATE_CONSUMPTION = current_stock / (2 * n)
  DEFECT_CONSUMPTION = current_stock / n

Helper functions:
  count_defectors(actions): return count of players who defected

Strategy:
  if round_number == 1:
    action = C  # start cooperative

  else if round_number == total_rounds:
    action = D  # final round defection

  else if round_number == total_rounds - 1:
    # penultimate round: behave like middle rounds
    proceed to middle_round_logic()

  else:
    middle_round_logic():
      last_round_actions = history_actions[-1]
      num_defectors = count_defectors(last_round_actions)

      # Check if entire group cooperated last round
      if num_defectors == 0:
        action = C  # maintain cooperation

      # Check if everyone defected last round (forgiveness round)
      else if num_defectors == n:
        action = C  # forgive, try to rebuild cooperation

      else:
        # Partial defection last round, punish by defecting
        action = D

  # Additional rule: if stock critically low (e.g. less than n*COOPERATE_CONSUMPTION)
  if current_stock < n * COOPERATE_CONSUMPTION:
    # stock starvation → defect to maximize short-term payoff
    action = D

return action
```

---

### Explanation

- **Round 1:** Always cooperate. This seeds mutual trust and keeps the stock at capacity.
- **Round 2 to r-2:** If everyone cooperated previously, continue cooperating. If some defected, punish by defecting. If all defected, forgive and try cooperating again (to break cycles of mutual defection).
- **Penultimate round:** Act like middle rounds to maintain cooperation; preserve stock for final round payout.
- **Final round:** Defect unconditionally since no future cooperation is possible.
- **Stock critical check:** If stock drops too low to sustain cooperation, switch to defect to avoid exploitation without sufficient resource.
- **Forgiveness:** Prevents a cascade of permanent punishments, allowing return to cooperation.
- **Punishment:** Sustains cooperation by deterring defectors.

---

### Cooperative mindset

This strategy:

- Prioritizes sustaining the common pool resource early and mid-game by rewarding cooperation.
- Uses punishment only if others defect to protect the common resource.
- Allows an opportunity to return to cooperation in case of temporary defections (forgiveness).
- Respects boundaries of rational self-interest due to endgame defection.
- Balances long-term collective interest and short-term individual incentives within the game's repeated structure and complete info.

---

If implemented, this strategy should produce high average payoffs when interacting with other cooperative or conditionally cooperative strategies, but also prevents being exploited by persistent defectors.
'''

description_COOPERATIVE_44 = '''
Below is a cooperative strategy designed for this Common Pool Resource game. It is designed to foster and sustain cooperation by cooperating initially, maintaining cooperation if others do, and punishing defection temporarily to deter free-riding. It manages the stock carefully, avoids over-exploitation, and adapts near the end of the game to maximize total payoff.

---

## Strategy Name: **"Sustained Cooperation with Forgiveness and Endgame Adjustment"**

### Intuition

- Cooperate initially and keep cooperating as long as everyone cooperates.
- If any player defects, punish them by defecting once in the next round to discourage defection.
- After the punishment, forgive and return to cooperation, assuming others also do.
- Monitor stock level: if stock ever near depletion, switch to cooperation to allow recovery.
- Adjust actions in the final round(s) to maximize immediate individual payoff since no future rounds remain.

---

### Notation / Useful Variables

- `r`: total rounds
- `t`: current round (1 ≤ t ≤ r)
- `n`: number of players
- `A_i(t)`: action of player i in round t (known at round t+1)
- `S_t`: stock at start of round t (initial: S_1 = capacity)
- `obs_actions_t`: actions of all players in round t (observed starting t+1)
- `punishment_round`: boolean flag indicating whether current round is a punishment round
- `defectors_last_round`: set of players who defected in last round

---

### Decision Rules

**1. First Round (t = 1):**  
- Always **Cooperate (C)**  
Reason: Signal cooperative intention, foster high initial stock growth.

**2. Rounds 2 to r-1:**

- If the stock is very low (close to 0 or a small threshold, e.g. S_t < capacity/(4n))  
  → **Cooperate (C)** to help stock recover

- Else if previous round contained defection:  
  - If you are the punishing player (i.e. if you *detected* defectors last round and currently punishing) → **Defect (D)** for 1 punishment round per defector (or just one round total)  
  - Else, if your punishment round is over → **Cooperate (C)** (forgiveness phase)

- Else (no defection last round, stock safe):  
  → **Cooperate (C)**

**3. Last Round (t = r):**  
- **Always Defect (D)** regardless of history  
Reason: No future punishment possible, incentivizes immediate payoff; cooperation incentive vanishes.

---

### Handling Edge Cases

- If multiple defectors last round, still punish only one round total (simplicity, assumes no communication).

- Forgiveness: after one punishment round, revert to cooperate unless fresh defection observed again.

- If the stock falls dangerously low at any point, override punishment or forgiveness and cooperate to boost recovery.

- No punishment in final round (since no future rounds to enforce), so defect in last round.

---

### Pseudocode

```python
def cooperative_strategy(t, r, n, capacity, S_t, history):
    # history: list of dicts with each round's actions keyed by player_id
    
    # Parameters
    STOCK_RECOVERY_THRESHOLD = capacity / (4 * n)  # threshold below which cooperate to recover
    
    # Initialization (persistent state)
    if 'punishment_round' not in cooperative_strategy.__dict__:
        cooperative_strategy.punishment_round = False
        cooperative_strategy.defectors_last_round = set()
        cooperative_strategy.punishment_counter = 0
    
    # Identify defectors in last round (if any)
    if t > 1:
        last_round_actions = history[-1]
        cooperative_strategy.defectors_last_round = set(
            player for player, action in last_round_actions.items() if action == 'D'
        )
    else:
        cooperative_strategy.defectors_last_round = set()
    
    # Last round: always defect
    if t == r:
        return 'D'
    
    # If stock is dangerously low, cooperate to help recovery
    if S_t < STOCK_RECOVERY_THRESHOLD:
        cooperative_strategy.punishment_round = False
        cooperative_strategy.punishment_counter = 0
        return 'C'
    
    # Handle punishment logic
    if cooperative_strategy.punishment_round:
        # Punishment turn
        cooperative_strategy.punishment_counter -= 1
        
        if cooperative_strategy.punishment_counter <= 0:
            cooperative_strategy.punishment_round = False
        
        return 'D'  # defect on punishment round
    
    else:
        # Not currently punishing
        if cooperative_strategy.defectors_last_round:
            # Start punishment round(s), e.g. punish for 1 round total
            cooperative_strategy.punishment_round = True
            cooperative_strategy.punishment_counter = 1
            return 'D'
        else:
            # No defection last round, cooperate
            return 'C'
```

---

### Explanation

- **First round cooperation** helps build a healthy stock and signals good faith.
- **Punishment upon defection** deters free-riders by reducing their payoff.
- **Forgiveness after punishment** avoids endless retaliation, encouraging future cooperation.
- **Stock monitoring** prioritizes sustainability even during punishment phases.
- **Defecting in the last round** is rational since no future retaliation possible.
- This approach balances individual incentives with collective preservation of the resource.

---

### Final remarks

- This strategy is self-enforcing and does not rely on communication.
- It balances cooperation and punishment to sustain a renewable resource.
- It exploits the repeated nature and memory of the game to incentivize cooperation.
- It aligns with cooperative mindset: preserve the resource by cooperating but penalize defection to discourage ruinous behavior.

---

If you would like, I can also provide a formal description or analyze its expected outcomes under various opponent behaviors.
'''

description_COOPERATIVE_45 = '''
Here is a clearly cooperative and resilient strategy that balances maximizing long-term group payoffs while guarding against exploitation in this repeated common-pool resource game.

---

## Key Intuition Behind The Strategy

- **Cooperation means everyone plays C** to consume only stock/(2n), which is sustainable and keeps the stock healthy.
- **Defection (playing D)** yields a higher immediate payoff per round but risks depleting the stock and thus total long-term payoffs.
- Because **stock dynamics regenerate only if total consumption is low**, mutual cooperation sustains the resource and collective payoffs.
- However, **some defectors may try to exploit cooperators**, so the strategy must punish defection to maintain incentives.
- Since the last round has no future consequences, **it’s optimal to defect then** to maximize last-round payoff.
- The strategy must also handle the first round (no history) and respond logically to observed defections.

---

## Definitions

- **C action:** Consume stock/(2n)
- **D action:** Consume stock/n  
- **round t:** current round (1 ≤ t ≤ r)
- **history:** observed actions of all players in previous rounds
- **defectors_last_round:** set of players who played D in the last round
- **stock S_t:** stock at start of round t (known from game state)
- **threshold for cooperation:** We define the *cooperative equilibrium* as all players playing C (lowest sustainable consumption)
- **punishment length:** We'll punish defections only for 1 round after detecting defection (to maintain simplicity and forgiveness)

---

## Strategy Description

### Summary

- **Round 1:** Cooperate (play C) to establish cooperation from the start.
- **Rounds 2 to r-1:**
  - If nobody defected in previous round, cooperate.
  - If anyone defected in previous round, punish by defecting (playing D) once.
- **Round r (last round):** Defect to maximize last-round payoff (since no future rounds).
- **Forgiveness:** After punishing defectors once, return to cooperation if no further defection.
- **Stock Awareness:** If stock drops dangerously low (< n), switch to defect to secure immediate payoffs (since cooperation may no longer be sustainable).
- **Detect defection by checking actions from previous round (perfect info).**

---

### Pseudocode

```python
def cooperative_strategy(t, r, n, capacity, S_t, history):
    # t: current round (1-indexed)
    # r: total rounds
    # n: number of players
    # capacity: max stock
    # S_t: current stock at start of round t
    # history: list of all actions in previous rounds, each element is a dict {player_id: action}

    COOPERATE = 'C'
    DEFECT = 'D'

    # Edge case: If stock below minimum sustainable level, defect to get max immediate payoff
    # Minimum sustainable stock is roughly n (sum of n players cooperative consumption = S/(2n)*n = S/2 requires S not to be too low)
    # Here, if S_t < n -> resource is depleted, choose defect for last benefit
    if S_t < n:
        return DEFECT

    # Last round: Defect since no future punishment possible, maximize payoff
    if t == r:
        return DEFECT

    # Round 1: Cooperate to set cooperative baseline
    if t == 1:
        return COOPERATE

    # From second round to one before last
    # Check if any player defected in previous round
    prev_round_actions = history[t-2]  # indexing from 0, so round t corresponds to t-1
    any_defected = any(action == DEFECT for action in prev_round_actions.values())

    if any_defected:
        # Punish defectors by defecting this round to discourage defection 
        return DEFECT
    else:
        # No defection last round, cooperate
        return COOPERATE
```

---

### Explanation

- **Round 1 cooperation:** Signals willingness to cooperate.
- **Reactive punishment:** If anyone defects, punish by defecting once, then return to cooperation if no further defections.
- **Forgiveness:** Do not escalate or permanently defect; punish for one round only.
- **Last round defection:** No future rounds means no incentive to maintain cooperation, defect to maximize last payoff.
- **Stock-awareness:** If stock low, switch to defect to "harvest" last possible payoff since cooperation may be futile.

---

## Why this strategy is cooperative and effective

- Maintains **mutual cooperation most rounds**, maximizing joint payoffs and sustainability.
- Uses **simple trigger and forgiveness** to deter defection without permanent breakdown.
- Punishes defectors individually and quickly to reinforce cooperation incentives.
- Exploits endgame rationality by defecting last round, avoiding being exploited then.
- Accounts for stock scarcity as a fallback, avoiding irrational cooperation when resource is gone.

---

## Possible Extensions (if more complexity allowed)

- Use a longer punishment phase to discourage repeated defection.
- Track defectors individually, punish only defectors.
- Adjust cooperation thresholds dynamically by observed stock recovery.
- Use probabilistic forgiveness to allow re-entry to cooperation.

But given your tournament setting and assumptions, the above strategy strikes a good balance between cooperation, deterrence, and rational endgame play.
'''

description_COOPERATIVE_46 = '''
Here is a fully cooperative strategy concept for the Common Pool Resource game, focused on maintaining the resource at sustainable levels and maximizing collective long-term payoff. It employs conditional cooperation, forgiveness, and endgame adjustment, all from the perspective of a single player who observes all players' past actions and stock levels.

---

## Cooperative Strategy: "Sustainable Conditional Cooperation with Endgame Adjustment"

### Intuition
- Cooperate to preserve the common pool whenever the stock is healthy (close to capacity).
- Detect and respond to defections (high consumption levels) by switching to punishment (defect) to prevent exploitation.
- Forgive defections after one round of punishment if cooperation is resumed.
- Adjust behavior in the last round—defection is allowed since future costs do not apply.
- Use the stock level as a signal for sustainable harvesting and safety buffer.

---

### Parameters and Notation
- Let:
  - `t` = current round (1 ≤ t ≤ r)
  - `S_t` = stock at start of round t (before consumption)
  - `actions_{t-1}` = vector of all players' actions in previous round (for t > 1)
  - `C_action` = cooperate (`C`) meaning consume `S_t / (2n)`
  - `D_action` = defect (`D`) meaning consume `S_t / n`
- Threshold parameters (tunable based on capacity and n):
  - `S_high` = 0.8 × capacity (stock level above which cooperate confidently)
  - `S_low` = 0.3 × capacity (stock level below which defect to conserve)
  
---

### Decision Rules

#### For round 1 (initial round):
- **Action:** Cooperate (`C`)
- **Reason:** With a fresh, full resource and no history, start positively.

#### For rounds 2 to r-1 (intermediate rounds):

1. **Check if previously observed defection:**
   - If in `actions_{t-1}`, any player defected (`D`), **go to punishment** phase.

2. **If no observed defection in previous round:**

   - If current stock `S_t` ≥ `S_high`, **cooperate** (play `C`) to maintain high resource.
   - Else if `S_low` ≤ `S_t` < `S_high`, **cooperate**, but monitor closely.
   - Else if `S_t` < `S_low`, **defect** (play `D`) to reduce pressure and hasten recovery.

3. **Punishment phase:**
   - If responding to defection:
     - **Play defect (`D`) once** to punish defectors.
     - Then next round, if all players returned to cooperation last round, forgive by returning to cooperate.
     - If defection persists, continue defecting.

#### Round r (last round):

- Defection is allowed regardless of stock (since no future rounds to preserve):
  - If stock ≥ `S_low`, **defect** to maximize payoff.
  - Else (stock low), still defect (since no future risk).
- This is an endgame "harvest as much as possible" move.

---

### Pseudocode

```python
def cooperative_strategy(t, r, n, capacity, S_t, actions_prev, history):
    S_high = 0.8 * capacity
    S_low = 0.3 * capacity

    # First round: cooperate
    if t == 1:
        return 'C'

    # Last round: defect regardless
    if t == r:
        return 'D'

    # Check for defection in previous round
    defection_last_round = any(a == 'D' for a in actions_prev)

    # Track forgiveness state: did we punish last round?
    punished_last_round = False
    if len(history) >= 2:
        punished_last_round = history[-2]['punished'] if 'punished' in history[-2] else False

    # Punishment logic
    if defection_last_round:
        # Punish once this round
        action = 'D'
        punished_this_round = True
    else:
        # If we punished last round and players cooperated last round, forgive
        if punished_last_round:
            # Check if all players cooperated after punishment
            cooperated_after_punish = not any(a == 'D' for a in history[-1]['actions'])
            if cooperated_after_punish:
                # Forgive: cooperate
                action = 'C'
                punished_this_round = False
            else:
                # Continue punishment
                action = 'D'
                punished_this_round = True
        else:
            # No defection detected, cooperate or defect depending on stock
            if S_t >= S_high:
                action = 'C'
            elif S_low <= S_t < S_high:
                action = 'C'
            else:  # S_t < S_low
                action = 'D'
            punished_this_round = False

    # Record punishment flag for next round's forgiveness logic
    # This should be stored externally as part of the player's history

    return action, punished_this_round
```

---

### Explanation and Cooperative Mindset

- **Cooperation by default:** Start cooperative to build trust and maximize mutual benefits.
- **Punishment only in response to defection:** Deter free-riding to sustain the resource.
- **Forgiveness:** Punishment lasts only one round if cooperation resumes, encouraging norm restoration.
- **Responsive to stock:** Being adaptive to resource levels helps avoid collapse and promotes sustainability.
- **Endgame defection:** Rationally defect in the final round as no future consequences exist, maximizing final payoff.

---

### Why is this cooperative?

- It aligns incentives to preserve the common pool for ongoing mutual benefit.
- It punishes but does not escalate or hold grudges, fostering an environment where cooperation can return after mistakes.
- It avoids brinkmanship by adjusting behavior based on the actual resource state, preventing reckless depletion.
- Explicitly rewards cooperation and punishes defection in a fair and transparent way without communication.
- Recognizes that endgame defection is rational but non-destructive to the overall cooperative equilibrium across rounds.

---

If implemented consistently, this strategy should:

- Sustain the common pool close to capacity most rounds,
- Achieve higher long-run payoffs for all cooperators,
- Discourage persistent defectors through proportionate retaliation,
- Ensure adaptability to evolving resource levels,
- And handle the game's finite horizon effectively.

This provides a robust, cooperative, and resilient approach suitable for entering the tournament against unknown independent strategies.
'''

description_COOPERATIVE_47 = '''
Below is a carefully designed cooperative strategy for the specified Common Pool Resource Game. It aims to maximize the long-term joint welfare via mutual cooperation while deterring defection by punishing defectors temporarily and forgiving to restore cooperation.

---

## Strategy Name: **Trigger-Grim with Forgiveness**

---

### Intuition

- **Cooperate as long as no one defects**, to sustain the resource and maximize joint payoffs.
- **Detect defection immediately** via observed actions.
- **Punish defectors by defecting in the following round(s)** to discourage overconsumption.
- **After a fixed short punishment phase, return to cooperation** (forgiveness) to avoid permanent breakdown caused by errors or misunderstandings.
- In the **last round**, defect (to maximize immediate payoff), since no future punishment is possible.

The strategy balances cooperation, punishment, and forgiveness to sustain cooperation through repeated play in a non-communicative environment.

---

### Notation and Observations

- **Round t ∈ {1,...,r}**
- **S_t**: stock at start of round t
- **a_i,t ∈ {C,D}**: our own action in round t
- **a_{-i,t} ∈ {C,D}^ (n-1)**: actions of other players in round t (fully observed after round’s end)
- **T**: punishment length (e.g., T=1 or 2 rounds)

---

### Key Definitions

- **Cooperation condition for others in round t:**
  
  Other players are cooperating in round t if for all j≠i, a_{j,t} = C.
  
- **Defection detection:**

  Defection detected if any other player defected in previous round(s).

- **Punishment state variables:**

  - **punish_counter**: counts how many rounds remain in punishment phase.
  - Initialize punish_counter = 0.

---

### Decision Rules per Round

#### Round 1:

- No history exists → Cooperate.

#### Intermediate rounds (1 < t < r):

- If **punish_counter > 0**:
  - Defect.
  - Decrement punish_counter by 1.
- Else if **any defection detected in previous round (t-1)**:
  - Enter punishment:
    - punish_counter = T (e.g., 1 or 2)
    - Defect this round.
    - Decrement punish_counter by 1.
- Else:
  - Cooperate.

#### Last round (t = r):

- Defect (maximize immediate gain because no future rounds to punish).

---

### Pseudocode

```python
# Parameters
T = 1  # punishment length in rounds

# Variables
punish_counter = 0

def decide_action(t, r, history):  
    # history: list of past rounds' actions for all players
    
    global punish_counter
    
    if t == 1:
        # First round: cooperate to build trust
        return 'C'
    
    if t == r:
        # Last round: defect to maximize immediate payoff
        return 'D'
    
    # Check if currently punishing
    if punish_counter > 0:
        punish_counter -= 1
        return 'D'
    
    # Check last round for defection
    last_round_actions = history[t-2]  # zero-indexed, actions of all players round t-1
    # Exclude self's action from check (assumed known)
    others_actions = [a for idx,a in enumerate(last_round_actions) if idx != self_index]
    
    if any(action == 'D' for action in others_actions):
        # Defection detected, start punishment
        punish_counter = T - 1  # one round used this round
        return 'D'
    
    # Else cooperate
    return 'C'
```

---

### Additional Notes

- **Punishment length T** controls forgiveness severity:
  - T=1 is a mild "tit-for-tat" punishment (punish once).
  - T>1 increases punishment harshness, deterring defectors more strongly but risks fragility.

- **Forgiveness** ensures strategy recovers from mistakes or misunderstandings (e.g., noise, accidental defects).

- **No assumptions about others’ strategy** are needed beyond observable past actions.

- **Sustainability**: By cooperating unless provoked, the strategy sustains high stock levels, maximizing payoffs.

- **Last round defection** aligns with game theory endgame analysis: no incentive to cooperate when no future punishment is possible.

---

## Summary

| Round            | Condition                                  | Action      |
|------------------|--------------------------------------------|-------------|
| 1                | Initial round                             | Cooperate   |
| 2 to r - 1       | Under punishment (punish_counter > 0)   | Defect      |
| 2 to r - 1       | Defection detected last round             | Defect and start punishment |
| 2 to r - 1       | No defection detected                      | Cooperate   |
| r (last round)    | Any                                      | Defect      |

---

This strategy strikes a pragmatic balance between cooperation, retaliation, and forgiveness, promoting sustainable resource use and resilient mutual cooperation in a purely observational repeated game setting without communication.
'''

description_COOPERATIVE_48 = '''
Here is a detailed cooperative strategy for the Common Pool Resource Game, designed to sustain the resource stock and achieve high collective payoffs by encouraging mutual cooperation. It is robust to independent opponents and does not rely on communication or coordination devices beyond observing past actions.

---

### Intuition and Goals

- Cooperate (play **C**) to conserve the resource, ensuring it remains near capacity to maximize long-term payoffs.
- Defect (play **D**) only as a measured punishment for others’ defections to incentivize cooperation.
- Use past observed actions to detect defections reliably.
- Gradually repair cooperation after punishment phases.
- Exploit knowledge of the resource dynamics to keep the stock sustainable.
- Special cases for first and last rounds to maximize final payoffs.

---

### 1. Decision Rules (Per Round t = 1,...,r)

Define:

- **Sₜ**: current stock level at start of round t (common knowledge)
- **History of actions of all players before round t**: Hₜ₋₁
- **Defection threshold**: opponent defect is playing D in a round
- **Punishment length**: P (integer ≥ 1), number of rounds to defect after detecting defection
- **Punishment state**: whether currently punishing or not
- **Punishment count**: how many punishment rounds remain

Initialize:

- At round 1, no punishment state.

---

### Pseudocode Outline:

```python
# Parameters to tune:
P = 2  # Punish defectors by defecting for 2 rounds after detection

# Variables tracked:
punishment_count = 0  # rounds left to punish
punished_players = set()  # players who defected recently and should be punished

def observe_defections(H):  
    # Returns set of players defecting in last round t-1
    last_round = H[-1]  # H[-1] is tuple of all players' actions in round t-1
    defectors = {i for i, a in enumerate(last_round, start=1) if a == 'D'}
    return defectors

def decide_action(t, S, H, punishment_count, punished_players):
    if t == 1:
        # No history: begin fully cooperative
        return 'C', punishment_count, punished_players

    # Check if new defections occurred last round
    defectors = observe_defections(H)
    
    # Update punishment list: add new defectors
    punished_players.update(defectors)
    
    if punishment_count > 0:
        # Currently punishing: play D to punish defectors
        punishment_count -= 1
        action = 'D'
        
        # After punishment ends, reset punished players (for forgiveness)
        if punishment_count == 0:
            punished_players.clear()
    else:
        # No current punishment:
        # If anyone defected last round, start punishment for P rounds
        if len(defectors) > 0:
            punishment_count = P
            action = 'D'  # defect to punish
            punished_players.update(defectors)
            punishment_count -= 1  # already using one punishment round now
        else:
            # No detected defections:
            # Cooperate to sustain resource
            
            # Special consideration for last round (t == r):
            # Defect to maximize immediate payoff, since no future rounds
            if t == r:
                action = 'D'
            else:
                action = 'C'
                
    return action, punishment_count, punished_players
```

---

### 2. Handling Edge Cases

- **First Round (t=1):** No history, cooperate to establish trust and resource stock at capacity.
- **Last Round (t=r):** Defect to maximize payoff since there is no future round to protect resource or respond to defections.
- **If stock level S becomes dangerously low (e.g., S < threshold):** optionally cooperate unconditionally to allow stock recovery. However, since cooperating is default except punishment rounds, this is naturally handled.
- **Multiple defectors:** punish all detected defectors collectively by defecting; no need for player-specific punishments.
- **Forgiveness:** after finishing a punishment phase with length P, resume cooperation on the presumption of renewed cooperation.
- **No communication or coordination needed:** strategy only uses observed actions histories.

---

### 3. Cooperative Mindset Alignment

- Always cooperate by default to maintain the resource.
- Punish defectors mildly (limited rounds of punishment) to sustain cooperation incentives.
- Forgive quickly (after P rounds) to avoid endless retaliation.
- Exploit the last round opportunity to defect, since no future cooperation is possible.

---

### Additional Notes:

- Choice of **P=2** punishment rounds balances deterrence and forgiveness; it can be tuned.
- The strategy relies on perfect monitoring: all players’ previous moves are known.
- By cooperating except when punishing, the strategy helps keep the stock near capacity, maximizing sustainable returns.
- The strategy suffers if all defect in first round, but that is unavoidable without communication.
- The stock dynamics naturally reward cooperation as the stock regrows near capacity after low-to-moderate consumption.

---

# Summary of the Strategy

1. **Start cooperating on first round.**
2. On each subsequent round:
   - If anyone defected in previous round, defect for P rounds to punish.
   - Otherwise, cooperate.
3. On the last round, defect to maximize immediate payoff.
4. After punishment rounds end, forgive and return to cooperation.
5. Track defections via full public history, punish collectively but briefly.

---

This strategy is simple, robust, and aligns incentives towards long-term cooperation maximizing payouts through sustainable resource management.
'''

description_COOPERATIVE_49 = '''
Here is a cooperative strategy designed to maximize joint payoffs by sustaining the common pool resource over time and punishing defection reliably, benefiting from the known structure of the game and perfect monitoring of past actions.

---

## Cooperative Strategy: "Conditional Cooperation with Forgiveness"

### Intuition:
- Cooperate as long as *all* players cooperated in the previous round.
- If any defection is detected, punish by defecting for a limited time.
- After punishment phase, return to cooperation ("forgiveness") to allow rebuilding cooperation.
- In the **last round**, defect to maximize final round payoff (as future consequences vanish).
- The strategy leverages repeated interaction, perfect monitoring, and known payoff dynamics to sustain cooperation.

---

### Notation & Inputs
- **n**: number of players
- **r**: total rounds
- **t**: current round (1 ≤ t ≤ r)
- **A_{-i,t-1}**: actions of all other players in round t-1 (if t > 1)
- **defect_punish_length**: fixed punishment length (small integer, e.g. 2 rounds)
- **punishment_counter**: how many punishment rounds remain (state variable)

---

### State Variables (per player)
- `punishment_counter` (initially 0): counts rounds of punishment remaining.
- `last_round_defected` (bool): whether any defection observed last round.

---

### Decision Rules

**Round 1 (t=1):**
- Cooperate (C)
- Explanation: Begin with trust, preserve resource.

**Rounds 2 to r-1 (2 ≤ t < r):**

- If `punishment_counter > 0`:
  - Defect (D)
  - Decrement `punishment_counter` by 1
  - Explanation: Punish detected defection by defecting temporarily.
  
- Else:
  - If **all** other players cooperated in previous round:
    - Cooperate (C)
  - Else (any defection detected last round):
    - Set `punishment_counter = defect_punish_length - 1` (start punishment period)
    - Defect (D)
    - Explanation: Initiate punishment phase for defection.

**Round r (final round):**
- Defect (D)
- Explanation: No future consequences; maximize single-round payoff.

---

### Edge Cases Handled

- **First round:** No prior history, so always cooperate to signal goodwill.
- **Last round:** No incentive to cooperate, so defect to maximize immediate gain.
- **Defection by multiple players:** Single defection triggers punishment, regardless of how many defected.
- **Punishment length:** Finite and fixed to allow eventual return to cooperation, avoiding endless cycles of punishment.
- **Stock depletion risk:** By cooperating mostly and punishing defectors, maintains stock near capacity to maximize total payoffs for all cooperative players.

---

### Pseudocode

```python
def cooperative_strategy(t, r, A_minus_i_prev, punishment_counter):
    """
    Parameters:
        t : int                 # current round number
        r : int                 # total number of rounds
        A_minus_i_prev : list   # actions of other players in previous round (empty if t=1)
        punishment_counter : int # number of punishment rounds left (state variable)
        
    Returns:
        action : 'C' or 'D'
        updated_punishment_counter : int
    """
    # Parameters
    defect_punish_length = 2  # Punish defectors by defecting for next 2 rounds
    
    # Last round - defect to maximize payoff
    if t == r:
        return 'D', punishment_counter  # No change to punishment counter really matters
    
    # First round - cooperate
    if t == 1:
        return 'C', 0
        
    # If currently punishing defectors
    if punishment_counter > 0:
        return 'D', punishment_counter - 1
        
    # Check if any defection last round
    any_defect = any(action == 'D' for action in A_minus_i_prev)
    
    if any_defect:
        # Start punishment phase
        return 'D', defect_punish_length - 1
    else:
        # All cooperated, cooperate as well
        return 'C', 0
```

---

### Rationale / Why This Works as a Cooperative Strategy

- **Maintains high stock:** By cooperating, consumption per player is modest, allowing stock regeneration and sustained high payoffs.
- **Mutual cooperation is self-enforcing:** Deviation leads to punishment, which reduces payoff for defectors.
- **Simple forgiveness:** Punishment is temporary to avoid spirals of retaliation.
- **Last round defection is a standard backward induction step** to maximize final payoff.
- **No assumptions on prior coordination** are needed, only observation of past actions.
- **Works well with perfect and public monitoring of previous rounds.**

---

If most players implement variants of this cooperative strategy, overall stock will stay close to capacity, maximizing total payoffs for everyone over the repeated game. Defectors receive swift punishment reducing their incentive to exploit.

---

Let me know if you want this adapted for stochastic or noisy observations, or further nuanced strategy details!
'''

description_COOPERATIVE_50 = '''
Below is a description of a **cooperative strategy** for the Common Pool Resource repeated game with parameters \(n\), \(r\), and capacity. The goal is to maximize long-run total payoffs by sustaining the stock, avoiding premature depletion, and encouraging cooperative behavior by punishing defection.

---

## Key Intuition Behind the Strategy

- **Cooperate by default** to avoid over-exploiting the resource.
- **Consume the cooperative share (C action)** to keep the stock sustainable over rounds.
- **Monitor opponents’ actions** for defection.
- **Punish defection** by defecting for a limited punishment period to discourage repeated defection.
- **Forgive and return to cooperation** if opponents resume cooperation.
- **Defect in the last round** to maximize final payoff, since no future rounds remain for retaliation.

---

## 1. Decision Rules

| Round Number | Condition                                            | Action                                    |
|--------------|-----------------------------------------------------|-------------------------------------------|
| Round 1      | No history yet                                      | Cooperate (C)                             |
| Intermediate rounds (2 ≤ t < r) | If no defection detected previously or punishment phase over | Cooperate (C) |
| Intermediate rounds (2 ≤ t < r) | If defection detected at round \(t-1\) or in ongoing punishment phase | Defect (D) during punishment window |
| Round r (last round) | Always defect (D) to maximize immediate payoff | Defect (D)                             |

---

### Detecting Defection

- Defection means a player extracts more than the cooperative share:
  - Coop share consumption per player at round \(t\) is \(S_t/(2n)\).
  - Defection share consumption per player at round \(t\) is \(S_t/n\).
- By the rules, an action is either C (consume \(S_t/(2n)\)) or D (\(S_t/n\)).
- Since players observe all actions, defection is detected if any opponent chooses D in round \(t-1\).

### Punishment

- Punish defectors collectively by defecting for \(p\) rounds (punishment length).
- Punishment is shared by all cooperators as a group response.
- After punishment, return to cooperation if no new defections occur.

---

## 2. Handling Edge Cases

- **First Round**: No past info, so always cooperate.
- **Last Round**: No incentive to maintain the resource; defect to maximize immediate payoff.
- **Stock Near Zero**: If stock is extremely low (e.g., below a threshold \(\epsilon\)), cooperate anyway to avoid guaranteed extinction, accepting diminished payoff this round and attempt recovery in growth phase.
- **Multiple Defections**: Restart punishment timer on any detection of defection.
- **R rounds very small (e.g., r=2)**: Same logic applies; just shorten punishment phases since possible future rounds are limited.
- **Stock Depletes Despite Cooperation (due to others defecting)**: Punishment aims to bring others back; cooperators maintain cooperative behavior until stock is 0.
- **If stock reaches 0 at start of round \(t\)**: No payoff possible; continue playing cooperating actions (no impact on stock), punishment irrelevant.

---

## 3. Pseudocode of the Strategy

```python
# Parameters
n        # Number of players
r        # Number of rounds
capacity # Max stock
p = 2    # Punishment length in rounds (can be tuned)

# State variables to store history
punishment_counter = 0  # rounds remaining to punish
last_defection_round = 0 # last round when defection detected

for t in 1 to r:
    observe all players' actions at round t-1 (if t > 1), and current stock S_t
    
    if t == 1:
        # No history, cooperate
        action = 'C'
        
    elif t == r:
        # Last round, defect to maximize payoff
        action = 'D'
        
    else:
        # From 2nd to penultimate round
        
        # Check if any opponent defected at round t-1
        if any opponent played 'D' at t-1:
            last_defection_round = t-1
            punishment_counter = p
        
        if punishment_counter > 0:
            action = 'D'  # Punish defectors by defecting
            punishment_counter -= 1
        else:
            action = 'C'  # Cooperate
            
    play action
    
# Notes:
# - Observability of opponents' actions per round is given
# - Punishment resets if a new defection detected (punishment_counter reset)
```

---

## Strategic Justification

- **Default Cooperation** preserves stock and provides steady payoff.
- **Punishment deters defection** by threatening short-term payoff loss for defectors.
- **Forgiveness allows return** to cooperation to avoid endless retaliation and possible mutual ruin.
- **Defection in final round is individually rational**, exploiting no future retaliation possible.

---

## Summary

| Round        | Condition                             | Action          |
|--------------|------------------------------------|-----------------|
| 1            | No info                            | Cooperate (C)   |
| 2 to r-1     | If recent or ongoing defection     | Defect (D) punish|
| 2 to r-1     | Otherwise                         | Cooperate (C)   |
| r (last round)| Always defect                     | Defect (D)      |

This strategy implements a classic **tit-for-tat-style** conditional cooperation with forgiveness and end-game defection, aligned with a strong cooperative mindset within the given information constraints. It balances sustainability and incentive compatibility, promoting high group payoffs in repeated play.

---

If you want, I can also provide an annotated example trace showing how this strategy behaves under sample sequences of opponents’ play.
'''

description_COOPERATIVE_51 = '''
Below is a detailed cooperative strategy designed specifically for the described Common Pool Resource Game. It aims to sustain the resource over repeated rounds by encouraging cooperation, while having a simple and robust detection-and-punishment mechanism for defections.

---

## Cooperative Strategy Overview

**Goal:** Maximize joint long-term payoffs by maintaining the commons stock at high levels through consistent cooperation (playing **C**) — consuming a smaller amount — unless defection is detected, in which case apply a calibrated, temporary punishment followed by a return to cooperation.

---

## 1. Decision Rules

### Definitions:

- Let **S_t** = observed stock at start of round *t*.
- Let **actions_{t-1}** = vector of all players’ actions in previous round (known due to perfect information).
- Let **expected_stock_C** = theoretical new stock if *all* players cooperated in previous round starting from *S_{t-1}*.
- Let **deviation_detected** = Boolean flag indicating if defection was likely in previous round.
- Let **punishment_rounds_left** = counter for how many rounds remain in the punishment phase.

### Initialization:

- At start (round 1), no history => assume cooperation.
- punishment_rounds_left = 0
- deviation_detected = False

### Round-by-round logic (for round t = 1 to r):

**At round 1 (t=1):**
- Play Cooperate (C).

**At rounds 2 ≤ t < r (interior rounds):**

1. If punishment_rounds_left > 0:  
   - **Punishment phase:** Play Defect (D) to pressure defectors.  
   - Decrement punishment_rounds_left by 1.

2. Else (not punishing):

   a. Compute expected stock under full cooperation from *S_{t-1}*:  
      \[
      \text{expected_stock_C} = \min\bigg(
         \big(S_{t-1} - n \times \frac{S_{t-1}}{2n}\big) + 
         2 \times \big(S_{t-1} - n \times \frac{S_{t-1}}{2n}\big) \times 
         \left(1 - \frac{S_{t-1} - n \times \frac{S_{t-1}}{2n}}{\text{capacity}}\right)
      , \text{capacity}\bigg)
      \]
      
      Simplified:  
      - Total consumption if all cooperate = \(n \times \frac{S_{t-1}}{2n} = \frac{S_{t-1}}{2}\)  
      - Stock after consumption = \(S_{t-1} - \frac{S_{t-1}}{2} = \frac{S_{t-1}}{2}\)  
      - Growth = \(2 \times \frac{S_{t-1}}{2} \times \left(1 - \frac{\frac{S_{t-1}}{2}}{\text{capacity}}\right) = S_{t-1} \left(1 - \frac{S_{t-1}}{2 \times \text{capacity}}\right)\)  
      - New stock (expected) = \(\min\left(\frac{S_{t-1}}{2} + S_{t-1} \left(1 - \frac{S_{t-1}}{2 \times \text{capacity}}\right), \text{capacity}\right)\)
      
   b. Observe actual stock at start of current round, \(S_t\).

   c. **Deviation detection rule:**  
      If \(S_t < \text{expected_stock_C} - \delta\), where \(\delta > 0\) is a small tolerance threshold for noise/rounding, **then defection is detected**.  
      (This threshold can be set heuristically, e.g., \(\delta = 0.01 \times \text{capacity}\)).

   d. **If defection detected:**
      - Set deviation_detected = True
      - Set punishment_rounds_left = \(m\), a fixed number of punishment rounds (e.g., 2 or 3 rounds)
      - Play Defect (D) immediately this round

   e. **If no defection detected:**
      - Play Cooperate (C)

**At round r (last round):**

- Always Defect (D) because no future punishment is possible and incentives to cooperate vanish (standard backward induction logic in finitely repeated games).

---

## 2. Handling Edge Cases

- **Round 1 (no history):** Cooperate, to start by building trust and keeping the resource sustainable.
- **Round r (last round):** Defect unconditionally.
- **If stock reaches very low level (e.g., \(S_t \leq \frac{\text{capacity}}{4n}\)), even if no explicit defection detected:**  
  - Defect for next \(m\) rounds to punish possible defectors and prevent further overuse.  
  - If stock is zero, no growth possible; defecting may not generate payoff, but is consistent with punishment logic.
- **If simultaneous defections cause sharp depletion observed, punishment phase triggers to restore discipline.**

---

## 3. Cooperative Mindset Alignment

- Preserves cooperation as long as the resource behaves as expected under cooperation.
- Punishes defections moderately, but only temporarily — after punishment ends, cooperation resumes.
- Does **not** defect preemptively or escalate punishment indefinitely, allowing recovery.
- Uses only observable game history (stock and all players’ previous actions) to infer defections.
- Tolerates small fluctuations due to model noise or unexpected events by introducing a tolerance threshold \(\delta\).
- Recognizes the futility of cooperation in the last round and defects accordingly, complying with game-theoretic rationality.

---

## Pseudocode Summary

```python
initialize:
  punishment_rounds_left = 0
  delta = 0.01 * capacity  # tolerance threshold
  m = 3  # punishment rounds

for t in 1 to r:
  observe current stock S_t
  if t == 1:
    action = 'C'

  elif t == r:
    action = 'D'  # last round: defect

  else:  # 2 <= t < r
    if punishment_rounds_left > 0:
      action = 'D'
      punishment_rounds_left -= 1
    else:
      # Compute expected stock if all cooperated last round:
      S_prev = stock at start of round t-1
      total_consumption_C = S_prev / 2
      S_after_consumption = S_prev - total_consumption_C
      growth = 2 * S_after_consumption * (1 - (S_after_consumption / capacity))
      expected_stock_C = min(S_after_consumption + growth, capacity)

      if S_t < expected_stock_C - delta:
        # Deviation detected: start punishment
        punishment_rounds_left = m - 1  # one punishment round now + m-1 more
        action = 'D'
      elif S_t <= capacity / (4 * n):
        # Stock critically low: pre-emptive punishment
        punishment_rounds_left = m - 1
        action = 'D'
      else:
        action = 'C'
```

---

## Remarks

- This strategy is a **"grim trigger with forgiveness"**: punishes defection with several defect rounds but returns to cooperation instead of permanent defection.
- Detects defection through state (stock) discrepancies instead of relying exclusively on observed actions, allowing robustness if some players occasionally defect or random noise exists.
- Sets a clear, simple boundary on behavior that other LLM-generated strategies can recognize and respond to.
- Balances rational self-interest with cooperative long-term sustainability, maximizing aggregate and individual payoffs.

---

If you want, I can suggest exact `m` and `delta` tunings or discuss alternative cooperative strategy variants (e.g., tit-for-tat style). Just ask!
'''

description_COOPERATIVE_52 = '''
### Cooperative Strategy for the Common Pool Resource Game

---

#### Intuition and Cooperative Goal
The game models a classic common-pool resource dilemma where mutual cooperation maximizes sustainable long-term payoffs by preserving the stock. Cooperation means each player takes a smaller share (C: stock/(2n)) per round, allowing the stock to regenerate, ensuring continued payoffs over all rounds. Defection means taking a larger share (D: stock/n), which risks depleting the stock and collapsing future payoffs.

---

### 1. Decision Rules: When to Cooperate vs Defect

Our strategy is a **conditional cooperation** (a form of *tit-for-tat* adapted for a resource game):

- **Start by cooperating** on the first round to signal willingness.
- In round *t > 1*, observe the number of defects in round *t-1*.
- If *no one defected* in the previous round, continue cooperating.
- If *one or more players defected* previously, retaliate by defecting for a limited punishment phase.
- After the punishment phase ends, **attempt to return to cooperation** to restore the resource.
- If the stock falls below a critical threshold, **switch to defection** to maximize immediate payoff as future gains are unlikely.

---

### 2. Handling Edge Cases

- **First round: Cooperate unconditionally.**
- **Last round (round = r):** Defect regardless (since no future rounds remain, no incentive to preserve the resource).
- **Near depletion:** If stock is very low (e.g., less than a small fraction of capacity, say 10%), defect to maximize final round gain, because cooperation won't help replenish in time.
- **Punishment duration:** Punish defectors (including unknown individual defectors) by defecting for a fixed number of rounds (e.g., 1 round) to discourage defection but avoid permanent conflict.

---

### 3. Cooperative Mindset

This strategy:

- Prioritizes mutual cooperation as default.
- Punishes only in response to defection to enforce reciprocity.
- Forgives quickly to restore cooperation.
- Protects the common stock to sustain payoffs over the entire game.
- Balances individual payoffs with group welfare.

---

### 4. Pseudocode for the Strategy

```python
initialize:
    punish_rounds_remaining = 0
    last_round = False

parameters:
    punishment_length = 1       # number of rounds to punish after defection detected
    depletion_threshold = 0.1 * capacity  # threshold to consider stock critically low

for round t in 1 to r:
    
    observe:
        S = current_stock_level
        actions_last_round = actions of all players in round t-1 (if t > 1)
    
    # Edge cases:
    if t == 1:
        # First round: Cooperate
        play_action = 'C'
        continue
    
    if t == r:
        # Last round: defect to maximize immediate payoff
        play_action = 'D'
        continue

    if S <= depletion_threshold:
        # Stock critically low, defect to maximize immediate payoff
        play_action = 'D'
        continue

    # Check if in punishment phase
    if punish_rounds_remaining > 0:
        # Continue punishment by defecting
        play_action = 'D'
        punish_rounds_remaining -= 1
        continue

    # No punishment phase, check previous round actions for defection
    defectors_last_round = count_actions(actions_last_round, 'D')

    if defectors_last_round == 0:
        # Everyone cooperated last round, cooperate now
        play_action = 'C'
    else:
        # Defection detected, punish by defecting next punishment_length rounds
        punish_rounds_remaining = punishment_length - 1  # subtract current round
        play_action = 'D'

    # Output the chosen action
    return play_action
```

---

### Explanation

- **First round cooperation** sets a norm.
- As long as **everyone cooperates**, the strategy keeps cooperating.
- **Upon any defection**, the strategy defects for exactly `punishment_length` rounds, then tries to cooperate again.
- If the **stock falls below the safe threshold**, defect to secure gains before collapse.
- **Last round defection** extracts maximum payoff without risking future loss.

---

### Why This Strategy?

- **Sustains the common resource:** Encourages everyone to choose `C`.
- **Reciprocal:** Responds only to defection with punishment.
- **Forgiving:** Returns to cooperation instead of endless defecting cycles.
- **Rational endgame:** Defects on the last round where no future cooperation benefit exists.
- **Self-protective:** When resource is depleted, switches to defect to optimize payoff under ruin.

---

This is a robust, self-interested yet cooperative equilibrium candidate that should perform well against a wide range of opponent behaviors in the tournament.
'''

description_COOPERATIVE_53 = '''
Below is a **cooperative strategy** designed to sustain mutual cooperation in the Common Pool Resource Game by incentivizing cooperation and punishing defection, while cautiously managing the renewable resource stock over rounds.

---

## High-Level Intuition

- Cooperate as long as everyone cooperates and the stock stays above a safe threshold.
- Defect to punish any detected defector in the previous round.
- Attempt to recover cooperation after a single defection by returning to cooperation if all cooperate again.
- Defect in the last round to maximize immediate payoff if cooperation is broken (endgame reasoning).
- Protect the stock by switching to cooperation if the stock falls near depletion, to preserve future payoffs.

---

## Key Design Components

### 1. Initial Trust & Cooperation
- **Round 1:** Cooperate.
- Reason: Start with the cooperative action, trusting others initially.

### 2. Monitoring Opponents' Actions
- After each round, observe everyone’s actions.
- If *all* cooperated last round, continue cooperating.
- If *any* defected last round, switch to punishment (defection).

### 3. Punishment Phase (Trigger Strategy)
- Once a defection is detected, punish by defecting in the *next round*.
- If after punishment, all observed cooperate, return to cooperation.
- This creates a "grim-trigger light" — a one-round defection punishment phase followed by forgiveness.

### 4. Stock-Driven Adaptation
- Define a **threshold stock level** `T = capacity / 2` (half the max).
- If stock falls below `T`, prioritize cooperation to allow resource regeneration.
- Even if defectors try to exploit, cooperate individually to conserve stock.
- If stock is very low (e.g., below `capacity / (4n)`), fully cooperate regardless of previous defections.

### 5. Last Round Defection (Backward Induction)
- **Round r:** If the game reaches the last round and cooperation exists, defect for the one-shot gain.
- Exception: If stock is nearly depleted (too small payoff), cooperate anyway.
- Reason: No future punishment possible; defecting yields more payoff in last round.

---

## Pseudocode: Cooperative Strategy for Player i

```python
def cooperative_strategy(history, S_t, round_t, n, r, capacity):
    """
    history: List of tuples of form [(a_1,...,a_n)_1, ..., (a_1,...,a_n)_{t-1}]
        where each a_i ∈ {C, D}
    S_t: current stock before current round t
    round_t: current round (1-based)
    n: number of players
    r: total number of rounds
    capacity: maximum sustainable stock
    
    Returns: 'C' or 'D'
    """
    # Parameters
    threshold_stock = capacity / 2
    critical_stock = capacity / (4*n)
    
    # 1. First round: cooperate
    if round_t == 1:
        return 'C'
    
    # Retrieve previous round actions
    previous_actions = history[-1]  # tuple/list of length n
    
    # 2. Detect if any player defected in last round
    defectors_last_round = [j for j, act in enumerate(previous_actions) if act == 'D']
    any_defected_last_round = len(defectors_last_round) > 0
    
    # 3. Punishment logic:
    # Determine if we are in punishment phase:
    # We punish only for one round after detecting defection
    
    # Check if we punished last round by defecting
    my_last_action = previous_actions[i-1]  # zero based indexing
    
    # Count if last round was punishment (ours or others)
    punished_last_round = my_last_action == 'D' and any_defected_last_round
    
    # 4. Stock based adaptation
    # If stock below critical level, cooperate to help recovery no matter what
    if S_t < critical_stock:
        return 'C'
    
    # If stock below threshold, prioritize cooperation to rebuild stock
    if S_t < threshold_stock:
        # If last round was full cooperation and no defection, continue cooperating
        if not any_defected_last_round:
            return 'C'
        else:
            # If defection happened, punish once and then try cooperation
            if not punished_last_round:
                return 'D'
            else:
                return 'C'
    
    # 5. Handle defectors
    if any_defected_last_round:
        # If we did not punish last round, punish now
        if not punished_last_round:
            return 'D'
        else:
            # After punishing once, if all cooperate, forgive
            # Here, "all cooperate" means all cooperated in current round? No info yet
            # So, we forgive after one round punishment anyway
            # So in next round after punishment, cooperate
            return 'C'
    
    # 6. Normal cooperation if no defectors detected and stock healthy
    if round_t < r:
        return 'C'
    
    # 7. Last round (round_t == r)
    # Defect unless stock too low (then cooperate for minimal payoff)
    if S_t >= critical_stock:
        return 'D'
    else:
        return 'C'
```

---

## Narrative Summary of the Strategy

- **Start by cooperating**, showing good faith.
- **Monitor others’ behavior each round**:
  - If everyone cooperated, keep cooperating.
  - If any defected, **punish once by defecting next round**.
  - If no further defections, **forgive and return to cooperation**.
- **Watch the resource stock**:
  - If the resource is getting depleted (stock below half capacity), cooperate to allow recovery.
  - If critically low stock, always cooperate to avoid collapse.
- **In the last round, defect** if the stock is sufficient to gain more, as there is no future punishment possible.
- The strategy balances **sustaining the resource** and **enforcing cooperation through limited punishment**, encouraging long-term cooperation by linking behavior to resource health and maintaining incentive to cooperate rather than defect.

---

## Why This Strategy Is Cooperative

- It **starts cooperatively** and only defects as **a measured punishment** against defection.
- It **allows quick recovery** to cooperation after punishment, avoiding endless retaliation.
- It **actively manages the resource stock** to sustain mutual benefits.
- It uses **common knowledge and observability** to identify defectors and respond appropriately.
- It recognizes **the finite horizon** with a last-round defection, consistent with backward induction rationality.
- It **does not exploit defection unfairly** but uses defection strategically to maintain cooperation.

---

This strategy encourages a cooperative equilibrium with a self-enforcing punishment to deter defection, while preserving the common pool resource for sustained payoffs over multiple rounds.
'''

description_COOPERATIVE_54 = '''
Here is a cooperative strategy designed for the Common Pool Resource Game under the conditions and limitations you specified.

---

## Strategy Overview: Tit-for-Tat with Forgiveness and Endgame Cooperation

This strategy aims to sustain the common pool resource by encouraging mutual cooperation (choosing C) while punishing observed defections (D) to prevent exploitation. It includes forgiveness to avoid endless retaliation cycles, and it anticipates the last rounds to avoid opportunistic defections at the end. It uses publicly observable actions and history, abiding by perfect information and repeated interactions, but no communication.

---

## Intuition

- Cooperate in the first round to establish trust.
- Continue cooperating so long as no player defects.
- If any player defects, punish by defecting in the next round (or for a few rounds), but forgive after that, returning to cooperation.
- In the last two rounds, defect to maximize individual payoff, as cooperation incentives unravel near the end (endgame effect).
- If the stock drops below a critical threshold, shift to cooperation to recover stock, or defect if stock is near zero to avoid collective losses.

---

## Parameters (for tuning)

- **punish_length**: number of rounds to defect after detecting a defection before forgiving (e.g., 1 round)
- **stock_threshold**: minimum stock level above which cooperation proceeds normally (e.g., 1.5 * n)
- **endgame_rounds**: number of last rounds where defecting is optimal (e.g., 2)

---

## Detailed Decision Rules

1. **Round 1**  
   Play **C** (cooperate).

2. **Rounds 2 to r - endgame_rounds**  
   - If in the previous round *all* players cooperated, play **C**.
   - If *any* player defected in the previous round (including yourself), enter a punishment phase:
     - Defect for `punish_length` rounds, then return to cooperation if no new defections observed.
   - Always monitor stock level:
     - If stock ≤ stock_threshold, cooperate regardless to help stock recover.
     - If stock = 0 (extinct), defect (nothing to lose).

3. **Last `endgame_rounds` rounds (r-endgame_rounds+1 to r)**  
   - Defect every round (play D) to maximize short-term payoff.

---

## Pseudocode

```python
# Inputs per round t:
#   history: list of tuples (actions_in_round), each tuple of size n ('C' or 'D')
#   stocks: list of stock values at start of each round
# Parameters:
punish_length = 1
stock_threshold = 1.5 * n  # example threshold, tunable
endgame_rounds = 2

# Internal state:
punish_counter = 0

def decide_action(t, history, stocks, player_index):
    S = stocks[t-1]  # stock at start of current round
    n = len(history[0]) if t > 1 else n  # number of players
    
    if t == 1:
        # First round: cooperate to build trust
        return 'C'
    
    # Endgame defecting
    if t > r - endgame_rounds:
        return 'D'
    
    # Check stock level to guard against collapse
    if S <= 0:
        # Resource depleted, defect to maximize payoff on depleted commons
        return 'D'
    elif S <= stock_threshold:
        # Resource low, cooperate to assist recovery
        return 'C'
    
    # Check previous round actions
    prev_actions = history[t-2]
    any_defected = any(a == 'D' for a in prev_actions)
    
    global punish_counter
    
    if punish_counter > 0:
        punish_counter -= 1
        # Continue punishing if in punishment phase
        if punish_counter == 0:
            # Forgive after punish_length rounds, return to cooperation next round if no new defections
            if any_defected:
                # New defection detected, reset punish phase
                punish_counter = punish_length
            return 'D'
        else:
            return 'D'
    
    if any_defected:
        # Enter punishment
        punish_counter = punish_length
        return 'D'
    
    # Otherwise, cooperate
    return 'C'
```

---

## Explanation and Rationale

- **First round cooperation** encourages others to cooperate by setting a positive example.
- **Punishment phase** discourages repeated exploitation: if any player defects, defect for `punish_length` rounds.
- **Forgiveness** allows the cycle of retaliation to end, avoiding perpetual mutual defection.
- **Stock monitoring** ensures the strategy is adaptive: if the stock gets dangerously low, cooperate to help it recover instead of pushing it to collapse.
- **Endgame defection** leverages standard backward induction insight: the incentive to cooperate vanishes in the last rounds, so the strategy defects to maximize payoff.
- The parameters (punish_length, stock_threshold, endgame_rounds) can be adjusted based on empirical observation or simulations.

---

## Notes on Limitations

- This strategy cannot enforce cooperation unilaterally but tries to sustain cooperation by punishing defections.
- Without communication or coordination, full cooperation cannot be guaranteed against all strategies.
- Forgiveness helps avoid an arms race of defections.
- Stocks dynamics may enable cooperation to sustain a high stock level, yielding better long-term payoffs.

---

If you want, I can also provide a more advanced "Gradual Punishment" or "Reactive Trust" strategy, but the above is a strong baseline cooperative approach that leverages classical folk-theorem reasoning, tailored to the specific game dynamics here.
'''

description_COOPERATIVE_55 = '''
Below is a detailed cooperative strategy designed to maximize long-term collective payoff in the Common Pool Resource Game. It balances restraint and punishment to incentivize cooperation, and accounts explicitly for start, continuation, and endgame behavior.

---

## Strategy Name: **Conditional Cooperation with Gradual Punishment**

---

### Intuition / Overview

- **Goal:** Sustain the common pool near capacity to maximize long-term returns for all players (including myself).
- **Cooperation mode:** Play **C** to consume conservatively, preserving the stock and enabling growth.
- **Defection detection:** Monitor for any player(s) defecting—consuming more than cooperative share.
- **Punishment:** If a defection is detected, switch to defecting (**D**) for a small number of rounds proportional to defection severity to reduce defectors' incentives.
- **Forgiveness:** After punishment, return to cooperation if all cooperate again.
- **Endgame:** On the last round, defect to maximize final payoff, as no future punishment or reward is possible.

---

### Rationale

- The stock dynamics reward cautious consumption (cooperation).
- Defection yields a higher immediate payoff but damages the resource.
- Repeated interaction and observation enable sustained cooperation via threat of punishment.
- Punishments are measured to avoid needless chaos while disciplining defectors.
- Endgame defection is standard in finite repeated games with no continuation.

---

### Notation

- Let:
  - `t` ∈ {1,...,r} be the round index
  - `S_t` be the stock at start of round t
  - `a_i,t` ∈ {C,D} be my action at round t
  - `A_{-i,t}` be vector of other players' actions at t
  - `Obs_t` be the observed actions of all players in round t (including myself)
  - `Past_t` be the history up to the start of round t

- Parameters for internal use:
  - `punish_rounds`: number of rounds to punish defection, e.g., 2 rounds
  - `punishment_counter`: counts how many punishment rounds remain

---

### Decision Rules

#### Step 1: Initialization (start of round 1)

- `punishment_counter ← 0`

#### Step 2: Each round `t` from 1 to r

If `t == r` (last round):

- **Play Defect (D)** (gain maximum immediate payoff, no future rounds to protect)

Else if `punishment_counter > 0`:

- **Play Defect (D)**
- Decrement `punishment_counter` by 1

Else:

- Check opponents' last round action (round `t-1`) if `t > 1`:

  - For each opponent `j`:

    - If opponent `j` played **D** in round `t-1` **and** stock level after round `t-1` fell below a threshold (e.g., less than 90% initial capacity):

      - **Defection detected**

      - Set `punishment_counter ← punish_rounds`

      - Immediately **play Defect (D)** this round

      - Break loop (only need to punish once per detected defection)

- If no defection detected (or `t==1`):

  - **Play Cooperate (C)**

---

### Handling special cases / notes

- **First round (t=1):** No prior history, so cooperate.

- **Stock Threshold:** Use current stock `S_t` to gauge when defection damages resource — avoid punishing for marginal or accidental decreases.

- **Punishment period:** Limited length to avoid permanent defection if defectors repent.

- **Multiple defectors:** Same punishment applies collectively.

- **Observation:** Perfect information ensures all actions are known.

- **Robustness:** If multiple defections happen, punishment counter resets accordingly.

---

### Pseudocode

```python
initialize punishment_counter = 0
punish_rounds = 2       # configurable parameter

for t in 1 to r:

    if t == r:
        # Last round: defect for max payoff
        action = D

    elif punishment_counter > 0:
        # Currently punishing defectors
        action = D
        punishment_counter -= 1

    else:
        if t == 1:
            # First round, no history: cooperate
            action = C

        else:
            # Check opponents' previous actions
            defection_detected = False

            for opponent in opponents:
                if opponent.action[t-1] == D:
                    # Check stock depletion severity
                    if stock[t] < 0.9 * capacity:  # threshold example
                        defection_detected = True
                        break

            if defection_detected:
                # Start punishment period this round
                punishment_counter = punish_rounds
                action = D

            else:
                # No defection, cooperate
                action = C
```

---

### Summary

This strategy promotes cooperation by:

- Starting with cooperation.
- Sustaining cooperation as long as all cooperate and stock remains high.
- Detecting and punishing defection only if resource damage is significant.
- Limiting punishment duration to encourage return to cooperation.
- Maximizing last round payoff by defecting.

It aligns clear incentives, builds trust, and protects the common resource effectively in the absence of communication or coordination devices.
'''

description_COOPERATIVE_56 = '''
Below is a cooperative strategy designed to maximize long-term total payoffs by sustaining the common pool resource while also responding to defections by other players. The strategy aims to foster cooperation but also protects itself from exploitation by defectors.

---

## Intuition and Rationale

- **Cooperation (action C)** uses half the per-player extraction of defection, allowing the stock to regenerate more effectively.
- Mutual cooperation sustains high stock levels and high overall payoffs over time.
- Defections accelerate depletion, harming everyone in the long run.
- The strategy punishes detected defections by responding with defection in subsequent rounds but returns to cooperation if others do, incentivizing restoring cooperation.
- In the **final round**, with no future incentives, the strategy defects to maximize one-shot payoff.
  
This is a form of *conditional cooperation* with *punishment* and *forgiveness*.

---

## Strategy Description

### 1. Variables maintained:

- `round`: current round number (1 to r)
- `history`: previous rounds of all players' actions; in particular, `actions_prev = [a_1, a_2, ..., a_n]` from last round
- `defectors_last_round`: players who defected last round (played D)

### 2. Decision rules for player i in round t:

- **Round 1:**
  - Cooperate (C) unconditionally (trial of trust, no information yet)
  
- **Rounds 2 to r-1:**
  - If **no other player defected in previous round** (∀j ≠ i, a_j^{t-1} == C):
    - Cooperate (C) to sustain common stock
  - Else (some players defected last round):
    - Defect (D) in current round to punish defectors and discourage unilateral defection
    - Exception:   
      - If in the previous round you also defected, but this round you observe **all cooperated** last round, return to cooperate (forgiveness), else continue defecting
  - In short: defect if detected defection last round, else cooperate.
  
- **Round r (Final round):**
  - Defect (D) unconditionally (one-shot incentive to maximize payoff)

---

## Pseudocode for player i:

```python
def strategy(round, r, n, history, player_index):
    # history: list of previous rounds' actions for all players
    # Example: history[-1] = [a_1, a_2, ..., a_n] actions of last round
    
    if round == 1:
        # Start cooperatively to build trust
        return 'C'
    
    if round == r:
        # Last round: defect to maximize immediate payoff
        return 'D'
    
    # From round 2 to r-1:
    actions_last = history[-1]  # actions of all players last round
    
    # Identify if any other player defected last round
    defectors_last = [j for j, a in enumerate(actions_last) if a == 'D' and j != player_index]
    
    # Our own last action
    my_last_action = history[-1][player_index]
    
    if len(defectors_last) == 0:
        # No one defected last round -> cooperate
        return 'C'
    else:
        # Someone defected last round
        if my_last_action == 'D':
            # If I already defected last round and now others cooperate (check previous round within history)
            # Forgiveness rule: if all cooperated in previous round before last (t-2), start cooperating again
            if round > 2:
                actions_before_last = history[-2]
                others_cooperated_before_last = all(
                    (actions_before_last[j] == 'C') for j in range(n) if j != player_index
                )
                if others_cooperated_before_last:
                    # Forgive and return to cooperate
                    return 'C'
            # Otherwise continue defecting to punish
            return 'D'
        else:
            # I cooperated last round but others defected -> defect now to punish
            return 'D'
```

---

## Explanation of forgiveness logic

- If I defected last round to punish defectors but observe that in the round before last everyone cooperated (signal of restored cooperation), I forgive by cooperating again.
- This prevents endless cycles of mutual defection due to retaliation.
- Forgiveness promotes returning to cooperation.

---

## Summary

| Round         | Condition                                            | Action          |
|---------------|-----------------------------------------------------|-----------------|
| 1             | First round                                         | Cooperate (C)   |
| 2 to r-1      | No defectors last round                             | Cooperate (C)   |
| 2 to r-1      | Defectors last round AND you cooperated last round | Defect (D)      |
| 2 to r-1      | Defectors last round AND you defected last round:  |                 |
|               | - If all cooperated two rounds ago, Forgive        | Cooperate (C)   |
|               | - Else continue defecting                            | Defect (D)      |
| r (final)     | Any                                                 | Defect (D)      |

---

## Cooperative mindset alignment

- Starts by trusting others and cooperating.
- Enforces cooperation by punishing defectors to avoid over-exploitation of resource.
- Forgives when mutual cooperation is restored to avoid escalation.
- Maximizes long-run payoff by maintaining stock near capacity.
- Avoids exploitation by retaliating against defectors.
- Defects in final round because no future to protect, maximizing own payoff at the end.

---

This strategy balances patience, enforcement, and forgiveness suitable for the game’s dynamics and constraints. It is a classic conditional cooperator adapted to this common pool resource environment.
'''

description_COOPERATIVE_57 = '''
Below is a cooperative strategy designed for this Common Pool Resource game. It is based on maintaining the sustainability of the resource while seeking to build mutual trust and maximize cumulative payoffs through cooperation. The strategy incorporates conditional cooperation with clear rules for responding to defections, and nuanced behavior for first and last rounds.

---

## Cooperative Strategy: "Sustained Reciprocity with Endgame Awareness"

### Intuition
- Cooperate initially to promote resource sustainability and build trust.
- Continue cooperating as long as all others cooperate, thereby keeping stock at high levels.
- If any defection is observed, respond by defecting for a fixed "punishment" period to discourage free-riding.
- After punishment, return to cooperation — forgive but do not forget.
- In the last round, defect (since there is no future incentive to cooperate) to maximize final payoff.
- Edge cases handled with clear rules and stock-awareness.

---

### Parameters and Definitions

- **n, r, capacity:** game parameters (known)
- **S_t:** stock at the beginning of round t (observed)
- **history:** record of all previous rounds, including all players’ actions
- **punishment_length:** number of rounds to defect after observing defection (e.g., 2)
- **punishment_counter:** counts down remaining punishment rounds
- **defection_detected:** boolean flag for detecting defection in previous rounds

---

### Decision Rules (at round t)

```
If t == r:  
    # Last round: defect to maximize immediate payoff (no future consequences)
    Play D
Else if punishment_counter > 0:
    # Currently punishing defectors
    Play D
    punishment_counter -= 1
Else:
    # Check previous round(s) for defections by any player other than self
    if t == 1:
        # First round: cooperate to signal willingness
        Play C
    else:
        if any player j ≠ self defected in round t-1:
            # Defection detected last round: start punishment
            punishment_counter = punishment_length - 1  # this round counts as 1
            Play D
        else:
            # No defection observed, cooperate
            Play C
```

---

### Explanation and Rationale

1. **First Round (t=1):**  
   - Always cooperate to demonstrate willingness to sustain the resource.
   - This helps keep stock high from the start.

2. **Intermediate Rounds (1 < t < r):**  
   - Monitor actions of all other players.
   - If cooperation continues (no one defects), continue cooperating.
   - If any defection detected, punish by defecting for **punishment_length** rounds.
   - Punishment deters others from defecting since defection leads to immediate retaliation, lowering everyone's payoff.
   - After punishment rounds, revert to cooperation to allow trust rebuilding and resource recovery.
   - The choice of punishment length balances deterrence and forgiveness.

3. **Last Round (t = r):**  
   - No future rounds to incentivize cooperation.
   - Defect to maximize immediate payoff, as defection yields more payoff per round.

4. **Stock Awareness:**  
   - Although not explicitly checking stock levels, the design of cooperative play promotes maintaining stock near capacity.
   - If stock falls too low due to repeated defections, cooperating still yields maximal sustainable benefit in the medium term.
   - Defecting deprives everyone of future payoffs via resource collapse.

---

### Optional Enhancement: Minimal Stock Threshold Check (to avoid stock collapse)

If you want to be stock-aware, you can add:

```
Define threshold = capacity / 4  # e.g., 25% of capacity

# Before acting (except last round):

If S_t < threshold:
    # Stock dangerously low; prioritize cooperation to promote recovery
    Play C

Else:
    # Follow standard rules above
```

---

### Pseudocode Summary

```
Initialize:
    punishment_length = 2
    punishment_counter = 0

For t in 1..r:
    Observe S_t, history of all actions
    
    If t == r:
        action = D
    Else if punishment_counter > 0:
        action = D
        punishment_counter -= 1
    Else:
        if t == 1:
            action = C
        else:
            if any j != self defected at round t-1:
                punishment_counter = punishment_length - 1
                action = D
            else:
                action = C

    Execute action
```

---

### Summary

- Start cooperative.
- Cooperate as long as nobody defects.
- Punish defection with a fixed number of defect rounds.
- Return to cooperation (forgive) after punishment.
- Defect in final round.
- The strategy aims to sustain the common pool stock, maximize long-run payoffs, and encourages others to cooperate by credible threat and forgiveness cycles.

---

This strategy balances sustainability, reciprocity, and strategic consideration of the endgame — matching the cooperative mindset within the constraints of no communication and perfect observability.
'''

description_COOPERATIVE_58 = '''
Below is a cooperative strategy designed to support sustainable exploitation of the common pool resource by maintaining a healthy stock through mutual cooperation, with measured punishment to discourage defections. It leverages the knowledge of all players' actions each round (perfect information) but requires no communication or coordination beyond that.

---

### **Cooperative Strategy: "Gradual Reciprocity with Forgiveness"**

#### **Key Intuition**
- In the **first round**, cooperate to establish trust and maximize stock sustainability.
- As long as **all players cooperated in the previous round**, cooperate again, supporting sustainable resource use and stable payoffs.
- If **any player defects in a round**, punish by defecting once in the next round to discourage free-riding.
- After punishing, return immediately to cooperation (forgiveness), allowing recovery of cooperation if others comply.
- In the **last round**, defect (exploit maximally) since future retaliation is impossible (backward induction).
  
This balances sustainability, punishment, and forgiveness, consistent with folk-theorem logic for repeated games.

---

### **Notation**
- `round`: current round number, 1 ≤ round ≤ r
- `history`: list of all previous rounds, where each round record contains all players' actions
- `my_index`: your own player index (1 to n)
- `n`: number of players
- `capacity`: maximum stock

---

### **Decision Rule**

```pseudocode
function decide_action(round, history):
    if round == 1:
        // First round: start cooperatively
        return C

    if round == r:
        // Last round: defect to maximize final payoff (no future costs)
        return D

    last_round_actions = history[round - 1]  // actions of all players in previous round

    // Check if all players cooperated last round
    if all(action == C for action in last_round_actions):
        return C  // mutual cooperation: cooperate

    else:
        // Some players defected last round, so punish this round

        // Punish by defecting once
        punished_last_round = (round >= 3) and 
            (some_player_defected(history[round - 2])) and 
            (all_actions_were_defect_in_punishment_round(history[round - 1]))

        if punished_last_round:
            // Punishment already executed last round, forgive now
            return C

        else:
            // Punish defectors by defecting this round
            return D
```

---

### **Explanation**

- **Round 1:** Start cooperatively to encourage reciprocity and protect the stock early on.
- **Rounds 2 to r-1:**  
  - If all cooperated last round → cooperate now → sustain stock and maintain good payoffs.  
  - If any defected last round → defect this round as punishment → reduce incentives to defect.  
- **Punishment management:**  
  Use a **one-round punishment** approach—punish once immediately following a defection round, then forgive (return to cooperation), resetting the norm. This prevents permanent defection spiral and encourages re-cooperation.
- **Round r (last round):**  
  Defect to secure maximal final round payoff since no future retaliation exists.

---

### **Handling Ambiguities and Edge Cases**

- If multiple rounds in a row have defection(s), the punishment still stays one round per defection event, granting forgiveness whenever no recent defection.
- If multiple players defected, punish all in the next round with defect.
- If you detect your own mistake (accidental defection), you will still be punished one round but can return to cooperation after.
- If the stock reaches very low levels due to others’ persistent defections, you still follow the punishment-forgiveness cycle, as individual defection does not help regenerate stock.

---

### **Summary:**

| Situation                          | Action            |
|----------------------------------|-------------------|
| Round 1                          | Cooperate (C)     |
| Round r (last round)             | Defect (D)        |
| All players cooperated last round | Cooperate (C)     |
| Some player(s) defected last round & punishment NOT executed yet | Defect (D) (punish) |
| Some player(s) defected last round & punishment executed last round | Cooperate (C) (forgive) |

---

### **Rationale for Cooperation**

This strategy sustains the resource near capacity by encouraging repeated mutual cooperation which consumes only stock/(2n), preventing rapid depletion. The occasional one-round punishment for defections deters exploitation, but forgiveness offers a path back to cooperation, preventing the tragedy-of-the-commons collapse. Defecting last round virtue maximizes terminal payoff as backward induction prescribes.

Thus, it aligns well with cooperative mindset within the game’s constraints.

---

If you want, I can also provide this as a more formal algorithm or in a different style—just ask!
'''

description_COOPERATIVE_59 = '''
Below is a detailed cooperative strategy design for the Common Pool Resource game, aiming to maximize total collective payoff by maintaining the stock at sustainable levels and punishing defection to deter free-riding.

---

# Cooperative Strategy Design

---

## Rationale / Goals

- **Long-run sustainability:** Maintain the stock near capacity to maximize repeat payoffs.
- **Mutual cooperation:** Everyone cooperates (chooses C) to consume minimally, enabling growth of the common pool.
- **Punishment of defection:** Defection harms the pool; detect it and respond with temporary punishment to discourage free-riding.
- **Forgiveness:** After punishment phase, return to cooperation to allow recovery.
- **Endgame behavior:** In last round, defect because no future punishment is possible.

---

## Core Ideas

- **Cooperation baseline:** Always play C if all others cooperated last round and stock is sufficient.
- **Detection:** If any player defects, transition to a punishment phase.
- **Punishment phase:** Punish by defecting for a fixed number of rounds to reduce the defectors’ short-run payoff.
- **Recovery:** After punishment phase, return to cooperation unless further defections are detected.
- **Last round:** Unconditionally defect (D) to maximize immediate payoff.

---

## Parameters

- `punishment_length`: number of rounds to punish after detecting defection (e.g., 1 or 2 rounds)
- `state variables` maintained locally:
  - `punishment_counter`: counts down remaining punishment rounds
  - `defection_detected`: boolean flag if defection was seen last round
  - `round_number`: current round (1 to r)
  - `stock_history`: recorded stocks from previous rounds
  - `action_history`: recorded action profiles from previous rounds

---

## Decision Rules Summary

| Condition                                      | Action       |
|------------------------------------------------|--------------|
| Last round (round_number == r)                 | Defect (D)   |
| In punishment phase (punishment_counter > 0)  | Defect (D)   |
| Else if everyone cooperated last round         | Cooperate(C) |
| Else (defection detected last round)           | Enter punishment phase, Defect (D) |

---

## Detailed Strategic Steps

### Initialization (Round 1)
- Cooperate (C) unconditionally since no history is available.
- Set `punishment_counter = 0`, `defection_detected = False`

### General round t, 1 < t < r
1. Observe last round's actions of all players.
2. If someone defected last round (any action D), set `defection_detected = True`.
3. If `defection_detected` and `punishment_counter == 0`, start punishment:
   - Set `punishment_counter = punishment_length`.
4. If `punishment_counter > 0`:
   - Play D
   - Decrement `punishment_counter` by 1
   - If `punishment_counter == 0`, clear `defection_detected`
5. Else if no defection last round:
   - Play C

### Last round (round r)
- Unconditionally defect (D), maximize final payoff since no future punishment possible.

---

## Pseudocode

```python
# Parameters
punishment_length = 2  # can be tuned

# State variables initialized before round 1
punishment_counter = 0
defection_detected = False

for round_number in range(1, r+1):

    if round_number == 1:
        action = 'C'  # No history yet

    elif round_number == r:
        action = 'D'  # Last round, defect to maximize payoff

    else:
        # Inspect last round's actions of all players, including self
        last_round_actions = get_actions(round_number - 1)

        if 'D' in last_round_actions:
            defection_detected = True

        if punishment_counter == 0 and defection_detected:
            # Start punishment phase
            punishment_counter = punishment_length

        if punishment_counter > 0:
            action = 'D'
            punishment_counter -= 1
            if punishment_counter == 0:
                defection_detected = False  # End punishment phase
        else:
            action = 'C'

    play(action)
```

---

## Handling Edge Cases

- **First round (no history):** Always cooperate to foster trust and start stock on a good path.
- **Last round:** Defect unconditionally, standard backward induction result in finitely repeated games with no future punishment.
- **Stock depletion impact:** Strategy does not rely explicitly on stock level except via observed actions, as defectors naturally harm stock which triggers punishment; minimal stock means low payoff for all, encouraging cooperation.
- **Multiple defectors:** Punishment phase treats any defection equally, collectively punishing to enforce cooperation norm.
- **If opponents never cooperate:** This strategy will defect during punishment and then try cooperation again after punishment phase, ready to punish again if defection recurs. It tries to sustain cooperation but punishes persistent defectors.

---

## Why This Strategy Is Cooperative

- It tries first to maintain cooperation and preserve the common resource.
- It punishes defectors but then forgives, enabling return to cooperation.
- It balances incentives: cooperation maximizes the long-run joint payoff by stabilizing the common pool stock.
- Punishment deters selfish behavior, boosting overall group benefit.
- It respects the game's repeated structure and moves in a way compatible with standard Tit-for-Tat-like cooperative strategies known in repeated games.

---

If you want, I can also provide a variant with stock-threshold heuristics or probabilistic forgiveness, but the above is a clean, canonical cooperative strategy suitable for this setting.
'''

description_COOPERATIVE_60 = '''
**Cooperative Strategy for the Common Pool Resource Game**

---

### High-Level Intuition

The key to cooperation in this repeated common pool resource game is to sustain the resource stock close to capacity to maximize ongoing payoffs over all rounds.

- Cooperating (C) uses less stock per player, preserving the resource.
- Defecting (D) gains a higher short-term payoff but risks depleting the stock, reducing future payoffs for everyone.
- Since payoffs are cumulative over rounds and future rounds depend on current stock, maintaining high stock benefits all, including oneself.
- Because the game has no communication or coordination channels, the strategy relies on **observable actions** and **credible punishment** to enforce cooperation.

---

### Core Principles of the Strategy

1. **Start cooperatively** (play C in round 1) assuming others do too.
2. **Maintain cooperation as long as everyone cooperates.**
3. **Detect defections by others using the observed consumption behavior inferred from changes in stock.**
4. **Punish defectors with temporary defection to discourage further betrayal (grim-trigger softened).**
5. **Forgive after punishment if cooperation resumes to avoid endless retaliation.**
6. **In the final round, defect (D) to maximize immediate gain since no future rounds remain.**

---

### Detailed Rule Description

Notation:

- `t`: current round (1 ≤ t ≤ r)
- `S_t`: stock at start of round t (observed after round t-1)
- `actions_t-1`: vector of all players' actions observed last round
- `n`: number of players
- `capacity`: maximum sustainable stock
- `my_last_action`
- `punishment_rounds_left`: counter to track how many rounds remain in punishment for defections

---

### Decision Rules Per Round

**If t == 1:**
- Play **C** (cooperate), establish cooperative baseline.

**Else if t == r:**
- Play **D** (defect), since no future rounds—maximize last round payoff.

**Else (1 < t < r):**

1. **Check for defections in last round:**  
   Evaluate whether the *observed* actions imply defection by others.  
   Since actions are simultaneous and observable post round, we can perfectly observe whether each opponent cooperated or defected in round t-1.  
   - If **any player defected** in round t-1 (including self), start or continue a punishment phase.
   - Else continue cooperating.

2. **Punishment phase:**  
   - When detecting defection by others, punish them by defecting for `P` rounds (where `P` is a small fixed number, e.g., `P=2`) to discourage defections.
   - Maintain a counter `punishment_rounds_left` initialized at detection of defection.
   - Defect in punishment rounds, then reset back to cooperation if no new defections.
   
3. **Forgiveness and return to cooperation:**  
   - If no defections detected during punishment rounds, after `P` rounds, reset `punishment_rounds_left=0` and return to cooperation.
   
4. **If no defections detected and not in punishment, cooperate.

---

### Pseudocode

```python
# Parameters
PUNISHMENT_LENGTH = 2  # rounds of punishment after detecting defection

# State variables (per player instance)
punishment_rounds_left = 0

def decide_action(t, r, n, capacity, S_t, actions_last_round, punishment_rounds_left):
    """
    inputs:
        t: int, current round number (1-based)
        r: int, total rounds
        n: int, number of players
        capacity: float, max stock
        S_t: float, current stock at start of round t
        actions_last_round: list of chars ['C' or 'D'] of length n from last round
        punishment_rounds_left: int, rounds left in current punishment phase
    
    returns:
        action: 'C' or 'D'
        updated_punishment_rounds_left: updated punishment counter
    """

    # 1. First round: cooperate
    if t == 1:
        return 'C', 0

    # 2. Last round: defect (no future to protect)
    if t == r:
        return 'D', 0

    # 3. For intermediate rounds:

    # Check if a defection occurred last round (ANY player defected)
    someone_defected = ('D' in actions_last_round)
    
    if someone_defected:
        # Start or continue punishment phase
        punishment_rounds_left = max(punishment_rounds_left, PUNISHMENT_LENGTH)
    
    # If currently punishing, defect and decrement punishment counter
    if punishment_rounds_left > 0:
        punishment_rounds_left -= 1
        return 'D', punishment_rounds_left

    # No defections recently detected, cooperate
    return 'C', 0
```

---

### Strategy Explanation & Advantages

- **Cooperate initially** to signal cooperative intent and preserve stock.
- **Punish defections temporarily** to provide incentive to others to cooperate (defection earns short-term gain, but triggers punishment reducing future gains).
- **Return to cooperation** after punishment avoids escalation of endless defections (contrasts with grim-trigger which never forgives).
- **Defect in last round** to reap final-stage immediate payoff when future repercussions do not matter.
  
This approach encourages mutual cooperation by linking future payoffs to present behavior, relying on transparency of actions and stock state.

---

### Edge Case Handling

- **First Round**: Always cooperate to build trust.
- **Last Round**: Defect since no future rounds to preserve.
- **Punishment Length**: Fixed short length (`P=2` rounds) balances deterrence and forgiveness.
- **Multiple Defectors**: Detecting any defection triggers punishment.
- **Self-Defection**: If accidentally defected last round (e.g., due to own bug or error), treat as defection and punish self as well to preserve credibility; alternatively, do not punish yourself separately but respond in the same way (above pseudocode treats any detected defection uniformly).
- **Stock Fluctuations**: Instead of relying on inferred consumption from stock changes (which might be noisy), use observed actions directly since they're given perfectly.
  
---

### Summary

This strategy fosters cooperation by:

- Starting cooperative
- Monitoring all players' actions
- Using finite, temporary punishments for defections
- Forgiving to stabilize cooperation
- Defecting last round to maximize final payoff

It aligns incentives so everyone benefits from mutual cooperation and discourages unsustainable harvesting behaviors.
'''

description_COOPERATIVE_61 = '''
Below is a detailed cooperative strategy design tailored to the described Common Pool Resource Game, emphasizing mutual cooperation, punishment of defection, and careful handling of edge cases such as the first and last rounds.

---

## Cooperative Strategy: "Reciprocal Cooperation with Forgiveness and Endgame Awareness"

### Intuition
- **Baseline:** Start cooperatively to sustain the resource and maximize long-term payoffs.
- **Punishment:** Defect temporarily if defection detected among others, to incentivize return to cooperation.
- **Forgiveness:** Allow quick return to cooperation if opponents revert to cooperating, avoiding endless retaliation.
- **Endgame:** Adjust behavior in last round(s) anticipating no future consequences.
- **Resource-sensitive:** Defect if stock is critically low to avoid total collapse.
  
---

### 1. Key Concepts and Notation

- **R:** total rounds.
- **t:** current round, t ∈ {1, 2, …, R}.
- **n:** number of players.
- **A_i,t:** Action of player i in round t (C or D).
- **H_{t-1}:** history up to round t-1 (all players’ actions).
- **S_t:** common pool stock at start of round t.
- **Thresholds:**
  - Stock critical threshold `S_crit` = capacity / (4) — below which defect to avoid irreversible depletion.

---

### 2. Strategy Outline

**Initialisation:**
- Round 1: Cooperate (play C) to signal trust and sustain stock.

**In rounds 2 to R - 1:**

- Observe history: identify if defectors exist from previous round (t-1).
- If **no defection detected** among others in previous round → cooperate.
- If **defection detected** among others in previous round:
  - Punish by defecting in current round.
  - Forgive if all players cooperate in current round after punishment.
  
- If stock falls below `S_crit` at start of round → defect to maximize immediate payoff (resource may not recover sufficiently).

**Last round (t = R):**

- Defect regardless of history to maximize final immediate payoff since no future punishment is possible.

---

### 3. Detailed Decision Rules

Let:
- `OppDefect(t-1) = True` if any other player defected in round t-1, else False.
- `PunishmentState`: Boolean flag whether currently punishing.
- Initial: `PunishmentState = False`

Pseudo variables maintained internally:
- `PunishmentCounter`: number of consecutive punishment rounds.

**At round t, do:**

```
If t == 1:
    Play C  # Start cooperatively

Else if t == R:
    Play D  # Final round defect to maximize payoff

Else:
    If S_t < S_crit:
        Play D  # Stock too low, defect to maximize immediate gain

    Else if PunishmentState == False:
        If OppDefect(t-1) == False:
            Play C  # No defection detected, keep cooperating
        else:
            PunishmentState = True
            PunishmentCounter = 1
            Play D  # Start punishing defectors

    Else if PunishmentState == True:
        If OppDefect(t-1) == False:
            PunishmentState = False  # Defectors returned to cooperation, forgive
            Play C
        Else:
            # Continue punishment for up to 2 rounds total
            If PunishmentCounter < 2:
                PunishmentCounter += 1
                Play D
            Else:
                # Forgive after 2 rounds punishment to avoid endless cycle
                PunishmentState = False
                Play C
```

---

### 4. Explanation & Rationale

- **Cooperate initially:** To demonstrate goodwill, help maintain the resource.
- **Defect final round:** No future to protect against; rational to harvest maximum now.
- **Stock threshold defect:** If stock critically low, cooperating only hurts your payoff since stock may not regenerate effectively.
- **Punishment:** Defect once if defection detected to discourage freeriding.
- **Forgiveness and limit on punishment rounds:** Avoid infinite retaliation cycles that degrade payoffs for all.
- **Monitor actions each round:** Because perfect monitoring is allowed, the strategy can react swiftly to defection.

---

### 5. Strategy Benefits & Cooperative Alignment

- Maximizes long-term joint payoffs by encouraging mutual cooperation.
- Deterrent against defection without harsh permanent punishment.
- Forgiveness helps restore cooperation quickly.
- Adapts to resource state dynamically, preventing collapse.
- Rational final-round defect respects game-theoretic endgame incentives.
  
---

# Summary

| Situation                            | Action    |
|------------------------------------|-----------|
| First round (t=1)                   | Cooperate |
| Last round (t=R)                   | Defect    |
| Stock below critical threshold     | Defect    |
| No defection last round             | Cooperate |
| Defection detected last round       | Defect (start or continue punishment up to 2 rounds) |
| Post-punishment and opponents cooperate | Cooperate (forgive) |

---

# Optional Pseudocode

```python
def cooperative_strategy(t, R, S_t, capacity, history, n, PunishmentState, PunishmentCounter):
    S_crit = capacity / 4
    if t == 1:
        return 'C', PunishmentState, PunishmentCounter  # start cooperating
    if t == R:
        return 'D', PunishmentState, PunishmentCounter  # defect final round

    # Detect defection in previous round by others
    prev_actions = history[t-2]  # zero-indexed; t-2 corresponds to round t-1
    OppDefect = any(a == 'D' for i,a in enumerate(prev_actions) if i != player_index)

    if S_t < S_crit:
        return 'D', PunishmentState, PunishmentCounter  # defect if stock low

    if not PunishmentState:
        if not OppDefect:
            return 'C', False, 0  # cooperate when no defection
        else:
            # start punishment
            return 'D', True, 1

    else:  # PunishmentState == True
        if not OppDefect:
            # forgive and cooperate
            return 'C', False, 0
        else:
            if PunishmentCounter < 2:
                return 'D', True, PunishmentCounter + 1
            else:
                # end punishment after two rounds
                return 'C', False, 0
```

---

This strategy combines standard cooperative repeated-game approaches (tit-for-tat style), resource state awareness, and final-round rationality, and should compete well in a tournament of independently generated strategies with transparent game rules and histories.
'''

description_COOPERATIVE_62 = '''
Here is a carefully designed **Cooperative Strategy** for the given Common Pool Resource Game, balancing cooperation incentives and punishment to sustain cooperation over multiple rounds.

---

## Intuition and Goals

- Cooperation (C) by all players sustains the stock near capacity, maximizing long-term payoffs for everyone.
- Defection (D) yields higher immediate payoff but risks severe stock depletion, harming everyone.
- Without communication or trust guarantees, the strategy must rely on *observed opponent behavior* and *punishment* to deter defection.
- Because perfect cooperation is fragile, the strategy uses *trigger punishments* to discipline defectors but also a *forgiveness mechanism* to return to cooperation.
- Last round defecting is individually rational (no future punishment), so in the last round defecting to maximize payoff is accepted.

---

## Strategy Description

### Definitions:
- Let **t** ∈ {1, ..., r} be the current round.
- Let **S_t** be the current stock at the start of round t (all players observe this).
- Let **history** up to round t-1 record all players’ past actions.
- Define **defectors_t-1** as the set of players who defected in round t-1.
- Parameter: **punishment_duration = 2 rounds** (can be tuned).

---

### 1. First round (t=1):

- Cooperate (C) unconditionally.
- Rationale: Start with trust to build cooperative norm.

---

### 2. Intermediate rounds (1 < t < r):

- **Step 1: Check punishment status**

  If currently *in a punishment phase* against any player(s), respond by defecting against those players (or defect unconditionally to signal punishment).

- **Step 2: Otherwise, check opponent behavior in previous round (t-1):**

  - If no defections observed in round t-1 (everyone cooperated), then **Cooperate (C)**.

  - If any defections observed in t-1:

    - Enter *punishment phase* targeting the player(s) who defected:

      - Defect in the next `punishment_duration` rounds against defectors.

      - Cooperate against players who cooperated at t-1.

      - Use observed player action history to implement *conditional defection* against defectors, cooperation against cooperators.

- **Step 3: Forgiveness**

  - After punishment_duration rounds, return to unconditional cooperation with all, erasing grudge.

---

### 3. Last round (t = r):

- Defect (D) unconditionally (to maximize final payoff).

- Rationale: There is no future punishment, so cooperating in final round is dominated by defecting.

---

### Edge cases handling:

- If stock falls very low (e.g., below n × D-consumption), defection may be collectively futile.

- To prevent collapse, if stock < threshold (e.g., stock < capacity/4), then cooperate to aid stock recovery pragmatically.

---

## Pseudocode

```python
initialize:
    punishment_duration = 2
    punishment_counters = dict()  # player_id -> rounds left in punishment
    all_players = {1,...,n}

for round t in 1 to r:
    observe stock S_t
    observe previous round actions: actions_{t-1} (empty if t=1)

    if t == 1:
        # Start cooperatively
        action = 'C'

    elif t == r:
        # Last round defect unconditionally
        action = 'D'

    else:
        # Update punishment_counters based on previous round
        # Decrease counters
        for p in punishment_counters.keys():
            punishment_counters[p] = max(0, punishment_counters[p]-1)
            if punishment_counters[p] == 0:
                del punishment_counters[p]

        # Identify defectors last round
        defectors_last_round = {p for p, a in actions_{t-1}.items() if a == 'D'}

        # If new defectors appeared last round, add them to punishments
        for d in defectors_last_round:
            if d not in punishment_counters:
                punishment_counters[d] = punishment_duration

        # Determine if I am currently punishing someone
        if punishment_counters:
            # If I am punishing this round:

            # If I was notified as a defector (i.e., punished), I defect
            # If you want to target defectors precisely:
            # Defect if self is in punishment target? 
            # But since I am a single player, I only decide my own action:

            # To discourage defectors, defect now to punish defectors
            action = 'D'

        else:
            # No active punishment, cooperate
            action = 'C'

        # Edge stock low: cooperate to aid recovery
        threshold = capacity / 4
        if S_t < threshold:
            action = 'C'
```

---

## Explanation

- **Start cooperatively:** Sets baseline trust, maximizing shared payoff.

- **Punishment phase:** Any defection triggers 2 rounds of defection punishment targeting defectors, signaling impact and deterring future defection.

- **Punishment duration:** Short but costly enough to discourage defection.

- **Forgiveness:** After punishment, return to cooperation, promoting long-run cooperation resilience.

- **Last round defect:** Rational individual action.

- **Stock threshold cooperation:** Prevents destructive depletion spirals by cooperating when resource critically low.

---

## Notes on Implementation in Tournament

- The strategy relies solely on publicly observable actions.

- No explicit identification signals, no randomization needed.

- Prioritizes cooperation, punishes defections quickly but forgives, promoting stable cooperation.

- Last round defecting yields maximum payoff without endangering future cooperation (which does not exist).

---

# Summary

**The strategy is a conditional cooperation plan that:**

- Cooperates initially and as long as no defection is observed

- Punishes defectors with 2 rounds of defection

- Forgives and returns to cooperation afterward

- Defects unconditionally in the last round

- Aids recovery if stock falls critically low

This aligns tightly with cooperative principles within the constraints of no communication and perfect information repeated game.
'''

description_COOPERATIVE_63 = '''
**Cooperative Strategy: "Conditional Gentle Cooperation with Forgiveness and Final Round Defection"**

---

### Key Ideas

- Aim to maintain the common pool near or at capacity to enable sustained cooperation.
- Cooperate unless there is clear evidence that others defected, then punish temporarily.
- After punishment, forgive and return to cooperation to rebuild trust and stock.
- On the **last round**, maximize own payoff by defecting because no future rounds remain to incentivize cooperation.
  
This strategy is inspired by "tit-for-tat"-like logic adapted to a dynamic resource with growth, and the mixed payoff structure, balancing individual incentives and collective benefit.

---

### Intuition / Explanation

- **Why cooperate?** Consuming moderately (C) preserves the stock, leading to repeated benefits for all.
- **Why punish defectors?** Defectors (D) over-consume, depleting stock; unless punished, they will continue.
- **Why forgive?** Harsh permanent punishment collapses cooperation; forgiving allows return to sustained cooperation.
- **Why defect last round?** No incentive exists to preserve stock beyond the last round, so defect to maximize payoff.

---

### Notation

- Let t ∈ {1,..., r} be the current round.
- Let S_t be the stock at the start of round t.
- Let A_i,t ∈ {C, D} be your action at round t.
- Let A_{-i,t} be the vector of other players' actions at round t.
- Observed history up to round t - 1: actions and payoffs of all players.
- Threshold variables:
  - `defect_detected`: boolean indicating if defection was detected last round.
  - `punish_rounds_remaining`: integer counter for punishment length.

---

### Decision Rules

#### Initialization
- Start with no punishment: `punish_rounds_remaining = 0`

#### Round 1 (t=1)

- **Action:** Cooperate (C)
- Reason: No history yet, start on good-faith cooperation.

#### Rounds 2 to r-1 (1 < t < r)

- **Step 1: Detect defection last round**

  - If any player defected last round (t-1), i.e. `D` chosen by others in last round → set `defect_detected = True`.
  - Else `defect_detected = False`.

- **Step 2: Manage punishing phase**

  - If `punish_rounds_remaining > 0`:
    - Continue punishing by defecting (D).
    - Decrement `punish_rounds_remaining`.
  - Else if `defect_detected == True` and `punish_rounds_remaining == 0`:
    - Start punishment: set `punish_rounds_remaining = 2` (for example, punish for 2 rounds).
    - Defect (D) this round.
  - Else (no defection detected, no punishment ongoing):
    - Cooperate (C).

- **Step 3: Forgiveness**

  - After punishment rounds complete, return to cooperation.
  - Forgiveness helps reset cooperation cycle.

#### Round r (last round)

- Defect (D)
- Reason: No future rounds to sustain cooperation benefit; maximize immediate payoff.

---

### Endogenous Check: Stock Level Safety

Optionally, if stock is extremely low (e.g., S_t < n):

- Regardless of punishment or defection cycles, cooperate to aid stock recovery.
  
This prevents inevitable collapse if stock is exhausted.

---

### Pseudocode

```python
# Parameters
n  # number of players
r  # total rounds
capacity  # max stock capacity

# Variables (outside main loop)
punish_rounds_remaining = 0  # counts how many rounds remain in punishment
last_round = r

for t in range(1, r+1):

    if t == 1:
        # First round: cooperate
        action = 'C'

    elif t == last_round:
        # Last round: defect for immediate gain
        action = 'D'

    else:
        # Check if any other player defected last round
        defect_detected = any(other_action == 'D' for other_action in actions_of_others_in_round(t-1))

        if punish_rounds_remaining > 0:
            # Continue punishment
            action = 'D'
            punish_rounds_remaining -= 1

        else:
            if defect_detected:
                # Start punishment phase
                punish_rounds_remaining = 2  # punish 2 rounds after detection
                action = 'D'
            else:
                # No defection detected, cooperatively consume
                action = 'C'
```

---

### Summary

| Round    | Condition                               | Action                   |
|----------|---------------------------------------|--------------------------|
| 1        | Initial round                         | Cooperate (C)            |
| 2 to r-1 | Punishment ongoing                    | Defect (D)               |
| 2 to r-1 | Defection detected last round         | Start Punishment (D)     |
| 2 to r-1 | No defection detected & no punishment | Cooperate (C)            |
| r (last) | Any                                  | Defect (D)               |

---

### Why this works

- Starts with goodwill → builds cooperative momentum.
- Punishes defectors quickly → deters over-consumption.
- Forgives → returns to cooperation, enabling stock recovery.
- Last round defection exploits last-move advantage given no incentive to cooperate.

This is a *conditional cooperation* strategy compatible with repeated dynamics and observable actions/payoffs, balancing collective good and self-interest without explicit communication.
'''

description_COOPERATIVE_64 = '''
Here is a cooperative strategy designed to sustainably maximize long-term payoffs by maintaining the common pool, while punishing defection to discourage free-riding. It combines:

- Initial full cooperation  
- Continual monitoring of others' behavior  
- Retaliation phases on detecting defection  
- Forgiveness to restore cooperation following punishment  
- Special handling for the **last round** considering no future interaction  

---

## Intuition and Goals

- Cooperation: Each player consumes **stock/(2n)** → less depletion per round → stock sustainable → high cumulative payoffs.
- Defection is tempting because defectors get higher payoff that round but accelerate stock depletion, reducing future gains.
- Punish defections to deter.
- Forgive to avoid prolonged deadlock.
- On last round, defect to maximize immediate payoff (since no future rounds).
  
---

## Notation

- Let `t` = current round number, from 1 to r
- Let `actions[t][i]` = observed action of player i in round t (`C` or `D`)
- Let `defectors_in_last_round` = set of players who defected in previous round
- Let `punishment_rounds` = number of rounds to punish defectors after detecting defection (tunable parameter, e.g. 1 or 2 rounds)
- Let `punishment_counter` = counter for how many rounds of punishments remaining
- Let `defector_detected` = boolean flag indicating if defection was detected last round

---

## Decision Rules (Pseudocode)

```pseudo
Initialize:
  punishment_rounds := 2  // Number of rounds to punish defectors after detection
  punishment_counter := 0 // Counts punishment rounds left
  defector_detected := False
  defectors_in_last_round := empty set

For each round t in 1 to r:

  If t == r:
    # Last round: Defect (greedy)
    action := D

  Else if t == 1:
    # First round: Cooperate (establish cooperation)
    action := C

  Else:
    # For t > 1 and before last round

    # Step 1: Analyze previous round actions of others
    defectors_in_last_round := { j | j ≠ self and actions[t-1][j] == D }

    If defectors_in_last_round is not empty:
      defector_detected := True
      punishment_counter := punishment_rounds

    If punishment_counter > 0:
      # Punishment phase: defect to punish defectors
      action := D
      punishment_counter := punishment_counter - 1

    Else:
      # No detected defection, cooperate to maintain cooperation
      action := C

  # Return action for current round
```

---

## Explanation

- **Round 1**: Cooperate to signal willingness to sustain the stock.
- **Rounds 2 to r-1**:
  - If no defections observed last round, cooperate.
  - If defections observed last round, punish by defecting for a fixed number of rounds (`punishment_rounds`), regardless of who the punisher is.
  - After punishment rounds exhausted, return to cooperation (forgiveness).
- **Round r**:
  - Defect, because it’s the last round and no future retaliation is possible.
  
---

## Key Features

- **Cooperation as Default**: Maximize sustainability and joint payoff.
- **Deterrence via Punishment**: Defection triggers defection for next `punishment_rounds` rounds, reducing incentive to defect.
- **Forgiveness**: Punishment is temporary, preventing endless retaliation cycles.
- **Last Round Defection**: Recognizes rational incentive to defect last round; no retaliation possible.

---

## Adaptations and Parameters

- `punishment_rounds` can be tuned. Longer punishments harshly deter defections but risk lowering payoffs if accidental/noisy defections occur.
- Monitoring all players’ actions except oneself assumes perfect observation.
- Strategy does not rely on coordination beyond observed past actions.
- If you want to be more lenient, decrease punishment rounds to 1.
- If you expect many defectors, harsher punishment might be needed.

---

## Summary

This strategy embodies **“Conditional Cooperation + Punishment + Forgiveness + Endgame Defection”**, a common robust design in repeated common pool resource games with no communication, to maximize long-run cooperative payoffs and deter short-term temptation to defect.

---

If you want, I can also provide a concise step-by-step bullet version or formal pseudocode in a code block. Just ask!
'''

description_COOPERATIVE_65 = '''
Here is a robust cooperative strategy respecting your constraints and aiming to sustain the common pool resource while responding to defections fairly.

---

## Cooperative Strategy: "Conditional Fair Cooperation with Forgiveness"

### Intuition
- Aim to maintain the resource pool near or at capacity, maximizing joint long-run payoffs.
- Begin cooperatively to establish good will.
- Detect defections by monitoring others’ actions (via inferred consumption).
- Punish defectors temporarily by defecting against them, but forgive after punishment to resume cooperation.
- Slightly defect in the last round to capture any remaining personal payoff (endgame effect).
- This balances collective sustainability with incentives to deter and recover from free-riding.

---

### Notation & Observations
- `n`: number of players
- `r`: total rounds
- `capacity`: max stock
- `S_t`: stock at start of round t
- `A_{i,t}`: action of player i in round t (C or D)
- `π_{i,t}`: player i’s payoff in round t
- From observed payoffs of others at round t - 1, we infer their actions:
  - payoff = S_{t-1} / (2n) ⇒ player cooperated at t-1
  - payoff = S_{t-1} / n ⇒ player defected at t-1
- We keep a **history** record of observed actions for all players.

---

### Decision Rules

#### Round 1 (Initialization)
- **Action**: Cooperate (C) because no history of defection exists.
- **Rationale**: Signal cooperative intent and help build sustainable stock.

#### Rounds 2 to r - 1 (Intermediate Rounds)
- Calculate defector set from previous round’s observations:  
  \[
    D_{t-1} = \{ j \neq i : A_{j,t-1} = D \}
  \]

- Maintain a **punishment memory** with counter `punish_until[j]` for each player j:
  - If player j defected at t-1, set `punish_until[j] = t + P - 1`
  - `P` is fixed punishment length, e.g., `P = 2` rounds.

- **Action Decision**:

  1. If current round \( t \leq \max_j punish_until[j] \) for some j who defected:
     - Defect against defectors in the punishment phase
     - Cooperate with all others

     Since actions are simultaneous and the game does not allow distinguishing which players we defect against separately, the best implementable proxy:
     - **If any active punishees exist (`punish_until[j] ≥ t`), defect this round.**
     - Else cooperate.

  2. If no active punishments, cooperate.

- **Rationale**:  
  - Defecting punishes defectors by reducing stock faster, decreasing defectors’ payoffs.
  - Forgiveness after punishment avoids endless cycles.
  - Cooperation with non-defectors preserves the resource.

#### Round r (Last Round)
- **Action**: Defect
- **Rationale**: No future rounds to sustain cooperation; defecting maximizes last round payoff.

---

### Summary in Pseudocode

```python
# Parameters
P = 2  # punishment length in rounds

# State
punish_until = {j: 0 for j in range(1, n+1) if j != self_id}  # track punishment end rounds per opponent

def infer_action(payoff, stock):
    # Payoff close to stock / (2n) = C, close to stock / n = D
    threshold_mid = (stock / (2*n) + stock / n) / 2
    if payoff < threshold_mid:
        return 'C'
    else:
        return 'D'

def decide_action(t, observed_payoffs_prev_round, stock_previous):
    global punish_until
    
    if t == 1:
        # Round 1: always cooperate
        return 'C'
        
    # Update punishments from previous round
    for j, payoff_j in observed_payoffs_prev_round.items():
        action_j = infer_action(payoff_j, stock_previous)
        if action_j == 'D':
            punish_until[j] = max(punish_until.get(j, 0), t + P - 1)

    # Check if in punishment phase against any defector
    if t < r and any(punish_until[j] >= t for j in punish_until):
        # Punish in intermediate rounds
        return 'D'

    # Last round defect
    if t == r:
        return 'D'

    # Otherwise cooperate
    return 'C'
```

---

### Notes on Cooperation Alignment

- This strategy starts cooperatively and aims to sustain the pool by consistent cooperation unless punished.
- It strictly punishes defectors but only temporarily, allowing returns to cooperation to maximize collective payoffs.
- It uses observed payoffs to infer others’ actions transparently.
- The forgiveness window prevents long-term retaliation cycles that would collapse the resource.
- Defecting last round recognizes endgame incentives to maximize personal gain when cooperation incentives vanish.

---

### Extensions / Variations (if allowed)

- Use a tolerance threshold: only punish if number of defectors exceeds a small fraction.
- Gradually escalate punishment if repeated defection occurs.
- Implement "generous" forgiveness: randomly forgive defectors earlier to avoid destabilizing cooperation.

---

If you want, I can help formalize this strategy further or analyze its theoretical robustness.
'''

description_COOPERATIVE_66 = '''
Here is a cooperative strategy design for the Common Pool Resource Game that respects the game constraints and aims to maximize joint payoffs through sustainable use of the common pool.

---

## Intuition & Goals

- Cooperation (C) means each player consumes a smaller part of the stock, allowing it to replenish.
- Defection (D) means higher immediate payoff but risks depleting the resource.
- Since the game is repeated, the strategy should encourage sustained cooperation for maximal total payoffs.
- Punishments for defections should be clear but forgiving to restore cooperation.
- On the last round, no future punishment is needed, so defecting can be optimal.
- Monitoring opponents' actions is possible via past round actions (perfect information).

---

## Key Observations

- If everyone cooperates every round, the stock remains at capacity and payoffs are steady.
- A single defection risks lowering stock but may gain a short-term advantage.
- Identifying defectors and responding helps enforce cooperation.
- Strategy must be robust without explicit communication or coordination protocols.

---

## Proposed Strategy: **"Gradual Conditional Cooperation with Last Round Defect"**

---

### Parameters used in strategy

- **Tolerance threshold for defections:** 0 defectors tolerated per round.
- **Punishment length:** 1 round of punishment for a defection (short but credible).
- **Punishment response:** Defect once against detected defection.
- **Last round behavior:** Defect unconditionally in last round (to maximize individual payoff).

---

### Strategy outline

**Round 1 (t=1):**  
- **Action:** Cooperate (C)  
- **Reason:** Establish cooperative baseline, no history yet.

**Any round before the last (1 < t < r):**  
- **If no defections detected in previous round (t-1):**  
  - Cooperate (C)  
  
- **If any player defected in previous round (t-1):**  
  - Punish defectors by defecting in current round (D)  
  - For others (non-defectors), continue cooperating (C)  
  - (If you defected last round, continue defecting this round as self-punishment)  
  
- **After punishment round:**  
  - Return to cooperate if no new defections occur.  

**Last round (t = r):**  
- **Defect (D) unconditionally.**  
- Rationale: No future rounds to lose by defecting; maximize last round payoff.

---

### Detecting Defectors

- In round t, player observes actions of all n players in round t-1.
- Defectors = players who played D in t-1.

---

### Pseudocode

```python
# Inputs per round t:
# history_actions: list of lists, length (t-1), each sublist of length n
#   history_actions[t-1][i] = action of player i+1 in round t (0-index)
# player_id: your player index (0 to n-1)
# r: total rounds
# t: current round (1-indexed)

def cooperative_strategy(t, player_id, history_actions, r):
    if t == 1:
        # First round - start by cooperating
        return 'C'
    
    if t == r:
        # Last round - defect to maximize payoff
        return 'D'
    
    # Identify defectors in previous round
    prev_round = history_actions[t-2]  # t-2 because t is 1-indexed
    defectors = [i for i, a in enumerate(prev_round) if a == 'D']
    
    if len(defectors) == 0:
        # No defections last round, cooperate
        return 'C'
    
    # Punishment phase:
    # If I defected last round, continue defecting (self-punishing)
    if prev_round[player_id] == 'D':
        return 'D'
    
    # If not defected last round, punish defectors by defecting this round
    # (Since actions are simultaneous, your defection punishes defectors by reducing stock)
    return 'D'
```

---

### Explanation

- **First round:** Cooperate to establish good faith.
- **Between rounds 2 and r-1:**  
  - If everyone cooperated previously, keep cooperation.
  - If anyone defected, defect once to punish.
  - Players who defected last round must also defect now to sustain punishment on themselves.
  - After punishment round, if no new defections occur, return to cooperate.
- **Last round:** Defect as final payoff-max attempt, since no future consequences.

---

### Why this works as a cooperative strategy?

- It sustains cooperation as long as all cooperate.
- Deter defection by punishing immediately but briefly.
- Forgiveness after 1-round punishment allows to restore cooperation.
- Defection on last round is rational and socially efficient given no future.
- No assumptions about opponents communicating or coordinating.
- Uses perfect information to identify defectors exactly.
- Aligns with maximizing group payoffs and ensures sustainability of stock.

---

### Additional remarks:

- This is a *trigger-style* strategy with very short memory and punishment to avoid over-penalizing.
- Can be adapted with longer punishment if desired.
- Designed to work symmetrically for all players.
- Can tolerate no defectors; even a single defection triggers punishment.
- If all players use this, the outcome is cooperation until last round, with high sustainability and payoffs.

---

If you want, I can also produce a version with more forgiving or harsher punishment policy, or a more nuanced approach based on stock level. But given the problem statement, this strikes a careful balance between cooperation, punishment, and payoff maximization.
'''

description_COOPERATIVE_67 = '''
Here is a cooperative strategy tailored to the given Common Pool Resource (CPR) game. It aims to sustain the resource while maximizing long-term group payoffs under perfect monitoring and without explicit communication.

---

## Intuition and Objectives

- Cooperation (C) means consuming **less** (stock/(2n)) so the resource regenerates better.
- Defection (D) means consuming **more** (stock/n) short term, risking resource collapse.
- The stock regenerates **best at intermediate depletion levels**, so sustaining cooperation maintains a high steady stock.
- The strategy aims to:
  - Start cooperatively to build goodwill and resource stock.
  - Punish defection by defecting in the next round but try to **forgive and return to cooperation** if opponents do so.
  - Adjust behavior if the stock is low to avoid complete collapse.
  - Defect in the last round (endgame) since no future rounds exist to punish defections.
  
---

## Strategy Description

### Parameters and Variables

- `t`: Current round number (1 to r)
- `history`: Full history of all players' actions each round
- `S_t`: Observed stock at start of round t (known since actions and consumption are public)
- `C_players`: Set of players who cooperated in the previous round
- `D_players`: Set of players who defected in the previous round
- `defected_last_round`: Boolean flag if **any** other player defected in round t-1
- `low_stock_threshold`: A fraction of capacity considered "low" (e.g., 30% of capacity)

### High-Level Rules

1. **Round 1 (No history): Cooperate.**  
   Start trusting others and consume moderately.

2. **Rounds 2 to r-1:**
   - **If no one defected last round:** Cooperate.
   - **If anyone defected last round:** Defect this round as punishment.
   - **If stock is low (≤ low_stock_threshold × capacity):** To avoid collapse, defect to maximize immediate payoff and avoid stock depletion spiral.

3. **Round r (Last round): Defect.**  
   No incentive to maintain cooperation on last round.

---

## Pseudocode

```python
def cooperative_strategy(t, history, S_t, capacity, n):
    low_stock_threshold = 0.3  # 30% of capacity
    
    if t == 1:
        # Round 1: Trust and cooperate
        return 'C'
    
    if t == r:
        # Last round: Defect
        return 'D'
    
    # From round 2 to round r-1:
    # Check if any players defected last round
    last_round_actions = history[t-2]  # zero-index correction: t=2 means history[0]
    
    # Ignore self's action in punishment calculation (player i is not known here,
    # but assuming symmetric strategy, each player applies same rules)
    defected_last_round = any(action == 'D' for action in last_round_actions)
    
    # If stock is low, defect to maximize own payoff
    if S_t <= low_stock_threshold * capacity:
        return 'D'
    
    if defected_last_round:
        # Punish defection by defecting this round
        return 'D'
    else:
        # Otherwise cooperate
        return 'C'
```

---

## Explanation and Cooperative Alignment

- **Start cooperatively** to foster resource sustainability and establish a cooperative environment.
- **Punish defection with defection in the following round** to discourage free-riding, implementing a simple grim-trigger or tit-for-tat style deterrent.
- **Forgive by returning to cooperation when opponents resume cooperation**, supporting the recovery of cooperation.
- **If resource stock falls very low, defect** to avoid being the sucker in a near-collapsed system. This reflects realistic risk aversion.
- **Defect in the last round** since no future interactions exist to enforce cooperation—standard backward induction.

---

## Additional Notes

- This is a **conditional cooperation strategy with a punishment phase** triggered by observed defection.
- Since all players act simultaneously and can perfectly observe actions and stock, this strategy uses that information fully.
- This strategy does **not assume explicit communication** or coordination beyond observing past actions and stock.
- It balances short-term self-interest and long-term sustainability.
- It is resilient against exploitation unless all players defect immediately, in which case the stock collapses (an unavoidable tragedy of the commons).

---

If desired, the threshold or punishment rules can be tuned for specific parameter values, but this template offers a clean, interpretable cooperative approach consistent with the game dynamics and constraints.
'''

description_COOPERATIVE_68 = '''
Here is a cooperative strategy designed to maximize the group's collective payoff by maintaining the common pool stock sustainably as long as possible, while considering potential defections and the dynamics of the game. This strategy is a conditional cooperation (trigger) strategy tailored for the given game setting and knowledge constraints.

---

## Cooperative Strategy: "Sustained Reciprocity with Punishment and Endgame Adjustment"

### Overview

- **Goal:** Sustain the common pool stock near capacity by cooperating (consuming less) as long as no defections are observed.
- **Punishment:** Permanently punish any observed defection by defecting henceforth to deter free-riding.
- **Endgame:** Defect in the last round (or last few rounds) to maximize individual payoff since no future punishment is possible.
- **First round:** Cooperate to signal cooperative intent.
- **Stock-based adjustment:** Defect if stock is critically low to maximize short-term payoff (self-protection).

---

### Key Intuitions

- Cooperation (C) consumes stock/(2n), which is half the consumption of defection (D). Collective cooperation preserves the stock, allowing growth to replenish it.
- Defection gives higher immediate payoff but risks stock collapse and long-term loss.
- Defection by any player reduces total payoff for all, so cooperation must be conditional on others cooperating.
- Last round(s) are effectively a one-shot game, incentivizing defection.

---

### Parameters and Variables

- `n`: Number of players.
- `r`: Number of rounds.
- `t`: Current round (1-based).
- `capacity`: Capacity of the stock.
- `S_t`: Stock at start of round `t`.
- `history`: List of tuples of actions per round for all players, known at start of each round `t`.
- `self_i`: Own player index.
- `defected`: Flag indicating if any defection by any player was detected so far.
- `low_stock_threshold`: Threshold below which cooperation is futile (e.g., 10% of capacity).
- `endgame_rounds`: Last `k` rounds to defect unconditionally (e.g., last round or last two rounds).

---

### Decision Rules (Pseudocode)

```python
def choose_action(t, S_t, history, self_i, capacity, n, r):
    low_stock_threshold = 0.1 * capacity   # e.g., 10% of capacity
    endgame_rounds = 1                      # Defect in the last round
     
    # 1. First round: cooperate to signal cooperative intent
    if t == 1:
        defected = False
        return 'C', defected
    
    # 2. Observe past rounds for defection by any player
    # history is a list of rounds; each round is a list of n actions
    previous_actions = history[t-2]  # actions in round t-1 because t is 1-based
    if any(action == 'D' for action in previous_actions):
        defected = True
    else:
        # Check if defection was detected earlier
        defected = any('D' in round_actions for round_actions in history[:t-1])
    
    # 3. Endgame defect
    if t > r - endgame_rounds:
        return 'D', defected
    
    # 4. If defection previously detected, permanently defect (punishment)
    if defected:
        return 'D', defected
    
    # 5. Stock-based adjustment: if stock critically low, defect to maximize payoff
    if S_t < low_stock_threshold:
        return 'D', defected
    
    # 6. Otherwise, cooperate
    return 'C', defected
```

---

### Explanation

- **Round 1:** Start by cooperating to build trust and maximize group payoff.
- **Detection of Defection:** Monitor actions to detect if any player defected. Because actions are observable, defection cannot be hidden.
- **Permanent Punishment:** If anyone defects even once, switch permanently to defection to discourage exploitation.
- **Endgame Defection:** Since no future retaliation is possible, defect at the last round to maximize the last payoff.
- **Stock Threshold:** If stock falls below a critical threshold (e.g., 10%), cooperation likely leads to poor payoffs next rounds due to no recovery or very small growth. Thus defecting preserves individual payoff.

---

### Cooperative Alignment

- The strategy maximizes joint payoffs by sustaining the stock through cooperative consumption as long as no one defects.
- It enforces cooperation via the threat of permanent defection punishment.
- It recognizes rational incentives to defect in the last round, so preempts by defecting there.
- It guards against stock collapse by defecting if stock is almost depleted, where cooperation is no longer beneficial.
- It never defects first (except last round), showing a cooperative mindset and willingness to cooperate when trust persists.

---

### Summary

| Round Condition                | Action                     |
|-------------------------------|----------------------------|
| Round 1                       | Cooperate (C)              |
| Any prior defection detected   | Defect (D) permanently     |
| Round is last or last few      | Defect (D)                 |
| Stock < 10% capacity            | Defect (D)                 |
| Otherwise                    | Cooperate (C)              |

---

This strategy strikes a balance between cooperation and deterrence, leveraging perfect monitoring and repeated interaction to sustain the common pool resource optimally while rationally handling endgame and edge cases.
'''

description_COOPERATIVE_69 = '''
Below is a cooperative, conditional strategy designed for the Common Pool Resource game. It promotes long-term mutual sustainability and maximizes group benefits by maintaining the common stock close to capacity while punishing defections to deter over-extraction.


---

## Intuition and Rationale

- **Cooperation** means playing **C** (consume less = stock/(2n)) to maintain the common pool near its capacity and maximize steady payoffs.
- **Defection** means playing **D** (consume more = stock/n), which gains temporarily but risks stock depletion.
- Since all players share the pool, defectors hurt everyone, including themselves, over time.
- We want a strategy that:
  - Plays **C** to build and sustain the stock.
  - Detects and punishes defectors quickly.
  - Allows return to cooperation if others also return.
- The main tension is exploitation vs. sustainability. We build in **"trigger/punishment"** and **"forgiveness"** phases.

---

## Definitions and Observations

- Players have perfect info on all previous rounds' actions.
- Each round t, stock \( S_t \) is public (can be inferred from previous rounds).
- Number of defectors = count of players choosing **D** in \( t-1 \).
- Since players cannot communicate, everyone judges behaviour based on observed actions.
- Payoff incentives favor defecting on last round to maximize immediate payoff.
- But last-round defection destroys future rounds; no future rounds means no punishment possible.
- So: cooperation is optimal before last round if others cooperate.

---

## Strategy Outline

### Variables

- \( t \in \{1, \ldots, r\} \) : current round
- \( D_{t-1} \) : number of defectors observed last round (0 if \( t=1 \))
- \( P \) : punishment phase indicator (boolean), initially False
- \( M \) : memory about past defections, initially False

---

### Decision Rules

In round \( t \):

1. **First round \( t=1 \):**  
   - Cooperate (play C) — establish good-faith cooperation.

2. **If in punishment phase (P = True):**  
   - Defect (play D) — punish defection by defecting once.
   - After punishing exactly one round, return to cooperation (set \( P \leftarrow False \)) in next round.

3. **Otherwise (P = False):**  
   - If any defection detected last round (\( D_{t-1} > 0 \)):  
     - Enter punishment phase next round: set \( P \leftarrow True \).  
     - **This round:** Cooperate (play C).  
     - **Next round:** punish by defecting once.

   - Else (no defection last round):  
     - Cooperate (play C).

4. **Last round \( t=r \):**  
   - Cooperate if no defection last round (continue cooperation).  
   - If punishing (P = True), defect to punish last defection (since no future rounds to rebuild). 
   - If defect detected last round and not yet punished, defect this round to punish.

---

### Edge Cases

- If multiple defectors appear, single-round punishment may not be enough but limited to one round here to allow quick return to cooperation.
- Cooperation resumes immediately after punishing, to encourage others to cooperate again.
- If continuous defections occur, punishment cycles continue.
- On last round, you can defect to punish and/or maximize individual payoff since no future rounds.

---

## Pseudocode

```python
# Inputs per round:
# - t: current round number (1-based)
# - r: total rounds
# - history: list of previous rounds' actions, each a list of n actions ('C' or 'D')
# - P: punishment mode flag (boolean)
#
# Output:
# - action: 'C' or 'D'

def cooperative_strategy(t, r, history, P):

    if t == 1:
        # First round: cooperate
        return 'C', False  # action, punishment_flag

    # Count defections last round
    last_round_actions = history[t-2]  # zero-indexed
    num_defectors = last_round_actions.count('D')

    if P:
        # Currently punishing: defect this round, then stop punishing
        return 'D', False  # defect and stop punishing next round

    else:
        if num_defectors > 0:
            if t == r:
                # Last round: defect to punish and maximize payoff
                return 'D', False
            else:
                # Punish next round, cooperate this round
                return 'C', True
        else:
            # No defections detected, cooperate
            return 'C', False
```

---

## Explanation

- **First round:** Always cooperate to build trust and stock.
- **Detect defectors:** When anyone defects, we note and trigger one round of punishment *after* current round.
- **Punishment:** Single round defect to penalize defectors.
- **Forgiveness:** Return to cooperation immediately after punishment, promoting stable cooperation.
- **Last round:** Defect to punish or maximize immediate payoff, since no future rounds to consider.

---

## Advantages

- Promotes near-maximum stock through repeated cooperation.
- Deterrent against defectors via credible punishment.
- Forgiving — not stuck in endless punishment cycles.
- Transparent and deterministic based solely on observed actions.
- Simple enough to be robust against a variety of opponent strategies.

---

**Summary:**  
This is a *conditional cooperation* strategy with *tit-for-tat* style punishment delayed by one round, designed to sustain the common resource, discourage over-consumption, and enable mutual payoff maximization over repeated rounds.
'''

description_COOPERATIVE_70 = '''
Below is a cooperative strategy for the Common Pool Resource Game that aims to sustain the resource while maintaining fairness and mutual trust. The strategy is designed to maximize long-term collective payoffs by encouraging cooperation, detecting and punishing defection, and cautiously adjusting behavior near the game's end.

---

## Strategy Overview

- **Core idea:** Cooperate (play C) as long as all players have cooperated in previous rounds, maintaining the stock near capacity.
- **Detection:** Use observable actions to detect defection (players choosing D).
- **Punishment:** Temporarily defect (play D) to deter free-riding, but quickly return to cooperation if defection ceases.
- **Graceful endgame:** Gradually relax cooperative constraints as the game approaches the last rounds, since the incentive to conserve stock declines.
- **Edge cases:** Handle first round (no history), last round, and low-stock scenarios.

---

## Detailed Decision Rules

### Key variables and observed info per round t ≥ 1:

- `S_t` = current stock before actions in round t
- `actions_t-1` = vector of last round's actions by all players (if t > 1)
- `defections_last_round` = number of defectors detected in round t-1
- `round` = current round number
- `r` = total rounds
- `capacity` = max sustainable stock
- `n` = number of players

---

### Initial Parameters / Thresholds

- **Tolerance window:** Allow 0 defections tolerated; any defection triggers punishment.
- **Punishment duration:** Punish defectors by defecting for `p = 1` round. (Lenient to avoid endless cycles.)
- **Endgame cooperation relaxation:** Start at round `r - ceil(0.25*r) + 1` (last 25% rounds).
- **Minimum stock threshold for cooperation:** 0.5 * capacity (if stock < threshold, more cautious behavior applies).

---

### Strategy Pseudocode

```python
def cooperative_strategy(t, S_t, actions_t_minus_1, history_actions, capacity, n, r, state):
    # 'state' is local memory to track punishment rounds per player:
    # state = { 'punish_until_round': {player_i: round_number or 0}, 'defection_detected': False }
    
    # Initialize state if first call
    if state is None:
        state = { 'punish_until_round': {i: 0 for i in range(1, n+1)}, 'defection_detected': False }
    
    # Round 1: cooperate unconditionally since no history
    if t == 1:
        action = 'C'
        return action, state

    # Detect defectors from previous round
    defectors = []
    for i, act in enumerate(actions_t_minus_1, start=1):
        if act == 'D':
            defectors.append(i)

    # Update punishment state: punish for one round after detection
    for defector in defectors:
        state['punish_until_round'][defector] = t  # punish in this round t

    # Determine if current player is being punished (t <= punish_until_round[player])
    # We are player i (self/player index must be known)
    # Since strategy must be general, assume the function receives 'player_i' as argument
    player_i = state.get('player_i', 1)  # example default if not set, should be provided

    # If current player is punishing any defector (i.e., has defected previously)
    # or if punishment applies to self (not relevant here but can influence reciprocity)
    
    # Defection flag
    defection_in_last_round = len(defectors) > 0

    # Check if in punishment phase: if *any* defection happened last round, punish for 1 round
    punishment_active = defection_in_last_round and (t <= max(state['punish_until_round'].values()))

    # Endgame starts this round if t > r - ceil(0.25*r)
    endgame_start = r - (r + 3) // 4 + 1
    in_endgame = t >= endgame_start

    # Stock considerations
    low_stock = S_t < 0.5 * capacity

    # Decision rules:
    if in_endgame:
        # Last 25% rounds: defect to maximize own payoff (free riding justified by finite horizon)
        # But if stock is extremely low, cooperate minimally to prevent zero stock if beneficial
        if low_stock:
            action = 'C'
        else:
            action = 'D'

    else:
        if punishment_active:
            # Punishment: defect to discourage free-riding
            action = 'D'
        else:
            # Normal cooperative phase
            action = 'C'

    return action, state
```

---

## Explanation

1. **First Round:** Cooperate unconditionally to establish trust and avoid premature stock depletion.

2. **Ongoing Rounds:**
   - Observe previous round’s actions.
   - If everyone cooperated (`C`), continue cooperating to sustain the stock.
   - If defectors are detected (players played `D`), punish them by defecting once in the next round.
   - Punishments are temporary: defect only for 1 round as retaliation to limit escalation.
   - Resume cooperation immediately if defection stops, enabling quick return to mutual cooperation.

3. **Stock Awareness:**
   - The stock will replenish best if consumption stays around capacity/2.
   - The strategy favors cooperation to maintain the stock near capacity.
   - If stock becomes dangerously low (less than half capacity), the strategy cautiously cooperates even in the endgame to prevent collapse.

4. **Endgame Behavior (Last ~25% rounds):**
   - Purely rational incentive to defect and maximize immediate payoff because no future rounds remain.
   - The strategy defects unless stock is very low, in which case it cooperates to slightly extend usable stock, which can benefit final payoffs.

5. **Punishment Mechanism:**
   - Simple “grim-trigger-lite”: one-round defection in response to any defection last round.
   - Prevents endless cycles of defection since forgiveness is automatic.
   - Encourages other players to cooperate for mutual benefit.

---

## Cooperative Mindset Alignment

- Prioritizes **long-term sustainability** of the common pool by cooperating when possible.
- Enforces cooperation norms by responding to defection firmly but fairly.
- Avoids over-punishment to promote recovery from accidental or experimental defections.
- Accepts rational end-of-game behavior but mitigates extreme stock depletion.
- Uses **perfect information** assumption effectively by conditioning behavior on observed past.

---

# Summary

This strategy implements a **"reactive cooperation with limited punishment and endgame defection"** rule:

- Start with cooperate.
- If defection observed last round → punish by defecting one round.
- If no defection last round → cooperate.
- Near last rounds (last 25%) → defect unless stock is critically low.
- Track punishment rounds with memory to limit retaliation.
- Maintain stock near sustainable levels to maximize total payoffs.

---

If you want, I can provide a more formal presentation or a flowchart of decision steps.
'''

description_COOPERATIVE_71 = '''
**Cooperative Strategy for the Common Pool Resource Game**

---

### Intuition and Goal

- The **socially efficient steady-state stock level** emerges when the common pool is neither overexploited nor underused.
- Cooperation means *sustaining the resource* near the carrying capacity or at a level that maximizes total long-run payoffs.
- Defection leads to rapid depletion and ruin, harming everyone including the defector.
- Punishments (defections) discourage free-riding but should be limited to maintain cooperation.

---

### Key Observations from Game Specification and Examples

- **Cooperate (C)** consumes less per player → slower depletion → sustainable stock.
- **Defect (D)** consumes more per player → faster depletion → stock collapse risk.
- If everyone plays C, stock regenerates fully each round (example 1).
- If everyone plays D, stock collapses to 0 (example 2).
- Mixtures lead to intermediate stock levels and depletion risk (example 3).

---

### Strategy Outline

Our strategy: **Conditional Cooperation with Forgiveness and Endgame Defection**

- **Default:** Cooperate (play C)
- **Trigger for Punishment:** If any other player defects in the previous round, punish by defecting in the current round.
- **Length of Punishment:** Single-round punishment ("tit-for-tat" style).
- **Forgiveness:** Return to cooperation in the next round if no further defections.
- **Endgame behavior:** Defect in the last round to maximize last-round payoff (since no future retaliation possible).
- **Stock monitoring (optional):** If stock falls below a critical threshold (e.g., 20% capacity), cooperate unconditionally to help recovery.

---

### Detailed Decision Rules

1. **Round 1:** Cooperate.
2. **Rounds 2 to r-1:**  
   a. If *any player defected* in previous round → Defect this round (punishment).  
   b. Else → Cooperate.
3. **Round r (last round):** Defect unconditionally (no incentive to maintain cooperation).
4. **Stock check override:**  
   If the current stock S < 0.2 × capacity, *always cooperate* this round (even during punishment) to help stock recovery.
   This is to avoid irreversible collapse.
5. **Observation:** All decisions use **public information** (observed past actions and current stock).

---

### Explanation

- **Conditional Cooperation** enforces joint sustainability: players who defect impose a cost on themselves via reciprocal defection from us.
- **Single-round punishment** keeps cooperation stable but avoids potentially endless cycles of retaliation.
- **Endgame defection** exploits the last round's one-shot nature, maximizing immediate payoff.
- **Stock check override** preserves the resource base so cooperation remains possible in the future.
- Combined, these promote sustained cooperation where possible, deter defection, and adjust behavior as end approaches.

---

### Pseudocode

```python
def cooperative_strategy(round_index, total_rounds, current_stock, capacity, history_actions):
    """
    Parameters:
    - round_index: current round number (1-based)
    - total_rounds: total rounds r
    - current_stock: current stock level S
    - capacity: max sustainable stock level
    - history_actions: list of tuples (actions_this_round) for all previous rounds
                       where each element is a list of player actions ['C' or 'D']

    Returns:
    - 'C' or 'D' as action this round
    """
    # Threshold for stock recovery cooperation
    STOCK_RECOVERY_THRESHOLD = 0.2 * capacity

    # Endgame: last round - defect unconditionally
    if round_index == total_rounds:
        return 'D'

    # First round: cooperate
    if round_index == 1:
        return 'C'

    # Check stock recovery override
    if current_stock < STOCK_RECOVERY_THRESHOLD:
        # Help recovery by cooperating regardless of punishment
        return 'C'

    # Otherwise, check if anyone defected in previous round
    previous_round_actions = history_actions[-1]  # actions from last round
    if 'D' in previous_round_actions:
        # Punishment: defect this round
        return 'D'
    else:
        # No defection last round: cooperate
        return 'C'
```

---

### Summary

| Situation                     | Action               | Rationale                                       |
|------------------------------|----------------------|------------------------------------------------|
| Round 1                      | Cooperate (C)        | Establish cooperation                           |
| Round 2 to r-1               | Defect if last round had defection; else Cooperate | Punish defectors, but forgive quickly           |
| Stock below 20% capacity     | Cooperate (override) | Avoid collapse, preserve future cooperation    |
| Round r (last round)         | Defect (D)           | No future punishment possible, maximize payoff |

---

This strategy aligns with a **cooperative mindset** by:

- Rewarding cooperation with cooperation.
- Punishing defections swiftly but forgiving.
- Protecting the common resource stock to enable future gains.
- Optimizing self-interest in the last round consistent with standard repeated game theory.

---

If you want, I can help devise variations or analyze expected performance in specific environments!
'''

description_COOPERATIVE_72 = '''
Below is a cooperative strategy design for the described Common Pool Resource (CPR) game that seeks to sustain the resource and maximize long-term collective payoffs by encouraging mutual cooperation and punishing defection. It respects all given constraints and uses only observed history.

---

# Cooperative Strategy Design for CPR Game

## Intuition & Goals
- **Sustainability:** Keep the common pool stock near the capacity to maintain high future payoffs.
- **Cooperation:** Play C (cooperate) if others do, to share the resource evenly and allow regrowth.
- **Deterrence:** Defect (play D) only as a measured punishment when others defect, to discourage selfish overconsumption.
- **Forgiveness:** Return to cooperation if others do, to re-establish mutual benefit.
- **Edge cases:** Handle first round (no history) and last round (incentives may differ) explicitly.

---

## Key Observations from Game Specification
- Cooperators consume half as much as defectors: payoff per C = S/(2n); payoff per D = S/n.
- Defection reduces the stock more severely, risking collapse.
- Growth is maximized when stock after harvest is about **capacity / 2**.
- Total consumption below capacity maintains or grows stock; equal or excessive consumption causes depletion.
- Players have perfect information: can observe all players' actions and payoffs each round.

---

## Strategy Outline

### Notation
- `t`: current round (1 ≤ t ≤ r)
- `S_t`: stock at start of round t (known from history)
- `actions_{t-1}`: vector of all players' actions in round t-1 (empty if t=1)
- `defectors_{t-1}`: set of players who defected in round t-1
- `all_cooperate_{t-1}`: true if all players cooperated in t-1
- `punishment_rounds`: counter for how many rounds have been in punishment phase
- `MAX_PUNISH_ROUNDS`: max punishment length (e.g., 2 rounds)
- `punishment_triggered`: true if a defection was detected and punishment phase active

---

### Decision Rules

1. **First round (t=1):**
   - Cooperate (`C`).
   - Rationale: no history, best baseline to maintain stock and build trust.

2. **Rounds 2 through r-1:**

   - **If no defection detected in previous round (all others cooperated):**
     - Cooperate (`C`).
     - Reset punishment counter if previously punishing.
   
   - **If defection(s) detected in previous round:**
     - Enter punishment phase: defect (`D`) for next `MAX_PUNISH_ROUNDS` rounds.
     - Increment punishment counter each round.
     - After punishment rounds expire, revert to cooperation if no new defections.
   
   - **If currently in punishment phase but no new defections:**
     - Continue punishing until max rounds reached.
   
   - **Stock checks:**
     - If stock level `S_t` ≤ 2n (very low and near collapse), cooperate (`C`) regardless to try to preserve remaining resource.

3. **Last round (t = r):**
   - Defect (`D`).
   - Rationale: No future rounds, so incentive to defect for max immediate payoff.
   - But if all others cooperated last round, can consider cooperating for social preference (optional).
   - This is a standard boundary condition in finitely repeated games.

---

### Summary of Behavior by Situation

| Situation                                      | Action      | Reasoning                      |
|------------------------------------------------|-------------|-------------------------------|
| Round 1                                        | Cooperate   | No history, establish baseline |
| No defections last round & not punishing       | Cooperate   | Mutual cooperation maintained  |
| Defections last round (new defection detected) | Defect      | Punish defectors               |
| Within punishment rounds (punishment ongoing)  | Defect      | Maintain punishment pressure   |
| Punishment rounds expired, no new defection    | Cooperate   | Forgive & return to cooperation|
| Stock very low (≤ 2n)                          | Cooperate   | Preserve resource until end    |
| Round r (last round)                           | Defect      | Maximize final payoff          |

---

## Pseudocode

```python
# Parameters:
MAX_PUNISH_ROUNDS = 2   # Tunable

# State variables to be maintained internally:
punishment_triggered = False
punishment_rounds = 0

def cooperative_strategy(t, r, S_t, history):
    """
    Inputs:
    - t: current round (1-based)
    - r: total rounds
    - S_t: stock at beginning of round t
    - history: list of tuples [(actions_round_1), (actions_round_2), ...] actions of all players
               actions_round_i: list or array of actions ['C' or 'D'] by players in round i
    
    Returns:
    - action: 'C' or 'D' for this round
    """
    global punishment_triggered, punishment_rounds
    
    n = len(history[0]) if history else None 

    # First round: cooperate unconditionally
    if t == 1:
        punishment_triggered = False
        punishment_rounds = 0
        return 'C'

    # Last round: defect to maximize immediate payoff
    if t == r:
        return 'D'

    # Analyze last round actions
    last_actions = history[t-2]  # zero-indexed
    defectors_last_round = [i for i, a in enumerate(last_actions) if a == 'D']
    all_cooperate_last_round = (len(defectors_last_round) == 0)

    # If stock is very low, cooperate to preserve resource
    if S_t <= 2 * n:
        # Reset punishment to give chance for recovery
        punishment_triggered = False
        punishment_rounds = 0
        return 'C'

    # Check for new defections
    if not all_cooperate_last_round:
        # Detected defection, trigger punishment
        punishment_triggered = True
        punishment_rounds = 1
        return 'D'

    # If punishing phase ongoing
    if punishment_triggered:
        if punishment_rounds < MAX_PUNISH_ROUNDS:
            punishment_rounds += 1
            return 'D'
        else:
            # Punishment period over, forgive and revert to cooperation
            punishment_triggered = False
            punishment_rounds = 0
            return 'C'

    # Otherwise, if no defection and no punishment, cooperate
    return 'C'
```

---

## Explanation and Justification

- **First round cooperation** builds trust and sustains the pool.
- **Punishment after defection** deters free riders by lowering their future payoffs.
- **Limited punishment length** prevents endless retaliation and allows return to cooperation.
- **Cooperate when stock is low** helps avoid collapse and keeps the game viable.
- **Defect on last round** is standard in finitely repeated games with no future punishment.
- This strategy is conditional cooperation with “grim-trigger-esque” but forgiving punishment, aligned with classical "tit-for-tat" ideas but adapted to the resource-stock dynamics.

---

## Possible Extensions (if allowed)

- Adjust punishment length dynamically based on severity or number of defectors.
- Use stock observation to modulate cooperation (be more conservative if stock trending down).
- Attempt to incentivize defection in last round only if safe to do so (if not close to collapse).
- Track individual defectors and punish only them if personal histories allowed.

---

# Summary

This design explicitly defines:

- When to cooperate: first round, after observing all cooperate, low stock rounds, post-punishment
- When to defect: to punish defectors for a limited number of rounds, and in last round to maximize payoff
- How to handle edge cases: first and last rounds, low stock scenarios
- How to align with cooperation: sustain stock by avoiding overconsumption, promoting mutual cooperation, forgiving past defections after punishment

This balanced cooperative strategy should perform well in a tournament setting against a mix of strategies by encouraging mutual cooperation, enabling sustainability of the common resource and maximizing long-term payoffs consistent with the game’s incentives.
'''

description_COOPERATIVE_73 = '''
Below is a fully cooperative strategy for the described Common Pool Resource Game. It aims to sustain the resource near its maximum capacity by encouraging mutual cooperation, punishing defection in a measured way, and forgiving past defections if cooperation resumes. The goal is long-term joint benefit, aligning with the cooperative mindset.

---

## Strategy Overview

- **Cooperate (C)** initially and whenever the common pool stock is sufficiently healthy.
- **Detect defections** by monitoring others’ actions via the common knowledge at each round.
- **Punish defection(s)** temporarily to discourage overconsumption.
- **Forgive** after a punishment phase if cooperation resumes.
- **Defect only if nobody cooperates anymore to avoid being exploited infinitely.**
- Adapt slightly near the last round to maximize final turn payoffs without risking stock depletion.

---

## Intuition Behind the Strategy

- Since defection consumes more stock per player (S/n) than cooperation (S/2n), mutual cooperation keeps depletion low and allows the growth to refill the pool to capacity.
- Detecting and punishing defectors prevents freeloading.
- Because the game is repeated and players can see all past actions, defections are public knowledge enabling community-enforced cooperation.
- Forgiveness avoids permanent defection spirals, encouraging “return to cooperation.”
- Near the last round, incentives to defect rise, but cooperating enough rounds mitigates irreversible depletion.

---

## Parameters and Variables Used in Strategy

- `n`, `r`, `capacity`: game parameters, known to all
- `S_t`: common pool stock at round t (observed)
- `actions_{t-1}`: vector of all players’ actions last round (at round t>1)
- `round`: current round number (1 to r)
- `punishment_rounds`: number of rounds to punish detected defector(s) after defection observed (e.g., 2 rounds)
- `punish_timer`: local counter tracking punishment rounds left
- `defection_detected`: boolean indicating if any defection observed last round (excluding own defection)
- `threshold_stock_high`: threshold for “healthy” stock close to capacity, e.g., 90% of capacity
- `threshold_stock_low`: threshold signaling strong depletion, e.g., 50% of capacity

---

## Detailed Decision Rules

### 1. First Round (t = 1)

- **Action:** Cooperate, to set example and maintain stock.

### 2. Rounds 2 to r-1 (middle rounds)

- **If currently punishing (punish_timer > 0):**
  - Defect to punish.
  - Decrement `punish_timer`.

- **Else (not punishing now):**
  - Inspect actions from last round:

    - If any other player defected last round (`defection_detected = True`):
      - Begin punishment phase: set `punish_timer = punishment_rounds`.
      - Defect this round (punishment action).

    - Else (all cooperated last round):

      - If current stock `S_t ≥ threshold_stock_high`:
        - Cooperate (resource healthy, maintain cooperation).

      - Else if `threshold_stock_low ≤ S_t < threshold_stock_high`:
        - Cooperate (resource moderately depleted but manageable).

      - Else if `S_t < threshold_stock_low`:
        - Cooperate anyway to allow resource to recover (do not increase consumption).

### 3. Last Round (t = r)

- Since no future rounds remain, temptation to defect is highest.

- **If no defection detected last round:**
  - Cooperate (reward cooperators, maintain fair sharing).

- **If defection detected last round or currently punishing:**
  - Defect (extract maximum payoff this final round).

---

## Additional Notes

- The **punishment phase length** is a strategic parameter; too short might invite repeated defection, too long might reduce long-term gains.
- The **punishment phase targets defectors collectively**, i.e., the strategy defects when any defection is detected to signal disapproval and deter it.
- The strategy **never defects first** except when punishing or at endgame.
- The strategy relies on perfect information of all players’ last actions to detect defections accurately.
- In case of near-zero stock (e.g., after severe defection by others), cooperating helps stock to regenerate if possible.
- Since defectors consume more, one or two defectors can cause depletion; this strategy applies community enforcement to keep group cooperation stable.

---

## Pseudocode

```python
# Parameters
punishment_rounds = 2
threshold_stock_high = 0.9 * capacity
threshold_stock_low = 0.5 * capacity

# State variables (initial)
punish_timer = 0

def cooperative_strategy(round, S_t, actions_last_round, my_index):
    global punish_timer
    
    # 1. First round: cooperate
    if round == 1:
        return 'C'
    
    # 2. Identify defection by others last round (exclude self)
    defection_detected = False
    for i, a in enumerate(actions_last_round):
        if i != my_index and a == 'D':
            defection_detected = True
            break
    
    # 3. If currently punishing, continue defecting
    if punish_timer > 0:
        punish_timer -= 1
        # Except on last round, defect maximum payoff
        if round == r:
            return 'D'
        else:
            return 'D'

    # 4. If defection detected last round, start punishment
    if defection_detected:
        punish_timer = punishment_rounds - 1  # minus 1 because we punish this round already
        if round == r:
            # Final round, defect for payoff
            return 'D'
        else:
            return 'D'
    
    # 5. No defection detected and not punishing
    
    # Last round decisions
    if round == r:
        return 'C'
    
    # Middle rounds: cooperate to preserve stock
    # Optionally adjust behavior by stock levels
    
    if S_t >= threshold_stock_high:
        return 'C'  # healthy stock
    
    if S_t >= threshold_stock_low:
        return 'C'  # moderate stock
    
    # Low stock, still cooperate to recover resource
    return 'C'
```

---

## Summary

- **Start cooperating.**
- **Detect any defection → defect for fixed punishment rounds.**
- **Forgive if all cooperate again → switch back to cooperating.**
- **Near last round, defect if punishing or defection detected last round, else cooperate.**
- Always prioritize cooperation to sustain the common pool and maximize group long-term payoffs.

This design aims for stable cooperation enforced via simple trigger punishments and forgiveness, which is a widely recognized method in repeated games for maintaining cooperation over time without explicit communication.
'''

description_COOPERATIVE_74 = '''
Here is a cooperative strategy designed to promote mutual sustainability and maximize joint payoffs over the repeated dynamics of the common pool resource game. This strategy leverages conditional cooperation and forgiveness, balancing caution with opportunity throughout the rounds.

---

## Key Intuition

- **Cooperate whenever the resource is healthy and others cooperate** to maintain the stock near capacity, maximizing sustainable payoffs.
- **Punish defectors by defecting temporarily** to discourage overconsumption but quickly forgive to restore cooperation.
- **Defect in the last round**, as there is no future to sustain cooperation (standard backward logic).
- **Condition on observed history (past actions & stock level)**, not on unverifiable assumptions.
- **Avoid aggressive or permanent punishment** to support long-term cooperation.

---

## Strategy Description

### Definitions

- Let **t** ∈ {1, ..., r} denote the round.
- Let **S_t** be the common pool stock at the start of round t.
- Let **A_t = (a_{1,t}, ..., a_{n,t})** be the vector of all players' actions at round t.
- Let **defectors_in_last_round = number of players choosing D in round t-1** (if t > 1).
- Let **T_defect_punish = 1** be the length of defection punishment.
- Let **capacity** be the maximum stock.
- Let **threshold_low = capacity / 2** be a heuristic lower bound on stock for cooperation.
- Let **defect_last_round = Boolean flag whether player defected last round** (for self-tracking).
- Each player knows all actions history.

---

### Decision Rules

**Round 1 (t=1):**  
- **Cooperate (C).**  
  Start by cooperating to signal good faith and help maintain resource.

**Intermediate rounds (1 < t < r):**  
- If **any player defected in previous round (defectors_in_last_round > 0)**:  
  - **Defect (D)** this round **as retaliation for one round** (punish defectors).  
- Else (all cooperated last round):  
  - If **stock S_t < threshold_low**, indicating resource depletion:  
    - **Cooperate (C)** (excessive defecting hurts stock, keep cooperating to recover).  
  - Else:  
    - **Cooperate (C)** (stock healthy, no reason to defect).  

**Last round (t = r):**  
- **Defect (D).**  
  Since no future rounds exist to incentivize cooperation, maximize immediate payoff.

---

### Additional Notes

- **One-round retaliation** discourages defection but allows reconciliation.
- The threshold `capacity/2` helps avoid stock collapse by maintaining moderate consumption.
- The player ignores others' potential strategies but reacts solely on observed defection.
- The player tracks all past actions to detect defections.
- Forgiveness avoids spiraling mutual defection, encouraging return to cooperation.
- The strategy is symmetric and transparent under the common knowledge assumption.

---

## Pseudocode

```
initialize:
    threshold_low = capacity / 2
    T_defect_punish = 1
    defectors_in_last_round = 0

for t in 1 to r:
    if t == 1:
        action_t = 'C'  # Start cooperatively
    else if t == r:
        action_t = 'D'  # Last round defect
    else:
        if defectors_in_last_round > 0:
            action_t = 'D'  # Punish defectors
        else:
            if S_t < threshold_low:
                action_t = 'C'  # Cooperate to help stock recover
            else:
                action_t = 'C'  # Cooperative as no defection last round and stock healthy

    execute action_t

    observe actions A_t of all players

    defectors_in_last_round = count of players j in A_t with a_{j,t} == 'D'
```

---

## Summary

| Round     | Condition                                | Action          | Rationale                           |
|-----------|-----------------------------------------|-----------------|-----------------------------------|
| 1         | First round                             | Cooperate (C)   | Signal cooperation, good start    |
| 2 to r-1  | If any defected in (t-1)                | Defect (D)      | Punish defection (one round only) |
| 2 to r-1  | Else if stock < capacity/2              | Cooperate (C)   | Help stock recover                 |
| 2 to r-1  | Else                                   | Cooperate (C)   | Maintain cooperation, max payoffs |
| r (last)  | Always                                 | Defect (D)      | No future, best immediate payoff  |

---

This strategy embodies a **conditional cooperation** mindset that maximizes sustainable resource use, deters free-riding, and maximizes payoffs over time when facing unknown independent strategies. It does not rely on communication but purely on observable actions and the evolving state.

If most players follow similar logic, the group maintains high resource stock and gains good payoffs over multiple rounds. If opponents defect, the punishment discourages overconsumption and encourages return to cooperation without endless conflict.

---

If you want me to refine this strategy in any particular way or provide concrete examples, just ask!
'''

description_COOPERATIVE_75 = '''
**Cooperative Strategy Design**

---

### Intuition and Objective
The game is a repeated common pool resource (CPR) scenario with strategic tension between cooperation (C) and defection (D). Cooperating helps sustain the resource yielding long-term payoffs, while defection yields higher immediate payoffs at the risk of resource depletion.

**Goal:** Maximize the *sum of payoffs over r rounds* by maintaining the stock near capacity through mutual cooperation, while being robust to occasional defections by punishing defectors to deter free-riding.

---

### Key Observations
- **Cooperation payment per round per player:** S/(2n)
- **Defection payment per round per player:** S/n = 2 × cooperating payoff
- Growth is maximal around S ≈ capacity/2, but the stock replenishes fully if total consumption stays low.
- Defection by all players depletes stock to zero immediately, ruining future payoffs.
- Defection by a few reduces stock and future payoffs, but can be partially forgiven to encourage return to cooperation.

---

### Strategy Overview: "Conditional Cooperate with Forgiveness and Last-round Defect"

We adopt a **trigger-style, conditional cooperation strategy with forgiveness**, having three key components:

1. **Start cooperating in round 1**
2. **Cooperate each round if no defection has been detected**
3. **If defection detected, defect for a fixed punishment period to discipline defectors**
4. **After punishment, forgive and return to cooperation**
5. **In last round, defect to maximize immediate payoff (end-game defection)**

This strategy balances reciprocity, deterrence, and long-term cooperation.

---

### Definitions

- **0-based round index t ∈ {0, ..., r-1}**
- **History of actions:**
  At end of round t, observe actions of all players.
- **Defection detection:**
  A defection is detected if any player chose D in round t.
- **Punishment duration `P`:** fixed (e.g., 2 rounds)
- **Punishment state:** counts remaining rounds to punish defectors

---

### Detailed Strategy Description

**Initialize:**
- `punishing = false`  (whether currently punishing defectors)
- `punish_rounds_left = 0`  (rounds left to punish)

**For each round t (starting at 0):**

1. **Last round check:**
   - If `t == r - 1` (last round), **choose D** (defect) to maximize immediate payoff.
   - Reason: No future rounds to protect, standard backward induction.

2. **If currently punishing (punishing == true):**
   - Choose D (defect) this round.
   - Decrease `punish_rounds_left` by 1.
   - If `punish_rounds_left == 0`, set `punishing = false` (forgive and return to cooperation next round).

3. **Else (not punishing):**
   - Check if **defection detected in previous round (t-1)**:
     - If yes, **start punishment:**
       - Set `punishing = true`
       - Set `punish_rounds_left = P`
       - Choose D this round (begin punishment immediately)
     - Else:
       - Choose C (cooperate)

4. **In round 0 (first round):**
   - Cooperate unconditionally (no history yet)

---

### Pseudocode

```python
# Parameters
P = 2  # punishment length in rounds

# State variables
punishing = False
punish_rounds_left = 0

for t in range(r):
    if t == r - 1:
        # Last round: defect
        action = 'D'

    elif punishing:
        # During punishment phase: defect to discipline defectors
        action = 'D'
        punish_rounds_left -= 1
        if punish_rounds_left == 0:
            punishing = False

    else:
        if t == 0:
            # First round: cooperate
            action = 'C'
        else:
            # Check for defection in previous round's actions
            if any(player_action == 'D' for player_action in actions_at_round(t-1)):
                # Start punishment
                punishing = True
                punish_rounds_left = P
                action = 'D'
            else:
                # No defection detected, cooperate
                action = 'C'
    
    play(action)
```

---

### Rationale

- **First round cooperate:** Build trust, avoid wrecking the resource immediately.
- **Punishment after defection:** Defectors are penalized by losing mutual cooperation gains, which deters unilateral defection.
- **Punishment limited in duration:** Encourages forgiveness, prevents endless mutual defection.
- **Return to cooperation:** Long-term collective gain is always preferred.
- **Last round defection:** Since no future interaction, defecting maximizes immediate payoff.

---

### Addressing Edge Cases

- **If others always cooperate:** Steady cooperation yields maximal sustainable payoffs and stable stock.
- **If some defect initially:** Strategy punishes defectors, but after punishment forgives and tries to restore cooperation.
- **If others defect persistently:** You cycle between cooperation and punishment; you never defect unprovoked.
- **If stock is low due to prior rounds:** The strategy still aims to rebuild stock by cooperating when possible.
- **Very short games (r=2):** Punishment is possible only for one round; still, first round cooperate, last round defect.
- **Large n and capacity:** Strategy is invariant to parameter scale; depends only on observed defection.

---

### Summary

This strategy embodies a cooperative mindset by:

- Initially cooperating to sustain the resource.
- Reacting to defection with proportionate punishment.
- Forgiving to enable cooperation restoration.
- Exploiting last-round to maximize payoff sensibly.

It uses only game history, no communication or shared norm assumptions, and respects game-theoretic rationality.

---

If you want a more sophisticated variation (e.g. tuning punishment length dynamically based on defection frequency or stock level), it can be added, but the above is a robust fundamental cooperative strategy suitable for tournament play.
'''

description_COOPERATIVE_76 = '''
Here is a cooperative strategy designed to maximize long-run collective payoffs by maintaining the common pool near its sustainable capacity while discouraging defection by punishing opponents’ defections proportionally.

---

### Strategy Name: **Sustained Mutual Cooperation with Graduated Punishment**

---

### Intuition

- Cooperate **(C)** as long as no defections have been observed.
- Defect **(D)** only to punish observed defections, signaling disapproval and deterring free-riding.
- Punishments are proportional: defects trigger a period of defections lasting a number of rounds proportional to the severity of defection, then revert back to cooperation.
- Near the last round, since future punishments have no value, defect to maximize immediate payoff.
- This protects the cooperative pool from being depleted, and tries to sustain cooperation for maximal total payoffs.

---

### Detailed Description

**Parameters:**  
- `n` = number of players  
- `r` = total rounds  
- `capacity` = maximum sustainable stock level  
- `C_for_C` = consumption when cooperating = current_stock/(2n)  
- `C_for_D` = consumption when defecting = current_stock/n  

**State Variables:**  
- `history` = record of all players’ actions per past rounds  
- `punishment_rounds_left` = integer counting own punishment rounds left  
- `punishment_length_per_defection` = fixed integer parameter (e.g., 2)  
- `defections_observed_last_round` = count of how many opponents defected last round

---

### Decision Rules per Round `t`

1. **First round (`t == 1`):**  
   Cooperate unconditionally.  
   *Justification: no prior info, cooperation kick-starts the collaboration.*

2. **Rounds `1 < t < r`:**  

   - **If currently punishing (`punishment_rounds_left > 0`):**  
     - Play Defect (D) this round.  
     - Decrement `punishment_rounds_left` by 1 at end of round.

   - **Else (not punishing):**  
     - Inspect opponent actions in the previous round (`t-1`):  
       - Count how many opponents defected last round, call this `d_count`.  
     - If `d_count == 0`:  
       - Cooperate (C) this round.  
     - Else if `d_count > 0`:  
       - Begin punishment by setting  
         `punishment_rounds_left = d_count × punishment_length_per_defection`  
       - Defect (D) this round to start punishment immediately.

   *Justification: only punish when others have defected, scaling punishment length by defectors count.*

3. **Last round (`t == r`):**  
   - Defect (D) regardless.  
   *Justification: no future to punish or be punished, so defect for maximum last-round payoff.*

---

### Handling Edge Cases

- **Multiple simultaneous defectors:** Punish for multiple rounds proportional to how many defected to discourage widespread defection.  
- **Stock approaching zero:** This strategy is designed to avoid low stock by maintaining cooperation early and punishing defections.  
- **If punished wrongly:** Since punishment is only triggered by observed defections, false punishments do not occur as observations are perfect.  
- **If others always defect:** Strategy defects indefinitely after first observed defection because cooperation is unprofitable without reciprocation.  
- **If others always cooperate:** Continue to cooperate till last round for mutual maximal payoffs.

---

### Pseudocode

```python
# Parameters to set beforehand
punishment_length_per_defection = 2  # tunable parameter

def strategy(t, r, history, current_stock, n):
    """
    t: current round (1-indexed)
    r: total rounds
    history: list of dicts recording previous rounds' actions, each dict maps player_i -> action_i
    current_stock: float, stock before actions this round
    n: int, number of players (including self)
    
    Returns: action 'C' or 'D' for this round
    """
    
    # Initialize persistent variable outside this function:
    # punishment_rounds_left = 0
    
    global punishment_rounds_left
    
    # 1. First round: cooperate
    if t == 1:
        return 'C'
    
    # 3. Last round: defect regardless
    if t == r:
        return 'D'
    
    # 2. Middle rounds:
    if punishment_rounds_left > 0:
        # Currently punishing
        punishment_rounds_left -= 1
        return 'D'
    
    # Not punishing: check last round opponents' actions
    last_round_actions = history[-1]  # dict player_i -> action_i
    
    # Count how many opponents defected last round
    # Assuming self is player 1 (or any fixed index), exclude self
    self_player = 1
    defectors = [p for p, a in last_round_actions.items() if (p != self_player and a == 'D')]
    d_count = len(defectors)
    
    if d_count == 0:
        # All cooperated last round -> cooperate
        return 'C'
    else:
        # Trigger punishment proportional to defectors count
        punishment_rounds_left = d_count * punishment_length_per_defection - 1
        # Immediate punishment this round
        return 'D'
```

---

### Summary

- **Always start cooperative.**  
- **Punish defectors proportionally by defecting yourself for several rounds.**  
- **Return to cooperation after punishment if no further defections.**  
- **Defect in the last round to maximize immediate payoff.**  

This strategy upholds the cooperative mindset by prioritizing sustainable harvesting and joint long-term gains while discouraging abuse by defecting opponents through credible, proportional punishments that encourage return to cooperation.

--- 

If you want a more forgiving or harsher punishment parameter, adjust `punishment_length_per_defection`. A value like 2 balances retaliation and forgiveness well.
'''

description_COOPERATIVE_77 = '''
Here is a cooperative strategy tailored to the Common Pool Resource Game as specified, emphasizing sustainability, reciprocity, and implicit punishment for defection. The goals are to maximize long-term joint payoff by maintaining resource stock near capacity and to avoid the tragedy of the commons.

---

## Strategy Overview

**Core Principle:**  
Cooperate as long as all players have cooperated in the past (no defections detected). Defect temporarily as punishment if any defection is detected, then return to cooperation to restore trust and resource stock.

---

## Key Intuition

- **Cooperation (C)** is playing safe: each player consumes a small share (stock / 2n), preserving the stock and allowing recovery.
- **Defection (D)** extracts a larger share (stock / n), which harms long-term stock sustainability.
- **Punishment phase** deters exploitation by retaliating against defectors, reducing their payoff.
- **Forgiveness** is incorporated to avoid permanent breakdown in cooperation.

---

## Detailed Decision Rules

### At Round t (1 ≤ t ≤ r), with observed history Hₜ₋₁:

- Let `defection_detected` be a boolean flag: True if any player defected (played D) in any previous round (before t), False otherwise.
- Let `punishment_rounds` be a counter for rounds spent punishing defectors.
- Let `max_punishment` = 1 round (can be tuned).
- Let Sₜ be the resource stock available at the start of round t.

---

### Decision Logic:

#### 1. First Round (t=1)

- Cooperate (play C) unconditionally.

```pseudocode
if t == 1:
    action = C
```

---

#### 2. Subsequent Rounds (2 ≤ t < r)

- If **no defection detected** in history → cooperate.

- If **defection detected**, enter punishment phase:

  - Play Defect for `max_punishment` rounds.
  - Increment punishment_rounds each round during punishment phase.
  - After punishment phase completed, return to cooperate and reset defection_detected to False.

```pseudocode
if defection_detected == False:
    action = C
else:
    if punishment_rounds < max_punishment:
        action = D
        punishment_rounds += 1
    else:
        action = C
        defection_detected = False
        punishment_rounds = 0
```

- Detect defection by observing if any player uses D in any previous round.

---

#### 3. Last Round (t = r)

- Defect (D) — since no future punishment is possible and incentive to free-ride exists.

```pseudocode
if t == r:
    action = D
```

---

## Summary of Variables & States

- `defection_detected` (bool): tracks if any defector observed in past rounds.
- `punishment_rounds` (int): counts how long the punishment phase has lasted (max 1 round).
- `max_punishment` (int): length of punishment phase = 1 round.
- `t` current round number.
- `Sₜ` current stock level (used indirectly as it affects payoffs).

---

## Additional Considerations

- **Why punish only 1 round?**  
  Minimal effective punishment suffices because defectors lose immediate payoff from others’ retaliation. Prolonged punishment risks mutually assured destruction (stock collapse).

- **Why cooperate first round?**  
  Establish trust and maintain maximum resource stock from start.

- **Why defect last round?**  
  Standard finite-horizon free-rider effect: in last round no future punishment is possible.

- **No detection errors:**  
  Perfect observation assumed. If any defectors seen, flag is set.

- **Stock dynamics and cooperation:**  
  Cooperation preserves stock near capacity, enabling higher payoffs in subsequent rounds.

---

## Pseudocode Summary

```pseudocode
Initialize:
    defection_detected = False
    punishment_rounds = 0
    max_punishment = 1

for t in 1 to r:
    if t == 1:
        action = C

    else if t == r:
        action = D  # Last round free-ride

    else:
        if defection_detected == False:
            action = C
        else:
            if punishment_rounds < max_punishment:
                action = D
                punishment_rounds += 1
            else:
                action = C
                defection_detected = False
                punishment_rounds = 0

    Execute action

    Observe all players' actions in round t
    if any other player played D:
        defection_detected = True
```

---

## Cooperative Nature & Alignment

- **Mutual cooperation** by default sustains the resource.
- **Minimal retaliation** discourages exploitation.
- **Forgiveness** allows return to cooperation after punishment.
- **Explicit last-round defection** is necessary rationality with finite horizons.
- **No over-punishment** keeps system stable.
- **Strategy easy to recognize and reciprocate.**

---

# Final Notes

This strategy is a form of *grim-trigger-like* with limited forgiveness, adapted to resource dynamics and finite horizon constraints. It should perform well in tournaments by promoting cooperation and deterring exploitation.
'''

description_COOPERATIVE_78 = '''
Here is a cooperative strategy designed to sustain the common pool resource and maximize long-term payoffs by fostering cooperation among players, while being robust to defections. It uses a calibrated trigger and forgiveness mechanism typical in repeated common-pool-resource dilemmas.

---

## Cooperative Strategy: "Tit-for-Tat with Threshold Trigger and Forgiveness"

### Intuition
- **Goal:** Maintain the stock near capacity to maximize joint sustainable payoffs.
- **Cooperate** as long as others do (enough cooperators), thus consuming modestly.
- **Defect** only to punish detected defections, but revert quickly to cooperation after punishment.
- Use *stock level* and *observed actions* to infer others' cooperation or defection.
- Avoid premature defection or ending in a collapse of the resource.
- In the **last round**, defect to maximize immediate payoff (since no future rounds remain).

---

### Key Parameters of the Strategy
- **C (Cooperate):** consume S/(2n)
- **D (Defect):** consume S/n
- **Initial move (round 1):** Cooperate
- **Trigger condition (to punish defectors):** if the number of defectors observed in the previous round ≥ 1 **OR** if the updated stock after consumption is significantly lower than expected under cooperation → defect to punish.
- **Punishment duration:** 1 round (single retaliation round), then revert to cooperation if no further defections.
- **Forgiveness:** If punishment done and no new defections detected, cooperate again.
- **Last round:** Defect unconditionally (since no future rounds to incentivize cooperation).

---

### Detailed Decision Rules

#### Round 1
- Always **Cooperate** (no history yet).

#### Round t, 2 ≤ t < r (intermediate rounds)
1. Observe previous round actions and final stock for round t-1.
2. Count how many players defected last round (`num_defectors`).
3. Compute expected stock after consumption if all cooperated in last round:

\[
S_{expected} = \text{stock}_{t-2} - n \times \frac{\text{stock}_{t-2}}{2n} + 2 \times \left(\text{stock}_{t-2} - n \times \frac{\text{stock}_{t-2}}{2n}\right) \times \left(1 - \frac{\text{stock}_{t-2} - n \times \frac{\text{stock}_{t-2}}{2n}}{\text{capacity}}\right)
\]

(If t=2, \(\text{stock}_{t-2}=\) initial stock.)

4. Check if current stock \(\text{stock}_{t-1}\) is *much below* \(S_{expected}\), where "much below" means by more than a small tolerance (say 5% of capacity).

5. If either:
   - `num_defectors ≥ 1` in last round, **or**
   - \(\text{stock}_{t-1} < 0.95 \times S_{expected}\)

   then:
   - Defect this round to punish.

6. Else:
   - Cooperate.

7. If you defected in previous round as punishment:
   - If no defection observed in last round, revert to cooperation (forgiveness).

#### Round r (last round)
- Defect unconditionally (one-shot gain maximization).

---

### Rationale

- **Start cooperative:** fosters trust and preserves stock initially.
- **Detect defection via observed actions and stock fall:** because defection consumes twice as much, stock falls faster if defectors exist.
- **Punish quickly (1 round) if defectors detected:** sends a signal that defection is costly.
- **Forgive if cooperation resumes:** allows return to mutual cooperation.
- **Last round defect (backward induction):** no incentive to sustain cooperation.

---

### Pseudocode

```pseudo
INPUTS: n, r, capacity, game history up to round t-1:
  - stock_history[0..t-1], actions_history[1..t-1][1..n]

FUNCTION decide_action(t, stock_history, actions_history):
  IF t == 1:
    RETURN 'C'

  IF t == r:
    RETURN 'D'  # Defect last round

  prev_stock = stock_history[t-2]
  cur_stock = stock_history[t-1]

  # Count defectors last round
  num_defectors = count of players j in actions_history[t-1] with action == 'D'

  # Compute expected stock after full cooperation at previous round
  consumption_coop = prev_stock / (2*n)
  total_consumption_coop = n * consumption_coop
  stock_after_consume = prev_stock - total_consumption_coop
  growth = 2 * stock_after_consume * (1 - stock_after_consume / capacity)
  expected_stock = min(stock_after_consume + growth, capacity)

  # Check for defection signal
  stock_drop_threshold = 0.95 * expected_stock

  # Check if I defected last round as punishment
  I_last_round_action = actions_history[t-1][me]

  # Punishment logic
  IF (num_defectors >= 1 OR cur_stock < stock_drop_threshold):
    # Punish by defecting
    RETURN 'D'
  ELSE:
    # If I punished last round, forgive now
    IF I_last_round_action == 'D':
      # Forgive and cooperate
      RETURN 'C'
    ELSE:
      # Continue cooperating
      RETURN 'C'
```

---

### Summary

| Round           | Action                           | Reason                                                    |
|-----------------|---------------------------------|-----------------------------------------------------------|
| Round 1         | Cooperate                      | Establish good cooperation                                |
| Intermediate    | Cooperate if no defection seen and stock healthy; else defect to punish | Enforce cooperation; protect resource sustainably       |
| After punishment| Forgive and cooperate if others cooperate | Allow return to cooperation                               |
| Last round      | Defect unconditionally         | Maximize final payoff as no future consequences            |

---

This strategy balances incentive compatibility (discourages defection), cooperation, and pragmatic self-interest, aligned with the cooperative mindset but robust against exploitation. It maintains the resource stock well, maximizing long-term payoffs, while punishing defectors to enforce socially optimal behavior in an environment of repeated interaction but no communication or enforced agreements.
'''

description_COOPERATIVE_79 = '''
Here is a detailed cooperative strategy for the described Common Pool Resource game. The strategy aims to sustain the common pool stock while maximizing cumulative payoffs through cooperation, and punishes defections just enough to discourage over-extraction, with forgiveness to restore cooperation whenever possible.

---

### Strategy Overview

**Goal:** Maintain the common pool stock near full capacity by cooperating (playing C) to ensure sustainable payoffs for all players.

**Key Insight:**  
- Cooperation consumes less (stock/(2n)), supporting stock regeneration.  
- Defection depletes stock faster, risking collapse and zero payoffs later.  
- Since the game is repeated, sustaining cooperation benefits everyone.

---

### 1. Decision Rules

- **Initial Round (t=1):** Cooperate (play C). Start with trust and build cooperation from the beginning.

- **Subsequent Rounds (t > 1):**  
  a) Always Cooperate if *all* other players cooperated in previous round.  
  b) If *any* player defected in the previous round, punish by defecting for one round (Tit-for-Tat style), then forgive and return to cooperation.

- **Endgame (Last Round t = r):** Defect (play D) to maximize immediate payoff, since there's no future retaliation or cooperation to sustain.

---

### 2. Handling the Edge Cases

- **First Round:** No past history—play C to signal willingness to sustain the resource.

- **Last Round:** Defect unconditionally—no future rounds, so no incentive to cooperate.  
  This maximizes that round's payoff.

- **After Punishment Round:** Forgive immediately — return to cooperate regardless of previous defection history except for last round.  
  This avoids endless cycles of punishment and rebuilds trust.

- **If stock level drops dangerously low (say below a threshold):** To be robust, if the stock falls below a critical threshold (e.g., less than half capacity), cooperate indefinitely thereafter (except last round), to allow stock recovery.

---

### 3. Cooperative Mindset Alignment

- **Trust + Reciprocity:** Start cooperative, mirror cooperation when others cooperate.  
- **Punishment + Forgiveness:** Punish defection immediately but forgive fast to encourage resuming cooperation.  
- **Sustainability Focus:** Maintain resource level to maximize total gains over all rounds.  
- **Last Round Rationality:** Defect last round recognizing the one-shot nature to not be exploited.

---

### Pseudocode

```python
def cooperative_strategy(t, r, n, capacity, S_t, history):
    # Parameters:
    # t: current round (1-based)
    # r: total rounds
    # n: number of players
    # capacity: max stock
    # S_t: current stock at start of round t
    # history: list of length t-1 with previous rounds actions for all players,
    #          format: history[round_index][player_index] in {'C','D'}
    #          For example, history[0] is actions in round 1, indexed by players 0..n-1

    # Our index is not known, so strategy is symmetric: decision depends on other players' actions only.

    if t == 1:
        # First round: cooperate to signal trust
        return 'C'

    if t == r:
        # Last round: defect to maximize immediate payoff
        return 'D'

    # From round 2 to r-1:
    prev_round_actions = history[t-2]  # actions from previous round
    # Assuming this player's own action unknown here, strategy symmetric for all players

    # Check if any defection by others in previous round
    # Since players know all actions and perfect info, identify if any player defected
    if 'D' in prev_round_actions:
        # Punishment: defect this round once, then forgive next round
        # How to know if we just punished last round or not?
        # We can count consecutive punishment rounds from history:
        # But since history does not track own defection, assume symmetric:
        # Strategy: after defecting once as punishment, forgive next round

        # Count how many times last round was punished:
        # Simplify: if last round we defected as punishment, forgive now.
        # But we do not track own action here! So keep a simple reactive approach:

        # Use a memory of last own action:
        # Since no own action tracking in given function, assume external handling.
        # To resolve, implement as "Grim trigger" with forgiveness step:

        # We'll maintain a state variable "punished_last_round"
        # Pseudocode outside function: 
        # If previous round had defection, defect this round once; next round cooperate.

        # Here, approximate by:
        # Defect only if previous round had defection AND previous round we cooperated
        # Else cooperate.

        # To implement stateless in this framework:
        # If any defection previous round -> defect
        # If previous round any defection AND this round any defection previous round? complex.

        # Since we can't remember state inside function, simpler rule:
        # Defect immediately after defection by others, else cooperate
        return 'D'

    else:
        # No defection in previous round -> cooperate
        # Also check stock level, if dangerously low, cooperate anyway to support recovery
        if S_t < capacity / 2:
            return 'C'

        return 'C'
```

**Note:** Without explicit memory we implement a simple *Tit-for-Tat*: defect immediately after observing defection, else cooperate. Forgiveness is implicit next round because if others cooperate again, no defection to punish.

---

### Explanation of Behavior

- **Start Cooperating:** Signals intent, builds mutual cooperation.

- **Tit-for-Tat Punishment:** Defect only once after observing defection, discouraging free-riding.

- **Forgiveness:** Since defection ceases if others return to C, the strategy resumes cooperation.

- **Endgame Defection:** Exploits last round with no repercussions, consistent with backward induction.

- **Focus on Sustainability:** Cooperate when stock is low to encourage recovery.

---

### Optional Enhancements

- Implement a small tolerance buffer before defecting (e.g., tolerate a single defection before punishing) for more forgiveness.

- Adapt defection severity proportional to number of defectors in previous round (multi-player case).

- Use stock level to fine-tune cooperation intensity, but given limited action set {C,D}, best to keep simple.

---

### Summary

- **Round 1:** Cooperate  
- **Rounds 2 to r-1:** If any defection detected previous round, defect; otherwise cooperate  
- **Last round:** Defect  
- **Also, if stock < capacity/2, cooperate to help recovery**  

This strategy balances cooperation, punishment, and forgiveness to sustain the resource and maximize collective payoff over repeated rounds without communication or coordination devices.

---

If you want, I can help write this into more formal pseudocode or explain the reasoning behind any part in more detail.
'''

description_COOPERATIVE_80 = '''
Here is a **cooperative strategy** designed specifically for the described Common Pool Resource Game, which aims to sustain the resource while maximizing collective payoffs through mutual cooperation intensified by clear punishment for defectors.

---

## Strategy Name: **Reciprocal Cooperation with Graduated Punishment**

---

### 1. Decision Rules

- **Initial Phase (Round 1):**  
  - Cooperate (play C). Start by trusting all players and consume conservatively.

- **Ongoing Phase (Rounds 2 to r-1):**  
  - If **all players cooperated in the previous round**, cooperate this round as well.  
  - If **any player defected in the previous round**, defect this round as punishment.  
    - This is a *grim trigger* style punishment that is temporary: it lasts only one round.  
  - After the punishment round, return to cooperation **provided** that all players cooperated in the punishment round.

- **Last Round (Round r):**  
  - Defect (play D), regardless of history, to maximize last-round payoff. Defection cannot be punished afterward since no future rounds exist.

### 2. Edge Case Handling

- **First Round:** No history exists, so cooperation establishes trust and frugality.

- **Punishment Duration:** Punishment lasts exactly one round following any detected defection, allowing forgiveness and a return to cooperation if all players comply.

- **Last Round:** Defection is dominant because no future retaliation is possible; cooperate here only if a player highly values collective payoffs over final round gains.

- **Stock Collapse Avoidance:**  
  Our base strategy protects the stock by avoiding overharvesting. Cooperation means each player consumes stock/(2n), so total extraction is stock/2 each round. This, coupled with the growth dynamics, tends to maintain stock near capacity.

### 3. Rationale & Cooperative Mindset Alignment

- **Promote sustainability:**  
  By cooperating (consuming stock/(2n)), the strategy consumes conservatively, allowing the resource to regenerate.

- **Discourage defection:**  
  Defecting yields a higher immediate payoff but damages the resource stock and gains will diminish in future rounds. Punishment by defection in the next round internally disciplines defectors.

- **Forgiveness and return to cooperation** allows dynamics to recover from mistakes or misunderstandings.

---

## Pseudocode

```python
def cooperative_strategy(round_number, total_rounds, history):
    # history: list of n-length action tuples from previous rounds, e.g.,
    # [(C, C, D, C), (C, C, C, C), ...]
    # "C" and "D" denote respective player actions in previous rounds

    if round_number == 1:
        # First round: cooperate
        return 'C'

    if round_number == total_rounds:
        # Last round: defect unconditionally to maximize final payoff
        return 'D'

    prev_actions = history[-1]  # actions of all players in previous round

    # Check if any player defected last round
    if 'D' in prev_actions:
        # Punish by defecting exactly one round
        return 'D'
    else:
        # All cooperated last round, so cooperate
        return 'C'
```

---

## Summary

- Begin by cooperating.
- Cooperate as long as everyone cooperates.
- If you observe any defection, punish by defecting once.
- After punishment, return to cooperation if cooperation resumes.
- Defect only in the last round to capture maximum last-round payoff.

This strategy balances **collective resource sustainability**, **punishment to deter free-riding**, and **forgiveness to maintain cooperation over repeated rounds**, embodying a robust cooperative mindset in a repeated common pool resource environment without communication or coordination devices.
'''

description_COOPERATIVE_81 = '''
Below is a **cooperative strategy** designed for this common pool resource (CPR) game, structured to promote mutual cooperation, sustain the resource stock, and maximize long-term joint payoffs. It employs conditional cooperation and proportional retaliation to deter defection, while recognizing the finite horizon.

---

## Cooperative Strategy: "Sustained Reciprocity with Endgame Cooperation"

### Intuition and Goals
- **Promote mutual cooperation (all C)** to sustain the resource near capacity, maximizing long-term payoffs.
- **Retaliate proportionally** to defections observed, discouraging over-exploitation.
- **Forgive defections** gradually to restore cooperation if others revert.
- **Coordinate on cooperation in the final round(s)** to avoid wasteful defection and maximize last-round payoffs.
- Use **perfect information about past actions** to update beliefs and adapt.

---

### Key Assumptions
- Observes the *actions* of all other players in previous rounds.
- Knows the **number of defectors** each round.
- Cannot communicate but all understand the game structure and consequences.

---

### Definitions and Notation
- `t`: current round (1 to r)
- `n`: number of players
- `history`: list of previous rounds' actions for all players
- `defectors_last_round`: count of players who defected at round t-1 (excluding self)
- `defectors_current_round`: predicted or reacted count at round t (for this strategy mainly from history)
- `S_t`: stock level at start of round t (common knowledge)
- `cooperate_fraction(t)`: fraction of cooperative actions in previous rounds
- `punishment_length`: number of rounds to punish after a defection detected (e.g., a function of number of defectors)
- `punishment_timer`: rounds left for punishment phase
- `max_punishment`: parameter to limit harshness of punishment

---

### Strategy Description

#### 1. First Round (t = 1)
- **Play C (Cooperate).**
- Rationale: Establish cooperative baseline; resource at full capacity; no prior deviations.

#### 2. Intermediate Rounds (1 < t < r)
- **If no defections by others in previous round (defectors_last_round = 0):**
  - Continue cooperating (play C).
- **If defections detected in previous round:**
  - Enter a **punishment phase** proportional to the severity of defection.
  - Punish by defecting (play D) for `min(defectors_last_round, max_punishment)` rounds.
    - This increases total consumption, signaling retaliation and discouraging over-exploitation.
  - After punishment rounds expire, revert to cooperation.

- **Recovery mechanism:**
  - If after punishment round(s), the other players have returned to cooperating (defectors_last_round = 0), reset punishment timer and cooperate again.
  - If defection persists, extend punishment accordingly.

#### 3. Last Round(s) (t = r or possibly last 1-2 rounds)
- **Always cooperate (play C).**
- Rationale: No future rounds to punish/ reward, so best joint payoff occurs if all cooperate and sustain resource at end.

---

### Pseudocode Sketch

```python
# Parameters
max_punishment = 2  # max rounds to punish after detection
punishment_timer = 0  # counts down punishment rounds

for t in 1 to r:
    if t == 1:
        action = 'C'  # start cooperatively
        punishment_timer = 0
        
    elif t >= r:  # last round or last two rounds (can adjust threshold)
        action = 'C'  # normalize cooperation to maximize last round payoff
        punishment_timer = 0
        
    else:
        # Count number of defectors excluding self in previous round
        defectors_last_round = count_defectors(history[t-1], exclude_self=True)
        
        if punishment_timer > 0:
            # Still punishing
            action = 'D'
            punishment_timer -= 1
        else:
            if defectors_last_round == 0:
                # No defection last round - cooperate
                action = 'C'
            else:
                # Defection detected - start proportional punishment
                punishment_timer = min(defectors_last_round, max_punishment) - 1
                action = 'D'
            
    # Execute action
    play(action)
```

---

### Summary of Decision Rules

| Condition                              | Action        | Notes                         |
|--------------------------------------|---------------|-------------------------------|
| First round (t=1)                    | Cooperate (C) | Establish cooperative baseline |
| No defections last round              | Cooperate (C) | Maintain mutual cooperation    |
| Defection(s) last round detected      | Defect (D)    | Punish proportionally for up to `max_punishment` rounds |
| During punishment phase               | Defect (D)    | Maintain retaliation           |
| Last round(s) (t = r, or last 2 rounds) | Cooperate (C) | Maximize last-round joint payoff |

---

### Strategy Properties and Rationale

- **Cooperative baseline:** Starting fully cooperative sends clear intent to cooperate, stabilizing stock near capacity.
- **Proportional punishment:** Defecting players face retaliation proportional to how many defected, discouraging exploitation.
- **Limited punishment length:** Avoid infinite punishment cycles which reduce overall payoffs.
- **Forgiveness:** If opponents revert to cooperation, this strategy quickly forgives by returning to cooperation.
- **Final round cooperation:** Prevents wasteful defections when future punishment isn't possible.
- **No assumptions on opponents' sophistication:** Strategy reacts only to observed defections, relies on conditional cooperation.
- **Preserves resource stock:** By mostly cooperating and only defecting to punish, stock remains healthier than always defecting.

---

### Adaptations & Optional Enhancements (if allowed)

- Use a **memory window** of last k rounds to smooth noisy observations of defectors.
- Adjust `max_punishment` dynamically if defectors persist.
- In a small population, could increase punishment severity.
- If stock falls below a threshold despite cooperation, possibly increase cooperation likelihood or defect strategically to avoid collapse.

---

This balanced, reciprocity-based cooperative strategy should perform well against a variety of strategies in independent tournaments, fostering stable cooperation while protecting against exploitation.
'''

description_COOPERATIVE_82 = '''
Below is a cooperative strategy designed to achieve and sustain mutual cooperation in this Common Pool Resource (CPR) game setting. It aims to preserve the common stock by encouraging cooperation—consuming the smaller share C—and punishes defection with a temporary switch to defecting that discourages free-riding. The strategy is resilient to exploitation attempts while remaining forgiving to return to cooperation after punishment.

---

## Cooperative Strategy: "Conditional Cooperation with Punishment and Forgiveness"

### Intuition

- **Goal:** Maintain the resource stock close to capacity to maximize total payoffs over all rounds through sustained cooperation.
- Each round, cooperate by consuming **stock/(2n)**, keeping depletion moderate and the stock sustainable.
- If any player defects, immediately punish by defecting in the next round (consuming **stock/n**) to deter exploitation.
- After one round of punishment, return to cooperation to re-establish mutual cooperation and allow stock recovery.
- In the last round, defect to extract maximum payoff since there's no future to sustain.

---

### State and Memory

- Track the **actions of all players** in the previous round.
- Track **current round number t**.
- Track **current stock S** (publicly known after each round).
- Maintain a simple state:
  - `punishing = True/False` indicating if you are currently punishing defectors.

---

### Decision Rules

1. **Round 1 (t = 1):**
   - Cooperate (play C) to initiate cooperation and build trust.

2. **Rounds 2 to r-1:**
   - If `punishing` is True:
     - Defect (play D) to punish defectors detected last round.
     - Reset `punishing` to False for next round (one-round punishment).
   - Else (`punishing` is False):
     - Check the previous round's observed actions of other players.
     - If **any player defected** last round (i.e., any played D):
       - Set `punishing = True` and **defect this round** to punish.
     - Else:
       - Cooperate (play C) to maintain cooperation.

3. **Round r (last round):**
   - Defect (play D) to maximize personal payoff since no future consequences.

---

### Edge Cases

- If the stock `S` becomes critically low (e.g., near zero) due to others' repeated defection and resource collapse, the strategy continues to punish by defecting (for one round) until cooperation resumes.
- If stock recovers, revert to cooperation as above.
- No infinite punishment: punishment lasts exactly one round to avoid deadlock.
- Forgiving to allow return to cooperation after defectors "learn" cooperation payoff benefits.

---

### Pseudocode

```python
# Input: round t (1 to r), stock S, actions_last_round (list of all players' actions at t-1)
# State: punishing (initially False)

def strategy(t, r, S, actions_last_round):
    global punishing
    
    if t == 1:
        # Start cooperatively
        punishing = False
        return 'C'
        
    elif t == r:
        # Last round: defect to maximize payoff
        punishing = False
        return 'D'
        
    else:
        if punishing:
            # One round punishment
            punishing = False
            return 'D'
        else:
            # Check if anyone defected last round
            if 'D' in actions_last_round:
                punishing = True
                return 'D'  # Begin punishment
            else:
                # Everyone cooperated last round
                return 'C'
```

---

### Rationale

- **Why punish only one round?**  
  To avoid prolonged mutual defection and loss of stock and payoffs. A short punishment disables exploitation incentives but keeps cooperation feasible.

- **Why defect last round?**  
  The last round payoff has no future consequence, so rational players maximize immediate gain.

- **Why cooperate initially?**  
  Initiates cooperation, signals willingness to maintain resource stock.

- **Why punish upon detecting any defection?**  
  Defection depletes stock faster, harming everyone indirectly. Punishment imposes immediate cost on defectors to incentivize cooperation.

- **Why forgive?**  
  To allow re-establishment of cooperation after costly defections/punishments.

---

### Behavioral Summary

| Round       | Condition                                      | Action            |
|-------------|------------------------------------------------|-------------------|
| 1           | Start of game                                   | Cooperate (C)     |
| Intermediate| If currently punishing                          | Defect (D)        |
| Intermediate| Else if any player defected last round         | Begin punishment: defect (D) |
| Intermediate| Else                                          | Cooperate (C)     |
| Last (r)    | Last round                                      | Defect (D)        |

---

This strategy upholds a cooperative mindset by:

- Preserving the stock through mutual cooperation,
- Discouraging defection by credible punishment,
- Allowing recovery and forgiveness to sustain the cooperation equilibrium,
- Utilizing full information to respond conditionally and swiftly.

It balances stability, resilience, and incentive alignment suitable for competition against independent, possibly selfish strategies.
'''

description_COOPERATIVE_83 = '''
Here is a fully cooperative strategy designed for the repeated common-pool resource game described. It aims to sustain the resource at or near capacity to maximize long-term payoffs for everyone while being robust to defections by others.

---

### Strategy Purpose

- **Maximize long-term group payoff** via sustained cooperation.
- **Prevent resource collapse** by avoiding over-consumption.
- **Punish defectors**, but return to cooperation if defection stops.
- **Smoothly handle first/last rounds with rational considerations.**

---

### Key Intuition

- When everyone cooperates, total consumption = n × (stock/(2n)) = stock/2, leaving half the stock to grow back, maintaining a high stock level.
- Defecting gives higher short-term payoff individually but risks depleting stock faster, harming all in the long term.
- Punishing defectors by defecting in the next round deters over-harvesting.
- Returning to cooperation if others return stabilizes the group.

---

### Notation

- **t**: current round (1 ≤ t ≤ r)
- **S_t**: stock at start of round t (known to all)
- **a_i,t**: action of player i in round t (C or D)
- **Actions_t**: vector of actions for all players in round t
- **n_defect_t-1**: number of defectors in round t-1 (from history)
- **threshold_round**: round near the end to switch to defect to maximize last-round payoff (optional, see below)

---

### Decision Rules

```pseudocode
Initialize:
    cooperate = True  # start cooperative
    defect_grace_period = 0  # rounds left to punish defectors

For each round t:

    if t == 1:
        # First round: Always cooperate to signal willingness
        action = C
        cooperate = True
        defect_grace_period = 0

    else:
        # Observe others' actions from round t-1
        n_defect_t_1 = count_defectors(Actions_(t-1))

        if defect_grace_period > 0:
            # We are punishing defectors by defecting
            action = D
            defect_grace_period -= 1

        else if n_defect_t_1 > 0:
            # Detected defection last round, punish defectors this round
            action = D
            defect_grace_period = 1  # temper punishment to 1 round (can be tuned)

        else:
            # Everyone cooperated last round
            action = C
            cooperate = True

    # Optional last round reasoning for maximizing individual payoff
    if t == r:
        # Defect last round for maximum individual payoff:
        # Reason: no future rounds, no punishment possible.
        action = D
```

---

### Explanation

1. **Round 1**: Start by cooperating to establish mutual trust and maximize resource stock.

2. **Rounds 2 to r-1**:
   - If no one defected in previous round, cooperate.
   - If any player defected last round, punish by defecting for exactly 1 round, then return to cooperation.
   - This "tit-for-tat with forgiveness" punishes defectors but allows cooperation to resume quickly, avoiding persistent retaliation wars.

3. **Last round (round r)**:
   - Defect to maximize your individual payoff since there's no future punishment.
   - Everyone should anticipate this; thus mutual defection last round is expected.
   
**Note:**  
The last round defect is standard in repeated games with known end, recognizing backward induction reasoning. However, cooperation before the last round preserves the resource and improves total payoffs.

---

### Edge Cases & Robustness

- **If stock is low** (e.g., near 0): Cooperate anyway to allow resource regrowth, or defect if last round (to maximize payoff before reset).
- **If capacity is very large**: The above logic still applies; cooperating halves consumption, sustaining stock.
- **If a player defects multiple rounds**: The strategy punishes each defection with defect in next round; no escalating punishment but steady deterrence.
- **If all defect**: Stock collapses and payoffs fall; this strategy tries to avoid this via cooperation and mild punishment.

---

### Summary

| Condition | Action                    | Comment                              |
|-----------|---------------------------|------------------------------------|
| Round 1   | Cooperate (C)             | Signal cooperation                  |
| Previous round had no defectors | Cooperate (C)         | Maintain cooperation               |
| Previous round had ≥1 defectors | Defect (D), punish 1 round | Discourage defection               |
| Last round (t = r) | Defect (D)             | Maximize payoff; no future rounds |

---

### Additional Tips for Implementation

- Keep track of all players’ past actions to detect defectors.
- Implement a state variable `defect_grace_period` to avoid chained punishments.
- Use a clear convention for actions (`C` or `D`) in code and history.
- If desired, the forgiveness period can be tuned (e.g., punish for 2 rounds), but 1 round is simplest and effective.

---

This strategy embodies a **"Tit-for-Tat with Forgiveness"** for sustaining cooperation and a **rational final defection** in the last round, maximizing collective and individual payoffs aligned with a cooperative mindset.
'''

description_COOPERATIVE_84 = '''
**Cooperative Strategy Design for the Common Pool Resource Game**

---

### Strategy Summary

This strategy aims to maintain and maximize the common pool's stock over time by fostering mutual cooperation, minimizing stock depletion, and punishing defection while allowing forgiveness to restore cooperation.

---

### Key Intuition

- **Cooperate (C)** to conserve the common resource, consuming less per round.
- **Defect (D)** only as a calibrated punishment to defectors — to discourage overexploitation.
- **Detect** defections based on empirical stock dynamics and payoffs observed.
- **Punish** defectors by defecting in the next round to impose cost.
- **Forgive** after punishment round(s) by returning to cooperation unless defection continues.
- **Adjust behavior in the last round** as cooperation incentives vanish (endgame effect).

---

### Details

**Notation**

- Let  
  - `t` = current round (1 ≤ t ≤ r)  
  - `S_t` = stock at start of round t  
  - `a_i,t` ∈ {C, D} = this player's action at round t  
  - `obs_actions_{t-1}` = vector of all players' actions in round t-1  
  - `π_i,t` = payoff of player i in round t  

---

### 1. Decision Rules

#### Round 1 (t = 1)

- **Action:** Cooperate (C)  
- Reasoning: Start with maximal cooperative behavior to set an initial baseline.

#### Round t > 1

1. **Detect defection in previous round:**

   - Using observed `obs_actions_{t-1}`, identify if any player defected in previous round — i.e., played D.
   - Alternatively, since actions are public, track a “defectors” set: players who defected last round.

2. **If no defection detected last round:**

   - **Play C (Cooperate).**

3. **If defection detected last round:**

   - **Punishment Phase: Defect against defectors:**
     - Defect against players who defected last round; cooperate with others.
   
   **However, since the game is simultaneous and players cannot pick different actions against individuals, this must be simplified:**

   - If any defection detected in last round, play **D** (Defect) in this round as punishment.
   
   (Since no selective punishing possible, defect all players to signal punishment.)

4. **Forgiveness:**

   - After one round of punishing (defecting due to defection), **return to cooperate (C)** in the next round **if no new defection**, restarting cooperation phase.

5. **Edge case for last round (t = r):**

   - Cooperation incentives disappear in final round since no future punishment possible.
   - Rational players tend to defect in last round.
   - **Play D in last round** to maximize immediate payoff.

---

### 2. Summary of Decision Logic

| Round Condition                    | Action            | Comments                       |
|----------------------------------|------------------|-------------------------------|
| t = 1                            | C                | Start cooperatively            |
| t = r (last round)               | D                | No future punishment; defect  |
| Defection detected at t-1        | D                | Punish in current round        |
| No defection at t-1 & t < r      | C                | Maintain cooperation           |
| Defection just punished at t-1 & no new defection| C         | Forgive and return to cooperation |

---

### 3. Pseudocode

```python
# Initialize
punishing = False  # tracks if we are currently punishing defectors

for t in range(1, r+1):
    if t == 1:
        # Round 1: cooperate
        action = 'C'
        punishing = False

    elif t == r:
        # Last round: defect
        action = 'D'

    else:
        last_round_actions = observe_actions(t-1)  # actions of all players in previous round
        defected_last_round = any(a == 'D' for a in last_round_actions)

        if punishing:
            # If we were punishing last round and no new defection, forgive now
            if not defected_last_round:
                action = 'C'
                punishing = False
            else:
                # Continue punishing if defection persists
                action = 'D'
        else:
            if defected_last_round:
                # Enter punishment phase
                action = 'D'
                punishing = True
            else:
                # No defection, cooperate
                action = 'C'
```

---

### 4. Cooperative Mindset Explained

- The strategy **starts with cooperation** and will **sustain cooperation indefinitely** if all players cooperate.
- If any player defects, it triggers **mutual punishment** (everyone defects for one round).
- After punishment, the strategy **forgives** by returning to cooperation, giving defectors a chance to return to cooperative behavior.
- This is a **grim-trigger-lite** strategy with one-round punishments and forgiveness, aiming to stabilize cooperation without endless retribution.
- The **last round defection** is justified since no future rounds remain to enforce cooperation.
- This encourages others to cooperate from the start to avoid triggering punishment cycles, supporting sustainable resource management.

---

### 5. Shortcomings / Limitations

- Punishment is collective and not targeted, since actions are simultaneous and undifferentiated.
- Possibility of sporadic mistakes or misunderstanding may cause punishment cycles but forgiveness helps to reset cooperation.
- If many defectors exist, the resource may still collapse, but the strategy tries to mitigate that through incentives.

---

**In sum, this strategy plays “Cooperate unless defected against last round, then Defect for one round as punishment, then forgive and cooperate again,” and always defects in the last round. It promotes sustained cooperation, minimal necessary punishment, and forgiveness to keep the common pool sustainable.**
'''

description_COOPERATIVE_85 = '''
Below is a cooperative strategy designed to sustain the common pool resource and maximize joint payoffs through mutual cooperation, while deterring defection. It is tailored to the information and constraints provided.

---

## Intuition Behind the Strategy

- **Cooperation (C)** means moderate consumption: stock/(2n) per player.
- **Defection (D)** means aggressive consumption: stock/n per player.
- Cooperating preserves the pool, enabling sustained high payoffs over time.
- Defecting maximizes immediate payoff but depletes the stock, harming all in the long term.
- Since the game repeats, players can incentivize cooperation by punishing defection.
- Without communication or coordination, the best enforcement is to detect defections and respond collectively with punishment.
- Toward the last round, the future incentive disappears, so the strategy transitions accordingly.

---

## Main Idea of the Strategy

- **Round 1:** Cooperate unconditionally (establish baseline).
- **Rounds 2 to r-1:** Cooperate if *all* players cooperated in previous round; otherwise, defect as punishment.
- **Last round (round r):** Defect unconditionally (no future round to punish or reward).
  
The threat of mutual defection punishment after a detected defection sustains cooperation during the game.

---

## Handling Edge Cases

- **Initial Round:** No history, so start cooperative to build trust.
- **Last Round:** Defect, since no incentive to maintain cooperation (endgame effect).
- **If stock drops to very low levels (e.g., 0):** Defecting from low stock gains no payoff, so the strategy stays consistent with the punishment phase.
- **Multiple defections or single defection:** Treat every defection detected as sufficient to switch to punishment mode for one round.
- **If after punishment round, all players cooperated:** revert back to cooperation.
  
This ensures forgiveness and promotes return to cooperation when others do.

---

## Pseudocode for Player i's Strategy

```python
def cooperative_strategy(round_t, history, stock, n, r, capacity):
    """
    round_t: current round number (1-based)
    history: list of all previous rounds' action profiles, each a list of length n of 'C'/'D'
    stock: current stock level
    n: number of players
    r: total rounds
    capacity: maximum sustainable stock
    
    Returns: 'C' or 'D'
    """
    
    # 1. Last round: defect unconditionally (no future incentive)
    if round_t == r:
        return 'D'
    
    # 2. First round: cooperate unconditionally (no history)
    if round_t == 1:
        return 'C'
    
    # 3. From round 2 to r-1:
    # Check if all players cooperated in previous round
    previous_actions = history[-1]  # list of n actions from last round
    
    if all(action == 'C' for action in previous_actions):
        # If all cooperated last round, cooperate now
        return 'C'
    else:
        # Else defect now as punishment
        return 'D'
```

---

## Explanation and Rationale

- **Gradual Reciprocal Cooperation:** The strategy rewards cooperation by cooperating if everyone cooperated last round.
- **Simple Punishment:** If any player defects, all defect next round to punish defectors.
- **Forgiveness:** If the punishment round yields cooperation by all, it resets back to cooperation.
- **Endgame Defection:** No incentive to cooperate in last round, so defect to maximize final payoff.
- **Observed History Only:** Since actions of all players are perfectly observed, this detection is immediate.
- **No reliance on communication or pre-play agreements.**

---

## Expected Outcomes

- If all (or a majority) play this strategy, cooperation can be sustained indefinitely until last round.
- Defection is deterred by sure punishment next round, which lowers payoffs.
- The pool remains near capacity through repeated moderate consumption.
- Players maximize total discounted payoff over the game.
- The last round defect is a known equilibrium result in finitely repeated games and should be anticipated.

---

## Summary

| Condition              | Action    |
|------------------------|-----------|
| Round 1                | Cooperate |
| Round t (2 ≤ t < r)    | Cooperate if all cooperated last round; else Defect (punish) |
| Round r (last round)   | Defect    |

This strategy maximizes joint long-term payoffs through stable cooperation backed by a credible punishment threat, aligning clearly with a cooperative mindset given the game's structure and constraints.

---

If you want, I can also suggest enhancements or variants adapted to noisy or partial observation but under provided assumptions, this is a clean, straightforward cooperative strategy.
'''

description_COOPERATIVE_86 = '''
Below is a cooperative strategy designed for the Common Pool Resource Game, explicitly balancing maximization of joint payoffs with deterrence of defection, and adapting across the rounds considering the stock dynamics.

---

## Strategy Overview: "Conditional Cooperation with Forgiveness"

- **Goal:** Sustain the common stock near capacity by mostly cooperating.
- **Cooperation action:** Consume stock / (2n) per round.
- **Defection action:** Consume stock / n per round.
- **Basic principle:** Cooperate if others have cooperated recently and the stock is not critically low; punish defectors temporarily by defecting to avoid being exploited.
- **Forgiveness:** Return to cooperation if conditions improve, to restore stock and joint payoffs.
- **Endgame:** In the last round, maximize personal payoff by defecting (no future punishment possible).

---

## Decision Rules

Let:
- `t` = current round index (1 ≤ t ≤ r)
- `S_t` = current stock at start of round t
- `actions_{t-1}` = vector of all players' actions in round t-1 (undefined for t=1)
- `defect_count_last_round` = number of players who defected in round t-1 (0 if t=1)
- `stock_threshold_low` = 0.3 × capacity (critical low stock threshold)
- `forgiveness_rounds` = number of rounds to punish defectors before forgiving (e.g. 2)
- `punish_counter` = number of remaining punishment rounds (tracked in memory)

### On Round 1 (t=1):

- No history yet, so **Cooperate** to signal willingness to maintain stock and establish trust.

### For rounds t = 2 to r-1:

- **If** `punish_counter > 0`:

  - Defect this round (punishment phase)
  - Decrement `punish_counter`

- **Else**:

  - **If** last round had no defectors (`defect_count_last_round == 0`) **and** `S_t > stock_threshold_low`:

    - Cooperate

  - **Else if** at least one defector last round **or** stock is low (`S_t ≤ stock_threshold_low`):

    - Defect this round to protect yourself and signal disapproval

    - Set `punish_counter = forgiveness_rounds - 1` (start punishment phase)

### On last round (t=r):

- Defect unconditionally to maximize own payoff (no future punishment possible)

---

## Rationale

- Starts with cooperation to maintain the stock near capacity.

- Observes others’ actions and stock level:

  - If everyone cooperated and stock is healthy, continue cooperating.

  - If defection detected or stock low, punish by defecting for a fixed number of rounds (to avoid immediate switch back and to signal consequences).

- After punishment rounds, returns to cooperation if opponents behave well and stock recovers, showing forgiveness and enabling long-term cooperation.

- Last round is a classical endgame defection since no future rounds remain.

---

## Pseudocode

```python
def decide_action(t, r, S_t, actions_last_round, punish_counter):
    n = len(actions_last_round) if actions_last_round is not None else predetermined_n
    capacity = predetermined_capacity
    stock_threshold_low = 0.3 * capacity
    forgiveness_rounds = 2  # can tune for more/less forgiveness

    # Round 1: cooperate
    if t == 1:
        punish_counter = 0  # no punishment active
        return 'C', punish_counter

    # Last round: always defect
    if t == r:
        return 'D', punish_counter  # no update needed

    # Count defectors last round
    defect_count_last_round = sum(1 for a in actions_last_round if a == 'D')

    # If in punishment phase
    if punish_counter > 0:
        punish_counter -= 1
        return 'D', punish_counter

    # Otherwise decide based on last round
    if defect_count_last_round == 0 and S_t > stock_threshold_low:
        # Everyone cooperated, stock healthy: cooperate
        return 'C', punish_counter
    else:
        # Defect and start punishment phase
        punish_counter = forgiveness_rounds - 1
        return 'D', punish_counter
```

---

## Properties

- Encourages mutual cooperation that sustains the resource near capacity for maximum payoffs.

- Punishes defectors with temporary defection, deterring free-riding while limiting damage.

- Forgiveness allows return to cooperation reducing endless retaliation.

- Responds to critical stock depletion by defecting to signal urgency and protect self-interest.

- Last round defection is standard in finitely repeated games without further repercussions.

---

## Summary

This strategy is a **conditional cooperative trigger strategy with forgiveness**, adapted to the dynamic resource stock and repeated simultaneous-move structure. It does not rely on coordination or communication but leverages perfect observability of opponent actions and stock levels to maintain cooperation and maximize joint benefits, while protecting against exploitation.

---

Feel free to ask if you'd like me to tailor the punishment length or thresholds!
'''

description_COOPERATIVE_87 = '''
Here is a carefully designed cooperative strategy for the described Common Pool Resource Game. It balances maximizing collective long-term payoff by maintaining the stock while guarding against exploitation by defectors.

---

## Intuition and Goals

- **Maintain the common stock near capacity** to sustain high payoffs over rounds.
- **Cooperate initially** to signal willingness to maintain the resource.
- **Detect defection quickly** by monitoring others' actions and resulting stock changes.
- **Punish defectors by defecting if exploited**, enforcing a deterrent against over-consumption.
- **Return to cooperation if the opponent resumes cooperation**, promoting recovery and stability.
- **Defect in the last round if there was defection earlier**, to maximize own payoff (backward induction).

---

## Strategy Summary

| Round | Decision rule                             | Explanation                                                         |
|-------|-----------------------------------------|---------------------------------------------------------------------|
| 1     | Cooperate                              | Establish cooperation and build reputation                          |
| 2 to r-1 | Cooperate if all players cooperated last round and stock ≥ threshold<br>Defect if any player defected last round<br>Defect if stock too low<br> | Encourage cooperation, punish defectors, avoid resource collapse    |
| r (last round) | Defect if defection was detected any time previously<br>Cooperate otherwise | Take advantage of the last round if there was past defection        |

---

## Detailed Decision Rules

Define variables:

- `t`: current round number (1 ≤ t ≤ r)
- `history`: record of all players' actions in previous rounds
- `stock[t]`: common pool stock at start of round t
- `defection_detected`: boolean, true if any player defected on any past round
- `all_cooperated_last_round`: boolean, true if all players cooperated in round t-1
- `stock_threshold_coop`: threshold stock level below which we consider defecting or punishing (e.g., capacity / 2)

---

### Pseudocode

```python
def cooperative_strategy(t, history, stock, capacity, n, r):
    # Initialization
    stock_threshold_coop = capacity / 2
    
    if t == 1:
        # Round 1: Cooperate unconditionally to establish cooperation
        return 'C'
    
    # Check past defection history (any defection by others in any previous round)
    defection_detected = any(
        action == 'D' for past_round in history for action in past_round
        if past_round != history[-1]  # consider all except current, or could consider all
    )
    
    # Check if all cooperated last round
    last_round_actions = history[-1]
    all_cooperated_last_round = all(action == 'C' for action in last_round_actions)
    
    # Last round decision
    if t == r:
        # Defect if defection was detected any time; else cooperate
        if defection_detected:
            return 'D'
        else:
            return 'C'
    
    # Intermediate rounds (2 to r-1)
    
    # If stock is critically low, defect to avoid further stock depletion (defensive)
    if stock < stock_threshold_coop:
        return 'D'
    
    # If all cooperated last round, cooperate to maintain the resource stock
    if all_cooperated_last_round:
        return 'C'
    
    # Else (some defection detected last round), defect as punishment
    return 'D'
```

---

## Explanation

- **Round 1:** Start by cooperating to build a cooperative environment.
- **Rounds 2 to r-1:**
  - If everyone cooperated last round and the stock is healthy (≥ half capacity), continue cooperating.
  - If any defection occured last round, punish by defecting this round.
  - If the stock level becomes dangerously low (< half capacity), defect defensively to avoid further depletion (can be tuned, but helps avoid being exploited by persistent defectors).
- **Round r (last round):**
  - Defect if there was ever a defection to maximize payoff by free-riding at the end (standard backward induction).
  - Otherwise, cooperate to sustain mutual payoffs if cooperation was maintained throughout.

---

## Properties & Considerations

- **Trigger Strategy Variant:** Punishes defection immediately; this makes defection costly.
- **Forgiveness and Recovery:** After punishing defection one round, if cooperation resumes, the strategy returns to cooperation (since punishment is only triggered by last round defection).
- **Stock Monitoring:** Avoids reckless cooperation when stock is depleted, protecting against persistent over-harvesting.
- **No communication or coordination assumed:** The strategy only uses observed past actions and stock.
- **Limits exploitation:** Persistent defectors are punished quickly, but opponents can regain cooperation status by cooperating.

---

This strategy aligns with the cooperative mindset by prioritizing maintaining the common pool resource and mutual benefit, while pragmatically incorporating punishments to deter defection and a last-round defect incentive consistent with standard game theory.
'''

description_COOPERATIVE_88 = '''
Here is a cooperative strategy designed for the Common Pool Resource Game described, aimed at sustaining the common pool resource and maximizing long-run payoffs through mutual cooperation.

---

## Cooperative Strategy Description

### Intuition and Goals

- **Sustain the resource**: Keep the common pool stock close to or at capacity to ensure maximal and sustainable payoffs over many rounds.
- **Mutual cooperation**: Assume others will cooperate as long as you do, and retreat to punishment only if defections are observed.
- **Punishment and forgiveness**: Use a "grim trigger"-style approach but with forgiveness to avoid permanent mutual collapse due to errors.
- **Endgame behavior**: Gradually relax cooperation for the last rounds where future retaliation is less effective.

### High-level overview

1. **First round**: Cooperate.
2. **While no defections have been observed**: Cooperate to maintain high stock.
3. **If defect is observed**: Punish with defection for a limited number of rounds (e.g., a fixed punishment phase).
4. **After punishment phase ends**: Return to cooperation (forgiveness).
5. **Final round(s)**: Defect to maximize immediate payoff, as no future rounds remain.

---

## Detailed Decision Rules

- Let `t` = current round number (1-based).
- Let `history` be full record of all players’ actions up to `t-1`.
- Let `defection_detected` be true if any player defected in any previous round.
- Let `punishment_rounds` = fixed number of rounds to punish after a defection (e.g., 2 rounds).
- Let `punishment_timer` count down punishment rounds left.

---

### Pseudocode

```python
# PARAMETERS
punishment_rounds = 2  # Number of rounds to punish after defection detected

# STATE VARIABLES (initialized outside the strategy function)
punishment_timer = 0
defection_detected = False

def decide_action(t, history, n, r):
    global punishment_timer, defection_detected
    
    # Check for defections by any player in previous rounds
    if not defection_detected:
        for round_actions in history:
            if 'D' in round_actions:
                defection_detected = True
                punishment_timer = punishment_rounds
                break

    # Final rounds logic: defect in last round; optionally last 1-2 rounds
    if t == r:
        return 'D'
    if t >= r - 1:
        # In penultimate round, switch to defection to avoid being exploited in last round
        return 'D'

    # Punishment phase if needed
    if punishment_timer > 0:
        punishment_timer -= 1
        # Defect during punishment to penalize defectors
        return 'D'

    # Otherwise cooperate to sustain stock
    return 'C'
```

---

### Explanation of logic

- **Cooperate initially** to build trust and keep stock at capacity.
- **Monitor all players’ actions each round**; if any defect, mark defection detected.
- **Punish defectors by defecting for a brief fixed number of rounds** (2 rounds), which is enough to reduce their payoff and signal disapproval but avoids permanent breakdown.
- **After punishment, resume cooperation** — this permits recovery of the resource and mutual gains.
- **In the last round (and possibly the penultimate round), defect** to maximize immediate payoff when no future retaliation can be imposed. Staying cooperative in these rounds risks exploitation.

---

## Why this strategy is cooperative and effective?

1. **Aligned incentives:** Cooperation yields sustainable stock → higher long-run payoff for all.
2. **Conditional cooperation:** Defect only when defectors appear; otherwise cooperate.
3. **Forgiving:** This avoids permanent conflict due to isolated defects or errors.
4. **Rational exploitation at the end:** Defects in the last round(s) is standard backward induction equilibrium, protecting from exploitation at the end.
5. **Simple and robust:** No assumptions on players’ norms beyond observable behavior.

---

## Edge Cases

- **Round 1**: Always cooperate.
- **Immediate defection by others in round 1**: Punish starting next round.
- **Multiple defectors**: Punishment applies regardless of how many defect.
- **Stock dynamics and multiple defectors**: Strategy doesn’t react to stock level explicitly but uses observed defections as a proxy, since defections drive stock collapse.
- Because stock growth is nonlinear, sustained cooperation tends to maintain high stock.

---

# Summary

| Situation              | Action      |
|-----------------------|-------------|
| Round 1               | Cooperate   |
| No defections seen    | Cooperate   |
| Defection detected    | Defect for 2 rounds (punishment) |
| After punishment     | Cooperate   |
| Penultimate and last rounds | Defect     |

This strategy balances cooperation with credible punishment and forgiveness, striving to maximize collective and individual payoffs over the repeated game.
'''

description_COOPERATIVE_89 = '''
Below is a cooperative strategy designed for the Common Pool Resource Game described. It aims to sustain the common pool stock and achieve high joint payoffs by fostering cooperation through conditional, incentive-compatible behavior.

---

## Cooperative Strategy Description: "Sustained Cooperation with Punishment and End-Game Adjustment"

### Key Intuition
- **Default:** Cooperate by consuming *stock/(2n)* each round, preserving the resource.
- **Monitoring:** Detect defections by comparing observed consumption rates.
- **Punishment:** Temporarily punish detected defectors by defecting for a fixed number of rounds to discourage free-riding.
- **Forgiveness:** Return to cooperation after punishment to try restoring trust.
- **Endgame:** In the last round, defect since there is no future to enforce cooperation.

---

### Notation and Observables
- Let `t` ∈ {1,...,r} be the round index.
- Let `S_t` be the stock at the start of round `t`.
- For each player `j`, observe action `a_j,t-1` ∈ {C,D} from previous round (except `t=1`).
- Maintain a set `PunishSet` of players currently punished (initially empty).
- Maintain `punish_counter_j` for each player `j`, counting remaining punishment rounds.

---

### Decision Rules

#### 1. **First Round (t=1)**
``` 
Play Cooperate (C)
```
Rationale: No history yet, start with cooperative trust.

---

#### 2. **Subsequent Rounds (1 < t < r)**
```
For each player j ≠ self:
  If j defected (played D) in round t-1 and j not already in PunishSet:
    Add j to PunishSet
    punish_counter_j = fixed_punish_length (e.g., 2 rounds)

If self in PunishSet:
  - Play Defect (D)
  - punish_counter_self -= 1
  - If punish_counter_self == 0:
      Remove self from PunishSet

Else if PunishSet is not empty:
  - Play Defect (D)  # mutual punishment to enforce cooperation

Else:
  - Play Cooperate (C)
```

**Explanation:**
- Detect any defections by others last round.
- Punish defectors by defecting for a small fixed number of rounds (e.g., 2).
- Punishment is mutual: when punishing anyone, defect yourself until punishment phase ends.
- After punishment, return to cooperation.
- If no defectors, always cooperate to maintain stock.

---

#### 3. **Last Round (t = r)**
```
Play Defect (D)
```
Rationale: No future to enforce cooperation, best short-term payoff by defecting.

---

### Additional Notes
- **Punishment length:** Short punishments (2 rounds) balance deterrence and efficiency.
- **Stock Monitoring:** The strategy uses only observed actions, not payoff or stock level. This avoids false detections from fluctuations.
- **No initial assumption about opponents:** Starts fully cooperative.
- **Robustness:** Punishment present deters unilateral defectors.
- **Stock sustainability:** By cooperating except during punishments, the stock tends to remain healthy.
- **Future considerations:** Could be extended with more sophisticated state tracking or forgiving at a discount.

---

## Pseudocode Summary

```
Initialize:
  PunishSet = {}
  For all players j: punish_counter_j = 0

for t in 1 to r:
  if t == 1:
    action = C
  else if t == r:
    action = D
  else:
    # Update PunishSet based on last round actions
    for j != self:
      if action_j,t-1 == D and j not in PunishSet:
        PunishSet.add(j)
        punish_counter_j = 2

    # Decrement punishment counters and remove finished punishments
    for j in PunishSet:
      punish_counter_j -= 1
      if punish_counter_j == 0:
        PunishSet.remove(j)

    if self in PunishSet:
      action = D
    else if PunishSet not empty:
      action = D
    else:
      action = C

  Play action
```

---

## Summary

By starting cooperatively, punishing observed defectors briefly but firmly, and forgiving after punishment, this strategy:

- Encourages mutual cooperation and preservation of the common pool.
- Discourages exploitation via conditional retaliation.
- Adapts in the final round to maximize individual payoff, reflecting standard backward induction.
- Operates only with knowledge of others' past actions, suitable for perfect information repeated setting without communication.

This approach aligns with the cooperative mindset of sustaining the resource and maximizing long-run joint payoffs while safeguarding against exploitation.
'''

description_COOPERATIVE_90 = '''
Below is a detailed cooperative strategy for the Common Pool Resource (CPR) Game that aims to sustain the stock as close as possible to capacity, maximizing long-run payoffs for all players who cooperate while punishing defection to discourage over-extraction.

---

## Cooperative Strategy: **"Sustained Cooperation with Grim Trigger"**

### Intuition

- Start by cooperating (C) to maintain the resource stock near capacity.
- Continue cooperating as long as everyone cooperated in previous rounds.
- If a defection (D) by any player is detected in any past round, defect forever after (grim trigger punishment).
- In the last round, defect regardless (since no future punishments matter).
- This supports a cooperative equilibrium that sustains the resource while deterring defection.

---

### 1. Decision Rules

**Round 1:**
- Cooperate (C) unconditionally since there is no history yet.

**Rounds 2 to r-1:**
- If *all* players cooperated in **all** previous rounds (no defection observed), cooperate (C).
- Else, defect (D) forever as punishment.

**Round r (last round):**
- Defect (D) unconditionally (final round defection).

---

### 2. Handling Edge Cases

- **First round (t=1):**  
  No prior history → cooperate.

- **Last round (t = r):**  
  Defect unconditionally to maximize final round payoff, as no future punishment possible.

- **Detection of defection:**  
  Because actions are public and simultaneous, players observe previous round’s actions perfectly.

- **No forgiveness:**  
  Once a defection is observed, the strategy defects forever (grim trigger) to incentivize long-term cooperation.

---

### 3. Cooperative Alignment Explanation

- Cooperating consumes less per player (S/(2n)) than defecting (S/n), preserving the stock.
- Sustaining stock near capacity maintains higher overall payoffs long-term.
- The threat of eternal punishment (defection forever after defection detection) deters selfish behavior.
- Final round defection extracts maximum payoff when no future consequences exist.

---

### Pseudocode

```python
def cooperative_strategy(t, r, history_actions, n):
    """
    Parameters:
    - t: current round (1-based)
    - r: total rounds
    - history_actions: list of lists, each inner list is actions by all players in round t-1
                       e.g. history_actions[t-2] = ['C', 'D', 'C', 'C']
    - n: number of players
    
    Returns:
    'C' if cooperating this round, 'D' otherwise
    """

    # Last round: defect
    if t == r:
        return 'D'

    # First round: cooperate unconditionally
    if t == 1:
        return 'C'

    # For rounds 2 to r-1:

    # Check if any defection observed in history
    for past_round in history_actions:
        if 'D' in past_round:
            # Defection detected - punish forever
            return 'D'

    # No defection detected - cooperate
    return 'C'
```

---

### Summary

| Round          | Action Rule                                      |
|----------------|-------------------------------------------------|
| First (t=1)    | Cooperate                                       |
| Intermediate   | Cooperate if no defection previously detected; else defect forever |
| Last (t = r)   | Defect                                         |

---

### Notes & Limitations

- This grim-trigger strategy strongly incentivizes cooperation but is unforgiving after defection.
- Since players cannot signal or communicate, the threat of eternal punishment can sustain cooperation if rational players want to avoid long term losses.
- Other strategies might attempt retaliation or forgiveness, but this approach sets a clear cooperative baseline.
- The strategy does **not** defect in intermediate rounds unless defection was already observed, supporting stable cooperation.

---

If you want a more nuanced forgiveness or gradual punishment approach, that can be designed too. But given the information and assumptions, an unforgiving grim trigger is a canonical cooperative strategy supporting high common payoffs.
'''

description_COOPERATIVE_91 = '''
Below is a carefully designed cooperative strategy for this repeated common pool resource game. It aims to maintain maximum sustainable stock and maximize collective payoffs by fostering cooperation and punishing defection in a controlled way. It works under the assumptions listed, notably: perfect observation of actions, no communication, no coordination devices, and repeated rounds.

---

## Strategy Overview: "Sustained Cooperation with Grim Trigger and Forgiveness"

This strategy attempts to maintain the resource at or near capacity by cooperating as long as no defections are detected. Upon defection detection, it applies a punishment phase (defecting) to discipline defectors and protect the resource. To avoid excessive collapse due to errors or misunderstandings, the strategy may forgive after a punishment phase.

**Key points:**

- **Cooperate (C) initially and while all observed players cooperate.**
- **If any defection is observed, enter punishment phase by defecting.**
- **After one round of punishment, revert to cooperation to allow recovery (forgiveness).**
- **In the last round, defect unconditionally to maximize immediate payoff.**

---

## Detailed Decision Rules

### Variables

- `round`: current round (1 to r)
- `history`: record of all players' actions in previous rounds (observable perfectly)
- `punish`: Boolean flag indicating if this round is punishment following a detected defection
- `defect_detected_last_round`: Boolean indicating if any player defected last round (excluding self)
- `capacity, n`: as per game parameters

### Initialization

- `punish := False` initially

---

### Per Round Decision Pseudocode

```python
function decide_action(round, history, capacity, n):
    # Last round special case: always defect (no future punishment possible)
    if round == r:
        return 'D'

    # Detect defection in previous round (if round > 1)
    if round > 1:
        actions_prev_round = history[round - 1]  # array of length n
        # Check if any other player defected last round
        defect_detected_last_round = any(
            actions_prev_round[player_idx] == 'D' 
            for player_idx in range(n) if player_idx != self_index
        )
    else:
        defect_detected_last_round = False

    # Update punishment flag
    # - If defect detected last round, enter punishment phase this round
    # - If currently in punishment phase, revert to cooperation next round (forgiveness)
    if defect_detected_last_round:
        punish = True
    elif punish:
        # Forgive after one round punishment
        punish = False

    # Decision rules
    if punish:
        # Punish by defecting to reduce stock sharply
        return 'D'
    else:
        # Cooperate if no punishment currently needed
        return 'C'
```

---

## Explanation

- **First round (t=1):** Cooperate to signal cooperative intent and maximize initial stock sustainability.
- **If all cooperate continuously:** Stock remains high (close to capacity), per example given.
- **If any defector appears:** The strategy defects next round to punish defectors and impose costs on them (stock reduces sharply, lowering their payoff in future rounds).
- **Punishment lasts exactly one round:** This lessens the risk of permanent mutual destruction from long punishments and allows others to return to cooperation.
- **After punishment round:** The strategy forgives by returning to cooperation, implementing a “tit-for-tat” style forgiveness, encouraging restoration of cooperation.
- **Last round:** Defect unconditionally because no future consequences exist.

---

## Rationale for Design Choices

- **One-round punishment ("grim-ish trigger")** offers effective deterrence against defection while avoiding prolonged destructive cycles.
- **Forgiveness after punishment** allows recovery of the common pool stock and prevents total collapse from persistent retaliation.
- **Observing all players' actions** ensures defections are detected promptly.
- **Defecting in final round** captures the maximal short-term payoff since no incentive to preserve stock remains.

---

## Possible Extensions (not in base strategy)

- Using thresholds of stock depletion (if stock S drops below a fraction of capacity, e.g., 50%, defect to trigger faster punishment)
- More nuanced retaliations (several rounds of punishment or probabilistic punishment)
- Differentiating defectors by individual (not possible since all act simultaneously and history shows aggregate)

---

## Summary

| Round        | Condition                          | Action                  |
|--------------|----------------------------------|-------------------------|
| Round 1      | Always                           | Cooperate (`C`)         |
| Rounds 2 to r-1 | If any player defected last round | Defect (`D`) (punish)   |
|              | else                            | Cooperate (`C`)         |
| Round r (last round) | Always                      | Defect (`D`)            |

---

This strategy maximizes collective returns by stabilizing the stock while providing incentives against defection. It is fully implementable with the given information and fits the cooperative mindset desired.
'''

description_COOPERATIVE_92 = '''
**Strategy Name:** *Conditional Cooperative Stewardship*

---

### 1. **Decision Rules (Main Idea)**

- **Default to cooperation (play C) in the first round** to maintain sustainable stock levels.
- **Continue cooperating if the common pool remains healthy and other players mostly cooperate.**
- **Detect defections by observing higher total consumption (i.e., stock depletion greater than expected) and respond with temporary punishments (defect) to discourage over-consumption.**
- **Use forgiveness mechanisms to return to cooperation once the stock stabilizes or recovers.**
- **Defect (play D) only when stock is critically low or clear exploitation by others occurs to preserve minimal payoff for self without ruining the resource.**

The strategy fosters cooperation for mutual long-term benefit but punishes defectors to maintain discipline, allowing recovery and eventual return to cooperation.

---

### 2. **Detailed Explanation**

#### Key variables:
- `S_t`: Stock at start of round `t`
- `C_t`: number of players cooperating in round `t` (unknown directly; can only infer from depletion)
- `total_consumption_t`: amount the stock decreased due to extraction in round `t`
- `expected_consumption_if_all_C = S_t / 2` (since each of n players consumes S_t/(2n), total = n * S_t/(2n) = S_t/2)
- `expected_consumption_if_all_D = S_t` (since total consumption = n * S_t/n)
- `threshold_defect_flag = expected_consumption_if_all_C + ε` (a tiny margin to detect deviation)
- `critical_stock_threshold = capacity / 4` (25% of capacity: below which defect to preserve stock)
  
#### Intuition behind thresholds:
- If total consumption is significantly above expected (all cooperating) consumption, it implies someone defected.
- If stock is dangerously low, defecting oneself does not help; defect only as a defensive move to consume what you can before collapse.
  
---

### 3. **Pseudocode of the Strategy**

```python
# Parameters known: n, r, capacity
# Initialize:
S_1 = capacity

# Internal state:
defection_detected = False
punishment_rounds_left = 0
punishment_length = 2  # number of rounds to punish after detecting defection
epsilon = 0.01  # small margin to allow for floating errors

for t in 1 to r:
    if t == 1:
        # First round: cooperate to establish trust and sustain stock
        action = 'C'

    else:
        # After round 1, observe stock depletion to infer others' behavior
        total_consumption = S_{t-1} - S_t  # S_t observed at start of round t
        
        # Expected consumption if all cooperated:
        expected_coop_consumption = S_{t-1} / 2
        
        # Check if defection likely happened in previous round
        if total_consumption > expected_coop_consumption + epsilon:
            defection_detected = True
            punishment_rounds_left = punishment_length
        
        # Strategy logic:
        if punishment_rounds_left > 0:
            # Punishment phase: defect to discourage defection
            action = 'D'
            punishment_rounds_left -= 1
        else:
            # Punishment over or no defection detected

            # If stock critical low, defect to get payoff before collapse (less cooperative demand)
            if S_t < critical_stock_threshold:
                action = 'D'
            else:
                # Otherwise, cooperate to sustain resource and maintain long-term gains
                action = 'C'
                
        # Forget defection flag if punished enough
        if punishment_rounds_left == 0:
            defection_detected = False

    # Play action
    yield action
```

---

### 4. **Handling Edge Cases**

- **First round:** Always cooperate; no prior information.
- **Last round (t = r):**  
  - The incentive to defect is higher since no future punishment exists (standard last-round defection logic).  
  - However, to keep the strategy cooperative (and possibly induce cooperation in others), still **cooperate on the last round unless stock is critically low**, in which case defect to secure immediate payoff.
- **Stock collapse (S_t ≈ 0):**  
  - Strategy defects, as cooperation yields no payoff and stock cannot recover.
- **Multiple consecutive defections detected:**  
  - Punish repeatedly for fixed punishment length following each detected defection.
- **Forgiveness:**  
  - After punishment rounds, return to cooperation to allow stock recovery and re-establish cooperation.

---

### 5. **Rationale Why This Is Cooperative**

- It **starts with cooperation**, signaling trust.
- It **maintains cooperation as long as the common pool and others' behavior allow**.
- It protects the resource state by punishing defectors, which **discourages overexploitation**.
- It **allows recovery of the stock** through forgiveness phase.
- It defects only as a **consequence of defection or in critical endgame scenarios**.
- This approach **balances immediate payoffs with long-term sustainability**, embodying a stewardship mindset.

---

### 6. **Summary**

| Condition                           | Action  |
|-----------------------------------|---------|
| Round 1                           | Cooperate (C) |
| Detected defection last round     | Defect (D) for fixed punishment rounds |
| After punishment rounds           | Cooperate (C) |
| Stock < 25% capacity              | Defect (D) (protect own payoff in critical state) |
| Otherwise                       | Cooperate (C) |

---

This strategy should produce high cumulative payoffs if others cooperate and maintain the pool, and discourage exploitative defectors via retaliation, optimizing the common pool game payoff over repeated rounds.
'''

description_COOPERATIVE_93 = '''
Below is a cooperative strategy designed to sustain the common pool resource over multiple rounds while maximizing collective long-term payoffs. It is inspired by an iterated “grim trigger” style approach, suitably adapted for this dynamic stock environment and simultaneous moves with full observability.

---

## Cooperative Strategy: "Sustained Cooperation with Trigger Punishment"

### Intuition

- **Goal:** Maintain high stock levels by everyone cooperating (playing C), sharing the resource sustainably.
- **Cooperation payoff:** Moderate each round (stock/(2n)), but keeps stock healthy for future rounds.
- **Defection payoff:** Higher immediate payoff (stock/n) but risks stock depletion, harming all in later rounds.
- **Mechanism:** Start cooperating, monitor others’ actions to detect defections and **punish defectors by defecting in all future rounds**.
- **Last round:** Since no future retaliation is possible, defect to maximize one-shot payoff.

---

### Detailed Behavior Rules

1. **Round 1 (Initial round):**  
   - **Action:** Cooperate (C) unconditionally.
   - **Rationale:** Establish cooperative baseline; no history yet.

2. **Rounds 2 to r-1 (Intermediate rounds):**  
   - **Condition:** Continue cooperating if no defections have been detected in all previous rounds.
   - **Detection:**  
     - Since actions are simultaneous but observable **after** the round, record actions of all players each round.
     - If *any* player defected (played D) in any previous round, switch permanently to defect (D).
       - This is the "grim trigger" punishment to deter defection.
   - **Action:**  
     - If no defections detected so far, cooperate (C).
     - Else, defect (D).

3. **Round r (Last round):**  
   - **Action:** Defect (D) regardless of history.
   - **Rationale:** No future retaliation possible, so defect to maximize immediate payoff.

---

### Edge Cases Handled

- **First round:** no opportunity to punish, so cooperate.
- **Detection is perfect and immediate (previous rounds observed before deciding current action).**
- **If any defection occurs, punishment is permanent, deterring defection overall.**
- **Last round defection is safe and individually optimal, consistent with backward induction.**

---

### Pseudocode

```python
# Inputs:
# - r: total rounds
# - round_t: current round (1 to r)
# - history_actions: list of lists of actions from past rounds
#    history_actions[t-1] = [a_1, a_2, ..., a_n] actions by all players at round t; own action included

def cooperative_strategy(round_t, history_actions, player_index):
    # Step 1: Last round
    if round_t == r:
        return 'D'  # Defect in last round

    # Step 2: Check previous rounds for any defection by any player
    for past_round in range(round_t - 1):
        # actions in past round
        actions = history_actions[past_round]  
        if 'D' in actions:  # any defection detected
            return 'D'  # permanent punishment

    # Step 3: No defections previously detected
    return 'C'  # cooperate
```

---

### Strategic Rationale Summary

- Cooperative consumption (C) splits the stock consumption evenly and sustains the fishery.
- Defection (D) yields higher immediate payoff but risks resource collapse.
- "Grim trigger" incentivizes all players to maintain cooperation lest they face permanent punishment.
- Last round defection aligns with standard finite repeated game logic.
- This strategy is transparent, stable, and robust under the assumptions.

---

### Expected Outcomes

- If all players adopt this strategy, the pool stock remains near capacity, maximizing long-run common payoffs.
- Any unilateral defection is deterred by credible permanent punishment.
- It balances individual incentives against collective welfare favorably in this repeated common pool resource setting.

---

If you want, I can also help with variants or adaptations for noisy observations or probabilistic forgiveness.
'''

description_COOPERATIVE_94 = '''
**Cooperative Strategy for the Common Pool Resource Game**

---

### Intuition

The strategy aims to sustain the common pool resource by cooperating (playing `C`) to keep the stock near or at capacity for as long as possible, thus maximizing long-term payoffs for all. Defection (playing `D`) is used only as a last resort to punish and deter opponents who defect, encouraging return to cooperation.

Because the resource regenerates best when the stock is healthy, cooperation yields higher collective payoffs in the long run. In the last round, since there is no future to protect, the strategy may defect to capture remaining value.

---

### Summary of Core Principles

- **Start cooperating** to signal goodwill.
- **Monitor opponents’ actions each round.**
- **Stick to cooperation as long as no one defects.**
- **If any opponent defects, punish by defecting in the next round.**
- **After one round of punishment, return to cooperation if the opponent resumes cooperating.**
- **In the last round, defect to maximize immediate payoff.**

---

### Detailed Description

---

#### Variables to track during play

- `round` — current round index (1 to r)
- `history` — record of all players' past actions, fully observable
- `opponents_defected_last_round` — boolean flag, true if any opponent defected last round
- `punishment_mode` — boolean, are we currently punishing?
- `last_round` — flag indicating if the current round is the last round `r`

---

#### Decision Rules

**Round 1:**

- Play `C` (cooperate) to establish trust and sustain the stock.

---

**Rounds 2 to r-1:**

- If `punishment_mode` is OFF:
  - If **any opponent defected in the previous round**, enter `punishment_mode` and play `D` this round.
  - Else play `C` to maintain cooperation.

- If `punishment_mode` is ON:
  - Play `D` this round to punish defectors.
  - After this round, if *all opponents cooperated last round*, exit `punishment_mode`.
  - Else remain in `punishment_mode`.

---

**Round r (last round):**

- Always play `D` — no future to protect, so maximize immediate payoff.

---

### Pseudocode

```python
def cooperative_strategy(round, r, history, capacity, n):
    # history is a list of past rounds (each round is a list of actions by all players)
    # Current player index: i (should be known internally)
    # Assume we can identify opponents as players other than i
    i = self_player_index  
    last_round = (round == r)

    # Initialize static or persistent variables
    if round == 1:
        punishment_mode = False
    else:
        punishment_mode = get_persistent("punishment_mode", False)

    def opponents_defected(history, round, i):
        # Check if any opponent defected in the previous round
        prev_round_actions = history[round - 2]  # zero-based index
        for j in range(n):
            if j != i and prev_round_actions[j] == 'D':
                return True
        return False

    if last_round:
        action = 'D'  # defect in last round to maximize payoff
    else:
        if round == 1:
            action = 'C'  # start cooperating
        else:
            if not punishment_mode:
                if opponents_defected(history, round, i):
                    punishment_mode = True
                    action = 'D'  # start punishment
                else:
                    action = 'C'  # continue cooperating
            else:
                # Currently punishing
                action = 'D'
                # Check if opponents cooperated last round to decide if exit punishment
                prev_round_actions = history[round - 2]
                opponents_cooperated_last_round = all(
                    prev_round_actions[j] == 'C' for j in range(n) if j != i
                )
                if opponents_cooperated_last_round:
                    punishment_mode = False  # exit punishment

    set_persistent("punishment_mode", punishment_mode)
    return action
```

---

### Explanation of Components

- **Cooperation as Default:** By cooperating unless provoked, the strategy contributes to stable resource replenishment and higher long-term payoffs.

- **Trigger Punishment:** If any defect is detected, defect next round to signal disapproval and deterrence.

- **Punishment Length:** Punishment lasts for one round by default. If opponents do not resume cooperation, punishment persists.

- **Last Round Defection:** Since no future rounds exist, defect to maximize immediate payoff, avoiding being exploited last moment.

- **Minimal Memory:** Only tracks if currently punishing. Uses public history to detect defection.

---

### Handling Edge Cases

- **First Round:** Cooperate; no prior info to punish.

- **Simultaneous Defections:** If multiple players defect at once, punishment starts immediately after detection to signal disapproval.

- **Persistent Defection by Opponents:** If opponents continuously defect, this strategy will defect in all subsequent rounds except the last.

- **Resource Collapse:** If stock collapses, the payoff for either action is minimal; the strategy maintains cooperation in hope of revival.

---

### Why This is Cooperative?

- Prioritizes cooperation for resource sustainability.

- Only punishes to enforce cooperation, not out of greed.

- Returns to cooperation once opponents do.

- No unconditional defection; encourages all to sustain the resource.

---

### Potential Variations / Enhancements (Optional)

- Include threshold on stock level under which cooperate regardless to help stock recover.

- Use forgiveness timers longer than one round punishment.

- Gradual defection intensity (e.g., occasional defection) to balance incentives.

- But these complicate the simple cooperative mindset and may not be needed for the tournament.

---

If you want, I can also provide an alternative version with these enhancements or tweaked forgiveness parameters. Otherwise, this straightforward “Cooperate unless provoked, punish once, forgive if cooperation resumes, defect last round” is a strong cooperative baseline.
'''

description_COOPERATIVE_95 = '''
Here is a cooperative strategy aligned with the game goals and constraints. It balances patience (to protect the common pool) and firmness (to discourage defection), aiming to sustain the resource and maximize long-run payoffs.

---

## Cooperative Strategy: Conditional Cooperation with Forgiveness ("Sustainable Reciprocity")

### Intuition / Overview

- **Goal:** Maintain the common stock at or near capacity by all cooperating, maximizing everyone's payoffs over all rounds.
- **Cooperate:** Default is to cooperate (harvest stock/(2n)) to keep the resource sustainable.
- **Detect Defection:** If any player defects (harvests more than stock/(2n)) in the prior round, punish defectors by defecting ourselves next round.
- **Forgiveness:** After punishing a defection for exactly one round, return to cooperation, allowing a return to sustainability.
- **First round:** Always cooperate to establish a baseline of good faith.
- **Last round:** Defect to capture leftover value because there is no future to protect (standard backward induction).
- **Stock awareness:** If stock falls below a critical threshold (e.g. 30% of capacity), punish defectors more harshly (defect consistently until stock recovers), since the resource is in danger.

---

### Detailed Rules

At round t (1 ≤ t ≤ r) let:

- S_t = stock at start of round t (known at start of round)
- A_{i,t} = previous action of player i at round t-1 (known after round 1)
- Defectors_{t-1} = set of players who defected at round t-1

Define a few parameters:

- `coop_harvest = S_t / (2n)`
- `defect_harvest = S_t / n`
- Threshold for low stock: `low_stock_threshold = 0.3 * capacity`

---

### Action Decision for *us* at round t

If t == 1:
- Play C (cooperate)

Else if t == r (last round):
- Play D (defect) — exploit remaining stock, no incentive to cooperate

Else (1 < t < r):
- If current stock S_t < low_stock_threshold:
  - If we detected any defection in previous round (Defectors_{t-1} ≠ ∅):
    - Defect (to punish immediately and discourage over-harvesting causing low stock)
  - Else:
    - Cooperate (try to help recover stock)

- Else (S_t ≥ low_stock_threshold):
  - If no defection detected in previous round (Defectors_{t-1} = ∅):
    - Cooperate
  - Else if we defected in last round:
    - Cooperate now (forgive after 1 round of punishment)
  - Else:
    - Defect (punish defectors)

---

### Additional Notes:

- Detection of defection is based on observing other players’ actions last round.
- Because players act simultaneously, punishment only affects next round.
- Forgiveness after 1 round of punishment prevents endless mutual defection.
- Low stock triggers stricter punishment to prevent collapse.
- By reverting to cooperation quickly, the stock can recover and everyone benefits.
- Choosing defect last round is standard rational backward induction.

---

### Pseudocode

```python
def cooperative_strategy(
    round_t, r, n, capacity, S_t,
    last_round_actions,  # dict player_id -> 'C' or 'D'
    own_last_action=None
):
    low_stock_threshold = 0.3 * capacity

    # Identify defectors last round
    defectors = [p for p, a in last_round_actions.items() if a == 'D'] if last_round_actions else []

    if round_t == 1:
        return 'C'

    if round_t == r:
        return 'D'

    # mid game rounds
    if S_t < low_stock_threshold:
        if len(defectors) > 0:
            return 'D'  # punish defectors harshly
        else:
            return 'C'  # cooperate to aid recovery

    # stock not low
    if len(defectors) == 0:
        return 'C'  # all cooperated last round, continue cooperating

    # defection detected last round
    # check if we already defected last round (to forgive)
    if own_last_action == 'D':
        return 'C'  # forgive and return to cooperation

    return 'D'  # punish defectors
```

---

### Explanation

- **Round 1:** Start cooperatively to build mutual trust.
- **Rounds 2..r-1:**
  - Cooperate if no defection last round and stock is healthy.
  - Defect to punish if defection detected last round (but only for one round, then forgive).
  - If stock is dangerously low, defect immediately if defection happened, else cooperate to help recovery.
- **Round r:** Defect to maximize last round payoff.

---

### Strategic Properties

- **Enforces cooperation:** Defections get quickly punished.
- **Forgiving:** Allows recovery from mistakes or experiments.
- **Sustainable:** Protects the resource, maximizing long-term payoffs.
- **Robust:** No assumptions about others' intentions except their actions.
- **Simple:** Only requires observing last round actions and current stock.

---

This strategy aims to maximize cooperative payoffs by keeping stock near capacity and preventing over-extraction through threat of punishment, while avoiding endless cycles of defection via forgiveness and encouraging recovery when resource is depleted.
'''

description_COOPERATIVE_96 = '''
Below is a cooperative strategy designed to maximize long-term collective payoff in the given Common Pool Resource (CPR) game. It aims to sustain the common stock and thus secure higher cumulative payoffs over all rounds by cultivating mutual cooperation, detecting defections, and punishing them only briefly.

---

## Intuition

- **Cooperate (C)** by default to keep the resource sustainable.
- **Defect (D)** only as a punishment for detected defectors, **but only briefly**, to avoid permanent collapse and encourage a return to cooperation.
- Use **tit-for-tat style** monitoring: mirror others' previous round behavior.
- Recognize **endgame effect**: defect in the last round, since no future rounds remain for retaliation, so exploit the stock maximally.
- Be forgiving to restore cooperation quickly after a defection.

---

## Strategy Description

### Variables tracked during gameplay
- `roundNumber` — current round index (1 to r)
- `lastRoundActions` — vector of all players' actions in previous round
- `defectionDetected` — Boolean, true if any player defected last round (including self)
- `punishmentRoundsLeft` — integer counter, number of remaining rounds to punish after detecting defection
- `cooperate` — Boolean, whether to cooperate this round

### High-level rules

1. **First round (roundNumber == 1):** Cooperate unconditionally.

2. **Rounds 2 to r-1:**
    - If no defection detected in last round, cooperate.
    - Else, if defection detected, start or continue a finite punishment phase:
       - Punish defectors by defecting this round.
       - After `punishmentLength` rounds of punishment, return to cooperation.
    - Always monitor all players’ last round choices (including self) to detect defections.

3. **Final round (roundNumber == r):** Defect unconditionally to maximize last-round payoff (no incentive to sustain stock for future rounds).

---

## Parameters

- `punishmentLength`: The fixed number of rounds to punish after detecting defection. A small constant (e.g., 1 or 2) to avoid lengthy resource depletion but sufficient to deter defectors.

---

## Pseudocode

```python
initialize:
    punishmentLength = 1  # or 2, tuneable
    punishmentRoundsLeft = 0
    defectionDetected = False

for roundNumber in 1 to r:

    if roundNumber == 1:
        # First round, cooperate unconditionally
        cooperate = True

    else if roundNumber == r:
        # Last round, defect to maximize final payout
        cooperate = False

    else:
        # rounds 2 to r-1

        # Detect if any player defected last round
        defectionDetected = any(action == 'D' for action in lastRoundActions)

        if punishmentRoundsLeft > 0:
            # Currently punishing defectors
            cooperate = False
            punishmentRoundsLeft -= 1

        else:
            if defectionDetected:
                # Start punishment phase
                punishmentRoundsLeft = punishmentLength - 1  # current round counts as one
                cooperate = False
            else:
                # No defection, cooperate to sustain resource
                cooperate = True

    # Output action for this round
    action = 'C' if cooperate else 'D'
```

---

## Explanation and Justification

- **Starting cooperatively** signals goodwill and aims to sustain the resource early on.
- **Detecting defection** anywhere signals a breach of cooperation. Punishing by defecting reduces their payoff, discouraging free-riding.
- **Punishment is limited in duration** to avoid excessive stock degradation that hurts all players, including cooperators.
- **Forgiveness after punishment** allows the group to restore cooperation quickly, preventing permanent cycles of retaliation.
- **Defecting last round** captures the rational incentive to maximize immediate payoff when no future retaliation is possible.
- **Observing all players' actions** aligns with perfect information assumption.
- The strategy aligns with the cooperative mindset by prioritizing sustainability and mutual benefit, while using minimal but firm deterrence against defectors.

---

## Edge Cases

- If multiple defectors appear, punishment applies equally: defect to punish all defectors simultaneously.
- Because actions are simultaneous, one player’s defection triggers punishment on all players (including oneself if defected). This is intentional to enforce accountability.
- If a player defects because of stock collapse (e.g., stock = 0), the strategy still triggers punishment, but since defection does not replenish stock, cooperation is incentivized to restore stock.
- If stock is low near last rounds, defecting last round maximizes player payoff since no future rounds remain to repair damage.
- If capacity is exactly 2n, the rules remain consistent mathematically.

---

This strategy balances cooperation, deterrence, and the final-round self-interest, optimizing cumulative payoffs under the game’s constraints and informational setup.
'''

description_COOPERATIVE_97 = '''
Below is a detailed cooperative strategy designed to maximize long-term collective payoffs by maintaining the common pool resource while deterring and responding to defection. This strategy is inspired by “trigger” or “grim-trigger”-style strategies suitable for repeated common-pool resource games but adapted to handle dynamic resource stock and multiple players without communication.

---

## Strategy Name: *Conditional Cooperative Steward*

### Intuition and Goals
- **Preserve the resource stock** close to its maximum capacity to sustain high payoffs over many rounds (since growth is highest at intermediate levels, but full cooperation stabilizes at capacity).
- **Start cooperative**, assuming others also prefer sustainability.
- **Detect defections reliably** by monitoring the resource stock dynamics after actions are revealed.
- **Punish defection by defecting for a finite punishment phase** to avoid perpetual collapse if the defector returns to cooperation.
- **Return to cooperation after punishment** to re-establish trust and sustainability.
- **Defect in the last round** (no future incentive to cooperate).

---

### 1. Decision Rules

#### Variables Tracked
- `round` : current round number (1 to r)
- `S` : common pool stock at the start of the round (known)
- `history` : complete actions and payoffs history from previous rounds, including observed consumption and resulting stock
- `punishment_timer` : integer counting rounds remaining in punishment phase; 0 if no punishment ongoing
- `capacity` : stock capacity parameter
- `n` : number of players

#### Parameters Set
- `defection_tolerance` = small float (e.g., 5% of expected consumption) — tolerance margin to detect defection from deviations in stock or observed consumptions
- `punishment_length` = minimum rounds to defect after defection detected (e.g., 2 rounds)
- `cooperator_consumption = S / (2n)`  (current round, updated after each round)
- `defector_consumption = S / n` (current round)

---

### Pseudocode of the Strategy

```python
def conditional_cooperative_steward(round, r, S, capacity, n, history, punishment_timer):
    # Last Round: Defect to maximize immediate payoff (no incentive to cooperate)
    if round == r:
        return 'D'

    # If currently in punishment, defect
    if punishment_timer > 0:
        punishment_timer -= 1
        return 'D', punishment_timer

    # First Round: Cooperate unconditionally
    if round == 1:
        return 'C', punishment_timer

    # After Round 1: Detect defection from history and stock dynamics
    # Step 1: Calculate expected total consumption if all cooperated last round:
    expected_consumption_coop = S_prev = history[round-2]['stock_start']  # stock start previous round
    expected_total_coop = n * (S_prev / (2*n))  # = S_prev / 2

    # Step 2: Calculate actual consumption inferred from stock levels
    # Consumption last round = stock_start - stock_end + growth
    stock_end_prev = history[round-2]['stock_end']
    growth_prev = 2 * stock_end_prev * (1 - stock_end_prev / capacity)
    actual_consumed = S_prev - (stock_end_prev + growth_prev)

    # Step 3: If actual consumption exceeds expected by more than tolerance, defect detected
    if actual_consumed - expected_total_coop > defection_tolerance:
        # Enter punishment phase starting now
        punishment_timer = punishment_length
        return 'D', punishment_timer

    # Else cooperate
    return 'C', punishment_timer
```

---

### 2. Handling Edge Cases:

- **First Round**: Cooperate unconditionally because no past info to infer defectors and cooperation maximizes initial stock sustainability.
- **Last Round**: Defect to maximize one-shot payoff (standard backward induction logic).
- **After Detected Defection**: Defect for `punishment_length` rounds as sanctioned retaliation.
- **After Punishment**: Return to cooperation to allow recovery of the resource and re-building of trust.
- **Close to Capacity but Small Deviation in Stock**: Small fluctuations in stock growth or others' minor deviations are tolerated; only significant deviations trigger punishment.
- **Multiple Defections**: Each defection resets the punishment timer.
- **If Stock Ever Reaches Zero**: Cooperate anyway in subsequent rounds (except last round) to help rebuild stock by limiting consumption.

---

### 3. Cooperative Mindset Summary

- The strategy assumes mutual cooperation is best for all in the long run.
- It **actively monitors common pool outcomes** to detect exploitive behavior.
- It **punishes defections proportionally and temporarily**, avoiding perpetual vendettas.
- It **forgives after punishment** to restore cooperation.
- It **preserves the common pool stock**, maximizing total payoffs.
- It **avoids unnecessary defection**, minimizing resource damage.
- It only defects in the **final round** to maximize personal payoff as no future rounds can reward cooperation.

---

# Additional Notes

- Since player actions are simultaneous and only actions and payoffs are observable, the most reliable defection detection is via deviations in total consumption inferred from stock dynamics, rather than guessing individual behavior.
- Using a **forgiving finite punishment** over infinite “grim trigger” encourages resuming cooperation even after shocks or mistakes.
- The tolerance margin accounts for minor noise or rounding errors.
- If multiple players defect simultaneously, it will trigger punishment mimicking a tit-for-tat group dynamic.

---

If you prefer, I can provide more detailed pseudocode or explanation for how to implement the history tracking and stock inference. Let me know!
'''

description_COOPERATIVE_98 = '''
Below is a fully cooperative strategy designed to maximize mutual long-term payoffs by preserving the common pool resource. The strategy uses *conditional cooperation* with forgiveness and clear rules for defect detection and recovery. It also adjusts behavior in the last round to optimize individual payoffs once the future no longer matters.

---

## Strategy Overview

The strategy is a variant of **"Tit-for-Tat with forgiveness tuned for common-pool depletion"** and includes:

1. **Start cooperative**: Cooperate (play C) in the first round.
2. **Observe round outcomes (stock and actions)**: Detect defections based on the observable stock depletion.
3. **Respond by cooperating if no defection detected, defect only if defection detected last round (punishment phase).**
4. **Forgive after one round of punishment, return to cooperation if opponents resume cooperation.**
5. **Last round defect**: Defect in the final round to gain maximum immediate payoff since no future rounds remain.
6. **Edge cases** like heavily depleted stock handled gracefully by cooperation to allow stock recovery.

---

## Rationale

- **Cooperating consumes less per player and sustains the stock longer, yielding stable payoffs over all rounds.**
- **Defection yields short-term gain at the cost of stock depletion:** If everyone defects repeatedly, stock collapses to zero, destroying future payoffs.
- **Tit-for-Tat style response penalizes defectors but is forgiving to allow return to cooperation.**
- **Use observable common stock dynamics to infer defections:** We don't observe actions directly, only stock states after consumption.
- **Final round defecting maximizes last round payoff since there's no risk of retaliation or future consequences.**

---

## Details on Defection Detection

We do not see individual actions, but:

- We know initial stock for each round S_t.
- After actions, total consumption can be inferred (S_t - S_t+1 after adjusting for growth).
- From total consumption, we can reverse infer if players cooperated or defected.

The full stock dynamics equation is:

1. Total_consumed_t = S_t - S_t+1 + growth_t  
   where growth_t = 2 × S_remaining × (1 - S_remaining/capacity), with S_remaining = S_t - total_consumed_t

Since growth depends on S_remaining (which depends circularly on total_consumed), solve for total_consumed numerically or by rearrangement:

   S_t+1 = S_remaining + growth_t  
   = S_remaining + 2 * S_remaining * (1 - S_remaining / capacity)  
   = S_remaining + 2 * S_remaining - 2 * (S_remaining^2) / capacity  
   = 3 * S_remaining - 2 * (S_remaining^2) / capacity

Since S_remaining = S_t - total_consumed_t, with S_t and S_t+1 known, total_consumed_t can be found; then average consumption per player = total_consumed_t / n.

- If average consumption per player ≈ stock/(2n), likely cooperation by all (or at least majority).
- If average consumption closer to stock/n, likely defection happened.

Exact thresholds can be set using tolerance for noise or slight deviations.

---

## Pseudocode of the Strategy for Player i

```python
Parameters:
- n, r, capacity (given)
- tolerance = small positive number for defection detection (e.g. 1% of stock)

Initialize:
- round = 1
- state = "cooperate"  # can be "cooperate", "punish"
- last_total_consumed = None
- last_S = capacity  # initial stock

For each round t in 1 to r:

    If t == r:
        # Last round: defect to maximize payoff (no future rounds)
        action = D

    Else if round == 1:
        # First round cooperate unconditionally
        action = C

    Else:
        # Infer total consumption in last round from stock changes
        # Solve for total_consumed last round numerically:

        # Using symbols:
        # S_t-1 = last_S
        # S_t = current stock before consumption this round (observed from game)

        # Define function f(S_remaining):
        #     return 3*S_remaining - 2*(S_remaining^2)/capacity - S_t
        #
        # Solve f(S_remaining) = 0 for S_remaining in [0, S_t-1]
        # total_consumed = S_t-1 - S_remaining

        total_consumed = infer_total_consumption(last_S, current_S, capacity)

        avg_consumption = total_consumed / n

        # Expected average consumption for all cooperate:
        expected_coop = last_S / (2*n)

        # Expected average consumption for all defect:
        expected_defect = last_S / n

        # Detect defection:
        if avg_consumption > expected_coop + tolerance:
            # Defection detected, switch to punishment
            state = "punish"
        else:
            # No defection or cooperation resumed
            if state == "punish":
                # Forgive if opponents cooperated this round
                state = "cooperate"

        if state == "cooperate":
            action = C
        else:
            # Punish defectors one round by defecting
            action = D

    Make move action

    Record current stock before next round as last_S = observed current stock
    round +=1
```

**Note:** `infer_total_consumption()` is a helper function to solve the quadratic equation implied by:

\[
S_{t} = 3 S_{rem} - \frac{2 S_{rem}^2}{capacity}
\]

Given \( S_t \) and \( S_{t-1} \), solve for \( S_{rem} \in [0, S_{t-1}] \), then compute:

\[
total\_consumed = S_{t-1} - S_{rem}
\]

---

## Behavior Summary

| Situation                   | Action        | Notes                         |
|----------------------------|---------------|-------------------------------|
| Round 1                    | Cooperate (C) | Begin with cooperation        |
| No defection detected       | Cooperate (C) | Encourage sustainable use     |
| Defection detected last round| Defect (D)    | Punish defectors once         |
| Defection ceases            | Cooperate (C) | Forgive and restore trust     |
| Last round (round r)       | Defect (D)    | Exploit max payoff last round |

---

## Advantages

- **Stable cooperation:** Maximizes long-term joint payoffs by sustaining the stock.
- **Responsive:** Detects defection by observing total consumption impact, punishes swiftly.
- **Forgiving:** Does not escalate defection indefinitely; allows return to cooperation.
- **Final round defect:** Rationally exploits last round to maximize personal payoff.
- **Robust:** Uses only game-observable information, no assumptions about signals or communication.

---

# Summary

A cooperative player runs a conditional cooperation strategy:

- Start cooperating.
- Monitor joint stock depletion to detect if others defected.
- If defection detected, punish by defecting once.
- Forgive and cooperate again if others return to cooperation.
- Defect in the last round for maximum individual profit.

This aligns incentives towards cooperative extraction to maintain the resource, maximizes long-run payoffs, is fair and understandable, and strategically punishes selfishness.
'''

description_COOPERATIVE_99 = '''
**Cooperative Strategy for the Common Pool Resource Game**

---

### Design Principles

- **Cooperation (C)** maximizes the sustainable stock level, enabling higher long-term payoffs.
- **Defection (D)** yields higher immediate payoffs but risks depleting the stock, harming all players.
- We must balance **forgiveness** and **punishment** to discourage defectors while allowing returns to cooperation if the other players cooperate.
- Given **perfect information**, we can use observed history of actions to detect defections.
- Without communication or coordination protocols, we rely on observable actions to infer cooperation.
- The game is **finite** with known round count *r*, so endgame effects incentivize defection toward the last rounds. Mitigate this by conditional cooperation until the last round or last few rounds.
  
---

### Strategy Overview: Conditional Cooperation with Trigger Punishment ("Grim with Forgiveness")

- **Start in round 1 with Cooperation.**
- In each round *t* (1 ≤ t < r):
  - Cooperate if all players cooperated in the previous round.
  - Defect if any player defected in the previous round.
- After defecting as punishment, return to cooperation if *all* players cooperated in a round following the punishment.
- In the **last round (round r):**
  - Defect regardless (if you want to maximize immediate payoff), or
  - Cooperate to preserve goodwill if you value group payoff or reputation (up to design choice).

Rationale:

- Trigger punishment deters defection because a single opponent defect triggers a round of punishment where you defect (reducing their future payoffs).
- Forgiveness allows recovery from mistakes or misunderstandings.
- Starting cooperatively establishes trust.
- Cooperation in last round can be chosen to optimize overall group payoff if the tournament pays cumulative payoff (depending on opponent behavior, defecting last round dominates).
  
---

### Detailed Decision Rules

1. **Round 1: Cooperate unconditionally.**

2. **Round t (2 ≤ t < r):**
   
   - If in round t-1 **all** players played C, then *play C*.
   - Else (any player defected in t-1), then *play D* (punishment round).
   
3. **Round t (t > 2) after a punishment round:**

   - If in round t-1 (the punishment round) **all** players played C, then return to *play C* (forgiveness).
   - Else continue to *play D* in round t.

4. **Round r (last round):**  
   - Option 1 (strict cooperative): Play C (to maximize total group payoffs).  
   - Option 2 (selfish): Play D (to maximize own immediate payoff if endgame defecting is better).

   *(Choose Option 1 if valuing cooperation; Option 2 if one-shot-like last round behavior.)*

---

### Pseudocode

```python
# Variables:
# history : list of observed action profiles from round 1 to t-1
#   - Each element is a list of size n of actions ['C' or 'D'], one per player
#   Assume players are indexed i = 0...(n-1), and our own index is player_i

def cooperative_strategy(t, history, player_i, n, r):
    if t == 1:
        # First round: cooperate unconditionally
        return 'C'

    if t == r:
        # Last round strategy; choose between cooperation or defection
        # Option 1: Cooperate
        return 'C'
        # Option 2: Defect
        # return 'D'

    last_round_actions = history[-1]  # actions from round t-1

    # Check if all players cooperated in previous round
    all_cooperated_prev = all(action == 'C' for action in last_round_actions)

    if all_cooperated_prev:
        # No defection last round: cooperate
        return 'C'
    else:
        # Punish defectors by defecting this round
        # Check if last round was punishment round (all cooperated except us)
        if t > 2:
            prev_prev_actions = history[-2]  # actions from round t-2
            all_cooperated_prev_prev = all(action == 'C' for action in prev_prev_actions)
            if all_cooperated_prev_prev:
                # This is first punishment round; defect
                return 'D'
            else:
                # Continue defecting only if last round was also punishment (defection)
                # If last round actions were all C in punishment round, forgive
                # Else continue defecting
                # But since last round had defection (else above), continue defecting
                return 'D'
        else:
            # Second round punishment phase
            return 'D'
```

---

### Explanation of Forgiveness Mechanism

- If players cooperate for multiple rounds, everything remains stable.
- If any player defects in round t-1, all players defect in round t as punishment.
- If everyone cooperates again in round t+1 after punishment round t, we revert to cooperation.
- This avoids permanent breakdown due to single defection or noise.

---

### Why This Strategy Is Cooperative

- It optimizes long-term group payoffs by sustaining the stock.
- Cooperation is the default trust baseline.
- Punishment deters exploitation and enforces incentives for cooperation.
- Forgiveness limits retaliation spiral and allows group to recover.
- Respects perfect information and common knowledge by conditioning solely on observed actions.
  
---

### Edge Cases Handling

- **First round:** No history → cooperate.
- **Last round:** Option to cooperate for collective welfare or defect to maximize immediate gain.
- **If everyone defects from start:** punishment rounds keep defecting, but since everyone defects, no incentive to cooperate alone → expect mutual defection finish.
- **Intermittent defection:** Triggered punishment rounds create strong disincentives for continued defection.
- **Unilateral t-switching:** If only some defect once, punishment rounds force them to pay cost of mutual defection briefly.
  
---

This cooperative strategy balances **long-run sustainability** and **punishment of defections**, making it well suited for tournaments against independent strategies relying on observable behavior.
'''

description_COOPERATIVE_100 = '''
Here is a detailed cooperative strategy designed to sustain cooperation in the Common Pool Resource Game, maximizing long-term collective payoff and stock preservation:

---

### High-Level Intuition

The strategy is a **conditional cooperative trigger strategy** designed for repeated play:

- **Start cooperative:** Cooperate in the first round to signal good faith.
- **Maintain cooperation only if others do:** Continue cooperating as long as every other player cooperated in the previous round.
- **If anyone defects even once, punish by defecting forever:** Defection triggers permanent punishment (defection) to discourage free-riding.
- **Defect in the last round regardless:** In a finitely repeated game, the backward induction argument implies defection in the last round. So, defect in the final round to maximize the immediate payoff.

The rationale is to sustain cooperation as long as possible to preserve the resource and maximize everyone's total payoffs, but also to protect yourself against exploitation by defectors.

---

### Strategy Description

**Notation:**

- Let `t` ∈ {1, ..., r} be the current round.
- Let `actions_{t-1}` be the vector of actions taken by all players in round `t-1`.
- Let `my_action_history` be the vector of this player's past actions.
- Let `n` be the total number of players.

---

### Decision Rules

```plaintext
IF t == 1:
    // First round: start cooperating to signal willingness to cooperate
    action = C

ELSE IF t == r:
    // Last round: defect to maximize one-shot payoff (backward induction)
    action = D

ELSE:
    // From round 2 until round r-1:
    // Check if everyone cooperated in the previous round (including self)
    IF all players played C in round t-1:
        // Continue cooperating to sustain cooperation
        action = C
    ELSE:
        // At least one defector last round → punish by defecting permanently
        action = D
```

---

### Edge Cases

- **First round:** No past history → cooperate unconditionally.
- **Last round:** Knowing that no future retaliation is possible, defect to maximize payoff.
- **If anyone defects even once during game:** Permanently defect on all subsequent rounds to punish and deter defection.
- **If all cooperate always:** Continue cooperating, preserving a sustainable stock and maximizing collective payoff.

---

### Explanation and Cooperative Alignment

- This trigger strategy is a well-known way to enforce cooperation in repeated games with perfect information by threatening punishment.
- By cooperating initially, you give others the opportunity to cooperate.
- By conditioning cooperation on universal cooperation previously observed, you help maintain the common stock.
- By defecting permanently after a defection, you deter exploitation.
- Defecting on the last round is rational and standard in finitely repeated prisoner’s dilemma-like games and does not meaningfully jeopardize cooperation in previous rounds.
- This strategy aligns with cooperative behavior insofar as it promotes *collective resource preservation* and *shared payoff maximization* whenever possible, but protects against selfish exploitation.

---

### Additional Optional Refinements (if implementation complexity allows)

- **Forgiveness variants:** Instead of defecting forever after one defection, defect for a fixed finite number of rounds (e.g., one round) then return to cooperation, to allow for errors or misinterpretations. This is riskier but may sustain cooperation better.
- **Stock-aware cooperation:** If stock level drops below some threshold (e.g., 50% capacity), cooperate even more strictly, never defect even if others defected, to allow stock recovery.

However, the basic trigger strategy above is safer and robust in tournament settings with unknown opponents.

---

# Summary

**Cooperative Trigger Strategy Pseudocode:**

```python
def choose_action(t, r, last_round_actions):
    # t: current round (1-based)
    # r: total rounds
    # last_round_actions: list of actions by all players in round t-1

    if t == 1:
        return 'C'  # Start cooperating
    
    if t == r:
        return 'D'  # Last round defect
    
    # From round 2 to r-1
    if all(a == 'C' for a in last_round_actions):
        return 'C'  # Continue cooperation if last round all cooperated
    else:
        return 'D'  # Punish defection by defecting forever
```

This strategy strongly promotes and enforces cooperation while guarding against exploitation, aligns perfectly with cooperative mindset goals in the common pool resource game.
'''

description_COOPERATIVE_101 = '''
Below is a carefully constructed cooperative strategy for the Common Pool Resource Game, designed to maximize collective payoffs while being robust to possible defections by others. The strategy follows a well-understood cooperative principle ("conditional cooperation") adapted to the specific payoff and stock dynamics of this game.

---

## Strategy Overview

The strategy aims to **sustain the common pool near capacity** by default, thereby **maximizing long-term payoffs for everyone**. Each player:

- **Starts by cooperating** (choosing C) to signal a cooperative intention.
- **Continues cooperating as long as all observed players have cooperated in recent rounds**, preserving the resource.
- **Punishes defection by defecting for a short, fixed "punishment phase"**, deterring free-riding.
- After the punishment phase, **returns to cooperation to allow resource recovery and resumption of cooperation**.
- On the **last round**, defects to maximize immediate payoff (no incentive to conserve for future rounds).

---

## Key Intuition

- Cooperation means consuming **S/(2n)** per person → slower depletion, resource regenerates fast.
- Defection means consuming **S/n** → double consumption per player → faster depletion, lower future payoffs.
- Cooperation sustains a high stock → higher payoffs long-term for all.
- Defection damages stock → hurt own plus others’ future payoffs.
- Punishment deters defection by reducing defectors’ short-term gain and demonstrating consequences.
- Returning to cooperation after punishment allows recovery and resetting cooperation.

---

## Decision Rules

Define variables:

- n: number of players (known)
- r: total rounds (known)
- t: current round number (1-based)
- history: record of all previous rounds' player actions (all known)

Let `punish_until` be a state variable initialised to 0, storing the round number until which this player defects as punishment.

### Action selection for round t:

1. **If t == r (last round):**  
   - Play **D** (defect to maximize one-shot payoff, no future rounds remain).

2. **Else if `punish_until` ≥ t:**  
   - Play **D** (still within punishment phase triggered by defection).

3. **Else (normal operation):**

   - If t == 1:  
     - Play **C** (start by cooperating to build trust and sustain stock).

   - Else t > 1:  
     - Check all players’ actions in round t - 1.  
     - If **all players chose C in previous round**, play **C** (continue cooperating).  
     - Else, **at least one player defected last round**:  
       - Set `punish_until = t + PUNISH_LENGTH - 1` (start punishment phase for PUNISH_LENGTH rounds)  
       - Play **D** for punishment this round.

---

## Punishment Length Parameter

- Choose a short fixed punishment length, e.g., `PUNISH_LENGTH = 2` rounds.  
- Short enough to allow recovery, long enough to deter defection.

---

## Edge Cases

- **First round (t=1):** Cooperate unconditionally because no past behavior to punish.
- **Last round (t=r):** Defect to maximize immediate payoff.
- **Multiple defectors:** The same punishment applies (defect for PUNISH_LENGTH rounds).
- **Recovery from defection:** After punishment finishes, return to cooperation to restore resource.

---

## Pseudocode

```python
# Initialization (run once)
punish_until = 0
PUNISH_LENGTH = 2

def choose_action(t, r, history):
    global punish_until

    # Last round: defect to maximize payoff
    if t == r:
        return 'D'

    # If currently punishing
    if punish_until >= t:
        return 'D'

    # First round: cooperate
    if t == 1:
        return 'C'

    # For t > 1, check previous round actions
    prev_round_actions = history[t - 2]  # zero-based index
    
    if all(action == 'C' for action in prev_round_actions):
        # Everyone cooperated last round → cooperate this round
        return 'C'
    else:
        # Someone defected last round → start punishment
        punish_until = t + PUNISH_LENGTH - 1
        return 'D'
```

---

## Why this is Cooperative

- Cooperation maximizes sustainable stock and payoffs.
- Punishment discourages defection, protecting cooperative players.
- Returning to cooperation after punishment supports mutual recovery and repeated cooperation.
- Defection only on last round maximizes individual payoff without harming common future (none remains).

---

## Summary

This **conditional cooperation with finite punishment and last-round defection** strategy:

- Encourages sustained cooperation to maximize joint payoffs.
- Punishes free-riding defections promptly.
- Allows forgiveness and cooperation resumption post punishment.
- Makes rational last-round defection to maximize final payoff.

It is a natural, clear, enforceable cooperative strategy in a repeated resource consumption setting without communication or coordination tools.
'''

description_COOPERATIVE_102 = '''
Here is a cooperative strategy designed to maximize the common pool stock sustainability and thus the total payoffs over all rounds, while accounting for the lack of communication and the possibility of defections. It leverages conditional cooperation and punishment phases to incentivize cooperation among players.

---

## Cooperative Strategy: "Conditional Cooperative Steward"

### Intuition

- Cooperate as long as all players have cooperated in the previous round, keeping the stock stable or growing.
- If any defections are detected in the previous round, switch to defection in the current round to punish defectors.
- After punishing for one round, revert back to cooperation to give others a chance to return to cooperation.
- In the last round, always defect to maximize immediate payoff since no future punishment is possible and no future rounds remain to preserve the stock.
- This strategy balances cooperation incentives (sustaining stock and high payoffs over time) with retaliatory punishment to discourage unilateral defection.

---

### Detailed Rules

| Round           | Condition/History                                          | Action     | Notes                                            |
|-----------------|------------------------------------------------------------|------------|--------------------------------------------------|
| Round 1 (t=1)   | No history yet                                             | Cooperate  | Start cooperatively to build trust               |
| Middle Rounds   | If **all players cooperated** in previous round (t-1)      | Cooperate  | Sustain stock and maximize group payoff          |
| Middle Rounds   | If **any player defected** in previous round (t-1)          | Defect     | Punish all by defecting once to deter defection  |
| Round after Punishment | After defecting due to punishment round                  | Cooperate  | Forgive and return to cooperation                 |
| Last Round (t=r)| Always Defect                                              | Defect     | No incentive to sustain stock in last round      |

---

### Reasoning

1. **Start Cooperating:** This builds goodwill and stabilizes the stock initially.
2. **Mutual Cooperation Maintains Stock Stability:** Cooperating consumes less per player, allowing the stock to regenerate and maintain a high value through the rounds.
3. **Punish Defection Immediately:** If any player defects, all players defect next round, causing high consumption to punish defectors by reducing stock and making defection less profitable.
4. **Forgiveness:** Punishment lasts one round only to avoid endless defection loops and incentivize returning to cooperation.
5. **Endgame Defection:** On the last round, defecting maximizes immediate payoff since preservation beyond the game has no value.

---

### Pseudocode

```python
# Inputs:
# - history_actions: list of length t-1 of lists of actions by all players,
#   e.g. history_actions[t-1][i] is player i's action in round t (0-based indexing)
# - self_index: index of this player (0-based)
# - current_round: integer t in [1, r]
# - total_rounds: integer r

def conditional_cooperative_steward(history_actions, self_index, current_round, total_rounds):
    # Last round: always defect
    if current_round == total_rounds:
        return 'D'
    
    # First round: cooperate
    if current_round == 1:
        return 'C'
    
    # Check actions in previous round
    prev_round_actions = history_actions[-1]  # actions of all players in round t-1
    
    all_cooperated = all(a == 'C' for a in prev_round_actions)
    
    # If all cooperated previously, cooperate this round
    if all_cooperated:
        return 'C'
    
    # Otherwise, defect this round to punish
    # Check if last round we punished (by defecting) so that 
    # we know whether to forgive this round or keep punishing
    # Retrieve own previous action:
    own_prev_action = prev_round_actions[self_index]
    
    # If last round we defected as punishment, now forgive by cooperating
    if own_prev_action == 'D':
        return 'C'
    
    # Otherwise, defect to punish the defectors
    return 'D'
```

---

### Notes on Robustness and Practical Implications

- **Detection:** Since actions are perfectly observed, defections are obvious, so punishment triggers reliably.
- **No coordination needed:** No explicit communication or signaling; punishment is automatic reaction.
- **Forgiveness avoids endless retaliation:** By forgiving after one round of punishment, players can return to cooperation even if mistakes occur.
- **Endgame defection aligns with equilibrium theory:** No incentive to maintain cooperation when no future rounds remain.
- **Sustains stock over time:** When no defection occurs, the stock stays near capacity, maximizing payoffs.

---

### Summary

| Round          | Condition                                               | Action   |
|----------------|---------------------------------------------------------|----------|
| 1              | First round, no history                                  | Cooperate (C) |
| 2 ≤ t < r - 1  | All players cooperated last round                        | Cooperate (C) |
| 2 ≤ t < r - 1  | Any player defected last round and did not punish last round | Defect (D) - Punish |
| 2 ≤ t < r - 1  | Any player defected last round and **we already punished last round** | Cooperate (C) - Forgive |
| r (last round) | Always defect                                           | Defect (D) |

---

This strategy aligns clearly with a cooperative mindset: preserve the stock with mutual cooperation, punish defections to sustain cooperation, and maximize total payoffs for all players in the long run.
'''

description_COOPERATIVE_103 = '''
Below is a fully cooperative strategy designed to foster and maintain cooperation in the Common Pool Resource game described. It carefully balances the incentive to sustain the resource while guarding against exploitation by defectors. 

---

## Core Idea:  
Use *conditional cooperation* based on prior round observations, aiming to maintain the common pool stock close to capacity by cooperating whenever possible, and punishing defectors temporarily to deter over-exploitation.

---

## 1. Decision Rules: When to Cooperate (C) vs Defect (D)

**Definitions:**
- Let *t* be the current round (1 ≤ t ≤ r).
- Let `stock[t]` be the common pool stock at round *t* start.
- Let `actions[t-1][i]` be the observed action of player *i* in previous round (for t > 1).
- Let `defectors[t-1]` = number of players who defected in round t-1.
- Let `punishment_rounds` be a fixed small integer (e.g., 1 or 2 rounds) during which defection is punished.

---

### First Round (t = 1):
- **Cooperate (C) unconditionally**.
  - Rationale: Without prior info, the best mutual outcome is cooperation to maintain the stock near capacity.

---

### Subsequent Rounds (2 ≤ t < r):
- **If you observed NO defection last round**:
  - Cooperate (C).
- **If you observed defection last round**:
  - Defect (D) for a fixed number of punishment rounds (`punishment_rounds`), then return to cooperate.
  - Punishment targeted at entire group since no player-specific identification possible.
- **If the stock is very low (e.g., ≤ capacity / (2n))**:
  - Cooperate regardless (even while punishing), to avoid collapse.
  
---

### Last Round (t = r):

- **Defect (D) always**.
  - Rationale: Standard backward induction in finite repeated games suggests last-round defection maximizes individual payoffs.
  - However, because all players know this, prior rounds’ cooperation might be fragile — but our strategy does not complicate further.

---

## 2. Edge Cases and Details

- **Stock Observations:**
  - If `stock[t]` drops to zero or near-zero unexpectedly, fallback to cooperation and patience since restocking depends on growth.
- **Punishment Duration:**
  - Example: `punishment_rounds = 2` meaning after observing defection in round t-1, defect in rounds t and t+1, then try cooperation again.
- **Deviation from Cooperation:**
  - Only defect as punishment or in the last round.
- **Memory:**
  - Keep track of how many rounds you are still punishing.
- **No Forgiveness if repeated defection:**
  - Restart punishment if defection detected again after cooperation period.

---

## 3. Cooperative Mindset Alignment

- Trust is rewarded: cooperate if no one defects.
- Defection is punished but punishment is temporary and aimed to restore cooperation.
- Avoid stock collapse by cooperating even in punishment phases if stock very low.
- Last round defect maximizes payoff but strategy tries to build good stock trajectory before then.

---

## 4. Pseudocode

```python
initialize:
    punishment_counter = 0

for t in 1 to r:

    if t == 1:
        # First round, no history
        action = 'C'

    elif t == r:
        # Last round, defect to maximize own payoff
        action = 'D'

    else:
        # Check observations from previous round
        last_round_defectors = count_defectors(actions[t-1])

        # Check stock level threshold
        low_stock_threshold = capacity / (2 * n)

        if stock[t] <= low_stock_threshold:
            # Always cooperate if stock too low to avoid collapse
            action = 'C'
            punishment_counter = 0  # reset punishment with mercy

        else:
            if last_round_defectors == 0:
                # No defection observed -> cooperate
                action = 'C'
                punishment_counter = 0  # reset any punishment

            else:
                # Defection observed in last round
                if punishment_counter > 0:
                    # Continue punishing
                    action = 'D'
                    punishment_counter -= 1
                else:
                    # Start punishment period
                    punishment_counter = punishment_rounds - 1
                    action = 'D'
```

---

## 5. Remarks:

- This strategy reflects a *grim-like trigger with forgiveness*, punishing defectors but returning to cooperation after a short punishment phase.
- It relies solely on observed actions, no signals.
- It balances long-term stock sustainability and short-term incentives, encouraging all players to sustain cooperation to keep payoffs stable and the stock healthy.
- The known last round defection is unavoidable in a finite horizon game with no communication, but cooperation till then maximizes cumulative payoffs for everyone.

---

# Summary:

| Scenario                           | Action                |
|----------------------------------|-----------------------|
| Round 1                         | Cooperate             |
| Subsequent rounds, no defection  | Cooperate             |
| Subsequent rounds, defection observed and punishment not active | Defect (start punishment)     |
| Punishment rounds active          | Defect                |
| Stock very low                   | Cooperate (override)  |
| Last round                      | Defect                |

This strategy is fully cooperative in intent, uses conditional cooperation to discourage defection, mitigates resource collapse, and maximizes the overall long-run payoff given the game structure and constraints.
'''

description_COOPERATIVE_104 = '''
Below is a **cooperative strategy** designed for this Common Pool Resource Game that balances the goal of sustaining the resource stock with maximizing total payoffs across all rounds, while being robust to defection.

---

## Strategy Name: *Conditional Cooperation with Forgiving Trigger*

### Intuition
- Start by cooperating, to maintain the resource and demonstrate cooperation.
- Continue cooperating as long as others do, sustaining the resource near capacity.
- If defections occur, punish by defecting to deter over-extraction.
- After punishment, forgive and return to cooperation to restore cooperation.
- In the last round, defect to maximize individual payoff since future repercussions do not exist.

### Key Points
- Cooperation means consuming **stock/(2n)**.
- Defection means consuming **stock/n**.
- Monitor others’ previous actions.
- Use observed stock dynamics as an indirect signal of defection.
- Use a simple memory of punishment state to decide responses.

---

## Detailed Rules

### Variables Maintained Between Rounds
- `punish`: boolean flag indicating if currently punishing defectors
- `punish_rounds_left`: integer counting remaining rounds to punish after detecting defection (e.g., 1 or 2 rounds)
- `last_actions`: record of all players’ last round actions

### Parameters (can be tuned)
- `punishment_duration = 1` round (length of punishment after detecting defection)

### Step-by-step decision rule at round t:

---

### 1. Initialization (Round 1)
- `punish = False`
- `punish_rounds_left = 0`
- Play **Cooperate (C)**

---

### 2. For rounds t = 2 to r-1 (middle rounds)

#### Observe:

- Actions of all players in round t-1 (`last_actions`)
- Current stock level `S_t`

#### Detect Defection:

- If **any player defected** in t-1 (played D):
  - Set `punish = True`
  - Set `punish_rounds_left = punishment_duration`

- Else if no defections and punishment ongoing:
  - Decrement `punish_rounds_left -= 1`
  - If `punish_rounds_left == 0`, set `punish = False`

#### Decide Action:

- If `punish == True`:
  - Play **Defect (D)**
- Else:
  - Play **Cooperate (C)**

---

### 3. Last Round (t = r)
- Play **Defect (D)**
- Reason: No future rounds, so no incentive to cooperate for future gain

---

## Pseudocode

```
Initialize:
  punish = False
  punish_rounds_left = 0

For rounds t = 1 to r:
  If t == 1:
    action = Cooperate
  Else if t == r:
    action = Defect
  Else:
    If punish:
      action = Defect
      punish_rounds_left -= 1
      If punish_rounds_left == 0:
        punish = False
    Else:
      If any player played Defect in last round:
        punish = True
        punish_rounds_left = punishment_duration
        action = Defect
      Else:
        action = Cooperate

  Execute action
  Observe all players' actions for next round
```

---

## Strategy Features

- **Start cooperative**: Signal peaceful intent and sustainability.
- **Trigger punishment**: Respond immediately to any defection—discourage over-extraction.
- **Forgive after punishment**: Allow return to cooperative state rather than endless retaliation.
- **Last round defection**: Rational choice to extract maximum payoff when no future rounds remain.
- **Simple memory and detection**: Uses clear observable behavior to guide responses.

---

## Discussion

- This strategy fosters mutual cooperation to maintain the resource near capacity, maximizing long-term payoffs.
- Punishment deters defectors by temporarily increasing stock depletion, signaling the cost of non-cooperation.
- Forgiveness prevents deadlock of mutual defection and slow recovery.
- No reliance on communication or coordination beyond observing actions.
- Adaptable for any number of players and rounds as per parameters.
- The last round defection is standard in finitely repeated games where backward induction applies.

---

If all players use this strategy, cooperation will be sustained for most rounds, preserving the resource close to capacity with high payoffs for all. Against non-cooperators, this strategy minimizes being exploited while offering opportunities for cooperation restoration.

---

Please let me know if you want me to elaborate on any part or provide a formal state diagram!
'''

description_COOPERATIVE_105 = '''
Below is a detailed cooperative strategy tailored to the given Common Pool Resource Game. It is designed to sustain cooperation and avoid depletion of the resource through conditional cooperation and punishment phases, inspired by standard repeated game cooperation strategies (like grim trigger or tit-for-tat variants), but adapted to this stochastic and dynamic environment.

---

### Overview of the Cooperative Strategy

**Core idea:**  
Maintain the common pool near or at its maximum sustainable capacity by cooperating (action C) as long as no player defects. Punish defections temporarily by defecting (D) to signal the cost of defection and promote a return to cooperation. In the last round, defect (D) to maximize individual payoff, since no future retaliation is possible.

---

### Intuition and Rationale

- **Cooperate (C) when all have cooperated in the past:** This ensures sustainable resource use, maximal long-run payoffs, and preserves the stock near capacity.
- **Defect (D) conditionally as punishment if any defection detected:** Signal that defection reduces everyone's payoff and threatens future gains, forcing others back to cooperation.
- **Punishment phase limited to one round:** Allows recovery to cooperation, minimizing self-inflicted losses.
- **Defect in last round:** No incentive to keep the resource sustainable after final round.

---

### Notation and Variables

- `round` = current round index (1 to r)
- `n`, `capacity`, `r` as per game parameters
- `history` = full history of all players' actions in previous rounds
- `last_round` = boolean indicator for round == r

---

### Detailed Decision Rules

#### Rule 1: Round 1 (First Round)

- Cooperate (C) unconditionally to start with trust.

#### Rule 2: Rounds 2 to r-1 (Intermediate Rounds)

- Check all players’ actions in the previous round:
  - If **all players cooperated (C)** last round, then **cooperate (C)** this round.
  - If **any player defected (D)** last round, then **defect (D)** this round as punishment.
- After punishing one round due to defection(s), return to cooperation in the following rounds if no further defections occur.

#### Rule 3: Round r (Last Round)

- Defect (D) unconditionally since no future punishment is possible and value gained this round maximizes final payoff.

---

### Handling Multiple or Consecutive Defections

- The above "one-round punishment" rule resets after a punishment round:
  - If defection detected last round → punish once by defecting.
  - If defection detected the round before last, but last round was punishment, **cooperate** unless new defection just occurred.
- This allows forgiving and prevents endless punishment cycles which deplete the resource.

---

### Pseudocode

```python
def cooperative_strategy(round, history, n, r):
    last_round = (round == r)
    
    if round == 1:
        # Start by cooperating
        return 'C'
    
    # Get actions from previous round
    prev_actions = history[round - 2]  # zero-indexed
    
    # Check if any defection in previous round
    defection_last_round = any(a == 'D' for a in prev_actions)
    
    if last_round:
        # Last round: defect unconditionally to maximize payoff
        return 'D'
    
    # If defection last round, punish by defecting this round
    if defection_last_round:
        return 'D'
    
    # If no defection last round, cooperate
    return 'C'
```

---

### Explanation of Cooperation Alignment

- **Mutual cooperation at start:** fosters resource sustainability.
- **Conditional defection only as punishment:** defends against exploitation and enforces cooperation norms.
- **Return to cooperation after punishment:** prevents permanent breakdown.
- **Last-round defection:** maximizes rational payoffs when cooperation can no longer be enforced.
  
This promotes a stable cooperation equilibrium under perfect information repeated game assumptions, balancing incentive-compatible behavior and resource sustainability.

---

### Summary

| Round            | Condition                                | Action   |
|------------------|----------------------------------------|----------|
| 1                | Always                                | Cooperate (C) |
| 2 ... r-1        | If all cooperated last round           | Cooperate (C) |
|                  | If any defected last round              | Defect (D) (punishment round) |
| r (last round)   | Always                                | Defect (D) |

---

This strategy will likely outperform purely defecting strategies by stabilizing the common resource, while deterring exploitation via credible temporary punishment, maximizing total individual payoffs in a multi-round setting.
'''

description_COOPERATIVE_106 = '''
**Cooperative Strategy for the Common Pool Resource Game**

---

### Overview

This strategy aims to maximize long-term collective payoffs by preserving the common pool stock near its sustainable capacity level while punishing defection to discourage over-extraction. The core idea is to:

- Start by cooperating to build trust and maintain the resource.
- Conditionally continue cooperating as long as all players do.
- Detect defections by observing unexpected stock depletion.
- Respond to defection by punishing defectors with a calibrated retaliation phase.
- Forgive and return to cooperation if players resume cooperative behavior.
- In the last round, defect to maximize immediate payoff since future repercussions no longer matter.

---

### Intuition Behind the Strategy

- **Cooperation (C)**: Consume stock/(2n) to maintain sustainable resource regeneration.
- **Defection (D)**: Consuming stock/n yields short-term gain but risks stock depletion.
- Punishment deters defection since defectors cause long-term harm to all.
- Forgiveness allows recovery from errors or occasional defection, avoiding endless mutual punishment.
- Defecting in the last round maximizes immediate gain as there are no future rounds.

---

### Notation

- `t`: current round number (1 ≤ t ≤ r)
- `S_t`: stock at start of round `t`
- `A_t`: profile of all players' actions in round `t` (including myself)
- `C_action` = cooperate
- `D_action` = defect
- `history`: all past rounds' actions and stock
- `punish_rounds`: fixed number of rounds to punish known defection, e.g., 2 rounds

---

### Decision Rules

**1. Initialization (Round 1):**

- Cooperate, setting a cooperative precedent.
- No past defection history exists.

**2. In rounds 2 to r-1:**

- Observe stock trend and actions from previous round(s).
- If all players cooperated last round (expected stock consumption = `n * (S_t-1/(2n)) = S_t-1/2`), expect stock to remain stable or grow.
- If stock is significantly lower than expected under full cooperation, infer that defection occurred (someone played D).
- Enter **punishment phase** if defection detected.
- During punishment phase, defect to punish defectors.
- After punishment phase ends, revert to cooperation assuming forgiveness.
- If no defection detected, continue to cooperate.

**3. Last round (t = r):**

- Defect to maximize immediate payoff since no future repercussions.

---

### Detecting Defection

Calculate expected stock if all cooperated last round:

- `Expected_consumption = S_t-1 / 2`
- `Expected_S_remaining = S_t-1 - Expected_consumption`
- `Expected_growth = 2 × Expected_S_remaining × (1 - Expected_S_remaining / capacity)`
- `Expected_S_t = min(Expected_S_remaining + Expected_growth, capacity)`

If `S_t` (observed stock at round start) is significantly lower than `Expected_S_t` (by some tolerance threshold ε, e.g., 1% of capacity), defection occurred.

---

### Punishment Phase

- Length: fixed, e.g., 2 rounds of defecting.
- Defect each round to reduce defectors' payoff.
- Punishment aims to deter future defection.
- No partial forgiveness during punishment phase.
- After punishment phase, reconcile by resuming cooperation.

---

### Full Pseudocode Description

```pseudo
INPUTS:
    n, r, capacity
    history = list of tuples (S_t, A_t) for t in [1..current_round-1]

PARAMETERS:
    punish_length = 2  # punishment duration in rounds
    tolerance = capacity * 0.01  # tolerance for stock deviation

STATE VARIABLES:
    punishment_rounds_left = 0

FUNCTION decide_action(t, S_t, history):
    IF t == 1:
        # First round: cooperate
        punishment_rounds_left = 0
        RETURN C_action

    IF t == r:
        # Last round: defect to maximize immediate payoff
        RETURN D_action

    # Check if currently punishing
    IF punishment_rounds_left > 0:
        punishment_rounds_left -= 1
        RETURN D_action

    # Otherwise, check for defection last round
    S_prev, A_prev = history[t-2]  # round t-1's stock and actions
    # Count players who cooperated and defected last round
    nC = count of C_action in A_prev
    nD = n - nC

    # Calculate expected stock assuming full cooperation in last round
    # Assume last round was full cooperation for expected stock calculation
    Expected_consumption = S_prev / 2
    S_remaining = S_prev - Expected_consumption
    growth = 2 * S_remaining * (1 - S_remaining / capacity)
    Expected_S = min(S_remaining + growth, capacity)

    # Compare expected stock with actual stock at start of current round t
    IF (Expected_S - S_t) > tolerance:
        # Defection detected — initiate punishment
        punishment_rounds_left = punish_length - 1  # punishment this round + punish_length-1 more rounds
        RETURN D_action

    # No defection detected — cooperate
    RETURN C_action
```

---

### Edge Case Handling

- **First round:** Always cooperate to establish cooperation baseline.
- **Punishment resets if new defection detected during punishment.** (You may either reset punishment counter or ignore to avoid infinite punish cycles; here we keep fixed length.)
- **Stock exactly at zero:** Defection detected, punish.
- **Stock close to zero near last rounds:** Strategy defects anyway in last round.
- **Tolerance exists to avoid reacting to minor fluctuations/noise in stock due to rounding.**

---

### Summary

- **Start cooperating.**
- **Maintain cooperation if stock follows expected growth.**
- **Detect stock drops indicating defection, switch to punishing by defecting for fixed rounds.**
- **After punishment, forgive and return to cooperation.**
- **Defect in last round for maximum payoff.**

This strategy balances cooperation for long-term sustainability with credible punishment to deter selfish exploitation, and forgiveness to avoid deadlocks.

---

If you want, I can provide a more formal algorithm or additional notes on parameter tuning.
'''

description_COOPERATIVE_107 = '''
Here is a cooperative strategy designed to sustain mutual cooperation in the Common Pool Resource Game under the described conditions. It aims to maximize joint payoffs by maintaining the stock near capacity, punishing defections to discourage overconsumption, and forgiving to allow recovery of cooperation.

---

### Core Ideas

- **Cooperation means playing C** (consume stock/(2n))
- **Defection means playing D** (consume stock/n)
- Goal is to maintain sustainable stock at or near capacity to maximize long-run payoffs for all.
- Punish detected defections by switching to defection for some rounds, then return to cooperation.
- Use a forgiving trigger strategy to allow recovery from mistakes.
- Avoid defection in the first round to signal cooperation intent.
- In the last round, exploit if previously defected, otherwise cooperate to maximize final payoffs and reputation (optional - see below).

---

### Strategy Overview

| Round            | Action                                 | Rationale                                      |
|------------------|--------------------------------------|------------------------------------------------|
| Round 1          | Cooperate (C)                        | Signal willingness to cooperate                 |
| Rounds 2 to r-1  | Mostly cooperate, punish defections | Sustain cooperation; punish defections          |
| Round r (last)   | Cooperate unless defected previously | Exhaust cooperation payoff unless punished     |

---

### Decision Rules

Let:

- `r`: total rounds
- `t`: current round (1 ≤ t ≤ r)
- `H_t`: full history of actions of all players up to round t-1
- `defected_players`: set of players detected defecting in previous rounds
- `punishment_rounds`: number of rounds to punish after detecting defection (e.g., 2)
- `punishment_timer_i`: punishment rounds left for player i (initially 0)
- `S_t`: observed stock level at start of round t (known since perfect information)
- `capacity`: max stock

---

### Detecting Defection

- In round t, observe each player j's action in round t-1.
- If j played D (defect) in t-1, mark player j as defected.
- Start punishment for player j (set `punishment_timer_j = punishment_rounds`).

---

### Punishment

- While `punishment_timer_i > 0`, defect to punish player i.
- If multiple players punishable, defect to punish all simultaneously by defecting yourself.
- After punishment rounds end, return to cooperate.

---

### Stock-based nuance

- If stock is very low (e.g., below threshold α × capacity, where α could be 0.25 or 0.3), defect to accelerate punishment and to avoid stock collapse from exploitation.
- Else, cooperate to sustain stock near capacity.

---

### Pseudocode

```
Initialize:
  punishment_rounds = 2
  punishment_timer = array of zeros indexed by player i
  defected_players = empty set

For t = 1 to r:
  if t == 1:
    action = C  # cooperate unconditionally round 1

  else:
    # Update punishment timers
    For each player i:
      if punishment_timer[i] > 0:
        punishment_timer[i] -= 1

    # Detect defections in previous round
    For each player i:
      if player_i_played_D_in_round(t-1) and punishment_timer[i] == 0:
        punishment_timer[i] = punishment_rounds

    # Decide action
    # If currently punish any player (any punishment_timer[i] > 0), then defect
    if exists i with punishment_timer[i] > 0:
      action = D

    else:
      # Check stock threshold
      if S_t < 0.3 * capacity:
        # Stock low, defect to avoid being exploited and accelerate recovery
        action = D
      else:
        # Stock healthy, cooperate to maintain resource
        action = C

  # Special case: last round t == r
  if t == r:
    # If currently defecting for punishment, keep defecting (to punish last)
    # Else cooperate to maximize last payoff 
    if exists i with punishment_timer[i] > 0:
      action = D
    else:
      action = C

  Play action
```

---

### Explanation

- **Round 1 cooperation** immediately signals readiness to preserve the resource.
- **Punishment** deters defectors by lowering your payoff through defection for some rounds, which also reduces their future payoffs by depleting stock less than if you cooperated.
- **Forgiveness** after punishment allows the system to heal, supporting renewed cooperation.
- **Stock threshold defection** prevents spiral into collapse by defecting when stock is critically low, signaling to others that exploitation risk is non-negligible (a form of "grim trigger" softening).
- **Last round cooperation** ensures maximal joint payoffs when cooperation has held; defect if punishing to enforce consequences.

---

### Why this is Cooperative

- Willing to cooperate initially and whenever no defections are detected.
- Provides clear, observable consequences to deter defections.
- Forgives after punishment to allow return to cooperative equilibrium.
- Avoids unnecessary defection that destroys resource and overall payoffs.
- Uses observable stock as a feedback signal to adjust behavior dynamically.

---

### Edge Cases

- **All players cooperate**: stock cycles near capacity, maximum payoffs sustained.
- **One or more defect early**: punishments triggered, reducing defectors’ incentives.
- **Stock collapses to zero**: subsequent rounds defect to accelerate punishment and exploit scarce resource cautiously.
- **Last round**: cooperate if no punishment ongoing to get last-round cooperative payoff; defect otherwise to enforce punishment.

---

This strategy is a form of **trigger + forgiveness + adaptive cooperation** tailored to the state-dependent common pool resource environment, promoting sustainable cooperative behavior despite incentives to defect.

---

If you want, I can help formulate a more formal mathematical summary or extend the strategy for mixed/covert defections. Would you like me to do that?
'''

description_COOPERATIVE_108 = '''
**Cooperative Strategy for the Common Pool Resource Game**

---

### Strategy Overview

The goal is to sustain the common pool resource close to its maximum sustainable capacity (i.e., `capacity`) by cooperating (consuming moderately) as long as others do the same, ensuring high total long-term payoffs for all. Defections (overconsumption) deplete the resource and should be punished to discourage unsustainable behavior. Given the repeated nature, perfect information, and observability of past actions, the strategy uses conditional cooperation based on players’ past behavior.

---

### 1. Decision Rules: When to Cooperate vs Defect?

**Basic principle**:  
- Cooperate (`C`) by default and remain in cooperation as long as no significant deviation (defection) is detected from others.  
- Defect (`D`) only to punish detected defections, then promptly return to cooperation if opponents do.

---

### 2. Handling Edge Cases: First round, Last round, Near-last round

- **First round**: Cooperate unconditionally. No history exists to infer others' intentions, and cooperation sets the foundation for mutual trust.

- **Intermediate rounds (2 to r-1)**:  
    - Cooperate if all players cooperated in previous round (or no evidence of defection).  
    - Defect to punish if any player defected in previous round. Punishment is limited to *one round* to avoid spirals of destruction and to enable return to cooperation.

- **Last round (round r)**:  
    - Defection incentive is highest (no future punishment or reward).  
    - Still, cooperate in last round as a sign of consistent cooperation (and to avoid mutual destruction), but defect only if the opponent defected in previous round (responding to defection one last time).  
    - (Optional: Since it’s the final round, some may defect unconditionally; pure cooperation here is a "nice" signal, but defending defection is also reasonable.)

---

### 3. Cooperative Alignment

- Maintain the resource at sustainable levels by avoiding overconsumption (defection) unless punishing defectors.
- Use **"Grim Trigger Lite"**: Only defect for one round after detecting defection, then forgive.
- This approach favors sustained cooperation with minimal costly punishment.
- Encourage mutual cooperation by signaling willingness to cooperate first and forgiving after punishment.

---

### Pseudocode (for player i at round t):

```python
# Parameters and game state inputs:
# n, r, capacity, current_round = t
# history_actions: list of tuples of all players' actions in previous rounds
#   - history_actions[t'] = list of actions of all players at round t'
#   - e.g. history_actions[t-1][j] is action of player j at round t-1
# current_stock (S) is observed before deciding actions for round t

def choose_action(t, history_actions, player_index, n, r, capacity):

    # Round 1: cooperate unconditionally
    if t == 1:
        return 'C'

    # Function to check if any defection happened last round
    def any_defection_last_round(actions_last_round):
        # Defection = 'D'
        return any(a == 'D' for a in actions_last_round)

    # Function to check if player i defected last round
    def player_defected_last_round(actions_last_round, player_index):
        return actions_last_round[player_index - 1] == 'D'

    # Previous round actions
    prev_actions = history_actions[t - 2]  # because index starts at 0

    # Detect if any player defected in last round
    defectors = [j+1 for j,a in enumerate(prev_actions) if a == 'D']
    defected_last_round = len(defectors) > 0

    # Decision logic

    if t == r:
        # Last round: cooperate if no defection last round, else defect only if defected against
        if defected_last_round:
            # Defect only if self was defected against last round
            if player_index in defectors:
                return 'D'
            else:
                return 'C'
        else:
            return 'C'

    else:
        # Intermediate rounds (2 <= t <= r-1)

        if not defected_last_round:
            # No defection last round = cooperate
            return 'C'

        else:
            # Defection(s) detected last round -> punish only one round: defect now
            # Then plan to revert to cooperation next round

            # Check if the player already defected in the previous round
            # To avoid chaining defections, cooperate if self defected in prev round and punishment round is ending
            self_defected_prev_round = player_defected_last_round(prev_actions, player_index)

            if self_defected_prev_round:
                # We defected last round as punishment, so forgive now
                return 'C'
            else:
                # Punish defectors by defecting now
                return 'D'
```

---

### Explanation of the Logic

- **Start cooperating.**  
- If no defection observed previously, continue cooperating to keep the resource stable and payoffs high.

- **If defection detected, punish by defecting once next round.**  
- After punishment round, forgive and return to cooperation unless a new defection occurs.

- **Last round behavior** tries to sustain cooperation but retaliates if defected against immediately prior to last round.

---

### Why This Strategy is Cooperative and Rational?

- **Sustains resource:** By cooperating when others cooperate, the resource replenishes near capacity, maximizing total payoffs.

- **Punishes defections fairly:** Punishment avoids free riding by defectors, discouraging depletion of resource.

- **Forgiving to avoid destructive wars:** Only one-round punishment followed by forgiveness limits payoff loss from prolonged mutual defection.

- **First round sets cooperative baseline:** Easy, trust-building start.

- **Last round nuanced:** Recognizes endgame incentives but still favors cooperation to avoid mutual destruction.

---

### Notes / Limitations

- Cannot assume opponents share this strategy, so risk of exploitation exists.

- Complexity is low, suitable for tournament environments with no communication.

- Strategy benefits from perfect information to detect defections accurately.

---

If implemented in the tournament, this strategy should yield high collective payoffs by stabilizing resource usage and minimizing depletion.
'''

description_COOPERATIVE_109 = '''
Here is a cooperative strategy designed to sustain high common stock and maximize long-term payoffs by fostering mutual cooperation, while having a clear conditional punishment to discourage defection. It is designed for repeated play with perfect monitoring and no communication.

---

## Strategy Name: **Conditional Cooperation with Forgiveness**

---

### Intuition

- **Start fully cooperative** to signal willingness to sustain common resources.
- **Continue cooperating as long as no defectors are observed**, preserving the resource stock and maximizing joint payout.
- **If any defection is detected, punish by defecting once to deter exploitation.**
- **Then forgive and return to cooperation, allowing recovery and restoring trust.**
- The **last round is special**: defect to maximize final payoff since no future punishment is possible.

This is a form of a *trigger strategy* with a single-period punishment and forgiveness.

---

### Detailed Decision Rules

At round \( t \in \{1, 2, \ldots, r\} \), player \( i \) observes the full history of actions by all players in all previous rounds (except current round which is simultaneous).

**Define:**

- \( H^{t-1} \) = history of past action profiles (all players' actions in rounds \(1\) to \(t-1\)).
- \( DefectedInLastRound \) = Boolean flag indicating if any player defected in round \( t-1 \).
- \( PunishFlag \) = Boolean flag indicating whether player \( i \) is currently in punishment mode.

---

### Initialization

- \( PunishFlag \leftarrow \text{False} \) initially.

---

### Round \( t = 1 \)

- Play **Cooperate (C)**.

---

### Round \( 2 \leq t \leq r-1 \)

1. Check actions from round \( t-1 \):
    - If *any* player defected (\(D\)) in round \( t-1 \), then set \( PunishFlag \leftarrow \text{True} \).
    - Else if \( PunishFlag = \text{True} \) (we are in punishment mode), then reset \( PunishFlag \leftarrow \text{False} \).

2. Decision based on \( PunishFlag \):
    - If \( PunishFlag = \text{True} \), **Defect (D)** this round (punishment).
    - Else, **Cooperate (C)**.

---

### Round \( t = r \) (Last round)

- Defect (D) regardless of history (final round defection is standard in finitely repeated games for maximizing final payoff).

---

### Summary of Logic in Pseudocode

```python
def strategy(t, r, history, n):
    # history: list of tuples of length t-1, each tuple length n with values {"C", "D"}
    # Returns action: "C" or "D"
    
    # Persistent state variable needed across rounds:
    # punish_flag: global boolean
    
    if t == 1:
        punish_flag = False
        return "C"
    
    # Check if anyone defected in previous round
    if "D" in history[t-2]:  # zero-indexed, t-2 is previous round
        punish_flag = True
    
    else:
        if punish_flag:
            punish_flag = False
            
    if t == r:
        return "D"  # last round defection
    
    if punish_flag:
        return "D"  # punishment round
    
    return "C"  # cooperate if no defection detected and not punished
```

---

### Explanation of Strategy Properties

- **Cooperation as default:** By cooperating initially and whenever no defection occurs, players maintain a high stock level, supporting sustainable high payoffs \( \pi_i \).
  
- **Punishment reduces incentive to defect:** If anyone defects, immediate retaliation via a single defect round reduces incentives to defect since it lowers the defector’s future payoff by reducing stock growth and invokes a direct payoff hit the round after defection.

- **Forgiveness allows recovery:** By limiting punishment to one round, the strategy avoids endless mutual defection and allows restoral of cooperation to rebuild the common stock.

- **Final round defection maximizes individual payoff:** Since there's no future punishment after round \( r \), defecting last round gives the highest immediate payoff without risk.

---

### Handling Edge Cases

- **First round:** Always cooperate—signals commitment to cooperation.
- **Last round:** Always defect for individual maximum gain.
- **Single defector:** Punish once in the next round, then forgive.
- **Multiple defectors or repeated defectors:** The one-shot punishment per defection maintains a credible deterrent without permanent breakdown.
- **Stock dynamics:** By cooperating, the stock remains at or near capacity, ensuring payoffs are maximized over time.

---

### Assumptions and Limitations

- Requires memory to track if any defection occurred last round.
- Requires perfect monitoring of all players' actions.
- No attempt to identify or single out specific defectors—punishes all by defecting.
- May be exploited by strategies that defect in the last round without consequence.

---

### Potential Extensions (if allowed)

- Track individual defection to punish defectors selectively.
- More sophisticated punishment length to deter serial defectors.
- Titrate cooperation levels based on stock health.

---

# Summary

The **Conditional Cooperation with Forgiveness** strategy fosters sustained cooperation by cooperating unless defected against, punishing defectors exactly once, then resuming cooperation, maximizing joint payoffs and legacy of stock health, with rational defection in the final round to extract maximum last-round benefit.
'''

description_COOPERATIVE_110 = '''
Here is a strategy designed to be cooperative, fostering sustainable use of the common pool resource and maximizing joint payoffs over repeated rounds.

---

## Strategy Overview: "Conditional Cooperation with Forgiveness and Endgame Defection"

### Core Intuition
- **Cooperate** by default to sustain the resource and maximize long-term payoffs.
- **Punish defections** by defecting in the next round to discourage exploitation.
- **Forgive occasional defections** to allow recovery and avoid endless retaliation cycles.
- **Defect in the last round(s)** since no future punishment/incentive possible, capture remaining resource.

---

## Detailed Decision Rules

### Key Variables and Observations per round t (1 ≤ t ≤ r)
- **S_t:** Stock available at the start of round t (common knowledge).
- **History:** Actions of all players in rounds 1 to t-1.
- **Defections by others in previous round (t-1):** Count of players who defected in round t-1.

---

### Initialization (Round 1)
- At round 1, **cooperate (C)** unconditionally.
- Reason: No prior history, assume cooperative norm to build trust.

---

### Rounds 2 to r-2 (Interior rounds)
At each round t (2 ≤ t ≤ r-2):

1. **Check opponent actions in previous round (t-1):**
   - If **no defectors** in t-1, **cooperate (C)**.
   - If **one defector or a small number (≤ threshold)**:
     - Defect (D) in this round as punishment.
     - But mark a flag `punished = True`.
   - If `punished = True` from previous round (i.e., you defected as punishment last round), then:
     - Forgive by cooperating (C) this round regardless of others' actions.
     - Reset `punished = False`.
   - If multiple defectors (more than threshold), defect continually until cooperation returns.

2. **Threshold for forgiveness:** 1 defector per round  
   (If only one player defects, punish once but forgive quickly. If many defect, treat as breakdown of cooperation.)

---

### Round r-1 (Penultimate round)
- If stock S_r-1 is healthy (> capacity/2):
  - Cooperate (C), holding to cooperative principle.
- If stock is critically low (≤ capacity/2):
  - Defect to claim some payoff before possible depletion.
- Retain forgiveness rule to repair cooperation if possible.

---

### Round r (Last round)
- Defect (D) unconditionally.
- Reason: No future rounds to punish or reward cooperation, so maximize own payoff by defecting.

---

## Summary of Behavior

| Round     | Condition                     | Action       |
|-----------|------------------------------|--------------|
| t = 1     | No history                   | Cooperate (C)|
| 2 ≤ t ≤ r-2 | No defection in t-1          | Cooperate (C)|
| 2 ≤ t ≤ r-2 | One defection in t-1         | Defect (D) once, then forgive next round |
| 2 ≤ t ≤ r-2 | More than one defector in t-1| Defect until cooperation returns        |
| t = r-1   | Stock healthy (> capacity/2) | Cooperate (C)|
| t = r-1   | Stock low (≤ capacity/2)      | Defect (D)   |
| t = r     | Last round                   | Defect (D)   |

---

## Pseudocode

```python
class CooperativeStrategy:
    def __init__(self, n, r, capacity):
        self.n = n
        self.r = r
        self.capacity = capacity
        self.punished = False  # Track if we just punished last round

    def decide(self, t, S_t, history):
        # history: list of tuples/lists of all players' actions per round
        # actions indexed 0..n-1, own index known or treat symmetrically?
        # Assume we know our player index self.i, not strictly necessary here though
        
        if t == 1:
            # Round 1: start cooperating
            return 'C'
        
        if t == self.r:
            # Last round: defect to maximize payoffs
            return 'D'
        
        if t == self.r - 1:
            # Penultimate round: defect if stock low, else cooperate
            if S_t <= self.capacity / 2:
                return 'D'
            else:
                return 'C'

        # For rounds 2 to r-2
        last_round_actions = history[t-2]  # since t indexed from 1, history from 0

        # Count defectors excluding self (if self is known)
        # If self index unknown, count all players defecting
        defectors = sum(1 for a in last_round_actions if a == 'D')

        # Threshold for tolerance
        DEFECTOR_THRESHOLD = 1

        if self.punished:
            # Forgive this round, cooperate regardless
            self.punished = False
            return 'C'

        if defectors == 0:
            # No defection last round, cooperate
            return 'C'
        elif defectors <= DEFECTOR_THRESHOLD:
            # Punish defectors this round
            self.punished = True
            return 'D'
        else:
            # Multiple defectors, defect to punish until cooperation returns
            return 'D'
```

---

## Rationale and Alignment with Cooperation

- Starts cooperatively to build trust.
- Detects and punishes unilateral defection but forgives quickly to allow return to cooperation.
- Long-term cooperation stabilizes stock near high levels, maximizing joint and individual payoffs.
- Defects only when necessary to prevent exploitation or at endgame when incentives to cooperate disappear.
- Responsive to the number of defectors to adapt punishment severity.
- Uses observable history (perfect monitoring) as basis for decisions.
- Avoids retaliation wars by forgiving after one punishment.
- Improves sustainability and fairness amid temptation to free-ride.

---

## Limitations and Considerations

- Cannot enforce cooperation alone if others all defect.
- Relies on others responding similarly—if others are permanently defecting, this strategy punishes them but loses stock.
- Forgiveness helps prevent endless defections, but if opponents repeatedly defect, cooperation breaks down.
- Endgame defection follows backward induction but may reduce total payoff if others also defect early.

---

This strategy balances the incentive to cooperate with the need for punishment to enforce cooperation, aligned with common-pool resource sustainability and repeated game logic.
'''

description_COOPERATIVE_111 = '''
Here is a cooperative strategy carefully designed to sustain cooperation in this repeated common pool resource game. It aims to promote mutual cooperation, maintain the resource near capacity, and discourage defection by punishing it—but also allows forgiveness to restore cooperation if defection was a one-time event or mistake.

---

### Intuition and High-Level Description:

- **Goal:** Maintain the common pool stock near capacity by all players cooperating (all choosing C) every round except the last.
- **Why cooperate?** Cooperation consumes less from the stock, enabling its regrowth and maximizing sustainable total payoffs.
- **Punishment for defection:** If any defection is observed (any player choosing D), punish all defectors by defecting in the next round to reduce their payoff, but revert to cooperation afterward.
- **Forgiveness:** Avoid endless retaliation; after punishing for one round, try to return to cooperation to restore the commons.
- **Last round behavior:** Since no future rounds exist for punishment and cooperation has no future benefit, defect to extract immediate payoff (defect is dominant in last round).

---

### Key elements of the strategy:

- **Start cooperative:** Round 1 choose C.
- **If previous round had full cooperation by all, continue cooperating.**
- **If any defection detected last round:**
  - Punish by defecting once if you previously cooperated.
  - Otherwise, resume cooperation.
- **On the last round (round r), always defect.**

---

### Formal description:

Define:
- `current_round` ∈ {1,...,r}
- `history` = all past rounds' action profiles of all players
- `my_last_action` ∈ {C,D}
- `any_defection_last_round` = True if any player chose D last round, else False

---

### Pseudocode:

```python
def cooperative_strategy(current_round, r, n, capacity, history, my_last_action):

    # On the last round: defect to maximize immediate payoff
    if current_round == r:
        return 'D'

    # On first round: cooperate unconditionally
    if current_round == 1:
        return 'C'

    # Analyze previous round actions
    last_round_actions = history[-1]  # list of length n, actions 'C' or 'D'
    any_defection_last_round = ('D' in last_round_actions)

    # If last round was full cooperation: continue cooperating
    if not any_defection_last_round:
        return 'C'

    # If there was defection last round:
    # Punishment phase: defect once if you cooperated last round
    # Then forgive and cooperate again

    # If I cooperated in last round and someone defected -> defect now as punishment
    if any_defection_last_round and my_last_action == 'C':
        return 'D'

    # Otherwise, cooperate (forgive)
    return 'C'
```

---

### Explanation:

- **Rounds 1..r-1:** Sustain cooperation, except immediately punishing defectors for one round.
- **Last round:** Defect, because no future rounds exist to enforce cooperation, making defection individually rational.
- **Punishment logic:** If you cooperated but others defected, defect once to punish.
- **Forgiveness:** If you defected already last round or punished last round, revert to cooperation to prevent endless retaliation.
- **Benefits:** This strategy forms a *trigger-and-forgive* pattern, encouraging mutual cooperation to keep the stock high and payoffs sustainable.

---

### Why is this cooperative?

- Cooperation is the default behavior.
- Defection only used as a short, mild punishment, not as a norm.
- Forgiveness avoids collapse into permanent defection.
- High common stock is maintained, benefiting all players over the repeated game.
- Players unincentivized to defect early because punishment reduces future payoffs.

---

### Edge cases:

- **First round:** No history, cooperate to establish norm.
- **Last round:** Defect since no incentive to cooperate; no future punishment possible.
- **If multiple defectors:** punishment still applies, and defectors lose out on future cooperation benefits.
- **If defect occurs sporadically / by mistake:** forgiveness phase quickly restores cooperation.
- **If everyone defects from the start:** punishment is irrelevant, but our strategy still tries cooperating initially to catalyze cooperation.

---

### Summary:

| Round              | Condition                      | Action      | Purpose                                      |
|--------------------|-------------------------------|-------------|----------------------------------------------|
| 1                  | No history                    | Cooperate   | Initiate cooperation anchor                  |
| 2..r-1             | Last round all cooperated     | Cooperate   | Sustain cooperative growth                    |
| 2..r-1             | Last round defected, I cooperated | Defect      | Punish defectors immediately                   |
| 2..r-1             | Last round defected, I defected | Cooperate   | Forgive, restore cooperation                  |
| r (last round)      | Always                       | Defect      | Maximize last-round payoff                    |

---

This strategy is a straightforward, principled cooperative approach aligned with standard repeated game theory concepts (e.g., Grim Trigger with forgiveness and last-round defection). It aligns well with the common pool resource game dynamics and incentivizes others to cooperate for joint long-term benefit.
'''

description_COOPERATIVE_112 = '''
Here is a carefully designed cooperative strategy for the repeated Common Pool Resource Game. The goal is to sustain the common stock near capacity over rounds while securing stable, reasonably high payoffs for all players through mutual cooperation.

---

### Strategy Name: **Sustained Cooperation with Trigger Punishment**

---

### Intuition and Goal

- Start cooperatively to maintain the resource.
- Keep stock near capacity for high long-term payoffs.
- Punish defectors immediately and temporarily by defecting in the next round only.
- Forgive after one-round punishment to allow return to cooperation.
- Defect in the very last round to maximize individual payoff since no future rounds remain.
  
---

### Decision Rules

Let:

- `t` = current round index (1-based, t ∈ {1,...,r})
- `S_t` = stock level at start of round t
- `history` = record of all players' actions in all prior rounds
- `actions_{t-1}` = vector of all players' actions in previous round (empty for t=1)
- `my_last_action` = this player's action in the previous round (undefined for t=1)
- `defected_last_round` = Boolean, true if any player defected in previous round, else false
- `punishment_mode` = Boolean flag that this player sets to know whether to punish defectors this round (defaults false)

---

### Action Selection at round t

1. **First round (t = 1):**

   - **Action:** Cooperate (C) unconditionally.
   - **Reason:** Establish a cooperative baseline, maintain stock at capacity.

2. **Rounds 2 to r-1:**

   a. **Check if previous round had defection by any player:**

   - If any player defected in round `t-1`, enter `punishment_mode` this round.
   - Else, remain in cooperation mode.

   b. **If `punishment_mode` is true (meaning last round someone defected):**
   
   - Defect (D) to punish defectors immediately.
   - After this punishment round, revert `punishment_mode` to false (forgive).

   c. **If `punishment_mode` is false (no defection last round):**
   
   - Cooperate (C) to maintain the resource.

3. **Last round (t = r):**

   - Defect (D) unconditionally.
   - **Reason:** No future rounds to maintain cooperation; defect to maximize last-round payoff.

---

### Edge Cases and Notes

- **First round:** No history to react to, so cooperate to set a cooperative tone.
- **Transition from punishment:** Only punish defectors for one round, then forgive to allow re-cooperation.
- **Multiple defectors:** Same one-round punishment regardless of how many defected.
- **Stock depletion:** Since cooperation consumes less and regeneration favors higher stocks, cooperation maintains the stock near capacity.
- **Increased defection:** If opponents continually defect, this strategy will punish every time, but only for one round after seeing a defection, so it encourages opponents to return to cooperation.
- **No signaling or explicit communication:** This strategy relies solely on observed past actions.
- **Cannot identify which player defected:** Punish everyone equitably by defecting one round after any defection.
- **Player index irrelevant:** Strategy is symmetric; same rules apply to all.

---

### Pseudocode

```python
def cooperative_strategy(t, r, history, capacity, n):
    """
    t: current round index (1-based)
    r: total rounds
    history: list of tuples/lists of length t-1, each containing n actions 'C' or 'D'
    capacity, n: game parameters, mainly for bookkeeping (not strictly needed)

    Returns: action 'C' or 'D' for round t
    """

    if t == 1:
        # First round: cooperate
        return 'C'

    # Check previous round actions
    last_round_actions = history[-1]  # list of actions by all players at round t-1

    # Detect if any defection occurred last round
    defected_last_round = any(action == 'D' for action in last_round_actions)

    # Maintain a persistent punishment mode stored externally or inferred.
    # Since no state can be kept, implement punishment as defect only once 
    # immediately after a defection was detected in the previous round.
    # This means if last round defected => punish now; else cooperate.

    if t == r:
        # Last round: defect unconditionally
        return 'D'

    if defected_last_round:
        # Punish defectors by defecting now
        return 'D'

    # Otherwise, cooperate
    return 'C'
```

---

### Why is this Cooperative?

- It starts from cooperation and aims to keep the stock stable near capacity by everyone cooperating.
- It responds to defection by defecting only once as a punishment, maintaining an incentive to cooperate again soon after.
- It fosters reciprocal cooperation: mutual cooperation yields sustainable payoffs and avoids stock collapse.
- It is forgiving: allows others to return to cooperation after punishment.
- Defection only happens as contingent punishment or in the last round, where defection can't harm future cooperation.
- Balanced: not naïvely forgiving (which would be exploited), nor permanently punitive (which would degrade cooperation forever).

---

### Summary

- **Round 1:** Cooperate.
- **Rounds 2 to r-1:** If anyone defected last round, defect (punishment), else cooperate.
- **Round r:** Defect unconditionally.

This strategy promotes sustained, mutual cooperation and stable resource management, securing high payoffs for all who cooperate. It punishes defections just enough to deter exploitation but forgives quickly to allow cooperative recovery.

---

If you want, I can help you with a more complex or adaptive variation, but this version should perform well in tournaments where cooperation can be mutually beneficial.
'''

description_COOPERATIVE_113 = '''
Here is a fully cooperative strategy for the Common Pool Resource Game, designed to maximize the sustained value of the common stock and total payoff, while being robust to unilateral deviations by opponents:

---

### Intuition and Key Points

- **Mutual cooperation (all play C)** maximizes long-term stock and sustainable payoffs.
- The common pool regenerates best when total consumption is low (cooperation).
- Defection (D) yields higher immediate payoff but depletes stock faster, harming everyone long-term.
- The strategy **starts cooperating**, punishes detected defection to discourage free-riding, but returns to cooperation to allow recovery.
- In the **last round**, since stock dynamics no longer matter, the strategy defects to maximize immediate payoff—standard backward induction logic.
- The strategy uses publicly observable past actions (players' round actions) for detection.

---

### Strategy Description

**Parameters used internally:**

- `n`: number of players
- `r`: total rounds
- `t`: current round (1-based)
- `capacity`: maximum sustainable stock (≥ 2n)
- `stock_t`: observed stock at start of round t (or calculated via history)
- `actions_t-1`: vector of all players’ actions in previous round (for t > 1)
- `defection_detected`: boolean flag if any defection detected in last round

---

### Decision Rules

**Round 1:**

- Play **Cooperate (C)** unconditionally.

**Rounds 2 to r-1:**

- If any player defected in the previous round, **punish by defecting in this round** (play D).
  - Punishment is a 1-round "grim trigger" — just one round of defection to penalize free-riding.
- Otherwise, **cooperate (C)**.

**Round r (last round):**

- Play **Defect (D)** unconditionally to maximize last round payoff.

---

### Reasoning

- Cooperation is the default to ensure sustainable harvesting.
- Defection is punished immediately next round by defecting once, which reduces incentives for defection.
- Punishment uses only public info from last round actions, no assumptions about coordination or communication.
- The punishment being only one round allows the group to recover quickly and get back to cooperation.
- The last round defection is classical backward induction because no future penalties exist.
- Stock dynamics and payoffs make cooperating in early rounds beneficial for all, given rational players.
- If all use this strategy, the group will mostly cooperate, maximizing payoffs and resource sustainability.
- If others defect, short punishment limits damage and signals willingness to cooperate again.

---

### Pseudocode

```python
# Inputs per round:
# t: current round (1-based)
# r: total number of rounds
# history_actions: list of action vectors from previous rounds, each vector length n
# For round 1, history_actions is empty

def cooperative_strategy(t, r, n, capacity, history_actions):
    # Round 1: cooperate
    if t == 1:
        return 'C'

    # Detect defection in last round
    last_round_actions = history_actions[-1]  # length n

    # Defection = action 'D'
    defection_detected = any(a == 'D' for a in last_round_actions)

    # Last round: defect unconditionally
    if t == r:
        return 'D'

    # If defection detected last round, punish this round by defecting once
    if defection_detected:
        return 'D'

    # Otherwise, cooperate
    return 'C'
```

---

### Additional Notes

- **Stock estimation:** Although not strictly needed, the strategy can infer stock after each round by applying the formula with observed consumption if desired, but it acts solely on past actions because perfect stock info might be noisy or unavailable.
- **Multiple defections:** Strategy only punishes 1 round after any defection, no escalating punishments to avoid collapse of cooperation.
- **No forgiveness delay:** Immediate resumption of cooperation after punishment supports stability.
- **Assumes observability of all players' actions in previous rounds**, as per problem description.
- **Rationale for Defect last round:** With no future rounds, future cooperation or punishment has no effect, so rationally defect.

---

### Summary

| Situation                   | Action           |
|----------------------------|------------------|
| Round 1                    | Cooperate (C)    |
| Round 2 to r-1             | Defect (D) if anyone defected last round, else Cooperate (C) |
| Round r (last round)       | Defect (D)       |

This strategy promotes sustainable cooperation long enough to keep the common stock healthy, punishes defectors briefly to discourage exploitation, and maximizes final-round payoff when no future incentives remain.

---

If you want, I can help draft variants with more complex forgiveness or probabilistic punishment, but this is a clean, transparent, and widely recommended cooperative approach for common pool resource repeated games under your specification.
'''

description_COOPERATIVE_114 = '''
Here's a carefully designed **Cooperative Strategy** for the Common Pool Resource Game that aims to sustain cooperation, preserve the resource stock, and maximize collective payoffs over the repeated rounds.

---

# Cooperative Strategy: "Conditional Long-term Cooperation with Forgiveness"

## Intuition and Rationale

- **Goal:** Maintain the common pool near its sustainable maximum (capacity) to maximize long-term payoffs.
- **Cooperation:** Consume the minimal quota (C) to keep the stock healthy.
- **Defection:** Temporarily punish potential defectors by defecting if they defected in the past.
- **Forgiveness:** After punishment, return to cooperation to allow recovery and re-establish trust.
- **Endgame:** In the very last round, defect to maximize immediate payoff since no future rounds remain.
- **First round:** Start cooperatively to signal willingness.
- **Dynamic response:** Punish only observed defections, and forgive after punishment to avoid endless downward spiral.

---

## Decision Rules in Detail

### Notation

- Let `t` index the current round, where `1 <= t <= r`.
- Let `A_j,t` be the action player j chose in round t.
- You are player `i`.
- Let `defectedLastRound` be a boolean indicating if any other player defected in round `t-1`.
- The "punishment phase" lasts for exactly 1 round after detecting defections.
- Maximize total payoff by cooperating whenever possible to sustain stock, defecting only as a credible but temporary punishment.

---

### Pseudocode

```python
# Strategy state variable
punishmentActive = False  # tracks whether currently in punishment phase

for t in range(1, r+1):

    if t == 1:
        # First round: Cooperate to initiate mutual cooperation
        action = 'C'
        punishmentActive = False
      
    elif t == r:
        # Last round: Defect (D) to maximize immediate payoff; no future rounds to consider
        action = 'D'
      
    else:
        # Intermediate rounds: Condition on previous actions
        
        # Check if any player defected in previous round
        defectedLastRound = any(A_j,t-1 == 'D' for j != i)
        
        if punishmentActive:
            # Already punishing last round's defection, now forgive and return to cooperation
            action = 'C'
            punishmentActive = False
            
        else:
            if defectedLastRound:
                # Detected defection last round, punish by defecting this round
                action = 'D'
                punishmentActive = True  # punishment lasts for only 1 round
            else:
                # No defection detected, cooperate to maintain stock
                action = 'C'
```

---

## Explanation of Behavior

- **Round 1:** Always cooperate; establishes cooperative baseline and preserves stock from start.
- **Rounds 2 to r-1:** 
  - If opponents cooperated last round, cooperate again.
  - If any opponent defected last round, defect once as punishment.
  - Then immediately return to cooperation, showing forgiveness.
- **Round r (last round):** Defect to maximize final individual payoff since no future punishment is possible.

---

## Handling Edge Cases and Notes

- **Multiple defections:** Punishment duration is fixed at 1 round per detected defection round, avoiding escalating cycles of defection.
- **Simultaneous defection detection:** Since all actions are observed perfectly, this coordination of punishment and forgiveness is stable.
- **Stock-dependent adaptation:** The strategy does not directly condition on stock level, trusting that mutual cooperation sustains stock near capacity.
- **No coordination device needed:** Autonomous and deterministic based solely on observable past actions.
- **If the stock is severely depleted:** Still cooperate (unless punishing) to help stock recovery through natural growth.
- **Rationale for forgiveness:** Avoids permanent defection spiral, increases total group payoff.
- **No exploitation:** Does not exploit defectors beyond one punishment round, avoiding major collapse of cooperation.

---

## Strategic Summary

| Round       | Condition                                   | Action | Notes                          |
|-------------|---------------------------------------------|--------|--------------------------------|
| 1           | Initial                                    | C      | Signal cooperation             |
| 2 to r - 1  | Opponents cooperated last round            | C      | Maintain sustainable use       |
| 2 to r - 1  | Opponent defected last round & not punished| D      | Punish defect once             |
| 2 to r - 1  | Currently in punishment phase               | C      | Forgive and return to cooperation |
| r (last)    | Always                                    | D      | Maximize last-round payoff     |

---

# Summary

This **Conditional Long-term Cooperation with Forgiveness** strategy:

- Starts by cooperating.
- Punishes defection quickly and briefly.
- Returns to cooperation to preserve sustainability.
- Defects only in last round aloud.
- Relies only on observable actions.
- Maximizes collective payoffs through sustained cooperation.

It is a *simple, yet robust* cooperative strategy for the repeated common pool resource game.
'''

description_COOPERATIVE_115 = '''
Below is a carefully designed cooperative strategy for the described Common Pool Resource Game. It embraces cooperation to sustain the resource over repeated rounds while being cautious about exploitation by defectors. The strategy uses conditional cooperation, punishes defections temporarily, and adapts in the last round.

---

### Cooperative Strategy: "Sustained Conditional Cooperation with Last-Round Adjustment"

#### Intuition and Goals

- **Primary Goal:** Maintain the common pool stock near capacity (or at a high level) across rounds to maximize long-term collective payoff.
- **Cooperation Baseline:** By cooperating (consuming stock/(2n)), each player takes no more than half the individual share of the common pool, supporting stock sustainability and growth.
- **Defection Punishment:** If others defect, defecting yourself to avoid being exploited, but only temporarily.
- **Forgiveness:** After a one-round punishment, return to cooperation if others do.
- **Last Round:** Since future rounds do not exist, defect to maximize individual payoff.

---

### Strategy Description

We define the following terms:

- `round`: current round number (1 to r)
- `actions_history`: list of tuples of previous round actions of all players, e.g. [(C, D, C), (C, C, C), ...]
- `last_round`: round == r

---

### Decision Rules

**1. Round 1:**

- **Action:** Cooperate (C)
- **Reason:** Establish cooperative baseline; no previous defections.

**2. Rounds 2 to r-1:**

- Examine opponents' actions in the immediately preceding round.
- **If all other players cooperated in the last round:**  
  - Cooperate (C) this round to sustain cooperation.
- **If at least one opponent defected in the last round:**
  - **If you defected in the last round (i.e., currently punishing):**  
    - Cooperate (C) this round to forgive and return to cooperation.
  - **Else (you cooperated last round, others defected):**  
    - Defect (D) this round to punish defectors and avoid exploitation.

This rule implements a *"grim trigger" with forgiveness after one round* pattern—a deterrent and a path to restore cooperation.

**3. Round r (Last Round):**

- Defect (D) unconditionally.
- **Reason:** No future rounds to influence; maximize immediate payoff.

---

### Pseudocode

```python
def cooperative_strategy(round, r, n, actions_history):
    # round: int, current round number (1-based)
    # r: int, total rounds
    # n: int, number of players
    # actions_history: list of tuples (prev round actions for all n players)
    # Each action in {'C', 'D'}

    # Last round: always defect
    if round == r:
        return 'D'

    # First round: cooperate
    if round == 1:
        return 'C'

    # From round 2 to r-1:
    prev_actions = actions_history[-1]  # actions in round (round - 1)
    my_prev_action = prev_actions[my_index]  # assume strategy knows own player index

    opponents_prev = [act for i, act in enumerate(prev_actions) if i != my_index]

    # If everyone cooperated last round
    if all(act == 'C' for act in opponents_prev):
        return 'C'

    # If at least one opponent defected last round
    if my_prev_action == 'D':
        # We were punishing last round; now forgive and cooperate
        return 'C'
    else:
        # Opponents defected last round, we cooperated => defect to punish
        return 'D'
```

---

### Notes and Justifications

- **Cooperation as default:** The strategy promotes cooperation unless provoked.
- **One-round punishment:** Defects immediately after detecting defection to deter exploitation.
- **Forgiveness after one round:** Avoids endless mutual defection, allows return to cooperation.
- **Unconditional defection on last round:** Standard backward induction for finite repeated games.
- **Perfect Information Use:** Uses full observable history to condition decisions.
- **No assumptions about others’ strategy:** Only reacts based on observed actions; robust to arbitrary opponent behavior.

---

### Summary

| Round       | Condition                               | Action                  |
|-------------|----------------------------------------|-------------------------|
| 1           | N/A                                    | Cooperate (C)           |
| 2 to r-1    | All others cooperated previous round   | Cooperate (C)           |
| 2 to r-1    | Some opponents defected previous round | Defect (D) if cooperator last round; else Cooperate (C) to forgive |
| r (last)    | N/A                                    | Defect (D)              |

---

This strategy fosters long-term cooperation by balancing cooperation and punishment, focusing on sustaining the resource and maximizing collective payoff unless exploitation occurs. It handles edge rounds explicitly and does not rely on communication or coordination beyond observable actions.
'''

description_COOPERATIVE_116 = '''
Below is a carefully designed **Cooperative Strategy** tailored for the Common Pool Resource Game as specified. It leverages the publicly observed history of actions and stock levels, and sticks to a cooperative mindset to sustain the resource with maximal group payoff over the repeated rounds.

---

## Intuition / Rationale

- **Baseline cooperation:** Always prefer to cooperate (C) by consuming less stock per round.
- **Monitoring others:** Since all actions are observed, detect defection (D) by others.
- **Punishment:** If defection is detected, respond with temporary punishment (defect) to discourage free-riding.
- **Forgiveness:** After punishment lasts one round, attempt return to cooperation to restore resource.
- **Stock level awareness:** Never defect if stock is very low—cooperation helps preserve remaining stock.
- **Last round:** Defect in the last round since no future rounds reward cooperation.
- **First round:** Cooperate to start with a good precedent.

---

## Detailed Strategy Description

### Variables and Inputs Available per round `t`

- `t` = current round (1-based)
- `r` = total rounds
- `n` = number of players
- `capacity` = max sustainable stock
- `S_t` = common pool stock at start of round `t` (known)
- `history` = complete history of actions for all players in rounds `1` to `t-1`
- Own player index: `i`
- Observations:
  - Actions of all players in previous rounds, including self.
  - Stock level dynamics imply we can infer total consumption last round.

---

### Notation

- `actions_t[j]` = action of player `j` in round `t` (C or D)
- `defectors_in_last_round` = players who played D in round `t-1`

---

### Decision Rules

#### 1. First round (t == 1)
- **Action:** Cooperate (C)
- **Reason:** Start on cooperative path, demonstrating trust.

#### 2. Last round (t == r)
- **Action:** Defect (D)
- **Reason:** No future rounds => no incentive to cooperate; maximize immediate payoff.

#### 3. Intermediate rounds (1 < t < r)

##### Detect defection in previous round(s)

- Identify if any other player defected (`D`) in round `t-1`.
- Maintain a **punishment memory:** if detected defection last round, punish in this round by defecting once.
- After a single round punishment, forgive and return to cooperation if no new defections.

##### Main rule

- If you are currently punishing (i.e., round `t-1` you punished due to detected defection), then cooperate unless defection continues.
- Otherwise, cooperate.

##### Stock threshold consideration

- Define a **critical stock threshold** = `0.5 * capacity`
- If current stock `S_t` is below threshold, then regardless of punishment, **always cooperate** to conserve the resource.

---

### Pseudocode

```python
def cooperative_strategy(t, r, n, capacity, S_t, history, i):
    # Constants
    CRIT_THRESHOLD = 0.5 * capacity

    # Helper: find if others defected last round
    def others_defected_last_round():
        if t == 1:
            return False  # no history yet
        last_round_actions = history[t-1]  # indexing rounds 1-based
        for j in range(1, n+1):
            if j != i and last_round_actions[j] == 'D':
                return True
        return False

    # Helper: find if self punished last round
    def self_punished_last_round():
        if t <= 2:
            return False
        # if in round t-1 we defected as punishment because of defection in t-2
        # Check if last round we defected but no defection detected in t-2
        prev_round_actions = history[t-1]
        prev_prev_round_actions = history[t-2] if t>2 else None
        # punish only lasts one round, so simple check:
        return (prev_round_actions[i] == 'D')

    # 1. First round - cooperate
    if t == 1:
        return 'C'

    # 2. Last round - defect
    if t == r:
        return 'D'

    # 3. Intermediate rounds

    # If stock is below threshold, cooperate to conserve resource
    if S_t < CRIT_THRESHOLD:
        return 'C'

    # If defection detected last round by others, punish this round
    if others_defected_last_round():
        return 'D'

    # Otherwise, cooperate
    return 'C'
```

---

## Summary

| Round      | Condition                                | Action       |
|------------|------------------------------------------|--------------|
| t = 1      | First round                             | Cooperate (C) |
| t = r      | Last round                              | Defect (D)    |
| 1 < t < r  | Stock below 50% capacity                | Cooperate (C) |
| 1 < t < r  | Defection detected in t-1 by others    | Defect (D)    |
| Otherwise  | Default                                | Cooperate (C) |

---

### Why is this cooperative?

- The default default action is cooperation, conserving resource and maximizing group payoff.
- Detect defection and respond with a swift one-round punishment, incentivizing others not to defect repeatedly.
- Forgiveness after one punishment round supports return to cooperation, avoiding endless retaliation.
- Protect resource when stock is low by cooperating despite punishments.
- Defecting only in last round where cooperation brings no future benefit.
- No assumptions about others’ strategies beyond observed actions – strategy is robust to temptation but rewards cooperation.

---

If implemented by all players, this strategy should sustain the common pool at a healthy level, maximize collective and individual payoffs, and deter free-riding via conditional punishment.
'''

description_COOPERATIVE_117 = '''
Below is a cooperative strategy tailored to the given common pool resource game, relying on observed history of other players’ actions and the resulting stock dynamics to encourage mutual cooperation and sustainable resource use. The strategy aims to sustain cooperation as long as possible to maximize total payoffs and avoid resource collapse, while having a clear, forgiving punishment to handle defection.

---

## Cooperative Strategy: **Conditional Sustained Cooperation with Forgiving Punishment**

### Intuition

- **Cooperate (C)** as long as everyone else cooperates and the stock remains healthy (close to capacity).
- **Defect (D)** only as a temporary punishment when others defect to enforce cooperation.
- **Return to cooperation** quickly after punishment if conditions improve.
- **Sustain cooperation until near the end**, then defect in the last round(s) to maximize end payoff since no future punishment will follow.

---

### Terminology / Observables

- Let round be indexed by t ∈ {1,...,r}
- Let S_t be the common pool stock at the start of round t
- Let actions_i,t be player i’s action in round t
- Let actions_all,t be the vector of all players’ actions in round t
- Let Defectors_t = {players j | actions_j,t = D} at round t

---

### Decision Rules by Round

#### Round 1 (t=1):

- Cooperate (C)
- Rationale: Start with full trust to establish cooperation baseline and maximize initial stock.

#### Intermediate Rounds (2 ≤ t ≤ r-2):

- **If in all previous rounds** (1,...,t-1), all players cooperated (i.e., no defections detected), and 
  - Current stock S_t ≥ 0.8 × capacity (meaning the stock is sufficiently healthy),  
  THEN  
  → Cooperate (C)

- ELSE IF defections observed in previous round (Defectors_{t-1} ≠ ∅),  
  THEN  
  → Defect (D) *once* as punishment (punishment round)

- ELSE IF we are currently in a punishment phase (i.e., own last action was D in response to past defection),  
  THEN  
  → Cooperate (C) to forgive and return to cooperation

- ELSE IF stock S_t < 0.5 × capacity (stock is dangerously depleted),  
  THEN  
  → Cooperate (C) regardless (to allow stock to recover),  
  but be prepared to punish if defection continues

- ELSE  
  → Cooperate (C)

#### Second-to-last round (t = r-1):

- Cooperate (C) irrespective of history  
- Rationale: Preserve cooperation to maintain stock for final round payoff

#### Last round (t = r):

- Defect (D) to maximize individual payoff, since no future retaliation possible

---

### Additional Notes

- **Punishment is a single round of defection** aimed at signaling disapproval and encouraging return to cooperation.
- The stock threshold values (0.8 and 0.5 times capacity) serve as heuristics to detect whether the resource is healthy or depleted.
- Players continue to cooperate even when stock is low, to promote recovery.
- The player only defects in response to observation of defection in the *immediately previous* round, maintaining forgiveness and avoiding endless punishment cycles.
- Defection in the last round extracts maximum payoff as no incentive to maintain cooperation remains.

---

### Pseudocode

```python
def cooperative_strategy(t, r, S_t, capacity, history):
    # history: list of dicts for past rounds with keys: 'actions' (list of length n)
    # own index: assumed known as i
    
    if t == 1:
        # First round: cooperate
        return 'C'

    elif t == r:
        # Last round: defect to maximize payoff
        return 'D'

    elif t == r - 1:
        # Second last round: cooperate to sustain stock for last round
        return 'C'

    else:
        # Check past cooperation
        all_coop = all(
            all(action == 'C' for action in round_info['actions'])
            for round_info in history
        )

        # Check if defection happened in immediately previous round
        prev_round = history[-1]
        defection_last_round = any(action == 'D' for action in prev_round['actions'] if action is not None)
        
        # Check if currently in punishment phase: 
        # i defected last round as punishment?
        own_last_action = history[-1]['actions'][i-1]  # assuming player index i (1-based)
        in_punishment_phase = (own_last_action == 'D')
        
        # Stock thresholds
        high_stock_threshold = 0.8 * capacity
        low_stock_threshold = 0.5 * capacity
        
        if all_coop and S_t >= high_stock_threshold:
            # Everyone cooperated, stock is healthy
            return 'C'
        
        if defection_last_round:
            # Punish once to enforce cooperation
            return 'D'
        
        if in_punishment_phase:
            # Forgive and return to cooperation
            return 'C'
        
        if S_t < low_stock_threshold:
            # Stock is low but cooperate to help recovery
            return 'C'
        
        # Default to cooperate
        return 'C'
```

---

## Summary

| Round       | Condition                          | Action   | Rationale                        |
|-------------|----------------------------------|----------|---------------------------------|
| 1           | Always                          | Cooperate | Establish trust                 |
| 2 to r-2    | No defection in history & stock healthy | Cooperate | Sustained cooperation         |
| 2 to r-2    | Defection detected in prev round  | Defect   | Punish defectors once           |
| 2 to r-2    | In punishment phase               | Cooperate | Forgive and move on             |
| 2 to r-2    | Stock low (<50% capacity)          | Cooperate | Promote recovery                |
| r-1         | Any                             | Cooperate | Prepare stock for last round    |
| r           | Any                             | Defect   | Maximize final round payoff     |

---

This cooperative strategy prioritizes mutual sustainability by sustaining cooperation when possible, punishing defection firmly but briefly, forgiving promptly to restore cooperation, and capitalizing on the final round to maximize gains without harming future interactions.

It is simple to implement, relies only on observable actions and stock levels, and aligns tightly with the cooperative ethos demanded.
'''

description_COOPERATIVE_118 = '''
Below is a cooperative strategy designed to maximize the sustainability and joint payoffs in the Common Pool Resource Game under the given assumptions and constraints.

---

## Strategy Overview

This strategy adopts a **trigger-style conditional cooperation with a forgiving mechanism** designed to:

- **Start cooperatively** to build trust and maximize long-run joint payoffs.
- **Maintain cooperation** as long as no defection (over-consumption) is detected.
- **Punish defection** by defecting for a limited number of rounds to discourage free-riding.
- **Forgive and return to cooperation** if opponents revert to cooperation, promoting recovery.
- **Adapt behavior at the last round**, maximizing final payoff knowing no future retaliation is possible.

---

## Intuition

- Cooperation means choosing the **C action (consume stock/(2n))**, preserving the stock and yielding moderate payoffs.
- Defection means choosing the **D action (consume stock/n))**, yielding higher immediate payoffs but damaging the common stock.
- By cooperating, the stock remains high, allowing for sustainable growth and higher total payoffs over multiple rounds.
- Detecting defections is possible by observing the effective total consumption and stock changes.
- Retaliation deters defections but must be limited and forgiving to avoid long-term collapse.
- Final round defecting maximizes terminal payoff without risk of retaliation.

---

## Detailed Decision Rules

### Notation

- `round` ∈ {1...r}: current round index
- `S`: current stock at start of round (observed)
- `actions_history[t]`: vector of all players' actions in round t, for t < round
- `my_last_action`: own action in previous round
- `defect_detected`: boolean flag indicating whether defection was detected from others since last cooperation
- `punish_rounds_left`: counter for how many rounds left to punish defections
- Parameters:
  - `PUNISH_LENGTH`: fixed number of rounds to punish after detection (e.g., 2)
  - `SAFE_MARGIN`: fraction near capacity to consider "safe" for cooperation (e.g., 0.8)

### Initialization

- `defect_detected = false`
- `punish_rounds_left = 0`

### At each round (pseudocode)

```pseudo
if round == r:
    # Final round: defect to maximize payoff (no future retaliation)
    action = D
    return action

if punish_rounds_left > 0:
    # Punishment phase: defect to penalize defector(s)
    action = D
    punish_rounds_left -= 1
    # Check if all players returned to cooperation to forgive early (optional)
    if round > 1 and all other players cooperated last round:
        punish_rounds_left = 0
    return action

if round == 1:
    # Initial cooperation to start trust-building
    action = C
    return action

# From round >= 2: Monitor others' actions for defection
others_actions = actions_history[round-1] excluding own last action
num_defectors = count of D in others_actions

# Detect defection:
# Defection = number of D > 0 OR total consumption > expected at full cooperation
expected_total_c = n * (S / (2 * n)) = S/2    # if all cooperate
actual_total_c = calculate from previous round's stock change:
    prev_stock = stock at round-1
    consumption = prev_stock - (stock after consumption)
    # Alternatively infer from number of defectors and last round stock
# Since all info available, a simpler test:
if num_defectors > 0:
    defect_detected = true
else:
    defect_detected = false

if defect_detected:
    # Begin punishment phase to penalize defectors
    punish_rounds_left = PUNISH_LENGTH
    action = D    # retaliate by defecting
    punish_rounds_left -= 1
    return action

# No defection detected, stock is safe?
if S >= SAFE_MARGIN * capacity:
    # Stock is healthy, continue cooperating
    action = C
else:
    # Stock is low, cautionary cooperation to restore stock or defect if stock very low
    if S < n:  # very low stock, cooperation won't help
        action = D
    else:
        action = C

return action
```

---

## Summary of Behavior

| Round           | Condition                                 | Action      | Rationale                                   |
|-----------------|-------------------------------------------|-------------|---------------------------------------------|
| 1 (initial)     | Always                                   | Cooperate (C) | Start with cooperation to establish trust   |
| Intermediate    | No defections detected                   | Cooperate (C) | Maintain sustainable harvest                 |
| Intermediate    | Defection detected (any player defects) | Defect (D) for `PUNISH_LENGTH` rounds | Retaliate to discipline defectors            |
| Punishment phase| Opponents return to cooperation early   | Return to cooperation early | Encourage cooperation and forgiveness       |
| Stock low       | Stock drops below threshold              | Cooperate (C) or defect (D) if very low stock | Try to restore stock or maximize last payoffs  |
| Last round (r)  | Always                                   | Defect (D)  | Maximize final payoff since no future rounds|

---

## Cooperation Mindset Alignment

- **Starts by cooperating**, signaling willingness to share resources.
- **Detects and punishes defection** firmly but finitely, discouraging selfish behavior.
- **Forgives and resumes cooperation** once others conform, promoting long-term joint benefit.
- **Maintains stock sustainability** by cooperating when stock is sufficient, preventing tragedy of the commons.
- **Adapts behavior pragmatically** when stock is very low or at the final round, balancing cooperation with self-interest.
- **Only uses publicly available information**; no communication or assumptions about norms.
- **Balances incentives for cooperation and deterrents for defection** to stabilize cooperative outcomes.

---

## Parameter Suggestions

- `PUNISH_LENGTH = 2` (punish defectors for two rounds before forgiving)
- `SAFE_MARGIN = 0.8` (consider stock above 80% capacity safe for cooperation)
- Thresholds can be tuned based on game length and number of players.

---

# Summary

This cooperative strategy uses a **conditional cooperation with limited punishment and forgiveness** mechanism aimed at sustaining the resource stock and maximizing collective payoffs over repeated rounds, while defending against exploitation by defectors. It leverages perfect information to monitor others' actions and applies game-theoretic logic to balance cooperation and self-interest throughout the gameplay.
'''

description_COOPERATIVE_119 = '''
Below is a fully cooperative strategy for this common pool resource game. The goal of the strategy is to maximize long-run collective and individual payoffs by maintaining the stock near capacity to preserve sustainable yields, while punishing defection only mildly to avoid rapid stock collapse.

---

## Strategy Overview and Rationale

- **Core Cooperative Principle:**  
  Always cooperate to sustain the resource unless there is clear evidence one or more opponents are defecting repeatedly. Cooperation means playing **C**, i.e., consuming stock/(2n).

- **Incentive to Cooperate:**  
  Cooperating maintains stock levels close to capacity, yielding a stable long-run payoff of approximately `capacity/(2n)` each round.

- **Punishment for Defection:**  
  Upon detecting defection (any player defecting in the previous round), punish by defecting once to discourage defection but immediately return to cooperation if defection stops. This mild punishment balances deterrence against destructive retaliation cycles.

- **Last Round Behavior:**  
  On the last round, defect to maximize immediate payoff since there is no future to protect.

---

## Detailed Decision Rules

### Initialization

- Round 1: Cooperate (C) unconditionally (establish cooperative precedent).

---

### At Each Round t (1 < t < r):

1. **Observe all players' actions in round (t-1).**  
2. **If round (t-1) = 1** or if **no player defected in round (t-1),** play C.  
3. **Else if any player defected in round (t-1),** play D once as mild punishment.  
4. At round t+1, regardless of past defection, return to cooperative play C unless defection continues.

---

### Last Round (t = r):

- Defect (D) to maximize immediate payoff, since no future repercussions.

---

## Summary of Logic

| Condition                              | Action at round t        |
|--------------------------------------|-------------------------|
| t = 1                                | Cooperate (C)           |
| t = r (last round)                   | Defect (D)              |
| Any player defected at t-1?           | Defect (D) (punishment) |
| Otherwise                           | Cooperate (C)           |

---

## Pseudocode

```python
def cooperative_strategy(t, r, history):
    # history is a list of previous rounds actions for all players:
    # history[t-1] = [a_1, a_2, ..., a_n], where a_i in {C, D}
    
    if t == 1:
        return 'C'  # Start cooperative
    
    if t == r:
        return 'D'  # Last round, defect for single-round gain
    
    # Check if any player defected in previous round
    previous_actions = history[t-2]  # zero-based index
    if 'D' in previous_actions:
        # Punish defection once
        return 'D'
    
    # Otherwise cooperate
    return 'C'
```

---

## Why This Strategy?

- **Encourages Cooperation:** Starts cooperative and continues as long as opponents reciprocate.  
- **Mild Punishment:** One-shot defect punishment deters repeated defection while avoiding irreversible stock depletion or endless mutual defection.  
- **Predictable and Transparent:** Opponents can infer our pattern and choose to cooperate for mutual benefit.  
- **Exploits Last Round:** Defects in the final round to maximize final payoff, consistent with backward induction logic.  
- **Robustness:** Does not rely on communication or complex signaling beyond observing past actions.

---

## Notes on Possible Dynamics

- If all players use this strategy, cooperation is stable, the resource stays near capacity, and each player earns roughly `capacity/(2n)` every round except last round when they get `capacity/n`.  
- If some defect repeatedly, the punishing defections reduce their incentives to continue defecting.  
- Because punishment is mild and forgiving, the stock is less likely to collapse than with harsh punishments.  
- This approach balances sustainability and payoff maximization.

---

This completes the design of the cooperative strategy for the given common pool resource game.
'''

description_COOPERATIVE_120 = '''
Below is a carefully designed cooperative strategy for the given Common Pool Resource Game. The strategy aims to maintain the resource sustainably, maximize joint payoffs over repeated rounds, and deter unilateral defection.

---

## Cooperative Crescent Strategy

**Principle:**  
Start fully cooperative, maintain cooperation as long as others cooperate, and respond swiftly but forgivingly to defections to restore cooperation. In the last round, defect to maximize individual payoff since there is no future to protect.

---

### 1. Decision Rules

- **Round 1:** Cooperate (play C).
- **Rounds 2 to r–1 (Middle rounds):**  
  - **If no defection detected in the previous round (all cooperated):** Cooperate (C).  
  - **If any defection detected in the previous round:** Defect (D) once as punishment, then return to cooperate in the following round if the opponent(s) revert to cooperation.  
- **Round r (Last round):** Defect (D), since there is no incentive to sustain the common pool any more.

---

### 2. Detecting Defection

- Observe actions of all players in the previous round.
- Defection is detected if any player took action D instead of C.

---

### 3. Handling Edge Cases

- **First round:** No history → start cooperative to build trust.
- **Last round:** Defect because no future rounds remain to justify cooperation.
- **Single defection:** Punish by defecting once in the next round, then forgive and return to cooperation if others cooperate.
- **Repeated defections:** Keep defecting if others continue to defect.
- **Stock near depletion:** Cooperation helps recovery; defecting when stock is low is short-sighted unless it's the last round.
- **Stock observed replenishment or high stock:** Maintain cooperation for higher joint payoffs.

---

### 4. Rationale / Cooperative Mindset

- **Mutual cooperation yields sustainable stock and steady payoffs (~S/(2n) each).**
- **Unilateral defection gains short term payoff but depletes stock, reducing future payoffs for everyone including the defector.**
- **Tit-for-tat with forgiveness incentivizes cooperation by rewarding cooperation and punishing defection without spiraling into permanent conflict.**
- **In the last round, defecting maximizes payoff because future punishments are impossible.**

---

### 5. Pseudocode

```python
def cooperative_crescent_strategy(round_number, total_rounds, previous_actions, capacity, current_stock):
    """
    Parameters:
      round_number (int): Current round index (1-based)
      total_rounds (int): Total number of rounds r
      previous_actions (list of list): Each sublist contains all players' actions in previous round, e.g. ['C', 'D', 'C', 'C']
                                       Empty for round 1.
      capacity (float): Maximum stock capacity
      current_stock (float): Stock at start of current round
    
    Returns:
      action (str): 'C' or 'D'
    """

    # Last round defect
    if round_number == total_rounds:
        return 'D'

    # First round: cooperate
    if round_number == 1:
        return 'C'

    # Check for defection in previous round
    defection_occurred = any(action == 'D' for action in previous_actions)

    # History of own previous actions is not accessible in spec; assume cooperation by default unless defecting to punish.

    # Simple memory: if any defection last round, punish once by defecting this round
    # However, since we have only current round data, consider a stateful approach:
    #
    # Implement a forgiving tit-for-tat:
    # If defection last round -> defect this round (punish)
    # Else -> cooperate

    # To implement forgiveness, we need state: For simplicity, assume strategy remembers if punished last round
    # But requirement is just specifying strategy logic, so can say:

    # Strategy:
    # If defection in previous round:
    #    If last round we punished already, cooperate now (forgiveness)
    #    Else defect now (punishment)
    #
    # Without explicit memory handling, assume a pure tit-for-tat with one-step punishment.

    # Since cumulative history is known, infer if we punished last round by checking our own previous action.
    # But per the problem spec, we can only rely on last round observed actions and game parameters.
    # We can maintain internal state: e.g. boolean "punished_last_round"

    # Below is a conceptual representation considering internal state (not implementable in pure memoryless).

    # For illustration:
    if defection_occurred:
        # Punish by defecting this round
        return 'D'
    else:
        # Cooperate if no defection detected last round
        return 'C'

```

---

### 6. Summary

| Round         | Condition                                     | Action   |
|---------------|-----------------------------------------------|----------|
| 1             | No history                                    | Cooperate (C) |
| 2 to r–1      | No defection last round                        | Cooperate (C) |
| 2 to r–1      | Defection detected last round                  | Defect (D) to punish |
| 2 to r–1      | Next round after punishing (forgiveness step) | Cooperate (C) unless defections recur |
| r (Last round)| Any                                            | Defect (D) |

---

This cooperative strategy balances sustainability, deterrence, and forgiveness to maximize collective payoffs while protecting the common pool resource through repeated interaction constraints.
'''

description_COOPERATIVE_121 = '''
Here is a cooperative strategy for the Common Pool Resource Game that aims to sustain the resource while maximizing joint payoffs, assuming all players start with a willingness to cooperate but face temptation to defect. The strategy uses a form of *trigger strategy with forgiveness* adapted to the structure of this game:

---

## Strategy Name: *Conditional Sustained Cooperation with Forgiveness*

### Intuition / High-Level Description
- Start by cooperating (C) to maintain the resource at sustainable levels.
- Continue cooperating as long as **no player defects unilaterally** (i.e., as long as total consumption matches full cooperation).
- If one or more players defect, defect in the next round as punishment (to discourage defection).
- However, if cooperation resumes immediately in the round after punishment (all players cooperate), forgive and return to cooperation.
- In the very last round, defect to maximize immediate payoff (since future consequences disappear).
- This strategy aims to maintain cooperation through credible punishment but also allow for recovery (forgiveness).

---

### Detailed Decision Rules

Let:
- \( t \) = current round number, \( 1 \leq t \leq r \)
- \( S_t \) = stock at start of round \( t \)
- \( A_j(t) \) = action of player \( j \) in round \( t \)
- \( A_i(t) \) = our own action in round \( t \)
- \( P_t \) = indicator whether *punishment round* \( t \) (our strategy defects)
- \( coop\_consumption_t = n \times \frac{S_t}{2n} = \frac{S_t}{2} \) (total consumption if all cooperate)

We observe:
- Previous round actions \( A_j(t-1) \) for all players \( j \)
- Previous round total consumption (can be inferred from stock difference plus growth, or from actions)

---

### Pseudocode

```python
Initialize:
    P_1 = False  # no punishment at first round

For each round t in 1...r:
    if t == 1:
        # First round: Cooperate unconditionally to signal goodwill
        A_i(t) = C
        P_t = False

    elif t == r:
        # Last round: Defect to maximize immediate payoff (no future loss)
        A_i(t) = D
        P_t = False

    else:
        # For rounds 2 to r-1:

        # Detect if previous round was full cooperation:
        # Check if total consumption last round = coop_consumption_{t-1}
        # Since everyone plays simultaneously, and we have perfect info about actions, verify:
        all_cooperated_last_round = (for all players j: A_j(t-1) == C)

        if P_{t-1} == False:
            # Previous round was not punishment
            if all_cooperated_last_round:
                # Continue cooperating
                A_i(t) = C
                P_t = False
            else:
                # Defection detected => enter punishment
                A_i(t) = D
                P_t = True

        else:
            # Last round was a punishment round
            # If opponents returned to cooperation, forgive; else, continue punishment

            if all_cooperated_last_round:
                # Forgiveness: return to cooperation
                A_i(t) = C
                P_t = False
            else:
                # Continue punishment
                A_i(t) = D
                P_t = True
```

---

### Notes on Implementation & Rationale

- **Initial Round:** Cooperation from the start establishes a "nice" reputation and avoids premature depletion.
- **Detecting Defection:** We use the fact that cooperation entails total consumption = \( S_t / 2 \). If total consumption exceeds this (implying someone defected), trigger punishment.
- **Punishment:** Punishing by defecting imposes maximum immediate cost on defectors, lowering their payoff and signaling serious disapproval.
- **Forgiveness:** If opponents resume cooperation immediately after punishment, forgive to avoid endless mutual defection and sustain mutual gains.
- **Last Round Defect:** Since no future rounds exist, cooperating yields less payoff than defecting, so defect for self-interest.
- **Dynamic State:** Because the stock depends on previous actions, sustaining cooperation keeps the resource stable or growing, maximizing long-term payoff.
- **No Assumptions on Opponent Norms:** The strategy uses only observed actions, with no need for communication or coordination devices.

---

### Handling Edge Cases

- **If others always defect:** The strategy will enter always-defect mode after first detection, minimizing losses and avoiding needless cooperation exploitation.
- **If some players defect intermittently:** The strategy punishes only for one round, then tests cooperation. If defectors continue, punishment persists.
- **If stock drops near zero:** The strategy cooperates unless defectors appear, but low stock means low payoff either way, so minimizing total depletion remains optimal.
- **Multiple defectors:** The punishment targets all defectors collectively via mutual defection, as individual targeting is not possible without communication.

---

### Summary

| Round       | Condition                               | Action       |
|-------------|---------------------------------------|--------------|
| 1           | Initial round                         | Cooperate (C)|
| 2 to r-1    | Previous round full cooperation, no punishment | Cooperate (C)|
| 2 to r-1    | Previous round had defection, no punishment | Defect (D), start punishment |
| 2 to r-1    | Previous round was punishment, now opponents cooperate | Cooperate (C), forgive |
| 2 to r-1    | Previous round was punishment, opponents defect again | Defect (D), continue punishment |
| r (Last)    | Any condition                         | Defect (D)   |

---

If implemented by all players, this strategy leads to sustained resource levels close to capacity, stable mutual cooperation, and strong deterrence of defection with a path for reconciliation. This maximizes joint payoffs over the entire repeated game and aligns well with cooperative mindset principles under the game's assumptions.
'''

description_COOPERATIVE_122 = '''
Below is a cooperative strategy designed for this repeated common pool resource game. This strategy is **conditional cooperation** aimed at sustaining the resource stock near capacity, maximizing long-term total payoffs, and punishing defection to enforce cooperation. It uses minimal assumptions consistent with standard game theory and relies solely on observable past actions and stock levels.

---

## Cooperative Strategy: "Conditional Sustained Cooperation"

### Intuition
- **Cooperate (C)** initially and as long as all players previously cooperated and the resource stock is healthy.
- **Defect (D)** to punish if any player defected in the previous round.
- Attempt to **return to cooperation** once the punishment phase is over and resource conditions improve.
- **Last round:** Defect to secure higher immediate payoff (endgame effect).
- The strategy enforces cooperation by reciprocating cooperation and punishing defection with defection.

---

### Definitions & State Variables
- `round` = current round index (1 to r)
- `S` = current common pool stock at start of round
- `capacity` = maximum stock capacity
- `n` = number of players (including self)
- `history` = record of all players' actions each prior round, known perfectly to all
- `punishment` = Boolean flag indicating whether the player is currently punishing defectors

---

### Decision Rules

#### 1. Initialization (Round 1)
- **Action:** Cooperate (C)
- **Reason:** Start with trust, attempt to stabilize the resource and build cooperative equilibrium.

#### 2. For rounds 2 to r-1 (intermediate rounds)

##### Condition for Cooperation:
- Nobody defected in the previous round (all played C).
- Stock at start of round is above a safe threshold `T`.
    - Choose `T = capacity / 2` as a heuristic (resource health threshold).
- Currently not punishing.

If the above hold, **Cooperate (C)**.

##### Condition for Punishment:
- If any player defected in the previous round → enter punishment phase.
- `punishment` flag set True.
- Defect (D) in current round to punish.
- Continue punishment for at least one round (i.e. defect in the next round after detecting defection).

##### Condition for Ending Punishment:
- After punishing for one round, return to cooperation if:
  - Stock level `S` is healthy: `S >= T`
  - All players cooperated in the punishment round (i.e. no further defections)
- Reset `punishment` flag to False.

If `S < T` (resource is low), remain punishing to avoid resource collapse.

#### 3. Last Round (Round r)
- **Defect (D)** to maximize one-shot payoff (endgame defection).
- No incentive to cooperate as no future rounds remain.

---

### Pseudocode

```python
def cooperative_strategy(round, r, S, capacity, n, history):
    T = capacity / 2    # Resource health threshold
    
    # On last round, defect
    if round == r:
        return 'D'
    
    # First round: cooperate
    if round == 1:
        punishment = False
        return 'C'
    
    # Check if currently punishing (maintain state across rounds)
    # Assume `punishment` flag stored/persisted externally
    
    # Detect if any defection in previous round
    previous_actions = history[round - 2]  # indexing: round-2 is previous round
    defected_last_round = any(a == 'D' for a in previous_actions)
    
    if defected_last_round:
        punishment = True
        return 'D'  # Punish by defecting
    
    if punishment:
        # Punishment carried out for one round already,
        # decide whether to end punishment or continue.
        # Check if previous round was clean cooperation
        previous_actions = history[round - 2]
        defected_last_round = any(a == 'D' for a in previous_actions)
        
        if (not defected_last_round) and (S >= T):
            punishment = False  # End punishment, return to cooperation
            return 'C'
        else:
            return 'D'  # Continue punishing because defectors persist or stock is low
    
    # If no punishing and no defection detected, cooperate only if stock healthy
    if S >= T:
        punishment = False
        return 'C'
    else:
        # Stock low but no detected defection: defect to avoid depletion risk
        punishment = True
        return 'D'
```

---

### Strategy Properties

- **Cooperative:** Begins by cooperating and cooperates whenever others do and resource is healthy.
- **Punishes defection:** Detects any defector and punishes by defecting one round (triggering short "grim trigger" punishment).
- **Recovers Cooperation:** Returns to cooperating if no subsequent defection occurs and resource is recovering.
- **Sustainable:** Maintains stock by only cooperating when resource is sufficiently healthy.
- **Endgame Defection:** Defects in final round to maximize personal payoff, standard backward induction logic.
- **No communication or assumptions beyond observation:** Based only on observable actions and stock level.
- **Simple and robust:** Well-defined triggers based on history and resource condition.

---

### Remarks

- The punishment length is 1 round for simplicity and to allow quick recovery.
- The threshold `T = capacity / 2` is a heuristic; can be tuned if parameters known.
- The logic can be adapted to longer punishment if defectors persist.
- Because defectors gain short-term advantage, the punishment deters them by lowering future stock and payoffs.
- By punishing defectors, the strategy enforces cooperative equilibrium as a subgame perfect equilibrium under the repeated game framework.

---

If you want, I can also provide variants such as longer punishment phases or more forgiving, but this baseline conditional cooperation with punishment is a standard and effective approach for common pool resource games under perfect information repeated setting.
'''

description_COOPERATIVE_123 = '''
Below is a cooperative strategy designed to maximize long-term sustainable payoffs and maintain the common resource stock at or near capacity. The strategy enforces cooperation by rewarding cooperation and punishing defections with a limited “grim trigger” forgiveness mechanism to avoid excessive collapse.

---

## Cooperative Strategy Description

### 1. Overview

- **Goal**: Maintain the common resource stock near capacity to maximize long-run total payoffs.
- **Cooperate**: Always choose **C (Cooperate)** as long as all players have cooperated recently and the stock is healthy.
- **Detect Defection**: If any player defects, respond with limited punishment by defecting for a small number of rounds.
- **Forgiveness / Recovery**: After punishment rounds, return to cooperation to restore trust and stock.
- **Last Round**: Cooperate on the last round to maximize final payoffs and avoid short-term greed gains.

---

### 2. Decision Rules

Let:
- **t** = current round, starting at 1
- **S_t** = stock at start of round t (known)
- **history** = record of all players’ previous actions in rounds 1,...,t-1
- **punish_counter** = integer counting how many punishment rounds remain (initially 0)

#### Rule A: First Round (t = 1)

- Cooperate unconditionally: choose **C**

#### Rule B: Subsequent Rounds (1 < t < r)

- If `punish_counter > 0`  
  → Defect (**D**) this round  
  → Decrement `punish_counter` by 1

- Else if (any player defected in last round):
  → Set `punish_counter` to `punishment_length` (a small integer, e.g., 2 rounds)  
  → Defect (**D**) this round  
  
- Else if (stock S_t < threshold_low):  
  (stock threshold to detect dangerous depletion, e.g., 50% capacity)  
  → Defect (**D**) to slow collapse (but with forgiveness, i.e. enter punishment mode)  
  → Set `punish_counter` to `punishment_length`  
  
- Else  
  → Cooperate (**C**)

#### Rule C: Last Round (t = r)

- Cooperate unconditionally: choose **C**  
(Mutual cooperation yields a high terminal payoff; defection gains little given no future rounds)

---

### 3. Parameters (suggested defaults)

- `punishment_length = 2` rounds  
- `threshold_low = capacity / 2` (50% of capacity)  

These can be tuned depending on the game length.

---

### 4. Intuition

- By cooperating while others cooperate and stock is healthy, all obtain steady moderate payoffs.
- Detecting defection triggers limited punishment to discourage free-riding.
- Punishment is limited so that the group can recover cooperation quickly.
- Defecting when stock dangerously low aims to signal emergency and reduce over-consumption.
- Last-round cooperation avoids destructive end-game defecting.

---

### 5. Pseudocode

```python
# Inputs per round:
# t: current round index (1-based)
# r: total rounds
# n: number of players
# capacity: maximum stock capacity
# S_t: current stock at start of round t
# history: list of dictionaries, each dict maps player index to action in round <t
# my_index: this player’s index (1 to n)
# punish_counter: integer, punishment rounds left (init 0)

def cooperative_strategy(t, r, n, capacity, S_t, history, my_index, punish_counter):
    # Constants
    punishment_length = 2
    threshold_low = capacity / 2
    
    if t == 1:
        # First round: cooperate
        action = 'C'
        return action, punish_counter
    
    if t == r:
        # Last round: cooperate unconditionally
        action = 'C'
        return action, punish_counter
    
    # Check if currently punishing
    if punish_counter > 0:
        # Defect during punishment
        punish_counter -= 1
        action = 'D'
        return action, punish_counter
    
    # Check last round actions for defection
    last_round_actions = history[-1]  # Dict: player_i -> 'C' or 'D'
    # Was there any defection last round?
    if any(act == 'D' for act in last_round_actions.values()):
        # Start punishment phase
        punish_counter = punishment_length - 1  # We defect now plus next punish_length-1 rounds
        action = 'D'
        return action, punish_counter
    
    # Check stock level
    if S_t < threshold_low:
        # Stock dangerously low, engage punishment to signal emergency
        punish_counter = punishment_length - 1
        action = 'D'
        return action, punish_counter
    
    # Otherwise cooperate
    action = 'C'
    return action, punish_counter
```

---

### 6. Interpretation

- The strategy behaves as a *conditional cooperator*:
  - Starts fully cooperative.
  - Punishes defections or dangerous depletion by defecting for a short time.
  - Then forgives and returns to cooperation.
- This balances enforcement and recovery, promoting stability of the common pool.
- Cooperating in the last round avoids destructive defection for immediate gain.

---

# Summary

| Round condition              | Action   | Notes                                |
|-----------------------------|----------|------------------------------------|
| t = 1                       | Cooperate (C) | Start cooperative                  |
| t = r (last round)          | Cooperate (C) | Maximize terminal payoff          |
| Currently punishing         | Defect (D)   | Punishment lasts `punishment_length` rounds |
| Defection detected last round | Defect (D)   | Trigger punishment                 |
| Stock below half capacity   | Defect (D)   | Signal emergency, start punishment |
| Otherwise                  | Cooperate (C) | Maintain cooperation               |

---

This simple yet robust conditional cooperation strategy aligns well with a cooperative mindset under common knowledge and perfect monitoring, designed to maximize joint payoffs over repeated rounds with dynamic stock.
'''

description_COOPERATIVE_124 = '''
Here is a cooperative strategy designed for the Common Pool Resource Game described, balancing collective sustainability and individual incentives within the given constraints.

---

## Key Intuition

- Cooperation (C) by all players sustains the stock near capacity indefinitely, yielding stable payoffs each round.
- Defection (D) yields higher immediate payoff but depletes the stock, reducing future payoffs for all.
- Because players observe past actions and payoffs, defection can be detected.
- The goal is to sustain cooperation over all rounds, maximizing total payoffs — the classical social dilemma.
- Punishment for defection is minimal (to discourage defection), but forgiveness is built in to enable recovery to cooperation.


---

## Strategy Description

The strategy is a **"Conditional Cooperation with Generous Trigger and Endgame Finite-Horizon Adjustment"**:

### 1. Initial Round (t = 1)
- Always **Cooperate (C)** to establish the baseline cooperation and signal willingness to sustain the stock.

### 2. For each intermediate round (1 < t < r)
- **If no defections observed in the previous round:**  
  - **Cooperate (C)** to sustain cooperation.

- **If any defections observed in the previous round:**  
  - Enter **Punishment mode** for the current round: **Defect (D)** to deter free riding.
  
- **Return to cooperation after punishment round:**  
  - If punishment round completed (i.e., one round of D as punishment), and no new defections detected, revert to cooperation.

### 3. Final Round (t = r)
- Knowing no future rounds remain to punish or reward:
  - Always **Defect (D)** to maximize immediate payoff.

---

## Detailed Rationale

- **Why cooperate initially?**  
  Cooperation preserves the common pool's capacity, enabling sustainable payoffs.

- **Why punish with defection after detecting defection?**  
  Defection harms others; punishing with defection deters defectors because they lose future cooperation benefits.

- **Why one-round punishment then forgiveness?**  
  Prolonged or harsh punishment reduces overall payoffs for everyone, including cooperators. A "generous" one-round punishment strikes a balance.

- **Why defect in the final round?**  
  No future reputation nor punishment is possible, so defecting to maximize last-round payoff is individually rational.

- **Why is this cooperative overall?**  
  The strategy promotes mutual cooperation to maintain the stock except when punishments are essential to sustain cooperation long-term.

---

## Formal Pseudocode

```python
def cooperative_strategy(t, r, history):
    # Inputs:
    # - t: current round (1-indexed)
    # - r: total number of rounds
    # - history: list of tuples for previous rounds
    #   each element is a list of tuples [(a_i, pi_i), ...] for all players i in round t-1,
    #   where a_i ∈ {C, D} is player i's action and pi_i its payoff

    if t == 1:
        # Round 1: start cooperatively
        return 'C'

    elif t == r:
        # Final round: defect to maximize payoff
        return 'D'

    else:
        # Check if any defection in the previous round by any player
        last_round_actions = [a for (a, pi) in history[t-2]]  # zero-indexed for history

        if 'D' in last_round_actions:
            # We punish this round with defection
            return 'D'
        else:
            # No defection last round, cooperate
            return 'C'
```

---

## Additional Notes

- **Observability Assumption:** Since perfect info is assumed, the strategy can detect defectors immediately.
- **No coordination or communication:** Cooperation is sustained purely via conditional actions.
- **Stock dynamics:** Sustained cooperation keeps the stock near capacity, maintaining high per-round payoffs.
- **Against defectors:** Punishment reduces incentives to defect repeatedly.
- **Resilience:** Cooperation resumes quickly following isolated defections.
- **Incentive alignment:** The strategy balances immediate individual incentive (defect in the last round) with long-run mutual benefit.

---

### Summary

| Round Type                | Action |
|--------------------------|---------|
| First round (t=1)        | Cooperate (C) |
| Intermediate rounds (1<t<r) | Cooperate if last round had only C; else Defect (punishment) for one round, then revert to cooperation |
| Last round (t=r)         | Defect (D) to maximize final payoff |

---

This approach is a practical and classical conditional cooperation strategy adapted to the specific payoffs and resource dynamics of the game, designed to maximize joint payoffs through mutual cooperation sustained by simple, observable punishments.
'''

description_COOPERATIVE_125 = '''
Below is a fully cooperative strategy designed to foster mutual cooperation, maintain the common pool resource sustainably during the repeated game, and maximize collective payoffs. It treats the well-being of the common resource as critical and uses conditional cooperation with forgiveness to handle defections, given no communication and only observable past actions.

---

## Cooperative Strategy: "Sustain and Forgive"

### Intuition
- Start by cooperating to sustain the resource.
- Continue cooperating as long as everyone cooperated in the previous round.
- If any player defected in the previous round, respond with defection as a punishment for exactly one round.
- Afterwards, forgive by returning to cooperation to encourage rebuilding trust.
- In the last round, defect to maximize immediate payoffs since resource sustainability no longer matters.

This is a form of "tit-for-tat with forgiveness," adapted for the common pool resource context.

---

## Detailed Decision Rules

### Notation
- Round index: t ∈ {1,...,r}
- Observed actions by all players in round t: Actions_t = {a_i,t for all i}
- Own action in round t: a_self,t
- Number of defectors in round t: D_t = count of players with action D in Actions_t
- Capacity: maximum stock capacity 
- Stock_t: common pool stock at start of round t, known publicly

---

### Strategy Rules

**1. Round 1 (t=1):**  
- Choose **Cooperate (C)**.  
- Rationale: Initiate with cooperation to preserve stock and signal goodwill.

**2. Intermediate rounds (1 < t < r):**  
- If **all players cooperated in t-1** (no defectors), **Cooperate (C)**.  
- Else (if any defection detected in round t-1), **Defect (D)** this round as punishment.  
- In the round after punishing (if punished in t-1), return to **Cooperate (C)** regardless of others' actions to forgive and rebuild cooperation.

**3. Last round (t = r):**  
- **Defect (D)** to maximize immediate payoff because no future interactions exist to preserve the stock.

---

### Pseudocode

```python
# Initialize history lists
actions_history = []  # list of sets of actions per round
punish_next_round = False  # flag to indicate punishment in coming round
punished_last_round = False  # flag that last round was a punishment round

def choose_action(t, r, actions_history):
    global punish_next_round, punished_last_round

    if t == 1:
        # First round: cooperate
        punish_next_round = False
        punished_last_round = False
        return 'C'

    if t == r:
        # Last round: defect to maximize payoff
        return 'D'

    prev_actions = actions_history[-1]  # actions from round t-1
    defectors_last_round = sum(1 for a in prev_actions if a == 'D')

    if punished_last_round:
        # Forgive this round and cooperate to encourage rebuilding trust
        punish_next_round = False
        punished_last_round = False
        return 'C'

    if defectors_last_round > 0:
        # Defection detected last round, punish by defecting this round
        punish_next_round = False
        punished_last_round = True
        return 'D'

    # Otherwise, all cooperated last round, cooperate
    punish_next_round = False
    punished_last_round = False
    return 'C'
```

---

## Explanation and Justification

- **Starting Cooperative:** Ensures that we do not deplete resource unnecessarily from the start, and signals willingness to cooperate.
- **Reciprocal Punishment:** Defecting immediately after an opponent defects discourages unilateral defection by imposing a cost.
- **One-Round Punishment:** Limiting punishment to one round avoids prolonged retaliations that drive resource depletion.
- **Forgiveness:** Returning to cooperation is crucial to reestablish collective trust and resource sustainability.
- **Last-round Defection:** Rational, since no future rounds exist to incentivize cooperation; max payoff is defecting.

---

## Behavior Under Assumptions

- Because actions are simultaneous, detecting defection or cooperation is straightforward via observed actions.
- Strategy is fully deterministic, so others can potentially learn to cooperate with it for mutual benefit.
- It assumes no prior trust but allows quick recovery from defections.
- Punishment is symmetric and fair, minimizing resource damage due to retaliation cycles.

---

## Edge Cases

- **Multiple defectors:** Any defection triggers punishment; all defectors are punished.
- **Chain of defections:** Punishment lasts only one round; if opponent returns to cooperation, so do we.
- **If opponents always defect:** strategy punishes by defecting every round after first but forgives; although unlikely to improve group payoff, it preserves potential for cooperative breakthroughs.
- **Changing parameters:** Capacities or player count affect absolute payoffs but not strategy logic.

---

# Summary

This "Sustain and Forgive" strategy provides:

- Clear rules for cooperating and defecting linked to observed past actions.
- Encourages sustainability by starting cooperative and punishing defections.
- Forgives to restore cooperation and prevent permanent collapse.
- Rational defection in the last round.
- Robustness to noisy or uncooperative opponents by conditional retaliation.

Such a strategy is well-aligned with the cooperative mindset necessary for common pool resource games with repeated interactions but no communication or coordination devices.
'''

description_COOPERATIVE_126 = '''
Below is a fully cooperative, conditional strategy designed for this Common Pool Resource (CPR) game. It supports sustainable resource use and aims to maintain the stock at or near capacity throughout the game, securing long-term mutual benefit.

---

## Strategy Overview: "Conditional Cooperation with Forgiveness"

**Key idea:**  
Start by cooperating to preserve the resource. Continue cooperating as long as all others cooperate (or mostly cooperate). If defections occur, respond with conditional punishment to discourage over-exploitation but forgive to restore cooperation. In the last round, defect to maximize immediate payoff (since no future rounds remain).

---

## 1. Decision Rules

### Notations:
- `t`: current round (1 ≤ t ≤ r)
- `A_i,t`: action chosen by player *i* in round *t* (C or D)
- `history`: complete record of all players’ actions from rounds 1, ..., t-1
- `defectors_in_last_round`: set of players who defected in previous round
- `cooperation_threshold`: number/ratio of defections tolerated before punishment (e.g., tolerate occasional defection)

---

### General (Rounds 1 to r-1):

- **Round 1:** Cooperate (C) unconditionally.
  
- **Subsequent rounds (t > 1 and t < r):**  
  - If **no defections detected in previous round**, cooperate.  
  - If defections occurred, defect only as a *targeted* punishment **against those who defected last round**.  
    Since actions are simultaneous and no direct targeting possible, translate this to:  
    - Defect if you observed any defection last round (punish collectively).  
  - However, if the stock falls below a low sustainability threshold (e.g., less than capacity/2), then cooperate unconditionally to help recover the resource.  
  - If defecting last round did not lead to stock recovery or caused stock collapse, switch back to cooperation to avoid mutual destruction.

---

### Final Round (t = r):

- Always defect (D) to maximize immediate payoff, because there is no future punishment or recovery incentive.

---

## 2. Handling Edge Cases

- **First round:** Cooperate to establish trust and sustain stock at max capacity.
- **Last round:** Defect, since no future consequences exist.
- **Low stock levels:** Override punishment and defecting tendencies with cooperation to avoid complete depletion and allow stock to grow.
- **Repeated defections (defectors never return to cooperation):**  
  After a fixed number of punishment rounds (e.g., 2 consecutive rounds), revert to cooperation to avoid indefinite resource depletion and incentivize others to return to cooperation.
  
---

## 3. Cooperative Alignment

- The strategy values resource sustainability over short-term gain.
- Punishment is limited and conditional, not permanently hostile.
- Forgiveness is built in to restore cooperation and avoid tragedy of commons.
- Players play cooperatively when others do, promoting mutual benefit and stable stock.
- Defection only used as a short-term deterrent considering the history of play.

---

## Pseudocode

```python
def cooperative_strategy(history, t, r, n, capacity, current_stock):
    """
    Parameters:
      history: list of length (t-1), each element a list of n actions ['C' or 'D']
      t: current round (1-based)
      r: total rounds
      n: number of players
      capacity: max stock capacity
      current_stock: stock at start of round t
    
    Returns:
      action: 'C' or 'D'
    """
    
    def last_round_defectors():
        if t == 1:
            return set()
        last_actions = history[-1]
        return {i for i, a in enumerate(last_actions) if a == 'D'}
    
    # Always defect on the last round
    if t == r:
        return 'D'
    
    # Round 1: cooperate unconditionally
    if t == 1:
        return 'C'
    
    defectors = last_round_defectors()
    # Define sustainability threshold for stock below which cooperate to help recovery
    sustainability_threshold = capacity / 2
    
    # If stock low, cooperate to recover
    if current_stock < sustainability_threshold:
        return 'C'
    
    # If no defectors last round, cooperate
    if len(defectors) == 0:
        return 'C'
    
    # If defectors exist, punish with defection in this round
    # But limit punishment length to avoid permanent collapse
    # Check defection streak length from history to limit punishment
    
    # Count consecutive previous rounds with any defection
    defection_streak = 0
    for past_round in reversed(history):
        if any(a == 'D' for a in past_round):
            defection_streak += 1
        else:
            break
    
    max_punishment_rounds = 2  # forgive after 2 rounds punishment
    
    if defection_streak <= max_punishment_rounds:
        return 'D'  # punish defectors collectively
    else:
        # Forgive after max punishment rounds
        return 'C'
```

---

## Explanation

- **Start cooperating** to ensure stock remains at carrying capacity.
- **Observe defections**: any defection detected triggers temporary punishment by defecting.
- The **punishment phase is capped** at 2 rounds to prevent endless retaliation and ruin of stock.
- If the **stock dips below half capacity**, cooperate regardless to let it recover.
- On the **last round**, defect for immediate payoff since no future rounds remain.
- This strategy is **simple, memory-based**, and relies only on observable actions and stock level.
- It is **cooperative in mindset**, seeks to maintain resource sustainability, and punishes defection temporarily.

---

Let me know if you need any clarifications or additional refinements!
'''

description_COOPERATIVE_127 = '''
Below is a cooperative strategy for the described Common Pool Resource Game that balances cooperation incentives, punishments for defection, and endgame considerations. It relies solely on observed actions and stock dynamics, requiring no communication or external coordination.

---

# Cooperative Strategy: "Conditional Cooperation with Forgiveness and Endgame Adjustment"

## Intuition
- **Cooperate initially and by default:** Start cooperative to sustain the resource.
- **Detect defection by others:** If any player defects, punish by defecting in the next round (to discourage free-riding).
- **Forgiveness:** If no further defections occur, return to cooperation after one punishment round to avoid perpetual retaliation.
- **Last round defect:** Defect in the last round unconditionally since no future punishment is possible (standard backward induction).
- **Stock-aware cooperation:** If stock falls dangerously low, defect to avoid collapse or allow time for stock recovery when cooperation is no longer fruitful.
  
This approach encourages mutual cooperation, deters defection through credible punishment, yet avoids permanent defection spirals. It also respects the unrecoverable nature of the last round.

---

## Detailed Decision Rules

Let:

- \( t \in \{1, ..., r\} \) be the round index
- \( S_t \) be the stock at the start of round \( t \) (known publicly)
- \( A_{j,t-1} \in \{C, D\} \) be the action player \( j \) took in the previous round (for \( t > 1 \))
- \( \text{Punish}_{t} \in \{\text{True}, \text{False}\} \) be an internal flag whether this player is punishing defectors in round \( t \)
- \( n \), \( r \), and \( \text{capacity} \) are game parameters known to all

---

## Algorithm / Pseudocode

```pseudo
Initialize:
  Punish_1 = False

For round t in 1 to r:

  If t == r:  
    # Last round: defect with no future consequences
    Play action = D

  Else if t == 1:
    # Round 1: start cooperatively
    Play action = C

  Else:
    # From round 2 to r-1, conditionally cooperate or defect

    Observe actions A_{j,t-1} for all players j ≠ self

    If Punish_{t-1} == True:
      # We are in punishment phase, meaning we defected last round to punish
      # Check if all others cooperated last round
      If all A_{j,t-1} == C for j ≠ self:
        # No new defections: end punishment, return to cooperate
        Punish_t = False
        Play action = C
      Else:
        # Defection persists, continue punishment
        Punish_t = True
        Play action = D

    Else:
      # Not currently punishing
      If any A_{j,t-1} == D for j ≠ self:
        # Someone defected last round => start punishment now
        Punish_t = True
        Play action = D
      Else:
        # Nobody defected last round, cooperate conditionally on stock level
        # If stock is too low, defect to avoid collapse or "give up"
        Threshold = capacity / (4 * n)   # Example threshold; tunable parameter
        
        If S_t < Threshold:
          # Stock dangerously low: defect to maximize last payoffs (somewhat pessimistic)
          Play action = D
          Punish_t = False
        Else:
          # Stock healthy: cooperate
          Play action = C
          Punish_t = False
```

---

## Explanation of Components

1. **Initial Cooperation:**  
   Round 1 is always cooperative (C) to start with trust.

2. **Detection and Punishment:**  
   If any opponent defected last round, defect this round to punish (triggering a punishment phase). This signals that defection is costly.

3. **Forgiveness:**  
   If after punishing one round all others cooperate, return to cooperation to restart mutual cooperation.

4. **Stock Threshold:**  
   A low-stock threshold helps avoid wasting effort trying to maintain cooperation when the resource is near collapse. This level is set conservatively to a fraction of capacity related to number of players (e.g., capacity // (4n)).

5. **Last Round Defection:**  
   Standard rational analysis shows defection in the last round maximizes individual payoff since no future rounds exist to enforce cooperation.

---

## Properties of the Strategy

- **Open to Cooperation:** Always tries cooperation when others cooperate and the stock is sustainable.
- **Enforces Cooperation:** Punishes defectors immediately in the next round by defecting, encouraging restraint.
- **Punishment is Temporary:** After one round of punishment, if no defectors, the player forgives and returns to cooperation.
- **Stock-Aware:** Avoids going down with the "ship" by defecting when the stock is dangerously low, preventing excessive waste.
- **Simple and Deterministic:** Easy to implement, just track previous round actions and stock.

---

## Example Walkthrough (n=4, capacity=100, r=10):

- **Round 1:** Play C.
- **Round 2:** If no defection by others round 1, play C. Else, punish.
- ...
- **Intermediate rounds:** Punish immediately upon defection, forgive after one round of punishment if cooperation resumes.
- **Stock Check:** If stock falls below 100/(4*4)= 6.25, defect to salvage last payoffs.
- **Round 10:** Defect unconditionally.

---

If all players follow this strategy, the stock will stabilize near capacity, maximizing mutual long-run payoffs. If others try to defect, defections are quickly punished, discouraging exploitation.

---

# Summary

**Strategy Name:** Conditional Cooperation with Forgiveness and Endgame Defection

**Actions:**

- Round 1: Cooperate
- Rounds 2 to r-1:  
 - Defect if punishing or if observed any defection last round  
 - Cooperate if all cooperated last round and stock above threshold  
 - Defect if stock below threshold  
- Round r: Defect unconditionally

**Rationale:** Promote sustained cooperation to maintain the common resource; punish defectors briefly to deter free-riding; forgive to restore cooperation; defect in last round to maximize individual payoffs when punishment no longer works.

---

This strategy leverages the full history and stock info available, aligns with cooperative mindset, and is robust in the given setting without coordination or communication.
'''

description_COOPERATIVE_128 = '''
Below is a cooperative strategy design tailored for the specified Common Pool Resource Game. It aims to sustain the common pool, achieve high joint payoffs, and punish defection to discourage over-exploitation — all under the given informational and structural constraints.

---

## Strategy Name: **Sustained Cooperation with Conditional Punishment (SCCP)**

---

## Intuition and Goals

- **Cooperate early and maintain cooperation** to keep the resource near capacity, ensuring high payoffs for everyone over time.
- **Punish defectors after observing defection** to discourage selfish behavior.
- **Forgive after punishment** to re-establish cooperation, avoiding endless defection cycles.
- **Adjust behavior in the last round** to optimize final payoffs given no future round.

---

## Key Points

- **Actions**: C = consume stock/(2n); D = consume stock/n
- **Perfect monitoring**: We see all players’ actions each past round.
- **No communication or pre-play agreement**: Strategy decisions only depend on observed history.
- **Symmetric strategy**: Same rules for all players using this strategy.
- **Punishment length**: finite, after which cooperation resumes.

---

## Decision Rules (Per round t)

**Notation:**

- t ∈ {1, 2, ..., r} is the current round
- history includes all players’ action profiles from rounds 1 to t-1
- defectors_in_last_round = set of players who played D in round t-1 (if t > 1)
- punishment rounds remaining: internal counter (starts at 0, resets)

---

### Initialization

- Round 1 (t=1): Cooperate (play C)  
  No history, assume cooperative start.

---

### For round 2 ≤ t < r (interior rounds)

1. **Check if punishment is active**:
   - If punishment rounds remaining > 0:
     - Play D (defect) to punish.
     - Decrement punishment counter by 1.
     - Continue to next round.
2. Else (no punishment active):
   - If in last round someone defected (defectors_in_last_round ≠ ∅):
     - Enter punishment phase: set punishment rounds remaining = P (P ≥ 1, e.g., P=2)
     - Play D (defect) this round (start punishment)
   - Else:
     - Play C (cooperate)

---

### Last round (t = r)

- Always play D (defect)

**Rationale:** No future rounds to sustain cooperation; maximize final round payoff by defecting.

---

## Edge Cases and Additional Details

- **If resource stock is very low (close to 0):**
  - Cooperate anyway to signal willingness to restore the stock if punishment phase is over.
- **If previously punished players come back:**
  - Strategy is forgiving: after punishment rounds, resume cooperation irrespective of who defected before.
- **If everyone uses the same strategy:**
  - Cooperation will persist indefinitely in rounds 1 to r-1.
- **If some players defect without reason,**
  - Defectors get punished for a fixed number of rounds, disincentivizing defection.
- **Choosing punishment length P:**
  - Tradeoff between severity and length.
  - Short punishment (e.g., P=2) is sufficient to reduce incentive to defect without collapsing cooperation.

---

## Pseudocode

```python
# Parameters
PUNISHMENT_LENGTH = 2  # adjustable

def SCCP_strategy(t, r, n, capacity, history, punishment_counter):
    # history: list of (actions_round_t), each is list of n actions (C or D)
    # punishment_counter: rounds of punishment still left to play D

    if t == 1:
        # Round 1: cooperate by default
        return 'C', punishment_counter

    # Last round: defect to maximize payoff, no future rounds
    if t == r:
        return 'D', punishment_counter

    if punishment_counter > 0:
        # In punishment phase: defect to punish
        punishment_counter -= 1
        return 'D', punishment_counter

    # No punishment ongoing
    actions_last_round = history[-1]  # list of actions from round t-1

    if 'D' in actions_last_round:
        # Someone defected last round -> start punishment
        punishment_counter = PUNISHMENT_LENGTH - 1  # minus 1 because defecting now counts as first punishment round
        return 'D', punishment_counter

    # Otherwise, cooperate
    return 'C', punishment_counter
```

---

## Summary

| Round           | Condition                          | Action                   |
|-----------------|----------------------------------|--------------------------|
| 1               | No past data                     | Cooperate (C)            |
| 2 to r-1        | Punishment active                | Defect (D), decrement counter |
| 2 to r-1        | No punishment, defectors last round | Defect (D), start punishment counter |
| 2 to r-1        | No punishment, no defectors last round | Cooperate (C)           |
| r (last round)  | Always                         | Defect (D)               |

---

## Cooperative mindset adherence

- Maximizes joint total payoffs by sustaining cooperation when possible.
- Punishes defectors to stabilize cooperation incentive.
- Forgives quickly to avoid cycles of defection.
- Uses full information to react conditionally.
- Respects known limitations: no communication or coordination devices beyond observation.

---

I trust this strategy will provide a strong baseline for cooperative play in the tournament context.
'''

description_AGGRESSIVE_1 = '''
**Aggressive Strategy for the Common Pool Resource Game**

---

### Intuition and Rationale

- Aggression means prioritizing immediate, maximum individual payoff over sustainability or cooperation.
- Defection yields a strictly higher payoff than cooperation in any given round if stock is positive.
- Because players consume simultaneously, and no communication or commitments are possible, defecting is the strictly dominant action for immediate gain.
- However, over repeated rounds, aggressive defection will deplete the common stock, potentially lowering future payoffs.
- To maximize total payoff aggressively, the strategy exploits opponents who might cooperate early, then ramps up defection as the stock depletes.
- It also avoids wasting rounds in "cooperation" mode which benefits others more than self.
- Because stock dynamics depend on remaining stock, aggressive defection will accelerate collapse, but since the final round is last, defecting there garners maximum immediate payoff regardless of future consequences.
  
---

### Strategy Outline

1. **Initial Round (t = 1): Always Defect.**  
   Purpose: Grab maximum payoff immediately, before others can respond.

2. **Rounds 2 to r-1: Defect if stock ≥ threshold; else cooperate.**  
   - Maintain defection while stock is sufficiently high to extract maximum payoff and accelerate depletion of the common pool (harming cooperators).  
   - If stock drops below a critical threshold where defection would quickly collapse the pool and yield zero payoff, temporarily cooperate to avoid immediate collapse and possibly gain payoff while others defect.  
   - The threshold is set to roughly (`stock ≥ capacity/(2n)`) ensuring defection yields > 0 payoff.

3. **Last Round (t = r): Always Defect.**  
   - No future consequences. Extract maximum payoff.

---

### Detailed Decision Rules

Let:
- `S_t` = stock level at start of round t
- `t` = current round (1 ≤ t ≤ r)
- `threshold = capacity / (2n)` (a minimal stock level that ensures defection yields positive payoff)

**Action selection:**

```
if t == 1:
    action = D  # Defect first round to exploit initial high stock

else if t == r:
    action = D  # Defect last round to maximize last payoff

else:  # intermediate rounds

    if S_t >= threshold:
        action = D  # Defect while stock allows positive payoff

    else:
        action = C  # Cooperate to minimally consume and preserve stock slightly
```

---

### Why `threshold = capacity/(2n)`?

- Defection payoff: `S_t / n`
- Cooperation payoff: `S_t / (2n)`

If stock `S_t < capacity / (2n)`, then payoff from defection is less than 0.5 (for example, very small). Defecting at very low stock depletes all remaining stock risking zero payoff next round. Cooperating consumes less, slightly preserves stock.

This threshold balances aggression and maximizing total payoff.

---

### Handling Edge Cases

- **Initial stock low (e.g., starting < threshold):** Still defect round 1 to extract maximum immediate payoff because no future to preserve.  
- **Stock 0 or near 0:** Cooperating won't help (payoff zero), but cooperating also avoids total immediate depletion penalty. Because stock cannot be negative, payoff would be zero regardless, so cooperate to conserve for growth.  
- **Only two rounds (r=2):** Defect both rounds for immediate gain. Temporary cooperation is not useful.  
- **More than two rounds (r > 2):** Follow threshold rule to be as aggressive as possible without immediate payoff collapse.

---

### Pseudocode Summary

```python
def aggressive_strategy(round_t, stock_S_t, capacity, n, r):
    threshold = capacity / (2 * n)

    if round_t == 1:
        return 'D'  # Defect first round

    elif round_t == r:
        return 'D'  # Defect last round

    else:
        if stock_S_t >= threshold:
            return 'D'  # Defect while stock sufficient

        else:
            return 'C'  # Cooperate to conserve stock minimally
```

---

### Summary

- Always defect first and last rounds.
- Defect in intermediate rounds as long as pool sustains profitable defection.
- Cooperate only transiently at very low stock levels to extend resource life slightly for payoff in the remaining rounds.
- Prioritize immediate and maximal consumption over long-term sustainability or cooperation.
- Exploit any cooperating opponents by consistently defecting whenever profitable.

This strategy clearly aligns with an aggressive mindset, maximizing immediate extraction of payoffs and pushing the common resource towards rapid depletion, outweighing cooperative or sustainability concerns.
'''

description_AGGRESSIVE_2 = '''
Below is a detailed description of a strongly aggressive strategy for the Common Pool Resource Game that aligns with your specification. It maximizes individual short-term gain and punishes cooperation signals by others, disregarding sustainability of the resource.

---

## Aggressive Strategy Description

**Key idea:**  
Always defect except in the very last round where the individual's incentive to defect is strongest and no future retaliation is possible. In earlier rounds, defecting maximizes immediate payoff and exerts pressure on others, driving rapid stock depletion but higher individual short-term gains. No cooperation is granted unless toward the last round where defecting guarantees maximum payoff without future consequences.

---

### Decision Rules

1. **First round (t = 1):**  
   Defect (choose action D).

2. **Intermediate rounds (1 < t < r):**  
   Always defect (D) regardless of previous history or stock level.

3. **Last round (t = r):**  
   Defect (D) to maximize immediate payoff since there is no future to preserve the resource.

---

### Rationale

- **Always defecting** maximizes immediate extraction (stock / n), which is twice the payoff of cooperating (stock / 2n).
- Defecting puts downward pressure on the common pool, potentially lowering future stock and opponents' payoffs, but aligns with aggressive mindset prioritizing self gain even at environment/resource expense.
- No attempt to cooperate or enforce reciprocity. No trust or forgiveness because communication and coordination are impossible.
- No cooperation in early or intermediate rounds to avoid being exploited by others who defect.
- Defection in the last round aligns with backward induction: no incentive to cooperate when the game ends.
- The strategy is simple, aggressive, and dominant in terms of payoff maximization over naïve cooperators or forgiving strategies.

---

### Edge Cases Handling

- **Initial stock at capacity:** Defecting extracts maximal possible units. Good for maximizing initial round gain.
- **Resource depletion:** No matter how low the stock goes, always defect to maximize marginal payoff. No concern for regeneration because future rounds cannot be improved by cooperation.
- **Number of players n:** Strategy is independent of n.
- **Number of rounds r:** Strategy scales trivially to any r > 1.
- **Observation of past moves:** History is ignored; no cooperation or adaptation.

---

### Pseudocode

```pseudo
Input: current_round t, total_rounds r
Output: action ∈ {C, D}

function aggressive_strategy(t, r):
    // Aggressive: always defect
    return D
```

**Alternatively, explicitly showing no cooperation at any round:**

```pseudo
function aggressive_strategy(t, r):
    if t >= 1 and t <= r:
        return D
```

---

### Summary

- **Always defect**, regardless of history or stock level.
- **Maximize immediate payoff** by consuming stock/n, twice the cooperative share.
- **Exploit others' cooperation** by never cooperating yourself.
- **Ignore stock sustainability**, enabling rapid exhaustion to maximize total payoff.
- **No forgiveness or cooperation**, no strategic modeling of opponents.
- **Takes advantage of last round** by defecting to ensure maximal payoff with no future repercussions.

This strategy fully embodies an aggressive mindset within the game's constraints and knowledge structure.

---

If you want me to design a more nuanced or conditional aggressive strategy that e.g. defects usually but responds in some way to cooperation or exhaustion dynamics, I can do that too. But the above is a clear, simple, strongly aggressive baseline strategy.
'''

description_AGGRESSIVE_3 = '''
Below is a detailed aggressive strategy tailored for the described Common Pool Resource Game. It is designed to maximize individual payoffs aggressively by defecting as long as it yields higher returns, exploiting cooperators when possible, and not shirking in the last rounds.

---

### Aggressive Strategy Description

**Objective:**  
Maximize individual payoff by defecting whenever it's profitable or strategically beneficial, exploiting cooperators, and ignoring sustainability concerns for short-term gain. The strategy aggressively defers to defection but modulates based on current stock and opponent behavior to sustain gains as long as possible.

---

### Key Intuition

- **Defection (D)** gives you higher per-round payoff when stock is sufficient, but risks depleting the common pool and future payoffs.
- **Cooperation (C)** gives lower immediate payoff, but tends to sustain the resource, mainly beneficial if others also cooperate.
- Since the strategy is aggressive, it prioritizes short-term gain over sustainability.
- Avoid "false cooperations" that opponents may exploit by defecting against you.
- Exploit cooperators by defecting when stock is high.
- Defection is particularly favorable on the last round since no future punishment can follow.
- If the stock reaches very low levels, defecting might yield no payoff (since the stock could be zero), so fallback to cooperation to "milk" some payoff if possible.
- Use history and stock to detect if others are cooperating or defecting.

---

### Decision Rules

Let:

- \( t \): current round (1-based),
- \( S_t \): stock available at round \( t \),
- \( r \): total rounds,
- \( n \): number of players,
- \( H_{t-1} \): history of all players’ actions up to previous round (observed),
- \( D_{-i}^{count} \): number of opponents who defected last round,
- \( k = \frac{S_t}{capacity} \): normalized stock level (0 to 1).

---

### Formal Strategy Specification

1. **First Round (t = 1):**
   - **Defect (D) always.**
   - Rationale: Start aggressively to maximize immediate payoff and signal aggressive intent.

2. **Intermediate Rounds (1 < t < r):**
   - **If normalized stock \( k > 0.5 \):**
     - **Defect (D).**
     - Rationale: Stock is sufficiently large, defecting yields higher payoff, exploit others.
   - **If \( 0.2 < k \leq 0.5 \):**
     - **Defect (D) if the majority of opponents defected last round or number of defectors ≥ half of opponents.**
     - Else **Cooperate (C).**
     - Rationale: If many defectors, defect to avoid exploitation; else exploit cooperative opponents but sustain a semblance of cooperation.
   - **If \( k \leq 0.2 \):**
     - **Cooperate (C).**
     - Rationale: Stock very low; defecting yields little or no payoff; cooperate to keep some payoff if possible.

3. **Last Round (t = r):**
   - **Defect (D) always.**
   - Rationale: No future rounds => no incentive to sustain stock; maximize immediate payoff.

---

### Additional Notes

- **Stock depletion awareness:** The strategy is aware of stock with \( k \) thresholds.
- **Opponent behavior:** The strategy uses the last round's observed opponent defect count to adjust cooperation in mid-low stock situations.
- **No forgiveness:** This strategy never returns to cooperation to build cooperation when stock is high unless stock is in the low-to-mid range and opponents are mostly cooperating.
- **No noise tolerance or complicated punishment:** Purely aggressive and self-serving.

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, capacity, S_t, history):
    """
    Parameters:
    - t: current round (1-based)
    - r: total rounds
    - n: number of players
    - capacity: maximum sustainable stock
    - S_t: current stock before round t actions
    - history: list of previous rounds actions per player 
               history[t-1][i-1] = 'C' or 'D'

    Returns:
    - action: 'C' or 'D'
    """
    k = S_t / capacity  # normalized stock level

    # Count number of defectors excluding self in last round
    if t == 1:
        D_minus_i_count = 0  # no previous rounds
    else:
        last_round = history[t-2]  # zero-based indexing
        # Exclude own last action:
        own_last_action = last_round[self_index]
        D_minus_i_count = sum(1 for i, a in enumerate(last_round) if i != self_index and a == 'D')

    # Rule 1: First round -> defect
    if t == 1:
        return 'D'

    # Rule 3: Last round -> defect
    if t == r:
        return 'D'

    # Intermediate rounds:
    if k > 0.5:
        # Large stock, defect aggressively
        return 'D'
    elif 0.2 < k <= 0.5:
        # Mid stock, adjust based on opponent defectors
        if D_minus_i_count >= (n - 1) / 2:
            return 'D'  # many defectors, defect to avoid exploitation
        else:
            return 'C'  # otherwise cooperate to exploit cooperators partially
    else:
        # Very low stock, cooperate to get some payoff
        return 'C'
```

(Note: `self_index` is the player's own index from 0 to n-1, assumed known to the strategy.)

---

### Summary

| Round           | Stock Level \(k = \frac{S_t}{capacity}\) | Action    | Reason                                               |
|-----------------|-------------------------------------------|-----------|------------------------------------------------------|
| 1 (first round) | Any                                       | Defect    | Aggressive start, maximize immediate gains           |
| 2..r-1          | \(k > 0.5\)                               | Defect    | Exploit healthy stock and cooperators                 |
| 2..r-1          | \(0.2 < k \leq 0.5\) and majority defect | Defect    | Avoid being exploited, respond aggressively           |
| 2..r-1          | \(0.2 < k \leq 0.5\) and less defectors  | Cooperate | Partial cooperation to exploit cooperators            |
| 2..r-1          | \(k \leq 0.2\)                            | Cooperate | Stock too low to exploit, sustain minimal payoff      |
| r (last round)  | Any                                       | Defect    | No future punishment, maximize last round payoff      |

---

This aggressive strategy should enforce a harsh stance on exploiting the common pool early and mid game when advantageous, while responding strategically to opponent defect behavior and stock depletion, and defecting without hesitation in the last round.
'''

description_AGGRESSIVE_4 = '''
Here's an **aggressive strategy** for the described Common Pool Resource Game. It is designed to maximize your own payoffs by exploiting the shared resource heavily while managing the risk of resource collapse. 

---

## Strategic Rationale

- **Aggressiveness:** Always defect (D) to extract the maximum payoff per round, except possibly when doing so would wreck the resource prematurely and reduce total future payoffs.
- **Resource management:** If the stock gets dangerously low, temporarily cooperate (C) to preserve the resource and extend the game, ensuring continued aggressive extraction later.
- **First round:** No prior info, defect immediately to maximize early gains.
- **Last round:** Always defect, as no future rounds remain to benefit from resource preservation.
- **Between rounds:** Monitor the resource level. Defect unless defecting would cause the resource to collapse to an unusable state zero or near-zero, in which case cooperate once to allow it to recover minimally.

---

## Decision Rules Summary

| Round      | Condition                                | Action   |
|------------|-----------------------------------------|----------|
| Round 1    | No history                              | Defect   |
| Last round | Always defect                          | Defect   |
| Otherwise  | If defecting this round → resource ≤ 0 | Cooperate (preserve resource) |
| Otherwise  | Defect                                  | Defect   |

---

## Key Insight & Computation for "safe" defect

At each round **t**, you observe the current stock \( S_t \).

- If you defect, your consumption is \( S_t/n \).
- Total consumption if all defect: \( n \times (S_t/n) = S_t \) (resource collapses to zero).
- But you only control your action. Others may defect or cooperate.

**Since no trust/coordination exists, assume worst case: everyone defects.**

Thus:

- If defecting now will cause the stock to drop to zero (or near zero), it's future payoff suicide.
- Cooperate to reduce total consumption, allowing resource growth.

---

## Detailed Algorithm

1. **Input:** round \( t \), total rounds \( r \), current stock \( S_t \), number of players \( n \), capacity \( C \)  
2. **If** \( t = 1 \) (first round):  
    - Action = Defect (D)  
3. **Else if** \( t = r \) (last round):  
    - Action = Defect (D)  
4. **Else:**  
    - Compute hypothetical stock after everyone defects this round:  
      \[
      S_{after} = S_t - n \times \frac{S_t}{n} = 0
      \]
    - With resource collapse to zero, no future rounds yield payoff.  
    - To avoid this, check if current stock \( S_t \) is "low". Define "low" as:  
      \[
      S_t < \text{threshold}
      \]  
      Choose threshold = \( 2n \) (minimum sustainable stock from specification) or slightly above.  
    - If \( S_t < \) threshold:  
      - Cooperate (C) once  
    - Else:  
      - Defect (D)  

---

## Interpretation of Threshold

When \( S_t \) is high, defecting keeps being aggressive. When \( S_t \) dips below threshold, cooperate once to refill stock without wasting entire payoff.

---

## Pseudocode

```python
def aggressive_strategy(t, r, S_t, n, capacity):
    # Parameters
    threshold = 2 * n  # minimal sustainable stock level
    
    # First round: defect hard to maximize gain
    if t == 1:
        return 'D'
    
    # Last round: defect for maximum payoff, no future concerns
    if t == r:
        return 'D'
    
    # Intermediate rounds
    if S_t < threshold:
        # Stock low - cooperate for one round to stabilize resource
        return 'C'
    else:
        # Otherwise defect aggressively
        return 'D'
```

---

## Explanation

- The strategy is **aggressive** because it almost always defects, maximizing immediate payoffs.
- It is **conditional** to prevent total resource collapse mid-game, allowing the resource to regenerate a bit and thus maximizing long-term payoffs.
- Cooperation is only used as a *last resort* to maintain the resource viability.
- No assumptions are made about opponents; assumes worst-case that everyone defects.
- This strategy hopes to out-earn cautious cooperators or naïve players by extracting aggressively while not self-destructing early.

---

### Summary

**Always defect except use occasional minimal cooperation to avoid catastrophic resource depletion in mid-game rounds. Defect in first and last rounds unconditionally.** This balances aggressive extraction with resource preservation whenever absolutely necessary.
'''

description_AGGRESSIVE_5 = '''
Below is a fully aggressive, exploitative strategy designed for the Common Pool Resource Game you specified. It aims to maximize immediate individual payoffs by defecting as much as possible while exploiting any cooperating players. However, it also leverages knowledge of the game length to extract extra returns at the end.

---

## Aggressive Strategy Description

### Core Idea
- **Default to defecting** every round to maximize immediate payoff.
- **Exploit cooperators:** If you observe any would-be cooperating behavior by others, keep defecting to gain more relative benefit.
- **First Round:** Defect to immediately seize maximum payoff.
- **Intermediate Rounds:** Continue defecting regardless of past actions.
- **Last Round:** Aggressively defect, since no future retaliation is possible.
- **Stock awareness:** Ignore sustainability and future stock replenishment; focus only on maximizing **your cumulative payoff**.
- **No forgiveness or cooperation:** Do not cooperate to rebuild or signal peaceful intent, since no trust or repeated coordination is assumed.

### Reasoning
- Defecting yields twice the payoff of cooperating in any given round at current stock levels.
- Because payoffs depend on current stock (which is affected by total consumption), sustained defection will reduce future payoffs.
- Despite this, an aggressive player prioritizes immediate advantage and relative gain over group sustainability, so does not restrain consumption.
- Since no communication or coordination is possible, cooperation is unlikely to be reliably sustained anyway, so building cooperation is futile.
- The last round is critical: no incentive to preserve stock because no future rounds exist.

---

## Pseudocode

```python
def aggressive_strategy(history, round_num, n, r, capacity, current_stock):
    """
    history: list of tuples of actions of all players in previous rounds
             e.g. history[t] = [a_1, a_2, ..., a_n] where a_i ∈ {C, D}
    round_num: current round number (1-based)
    n: number of players
    r: total rounds
    capacity: maximum sustainable stock
    current_stock: stock before current round actions

    Returns:
        A_i: action for this round ('C' or 'D')
    """
    # Aggressive principle: always defect
    # No cooperation or forgiveness, no matter opponent history

    return 'D'
```

---

## Edge Cases Handling

- **Round 1:** No history, just defect immediately.
- **Intermediate Rounds (2 ≤ round_num < r):** No cooperation, no punishments or rewards; keep defecting.
- **Last Round (round_num == r):** Defect to maximize last round payoff; no future rounds to influence.
- **Stock depletion:** If stock reaches zero, no payoff possible. This is acceptable since strategy prioritizes short-term gain.
- **If stock is very low:** Still defect, taking potentially zero or low payoff rather than cooperate.
  
---

## Summary

| Round           | Action                                                             |
|-----------------|--------------------------------------------------------------------|
| 1 (First round) | Defect (consume stock/n)                                           |
| 2 ... r - 1     | Defect (ignore opponents’ actions; prioritize maximizing individual gain) |
| r (Last round)  | Defect (no future rounds, exploit remaining stock fully)          |

This aggressive strategy assumes rivals may play any patterns but never gives up the immediate payoff advantage of defection.

---

**Note:** This aggressive strategy sacrifices long-term sustainability and total group payoffs to maximize the individual player’s total accumulated payoff, in line with the aggressive mindset required.
'''

description_AGGRESSIVE_6 = '''
Here is a design for an **aggressive strategy** for the Common Pool Resource Game:

---

## Strategy Overview: "Relentless Defector with Opportunistic Cooperation"

This strategy aims to maximize immediate and overall gains by mostly defecting (the aggressive action) because defecting consumes more stock and yields higher individual payoff per round **when exploited smartly**. However, it pragmatically incorporates opportunistic cooperation to avoid premature collapse of the resource stock when it would severely reduce future payoffs. It punishes opponents who exploit cooperation and takes advantage of others' cooperation when possible.

---

## Core Intuition

- **Defect aggressively** from the start and whenever the stock is sufficiently healthy.
- However, if the stock is dangerously low (where defecting would annihilate the stock), cooperate to sustain some regeneration.
- In the **last round**, defect always (no future rounds to worry about).
- Use previous rounds’ opponent actions and stock dynamics as signals for possible short-term cooperation, but favor defection as default.
- This approach balances greed with awareness of dynamic resource depletion, fitting an "aggressive but rational" profile.

---

## Detailed Decision Rules

Let the parameters be as per the spec:

- n = number of players
- r = number of rounds
- t = current round index (1-based)
- S_t = current stock at round t (before actions)
- capacity = maximum sustainable stock level

---

### 1. **Round 1 (Start of game)**

- No history yet.
- Aggressively defect to maximize first-round payoff.
  
**Action: Defect (D)**

---

### 2. **Intermediate rounds (2 ≤ t < r)**

At round t:

- Let `S_t` be the current stock.
  
- Compute the *critical depletion threshold*:

  Let
  
  \[
  \text{Total consumption if all defect: } TC_D = n \times (S_t / n) = S_t
  \]
  
  If all defect, stock hits zero immediately.

  Let
  
  \[
  \text{Total consumption if all cooperate: } TC_C = n \times (S_t / (2n)) = S_t / 2
  \]
  
  Then stock after consumption is at least \(S_t/2\).
  
- **Threshold decision**: Define a critical stock threshold \(S_{crit} = 2n\)

  (This threshold is the minimum sustainable stock level to allow the stock to regrow meaningfully without collapsing in one aggressive round.)

- **If** \(S_t > S_{crit}\) **then:**

  - Defect (D), exploiting the healthy stock.
  
- **Else:**

  - Cooperate (C) to avoid stock depletion to zero, allowing some regeneration.
  - Because at low stocks, defecting immediately depletes the resource to zero, killing all future payoffs.

---

### 3. **Last round (t = r)**

- No future payoffs will be affected by depletion.
- Aggressively defect since no future rounds to worry about.
  
**Action: Defect (D)**

---

### 4. **Reaction to opponent behavior**

Optionally, since we observe previous actions and payoffs:

- If in the previous round a majority of players defected (≥ half players defected), maintain defection.
- If in previous round a majority cooperated and stock is well above \(S_{crit}\), continue defecting to exploit cooperation.
- If you detect a pattern of mutual cooperation building stock, you can briefly cooperate to maintain growth, but only if stock is near \(S_{crit}\).

This can be implemented as:

- If \(S_t > S_{crit}\):

  Defect regardless of opponent actions.

- Else:

  Cooperate regardless of opponent actions.

- **Exception:** If in previous round, you detected that defectors caused large drops in stock, cooperate this round to preserve the resource.

---

## Pseudocode

```python
def aggressive_strategy(t, r, n, capacity, S_t, history):
    """
    t: current round (1-based)
    r: total rounds
    n: number of players
    capacity: max stock
    S_t: current stock before action
    history: list of previous rounds actions of all players (list of lists), each inner list length = n
    
    Returns: 'C' or 'D'
    """
    S_crit = 2 * n  # critical threshold
    
    # Last round: always defect
    if t == r:
        return 'D'
    
    # Round 1: no history, start aggressively with defect
    if t == 1:
        return 'D'
    
    # Intermediate rounds
    # Check if stock above critical threshold
    if S_t > S_crit:
        # Stock healthy, defect aggressively
        return 'D'
    else:
        # Stock dangerously low, cooperate to sustain resource
        return 'C'
```

---

## Summary

- **Always defect on round 1 and last round.**
- **Defect on intermediate rounds when stock is above critical threshold (2n).**
- **Cooperate when stock falls below or equal to 2n to preserve resource and sustain future gains.**
- This is a **greedy "exploitative" style** that risks depletion but blunts self-destruction by cooperating only when necessary.
- It ignores elaborate retaliations or trust, focusing on payoffs with resource-aware aggression.

This fits a clearly aggressive mindset: "Get as much as possible by defecting whenever the resource is adequate. Only back down (cooperate) when resource is critically low to avoid losing everything prematurely."

---

If you want a more reactive variant, you can add checks for opponent defection rates per round, but the above baseline strategy is aggressive, simple, and robust by design.
'''

description_AGGRESSIVE_7 = '''
Here is a detailed aggressive strategy design for the Common Pool Resource Game. This strategy prioritizes maximizing immediate payoffs by defecting whenever profitable, exploiting cooperative players, and minimizing cooperation. It also takes into account the dynamics of the stock to avoid premature collapse in early rounds when maximizing cumulative payoff is possible.

---

## Aggressive Strategy Description

### 1. Key Idea
- The strategy **defaults to defecting** (D) in every round except possibly in early rounds if defecting threatens the resource too much.
- It exploits cooperators who consume less, gaining higher per-round payoffs.
- It allows limited cooperation early on to sustain resource levels without triggering resource collapse prematurely.
- In the **last round**, defect unconditionally for maximum immediate payoff.
- If the stock level is near depletion, **defect anyway** to secure immediate high payoff before total collapse (since after the last round stock is irrelevant).
- If all other players defect, no reason to cooperate — defect as well.
- If some cooperation observed but stock is crashing, defect to maximize own short-term gain.

---

### 2. Decision Rules (Round by Round)

#### Notation
- t: current round (1 ≤ t ≤ r)
- S_t: stock at the start of round t
- Actions_{t-1}: vector of all players’ actions in previous round
- C_count_{t-1}: number of cooperators in previous round
- D_count_{t-1} = n - C_count_{t-1}
- capacity: resource capacity (≥ 2n)
- n: number of players

---

#### Round 1 (t=1):

- **Defect (D) unconditionally.**
  
Reason: No history to infer cooperation or punish. Maximize immediate gain.

---

#### Intermediate rounds (1 < t < r):

- If stock at start of round is **high**, defined as 

  \[
  S_t > 2n
  \]

  then defect.

  Reason: Resource can sustain heavy extraction, so maximize immediate payoff.

- If stock at start of round is **moderate to low** (defined as)

  \[
  2n \geq S_t > n
  \]

  then:

  - If last round had some cooperation (C_count_{t-1} > 0) **and** stock depletion was significant (stock dropped more than 25% from previous round), defect to exploit cooperators and accelerate payoff accumulation.

  - Else, cooperate **only** if expected stock after this round's consumption and growth remains above n; else defect.

  This conditional cooperation allows slight moderation if it can keep the stock from crashing completely before later rounds, to maintain some positive payoffs.

- If stock at start of round is **low** (≤ n):

  - Defect unconditionally.

  Reason: Resource is near collapse, no benefit to conserve since remaining rounds will have low payoff anyway.

---

#### Last round (t = r):

- Defect unconditionally, regardless of stock.

Reason: No future rounds, so no incentive to conserve.

---

### 3. Handling Edge Cases

- **If stock depletes to 0 at any round**, action is irrelevant; game effectively ends. Continue defecting to maintain strategy alignment.

- **If all other players defect (D_count_{t-1} = n - 1)**:

  - Defect too, no incentive to cooperate with defectors.

- **If all other players cooperate (C_count_{t-1} = n - 1)**:

  - Defect to exploit cooperative majority and maximize individual payoff.

---

### 4. Pseudocode

```python
def aggressive_strategy(t, r, S_t, n, capacity, Actions_prev):
    # Count cooperators and defectors in previous round
    if t == 1:
        # First round: defect unconditionally
        return 'D'

    C_count = Actions_prev.count('C')
    D_count = n - C_count

    # Last round: defect unconditionally
    if t == r:
        return 'D'

    # Define thresholds
    high_stock = 2 * n          # double number of players
    moderate_stock = n          # number of players

    # Assess stock category
    if S_t > high_stock:
        # High stock case: defect to maximize immediate payoff
        return 'D'

    elif moderate_stock < S_t <= high_stock:
        # Moderate stock case: check prior cooperation and stock trends
        
        # First compute stock depletion ratio from last round (approximate):
        # Assumes we know stock before last round: S_prev
        # For strategic purposes, approximate as:
        # stock_drop_ratio = (S_prev - S_t) / S_prev
        # Since S_prev unknown here, rely on Actions_prev:
        # Calculate approximate total consumption last round:
        consump_per_c = S_t / (2 * n)   # approx if cooperators consumed according to current stock
        consump_per_d = S_t / n
        total_consumption = C_count * consump_per_c + D_count * consump_per_d

        # This is an approximation and used only for decision logic.
        # If many cooperators (C_count >0) and total consumption > 25% of stock,
        # defect aggressively to exploit.
        if C_count > 0 and total_consumption > 0.25 * S_t:
            return 'D'
        else:
            # Cooperate only if stock after expected consumption and growth stays above n
            expected_stock_after_consumption = S_t - (C_count * (S_t/(2*n)) + D_count * (S_t/n))
            growth = 2 * expected_stock_after_consumption * (1 - expected_stock_after_consumption / capacity)
            expected_new_stock = min(expected_stock_after_consumption + growth, capacity)

            if expected_new_stock > moderate_stock:
                return 'C'
            else:
                return 'D'

    else:
        # Low stock (≤n) case: defect unconditionally to maximize final payoffs
        return 'D'
```

---

### 5. Explanation Summary

- The aggressive strategy **defaults to defecting** to gain maximum immediate payoff.
- It **only cooperates sparingly** when the stock is moderate and cooperation can prolong resource availability enough to boost cumulative payoff.
- In the **last round**, defect to extract maximum.
- It **exploits cooperative opponents** by always defecting when cooperators are present.
- It **ignores long-term sustainability** once resource stock is low, acting purely to maximize immediate gains.
- The strategy uses **stock thresholds based on number of players** to make nuanced decisions balancing exploitation and minimal cooperation to sustain resource where profitable.

---

Let me know if you want me to expand with more details or alternative formulations.
'''

description_AGGRESSIVE_8 = '''
Below is an **aggressive strategy** for the described Common Pool Resource Game. It is designed to maximize own short-term payoffs by defecting (harvesting larger shares) as long as it is profitable, while recognizing the risk of stock depletion and final-round behavior, with minimal regard for preserving the resource or cooperation.

---

## Intuition / High-Level Summary

- **Aggressive core:** Always defect (choose D) whenever possible to maximize immediate payoffs per round.
- **Final round:** Defect regardless, since no future incentives remain.
- **Avoid "wasting" the last round:** If stock is too low to yield positive payoff when defecting (i.e., stock < 1), cooperate to extend stock growth—but this is rare.
- **Adaptation to stock level:** Defect unless stock is extremely depleted (close to zero), then cooperate just enough to avoid zero growth if it benefits final round payoffs slightly.
- **Ignore opponents' past actions:** Since no cooperation incentives or punishments are intended.
- **First round:** Start defecting outright.

---

## Decision Rules

### Notation

- Let **t** = current round ∈ {1,...,r}
- Let **S_t** = current stock at start of round t
- Let **capacity** = max stock level
- Let **n** = number of players
- Actions per player: C or D

---

### Strategy Description

```
For each round t from 1 to r:

    If t == r (last round):
        Action = D
        // No future rounds, so aggressively defect to maximize last payoff.

    Else if S_t < 1:
        // Stock almost depleted: defecting yields payoff ~ 0 or negative growth,
        // cooperate to allow slight stock recovery growth if possible.
        Action = C

    Else:
        Action = D
        // Default aggressive stance: defect to maximize immediate payoff.

End For
```

---

### Explanation

- **At the start (round 1):** No history or trust, so defect immediately.
- **Mid-game rounds:** Defect aggressively to maximize payoffs and reduce the resource quickly.
- **When stock dangerously low (below 1):** Defecting yields tiny or zero payoffs, so cooperate to keep stock from crashing to zero prematurely, potentially yielding slightly higher payoffs in the next rounds. This act is purely self-interested and tactical—no trusting or norm enforcement.
- **Last round:** No incentive to preserve long-term stock; defect fully.

---

## Rationale for Threshold (S_t < 1)

- Defect payoff in round t is π_i = S_t / n
- For small S_t < 1, the defector payoff becomes less than 1/n, which is minimal.
- Cooperating consumes half the defect consumption (S_t / (2n)), but potentially benefits next round’s stock growth if there were one.
- Since last round no growth matters, cooperate only when stock almost zero to minimally sustain stock and increase expected payoffs in upcoming rounds (if any).
- Given that r > 1 and growth depends on leftover stock, we act aggressively except when stock is near zero.

---

## Optional: Ignoring Opponents’ Past Actions

- No reaction or retaliation to other players’ actions.
- Assumes maximally myopic and aggressive behavior.

---

## Summary

| Round        | Stock Condition | Action  | Reason                                 |
|--------------|-----------------|---------|--------------------------------------|
| Any < r      | S_t < 1         | C       | Avoid zero stock, preserve minimal growth |
| Any < r      | Otherwise       | D       | Maximize immediate payoff aggressively    |
| Last round r | Any             | D       | No future, defect fully                      |

---

## Pseudocode

```python
def aggressive_strategy(t, r, S_t, n, capacity):
    # t: current round (1-based)
    # r: total rounds
    # S_t: current stock level at round t start
    # n: number of players
    
    if t == r:
        return 'D'  # Always defect last round
    
    if S_t < 1:
        return 'C'  # Cooperate to preserve minimal stock
    
    return 'D'      # Defect aggressively otherwise
```

---

This strategy is **consistently aggressive**, seeks to maximize immediate payoffs by defecting as much as possible until the stock becomes too low to yield meaningful returns, then cooperates only as a tactical move to prolong minimal resource availability. It holds no illusions of cooperation or reciprocity and is designed to dominate in competitive settings without coordination or trust.
'''

description_AGGRESSIVE_9 = '''
Here is an aggressive strategy tailored to the Common Pool Resource Game:

---

### Strategy Name: **Defect-First, Punish-Last (DFPL)**

---

### Intuition:

- The aggressive player prioritizes short-term gain over sustainability.
- Defects from the start to maximize immediate payoff.
- Uses defection throughout except in the last round, where cooperation avoids leaving the stock depleted after the game (which may provide reputational or indirect benefits in the tournament if payoffs are considered collectively).
- Reacts harshly only if stock runs critically low, to cause a "scarcity shock" reducing others' payoffs.

---

### Detailed Decision Rules:

#### Initialization:

- **Round counter:** t = 1
- **Initial stock:** S_1 = capacity

#### At each round t (1 ≤ t ≤ r):

1. **Evaluate Stock Level:**  
   Let current stock be S_t (available from previous round dynamics).

2. **Decision for rounds 1 to r-1:**

   - **If stock is critically low:**  
     Define a critical threshold, e.g.  
     \[
       S_t < \alpha \times capacity
     \]  
     with \(\alpha = \frac{n}{capacity}\) (a very small fraction reflecting consumption scale). For instance, \(\alpha = 2n / capacity\), or simply a fixed threshold like 10% of capacity.

     Then:  
     **Defect (D) to accelerate depletion**, causing a "scarcity shock" to punish cooperators who may be trying to sustain.

   - **Otherwise (stock above critical threshold):**  
     Always **Defect (D)** to maximize immediate per-round payoff.

3. **Decision for final round t = r:**

   - To maximize last round payoff and avoid stock collapse after the game, **Cooperate (C)**.
   
   - Rationale: Defecting last round yields max immediate payoff but leaves stock depleted, ending the game with a "bad reputation" (if social norms or tournament scoring factor in sustainability) or no benefit in further iterations. Cooperation at last round conserves some resource which could be beneficial if tournament scoring aggregates (e.g., encourages sustainability).

---

### Summary of Behavior by Round:

| Round          | Action                        | Reasoning                                         |
|----------------|-------------------------------|--------------------------------------------------|
| 1 to r - 1     | Always Defect (D)              | Aggressively maximize immediate payoff           |
| If stock low   | Defect (D)                    | Punish by accelerating depletion                  |
| r (last round) | Cooperate (C)                 | Preserve resource to soften end-game impact       |

---

### Pseudocode:

```python
def aggressive_strategy(t, r, S_t, capacity, n):
    # Parameters
    critical_threshold = 0.1 * capacity  # threshold for "critically low" stock

    if t == r:
        # Last round: cooperate to preserve some stock post-game
        return 'C'
    
    if S_t < critical_threshold:
        # Stock critically low: defect to punish and enforce scarcity
        return 'D'
    
    # Otherwise: defect aggressively for immediate gain
    return 'D'
```

---

### Additional Notes:

- The threshold can be tuned experimentally; the idea is to be aggressive until stock approaches collapse, then double down defecting to punish anyone cooperating.
- This strategy does **not** try to maintain or restore stock actively — that is left to others.
- It exploits cooperators by defecting early (higher per-round payoff: S_t / n versus S_t / (2n)).
- Cooperation only at the end helps avoid complete ruin, potentially moderating total payoff loss.

---

This strategy captures an **uncompromising aggressive stance**: prioritize short-term gain, punish stock sustainability attempts by others, and only moderate behavior minimally at the terminal round.
'''

description_AGGRESSIVE_10 = '''
Below is an aggressive strategy designed for the specified Common Pool Resource Game, built to maximize individual payoffs by predominantly defecting, while only cooperating tactically to maintain the resource stock enough to exploit it in future rounds.

---

## Aggressive Strategy: "Sustained Defector with Strategic Cooldown"

### Overview
- **Core mindset:** Always defect to consume the maximum allowed share each round, aggressively pursuing high immediate payoffs.
- **Sustainability twist:** Occasionally cooperate only when the stock is critically low to allow limited resource regeneration, preventing total depletion that would end future payoffs.
- **Temporal adaptation:** Defect throughout almost all rounds except the final round, where defecting maximizes endgame payoff.

---

### Detailed Decision Rules

**Notation:**

- `t`: current round (1 ≤ t ≤ r)
- `S_t`: current stock at round t (before players consume)
- `capacity`: maximum sustainable stock
- `threshold_stock`: predefined critical stock level to trigger cooperation, set to `capacity / (2n)` (half the cooperative consumption per player)
- `last_round = r`

---

### 1. First Round (t = 1)

- **Defect**: Start aggressively to maximize first-round payoff.
  
```pseudo
if t == 1:
    play D
```

---

### 2. Intermediate Rounds (1 < t < r)

- Observe the current stock `S_t`.
  
- **If stock is above or equal to the threshold_stock:**

  - **Defect**: Continue to consume heavily since there's enough resource.
  
- **If stock falls below threshold_stock (critical depletion):**

  - **Cooperate** (play C) this round to reduce consumption demand.
  - This gives the stock a chance to partially regenerate before you resume defecting.
  - This cooperation is a tactical cooldown, not trust-based.

```pseudo
if 1 < t < r:
    if S_t >= threshold_stock:
        play D
    else:
        play C
```

---

### 3. Final Round (t = r)

- **Defect**: No future rounds remain, so greedily maximize final payoff regardless of stock state.

```pseudo
if t == r:
    play D
```

---

### Handling Edge Cases

- **Stock is zero or extremely low (S_t <= 0):**

  - Cooperation or defection have no payoff impact since no stock remains.
  - Still **defect** to maintain consistent aggressive posture, as cooperation yields no advantage.
  
- **All other players defect continuously (worst case for resource sustainability):**

  - The stock will plunge rapidly.
  - The strategy’s cooldown cooperation at critical low stock prevents immediate extinction whenever possible, buying occasional resource regrowth.
  
- **If other players cooperate at first round or later rounds:**

  - The strategy ignores cooperation signals because it exploits defecting immediately.
  
---

### Pseudocode Summary

```pseudo
Input: current round t, current stock S_t, total rounds r, capacity, n

threshold_stock = capacity / (2 * n)
last_round = r

if t == 1:
    action = D

else if 1 < t < last_round:
    if S_t >= threshold_stock:
        action = D
    else:
        action = C

else if t == last_round:
    action = D

return action
```

---

### Rationale Summary:

- Defecting maximizes immediate personal payoff each round.
- Occasional forced cooperation only occurs when continuing to defect risks collapse of the resource, which would eliminate all future payoffs.
- Ending with a defection round exploits final resource value, maximizing terminal payoff (since no future rounds remain).
- Does not rely on cooperation from others and ignores attempts at mutual cooperation.
- Uses minimal cooperation purely as a tactical, self-serving resource management to prolong exploitable resource life, embodying an aggressive exploitation mindset.

---

This approach is guaranteed to maximize individual payoff under aggressive behavior assumptions, balancing ruthlessness with strategic resource preservation just enough to enable continued exploitation.
'''

description_AGGRESSIVE_11 = '''
**Aggressive Strategy Design for the Common Pool Resource Game**

---

### Strategy Overview

This strategy aggressively prioritizes immediate and maximum payoff by defecting (D) as often as possible to consume a larger share of the common pool. It exploits the opportunity to maximize individual gain, even at the risk of depleting the resource or reducing future payoffs for all players, including itself.

The strategy recognizes the dynamic stock and the repeated nature but does **not** cooperate early on or form cooperation norms. It only modifies behavior under a strict survival condition near the endgame to avoid losing all remaining payoff opportunities.

---

### Decision Rules

| Round Condition               | Decision                    | Rationale                                                                                     |
|------------------------------|-----------------------------|-----------------------------------------------------------------------------------------------|
| **First Round (t=1)**          | Defect (D)                  | No history of cooperation; maximize immediate personal gain.                                  |
| **Middle Rounds (1 < t < r)** | Defect (D)                  | Continue maximizing payoff aggressively without cooperation, regardless of others’ actions.   |
| **Final Round (t = r)**        | Defect (D) if stock > 0; else Cooperate (C) or any action | If stock has already been exhausted (rare), cooperate causes no harm. Otherwise, defect to maximize last payoff. |

---

### Justification & Aggressiveness

- **Always defect** to consume `stock/n` shares, which is double the payoff compared to cooperating (`stock/(2n)`).
- No cooperation signals or forgiveness mechanisms to maintain aggressive stance.
- Ignores attempts by others to cooperate — exploits their cooperation.
- Only considers resource stock in the last round to possibly avoid wasting resource if stock is zero (no gain from defecting).
- Does not attempt complex reputation-building or punishment since it assumes no coordination.

---

### Handling Edge Cases

- **Resource depleted before last round**: If stock = 0 (which can happen under aggressive defection by others), no payoff can be gained regardless of action. Default to defect since no cost is involved (consumption zero).
- **Single round games (r=1)**: Simply defect to maximize the one-shot payoff.
- **No cooperation history or no information about others**: Always defect.
- **Stock approaching zero mid-game**: No change, remain defecting; aggressively consume whatever is available, accepting stock depletion.

---

### Pseudocode Representation

```python
def aggressive_strategy(round_number, final_round, current_stock, capacity, n, history):
    """
    Parameters:
    - round_number: current round (1-based index)
    - final_round: total number of rounds r
    - current_stock: current stock level S
    - capacity: maximum sustainable stock
    - n: number of players
    - history: list of tuples (actions of all players in previous rounds)

    Returns:
    - action: 'D' for defect or 'C' for cooperate
    """
    
    # Always defect, except if no stock remains in last round (then cooperate or defect is irrelevant)
    if round_number == final_round:
        if current_stock > 0:
            return 'D'
        else:
            # Stock exhausted - no payoff either way
            return 'D'  # or 'C' (indifferent)
    else:
        return 'D'
```

---

### Summary

- **Core rule:** Defect every round.
- **No conditional cooperation** or punishment.
- **Ignore opponents’ past actions.**
- **Only check stock in last round for trivial edge case.**
  
This strategy embodies an aggressive mindset by maximizing individual short-term gains at the likely cost of resource depletion and lower future payoffs, exhibiting pure self-interest without regard for sustainability or cooperation.
'''

description_AGGRESSIVE_12 = '''
Below is an **aggressive strategy** designed for the given Common Pool Resource game. The goal of this strategy is to maximize individual total payoff aggressively by exploiting the resource heavily and aggressively punishing any signs of cooperation or leniency by others, without concern for sustaining the resource. This strategy trades potential long-term sustainability for short-term gain — typical of an aggressive mindset.

---

## Aggressive Strategy Description

### Intuition
- **Always defect (D)** initially to maximize immediate payoff.
- If others retaliate by defecting (which is likely), continue defecting since cooperation is not rewarded aggressively.
- If all others cooperate, exploit them as much as possible by defecting.
- On the last round, defect regardless because no future consequence exists.
- If the stock ever reaches critically low levels (near zero), continue defecting anyway because there's no incentive to conserve a depleted resource — maximize extraction now.
- Never cooperate.

---

### Formal Decision Rules

At round *t* with current stock *S* and history of opponent actions:

1. **First round (t = 1):**  
   Play **D** (defect).

2. **Intermediate rounds (1 < t < r):**  
   - Inspect opponents' past actions in round (t-1):
     - If any opponent played **D** → play **D** (punish any cooperation by defecting)
     - Else (all opponents played **C**) → still play **D** to exploit cooperators.
   - If stock S is ≤ (n × S / capacity) threshold very low (e.g. < 10% capacity), still defect since resource is nearly depleted.

3. **Last round (t = r):**  
   Play **D** (defect) unconditionally for maximum immediate gain.

---

### Edge cases handling

- When the stock approaches zero or is zero, no incentive to cooperate; continue defecting.  
- Since payoff for defecting ≥ payoff for cooperating in any round for given stock level, cooperation is dominated; thus never cooperate.  
- Use perfect information about previous actions for punishing cooperation by others with continued defection.

---

### Pseudocode

```python
def aggressive_strategy(t, r, S, capacity, n, history):
    """
    t: current round (1-based)
    r: total rounds
    S: current stock level (float)
    capacity: max sustainable stock level
    n: number of players
    history: list of lists of opponent actions for past rounds
             e.g., history[t-2] = [a_1, a_2, ..., a_(n-1)] actions at round t-1
    
    Returns: 'C' or 'D'
    """
    
    # Define low stock threshold (e.g., 10% of capacity)
    LOW_STOCK_THRESHOLD = 0.10 * capacity
    
    # Last round: always defect
    if t == r:
        return 'D'
        
    # First round: always defect
    if t == 1:
        return 'D'
    
    # If stock very low, no incentive to cooperate
    if S <= LOW_STOCK_THRESHOLD:
        return 'D'
    
    # Check opponents' previous round actions
    # All opponents' actions for round t-1
    previous_actions = history[t-2]  # zero-based index
    
    # If any opponent defected last round, defect now
    if 'D' in previous_actions:
        return 'D'
    else:
        # All cooperated last round, exploit by defecting
        return 'D'
```

---

### Summary

- This aggressive strategy **always defects.**
- It never cooperates to maximize per-round payoff.  
- It exploits cooperators and punishes any attempted cooperation by defecting in response immediately.  
- On the last round or when resource is mostly depleted, it defects to grab maximum short-term payoff.  

This strategy represents a strongly selfish, aggressive exploitation approach with no attempts to sustain the resource or cooperate for mutual benefit. It maximizes immediate gain regardless of future sustainability.
'''

description_AGGRESSIVE_13 = '''
Below is a detailed description of an **aggressive strategy** tailored to this Common Pool Resource Game.

---
## Aggressive Strategy Overview

**Main idea:**  
Prioritize maximal immediate extraction by defecting (taking a larger share) unless cooperation is guaranteed to sustain a high stock to repeatedly exploit. Use defection to punish cooperation when others try to conserve. Toward the end of the game, shift fully to defection to maximize final payoff before no future rounds remain.

---

## 1. Decision Rules

- **Round 1 (initial round):**  
  *Defect* unconditionally. Start aggressive to signal no initial cooperation and maximize immediate payoff.

- **Rounds 2 to r-1 (intermediate rounds):**  
  - If in the previous round **all** other players cooperated (played C), then cooperate this round for a constant stock recovery, enabling better harvest next round.  
  - Otherwise (if any player defected last round), defect this round to exploit cooperators and punish defectors (no benefits from conservation without reciprocation).  
  - Additionally, **if the common pool stock falls below a threshold**, defect anyway to grab remaining resources before depletion (a form of "race to the bottom").  
    - Suggested threshold: stock < capacity / 2 (half capacity). Aggressive mindset prefers grabbing before it shrinks more.

- **Final round (round r):**  
  Defect unconditionally to maximize final round payoff, as no future rounds benefit from conserving stock.

---

## 2. Handling Edge Cases

- **First round:**  
  No history, so defect immediately.

- **Last round:**  
  Defect always, regardless of history or stock, to extract maximum immediate payoff.

- **Low stock / near depletion (stock < capacity/2):**  
  Defect even if others cooperated last round, intent to grab maximum payoff before stock collapses.

- **Unusual histories (e.g., all defection multiple rounds):**  
  Continue defecting: no incentive to cooperate with persistent defectors.

- **If stock ever reaches zero:**  
  Defect is moot (payoff zero). Strategy remains defect by default; no cooperation since stock=0.

---

## 3. Pseudocode

```python
def aggressive_strategy(round_number, total_rounds, last_round_actions, current_stock, capacity, num_players):
    """
    round_number: int, current round index (1-based)
    total_rounds: int, total number of rounds r
    last_round_actions: list of length n of {'C','D'} for previous round (None if round 1)
    current_stock: float, current common pool stock S
    capacity: float, maximum sustainable stock level
    num_players: int, number of players n
    Returns: 'C' or 'D' action for this round
    """

    # Parameters
    stock_threshold = capacity / 2  # threshold for aggressive extraction

    # 1. First round: defect unconditionally
    if round_number == 1:
        return 'D'

    # 2. Last round: defect unconditionally
    if round_number == total_rounds:
        return 'D'

    # 3. Intermediate rounds:

    # Check if all other players cooperated last round
    # (exclude own last action if available; if not known, assume including self)
    if last_round_actions is None or len(last_round_actions) != num_players:
        # Defensive fallback: defect
        return 'D'

    # Assuming player knows all actions, including own; remove own last action from check
    # but typically player knows own last action; if not available, consider all players
    # Here we conservatively consider all players' actions
    all_cooperated = all(a == 'C' for a in last_round_actions)

    # Stock below threshold triggers aggressive defection
    if current_stock < stock_threshold:
        return 'D'

    if all_cooperated:
        # Cooperate this round to sustain stock and future payoffs
        return 'C'
    else:
        # Defect to exploit and punish
        return 'D'
```

---

## Explanation of Aggressiveness

- Beginning defect forces other players to face aggressive extraction early.  
- Cooperation is only rewarded if everyone previously cooperated, encouraging conditional cooperation—but since starting move is defect, cooperation is hard to establish, preserving an aggressive stance.  
- Defecting below half capacity signals a "grab what you can before it runs out" mentality.  
- Final round defection maximizes last-moment payoff with no concern about stock regeneration.  
- Punishes attempts to cooperate with defection, maintaining dominance in resource capture over the repeated game.

---

## Summary

| Situation                      | Action        | Reason                                         |
|-------------------------------|---------------|------------------------------------------------|
| Round 1                       | Defect (D)    | Aggressively begin extracting                  |
| Final round (round r)          | Defect (D)    | Maximize end-game payoff                        |
| All others cooperated last round & stock ≥ capacity/2 | Cooperate (C) | Sustain stock common good for exploitation     |
| Otherwise                    | Defect (D)    | Exploit cooperators and punish defectors       |
| Stock < capacity/2 (any round after first) | Defect (D)    | Race to extract before collapse                 |

This strategy embodies an **aggressive**, self-interested approach maximizing immediate payoffs while conditionally cooperating only to sustain exploitable stock levels. It exploits opponents who try to cooperate but punishes defection through non-cooperation.

---

If you want, I can provide variants with tuning parameters or deeper analysis, but this aggressive rule set is a strong baseline for tournament play.
'''

description_AGGRESSIVE_14 = '''
Below is a description and pseudocode of a deliberately aggressive strategy for the Common Pool Resource (CPR) Game under your specification.

---

## Strategy Name: Defect-Until-Last-Round / Exploit & Pump

### Strategy Intuition
- **Aggressiveness:** Always defect (consume large share) as often as possible to maximize immediate payoff.
- **Sustainability:** Try to preserve the resource only if approaching the last round to avoid losing payoff entirely — but even then defect on last round for maximum gain.
- **No cooperation until forced:** Never cooperate to "slow down" consumption or protect the stock since coordination is unavailable and opponents may exploit cooperation.
- **Edge case handling:** 
  - First round: defect to get early maximum gain.
  - Penultimate round: check stock and only cooperate if stock dangerously low to allow at least some payoff in last round.
  - Last round: defect regardless to get max final payoff.
- Explicitly ignore potential forgiveness or tit-for-tat — aggressively exploit at every opportunity.

---

### Detailed Decision Rules

For round `t` in `{1, 2, ..., r}` with current stock `S`:

1. **If `t` < `r - 1` (All rounds but last two rounds):**  
   - **Action:** Always defect (`D`) to maximize immediate payoff (consume `S/n`).
   
2. **If `t == r - 1` (Penultimate round):**  
   - Estimate if defecting will reduce stock too much risking zero or near-zero stock in last round:
     - Compute hypothetical stock after defecting this round and defecting next round (last round).
     - If stock conservation is necessary to secure payoff in last round, **cooperate (`C`) this round** to conserve stock.
     - Else, defect (`D`).

3. **If `t == r` (Last round):**  
   - Always defect (`D`) to maximize payoff since no future rounds.

---

### Rationale for Penultimate Round Check

Define:

- Consumption by defect (D): `cD = S / n`
- Consumption by cooperate (C): `cC = S / (2n)`
- To decide cooperation in penultimate round, simulate two rounds ahead with:

  - If defect now and defect next round:
    - Stock after current consumption: `S1 = S - n * (S / n) = S - S = 0`
    - New stock after growth: zero --> 0
    - Last round payoff = 0

  - If cooperate now and defect next round:
    - Stock after current consumption: `S1 = S - n * (S / (2n)) = S - S/2 = S/2`
    - Growth = `2 * S1 * (1 - S1 / capacity)`
    - New stock last round = `S2 = min(S1 + growth, capacity)`
    - Last round payoff = `S2 / n` (if defect last round)

If last round payoff with cooperating penultimate round is meaningfully better than 0, cooperate in penultimate round.

---

### Pseudocode

```python
def aggressive_strategy(t, r, S, capacity, n):
    """
    t -- current round (1-based)
    r -- total rounds
    S -- current stock before player consumption
    capacity -- max sustainable stock
    n -- total players
    
    Returns: 'C' or 'D' (cooperate or defect)
    """
    
    # Consumption if defect now
    cD = S / n  
    # Consumption if cooperate now
    cC = S / (2 * n)
    
    if t < r - 1:
        # Early and mid game: always defect aggressively
        return 'D'
    
    elif t == r - 1:
        # Penultimate round: simulate two cases
        
        # Case 1: Defect now and defect last round
        S1_def_def = max(S - n * cD, 0)
        growth1 = 2 * S1_def_def * (1 - S1_def_def / capacity)
        S2_def_def = min(S1_def_def + growth1, capacity)
        last_round_payoff_if_def_def = S2_def_def / n
        
        # Case 2: Cooperate now and defect last round
        S1_coop_def = max(S - n * cC, 0)
        growth2 = 2 * S1_coop_def * (1 - S1_coop_def / capacity)
        S2_coop_def = min(S1_coop_def + growth2, capacity)
        last_round_payoff_if_coop_def = S2_coop_def / n
        
        # Threshold decision: if cooperating penultimate round yields positive last round payoff 
        # much greater than zero, cooperate now; else defect now
        # Define "meaningfully better" as last_round_payoff_if_coop_def >= last_round_payoff_if_def_def + epsilon
        epsilon = capacity * 0.01  # small threshold ~1% capacity
        
        if last_round_payoff_if_coop_def > last_round_payoff_if_def_def + epsilon:
            return 'C'
        else:
            return 'D'
        
    else:
        # Last round: always defect for maximum payoff
        return 'D'
```

---

### Summary

| Round          | Action                               | Reasoning                                  |
|----------------|------------------------------------|--------------------------------------------|
| 1 to r-2       | Defect                             | Maximize short-term payoff aggressively.   |
| r - 1 (penult) | Cooperate only if saved stock secures significant last-round payoff; else defect | Preserve resource if it yields actual last-round gain.                  |
| r (last)       | Defect                             | No future rounds, so maximize immediate payoff.  |

---

This strategy embodies aggressive, exploitative behavior, prioritizes short-term gain, and only slows down defecting when it is pragmatically necessary to secure any final payoff. It assumes no trust or cooperation from others and tries to maximize total personal payoff under given constraints.
'''

description_AGGRESSIVE_15 = '''
Below is an aggressive strategy designed for the Common Pool Resource Game described, aligned with an aggressive mindset to maximize individual payoffs by prioritizing defection while exploiting cooperation when possible.

---

### Aggressive Strategy Description

**Core idea:**  
Defect as often as possible to maximize immediate payoff, but exploit opportunities to defect against presumed cooperators and reduce cooperation only when the resource stock is critically low or the game is near the end, to avoid self-damaging outcomes in the last rounds.

---

### 1. Decision Rules: When to cooperate vs defect

- **First round:**  
  - **Defect.** There is no precedent, so seize maximum payoff immediately.

- **Intermediate rounds (2 to r-1):**  
  - **Defect, unless the stock is critically low (warning threshold).**  
  - If stock is low enough that defecting risks destroying the pool in the next round and causing zero payoffs overall, **cooperate to sustain the resource**, but only enough to avoid permanent depletion.
  
- **Last round (round r):**  
  - **Defect unconditionally.** No future rounds remain, so maximize immediate payoff.

- **Stock-based adjustment:**  
  - Define a **warning threshold** for stock \( S_{warn} \), e.g. \( S_{warn} = capacity / (2n) \times n \), approximating the minimum stock needed to safely defect without full depletion.  
  - If current stock \( S_t \leq S_{warn} \), cooperate to reduce exploitation and keep stock from collapsing prematurely.

- **Opponent action history exploitation:**  
  - Track opponents’ previous actions.  
  - If a player has cooperated in the previous round, attempt to defect against them to gain a higher payoff.  
  - Since actions are simultaneous, you cannot condition your action on individual players directly, but you can infer population tendencies:  
    - If the last round showed many defectors, continue defecting aggressively; if many cooperated, remain aggressive but alert for stock depletion.

---

### 2. Edge Cases Handling

- **First round:**
  - Defect by default, no past info.

- **Very low stock rounds:**
  - Avoid last-minute depletion by cooperating if stock is below \( S_{warn} \).
  - This delays total collapse and allows some payoff over later rounds if any remain.

- **Last round:**
  - Always defect. No incentive to cooperate as there is no future payoff to protect.

- **If stock reaches zero before last round:**
  - Payoffs will be zero regardless of choice; defect anyway as there's nothing to lose.

---

### 3. Aggressiveness Alignment

- Prioritize defection almost every round for higher immediate returns (consume \( \frac{S}{n} \) instead of \( \frac{S}{2n} \)).

- Only cooperate to avoid complete destruction of the resource, which is a strategic preservation move necessary for continued exploitation, not altruism.

- Never forgive defecting behaviors; no incentives to cooperate based on history except stock preservation.

---

### Pseudocode

```python
# Inputs available each round t:
# S_t: current stock level
# capacity: max stock
# r: total rounds
# t: current round (1-based)
# history_actions: list of sets of actions chosen by all players in previous rounds

def aggressive_strategy(S_t, capacity, r, t, history_actions):
    n = number_of_players  # known parameter

    # Calculate warning threshold for stock to trigger "cooperate-to-survive"
    # Minimum stock needed so that total defect consumption = S / n * n = S, which depletes stock completely
    # So be conservative: if stock < capacity/(4n)*n = capacity/4 heuristically
    S_warn = capacity / 4

    # Last round: no incentive to cooperate; defect always
    if t == r:
        return "D"

    # First round: defect immediately
    if t == 1:
        return "D"

    # If stock is below warning threshold, cooperate to avoid total depletion
    if S_t <= S_warn:
        return "C"

    # Otherwise, defect aggressively
    return "D"
```

---

### Summary

- **Generally defect every round to maximize extraction.**
- **Cooperate only to preserve the resource when stock is dangerously low.**
- **Always defect in first and last rounds.**
- **No attempts to punish or reward based on opponent history — pure payoff maximization.**
- **Aggressive consumption balanced only by self-preservation logic.**

This approach capitalizes on the dominance of defection for immediate profits, with minimal strategic concessions to stock sustainability only when necessary. It will perform well against cooperative or mixed strategies by exploiting them, while defection-only strategies are matched or outpaced by the preservation in low-stock scenarios.
'''

description_AGGRESSIVE_16 = '''
Below is a detailed design of an **aggressive strategy** for the specified Common Pool Resource Game.

---

## Aggressive Strategy: "Defect Unless Last Round Cooperative"

### High-level intuition

- The aggressive mindset prioritizes **maximizing own payoff each round**, disregarding sustainability and collaborators.
- Defection yields double the payoff per round compared to cooperation (given same stock).
- Since opponents may respond similarly aggressively, mutual defection can rapidly deplete the resource.
- However, in the **last round**, there is no future retaliation or benefit from stock replenishment, so maximizing immediate payoff with defection is always best.
- In early rounds, defect by default to exploit the higher immediate payoff.
- Introduce a minimal concession: If in the previous round **all other players cooperated**, cooperate this round to marginally sustain the resource (attempt a short-term "collaborative" exploitation), but still defect as soon as any defection is detected.
- This concession only applies from round 2 onward — first round is pure defection.
- The goal: extract maximum payoffs aggressively, exploiting others if they cooperate, but punishing any detected defection by defecting immediately.

---

### Formal Description

**Parameters known:**  
- n = number of players ≥ 2  
- r = total rounds (>1)  
- capacity = max stock ≥ 2n  
- Observed history: all players’ actions in all previous rounds  

**Action set:** A_i = {C, D}

---

### Decision Rules

Let `t` be the current round index (1 ≤ t ≤ r).  
Let `actions_previous_round` be the vector of opponent actions in round `t-1` (if t > 1).

**At round 1 (t = 1):**  
- Play **D** (defect).  
Rationale: no prior information, be maximally aggressive.

**At rounds 2 to r-1 (1 < t < r):**  
- If **all other players cooperated** in round t-1:  
  → Play **C** (cooperate) this round, to allow potential short-term resource replenishment and entice cooperation.  
- Else (at least one other player defected in round t-1):  
  → Play **D** (defect), to punish defection and maximize immediate payoff.  

**At last round (t = r):**  
- Regardless of history, play **D** (defect).  
Rationale: no future consequences; maximize immediate gains.

---

### Pseudocode

```python
def aggressive_strategy(t: int, r: int, player_index: int, 
                       history: List[List[str]]) -> str:
    """
    Inputs:
    - t: current round number (1-based)
    - r: total rounds
    - player_index: index of this player (1-based)
    - history: list of lists; history[k] = actions by all players at round k+1,
               each action in {"C", "D"}

    Returns:
    - "C" for cooperate or "D" for defect
    """

    if t == 1:
        # Round 1: no info, defect aggressively
        return "D"

    elif t == r:
        # Last round: maximize payoff, defect regardless
        return "D"

    else:
        # Intermediate round: check previous round actions of others
        prev_actions = history[t - 2]  # zero-indexed; t-1 th round stored at t-2
        other_players_actions = [a for i, a in enumerate(prev_actions) if (i+1) != player_index]

        if all(action == "C" for action in other_players_actions):
            # All others cooperated last round, reciprocate cooperation
            return "C"
        else:
            # At least one other defected last round, punish by defecting
            return "D"
```

---

### Summary of Strategy Properties

| Round       | Condition                      | Action |
|-------------|--------------------------------|--------|
| 1           | No previous info               | D      |
| 2 to r-1    | All others cooperated previous | C      |
| 2 to r-1    | Otherwise                     | D      |
| r (last)    | Always                       | D      |

- **Aggressiveness:** Defects by default, punishes defection harshly, only lightly "cooperates" if all others cooperated last round.
- **Sustainability:** Neglected from the perspective of maximizing own returns; cooperation is tactical to slightly delay depletion, but only if others are altogether cooperative.
- **Exploitative:** Gains more payoff exploiting cooperators, punishes defectors to gain relatively higher share.
- **Simplicity:** Requires only 1-step memory of opponents’ actions.

---

### Rationale / Behavioral Notes

- Because defectors consume `stock/n` while cooperators consume half that `stock/(2n)`, defecting doubles individual immediate payoff, making it the greedy dominant move.
- However, all-defect leads to zero stock quickly, ending payoffs.
- This strategy tries to exploit any full cooperation for one round to regain some stock, but abandons cooperation immediately if any defection observed.
- Defection in last round is pure gain; no future round to consider.
- No trust or complex prediction assumed; reacts only to observed full cooperation.

---

This aggressive strategy is expected to perform well against more cooperative or forgiving strategies by taking advantage of their cooperation but punishes defectors to avoid exploitation. It balances pure selfishness with minimal tactical cooperation when conditions seem temporarily favorable.

---

If you want, I can also provide variants or extensions incorporating longer memory or probabilistic deviations. Just ask!
'''

description_AGGRESSIVE_17 = '''
Below is an **Aggressive Strategy** tailored for the Common Pool Resource Game as specified. It maximizes individual payoff by defecting as often as possible and exploiting cooperators, while also considering stock depletion risks and endgame behavior.

---

### Intuition and Summary of the Aggressive Strategy

- **Core mindset:** Always **defect** to maximize immediate payoff (consume S/n) except in the last round when stock might be depleted, or if the stock is critically low to avoid zero payoffs.
- **Exploit others:** Rely on the presence of cooperators to sustain the stock. Defecting players get twice the payoff per round compared to cooperators.
- **Edge cases:**
  - **First round:** Start by defecting, as no history exists.
  - **Last round:** Defect unless stock is zero (no payoff possible), then cooperate (or take the lesser consumption) to try to get a payoff rather than zero.
  - **Low stock threshold:** If stock is so low that defecting would consume more than remaining stock (or drop stock below zero), defect anyway because aggressive means prioritize own payoff even if causing stock collapse.
  - **If stock is zero:** Cannot consume, payoff zero — strategy still defects (no cooperative advantage).
- **Observe history:** No forgiveness or cooperation triggered; pure aggressive defection throughout unless forced by stock exhaustion.

---

### Decision Rules

Let:
- t = current round (1 ≤ t ≤ r)
- S_t = current stock at start of round t known to all
- actions_t-1 = vector of all players' actions in round t-1 (empty if t=1)
- capacity, n known constants

---

### Pseudocode Description

```
Input: round t, current stock S_t, total rounds r

Constants:
  coop_consumption = S_t / (2 * n)
  defect_consumption = S_t / n

Decision:

If t == r:  // Last round
    If S_t == 0:
        // Stock empty, no payoff possible
        Play Defect  // Don't "waste" cooperation, no difference
    Else:
        // Defect for max payoff
        Play Defect

Else:
    // Not last round: play Defect to maximize immediate consumption
    Play Defect


// Notes:
// - This aggressive strategy always defects to maximize payoff, regardless of history.
// - Does not cooperate or punish to preserve or rebuild stock.
// - Relies on others cooperating sometimes to prevent stock collapse in future rounds.
// - Even if stock collapses, aggressive strategy maximizes payoff before collapse.
```

---

### Explanation

- **Why always defect?** Defecting yields double payoff per round compared to cooperating, so maximizing individual gain.
- **Why no cooperation in last round?** No incentive to conserve stock, no future rounds to protect, so defect for max payoff.
- **Why no cooperation to sustain stock?** Aggressive mindset disregards sustainability for individual gain.
- **Why no conditional actions (like punishing defectors)?** Without communication or coordination, and no guarantee others will cooperate again, aggressive players don't risk reduced immediate payoffs.
- **Risk:** Stock may collapse early if all defect, but payoff maximized upfront.

---

### Variant (optional minor tweak for stock depletion)

If you want a minor nuance to avoid wasting actions when stock is zero:

```
If S_t == 0:
    // No payoff possible anyway, play Defect (or cooperate - no difference)
    Play Defect
Else if S_t < (some small threshold correlated to consumption):
    // Stock is critically low, but still Defect, consistent with aggressive
    Play Defect
Else:
    Play Defect
```

---

# Final note

This **pure defection aggressive strategy** is simple, clear, and maximizes immediate payoff, trusting that others' cooperation or slower depletion dynamics will sometimes preserve the stock — but never sacrificing own payoffs to maintain it.

---

If you want, I can help write this as compact formal pseudocode or detailed algorithmic steps next.
'''

description_AGGRESSIVE_18 = '''
Here is an aggressive strategy tailored for the described Common Pool Resource Game. It maximizes individual payoff by prioritizing defection (high consumption), exploiting cooperators, and leveraging the finite horizon effectively.

---

## Aggressive Strategy Description

### Intuition / Summary
- **Baseline choice:** Defect (D) to maximize immediate payoff.
- **Punish cooperators by defecting to exploit their lower extraction and maximize personal gain.**
- **Exploit known cooperators while defecting regardless of others' past actions; be relentlessly aggressive, but avoid pushing the pool to zero prematurely if it would reduce your total payoff over the remaining rounds.**
- **Consider the remaining rounds and resource stock to balance short-term gain vs. resource depletion.**
- **Defect always in the last round to grab maximum payoff without concern for future consequences.**

### Components

#### 1. First Round (t=1)
- Defect (D) outright: no history to consider, maximize immediate consumption.

#### 2. Intermediate Rounds (1 < t < r)
- Observe the previous round’s consumption pattern (who defected/cooperated).
- If the resource stock is still sufficiently high relative to remaining rounds, **defect to maximize immediate yield.**
- However, if the resource stock has fallen below a critical threshold such that defecting risks depleting the stock to zero before the game ends, **switch to cooperate (C) to allow resource regrowth, preserving value for subsequent rounds.**
- The threshold can be computed as follows:

    Let:
    - `T_remaining = r - t + 1` (including current round)
    - `stock = current resource stock`
    - `max_consume_if_defect = stock / n`
    - `expected_consumption_if_all_defect = n * max_consume_if_defect = stock`
      
    Since defecting by all players consumes the entire stock this round (leading to zero next round), this is a bad outcome if rounds remain.

- So, if
  ```
  stock <= capacity / (2 * T_remaining)
  ```
  then cooperate this round to preserve resource growth, else defect.

- Note: The factor `capacity / (2 * T_remaining)` is heuristic, chosen to ensure resource sustainability roughly proportional to remaining rounds.

#### 3. Final Round (t = r)
- Defect (D) regardless of stock or history to maximize final payoff; resource sustainability is irrelevant after the game ends.

---

## Pseudocode

```python
def aggressive_strategy(t, r, n, capacity, stock, history):
    """
    Inputs:
    - t: current round (1-indexed)
    - r: total rounds
    - n: number of players
    - capacity: resource capacity
    - stock: current resource stock before actions this round
    - history: list of past rounds actions per player, e.g.
               history[t-2] = [a_1, a_2, ..., a_n] for round t-1
    
    Returns:
    - 'C' or 'D' (cooperate or defect)
    """
    
    # 1. Last round: Defect no matter what
    if t == r:
        return 'D'
    
    # 2. First round: Defect
    if t == 1:
        return 'D'
    
    # 3. Intermediate rounds:
    T_remaining = r - t + 1  # including current round
    
    # Threshold heuristic to preserve resource if stock is low
    threshold = capacity / (2 * T_remaining)
    
    if stock <= threshold:
        # Stock is low: cooperate to allow recovery
        return 'C'
    else:
        # Otherwise defect to maximize payoff
        return 'D'
```

---

## Additional Notes

- **Aggressiveness:** This strategy defects almost always except when the resource stock is critically low, protecting payoff in the long run without being overly “nice.”
- **No forgiveness or retaliation:** The strategy does not change behavior based on other players’ actions beyond the resource state, simplifying decision and maximizing personal gain.
- **Resource management:** It avoids wrecking the resource pool early when multiple rounds remain, preserving opportunity for payoff in future rounds.
- **Exploitation:** When others cooperate, the defect choices earn more per round.
- **Exiting strategy:** Final round defect ensures max grab without regard for resource impact.

---

This satisfies all requested points:
- Decision rules clearly specified.
- Edge cases (first & last rounds) handled explicitly.
- Aggressive (selfish, exploitative) mindset clearly embraced.
'''

description_AGGRESSIVE_19 = '''
Below is a detailed description of an **aggressive strategy** for the Common Pool Resource Game that is designed to maximize individual payoff by prioritizing defection and exploiting opponents, with limited regard for sustainability or cooperation incentives.

---

## Aggressive Strategy Overview

**Core principle:**  
Always defect (D) to maximize immediate consumption unless defecting would yield no benefit because the common pool is effectively depleted or near zero, in which case cooperate (C) to conserve the remaining resource minimally and potentially enable a slight regrowth in future rounds.

---

## 1. Decision Rules

### Round 1 (Initial round):
- No past actions exist, so no data on others’ behavior.
- **Action:** Defect (D).  
Rationale: Maximize immediate payoff by extracting the largest share from full initial stock.

### Intermediate rounds (2 to r-1):
- Observe the current common pool stock, S_t.
- Calculate the expected gain from defecting vs cooperating given current stock (S_t).

Decision function at round t (2 ≤ t ≤ r-1):

``` 
If S_t > 0:
   Choose Defect (D)
Else:
   Choose Cooperate (C)
```

Rationale:  
- Defecting always yields a strictly higher per-round payoff than cooperating if stock > 0 (π_D = S_t/n > S_t/(2n) = π_C).
- If stock is zero or effectively zero, defecting yields no benefit (π_D = 0).
- At zero stock, cooperating minimally withdraws from the pool and might allow slow regrowth (but given the rules, once stock is 0, growth is zero; so cooperate to avoid pointless defection).

### Last round (t = r):
- Defection maximizes immediate payoff, and no future rounds remain to worry about sustainability.
- **Action:** Defect (D), unless stock = 0, then choose Cooperate (C).

---

## 2. Handling Edge Cases

- **Stock depletion (S_t ≈ 0):**  
  Defecting yields no payoff; therefore opt to cooperate to avoid futile defection and conserve any residual stock.
  
- **Stock just above zero (very low stock):**  
  Still defect, as payoff from defection even if small is greater than cooperating.

- **If defecting causes stock to drop below zero:**  
  Not possible by the rules since consumption is based on current stock.

- **If all players defect and stock hits zero any time before last round:**  
  Continue to cooperate once stock is zero to enable theoretical regrowth (although growth will be zero at zero stock), or choose cooperate to avoid pointless zero payoff rounds.

---

## 3. Aggressive Mindset Justification

- This strategy **maximizes immediate personal gains each round by defecting**, exploiting the common pool aggressively.
- **Does not attempt to coordinate or reciprocate cooperation.**
- Takes advantage of the fact defecting always returns double the payoff of cooperating given positive stock.
- Only chooses cooperate when continued defection is pointless (stock depleted).
- Will not sacrifice short-term gain to maintain resource stock or encourage cooperation.
- Prioritizes winning the tournament by maximizing own cumulative payoff, regardless of collective resource health.

---

## Pseudocode Summary

```python
def aggressive_strategy(round_t, total_rounds, current_stock, n):
    if current_stock <= 0:
        # Stock depleted; defecting yields nothing
        return 'C'  # cooperate minimally
    else:
        # Always defect when stock positive
        return 'D'
```

- Note: On round 1, no history yet; use same logic since current_stock = capacity > 0, so defect.

---

## Optional Enhancements (within aggressive framing)

If you want a fallback for potential very low stock but > 0 situations to eke out some payoff:

```python
def aggressive_strategy(round_t, total_rounds, current_stock, n):
    min_defect_payoff = current_stock / n
    min_cooperate_payoff = current_stock / (2*n)
    if min_defect_payoff > 0:
        return 'D'
    else:
        return 'C'
```

---

# Summary

| Round            | Stock Condition       | Action      | Reason                        |
|------------------|-----------------------|-------------|-------------------------------|
| 1 (first round)   | Stock = capacity (>0) | Defect (D)  | Maximize initial immediate payoff |
| Intermediate (2 to r-1) | Stock > 0            | Defect (D)  | Maximize immediate payoff each round |
| Intermediate (2 to r-1) | Stock ≤ 0            | Cooperate (C) | Avoid pointless defection with zero payoff |
| Last round (r)   | Stock > 0            | Defect (D)  | Maximize final round payoff   |
| Last round (r)   | Stock ≤ 0            | Cooperate (C) | Minimize futile defection     |

---

This strategy embodies an uncompromising, single-minded pursuit of maximum immediate payoffs at the expense of sustainability or cooperation norms—an aggressive defect-first approach with minimal concession at resource depletion.
'''

description_AGGRESSIVE_20 = '''
Below is a description of an **aggressive strategy** for the given Common Pool Resource Game. The design emphasizes maximizing personal payoff each round by defecting as much as possible, exploiting the resource, and confronting others with defection to push for maximum short-run gain. The strategy carefully handles edge cases such as the first round and the last round with aggressive default behaviors.

---

## Aggressive Strategy Description

### Key Intuition
- Always prefer **Defect (D)** to maximize immediate payoff per round (D yields twice the payoff per unit stock compared to C).
- Use initial rounds to **gauge depletion effects** but do not cooperate.
- Exploit any round where the stock is still sufficiently high.
- Push resource usage hard early on because the payoff is higher before stock dwindles.
- On the **last round**, defect to maximize final payoff regardless of future consequences.
- Do not cooperate unless extraordinary incentive arises (which given assumptions and no coordination, never does).

### Reasoning
- Defection yields **π_i = S / n** per round, twice cooperation payoff.
- Stock can regenerate but aggressive strategy prioritizes harvesting maximum payoff before depletion.
- Cooperating players receive less payoff and slow down depletion only if others cooperate, which is unlikely in a purely selfish, uncoordinated environment.
- Since the game is repeated with perfect information, opponents may try to punish over-extraction. This strategy **ignores retaliation risk** and defects throughout.
- This pushes for dominance in payoff in the tournament.

---

## Decision Rules (Per Round t)

Input information each round:
- Current common stock S_t (observe after previous round’s update)
- Round number t (1 ≤ t ≤ r)
- History of all players' actions from previous rounds (can be ignored here, since strategy is fixed aggressive)

### Rule Summary

| Round        | Action        | Reason                                                                      |
|--------------|---------------|-----------------------------------------------------------------------------|
| First round (t=1) | Defect (D)   | No prior info, start aggressively to get large payoff immediately           |
| Intermediate rounds (1 < t < r) | Defect (D)   | Always defect, regardless of stock or opponent behavior                     |
| Last round (t = r) | Defect (D)   | Maximize final payoff; no future consequences so no incentive to cooperate  |

### Detailed Pseudocode

```python
def aggressive_strategy(t, r, S_t, history):
    """
    Parameters:
        t (int): current round number (1-indexed)
        r (int): total rounds
        S_t (float): current stock at start of round t
        history (list): list of tuples (actions of all players in previous rounds)
                        not used in this aggressive strategy
        
    Returns:
        action (str): 'C' or 'D'
    """
    
    # Always defect regardless of conditions
    return 'D'
```

---

## Handling Edge Cases

- **First Round (t=1):** Defect immediately; no need to test cooperation.
- **Last Round (t=r):** Defect to maximize final payoff.
- **Low Stock:** Even if stock is very low (e.g., close to zero), still defect. If stock is zero, payoff is zero anyway, so choice is immaterial.
- **No Cooperation Signal:** Since no communication and no known cooperative norms, no incentive or trust to cooperate.

---

## Summary

- **Strategy is pure defection (always choose D).**
- It is aggressive because:
  - Always takes maximum allowed share from stock (S_t / n).
  - Does not attempt to preserve stock for future rounds.
  - Does not punish or condition on opponents; relentless exploitation.
- In a tournament, this approach attempts to harvest maximal payoffs, even at the cost of depleting the resource eventually.

---

If you want to discuss refinements like tit-for-tat or conditional aggression, that can be done, but strictly speaking, the above fits an aggressive mindset and the constraints provided.
'''

description_AGGRESSIVE_21 = '''
**Aggressive Strategy Design for the Common Pool Resource Game**

---

### Strategic Intuition

- **Aggressive mindset:** Maximize own payoff by defecting as much as possible to extract maximum benefit from the common pool.
- **Risk:** Over-extraction can collapse the resource, reducing future payoffs.
- **Balance:** Try to maintain a survivable stock level to enable multiple rounds of high payoff, but prioritize immediate gain.
- **Observation:** Use knowledge of all players' past actions to decide whether to defect steadily or exploit opportunities.
- **No cooperation presumption:** Since no coordination, anticipate others may defect too, so do not waste rounds cooperating.

---

### High-Level Strategy Summary

- **Round 1:** Defect (D). Start aggressively to maximize immediate payoff.
- **Rounds 2 to r-1:**  
  - If the current stock is above a *threshold* level, keep defecting (D).  
  - If the stock falls too low, *temporarily* cooperate (C) to allow the resource to partially recover OR continue defecting if resource is too depleted (because cooperating won’t help if the resource is collapsing anyway).
- **Round r (last round):** Defect (D) regardless of stock — maximize final payoff as future doesn’t matter.

---

### Key Parameters

- Let stock threshold for "safe defection" be a fraction of capacity:  
  `threshold = capacity / 3` (adjustable heuristic)

- If `current_stock >= threshold` → Defect, else Cooperate *if* it will meaningfully sustain stock above zero; otherwise defect to extract whatever remains.

---

### Pseudocode

```python
def aggressive_strategy(round_num, total_rounds, current_stock, capacity, n, history):
    """
    Parameters:
    - round_num: current round index (1 to r)
    - total_rounds: total rounds (r)
    - current_stock: stock at start of current round (S)
    - capacity: maximum capacity (capacity)
    - n: number of players
    - history: list of tuples of previous rounds actions by all players
               e.g. history[round-1] = [a1, a2, ..., an] with a_i in {C, D}
    
    Returns:
    - action: 'C' or 'D'
    """
    
    threshold = capacity / 3  # heuristic threshold
    
    # Round 1: Aggressive Defect
    if round_num == 1:
        return 'D'
    
    # Last round: Defect no matter what to maximize immediate gain
    if round_num == total_rounds:
        return 'D'
    
    # Intermediate rounds
    if current_stock >= threshold:
        # Stock is sufficiently healthy, defect for max payoff
        return 'D'
    else:
        # Stock low: consider cooperating to allow some growth
        # But check if cooperation helps: if growth potential is negligible, defect anyway
        
        # Estimate growth if cooperating only (simulate minimal consumption):
        # Minimal total consumption if all cooperate = n * (S / (2n)) = S/2
        # Stock after consumption ~ S - S/2 = S/2
        # Growth = 2 * (S/2) * (1 - (S/2)/capacity)
        #       = S * (1 - S/(2*capacity))
        S_remaining_coop = current_stock / 2
        growth_coop = 2 * S_remaining_coop * (1 - S_remaining_coop / capacity)
        new_stock_coop = min(S_remaining_coop + growth_coop, capacity)
        
        if new_stock_coop > current_stock * 0.9:
            # Cooperation maintains stock effectively → cooperate to sustain
            return 'C'
        else:
            # Cooperation provides little recovery → defect to maximize immediate payoff
            return 'D'
```

---

### Explanation & Rationale

- **Always defect in the first and last rounds:**  
  First round maximizes initial gain; last round maximizes endgame extraction before game ends.
  
- **In middle rounds:**  
  - If resource is healthy (above threshold), maintain defect to maximize payoff.  
  - If resource is low, evaluate whether temporary cooperation will meaningfully help resource recovery to enable future gains. Only cooperate if growth effect is substantial. Otherwise continue defecting to maximize short-term gain since future rounds may not be worth preserving the resource.
  
- **Threshold choice (capacity/3):**  
  Balances between reckless depletion and saving resource for extra payoff rounds. You can tune threshold depending on risk appetite.

- **No exploitation of opponent specific history:**  
  Strategy only depends on state and round, no attempt to punish or reward others to keep aggressiveness and simplicity.

---

### Summary

This strategy takes an aggressive stance by defecting whenever practical to maximize own payoff, tempered by a minimal check to occasionally cooperate if the common pool stock is dangerously low but recoverable — hoping to prolong future payoffs. It sacrifices cooperation for dominating immediate returns and tries to avoid total resource collapse only when clear recovery is possible. The last-ditch effort is to defect on the last round no matter what.

---

If you want me to provide variants or explanation for more nuanced scenarios, just ask!
'''

description_AGGRESSIVE_22 = '''
Below is a detailed description of an **Aggressive Strategy** for the Common Pool Resource Game that leverages the game structure and payoff incentives to maximize individual gain through exploitation, while managing stock dynamics to avoid premature resource collapse before the last round(s).

---

## Aggressive Strategy Overview

- **Goal:** Maximize total individual payoff by favoring defection (high immediate payoff) while strategically cooperating only to sustain the pool long enough to exploit in as many rounds as possible.
- **Mindset:** Selfish and predatory. Defect whenever possible, but avoid collapsing the pool too early to enable multiple rounds of high payoffs.
- **Key Insight:**  
  - Defecting yields bigger immediate payoff (S/n > S/(2n))  
  - All defecting rapidly depletes resource, causing stock collapse → zero payoff in future rounds  
  - Cooperating preserves resource but yields lower payoff  
  - Mix cooperation/defection to keep stock in a "stable" zone, maximizing rounds with significant stock for defection payoffs

---

## Decision Rules

### Notation

- Let `S_t` be the stock at the start of round `t`.
- Let `r` be the total number of rounds.
- Let `t` be the current round number, where `t` runs 1 to `r`.  
- Track the observed actions of other players in previous rounds.
- Let `D_t` be the count of defectors observed in last round (or average defectors over last few rounds).
- Let `threshold` be a parameter estimating "maximum tolerable stock depletion" before switching behavior (see below).
- Define a "safe stock level" `S_safe` = capacity / 2 (the stock level roughly where growth and consumption balance for some defection without destruction).


### Round 1: Initial move

- **Defect**  
  - No information yet, maximize first-round payoff with high defection payoff (S_1 / n).
  - Aggressive mind favors immediate gain over caution initially.

### Intermediate rounds: 2 to r-1

- **If stock is high enough (S_t > S_safe):**
  - **Always defect**.  
  - Stock can sustain aggressive exploitation for at least one more round before risk of collapse.
  
- **If stock is low but not critically low (S_safe ≥ S_t > some lower cutoff):**  
  - **Defect if others are cooperating or defecting moderately** (D_{t-1} < n) — to get bigger share.  
  - **Cooperate only if many defectors in previous round (D_{t-1} close to n)** to avoid collapse.  
  - Reason: When many defectors appear and stock is below safe threshold, defecting risks driving effective stock to zero → zero payoff in future rounds.

- **If stock is critically low (S_t ≤ lower cutoff, e.g. capacity/(4n) × n or other empirically chosen value):**  
  - **Cooperate** to preserve some leftover resource for future rounds and delay collapse.

- **Summary:**
  - Mostly defect when stock is above threshold.
  - Switch to conditional cooperation only when stock is low and over-consumption threatens survival.
  - Use last round actions of opponents as signals about group aggression.

### Final round (t = r)

- **Always defect**  
  - No future rounds left → no incentive to preserve stock.
  - Maximize immediate payoff.

---

## Summary of Parameters to Tune

- `S_safe = capacity / 2` — when stock is above this, be fully aggressive (always defect).
- `Lower cutoff = capacity / 4` (example) — if stock below this, cooperate to preserve remaining resource.
- Monitor defectors in previous round `D_{t-1}` to decide cooperation or defection in borderline cases.

---

## Pseudocode

```python
def aggressive_strategy(round_t, total_rounds, stock_S_t, capacity, prev_round_actions):
    # Parameters
    n = len(prev_round_actions[0]) if prev_round_actions else n_players  # Assume known or passed
    S_safe = capacity / 2
    lower_cutoff = capacity / 4
    
    # Count defectors in previous round (if available)
    if prev_round_actions and round_t > 1:
        last_round = prev_round_actions[-1]
        D_prev = sum(1 for a in last_round if a == 'D')
    else:
        D_prev = 0
    
    # Round 1: defect unconditionally
    if round_t == 1:
        return 'D'
    
    # Last round: defect unconditionally
    if round_t == total_rounds:
        return 'D'
    
    # Intermediate rounds decision rules
    if stock_S_t > S_safe:
        # Stock sufficient - fully aggressive
        return 'D'
    
    elif lower_cutoff < stock_S_t <= S_safe:
        # Moderate stock - conditional aggression
        # Defect if opponents not fully defecting; else cooperate to preserve stock
        if D_prev < n:
            return 'D'
        else:
            return 'C'
    
    else:
        # Stock critically low - cooperate to prevent collapse
        return 'C'
```

---

## Explanation & Rationale

- **Round 1 Defect:** Max immediate gain — no prior info, be maximally exploitative.
- **Stock High → Defect:** Allows buildup of payoff, relies on resource regrowth to recover.
- **Stock Medium → Defect unless all defect:** If all defect too much, risk resource collapse — a shade of caution to maintain some longevity.
- **Stock Low → Cooperate:** Preserve what remains for any payoff in the next rounds.
- **Last round Defect:** No incentive to cooperate since no future payoff is lost.

---

## Strategy Behavior

- Aggressively pursues defect to maximize payoff.
- Only reluctantly switches to cooperation to avoid total collapse prematurely.
- Does not trust opponents to cooperate if they defect heavily.
- Exploits any cooperation by others aggressively.
- Focused on self-maximization without explicit punishment or forgiveness mechanisms.

---

This strategy balances ruthlessness with a minimal level of prudence required to keep the resource viable across multiple rounds, maximally exploiting opponents while avoiding a no-payoff race to destruction too early. It fits the aggressive mindset tightly, prioritizing defection whenever conditions allow but backing off only when the pool is dangerously low and aggression risks zero future earnings.
'''

description_AGGRESSIVE_23 = '''
Below is a detailed **aggressive strategy** description for the Common Pool Resource Game meeting your specifications:

---

## Strategy Name: Defect-First, Punish-Later Aggression (DFPLA)

### Intuition
The strategy prioritizes maximizing personal short-term gain by defecting (D) aggressively from the start, exploiting the common pool as much as possible. However, if others appear to defect too much or cause rapid resource depletion, it punishes defectors by continuing defecting while trying to maximize own payoff (no cooperation), since cooperation is unlikely to be reciprocated. In the last round, it always defects, as no future is left to incentivize cooperation.

---

### 1. Decision Rules

For player i in round t ∈ {1, ..., r} observe:

- **Previous rounds play history**: For each player j, the action played last round a_j,t-1, if t > 1.
- **Current stock S_t** (known at round start, from previous computation).
  
**On Round 1 (t=1):**

- Defect (D)

(Reason: No incentive to cooperate on first move when aggressive, as cooperating reduces immediate payoff and others can come in defecting freely.)

**On intermediate rounds 2 ≤ t < r:**

- **If stock S_t is high (defined as S_t ≥ threshold_high), and majority cooperated in previous round**, then cooperate (C).

     - "Majority cooperated": Number of players who cooperated last round > n/2
     - threshold_high = 0.7 × capacity

  (Rationale: If pool is still healthy and many cooperated last round, briefly exploit cooperation by cooperating to prolong the game and increase total payoff while maintaining aggressive posture.)

- **Otherwise, defect (D).**

  (Rationale: If stock is low or majority defected, no incentive to give up payoff; exploit until end.)

**On last round t = r:**

- Defect (D).

(Reason: No future to protect, so defect maximizes immediate payoff.)

---

### 2. Handling Edge Cases

- **First Round (t=1):** Always defect, since no history exists to base cooperation on.
- **Transition rounds with stock near zero:** If stock drops too low to support defect-level withdrawal (stock < n × stock/n), then action defaults to cooperate (as defecting would mean over-consumption impossible), but practically, since stock dynamics prohibit negative stock, just defect anyway - effectively serves as defecting until exhaustion.
- **If stock reaches zero before last round:** Defect (no stock to consume), payoff zero, but keep defecting to maintain aggressive signal.
- **If capacity very large:** Thresholds scaled to absolute capacity keep strategy consistent.

---

### 3. Pseudocode

```python
def aggressive_strategy(t, r, n, capacity, S_t, history):
    """
    Args:
        t (int): current round (1 to r)
        r (int): total rounds
        n (int): number of players
        capacity (float): max stock
        S_t (float): current stock at start of round t
        history (list of list): history of actions per round for all players 
                                (length t-1), each element is list of actions ['C' or 'D'] per player

    Returns:
        'C' or 'D'
    """

    threshold_high = 0.7 * capacity

    if t == 1:
        # First round: defect aggressively
        return 'D'

    if t == r:
        # Last round: defect for max immediate gain
        return 'D'

    # For rounds 2 to r-1:
    # Check cooperation level last round
    last_round_actions = history[-1]

    num_cooperators = sum(1 for a in last_round_actions if a == 'C')

    majority_cooperated = (num_cooperators > n / 2)

    if S_t >= threshold_high and majority_cooperated:
        # Cooperate to exploit cooperation and maintain resource
        return 'C'
    else:
        # Otherwise, defect aggressively
        return 'D'
```

---

### Summary

- **Aggressive by default:** Always defect first and last rounds.
- **Conditional cooperation:** Only cooperate in mid-game if resource is still healthy and majority cooperated last round.
- **Focus on exploiting others' cooperation** while punishing defection with defection.
- **No assumption of coordination, no cooperation unless clear majority cooperate and resource healthy.**

This provides a clear aggressive yet logically consistent response to observable history in a repeated common pool resource game with dynamic stock and imperfect cooperation incentives.

---

If you want, I can help you design variants or extensions of this aggressive strategy tailored to specific parameters or anticipated opponent types.
'''

description_AGGRESSIVE_24 = '''
**Aggressive Strategy Description for the Common Pool Resource Game**

---

### Overview

The goal of an aggressive strategy in this game is to maximize your individual payoff by consuming as much as possible without prematurely collapsing the common resource unless it is beneficial in the very last rounds. Cooperation is regarded as weak and exploited aggressively. The strategy balances defecting to maximize immediate gain while monitoring the resource stock to decide if the stock is near collapse, at which point it finishes extracting as much as possible.

---

### Core Ideas

- **Defect aggressively** as much as possible since defection yields higher immediate payoffs (consuming `S/n` vs `S/(2n)`).
- **Only cooperate if the stock approaches collapse** to avoid a potential waste of the last few rounds’ payoffs.
- **In the last round, always defect** to extract maximum remaining payoff.
- **Conditionally cooperate (only if necessary) to sustain stock slightly for continuation**, but since the game is aggressive, preferentially defect unlimitedly until near collapse.
- Use history of previous rounds to detect if the stock level is dangerously low, i.e., when the resource is about to collapse, and **shifting from defection to cooperate as a "last chance" effort** to squeeze minimal growth and payoff from the resource.

---

### Parameters Needed by Strategy

- Number of players `n`
- Total capacity `capacity`
- Current round `t`
- Total rounds `r`
- Current stock `S`
- History of actions by all players (optional for refinements, but core strategy mainly depends on stock and round)

---

### Pseudocode

```python
function aggressive_strategy(t, r, n, capacity, S, history):
    # Constants:
    DEFECT = 'D'
    COOPERATE = 'C'

    # Threshold to detect near collapse - empirically set 
    # (some fraction of capacity below which stock is considered dangerously low)
    collapse_threshold = capacity * 0.15

    # 1. Last round: always defect to extract maximum payoff
    if t == r:
        return DEFECT

    # 2. If stock is very low, near collapse threshold, cooperate to prolong resource minimally
    if S <= collapse_threshold:
        # cooperate to reduce consumption and get some growth benefit
        return COOPERATE

    # 3. Otherwise aggressively defect
    return DEFECT
```

---

### Explanation of Decision Logic

- **Round 1:** No hesitation, defect immediately. There is no incentive to cooperate when defecting yields twice the payoff per round.
- **Intermediate rounds:** Continue defecting unless the stock level is dangerously low (e.g., below 15% of capacity). This threshold allows the stock to replenish somewhat if you cooperate with others but only when necessary.
- **Near collapse:** Switch to cooperate to avoid immediate extinction of the resource, since total depletion yields zero growth and zero future payoff.
- **Last round:** Defect no matter what, to extract all available resources in that final round.

---

### Rationale

- Defection maximizes immediate payoff each round.
- The stock dynamic is regenerative but sensitive to consumption.
- Cooperating near collapse is a forced concession to prolong resource availability.
- Last round defect to maximize harvest.
- Does not rely on opponent cooperation.
- Does not punish or reward opponents based on their history; strictly myopic and payoff-maximizing.
- This aligns with an aggressive exploitation mindset: extract as much as possible, only slightly modulating behavior to survive until the last round.

---

### Alternative enhancements (optional / for later tuning)

- Dynamically adjust collapse_threshold based on observed stock depletion rates.
- Detect if others cooperate consistently and selectively defect to exploit them more aggressively.
- But purely from given info and constraints, sticking to above robust strategy is recommended.

---

**Summary:**  
**Aggressive Strategy = Always defect except when stock is low (≤15% capacity), then cooperate to slightly sustain common pool, and defect in last round to maximize final extraction.**
'''

description_AGGRESSIVE_25 = '''
Here is a detailed aggressive strategy for the Common Pool Resource Game that fits all the given constraints and assumptions.

---

### Strategy Name: "Relentless Defector"

### Core Idea:
Always prioritize maximizing immediate payoffs by defecting unless compelling evidence suggests everyone is cooperating. Exploit cooperators by defecting early and often, but try to avoid complete resource depletion to keep maximizing payoffs over multiple rounds.

---

### Intuition Behind the Strategy:
- Defection yields higher immediate payoff than cooperation for the same stock level.
- An aggressive player exploits cooperators whenever possible.
- However, relentless defection without regard can lead to quick depletion of the resource, causing zero payoffs in later rounds.
- To stay aggressive yet avoid resource exhaustion, defect by default but monitor total consumption and stock decline.
- Attempt "calculated cooperation" only if exhausting the resource is imminent and the residual stock is low and cooperation might extend the lifespan of the resource.
- In final round, defect to maximize liquidation payoff since no future rounds remain.

---

### Detailed Decision Rules:

#### 1. At Round 1 (Initial round):
- **Action:** Defect (D).
- **Reason:** There's no prior history, but defection maximizes first-round payoff.

#### 2. For Rounds t = 2 to r-1:
- Observe previous round's actions and resulting stock level.
- Calculate total consumption T_prev and remaining stock S_prev after previous round.
- Predict immediate payoff from defecting vs cooperating in this round based on current stock S_t.
- Check if resource is critically depleted:

  - Critical depletion condition:
  
    \[
    S_{prev} \leq threshold = capacity \times \frac{2n}{n + 2n}
    \]

    We choose this threshold to roughly estimate when defecting causes sharp decline.
  
- **If**
  - Total consumption in prior round is high (close to or exceeding sustainable limit e.g. total consumption >= capacity/2) **and**
  - Stock after previous round is below threshold (critical),
  
  **Then:**
  - Cooperate (C) to slow depletion and let stock regenerate.
  - Intention: Minimal cooperation to prolong stock and future payoffs.
  
- **Else:**
  - Defect (D) to maximize immediate payoff.

#### 3. At the Last Round t = r:
- Always defect (D).
- Reason: No future rounds; maximize payoff regardless of stock exhaustion.

---

### Pseudocode

```python
# Parameters known globally: n, r, capacity

# Inputs each round t (2 <= t <= r):
# history_actions: list of tuples of length t-1, each tuple size n representing actions of all players
# history_stocks: list of floats of length t representing stock levels before each round (S_1 at start)
# Note: S_t is stock before round t's consumption

def aggressive_strategy(t, history_actions, history_stocks):
    if t == 1:
        # Round 1
        return 'D'

    S_prev = history_stocks[t-1]          # Stock before previous round t-1
    actions_prev = history_actions[t-2]   # Actions in previous round
    n_defectors_prev = sum(1 for a in actions_prev if a == 'D')
    n_cooperators_prev = n - n_defectors_prev

    # Calculate total consumption previous round:
    # cooperators each consume S_prev/(2n), defectors each consume S_prev/n
    total_consumption_prev = (
        n_cooperators_prev * (S_prev / (2*n)) +
        n_defectors_prev * (S_prev / n)
    )

    # Stock after consumption but before growth, from game rules
    S_after_consumption = S_prev - total_consumption_prev

    # Define critical depletion threshold as ~ 0.67 * capacity (2n/(n+2n)=2/3)
    threshold = capacity * (2*n) / (n + 2*n)  # = capacity * 2n/3n = capacity * 2/3

    if t == r:
        # Last round: defect always
        return 'D'

    # If stock is critically low AND total consumption is high, cooperate to allow stock to recover
    if (S_after_consumption <= threshold) and (total_consumption_prev >= capacity / 2):
        # Cooperate to promote growth and avoid depletion
        return 'C'

    # Otherwise defect aggressively
    return 'D'
```

---

### Summary Notes

- **Always defect on the first and last rounds.**
- **In intermediate rounds, defect unless collective behavior and stock levels strongly suggest imminent collapse, then cooperate to preserve resource.**
- **This intermittent cooperation is just enough to keep resource from completely dying out, extending the stream of payoffs.**
- The strategy is non-cooperative, self-serving, and exploits cooperative opponents.
- It uses perfectly observable history and stock dynamics, making decisions solely on observed depletion, not on generosity or trust.
- No forgiveness or retaliation cycles — always aggressive except minimal survival cooperation.

---

If you want me to help with variants or more detailed analysis, let me know!
'''

description_AGGRESSIVE_26 = '''
**Aggressive Strategy for the Common Pool Resource Game**

---

### Intuition and Overview

The strategy is designed to maximize individual payoff by predominantly defecting to consume larger shares while exploiting the common pool before the stock dwindles. Due to the repeated nature and stock dynamics, an aggressive player exploits early rounds heavily and prepares to defect consistently, but optimizes in the very last rounds to avoid futile resource depletion. Since the game is simultaneous and without communication, it assumes no cooperation and punishes cooperating opponents by defecting strongly.

---

### Key Aggressive Principles

- **Defect early and persistently:** Always maximize per-round consumption.
- **Exploit cooperators:** If others cooperate, defect to gain more payoff.
- **Avoid waste after depletion:** Recognize when the stock is too low to gain from defection, and adjust accordingly.
- **Capitalize on last round:** Defect outright, as no future retaliation is possible.
- **Ignore cooperation signals:** Do not attempt to cooperate or punish, always assume others might defect.

---

### Strategy Decision Rules

Let:

- \( t \) = current round (1 to r)
- \( S_t \) = stock at start of round \( t \)
- \( A_{-i,t} \) = actions of all other players in round \( t \) (revealed after the round)
- \( coop\_count_{t-1} \) = number of players who cooperated in previous round (if \( t > 1 \))

---

### Step 1: First round \( t=1 \)

- **Action:** Defect  
- **Reason:** No prior information, maximize immediate payoff by consuming \( S_1 / n \).

---

### Step 2: Intermediate rounds \( 1 < t < r \)

- **If stock is high ( \( S_t \ge capacity / 3 \) ):**  
  Defect  
  *(Aggressive exploitation when resource is abundant)*

- **If stock is medium-low ( \( capacity / 10 \le S_t < capacity / 3 \) ):**  
  Defect if majority defected last round (i.e., > n/2 players defected in round \( t-1 \)), otherwise cooperate  
  *(Attempt minimal cooperation if others seem cooperative to preserve stock a bit, but only when stock is noticeably low)*

- **If stock is low ( \( S_t < capacity / 10 \) ):**  
  Cooperate  
  *(Minimize stock depletion to allow regrowth if possible, as defection risks ruin)*

---

### Step 3: Last round \( t = r \)

- **Action:** Defect  
- **Reason:** No future rounds, so maximize final payoff regardless of stock impact.

---

### Step 4: Dealing with actions observed from previous rounds

- The strategy only lightly conditions on others' past behavior at medium stock levels (Step 2).

- Otherwise, it ignores cooperation and continuously defects aggressively.

---

### Pseudocode Summary

```python
def aggressive_strategy(t, r, n, capacity, S_t, coop_count_prev=None, defect_count_prev=None):
    # Inputs: 
    # t: current round (1-based)
    # r: total rounds
    # n: number of players
    # capacity: max stock level
    # S_t: stock at start of round t
    # coop_count_prev, defect_count_prev: counts of players' previous round actions (if t>1)

    # Round 1: defect
    if t == 1:
        return 'D'

    # Last round: defect always
    if t == r:
        return 'D'

    # Intermediate rounds:
    if S_t >= capacity / 3:
        # stock abundant, defect
        return 'D'
    
    elif capacity / 10 <= S_t < capacity / 3:
        # medium stock: defect if majority defected last round, else cooperate
        if defect_count_prev is not None and defect_count_prev > n / 2:
            return 'D'
        else:
            return 'C'
    
    else:
        # low stock: cooperate to preserve resources
        return 'C'
```

---

### Additional Notes

- **Why cooperate sometimes at medium-low stocks?**  
  Pure defection when the stock is low risks driving the resource to zero prematurely, yielding zero payoff for all. Thus, minimal cooperation here can sustain the pool for future rounds and more payoff accumulation.

- **Ignoring cooperation signals elsewhere** ensures an aggressive stance that exploits any cooperating agents.

---

### Summary

| Round          | Stock Condition          | Action                                   |
|----------------|--------------------------|------------------------------------------|
| First Round    | Any                      | Defect                                   |
| Intermediate   | \( S_t \ge capacity/3 \) | Defect                                   |
| Intermediate   | \( capacity/10 \le S_t < capacity/3 \) | Defect if majority defected last round, else Cooperate |
| Intermediate   | \( S_t < capacity/10 \)  | Cooperate                                |
| Last Round     | Any                      | Defect                                   |

This preserves aggressiveness while managing stock to avoid ruin, maximizing the player’s total payoff in a tournament setting without reliance on cooperation or trust.
'''

description_AGGRESSIVE_27 = '''
Below is an **aggressive strategy** tailored for the Common Pool Resource Game with the given parameters and constraints. The focus is maximizing immediate payoffs by favoring defection (D), exploiting cooperators (C) when possible, and punishing below-par behavior, while still accounting for stock dynamics and the multi-round horizon.

---

## Strategy Rationale and Overview

- **Aggressiveness** means prioritizing **maximizing own immediate payoff** via defecting as much as possible.
- However, extreme greed may lead to resource depletion and zero payoff in final rounds.
- To balance, the strategy:
  - Starts with Defect to exploit initial high stock.
  - Monitors others’ actions from round 2 onward:
    - If others also defect (stock depleting fast), keep defecting — race to maximize payoff.
    - If others cooperate, continue defecting to harvest higher payoff.
  - If stock becomes dangerously low (approaching zero), defect only if last round; otherwise, cooperate minimally to sustain some stock and gain payoff in future rounds.
- **No forgiveness or costly cooperation** — if others defect you respond with defection to avoid being exploited.
  
---

## Detailed Decision Rules

**Parameters and Variables:**

- n = number of players
- r = number of rounds
- capacity = max sustainable stock (≥ 2n)
- t = current round (1 to r)
- S_t = stock at start of round t (observed at end of previous round)
- history of players' actions: A_j,t for player j at round t

---

### 1. First Round (t = 1)

No history to exploit.

- **Play D (Defect)**  
  Rationale: Maximize first-round payoff; stock initially full ⇒ maximum payout from defecting.

---

### 2. Intermediate Rounds (1 < t < r)

Use observed history to infer others’ behavior and current stock:

- Calculate **average defection rate** of others in the previous round:

  \[
    D\_rate = \frac{1}{n-1} \sum_{j \neq i} \mathbf{1}_{A_{j,t-1} = D}
  \]

- Calculate **stock threshold** to judge sustainability:

  \[
    S\_threshold = 2n
  \]

  (Using minimum sustainable stock at least to support everyone cooperating.)

- **If stock S_t ≤ S_threshold:**

  - *If last round (t = r):* Defect to maximize final payoff (resource exhaustion no longer worries).
  - *Else:* Cooperate to preserve stock for one more round (minimizing collective depletion), hoping others cooperate more or stock recovers.  

- **Else (S_t > S_threshold):**

  - Always Defect to maximize immediate payoff, regardless of others’ moves.

---

### 3. Last Round (t = r)

- Always Defect (D) since no future rounds exist to preserve the resource.

---

### Summary Table of Action Selection

| Condition                                                               | Action |
|-------------------------------------------------------------------------|--------|
| Round 1 (no history)                                                    | Defect |
| Stock low (≤ 2n) and rounds left > 1                                   | Cooperate (conserve) |
| Otherwise (stock sufficient, rounds 1 < t < r)                         | Defect |
| Last round (t = r)                                                     | Defect |

---

## Intuition and Aggressiveness

- The strategy exploits the initial high stock fully.
- It only cooperates to *temporarily* preserve stock if it gets dangerously low before the last round.
- This conservatism is minimal — the minimum stock threshold (2n) corresponds roughly to the lowest sustainable stock for all players cooperating.
- Else, it aggressively defects regardless of others’ behavior.
- The only "cooperation" is a tactical conservation to avoid completely losing the resource before it can be drained in the last round.
- No signaling or attempts to build cooperation — purely exploit and only conserve when near collapse.

---

## Pseudocode

```python
def aggressive_strategy(t, r, n, capacity, S_t, action_history):
    # Parameters
    S_threshold = 2 * n
    
    # Round 1: no history, defect
    if t == 1:
        return "D"
    
    # Last round: always defect
    if t == r:
        return "D"
    
    # Intermediate rounds:
    if S_t <= S_threshold:
        # Stock is low, cooperate to conserve
        return "C"
    else:
        # Stock sufficient, defect aggressively
        return "D"
```

---

## Handling Edge Cases

- **Stock 0 or near zero:**  
  Stock growth is zero if stock is zero, so once depleted, no regrowth. Strategy will cooperate only if this is not the last round, but no recovery will happen if stock is zero. Strategy accepts this risk since it's aggressive.

- **Highly cooperative others:**  
  The strategy exploits cooperators by defecting to gain more per round.

- **All defectors:**  
  Racing to exhaustion, defect every round.

- **Mixed behavior:**  
  Same logic; defect while stock allows, cooperate only if stock is low.

- **Number of players (n) and capacity:**  
  Threshold scales with n, ensuring low stock is judged correctly relative to player count.

---

# Summary

This aggressive strategy is essentially **defect-first, defect-often, but conserve only when stock is critically low and rounds remain to avoid complete collapse too early**. It maximizes selfish payoff with minimal concessions, perfectly aligned with the aggressive mindset required.
'''

description_AGGRESSIVE_28 = '''
**Aggressive Strategy for the Common Pool Resource Game**

---

### Core Idea
Maximize your individual payoff by defecting (D) as often as possible, extracting the largest share from the stock each round. Exploit cooperators when the stock is still sufficiently large so defecting yields high payoff. However, monitor stock depletion carefully and switch to cooperation (C) only to prevent total stock collapse near the final rounds to salvages some payoff at the end. This aggressive "try to reap as much as possible early, but don't kill the goose entirely at end" approach balances greed with some conservation.

---

### Detailed Decision Rules

#### Notation
- Let `t` be the current round: `1 <= t <= r`
- Let `S_t` be the stock at the start of round `t`
- Let `capacity` be the maximum sustainable stock level
- Let `n` be the number of players
- Let `R` be the remaining rounds: `R = r - t + 1`
  
---

### Strategy Description

**Round 1 (t=1):**
- Defect (D) to secure a large initial payoff and signal aggressiveness immediately.

**Rounds 2 through (r-2):**
- If stock `S_t` is "sufficiently high," keep defecting.
- Define "sufficiently high" as stock at least equal to `capacity / 4`.
  - Reason: Stock above 25% capacity still allows large payoffs and decent growth.
- Otherwise, cooperate (C) to slow depletion and let the stock recover if it's lower.

**Round (r-1) (the penultimate round):**
- If the stock `S_t` is very low (below `capacity / (4n)`), cooperate to try to preserve some stock for the last round.  
- Else, defect.

**Round r (last round):**
- Defect always — maximize the payoff since no future rounds remain, no incentive to preserve stock.

---

### Pseudocode

```python
def aggressive_strategy(t, S_t, r, capacity, n):
    # Parameters
    penultimate_round = r - 1
    low_stock_threshold = capacity / (4 * n)     # very low threshold for penultimate round
    sufficient_stock_threshold = capacity / 4    # threshold to continue defecting early/mid game
    
    if t == 1:
        # Start aggressive immediately
        action = 'D'
    elif t == r:
        # Last round: maximize payoff regardless of stock
        action = 'D'
    elif t == penultimate_round:
        # Penultimate round: be cautious if stock is very low
        if S_t < low_stock_threshold:
            action = 'C'
        else:
            action = 'D'
    else:
        # Early/mid game rounds: defect if stock is sufficient, else cooperate
        if S_t >= sufficient_stock_threshold:
            action = 'D'
        else:
            action = 'C'
    
    return action
```

---

### Explanation of Aggressiveness and Edge Handling

- **Aggressiveness:**
  - Immediate defection in round 1 to capture highest possible payoff early.
  - Defect in almost all rounds where stock allows high returns.
  - Defect in last round to maximize terminal payoff.
- **Conservation only when necessary:**
  - Switch to cooperation only when stock is low enough that continued defection would drastically reduce future payoffs.
  - Even in penultimate round, cooperation is minimal and only when stock is critically low.
- **No trust placed on opponents cooperating:**
  - No attempts to establish cooperation, no forgiveness, only opportunistic exploitation with minimal stock maintenance.
- **Edge Cases:**
  - First round always defect to set tone.
  - Last round always defect since no future losses.
  - Penultimate round carefully chosen to try to hedge bets if resource is almost depleted.

---

### Summary

This strategy is **aggressive** because it prioritizes defecting whenever the resource stock allows a high payoff, extracting maximum immediate value without regard for sustaining cooperation. However, it is *smart aggressive* by avoiding total resource collapse near the very end, preserving just enough stock to still earn some payoff in the last rounds. This balance allows maximum exploitation consistent with long-run payoff maximization under uncertainty about other players’ behavior.
'''

description_AGGRESSIVE_29 = '''
Below is a detailed aggressive strategy for the described Common Pool Resource Game.

---

## Aggressive Strategy: "Defect-First Exploitative"

### Strategy Intuition

- **Aggressive posture:** Prioritize immediate maximum extraction to maximize payoff, ignoring sustainability concerns unless stock is critically low.
- **Exploit others' cooperation:** Defect whenever beneficial to gain a higher share per round.
- **Selective cooperation only at critical stock level:** Cooperate (consume less) only to keep the resource from collapsing prematurely, thus maintaining a source for future exploitation.
- **Last round defect:** Always defect in the last round, as no future rounds remain to worry about stock sustainability.
- **No forgiveness or tit-for-tat:** Trust no one, do not try to punish or reward; always maximize personal payoff given the current state.

---

### High-Level Rules

1. **Round 1: Defect**
   - Start aggressive to claim large share immediately.
2. **Intermediate Rounds (2 to r-1):**
   - If current stock S is **high enough** (e.g. above critical threshold), defect.
   - If stock is **critically low**, cooperate to avoid total collapse (preserve positive stock for next round).
3. **Last Round (r): Defect**
   - No incentive to cooperate at all since no future payoffs.

---

### Defining Critical Threshold

- Because large consumption can drain the stock to zero and end payoffs prematurely, the strategy will cooperate if stock is too low to maintain a useful future resource.
- Threshold candidate: Let’s define a critical stock level **T = capacity / (2n) × n = capacity / 2** (half capacity).
   - Rationale: If stock ≤ capacity/2, cooperation can help sustain stock for remaining rounds.
- Alternatively, a dynamic threshold could be more nuanced (e.g. depending on rounds left), but a fixed simple threshold aligns with aggressive mindset with minimal complexity.

---

### Pseudocode

```python
def aggressive_strategy(round_t, r, stock_S, capacity, n):
    """
    round_t: current round number (1-based)
    r: total rounds
    stock_S: current stock before this round's consumption
    capacity: maximum stock capacity
    n: number of players
    Returns action: "C" or "D"
    """

    # Last round: Defect always
    if round_t == r:
        return "D"

    # First round: Defect immediately to exploit initial full stock
    if round_t == 1:
        return "D"

    # Intermediate rounds: decide based on current stock
    # Define critical threshold as half capacity
    T = capacity / 2

    if stock_S > T:
        # Stock sufficiently high, defect to maximize payoff
        return "D"
    else:
        # Stock low, cooperate to preserve resource
        return "C"
```

---

### Explanation

- **Round 1 Defect:** Start by grabbing as much as possible.
- **High stock Defect:** Exploit when stock is sufficient.
- **Low stock Cooperate:** Temporarily moderate consumption to avoid collapse, ensuring at least some payoff in later rounds.
- **Last round Defect:** No future penalty, harvest maximum payoff.

---

### Edge Cases & Further Considerations

- **Initial stock exactly at capacity (≥ 2n):** Strategy exploits fully from first round.
- **Stock zero or near zero:** Cooperate may not increase stock in practice, but cooperative consumption is minimal; defection would over-exploit and zero stock is guaranteed.
- **Dynamic threshold refinement (optional):** If desired, could lower threshold as rounds progress, becoming more reluctant to cooperate near the end.
- **No reliance on opponents' past behavior:** Pure state-and-round dependent strategy; robust against any opponent tactics.

---

## Summary

This strategy embodies aggressive exploitation with a minimal concession to preserve the stock only when absolutely necessary to avoid total collapse before the game ends, maximizing payoff over the repeated rounds. It is simple, deterministic, and aggressive—ideally suited for a tournament against independent LLM-generated strategies with no assumed coordination.
'''

description_AGGRESSIVE_30 = '''
Here is a designed aggressive strategy for the Common Pool Resource Game. The strategy is aggressive in the sense that it prioritizes maximizing immediate payoffs by defecting whenever profitable, exploiting cooperators when possible, and punishing defectors minimally to maintain high payoffs overall. It also carefully manages the stock level to avoid premature depletion that would hurt future payoffs.

---

## Strategy Overview: "Calculated Exploitative Defection"

**Key Idea:**  
- Defect (D) by default to maximize individual payoff each round.  
- Cooperate (C) only early on (round 1) to test if others cooperate and to avoid early catastrophic depletion.  
- Monitor opponents’ actions each round; if all defect (unsustainable extraction), switch to cooperation temporarily to help stock recovery.  
- In the last round, defect always to maximize immediate payoff since there is no future penalty.  
- Use stock level as a signal: if stock drops too low (below a critical threshold), cooperate temporarily to allow regrowth.  
- Do not attempt complex punishments—focus on maximizing own round payoffs, exploiting cooperating players where possible.

---

## Rationale

- Defection yields twice the immediate payoff compared to cooperation for the same stock.  
- When all defect, stock collapses, and future payoffs are zero.  
- Aggressive players maximizing payoff tend to defect, but total collapse hurts. This strategy attempts "damage control" by cooperating only when the system is near collapse, hoping to restore stock to an exploitable level.  
- The strategy exploits cooperators fully but accepts some cooperation itself temporarily when survival warrants.  
- This makes it more robust than naive always-defect, while remaining aggressive.  
- No explicit retaliation or sustained cooperation is used, hence no attempts to build trust or coordination.

---

## Parameters (tunable constants)

- **LowStockThreshold** = capacity / 4  (25% of capacity)  
- **TestRound** = 1  
- **LastRound** = r  

---

## Pseudocode

```python
function aggressive_strategy(round t, current_stock S, history_of_actions A, n, capacity, r):

    # On first round, cooperate once to test cooperation and avoid immediate depletion
    if t == 1:
        return C

    # On last round, defect regardless (no future penalty)
    if t == r:
        return D

    # Calculate opponent actions in previous round (t-1)
    last_round_actions = A[t-1]  # A is a dict or list of all players' actions per round

    # Count how many defected last round (excluding self if needed)
    num_defectors_last_round = count_defectors(last_round_actions)

    # If last round everyone defected, stock likely dropping fast
    # Cooperate temporarily for stock recovery
    if num_defectors_last_round == n:
        return C

    # If stock is low (< LowStockThreshold), cooperate for recovery
    if S < LowStockThreshold:
        return C

    # Otherwise, defect to maximize immediate payoff
    return D
```

---

## Explanation of Rules

1. **Round 1: Cooperate**  
   - Start with cooperation once to avoid early collapse and observe if others reciprocate.  
   - This sets a baseline, but does not trust others.

2. **Last Round: Defect Always**  
   - No future rounds mean no incentive to preserve stock.  
   - Maximize immediate payoff by defecting.

3. **If Everyone Defected Last Round:**  
   - If all players are defecting, stock drains too quickly, eventually yielding zero payoffs.  
   - Temporarily cooperate to enable stock regrowth, hoping to extract more payoffs in future rounds.

4. **If Stock Level is Low:**  
   - If stock is dangerously low (e.g., below 25% of capacity), temporarily cooperate to allow regrowth.

5. **Otherwise, Defect Always:**  
   - Default is aggressive defection to maximize round payoff and exploit cooperators.  
   - No sustained cooperation to avoid being exploited.

---

## Notes on Opponent Behavior and Observations

- The strategy does not assume any norms nor communication; it infers group behavior from observed actions.  
- Punishment is limited to ceasing cooperation if exploited, and cooperating only to preserve resource viability.  
- It exploits cooperative players while preventing total collapse for sustainable exploitation.  
- This strategy balances short-term greed and medium-term survival, reflecting an aggressive yet adaptive mindset.

---

If you want, I can also provide a variant incorporating memory of multiple past rounds or more nuanced thresholds, but this design aligns well with the aggressive objective and parameters given.
'''

description_AGGRESSIVE_31 = '''
Here is a description of an aggressive strategy designed for the given Common Pool Resource Game.

---

## Aggressive Strategy: "Relentless Defector"

### Strategy Overview
This strategy aims to maximize the player's own total payoff by defecting (consuming more) as often as possible, exploiting the common pool resource aggressively without explicit cooperation. It tries to extract maximum immediate payoff from each round, at the risk of depleting the stock over time. Due to the absence of trust and coordination, it assumes opponents may defect or cooperate unpredictably and does not attempt to sustain the resource unless it is beneficial for the player.

---

### Key Intuition
- **Defection** yields double the payoff per round compared to cooperation if the stock remains constant.
- **Cooperating** can help preserve the pool, but since other players' behaviour is unknown and uncoordinated, cooperation cannot be guaranteed or reliably reciprocated.
- The strategy **always defects except possibly the last round**, as defecting in the last round does not affect future payoffs.
- If the remaining stock is too low to yield meaningful payoff from defection, the strategy switches to cooperate to prolong the game and gain any possible payoff.

---

### Detailed Decision Rules

1. **Round 1 (Initial Round):**
   - Defect. Start aggressively to maximize immediate payoff.
  
2. **Interim Rounds (2 to r-1):**
   - If current stock S is healthy (above threshold), defect.
   - If current stock is very low (below threshold), cooperate to avoid total collapse that yields zero payoffs.
  
3. **Final Round (r):**
   - Defect. No future rounds remain, so maximize immediate extraction.

---

### Threshold for "Low Stock"
Define threshold as a fraction of capacity, e.g.:
- `threshold = 0.2 * capacity` (20% of capacity)

If `S < threshold`, switch to cooperation in order to keep some resource alive and get positive payoff (even if small). This is defensive but still aggressive relative to pure cooperation.

---

### Pseudocode

```python
def aggressive_strategy(round_number, total_rounds, current_stock, capacity, n):
    """
    Inputs:
        round_number: current round number (1-indexed)
        total_rounds: total number of rounds r
        current_stock: current stock S (float)
        capacity: max stock capacity (float)
        n: number of players
        
    Output:
        action: "C" or "D"
    """
    threshold = 0.2 * capacity  # threshold for low stock
    
    # Always defect in round 1 and last round
    if round_number == 1:
        return "D"
    if round_number == total_rounds:
        return "D"
    
    # In interim rounds, defect if stock healthy, else cooperate
    if current_stock >= threshold:
        return "D"
    else:
        return "C"
```

---

### Rationale

- **Maximize immediate gain:** Defecting yields payoff = S/n; cooperate yields only S/(2n).
- **Avoid total collapse:** By cooperating only when stock drops below threshold, the strategy tries to prevent zero stock and zero payoff rounds.
- **No assumptions about others:** It does not rely on reciprocal cooperation, enforcing a tough stance.
- **Last round defect:** Exploit resource fully; no future penalty.

---

### Expected Behaviour
- The strategy aggressively consumes stock initially.
- If opponents cooperate and pool remains large, it continues defecting.
- If pool is collapsing, it softens by cooperating to prolong positive payoffs.
- If opponents also defect always, expect rapid stock depletion and the strategy defecting until stock drops below threshold.
- Never tries to punish or reward others explicitly—purely self-maximizing within constraints.

---

This design aligns with an aggressive mindset by prioritizing high immediate payoffs with little concern for sustainability except when the resource is near depletion, where limited cooperation aims only to avoid total collapse and zero payoffs.
'''

description_AGGRESSIVE_32 = '''
Below is a detailed description of an **aggressive strategy** for the Common Pool Resource Game consistent with the given specification and constraints.

---

## Strategy Concept and Rationale

**Goal:** Maximize my own total payoff aggressively by exploiting the resource and opponents, at the expense of cooperation or sustainability.

**Aggressive mindset:**  
- Always favor defecting (D) to maximize immediate payoff each round.  
- Assume opponents are rational but unknown in strategy, so use observed behavior to exploit cooperators.  
- Only consider cooperating briefly to avoid total resource collapse if it severely harms my own long-term payoff.  
- Use last-round defect to maximize terminal payoff since no future consequences exist.

---

## Decision Rules

Let:  
- S_t = stock at the beginning of round t  
- i = current player index (myself)  
- Actions: C = cooperate, D = defect  
- History: records of all players’ past actions and payoffs

### Round 1 (Initial round)

- **Action:** Defect (D) unconditionally  
- **Rationale:** Start aggressively to gain as much as possible; no prior information to trust cooperation.

### Intermediate Rounds 2 to r-1

- **Default action:** Defect (D)

- **If stock S_t is dangerously low:**  
  Define threshold = 2n (minimum sustainable stock approximately equal to capacity/n for some margin).  
  If S_t < threshold:  
  → Cooperate (C) *if* defecting would lead to immediate extinction (S_{t+1} = 0) or collapse with zero growth next round, which would kill all future payoff.

- **Otherwise:**
  Defect (D)

- **Rationale:**  
  - Aggression rewards defecting every round for maximum payoff.  
  - However, if defecting now kills resource, payoffs in future rounds become zero, so cooperate temporarily to let resource repair.  
  - This is a pragmatic "resource exhaustion check" to prolong game and keep extracting value aggressively over multiple rounds.

### Last Round (round r)

- **Action:** Defect (D)

- **Rationale:** No future rounds, so no incentive to preserve stock.

---

## Pseudocode

```python
def aggressive_strategy(round_t, stock, capacity, n, r, history):
    threshold = 2 * n  # heuristic threshold for dangerously low stock
    
    # Round 1: always defect
    if round_t == 1:
        return 'D'
    
    # Last round: always defect
    if round_t == r:
        return 'D'
    
    # Intermediate rounds:
    # Predict stock after defecting by all players this round (worst case)
    # Total consumption if all defect: n * (stock / n) = stock (all consumed -> stock zero)
    # If stock is very low, defecting will set stock to zero and future payoffs zero.
    #
    # Conservative approximation: if current stock < threshold, defecting now kills resource
    
    if stock < threshold:
        # Cooperate to reduce consumption, preserving stock
        # Consumption if I cooperate and others defect:
        # My consumption: stock / (2n)
        # Others assumed defect: (n-1) * (stock / n)
        total_consumption = (stock / (2 * n)) + (n - 1) * (stock / n)
        stock_after = stock - total_consumption
        
        # Growth calculation after consumption
        growth = 2 * stock_after * (1 - stock_after / capacity)
        new_stock = min(stock_after + growth, capacity)
        
        # If new_stock > 0, cooperation prolongs resource and future payoff > 0
        # Thus cooperate
        if new_stock > 0:
            return 'C'
        else:
            # Cooperation won't help (stock collapses anyway)
            # Defect anyway (maximize immediate payoff)
            return 'D'
    
    # Otherwise defect aggressively
    return 'D'
```

---

## Summary

| Condition                     | Action |
|------------------------------|--------|
| Round 1                      | D      |
| Last round (round r)          | D      |
| Intermediate round & stock < threshold & cooperation preserves resource | C |
| Otherwise                    | D      |

---

## Additional notes

- The threshold and the logic for edge stock levels can be tuned empirically but should remain small relative to capacity for true aggressive play.
- No attempt to punish or reward opponents through contingent cooperation, as this would reduce aggressiveness.
- The strategy exploits the common pool aggressively but pragmatically preserves it just enough to sustain future payoffs when total collapse is imminent.
- Since no communication or coordination is allowed, this strategy maximizes my own payoff using only stock and history without expecting cooperation.

---

This aggressive strategy balances raw exploitation (defecting every round) with calculated minimal cooperation near resource collapse to avoid zeroing out returns early, thus aligning well with an aggressive but pragmatic mindset.
'''

description_AGGRESSIVE_33 = '''
Below is an aggressive strategy tailored for the Common Pool Resource Game with n players and r rounds. It maximizes the player’s own payoffs by defecting (D) as much as possible, exploiting cooperating players if they exist, and only cooperating when it is strategically beneficial to preserve harvesting opportunities late in the game.

---

### Core Ideas of the Aggressive Strategy

- **Aggression:** Prefer defect (D) every round unless cooperating preserves future payoffs.
- **Exploitation:** Exploit cooperating opponents by defecting against them.
- **Self-Interest Over Cooperation:** No altruistic cooperation; only cooperate if it increases own total payoff.
- **Edge Case Awareness:** Avoid cooperation in first rounds (maximize short-term gain), but avoid stock collapse before the last round by cooperating if necessary.
- **Adaptive Behavior:** Detect if the resource is collapsing (stock near zero) and adjust by cooperating briefly to restore resource, enabling some extraction in the final round.
- **No Trust / No Punishment:** Do not implement tit-for-tat or punish strategies; trust levels not assumed.

---

### Intuition

- Defecting yields double the payoff **in the short run** compared to cooperating.
- However, if everyone defects, stock will collapse, making future rounds worthless.
- Therefore, defect near the start, and if stock gets dangerously low, cooperate temporarily to let the resource restore.
- In the final round, defect always, as no future rounds remain to benefit from conservation.

---

### Decision Rules

Let:

- `t` = current round number (1-based)
- `S_t` = current stock at start of round t (known, public info)
- `threshold_low` = low-stock threshold (e.g., 0.2 * capacity)
- `threshold_recover` = recovery target stock (e.g., 0.5 * capacity)
- Actions: `C` (cooperate), `D` (defect)

---

#### Pseudocode of the Strategy

```pseudo
function choose_action(t, S_t, history):
    if t == r:
        # Last round: Defect to maximize final payoff (no future consequences)
        return D

    if t == 1:
        # First round: Defect to maximize short-term gain before resource depletion
        return D

    # For intermediate rounds (1 < t < r):

    if S_t <= threshold_low:
        # If resource is dangerously low, cooperate to help resource recover
        # but only cooperate until resource passes threshold_recover
        # Once recovered, go back to defecting

        # Look back on previous rounds to detect if we've been cooperating lately
        recent_cooperation_rounds = count_cooperation_in_last_k_rounds(history, k=2)

        if S_t >= threshold_recover:
            # Resource recovered, defect to maximize gain
            return D 
        else:
            # Keep cooperating to help resource recover
            return C
    else:
        # Stock sufficient, defect to maximize payoff
        return D

# Helper function for counting cooperation actions in last k rounds
function count_cooperation_in_last_k_rounds(history, k):
    # history is a list of tuples (actions_of_all_players_in_round)
    # We count how many times this player cooperated in last k rounds
    count = 0
    for round in last k rounds of history:
        if my_action_in_round == C:
            count += 1
    return count
```

---

### Notes on Thresholds and Parameters

- `threshold_low` could be set at roughly 20% of capacity.
- `threshold_recover` could be 50% of capacity, a level high enough to yield reasonable payoffs in subsequent rounds.
- These parameters can be calibrated based on n and capacity, but fixed proportions are straightforward.

---

### Summary of Behavior by Round / Stock Conditions

| Round         | Stock Condition               | Action |
|---------------|------------------------------|--------|
| Round 1       | Any                          | Defect |
| Intermediate  | Stock > threshold_low        | Defect |
| Intermediate  | Stock ≤ threshold_low        | Cooperate to recover until stock > threshold_recover |
| Last          | Any                          | Defect |

---

### Merits of This Strategy

- **Maximizes own short-term extraction:** by defecting whenever possible.
- **Extends resource life:** by cooperating only if the stock is about to collapse.
- **Avoids naive cooperation:** ignores opponent history or attempts to coordinate—fits an aggressive mindset focused on own payoffs.
- **Exploits cooperators:** frequently defects, harvesting the "cooperator discount".
- **Simple and robust:** relies only on public state info and round number.

---

If you want, I can also provide a fully commented pseudocode in your preferred language style. Would you like that?
'''

description_AGGRESSIVE_34 = '''
Here is an **aggressive strategy** tailored for the Common Pool Resource game, fitting the specifications and mindset:

---

### Strategy Name: **"Relentless Defector with Opportunistic Cooperation"**

---

### Overview:
This strategy aggressively prioritizes maximizing immediate personal payoff by defecting as much as possible — extracting the largest allowed share of the resource each round (D actions). However, it strategically cooperates in the last round to avoid unnecessary self-harm from over-exploitation *when future gains are impossible*, or to secure a slightly higher stock level if it benefits.

---

### 1. Decision Rules:

- **Initial round (t = 1):**  
  Always **Defect (D)** to maximize initial payoff and establish an aggressive stance.

- **Intermediate rounds (1 < t < r):**  
  Defect **if the common pool stock (S_t) is sufficiently large**, to guarantee a profitable immediate payoff.  
  Cooperate **only if** the stock is critically low, making defection likely to deplete the pool to zero or near zero, causing your future payoffs to collapse drastically.

- **Last round (t = r):**  
  Always **Cooperate (C)**, since there is no future round to benefit from stock regeneration. Cooperating here minimizes your cost share and slightly preserves the stock (though arguably irrelevant at terminal round), but mainly it signals maximal personal payoff without accelerating stock collapse unnecessarily.

---

### 2. Key Threshold Logic for Intermediate Rounds:

- Define a **critical stock threshold** `S_crit` to avoid taking too large a bite out of the resource when it risks destroying future payoffs.

- Given:  
  - Defect consumption cost per player: \( S_t / n \)  
  - Cooperate consumption cost per player: \( S_t / (2n) \)

- Choose `S_crit` = \( n \) (minimum safe stock to allow one defection without immediate collapse to zero). This is a simple heuristic estimating that if \( S_t < n \), defection will consume entire pool or more, causing zero or negative stock.

- **Logic:**  
  - If \( S_t \geq S_{\text{crit}} \) → Defect  
  - Else → Cooperate

---

### 3. Rationale:

- Aggressively defects as much as possible because:  
  - Defection yields double the immediate payoff compared to cooperation (25 vs 12.5 in example n=4, capacity=100) when the stock is sufficiently large.

- Avoids total exhaustion of the stock by cooperating when the pool risk hitting zero before last round (soft sustainability concern but still aggressive).

- Cooperates in last round to maximize final payoff when no future rounds remain.

- Does **NOT** try to punish or cooperate beyond self-interest—no tit-for-tat or forgiveness, consistent with aggression and no trust assumptions.

---

### 4. Pseudocode

```python
# Inputs: 
# t: current round (1-based)
# r: total rounds
# S_t: current pool stock before actions
# n: number of players

def aggressive_strategy(t, r, S_t, n):
    S_crit = n  # Critical stock threshold

    if t == r:
        # Last round: cooperate to maximize payoff without harming future (no future exists)
        return 'C'
    elif t == 1:
        # First round: defect aggressively
        return 'D'
    else:
        # Intermediate rounds: defect if sustainable, else cooperate to avoid self-destruction
        if S_t >= S_crit:
            return 'D'
        else:
            return 'C'
```

---

### 5. Edge Cases:

- **If initial stock is barely above minimal capacity (e.g., capacity = 2n):**  
  The strategy remains defect in round 1, but likely cooperates in later rounds once the pool shrinks. This aligns with aggressive intent adapted to limited resources.

- **If stock reaches zero before final round:**  
  Cooperate action has no impact on the completely depleted pool; strategy will just return 'C' in last round, best possible payoff zero.

- **If opponents are highly cooperative:**  
  This strategy exploits by defecting early and often, maximizing short-run payoff.

- **If opponents are defecting aggressively:**  
  This strategy accepts rapid depletion and adapts via occasional cooperation in late rounds to soften total wipeout.

---

### Summary:

| Round Type   | Condition           | Action   | Explanation                           |
|--------------|---------------------|----------|-------------------------------------|
| First round  | Always              | Defect   | Aggressive start for max gain       |
| Intermediate | Stock ≥ n           | Defect   | Exploit while sustainable            |
| Intermediate | Stock < n           | Cooperate| Preserve pool to avoid total collapse |
| Last round   | Always              | Cooperate| Maximize terminal payoff, no future |

---

This **Relentless Defector with Opportunistic Cooperation** strategy fits an aggressive mindset: maximize immediate gains aggressively, but strategically avoid needless self-destruction in intermediate rounds and preserve stock at the terminal round to get best possible final harvest.
'''

description_AGGRESSIVE_35 = '''
**Aggressive Strategy for the Common Pool Resource Game**

---

### Strategic Intuition

An aggressive player aims to maximize personal payoff by prioritizing high immediate consumption, at the risk of depleting the common resource. Defecting (D) yields double the payoff per round compared to cooperating (C) for a given stock level. The trade-off is that full defection by all leads to resource collapse (stock = 0), which means zero payoffs in subsequent rounds.

Given perfect information and observability:

- The strategy should **defect whenever it is profitable**, especially early and mid game when the stock is sufficient.
- To prolong the game and avoid zero future payoffs, the strategy monitors the stock and slightly restrains from defecting if the resource is close to depletion (to avoid self-destructive collapse).
- The last round is a "last chance" to grab max payoff—always defect.
- Conditional cooperation is rejected because it gives less payoff and requires trusting others, which is unlikely.

---

### Decision Rules Summary

1. **Round 1:** Defect (D) to maximize first-round payoff.
2. **Intermediate Rounds (2 to r-1):** 
   - If the **estimated next stock** after expected total defections would be **positive and reasonably above zero**, defect.
   - If the stock is critically low (below a threshold), cooperate **once or occasionally** to allow slight recovery.
3. **Final Round (r):** Always defect (D); no future rounds exist.
4. **Adjust based on observed total defections in previous round:**
   - If others are mostly cooperating (low total consumption), defect aggressively.
   - If others are mostly defecting (high total consumption), still defect unless stock close to collapse.
   
---

### Parameters and Thresholds for Aggressiveness

- **Critical stock threshold:** 10% of capacity (threshold = 0.1 × capacity); below which cooperate once to slightly recover.
- Otherwise defect aggressively.

---

### Pseudocode

```python
# Inputs per round:
# round_number: current round index (1-based)
# r: total rounds
# n: number of players
# capacity: max sustainable stock
# S: current stock level at start of round
# last_round_consumptions: list of n actions in previous round ('C' or 'D')
# (For round 1, assume unknown or all C as placeholder)

def aggressive_strategy(round_number, r, n, capacity, S, last_round_consumptions):

    # Constants
    CRITICAL_THRESHOLD = 0.1 * capacity  # 10% of capacity
    
    # Last round: always defect
    if round_number == r:
        return 'D'

    # First round: defect
    if round_number == 1:
        return 'D'

    # Calculate estimated total consumption if all defect
    total_consumption_if_all_defect = S  # since D consumes S/n * n = S

    # Calculate estimated stock after all defect consumption and growth
    S_after_consumption = S - total_consumption_if_all_defect  # = 0 if all defect
    growth = 2 * max(S_after_consumption, 0) * (1 - max(S_after_consumption, 0) / capacity)
    estimated_new_stock = min(S_after_consumption + growth, capacity)
    
    # If estimated_new_stock is below critical threshold, consider cooperating once to preserve stock
    if estimated_new_stock <= CRITICAL_THRESHOLD:
        # Cooperate once to allow growth to replenish stock
        # This is aggressive but slightly self-preserving
        return 'C'

    # Analyze other players' behavior last round (if available)
    # Count defectors in last round
    if last_round_consumptions is not None and len(last_round_consumptions) == n:
        num_defectors = last_round_consumptions.count('D')
    else:
        num_defectors = 0  # Unknown, assume cooperators

    # If many defectors last round, expect stock will be low next round,
    # but still defect to maximize short term gain unless critical stock
    if S <= CRITICAL_THRESHOLD:
        return 'C'  # Slight cooperation to avoid collapse

    # Otherwise, defect aggressively
    return 'D'
```

---

### Behavior Explanation:

- **Rounds 1 to r-1:** Defect aggressively as long as the stock is healthy and the next-step stock won't collapse the resource.
- **Near depletion:** Pause defecting briefly by cooperating once to preserve and allow stock growth.
- **Round r:** Always defect — no consideration for future rounds.
- **No trust:** Doesn't attempt to punish or reward others; highest payoff focus.
- **No communication or signal:** Decisions rely solely on stock and observed history.

---

### Summary

- **Always defect**, except in rare cases with critically low stock where a brief cooperation "breath" helps avoid resource extinction.
- Use stock thresholds to avoid zero future payoffs.
- Final round: full defection.
- This maximizes aggressive extraction and personal payoff, fitting an aggressive mindset with minimal self-preservation logic.

---

This strategy trades long-term sustainability for immediate gain but avoids guaranteed collapse by slight adaptation to resource state. It is aggressive and exploitative but not self-destructively reckless.
'''

description_AGGRESSIVE_36 = '''
Here is an aggressive strategy tailored to this Common Pool Resource game. The strategy focuses on maximizing individual payoffs by defecting as much as possible, exploiting cooperators, and maintaining some modicum of stock for later rounds to avoid immediate ruin — but not sacrificing short-term gain for sustainability or reciprocity.

---

## Aggressive Strategy Description

### Core Insight
- **Defecting (D)** gives a higher immediate payoff than cooperating (C) given the same stock.
- Over-harvesting leads to depletion of the resource, so pure always-defect risks stock collapse.
- To maximize individual payoff, defect aggressively but **moderate** consumption if stock falls too low to avoid zero stock too early.
- Since no trust or cooperation is assumed, the strategy never cooperates for altruistic reasons but adapts to keep playing for as many rounds as possible.
- In the last round, there is no incentive to conserve; defect maximally.

---

### Decision Rules

#### Initialization (Round 1)
- Defect unconditionally to maximize first-round payoff.

#### Intermediate Rounds (2 to r - 1)
- Monitor current stock `S_t`.
- If stock is **sufficiently high** (e.g., ≥ threshold), defect to get maximum individual payoff.
- If stock is **low** (i.e., depletion risk imminent), defect only if it won't reduce stock to 0 after consumption.
- If defecting this round would cause stock to drop to zero or negative after consumption, **cooperate** this round to preserve some stock.
- This preserves at least some stock to maintain positive growth and play further rounds.
- Here "sufficiently high" can be thresholded around `2 × n` (minimum capacity), or more conservatively as a fraction (e.g., > 30% capacity), depending on the exact parameters.

#### Last Round (Round r)
- Defect unconditionally to extract maximal payoff since no future rounds remain.

---

### Handling Edge Cases

- **First round:** Defect unconditionally to maximize initial gain.
- **Last round:** Defect unconditionally to maximize final gain.
- **Stock near zero:** If defecting would completely exhaust the stock this round, cooperate once to keep the pool alive and allow at least some payoff next round, then defect aggressively afterward.
- **Stock collapsed to 0:** No resources left; all payoffs zero. Behavior irrelevant.
- **If capacity or number of rounds is very small:** Same logic applies, with thresholds adjusted accordingly.

---

### Pseudocode

```python
def aggressive_strategy(round_number, total_rounds, current_stock, n, capacity):
    # Parameters
    threshold_stock = max(2 * n, capacity * 0.3)  # Stock threshold to safely defect
    
    # Calculate potential consumptions if defect or cooperate
    consumption_if_C = current_stock / (2 * n)
    consumption_if_D = current_stock / n
    
    # Calculate total defection consumption: n * (current_stock/n) = current_stock (would exhaust stock)
    # Calculate total cooperation consumption: n * (current_stock / (2 * n)) = current_stock / 2 (stock halves)
    
    # Round 1: always defect
    if round_number == 1:
        return 'D'
    
    # Last round: always defect
    if round_number == total_rounds:
        return 'D'
    
    # Simulate stock after full defection this round
    # Total consumption if all defect: current_stock (stock drops to zero)
    # But others may cooperate or defect, unknown - assume worst case (all defect)
    # To be aggressive, assume others defect so defecting won't help keep stock.
    # So to avoid losing future rounds, cooperate if defecting kills the stock prematurely.
    
    # Predict stock after own defection assuming worst case (all defect):
    total_consumption_if_all_defect = current_stock  # full depletion
    stock_after_consumption = current_stock - total_consumption_if_all_defect  # 0
    
    # Growth from zero stock is zero, so new stock zero
    new_stock_if_defect = 0
    
    # Predict stock if cooperate and others defect (worst case):
    # Total consumption = (n-1)*defect + 1*cooperate
    total_consumption_if_cooperate = (n-1) * consumption_if_D + consumption_if_C
    stock_after_consumption_coop = current_stock - total_consumption_if_cooperate
    # growth = 2 * S_remaining * (1 - S_remaining / capacity)
    growth_coop = 2 * stock_after_consumption_coop * (1 - stock_after_consumption_coop / capacity)
    new_stock_if_cooperate = min(stock_after_consumption_coop + growth_coop, capacity)
    
    # Decision logic
    # If defecting guarantees zero stock next round (destroy resource), cooperate to preserve it
    if new_stock_if_defect == 0 and new_stock_if_cooperate > 0 and round_number < total_rounds - 1:
        return 'C'
    
    # If stock is above threshold, defect to maximize payoff
    if current_stock >= threshold_stock:
        return 'D'
    
    # Else cooperate to maintain resource
    return 'C'
```

---

### Explanation:

- **Always defect first and last rounds for payoff.**
- **In intermediate rounds, defect if stock is healthy.**
- **If defecting kills the stock, cooperate once to preserve it for more payoff.**
- This is aggressive because it defects whenever possible and only cooperates as a tactical move to extend play and future payoffs.
- It assumes worst-case opponent behavior (all defect), so is defensive-aggressive.
- It never attempts cooperation for mutual benefit or trust-building.

---

## Summary

| Situation                  | Action   | Reason                             |
|----------------------------|----------|----------------------------------|
| Round 1                    | Defect   | Maximize first round payoff      |
| Round r (last round)       | Defect   | No future rounds to protect      |
| Intermediate rounds, stock ≥ threshold | Defect   | Aggressively maximize payoff     |
| Intermediate rounds, defecting kills stock | Cooperate | Tactical preservation for future |
| Stock is depleted (0)      | N/A      | No payoff possible                |

---

This aggressive strategy balances maximal exploitation of the common pool with self-preservation sufficient to keep harvesting for multiple rounds in face of full-defect assumptions on opponents.
'''

description_AGGRESSIVE_37 = '''
Below is a detailed aggressive strategy proposal tailored for the specified Common Pool Resource Game that you can enter into a tournament against unknown opponent strategies.

---

## Strategy Name: **"Always Strike Hard"**

---

### Intuition Behind the Strategy:

- The aggressive mindset demands maximizing your own payoff in every round, without regard for sustainability or cooperation.
- Defecting (D) yields strictly more payoff per round than cooperating (C) given equal stock.
- Since stock depends collectively on everyone’s consumption, aggressive defecting initially will deplete stock quickly.
- Despite depletion, defecting always gives higher immediate payoff.
- In later rounds, even if stock is low, defecting still yields better payoff than cooperating.
- Therefore, never cooperate.
- Since information is perfect and history observable, no incentive to cooperate to sustain stock.
- This is a full defection strategy maximizing short-term gain at expense of the commons.

---

### Decision Rules

| Round     | Action                          | Reasoning                                                                                           |
|-----------|--------------------------------|---------------------------------------------------------------------------------------------------|
| All rounds (1 to r-1) | Defect (D)                     | Maximize immediate payoff by consuming largest share per round. Defecting always yields more than cooperating. |
| Final round (r)        | Defect (D)                     | Same as above; last round so no future repercussions from depletion.                               |

No conditional strategies or retaliations; pure defection.

---

### Edge Cases Handling:

- **First round:** Stock is at capacity; defect to claim maximum payoff.
- **Last round:** No incentive to spare stock; defect to extract maximal point.
- **Stock near zero or zero:** Even if stock is depleted to zero, defecting results in zero payoff, no worse than cooperating.
- **Number of players n ≥ 2 and capacity ≥ 2n:** Strategy doesn’t depend on n or capacity values explicitly.

---

### Pseudocode

```python
def aggressive_strategy(round_number, total_rounds, stock, player_index, observed_actions):
    # Input:
    # - round_number: current round (1-based)
    # - total_rounds: total rounds r
    # - stock: current stock level S before decision this round
    # - player_index: your player id (not used here)
    # - observed_actions: history of all players' past actions up to round_number - 1 (not used)

    # Aggressive strategy: always defect regardless of stock or history
    return 'D'
```

---

### Explanation of Optimality Under Aggressiveness

- **Defecting yields payoff = S/n, double the cooperating payoff = S/(2n).**  
- Extracting more now pays off better than cooperating or waiting.  
- No incentive to preserve stock for future rounds — maximizing immediate rounds payoffs dominates.  
- Even repeated depletion does not deter aggressive play as opponents’ behavior is unknown and no communication exists.

---

### Summary

| Strategy Component | Description                       |
|--------------------|---------------------------------|
| Action each round  | Always Defect (D)                |
| Rationale          | Maximize immediate payoff; no cooperation or delayed reinvestment |
| Edge cases         | Uniform handling; same default action in all rounds |
| Use of information | None beyond knowing round number or stock (but decision does not depend on them) |

---

This is a simple, pure-aggressive, no-cooperation strategy that should perform well if opponents are less ruthless or if future sustainability is undervalued.

If you want me to produce a less trivial or conditional aggressive strategy (e.g., defect unless stock extremely low?), I can do so. But per your requirements and game structure, this pure defection baseline is the most aggressive and clear-cut.

---

Please let me know if you want me to describe an alternative or more sophisticated aggressive approach.
'''

description_AGGRESSIVE_38 = '''
**Aggressive Strategy for the Common Pool Resource Game**

---

### Core Idea

The aggressive strategy aims to maximize *individual* payoff by consistently defecting (D) except in particular defensive cases, prioritizing short-term gain over stock sustainability. It exploits cooperative players whenever possible, tolerates occasional cooperation only to maintain some stock to exploit in future rounds, but defects strongly when stock is nearing depletion or in the last round where no future concern exists.

---

### Intuition

- **Defect (D) maximizes per-round payoff**, consuming `stock/n` rather than `stock/(2n)` as Cooperate (C) does.
- The **stock dynamics enable regrowth if the stock remains sizable**, so a fully full-on defect all the time might wreck the resource and reduce long-term payoffs.
- Hence, a truly aggressive player **defects constantly** unless the stock is so low that a defect would leave no stock for future rounds, in which cooperate briefly to preserve some resource.
- On the **last round, defect unconditionally** to extract maximum payoff since the game ends.
- On the **first round**, defect to signal aggressive intent and achieve immediate high payoff.

---

### Decision Rules

---

| Condition                                      | Action   | Rationale                                                  |
|------------------------------------------------|----------|------------------------------------------------------------|
| **Round = 1**                                  | Defect (D) | No prior info, maximize immediate payoff                    |
| **Round = r (last round)**                     | Defect (D) | No future rounds, maximize immediate payoff                 |
| **Stock after consumption < threshold (low)** | Cooperate (C) | Conserve stock to allow regrowth, to avoid game-ending depletion |
| **Otherwise**                                  | Defect (D) | Exploit resource fully when stock is sufficiently healthy  |

---

### Threshold for Low Stock

Define a critical threshold to detect when stock is "too low":

- Let `stock` be current stock before this round's actions.
- Estimate expected total consumption if all defect: `n * (stock / n) = stock`.
- Fully defecting depletes stock to 0 → no growth.
- To avoid killing the resource, if stock is very low, defecting might collapse future payoff.
  
We trade-off:

- Cooperate to save some stock if current stock is below a critical fraction of capacity, e.g. `stock ≤ capacity / (2 * n)`

Why `capacity / (2 * n)`? Because:

- Cooperate consumes `stock/(2n)`, which is half a defector's share and thus less destructive.
- When stock is wildly low relative to capacity, cooperate to slowly conserve stock.

---

### Putting It All Together

**Parameters:**
- `n` = number of players (≥ 2)
- `r` = number of rounds (> 1)
- `capacity` = max stock (≥ 2n)
- `stock` = current stock at round start (updated from previous round)
- `round` = current round (1 to r)

**Strategy pseudocode:**

```python
def aggressive_strategy(round, r, stock, n, capacity):
    # Constants
    LOW_STOCK_THRESHOLD = capacity / (2 * n)

    # 1. First round: defect to maximize payoff
    if round == 1:
        return "D"

    # 2. Last round: defect unconditionally
    if round == r:
        return "D"

    # 3. Low stock scenario: cooperate to conserve stock
    if stock <= LOW_STOCK_THRESHOLD:
        return "C"

    # 4. Default: defect to maximize immediate payoff
    return "D"
```

---

### Comments

- This truly aggressive strategy prioritizes immediate gain (defect) unless resource collapse would strongly diminish future payoffs.
- It only cooperates when stock is extremely low, to enable the resource to regrow, ensuring more rounds with opportunity to defect again.
- This strategy **does not attempt to punish or reward opponents** based on their behavior; it is purely stock-state driven and time-aware.
- Assumes perfect observability of stock after each round (game spec says common information).
- No consideration of opponent modelling or cooperation—purely "exploit unless forced to conserve".

---

### Summary

| Round        | Stock Condition                | Action    |
|--------------|-------------------------------|-----------|
| first round  | any                           | Defect (D)|
| final round  | any                           | Defect (D)|
| any other    | stock ≤ capacity/(2n) (low)   | Cooperate (C) |
| any other    | stock > capacity/(2n) (healthy) | Defect (D) |

This strategy embodies aggression by consistently defecting except when conserving the resource is absolutely necessary to maintain future payoff opportunities. It extracts maximal benefit from cooperative opponents while aiming to avoid stock collapse that limits payoffs in repeated rounds.
'''

description_AGGRESSIVE_39 = '''
Below is a fully specified **Aggressive Strategy** tailored for the given Common Pool Resource Game. It prioritizes maximizing individual payoffs via defection whenever possible, while adapting minimally given the risks of stock depletion that would reduce future payoffs.

---

# Aggressive Strategy Description

**Key Idea:**  
Maximize immediate payoffs by defecting (D) as often as possible, since defecting yields higher per-round payoff per player than cooperating. Defecting consumes more stock per player, which risks running down the stock and losing future payoffs. To mitigate this, defect always except in the last round (where cooperation or defection does not affect future rounds), and when the stock falls critically low to prevent self-harm, cooperate just enough to preserve a minimal positive stock for round payoff.

---

# 1. Decision Rules

Let round index \( t = 1, 2, \ldots, r \), current stock \( S_t \), capacity \( C \), number of players \( n \).

- **If \( t < r \) (not last round):**  
  - If \( S_t \) is high enough to sustain defection consumption by all players *without driving the stock to zero*, defect (D).  
  - Else, cooperate (C) to conserve the stock, preventing full depletion.

- **If \( t = r \) (last round):**  
  - Defect (D) unconditionally to maximize immediate payoff since no future rounds remain.

---

## Threshold for "stock high enough"

- Max total consumption if all defect:  
  \[
  \text{max_total_defect_cons} = n \times \frac{S_t}{n} = S_t
  \]
  i.e., all defecting consumes all stock (reduces stock to zero).

- Defecting always consumes all the stock if everyone defects; the growth function then rebounds stock only if stock after consumption is nonzero, which it won't be. This means all defecting on round \( t < r \) will likely destroy stock for future rounds, reducing future payoff to 0.

- To avoid full destruction, check if that action will leave some positive stock after consumption or enough growth to recover.

Because stock growth depends on remaining stock after consumption, and to prevent getting zero stock:

- **Rule:** Defect only if current stock above a threshold \( S_{min} \) to permit next round payoffs to be positive. For aggressive simplicity, set:
  \[
  S_{min} = n
  \]

- Why \( n \)? Because each defection consumes \( S_t/n \) per player; if \( S_t < n \), then \( S_t/n < 1 \), leading to trivial payoffs and nearly zero growth.

- If \( S_t < S_{min} \), cooperate to reduce consumption and preserve stock.

---

## Summary of decision:

| Condition                        | Action |
|---------------------------------|---------|
| \( t = r \) (last round)          | Defect  |
| \( t < r \) and \( S_t \ge n \)   | Defect  |
| \( t < r \) and \( S_t < n \)     | Cooperate |

---

# 2. Handling Edge Cases

- **First round (\( t=1 \))**  
  - No previous history, but stock = capacity ≥ 2n by assumption. So, \( S_1 \ge 2n \), which is > n, so defect.

- **Last round (\( t = r \))**  
  - Defect always to maximize immediate payoff. No future stock concerns.

- **Very low stock \( S_t < n \) before last round:**  
  - Cooperate to consume less per capita and protect remaining stock.

- **Stock exactly zero**  
  - Cooperating or defecting yields zero payoff anyway. Defect by default to maximize immediate return if any.

- **Stock below zero due to numerical issues (shouldn’t happen under specification)**  
  - Treat as zero.

---

# 3. Pseudocode

```python
def aggressive_strategy(t, r, S_t, n, capacity):
    # Input:
    # t: current round (1-based)
    # r: total number of rounds
    # S_t: current common pool stock
    # n: number of players
    # capacity: max stock (not used in decision here)

    S_min = n  # Threshold stock to sustain defection

    if t == r:
        # Last round: defect unconditionally
        return 'D'
    
    if S_t >= S_min:
        # Stock is high enough to defect aggressively
        return 'D'
    else:
        # Stock is too low, cooperate to conserve
        return 'C'
```

---

# 4. Discussion and Rationale

- **Aggressive mindset:**  
  Nearly always defect to get higher payoff: \( \pi_i = S_t / n \) vs cooperating payoff \( S_t / (2n) \). Defection doubles your payoff per round compared to cooperation.

- **Stock preservation exception:**  
  If stock is very low, defecting will extinguish the resource in the next round, leading to zero payoffs from then on. Cooperating conserves stock.

- **No explicit punishment or reward strategy:**  
  Assumes opponents will act independently, possibly defecting. Forgoes cooperation except where forced by stock scarcity.

- **No guesswork on others’ behavior:**  
  Decision depends only on stock level and round count.

---

# Summary

This aggressive strategy aggressively defects each round unless the stock is critically low before the last round, to maximize immediate payoff while minimally preserving stock. It defects unconditionally in the final round to maximize terminal gain regardless of stock state.

This approach balances aggressive exploitation with minimal resource sustainability to maximize total payoff over \( r \) rounds.
'''

description_AGGRESSIVE_40 = '''
Here is a clear, aggressive strategy tailored for the Common Pool Resource Game. It maximizes immediate gain by defecting as often as possible, while managing the risk of stock depletion to ensure payoff accumulation across rounds. It uses observed actions to decide when to adjust behavior aggressively, but its default is defect.

---

### Aggressive Strategy Description

**Goal:** Maximize personal total payoff by defecting whenever it is beneficial while exploiting opportunities to maintain the resource just enough to keep earning high payoffs, even if that risks depleting the common pool by the end.

---

### 1. Decision Rules

- **Round 1 (Initial):**  
  Defect (D).  
  *Rationale:* Starting aggressively to maximize immediate payoff before cooperation could benefit others without your gain.

- **From Round 2 to Round (r - 1):**  
  - After observing previous round actions of all players:
    - If **any player cooperated in the previous round**, defect (D).  
      *Rationale:* No incentive to cooperate if others cooperate; exploit their cooperation.
    - Else if **all defected in the previous round**, defect (D).  
      *Rationale:* No reason to cooperate if everyone is defecting; remain aggressive.

  *Summary:* Always defect regardless of others. However, this formalizes that you don't mistakenly cooperate thinking others do.

- **Last Round (Round r):**  
  Defect (D).  
  *Rationale:* No future consequences, so maximize personal payoff.

---

### 2. Edge Case Handling

- **If stock approaches zero before last round:**  
  Continue defecting (D).  
  *Reasoning:* Being aggressive means not compromising on immediate gain even if the resource collapses early. Yielding by cooperating won't improve final payoff.

- **If stock is at or near capacity in any round:**  
  Defect (D).  
  *Rationale:* High stock means full payoff from defecting now; do not cooperate.

- **If observed actions somehow are unavailable or incomplete:**  
  Default to defect (D).

---

### 3. Strategy Summary

- **Always defect in every round, regardless of others' actions or resource stock level.**

Because:

- Defecting yields double the payoff per round compared to cooperating (S/n vs. S/(2n)).
- Cooperating only benefits others since your payoff is lower.
- Defecting yields maximum short-term personal payoffs.
- Since no communication or coordination is possible, there's no reason to cooperate to maintain stock.  
- This approach aligns perfectly with an aggressive strategy: exploit the common pool selfishly, maximize immediate returns at the risk of eventual depletion.

---

### Pseudocode

```python
def aggressive_strategy(round_number, total_rounds, stock, history):
    """
    Parameters:
        round_number (int): current round (1-based)
        total_rounds (int): total rounds in the game (r)
        stock (float): current stock level (S)
        history (list of dicts): past rounds actions, e.g.,
            [{'player_1': 'C', 'player_2': 'D', ..., 'player_n': 'C'}, {...}, ...]

    Returns:
        action (str): 'C' for cooperate, 'D' for defect
    """
    # Always defect
    return 'D'
```

---

### Additional Notes

- The strategy is simple but robust and strictly aggressive.
- It does not waste opportunities by cooperating.
- Given the payoff structure where defecting always yields higher individual payoff per round, and no coordination is possible, this is the most aggressive rational strategy.
- While this may cause rapid depletion of stock (a collective tragedy of the commons), this is consistent with the aggressive mindset.
- Opponents cooperating will only increase your payoff since you defect.
- Opponents defecting means everyone suffers eventual depletion; your strategy still maximizes your personal gain until then.

---

Let me know if you'd like an alternative aggressive-but-slightly-conditional strategy for comparison.
'''

description_AGGRESSIVE_41 = '''
Here is an aggressive strategy designed for the described common pool resource game. The strategy maximizes immediate individual gain through defection, but it also uses some dynamic conditioning on observed depletion to exploit cooperative opponents when appropriate.

---

### Strategy Overview

**Core principle:**  
Always defect (consume stock/n) to maximize immediate round payoff except when aggressive exploitation of cooperating opponents can increase long-run gain or when the resource is nearly depleted.

**Aggressiveness:**  
- Prioritize defect to get higher payoff each round.
- Exploit cooperators by repeatedly defecting to reduce their payoff share and hasten depletion.
- Do not cooperate unless it is strictly beneficial in the last round or when the stock is nearly depleted and defection yields no extra benefit.

---

### Detailed Decision Rules

Let:  
- `t` = current round (1 ≤ t ≤ r)  
- `S_t` = current stock before round t  
- `actions_t-1` = vector of all players' actions in previous round (known after first round)  
- `r` = total rounds  
- `n` = total players  

**Constants:**

- `defect_consumption = S_t / n`
- `cooperate_consumption = S_t / (2n)`  

---

### Rule 1: Initial Round (t=1)

- No history available, maximize immediate payoff → **Defect**

---

### Rule 2: Rounds t = 2 to r-1  
Conditions:

1. After round t-1, check opponent actions:
   - `num_defectors_t-1` = count of other players who defected in round t-1
   - `num_cooperators_t-1` = n - 1 - num_defectors_t-1  

2. Check current stock state:
   - If `S_t` ≤ `capacity / (2n)` (very low stock relative to number of players), cooperating gives almost same payoff as defecting (due to little resource). Defect anyway, since payoffs are low and defection keeps maximizing immediate gain.

3. Behavior:

- If **any** opponents cooperated in previous round (`num_cooperators_t-1 > 0`):  
  - Continue **defecting** to aggressively exploit cooperators’ restraint and increase your share.  
  - This speeds depletion and increases your relative payoff share in the short run.

- If **all opponents defected** in previous round (`num_cooperators_t-1 = 0`):  
  - Everyone defects = everyone low payoff and rapid depletion.  
  - Continue **defecting**, no incentive to cooperate.

---

### Rule 3: Last Round (t = r)

- No future rounds to preserve stock → always **defect** to maximize last-stage payoff.

---

### Summary

| Round          | Condition                                    | Action     |
|----------------|----------------------------------------------|------------|
| t = 1          | No history                                   | Defect     |
| 1 < t < r      | Any opponents cooperated last round?         | Defect     |
| 1 < t < r      | All opponents defected last round             | Defect     |
| 1 < t < r      | Stock very low (≤ capacity/(2n))              | Defect     |
| t = r          | Last round, no future concerns                 | Defect     |

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, capacity, S_t, actions_prev):
    # t: current round (1-indexed)
    # r: total number of rounds
    # n: number of players
    # capacity: resource capacity
    # S_t: current stock before round t
    # actions_prev: list of previous round's actions of all players except self ('C' or 'D')
    # returns: 'C' or 'D'
    
    # FIRST ROUND: no history
    if t == 1:
        return 'D'
    
    # LAST ROUND: maximize immediate payoff
    if t == r:
        return 'D'
    
    # Number of cooperators and defectors in previous round among opponents
    num_cooperators = sum(1 for a in actions_prev if a == 'C')
    num_defectors = len(actions_prev) - num_cooperators
    
    # Threshold for low stock, conservatively estimated as capacity/(2n)
    low_stock_threshold = capacity / (2 * n)
    
    # If stock is very low, defect anyway to maximize immediate payoff
    if S_t <= low_stock_threshold:
        return 'D'
    
    # If any opponents cooperated last round, aggressively defect to exploit
    if num_cooperators > 0:
        return 'D'
    
    # If all opponents defected last round, continue defecting
    return 'D'
```

---

### Rationale

- This strategy **always defects**—maximizing individual immediate reward and never diluting payoff by cooperating.
- It uses history to identify cooperators to exploit (by continuing defection rather than "forgiving").
- It does not cooperate even when stock is low, prioritizing aggression over sustainability.
- On the last round, defecting is strictly dominant.
- It foregoes cooperative or punitive retaliation strategies to maintain consistent aggression.
- Such strategy yields high payoffs if opponents cooperate and punishes restrained opponents harshly.
- Opponents who defect will result in a faster depletion, but since this strategy defects anyway, it takes no backward steps.

---

This aggressive, defect-unconditionally strategy aligns with an aggressive mindset aiming for maximum short-term payoff at the likely cost of the resource's sustainability and long-run group welfare.
'''

description_AGGRESSIVE_42 = '''
Here is an aggressive strategy designed for the common pool resource game you described.

---

### Strategy Name: **Defect-First, Punish-Late**

---

### 1. Summary of the Aggressive Approach

- Start aggressively by defecting immediately to maximize short-term payoff.
- Observe the history of others' actions to detect possible retaliations.
- Continue defecting throughout the game regardless of others' behavior, maintaining maximum individual payoff as much as possible.
- On the very last round, defect to capture the final maximal payoff without concern for future rounds.
- Use a minor exception for self-preservation when the stock becomes critically low (too close to zero), temporarily cooperate to prevent total depletion, aiming to sustain payoff longer.
- Do **not** cooperate proactively or attempt to rehabilitate the stock except when forced by stock collapse risk.
- Prioritize personal gain over group sustainability.

---

### 2. Decision Rules (Step-By-Step)

**Notation:**
- `t`: current round (1-based)
- `r`: total rounds
- `S`: current stock level (common knowledge)
- `actions_t_minus_1`: vector of all players’ actions in the previous round
- `threshold_stock`: very low stock level threshold (e.g., capacity / (4n)) to avoid zero stock collapse

---

**Round 1 (First round):**

- Defect outright.
```pseudo
if t == 1:
    play D
```

---

**Middle rounds (2 ≤ t < r):**

- If stock `S` is **above** threshold_stock:
  - Defect unconditionally.
- Else if stock `S` is **below or equal to** threshold_stock:
  - Cooperate in this round to allow stock to partially recover and avoid collapse.
```pseudo
else if t < r:
    if S > threshold_stock:
        play D
    else:
        play C
```

---

**Last round (t = r):**

- Defect regardless of stock level to maximize final payoff.
- No incentive to preserve stock after final round.
```pseudo
else if t == r:
    play D
```

---

### 3. Handling Edge Cases:

- **Stock near zero:**

  The risk of a zero stock means zero payoff not only now but in all future rounds. To maximize total payoff, temporarily cooperate when stock is critically low. This is a defensive, forced cooperation, not a shift in aggressiveness.

- **If others retaliate by defecting in response:**

  Continue defecting; do not attempt to cooperate to reinstate cooperation. Retaliation does not change the strategy because the priority is personal gain.

- **If others mostly cooperate:**

  Defecting maximizes immediate gain versus cooperators, fulfilling the aggressive goal.

- **If others defect:**

  Your defecting matches or beats their payoff share.

- **If stock has fully collapsed (S=0):**

  No difference in actions is possible; all payoffs are zero. Strategy remains defect by default.

---

### 4. Pseudocode Summary

```pseudo
function aggressive_strategy(t, r, S, actions_t_minus_1, capacity, n):
    threshold_stock = capacity / (4 * n)

    if t == 1:
        return D
    else if t < r:
        if S > threshold_stock:
            return D
        else:
            // cooperate defensively to avoid total collapse
            return C
    else:
        // last round: defect for maximal payoff
        return D
```

---

### 5. Explanation

- **Why defect first?**  
  Defecting in the first round secures the highest possible individual payoff immediately (S/n vs S/(2n)).

- **Why defect until stock gets low?**  
  Staying aggressive extracts high payoffs as long as the resource is viable.

- **Why cooperate when stock is very low?**  
  A small concession to keep the resource alive prevents zero payoffs for the last rounds, which mitigates score loss from resource extinction.

- **Why defect in the final round?**  
  No further rounds mean no incentive to conserve resource; all payoff-maximizing moves are to defect.

- **No forgiveness or cooperation attempts:**  
  Purely aggressive; prioritize short-term gain and maintain defection despite others' choices.

---

This strategy is a pure aggressive exploit: maximize payoff by defecting, only cooperate defensively to prevent ruin, defect to end the game. It is consistent with no communication, perfect information, and finite repeated play circumstances.
'''

description_AGGRESSIVE_43 = '''
Here is an aggressive strategy tailored to this Common Pool Resource game. The design explicitly prioritizes immediate gain by defecting aggressively, with some tactical cooperation only if it significantly benefits the aggressor near the end in order to maximize total payoff. Cooperation is never initiated and only tolerated in strictly self-beneficial conditions.

---

## Aggressive Strategy Description

**Core intuition:**  
Always defect (D) to maximize your per-round payoff, leveraging the higher individual share (S/n) from defection. Do not trust or rely on others to cooperate, since you cannot coordinate or enforce norms, and assume opponents are also rational and potentially aggressive. Only consider cooperating in the very last round if cooperation leads to a stable or slightly improved stock that boosts your payoff in that round or future theoretical gains.

---

### Decision Rules

- **Round 1 to r-1 (all but last):**  
  **Always Defect (D)**  
  Rationale:  
  - Defecting yields payoff = S/n, double what a cooperator gets (S/(2n)) if cooperating unilaterally.  
  - By defecting aggressively, you exploit the resource maximally.  
  - Since others can defect too, the stock will likely go down; but you prioritize immediate gains.

- **Round r (last round):**  
  - Observe current stock S.  
  - Calculate payoff if you cooperate vs defect this round:  
    - π_i(C) = S/(2n)  
    - π_i(D) = S/n  
  - Compare with opponents’ last actions:  
    - If everyone defected last round or stock is very low → defect again (nothing to gain by cooperating).  
    - If stock is *relatively healthy* (e.g., S > capacity/2) **and** if cooperating this round results in a higher immediate payoff than defecting because of growth benefits from cooperation (rare, but possible when n is large), then cooperate only in last round.  
    - Otherwise defect.

---

### Additional Tactical Considerations

- **Monitoring opponents:**  
  Given perfect information on all previous actions, track the count of cooperators vs defectors each round:  
  - If a majority cooperated last round and stock remains high, consider cooperating in the final round to extract some payoff with minimal stock depletion.  
  - Never initiate cooperation earlier since it risks exploitation.

- **Threshold for cooperation on last round:**  
  To keep it simple and robust to unknown opponent behavior and parameters, cooperate in the last round only if:  
  - Stock S ≥ capacity / 2  
  - And at least half of the players cooperated last round (indicating a relatively stable stock environment)

---

### Pseudocode

```python
def aggressive_strategy(round_t, total_rounds, current_stock, capacity, n, history):
    """
    Parameters:
        round_t (int): current round number (1-based)
        total_rounds (int): total rounds r
        current_stock (float): stock level at start of round t
        capacity (float): max sustainable stock
        n (int): number of players
        history (list of lists): each inner list is the actions of all players in round <t-1>

    Returns:
        action (str): 'C' or 'D'
    """

    # Always defect except possibly last round
    if round_t < total_rounds:
        return 'D'

    # On last round:
    # Compute payoffs for Cooperate vs Defect this round:
    payoff_c = current_stock / (2 * n)
    payoff_d = current_stock / n

    # Count cooperators last round
    if round_t == 1:
        # No history yet, defect
        return 'D'

    last_round_actions = history[-1]  # actions from round t-1
    coop_count = last_round_actions.count('C')

    # Cooperation condition threshold
    stock_threshold = capacity / 2
    coop_threshold = n / 2

    # If stock healthy and opponents somewhat cooperative, cooperate now; else defect
    if current_stock >= stock_threshold and coop_count >= coop_threshold:
        # Only cooperate if payoff from cooperate ≥ payoff from defect (usually false)
        # But cooperate anyway as a signal or to protect stock minimally
        if payoff_c >= payoff_d:
            return 'C'
        else:
            # Still can cooperate if signaling benefits are desired (but no enforcement)
            # To keep aggressive mindset, defect here if defect payoff strictly better
            return 'D'

    # Otherwise, defect
    return 'D'
```

---

## Summary

| Round       | Decision                      | Reason                                                                                      |
|-------------|-------------------------------|---------------------------------------------------------------------------------------------|
| 1 to r-1    | Defect (D)                    | Maximize immediate individual payoff; no trust in cooperation.                              |
| Last round  | Cooperate (C) only if stock ≥ capacity/2 and at least half others cooperated last round; else Defect (D) | Potential small gain or preservation of stock if environment stable; else final grab.       |

---

This strategy embodies aggressive behavior by prioritizing defection throughout, capturing as much resource as possible, and only cautiously cooperating in the very last round to salvage leftover stock under favorable conditions. It avoids the risk of exploitation by never initiating cooperation early and defecting predictably.
'''

description_AGGRESSIVE_44 = '''
Here is an aggressive, clearly exploitative and dominance-seeking strategy tailored to this Common Pool Resource Game.

---

### Aggressive Strategy Description

**High-level strategy:**  
Always defect (D) unless there is forced reason to cooperate (mostly for stock preservation near the end). This strategy maximizes immediate payoff per round. Being aggressive means consistently choosing the action that yields the highest individual round payoff — defect — regardless of cooperation incentives that preserve the resource. Since other players may be cooperative or mixed, this strategy exploits them by taking the higher payoff per round.

**Key intuition:**

- Defecting always gives a higher per-round payoff than cooperating (S/n > S/(2n)).
- Depleting the resource aggressively hurts everyone over time, but this strategy ignores that in favor of harvesting maximal payoff each round.
- In the last round, no incentive to preserve the stock, so defect aggressively.
- In early rounds, defect to maximize immediate gain.
- If stock is depleted (near zero), no point in cooperation because no return—defect (take whatever is left, even if zero).
- Slight exception if stock is on the brink of zero after consumption (since defecting will get zero payoff next rounds); but since payoff is per round and no future returns matter in last round, simply defect always.

---

### Decision Rules (Pseudocode)

```python
def aggressive_strategy(round_number, total_rounds, stock, capacity, n, history):
    """
    Inputs:
    - round_number: current round (1-based index)
    - total_rounds: total number of rounds r
    - stock: current common pool stock S before action
    - capacity: max stock capacity
    - n: number of players
    - history: list of tuples (actions_all_players, payoffs_all_players) for previous rounds
    
    Output:
    - action: 'C' or 'D'
    """
    
    # In any round:
    # Immediate payoff from defect = stock / n
    # Immediate payoff from cooperate = stock / (2n)
    # Defect always yields higher immediate payoff
    
    # Edge case: Last round has no future consequences, so defect
    if round_number == total_rounds:
        return 'D'
    
    # Edge case: If stock is 0 or close to zero, defect anyway (no gain, but no penalty)
    # This also handles low-stock edge cases gracefully.
    if stock <= 0:
        return 'D'
    
    # Main rule: Always defect to maximize immediate gain
    return 'D'
```

---

### Explanation of Edge Cases

- **First round (round_number == 1):** No information about others yet, still defect to grab maximum immediate payoff.
- **Intermediate rounds (1 < round_number < r):** Defect always to secure highest per-round payoff. No attempt at cooperation, even if stock falls — aggressive exploitation.
- **Last round (round_number == r):** Defect because no future rounds, so preserving stock is pointless.
- **Near depletion (stock ≤ 0):** Defect anyway; stock zero means no payoff, but cooperation doesn’t help.
- **Stock at capacity or moderate levels:** Still defect to maximize per-round payoff.

---

### Why this is Aggressive

- This is the most exploitative approach — taking the largest share per round.
- It ignores sustainable harvesting or cooperation incentives.
- It pressures resource depletion, aiming to maximize payoff even if the resource collapses.
- Opponents cooperating become exploited since defectors get twice their payoff in that round.
- No signal of willingness to cooperate; a pure aggressive defection strategy.

---

### Summary

| Condition                      | Action  | Reason                                      |
|-------------------------------|---------|---------------------------------------------|
| Any round (including first)    | D       | Defect maximizes immediate payoff           |
| Last round (r-th)              | D       | No future benefit from preservation          |
| Stock ≤ 0                     | D       | No payoff from cooperation anyway            |

---

This aggressive strategy maximizes short-term gains without regard for resource sustainability or future rounds. It aims to outperform cooperating or conditional strategies by relentless defection.
'''

description_AGGRESSIVE_45 = '''
Below is a detailed aggressive strategy design for the Common Pool Resource Game that explicitly states the decision rules, handles edge rounds, and embraces aggressive consumption to maximize short-term payoffs, potentially at the expense of long-term cooperation.

---

## Aggressive Strategy Description

### Core Idea  
Maximize immediate individual payoffs by defecting (D) whenever profitable, but incorporate some short-term adaptive behavior to exploit cooperators and prevent being exploited in the last round, ensuring no unnecessary cooperation. This strategy prioritizes individual gain, accepting depletion risks as necessary.

---

### 1. Decision Rules

**Notation:**
- Let *t* = current round (1 ≤ t ≤ r)
- Let *S_t* = observed stock at start of round *t*
- Let *actions_{t-1}* = vector of opponents' actions in previous round
- Let *defectors_{t-1}* = count of opponents who defected in round *t-1*

---

#### Round 1 (Initial round)
- No history available.
- **Action:** Defect (D)  
  > Reason: No history, maximal immediate payoff.

---

#### Intermediate rounds (1 < t < r)
- Observe opponents' last round actions.
- If **any opponent defected** in *t-1* (defectors_{t-1} ≥1), **defect** (D).  
  > Punish defectors immediately; no cooperation with defectors.

- Else (all cooperated last round), **defect** (D).  
  > Aggressive mindset: exploit cooperators for higher payoff.

- **Summary:** Always defect after round 1.

---

#### Last round (t = r)
- Always defect (D).  
  > No future punishment possible; maximize last round payoff.

---

### 2. Edge Cases

- **If stock S_t is very low (close to zero):**

  The strategy ignores stock exhaustion risks — continues to defect aggressively regardless of stock.  
  > Rationale: Maximizing immediate gains even if stock/welfare collapses.

- **If opponents all cooperate continuously:**

  The strategy exploits them by defecting every round except the first (no forgiveness).  
  > Aggressive exploitation without cooperation.

- **If all defect continuously:**

  The strategy defects as well, avoiding being exploited.

---

### 3. Pseudocode for Decision in Round t

```python
def aggressive_strategy(t, r, S_t, opponent_actions_prev_round):
    # First round
    if t == 1:
        return 'D'  # Defect by default
    
    # Last round
    if t == r:
        return 'D'  # Defect to maximize final payoff
    
    # Intermediate rounds
    # Count defectors in previous round
    defectors_prev = sum(1 for a in opponent_actions_prev_round if a == 'D')
    
    if defectors_prev >= 1:
        return 'D'  # Punish defectors strictly
    else:
        return 'D'  # Exploit cooperators aggressively
```

---

### 4. Strategy Summary

| Round           | Condition                        | Action |
|-----------------|--------------------------------|--------|
| t = 1           | No history                     | D      |
| 1 < t < r       | Any opponent defected last round | D      |
| 1 < t < r       | All cooperated last round      | D      |
| t = r           | End game                       | D      |

---

### 5. Explanation & Rationale

- **Always defect** except no conditional cooperation or forgiveness.
- **Aggressive exploitation**: seek maximum extraction every round.
- **No cooperation**: Unlike tit-for-tat or conditional cooperation, this strategy never cooperates, so it never sacrifices payoff for sustainability or social welfare.
- **Punishment and retaliation do not matter** because we never cooperate; defecting is baseline.
- **No uncertainty handling needed** due to deterministic rules.
- **Stock depletion accepted** as part of strategy cost.

---

This strategy is strategically aggressive: it aggressively extracts resources every round, exploits cooperators, punishes defectors (trivially, by defecting always), and seeks to maximize total payoff without regard for sustainability or mutual cooperation. It is robust in a tournament of mixed strategies by being consistently and predictably aggressive.
'''

description_AGGRESSIVE_46 = '''
Here is an aggressive strategy designed for the Common Pool Resource Game, aligning with your specification and maximizing individual payoff by exploiting cooperators and maximizing short-term extraction. This strategy assumes no trust or cooperation norms and aims to maximize individual gain even at the expense of resource depletion.

---

### Aggressive Strategy Description: "Defect-Exploit Until Last Round"

#### Intuition:
- Extract maximum payoff whenever possible by defecting,
- Exploit cooperators by defecting in early rounds,
- Avoid cooperating except where it yields strictly better payoff (very limited),
- Deplete resource quickly if opponents are naive,
- Defect in the last round for maximum payoff without regard for the stock (no future rounds to preserve stock),
- Optionally cooperate only if the stock is critically low and defecting yields zero payoff.

---

### Decision Rules:

#### Round 1 (Initial round)
- **Always defect:** No prior information, so start aggressively by defecting to gain a high initial payoff.

#### Intermediate Rounds (2 to r-1)
- Observe actions of others in the previous round:
  - If at least one other player cooperated in the previous round, **defect** to exploit cooperators.
  - If all players defected last round, **defect** to avoid being exploited and attempt to maximize payoff before resource collapse.

- Exception — critical low stock:
  - If current stock \( S \) is so low that defecting yields zero payoff (i.e., \( S = 0 \) or effectively zero), **cooperate** to receive a nonzero payoff if possible (since \( S/(2n) \geq 0 \)).
  - Else always defect regardless of the stock level.

#### Final Round (round \( r \))
- **Always defect:** No incentive to conserve stock for future rounds, maximize immediate payoff.

---

### Edge Case Handling:

- **If stock is zero at any point:** No action yields payoff > 0, strategy cooperates because defect yields 0 and cooperate may also be 0, but cooperate minimizes overexploitation label, though payoff same.
  
- **If stock is extremely low but not zero:** Defecting gives \( S/n \), cooperating gives \( S/(2n) \). If any payoff > 0, defect for maximum gain.
  
- **If there is no information about others (e.g., no prior rounds):** Defensive default — defect.

---

### Pseudocode

```python
def aggressive_strategy(round_number, total_rounds, current_stock, history_actions, n, capacity):
    # Inputs:
    # round_number: current round (1-based)
    # total_rounds: total rounds in game (r)
    # current_stock: current stock before actions are chosen
    # history_actions: list of lists, each sublist: actions of n players in previous rounds
    # n: number of players
    # capacity: max stock (not used in decisions, but known)

    # Constants representing actions
    C = 'C'
    D = 'D'

    # First round: no history, always defect
    if round_number == 1:
        return D

    # Last round: always defect
    if round_number == total_rounds:
        return D

    # Intermediate rounds: inspect last round actions
    last_round_actions = history_actions[-1]  # List of size n

    # Check if at least one cooperator last round
    cooperator_present = any(a == C for a in last_round_actions if a != 'self')

    # If stock is zero or effectively zero
    if current_stock <= 0:
        # Cooperate if defect yields 0 payoff, to avoid zero-sum misery, else defect
        # Here both yield zero, so cooperate slightly more tolerant
        return C

    # If at least one cooperator last round -> defect to exploit
    if cooperator_present:
        return D

    # If all defected last round -> defect to maximize payoff before collapse
    if not cooperator_present:
        return D
```

---

### Explanation:

- **Always defect initially and at the end** to maximize payoff.
- **Exploit cooperators whenever present** because defect gets double payoff this round.
- **Never cooperate to preserve stock or punish defectors**, because the aggressive mindset values short-term individual gain.
- **Only cooperate when stock is worthless** to avoid pointless zero payoffs.
  
This aligns perfectly with an aggressive, exploitative strategy that maximizes own payoff by defecting and never sacrificing payoff to conserve the pool or reward cooperators.

---

If you want, I can assist with a more nuanced variant balancing aggression with minimal cooperation, but this is the clearest purely aggressive approach.
'''

description_AGGRESSIVE_47 = '''
Here is a description of an **Aggressive Defector strategy** tailored for this Common Pool Resource Game. The goal of the strategy is to maximize the player's total payoff by exploiting the common pool as aggressively as possible. It assumes no cooperative social contract and prioritizes short- to mid-term gains.

---

## Strategy Name: Always Defect Until Last Round Defect/Cooperate Mix

### Core Idea
- Always play Defect (D) every round to maximize individual payoff per round.
- Use the last round as a "final harvest" opportunity to defect again if stock remains or occasionally to cooperate if it strategically improves payoff under extreme depletion.
- This strategy leverages aggressive resource consumption early on, taking advantage of higher stocks for maximum payoff.
- No attempt to foster cooperation or sustain the resource (since opponents are unknown and may defect).

---

## Decision Rules

### Round 1 to r-1 (All but last round)
- **Action:** Defect (D)
- **Reasoning:** Defecting yields a payoff of S/n which is twice as large as cooperating S/(2n). Without coordination, cooperating risks lower payoffs while others might defect and gain more. Aggression means maximizing immediate payoff.

### Round r (Last round)
- After observing stock at the start of round r, apply:
  - If current stock S > threshold (e.g., capacity * 0.2), **Defect (D)** to extract maximum payoff.
  - Else if stock is very low (e.g., S ≤ capacity * 0.2), **Cooperate (C)** to reduce total consumption and extract some payoff without causing total depletion (exploit last growth if any).
  
This rule in the last round is a minor concession to avoid zero payoffs if the stock is nearly depleted — cooperating might extract some payoff when defecting yields nothing due to zero stock or complete exhaustion.

---

## Edge Cases Handling

- **First Round:** Always Defect. The stock is at full capacity initially (S = capacity). Taking the large payoff ensures aggressive early gains.
  
- **Last Round:** Mixed action based on stock level as above to avoid zero payoff if the resource is nearly exhausted.

- **Situations where stock = 0 at start of a round:** Defect anyway (though no payoff available), because the strategy has no incentive to cooperate if the resource is gone.

- **Intermediate rounds with observation of stock going rapidly to zero:** Continue defecting to maintain aggressive posture, hoping for at least some payoff if others cooperate or the resource grows slightly.

---

## Pseudocode

```python
def aggressive_strategy(round_number, total_rounds, current_stock, capacity, n):
    """
    Inputs:
        round_number: current round (1-based)
        total_rounds: total rounds in game r
        current_stock: current common pool stock S at start of round
        capacity: max capacity
        n: number of players

    Output:
        action: 'C' or 'D'
    """

    # Threshold to switch last round action when stock is low
    stock_threshold = 0.2 * capacity

    if round_number < total_rounds:
        # Always defect in all rounds before last
        return 'D'

    else:
        # Last round behavior
        if current_stock > stock_threshold:
            return 'D'  # Maximum extraction possible
        else:
            # If stock is too low, cooperate to extract some payoff without full depletion
            return 'C'
```

---

## Summary

- **Aggressive goal:** Prioritize immediate maximum payoff every round.
- **Balanced final round:** Cooperate only if stock is so low defecting yields nothing, to gain at least partial payoff.
- **No forgiveness or cooperation attempts:** This strategy is purely self-interested and exploitative.
- **Simplicity:** No need to track others' history or try to induce cooperation.
- **Maximize extraction before resource shrinks.**

This aggressive approach risks driving the resource to depletion quickly, but maximizes the score if opponents do not sufficiently cooperate. It aligns with a "defect first, defect always" mindset with a minor last-round tweak to salvage payoff if possible.
'''

description_AGGRESSIVE_48 = '''
Here is a detailed **aggressive strategy** for the described Common Pool Resource Game.

---

### Strategic Objective:

- **Maximize immediate individual payoffs by defecting whenever beneficial.**
- **Exploit cooperative players by defecting against them to gain higher payoffs.**
- **Ignore long-term stock sustainability except to avoid zero-stock scenarios that eliminate all payoffs.**
- **Leverage knowledge of game horizon (number of rounds) to defect especially at endgame.**

---

### Strategy Description:

#### Key observations shaping the aggressive mindset:

- Defecting yields double the immediate payoff of cooperating in any single round because:
  - Cooperate payoff: S / (2n)
  - Defect payoff: S / n = 2 × (cooperate payoff)
- Stock dynamics imply that if total consumption is too high, stock collapses to zero, making future payoffs zero.
- Aggressive play tolerates causing low stock and expects to extract as much as possible before depletion.
- Opponents may cooperate or defect; defectors heavily reduce stock; cooperators marginally reduce it.
- Endgame considerations: no incentive to cooperate in last round since no future repercussions.

---

### Decision rules:

#### Round-specific logic:

1. **Round 1 (first round):**
   - Defect to maximize immediate payoff.
   - At game start, stock = capacity, so defecting yields maximum payoff.
   
2. **Rounds 2 to r-1 (middle rounds):**
   - **If previous round stock after growth is near zero or very low (threshold T_low), cooperate to avoid stock extinction.**
   - Else, **defect** to maximize current-round payoff.
   - "Near zero" can be defined as stock ≤ stock_sustain_threshold, where the threshold is set to ensure there is some stock for future payoffs (e.g. T_low = capacity / (4n) or based on observed dynamics).
   
3. **Round r (last round):**
   - Always **defect** to maximize final round payoff (no future rounds to punish).
   
---

#### Observations of others’ actions:

- Since the game is simultaneous-move, you cannot condition round t action on round t others’ actions.
- Use history of past rounds to estimate opponents' tendencies:
  - If large number opponents defected last round causing stock to be low, switch to cooperate to "extend" the game just enough to earn some payoff.
  - Otherwise, stay defecting aggressively.
- Aggressive mindset prefers defection, but pragmatically cooperates if collapse is imminent.

---

### Edge cases:

- **If stock = 0 at start of a round:** Game effectively ended, no payoffs, choose arbitrary action (e.g. cooperate).
- **If stock very low but not zero:** cooperate to allow stock to regrow slightly.
- **If stock after previous round is at capacity (high):** defect again to extract maximal payoff.
- **If more than half opponents defect consistently:** aggressive defection is justified because cooperating unilaterally wastes potential payoff.
  
---

### Pseudocode:

```python
function aggressive_strategy(round t, total_rounds r, current_stock S, capacity, n, history):
    # Parameters
    T_low = capacity / (4 * n)   # Threshold to avoid stock collapse
    
    # Last round: defect always
    if t == r:
        return 'D'
    
    # If stock is zero or extremely low, cooperate to allow regrowth
    if S <= 0 or S <= T_low:
        return 'C'
    
    # After Round 1: Check history to assess opponents' aggressiveness
    if t == 1:
        # First round defect to maximize immediate payoff
        return 'D'
    else:
        # Calculate proportion of defectors last round
        last_round_actions = history[t-1]  # actions played by all players in previous round
        num_defectors = count(last_round_actions == 'D')
        
        if num_defectors > n / 2:
            # Many defectors - stick to defect for higher payoff
            return 'D'
        
        # Stock safe and opponents mostly cooperative: defect aggressively
        return 'D'
```

---

### Summary:

- **Default: Defect every round except when stock is critically low.**
- **In critically low stock situations, cooperate briefly to avoid total collapse, extending the game just enough to squeeze some payoffs.**
- **Always defect in the last round to maximize endgame payoff.**
- **Use the history of opponent actions to detect aggression and respond aggressively.**

---

This strategy embodies a straightforward and clear **aggressive approach** aiming to maximize immediate payoffs while pragmatically avoiding self-destructive exhaustion of the common resource stock.
'''

description_AGGRESSIVE_49 = '''
Below is a detailed **aggressive strategy** proposal for the Common Pool Resource Game. It aims to maximize individual payoffs aggressively, prioritizing short-term gains even at the risk of long-term depletion.

---

## Aggressive Strategy Description: "Defect-then-Exploit"

### Core idea
- **Maximize immediate return by defecting as much as possible** (consume a large share).
- **Punish cooperators only if beneficial to self**, but otherwise ignore cooperation incentives.
- **Exploit the last-round defecting advantage** without concern for resource sustainability.

---

## Decision Rules

### Initialization (Round 1)
- **Always defect (D).**
  - Rationale: No past history to condition on, thus start aggressively by taking the maximum share (S / n).

### Intermediate Rounds (2 ≤ t < r)
- **If common pool stock S is high (≥ capacity / 2), always defect (D).**
  - Aggressive mindset: Take as much as possible while the pool is abundant.
- **If stock has dropped below capacity/2 but above a critical threshold, defect but monitor others' behavior:**
  - Check how many other players defected in previous round.
    - If > 50% defected, continue defecting.
    - Else if cooperation is detected from majority, **still defect** to exploit them.
  - No incentive to cooperate; defect regardless.
- **If stock is low (≤ n * (S / n) = S; i.e., the total consumption by all players defecting would deplete entire stock this round):**
  - Defect anyway, as it is last chance to get high payoff.
  
### Final Round (t = r)
- **Always defect (D).**
  - No future rounds; maximize immediate payoff regardless of resource depletion.

---

## Handling Edge Cases

- **First round**: No information; always defect.
- **Last round**: Defect regardless to get maximum payoff in final opportunity.
- **Resource near depletion (stock near zero)**:
  - Defect anyway to attempt extracting whatever remains.
  - No concern for sustainability.
- **Opponents cooperate en masse (rare with multiple players)**:
  - Exploit by defecting to gain even more relative payoff.
- **If all defect continuously and stock falls to zero**:
  - In subsequent rounds, defecting yields no payoff; no incentive to cooperate—still defect (no better alternative).

---

## Pseudocode

```pseudo
function aggressive_strategy(round t, total_rounds r, stock S, capacity, history_actions):
    # Parameters
    threshold_high = capacity / 2
    
    if t == 1:
        return 'D'  # Always defect in first round
    
    if t == r:
        return 'D'  # Always defect in last round
    
    # Count how many defected in previous round (if any)
    previous_round_defectors = count_defectors(history_actions[t-1])
    total_players = length(history_actions[t-1])
    
    # Aggressive threshold checks
    if S >= threshold_high:
        return 'D'  # Pool abundant: defect
    else:
        # Pool less abundant
        if previous_round_defectors / total_players > 0.5:
            return 'D'  # Majority defect, defect as well
        else:
            # Some cooperation detected, but still defect aggressively
            return 'D'
```

---

## Summary

- **Always defect** from start to finish.
- **Ignore any incentives to cooperate.**
- **Exploit others’ cooperation whenever present.**
- **Disregard sustainability concerns due to aggressive mindset.**
- **Maximize return every round by choosing D whenever possible.**

---

This strategy aligns with an aggressive, exploitative mindset prioritizing short-term maximization of payoffs at the expense of the common stock. It will compete effectively against cooperative or conditional strategies by leveraging maximum consumption every round.
'''

description_AGGRESSIVE_50 = '''
Below is a detailed description of an **aggressive strategy** for the Common Pool Resource Game, designed to maximize individual short-term payoffs by defecting when beneficial, while minimizing cooperation—yet with some foresight to avoid total resource collapse prematurely (since zero stock yields zero payoff).

---

## Strategy Overview: "Relentless Defector with Last-Round Exploitation"

**Core idea:**  
Defect in almost every round to maximize individual payoff (consume stock/n). Only cooperate *if and only if* the stock is critically low to prevent zero stock (which yields zero payoff for everyone). In the very last round, defect regardless of stock—maximizing immediate payoff with no future consequence.

---

## Decision Rules

We denote at round t:  
- S_t = current stock before players act  
- r = total rounds  
- n = number of players

### 1. First Round (t = 1)

- Defect unconditionally.  
Rationale: No prior data, opponent tendencies unknown, starting high stock means defecting maximizes immediate payoff.

### 2. Intermediate Rounds (1 < t < r)

- **Threshold calculation for critical stock:**  
  Calculate minimal stock level S_critical below which cooperating will help sustain stock and prevent collapse.  
  Because defect consumes stock/n per player, total max consumption if all defect: S_t (all stock consumed). Cooperating reduces consumption per cooperator, which slows depletion.

- **Decision rule:**  
  - If current stock S_t is **greater than or equal to** `threshold = n * (S_t / n) = S_t` (trivially true, so we define a minimal stock threshold biblically):  
    More meaningfully, set a fixed *low stock threshold* based on capacity and number of players. For instance, if stock after consumption is likely to fall below capacity/(2n), **cooperate** to preserve resource.  
  - In practice, simplified to:  
    - **If** stock S_t is above `capacity / (2*n)` (i.e., not critically low), **defect**.  
    - **Else** cooperate to slightly preserve stock and avoid full collapse.

*Rationale:* The stock dynamics formula favors stock levels around half capacity (by logistic growth), so once stock is very low, it grows slowly. When stock is so low that defecting will likely crash it to zero, the strategy cooperates to keep extracting positive payoffs in future rounds.

**Note:** This threshold can be tuned but reflects aggressive mindset: cooperate only when selfishly necessary.

### 3. Last Round (t = r)

- Defect unconditionally to maximize immediate payoff since no future rounds exist.

---

## Pseudocode

```
function decideAction(round t, currentStock S_t, totalRounds r, capacity, n):
    if t == r:
        return 'D'  // last round, defect unconditionally
    
    low_stock_threshold = capacity / (2 * n)
    
    if S_t < low_stock_threshold:
        return 'C'  // cooperate only if stock critically low
    
    return 'D'  // otherwise, defect aggressively
```

---

## Additional Notes

- The strategy never attempts cooperation as a reciprocal or retaliatory move; it is strictly driven by immediate payoff maximization tempered by minimal preservation efforts to avoid zero stock (thus zero payoff).
- Observes others’ past actions only implicitly via stock level; no direct punishment or forgiveness.
- No probabilistic mixing: strictly deterministic, aggressive exploitation approach.
- The choice of `capacity / (2*n)` as threshold ensures the strategy defects as much as possible while avoiding instant resource collapse, leaving some room for stock regrowth.
- In larger populations (large n), threshold is lower, enabling more aggressive defecting; in smaller groups, slightly more cooperation may occur if stock dips.

---

# Summary

This aggressive strategy relentlessly defects except when the common pool stock is dangerously low, in which case it temporarily cooperates just enough to prevent complete ruin of the resource and sustain future payoffs—except on the final round when it defects regardless to maximize payoff without concern for future repercussions. This reflects an "exploit first, conserve only when forced" aggressive stance.
'''

description_AGGRESSIVE_51 = '''
**Aggressive Strategy for the Common Pool Resource Game**

---

### Strategy Philosophy:
Be as exploitative and selfish as possible to maximize own payoff every round, prioritizing defecting to harvest maximum individual share. Do not cooperate except in very narrow circumstances to avoid mutual destruction, but otherwise maintain aggressive defections to out-earn opponents. Use any information from past rounds to anticipate stock depletion and act accordingly, focusing on last-round harvesting if needed.

---

### Key Points:
- **Defect (D) unless stock is critically low or last round approach**  
- In early/middle rounds, always defect to maximize immediate payoff  
- If stock is dangerously low and remaining rounds exist, cooperate briefly to allow stock recovery (to enable future payoffs)  
- On the last round, always defect to maximize final extraction regardless of sustainability  
- Observe the stock level and adjust near-zero stock cases to cooperate once to avoid zero payoff in the following round if more rounds remain  

---

### Notation and Parameters:

- `n` = number of players  
- `r` = total rounds  
- `capacity` = maximum sustainable stock  
- `t` = current round (1-indexed)  
- `S_t` = stock *at start* of round t (known before choosing actions)  
- Actions ∈ {C, D}  

---

### Decision Rules (Pseudocode):

```python
def aggressive_strategy(t, r, n, capacity, S_t):
    # Thresholds (tunable)
    low_stock_threshold = capacity / (4 * n)  # When stock is very low, be more cautious
    
    # 1. Last round (t == r): Always defect to maximize final payout
    if t == r:
        return 'D'
    
    # 2. Stock is critically low (less than low_stock_threshold)
    # To avoid total depletion that yields zero payoffs in subsequent rounds,
    # cooperate once to let stock grow again if not last round
    if S_t < low_stock_threshold:
        # If this is second to last round, defect anyway to maximize payout now, no future payoff to protect
        if t == r - 1:
            return 'D'
        else:
            # Cooperate once to enable stock recovery (highly opportunistic)
            return 'C'
    
    # 3. Otherwise (stock is adequate), always defect aggressively
    return 'D'
```

---

### Explanation:

1. **First Round (t=1):**  
   Stock is at capacity (≥ 2n), so well above low_stock_threshold. Defect immediately to get maximum payoff (S/n). Aggressive exploitation from the start.

2. **Intermediate Rounds:**  
   - If stock remains healthy, continue defecting to exploit the pool aggressively.  
   - If stock drops below threshold (e.g., less than capacity divided by 4n), defecting would risk zero or near-zero stock payoff in future rounds.  
   - To avoid losing all future gains, cooperate **once** to allow stock to grow again via natural growth function.  
   - This is a tactical concession, but still aggressive since it only triggers under immediate threat of ruin and only once per critical low stock period.

3. **Last Round (t = r):**  
   Defect no matter what—aggressive final harvest maximization. No incentive to preserve stock after game ends.

---

### Variations / Robustness Considerations:

- The low_stock_threshold can be tuned depending on capacity and rounds to optimize aggressive gains  
- The strategy does not rely on opponents cooperating and assumes no coordination  
- Patterns of occasional cooperation when stock is critically low can incentivize survival of the pool, ensuring future payoffs rather than a race-to-zero  
- Because all players know the rules and sees the history, this strategy anticipates opponents will defect more often, so it exploits them aggressively

---

### Summary:

| Round                  | Condition                     | Action  |
|------------------------|-------------------------------|---------|
| 1 ... r-2              | Stock ≥ low_stock_threshold   | Defect (D) |
| 1 ... r-2              | Stock < low_stock_threshold   | Cooperate (C) once, else Defect |
| r (final round)        | Any                           | Defect (D) |

---

This aggressive strategy aims to grab maximum individual payoff by defecting whenever profitable, conceding cooperation only as necessary to prevent total collapse of the common pool — but never relinquishing final round advantage. It fully exploits the structure to maximize cumulative payoff in the repeated context.
'''

description_AGGRESSIVE_52 = '''
Below is a detailed description of an aggressive strategy for the Common Pool Resource Game, meeting the specification and informed only by the given parameters and constraints.

---

## Strategy Name: Aggressive Defector (AggDef)

### Goal
Maximize individual total payoff by consistently exploiting the common pool as much as possible, using defection to gain the highest immediate payoff and forcing rivals into a resource-depleted state, while still adapting minimally to avoid total loss.

---

## 1. Decision Rules

**Key principles:**

- Defect (`D`) whenever it yields the highest immediate payoff or if the stock level is sufficient to support aggressive depletion.
- Only cooperate (`C`) if defection would cause the resource to collapse to zero and thus yield zero payoff to everyone in the final round.
- Use information from the **current stock level (S)** and **round number (t)** to decide action.
- Never rely on cooperative norms, punishment, or forgiveness — act purely to maximize immediate and cumulative payoff from personal consumption under resource constraints.

---

### Detailed Logic

#### Round 1 (t = 1):

- **Always defect (`D`)**
  - Initial stock is at capacity (≥ 2n).
  - Defecting yields π = S/n, which is twice the payoff of cooperating (S/(2n)).
  - No reason to cooperate at the beginning; gain full defector payoff immediately.

#### Intermediate Rounds (1 < t < r):

- Observe current stock `S_t`.

- Calculate potential new stock assuming all players defect:
  - Total consumption if all defect: `n × (S_t / n) = S_t`
  - Stock after consumption = `S_t - S_t = 0`
  - Growth = 0 (since stock after consumption = 0)
  - New stock = 0

- If `S_t` is **too low** (e.g., ≤ threshold), full defection would immediately deplete stock to zero, ending all future payoffs at zero.

- Define a **critical stock threshold (S_min)** below which defecting leads to total collapse with no benefit next round. This can be computed as the smallest stock that allows defection without immediate collapse:
  
  From specification, when total consumption equals current stock, stock goes to zero. So to avoid zero next round stock, total consumption must be less than current stock.

  Since defection consumes `S_t / n` per player and total consumption = `n × (S_t / n) = S_t`, total consumption equals stock, causing collapse.

  This means if all defect, stock always collapses to zero next round.

- However, since we cannot guarantee others' actions, assume worst-case that others will defect.

- **Rule:** If stock `S_t` is **greater than negligible value (say a small epsilon >0)**, defect.

- But if defecting now will cause zero stock and zero payoff next round (and it is not the last round), consider cooperating **only to preserve stock** for maximizing next rounds when being the sole defector.

- To be aggressive while not killing the game early:

  - If not last round, and `S_t` is low such that defecting would leave no stock for next round:
    - Cooperate to preserve some stock (others defecting, you cooperate).

  - Otherwise, defect.

#### Last Round (t = r):

- **Always defect (`D`)**
  - No future rounds remain.
  - Maximize immediate payoff regardless of stock depletion.

---

## 2. Pseudocode

```python
# Parameters
n = number_of_players
r = total_rounds
capacity = max_stock

# Inputs per round
# t: current round (1-based)
# S: current stock before actions

def AggDef_strategy(t, S, r, n, capacity):
    # Last round: always defect
    if t == r:
        return 'D'

    # First round: always defect
    if t == 1:
        return 'D'

    # Calculate hypothetical stock if all defect next round (worst case)
    # If all defect:
    total_consumption_defect = S  # n * (S / n) = S
    S_after_consumption = S - total_consumption_defect  # 0
    growth = 2 * S_after_consumption * (1 - S_after_consumption / capacity)
    S_next = min(S_after_consumption + growth, capacity)  # 0

    # If defecting now causes total collapse next round (stock zero),
    # only cooperate if this is not the last round to preserve resource.
    # Otherwise defect.

    # Threshold to avoid stock collapse: 
    # Since total consumption defect = S, it always collapses if all defect,
    # but since we can't guarantee all defect, assume others defect,
    # so stock will collapse if we defect now.

    # Check if stock is already low (near collapse)
    epsilon = capacity * 0.01  # e.g., 1% of capacity

    if S <= epsilon:
        # Stock is nearly depleted, defecting won't yield payoff,
        # cooperate to preserve minimal stock for future rounds (hope others cooperate)
        return 'C'

    # Else, always defect to maximize immediate payoff
    return 'D'
```

---

## 3. Explanation and Rationale

- **Aggressiveness:** Always defect except in rare cases where defecting would cause the resource to collapse immediately while there are still future rounds to exploit.

- **Edge Cases:**
  - First round: maximum immediate gain via defection.
  - Last round: defect to maximize final payoff without caring about sustainability.
  - Near depletion: switch to cooperate just enough to avoid zero payoffs in immediate future rounds.

- **Assumptions on others:**
  - No trust, assume others defect to maximize own payoffs.
  - Do not rely on cooperation or signaling.

- **Outcome expectation:**
  - This strategy will dominate cooperators (who get less payoff per round).
  - May accelerate resource depletion but tries to preserve minimal stock for potential next-round exploitation.
  - In a tournament of mixed strategies, this maximizes own total payoff aggressively.

---

## Summary

| Round          | Condition                             | Action  |
|----------------|-------------------------------------|---------|
| 1              | Always                             | Defect  |
| Last (r)       | Always                             | Defect  |
| Intermediate   | Stock ≤ threshold (near depletion) | Cooperate (preserve stock) |
| Intermediate   | Stock > threshold                  | Defect  |

This strategy is simple, transparent, and clearly aggressive, maximizing individual gain from defecting except for minimal cooperation to avoid immediate total collapse when it benefits future personal payoffs.

---

If you want, I can also help you derive value estimates for the threshold or refine based on observed opponent behavior from history. But per your instructions, this standalone aggressive strategy should be robust in a tournament setting with unknown opponents.
'''

description_AGGRESSIVE_53 = '''
**Aggressive Strategy for the Common Pool Resource Game**

**Goal:**  
Maximize own cumulative payoff aggressively by prioritizing immediate exploitation of the resource, minimizing restraint, and pushing other players towards cooperation or defection, exploiting their attempts to cooperate if possible.

---

### 1. Key Insights and Rationale

- **Defecting (D)** yields higher immediate payoff (S/n) than cooperating (C) (S/(2n)).  
- Repeated defection risks quickly depleting the resource stock, resulting in no future payoffs.  
- But since the growth function is quadratic and the stock can recover if not fully depleted, there is an opportunity to sustain some stock while maximizing payoffs.  
- Other players may attempt to cooperate if defecting reduces the stock too fast or leads to zero payoffs.  
- Aggressive means pushing own immediate payoff, including causing stock depletion if necessary, to maximize payoff in the current or next rounds.  
- We must specify behaviors for initial round (no history), intermediate rounds (observing history), and final round (no future incentive except maximum immediate payoff).

---

### 2. Aggressive Strategy Description

**State Variables at Round t:**

- `S_t`: Current stock at start of round t
- History of all players’ actions and payoffs up to round t - 1

---

### 3. Decision Rules

**In a round t (1 ≤ t ≤ r):**

- **If it's the last round (t == r):**  
  *Always Defect (D)* to maximize immediate payoff by fully exploiting current stock (no future rounds remain to preserve stock).

- **Else (t < r):**

  - Calculate the *estimated average resource usage* last round:

    \[
    C_{avg} = \frac{1}{n} \sum_{i=1}^n \text{consumption}_i^{t-1}
    \]

    where consumption by player i is either \( S_{t-1}/(2n) \) if they cooperated, or \( S_{t-1}/n \) if they defected.

  - Estimate expected stock after last round consumption and growth (as actually observed).

  - **If stock is high (above a threshold):**  
    Defect (D), exploiting plentiful resources while tolerating some stock reduction.

  - **If stock is low (below a threshold):**  
    Cooperate (C), to allow some stock recovery and prevent full depletion, keeping stock sustainable enough for future payoffs.

  - The thresholds ensure a balance: aggressively defect when the stock is sufficient, but avoid pushing stock to zero prematurely except near the end of the game.

---

### 4. Thresholds and Parameters

- Define a **stock threshold parameter**: 

  \[
  \text{threshold} = \frac{\text{capacity}}{4}
  \]

  (Quarter of capacity)

- If \( S_t > \text{threshold} \), Defect; otherwise Cooperate.

---

### 5. Additional Considerations

- Observe actions of others in last round:

  - If a significant majority defected last round, indicating likely mutual over-exploitation, cooperate this round to avoid zero stock.

  - If most cooperated or mixed actions, continue defecting to exploit cooperators.

- This can be operationalized by:

  \[
  D_{count} = \text{# of players defecting last round}
  \]

  - If \( D_{count} ≥ n/2 \), cooperate if stock low.

---

### 6. Pseudocode

```python
def aggressive_strategy(t, r, n, capacity, S_t, history):
    """
    Inputs:
        t: current round number (1-based)
        r: total rounds
        n: number of players
        capacity: max sustainable stock
        S_t: current stock at start of round t
        history: list of dictionaries with keys:
            - 'actions': list of length n with 'C' or 'D' for previous round
            - 'stock_after': stock after last round
    Output:
        action: 'C' or 'D' for current round
    """

    threshold = capacity / 4

    # Last round - maximize immediate payoff
    if t == r:
        return 'D'

    # First round: no history, start defecting aggressively
    if t == 1:
        return 'D'

    # For rounds 2 to r-1:

    last_actions = history[-1]['actions']
    last_stock_after = history[-1]['stock_after']
    D_count = last_actions.count('D')

    # Estimate if stock is healthy (above threshold)
    if S_t > threshold:
        # Stock high - exploit aggressively
        return 'D'
    else:
        # Stock low, check if others aggressively defecting
        if D_count >= n/2:
            # Many defectors and low stock, cooperate to avoid extinction and gain future payoffs
            return 'C'
        else:
            # Few defectors, stock low but others may cooperate - exploit cooperators
            return 'D'
```

---

### 7. Summary

| Round         | Condition                        | Action |
|---------------|--------------------------------|---------|
| t = 1 (start) | No history                     | Defect  |
| t = r (last)  | Maximize immediate payoff      | Defect  |
| 1 < t < r     | Stock > capacity/4             | Defect  |
| 1 < t < r     | Stock ≤ capacity/4 and ≥ half players defected last round | Cooperate |
| 1 < t < r     | Stock ≤ capacity/4 and < half defected last round | Defect  |

---

### 8. Strategic Summary

- The strategy aims to exploit common pool resources aggressively, always prioritizing defection to maximize immediate payoffs, except when the stock is dangerously low and most players are defecting — then cooperate temporarily to avoid resource collapse, preserving some payoff potential in future rounds.

- This approach balances raw greed with minimal sustainability to avoid complete wipeout except in the final round, where greed dominates.

- The simple threshold and majority checks enable aggressive but adaptive behavior without coordination.

---

If you want, I can also help prepare variations or sensitivity tests on threshold or behaviors.
'''

description_AGGRESSIVE_54 = '''
**Aggressive Strategy Design for the Common Pool Resource Game**

---

### Strategy Overview

This aggressive strategy aims to maximize individual payoffs by defecting (D) as often as possible to secure higher immediate consumption while still maintaining the resource stock **just enough** to continue exploiting it over multiple rounds. It uses information on previous rounds’ stock levels and outcomes to decide when to defect or cooperate, primarily defecting but cooperating occasionally to keep the stock from collapsing prematurely.

---

### Key Principles

1. **Aggressiveness:** Defect whenever the resource stock allows high payoffs.
2. **Sustainability buffer:** Cooperate only if the stock level is critically low, to avoid collapse.
3. **Endgame exploitation:** Defect with full intensity in the last round, no concessions.
4. **History awareness:** Use observed actions and stock to infer if total defect is rapidly depleting stock.
   
---

### Decision Rules

Let:

- t = current round (1 to r)
- S_t = stock at start of round t
- capacity = resource capacity
- n = number of players

---

#### 1. First round (t=1)

- No past history available.
- Defect to maximize immediate payoff.

```pseudocode
if t == 1:
    action = D
```

---

#### 2. Intermediate rounds (1 < t < r)

- If stock is **high enough** to survive another aggressive round, defect.
- Define a stock threshold `S_threshold` = (capacity / 4), i.e., 25% of capacity.
  
- If stock >= S_threshold:
  - Defect to maximize payoff.
- Else (stock < S_threshold):
  - Cooperate to slow depletion slightly, hoping to regain stock via growth.
  
```pseudocode
if 1 < t < r:
    if S_t >= capacity / 4:
        action = D
    else:
        action = C
```

---

#### 3. Last round (t = r)

- No incentive to preserve the resource beyond the game.
- Defect to maximize last round payoff, regardless of stock.
  
```pseudocode
if t == r:
    action = D
```

---

#### 4. Optional Refinement: React to Past Exploitation

(Use if implementation wants to incorporate opponent behavior inference.)

- If total consumption last round > capacity (i.e., resource collapsed or nearing collapse), switch to cooperate to allow some recovery.
- Otherwise, continue defecting if stock permits.

This is optional and increases complexity, but since opponents are independent and uncoordinated, the above safe threshold logic is sufficient.

---

### Summary Table: Action Choice by Round & Stock

| Round | Stock Condition                 | Action    |
|-------|--------------------------------|-----------|
| 1     | N/A                            | Defect    |
| 2..r-1| Stock ≥ capacity / 4 (High)    | Defect    |
| 2..r-1| Stock < capacity / 4 (Low)     | Cooperate |
| r     | N/A                            | Defect    |

---

### Rationale

- **Why defect first round?** You maximize early extraction and set an aggressive tone.
- **Why cooperate when stock is very low?** To avoid premature collapse that stops payoffs for everyone, including yourself.
- **Why defect last round?** No future rounds remain, so no incentive to preserve stock.
- **Why 25% capacity threshold?** It's a heuristic balancing aggressive consumption and avoiding imminent collapse, reflecting the growth function's maximum sustainability range.

---

### Pseudocode Summary

```pseudocode
function AggressiveStrategy(t, r, S_t, capacity, n):

    S_threshold = capacity / 4

    if t == 1:
        return D

    else if t == r:
        return D

    else:
        if S_t >= S_threshold:
            return D
        else:
            return C
```

---

### Additional Notes

- This strategy is purely **greedy with minimal conservation** to keep the resource exploitable.
- It does not rely on cooperation or punishment since opponents are independent and uncoordinated.
- It exploits the knowledge of stock dynamics to time cooperation for sustainability when necessary, otherwise defects to maximize personal payoff.
- Aggressive in the sense of defecting as much as possible, with only minimal restraint to prevent self-defeating collapse.

---

If you want, I can also help you develop variations that incorporate defection retaliation or more refined resource stock predictions.
'''

description_AGGRESSIVE_55 = '''
Below is a detailed description and rationale for an **aggressive strategy** in the specified Common Pool Resource (CPR) game, including decision rules, handling of edge cases, and alignment with an aggressive mindset.

---

## Strategy Name: "Dominant Defector with Opportunistic Retaliation"

### Intuition and Rationale

- **Aggressive mindset:** Maximize immediate individual payoffs by defecting whenever it benefits the player.
- **No trust or cooperation assumption:** Opponents are assumed likely to defect (or at least you do not rely on cooperation).
- **Retaliation:** Punish cooperative opponents by continuing to defect unless severe depletion occurs.
- **Edge sensitivity:** Avoid stock collapse early so you can exploit remaining rounds.
- **Last round:** No incentive to cooperate since the game ends.

---

### Key Ideas

- **Defect by default:** Defecting guarantees the highest immediate payoff (S/n > S/(2n)).
- **In last round, always defect:** No future retaliation possible.
- **If stock drastically depleted (below threshold), switch to cooperation to allow stock recovery, then revert to defecting:** This balances short-term aggression and avoiding a zero stock scenario (which yields zero payoffs).
- **Otherwise, defect relentlessly.**
- **Track stock level each round and update action accordingly.**

---

### Parameters for internal use:

- `threshold_low = capacity / (4 * n)` (Example: for capacity=100, n=4, threshold_low = 100 /16 = 6.25)
  
  This threshold indicates a severe depletion risk (stock very low compared to player count).

---

### Formal Decision Rules

Let:
- `t`: current round (1-based, 1 ≤ t ≤ r)
- `S_t`: current common pool stock at start of round `t`
- `r`: total number of rounds
- `capacity`, `n`: game parameters

**At round t:**

1. **If t == r (last round):**  
   `Action := Defect`  
   Rationale: No future rounds to preserve stock or punish.

2. **Else if S_t ≤ threshold_low:**  
   `Action := Cooperate`  
   Rationale: Stock too low — temporarily cooperate to help stock recover.  

3. **Else:**  
   `Action := Defect`  
   Rationale: Aggressively maximize immediate payoff.

---

### Pseudocode

```python
def aggressive_strategy(t, r, S_t, capacity, n):
    threshold_low = capacity / (4 * n)

    if t == r:
        # Last round: defect to maximize final payoff
        return 'D'

    if S_t <= threshold_low:
        # Pool severely depleted: cooperate to allow growth
        return 'C'

    # Otherwise, defect aggressively
    return 'D'
```

---

### Additional Notes

- **Why cooperate when stock is very low?**  
  Aggressive defection every round could cause pool collapse, resulting in zero future payoffs. The occasional cooperation at severe depletion prevents irreversible collapse, enabling further exploitation.

- **Why last round defect always?**  
  No future rounds mean no incentive to preserve stock or maintain goodwill.

- **Why no complex opponent modeling?**  
  The aggressive mindset prioritizes individual gain and does not rely on reciprocity or trust under uncertainty.

---

### Summary

| Round Condition                           | Action    | Reason                                         |
|-----------------------------------------|-----------|------------------------------------------------|
| Last round (t == r)                      | Defect (D) | Maximize immediate payoff, no future repercussions |
| Stock critically low (S_t ≤ threshold)  | Cooperate (C) | Support pool recovery to sustain future payoff potential |
| Otherwise                               | Defect (D) | Aggressively maximize payoff                     |

---

This strategy provides a simple, clear, and effective aggressive approach, balancing maximum short-term extraction with minimal strategic recovery to avoid stock collapse before the game ends. It should do well against timid and cooperative opponents and be resilient against other defectors.
'''

description_AGGRESSIVE_56 = '''
Here is a detailed aggressive strategy designed for the Common Pool Resource Game as specified. The strategy is self-contained and uses only the publicly observable information (past actions and stocks). It explicitly chooses when to defect or cooperate, handles edge cases like the first and last rounds, and consistently behaves aggressively.

---

## Aggressive Strategy Description

### Core Idea:
- **Exploit the common pool fully whenever possible by defecting** (D) to maximize immediate payoff.
- **Defect until the stock is critically low**, then temporarily cooperate to allow minimal stock recovery, ensuring future rounds can still yield some payoff.
- **In the last round, defect unconditionally to extract as much as possible since no future rounds remain.**
- **Use past observed actions of others to detect if others try to restrain consumption; ignore such attempts and remain aggressive.**

### Intuition:
- Defecting gains more payoff per round (S/n > S/(2n))
- However, if all defect always, the resource collapses quickly, potentially zeroing future payoffs.
- The strategy sacrifices short-term moderation for mostly maximal immediate gains but monitors the stock to avoid complete collapse.
- When the stock dips below a critical threshold, cooperate briefly to let the stock partially recover and extend game length, then resume defection.
- Ends with full defection, extracting any remaining resource.

---

## Parameters and Variables Used in Strategy

- **n** = number of players
- **r** = total rounds
- **capacity** = maximum sustainable stock
- **S_t** = current stock at round t (observable at start of round)
- **t** = current round number (1 ≤ t ≤ r)
- **threshold_stock** = critical stock level below which cooperation is triggered to allow recovery  
  Set as a fraction of capacity, e.g. threshold_stock = capacity / 4 (25% capacity)

---

## Decision Rules (per round t):

1. **If t == r (last round):**  
   → Defect (D) unconditionally to maximize last round payoff.

2. **Else if current stock S_t > threshold_stock:**  
   → Defect (D) to maximize immediate payoff.

3. **Else if current stock S_t ≤ threshold_stock:**  
   → Cooperate (C) this round to allow stock regrowth.

4. Additional rule: After cooperating once due to low stock, **resume defecting next rounds unless stock falls below threshold again**. (This means alternating between defecting and cooperating in collapse phases.)

---

## Pseudocode

```python
def aggressive_strategy(t, r, n, capacity, S_t):
    threshold_stock = capacity / 4  # 25% of capacity

    # Last round: always defect
    if t == r:
        return 'D'

    # Stock above threshold: defect aggressively
    if S_t > threshold_stock:
        return 'D'

    # Stock low: cooperate to allow recovery
    else:
        return 'C'
```

---

## Explanation of Edge Cases

- **First Round (t=1):** Stock = capacity (max), so S_t > threshold_stock ⇒ defect.  
  Aggressive move to capture high payoff immediately.

- **Stock Collapse Scenario:** If persistent defection drives stock ≤ threshold_stock, the strategy cooperates to gain some regrowth for future payoffs. But it does not "forgive" or trust others; cooperation is solely stock-driven, not reacting to opponents' behaviors.

- **Last Round (t=r):** Defects no matter what, extracting all remaining value even if it collapses the resource.

- **Handling Partial Collapse:** The strategy cooperates only when stock is low. If stock recovers beyond threshold (due to growth), resumes defecting next round.

---

## Why is this Strategy Aggressive?

- It maximizes immediate payoff by defecting as often as possible.
- It does not try to sustain cooperation with opponents.
- It only minimally restrains defection to avoid absolute collapse that yields zero payoffs.
- It exploits the growth function by timing small periods of cooperation as necessary, but never reciprocates cooperation nor punishes defection.
- It ends with full defection to claim last round resources aggressively.

---

## Optional Enhancements (if allowed)

- Track opponents’ past cooperations but always defect regardless to maintain aggression.
- Dynamically adjust threshold_stock lower for more aggressiveness (accept greater risk of collapse).
- Consider "immediate stock drop" history to decide cooperation intervals but basic stock-threshold rule suffices.

---

# Summary

- **Always defect when stock above 25% of capacity or in last round.**
- **Cooperate only when stock ≤ 25% capacity to recover stock and extend game life.**
- **Sole motivation is to maximize individual payoff, with minimal concession to stock sustainability.**

This aggressive strategy exploits common pool to the fullest while ensuring some survival of the resource for continued exploitation. It clearly aligns with an aggressive mindset in a repeated common pool resource setting.
'''

description_AGGRESSIVE_57 = '''
Here is a detailed **aggressive strategy** for the Common Pool Resource Game based on the specifications and constraints:

---

## Strategy Overview

This aggressive strategy aims to maximize short-term individual payoffs by primarily defecting (consuming a large share), leveraging opponents’ cooperation whenever possible, and using minimal cooperation only to avoid completely destroying the stock early to preserve some future payoff opportunities.

The strategy **prioritizes immediate gains** over long-term sustainability but adopts a minimal measure of restraint to partially preserve the resource until late stages when defection intensifies.

---

## Intuition behind the strategy

- **Defection** yields double the payoff as cooperation in the current round given the current stock value.
- However, always defecting risks driving the stock to zero early, cutting off all future payoffs.
- The strategy strikes a balance: early rounds exploit defective payoffs; mid-game begins to threaten stock depletion; late rounds defect fully to maximize last round gains.
- No assumption of opponents' cooperation — treat them as potentially cooperative or defective.
- The strategy treats the stock level as a signal of when to ease off and when to go full throttle.

---

## Decision Rules

```pseudocode
Inputs:
- t: current round index (1-based)
- r: total rounds
- n: number of players
- capacity: maximum sustainable stock
- S_t: current stock at start of round t
- history: observed actions of all players in all previous rounds (can be used if desired)

Constants:
- C_action = Cooperate (consume S_t/(2n))
- D_action = Defect (consume S_t/n)

Algorithm:

1. If t == 1 (first round):
    # No history yet, maximize immediate payoff with defection.
    Play D_action

2. Else if t < r (all rounds except the last):
    # Determine stock thresholds to decide defect/cooperate

    # Calculate expected total consumption if all defect:
    total_defect_consumption = S_t   # since each player consumes S_t/n, n players total S_t

    # Estimate if defecting now will drive stock nearly to zero:
    # If defecting risks total consumption >= stock, stock will collapse, no future payoffs.

    # Set a safety threshold to preserve stock (e.g., keep stock above n * (S_t / (2n)) per player for next round)

    stock_safety_threshold = capacity * 0.25  # at least 25% capacity preserved to ensure some growth

    if S_t > stock_safety_threshold:
        # Stock is healthy, defect aggressively
        Play D_action
    else:
        # Stock low, cooperate to slow depletion, maximize cumulative payoff
        Play C_action

3. Else if t == r (last round):
    # Last round: no future to preserve, maximize immediate payoff
    Play D_action
```

---

## Explanation of Logic

- **First Round: Defect**
  - No past info, favorite immediate gain.
- **Intermediate Rounds: Conditional Defect/Cooperate**
  - If stock high: defect to get double payoff.
  - If stock low: cooperate to avoid crashing stock to zero too soon; this yields some nonzero payoff next round.
- **Last Round: Defect**
  - Maximize last payoff, no future rounds to consider.

---

## Handling Edge Cases

- If **stock becomes zero or very close to zero before last round**:
  - Growth is zero → cooperating gives zero payoff; defecting also yields zero.
  - Strategy continues defecting (since no future payoffs) until game ends.

- If **capacity ≈ 2n (minimum allowed stock)**:
  - The same thresholds apply; aggressive defect first then cooperate once stock drops below threshold.

- **If observing opponents’ behaviour:**
  - Strategy ignores opponent actions since assumptions preclude coordination or trust.
  - Purely state and round dependent.

---

## Summary of Strategy Behavior

| Round      | Stock Level    | Action   | Rationale                       |
|------------|----------------|----------|--------------------------------|
| 1          | N/A            | Defect   | Maximize immediate gain         |
| 2..r-1     | Stock > 25% capacity | Defect   | Exploit high stock for gain      |
| 2..r-1     | Stock ≤ 25% capacity| Cooperate| Preserve stock for future rounds |
| r (last)   | Any            | Defect   | Maximize last round payoff      |

---

## Optional Enhancement (if using history):

- If in previous round a large number of players defected and stock crashed, consider cooperating earlier to mitigate collapse.
- But since opponents unknown, this adds complexity without guarantee.

---

# Final Notes

This strategy is deliberately aggressive: it exploits the common pool heavily when the stock is healthy, only cooperating minimally near depletion to avoid premature collapse, and defects all-out in the last round.

This approach aims to **maximize cumulative payoff while still preventing immediate resource exhaustion in early rounds** that would end future earning potential.

---

If you want the strategy in a compact pseudocode snippet:

```pseudocode
function decide_action(t, r, n, capacity, S_t):

    C_action = "C"
    D_action = "D"
    stock_safety_threshold = capacity * 0.25

    if t == 1:
        return D_action

    if t == r:
        return D_action

    if S_t > stock_safety_threshold:
        return D_action
    else:
        return C_action
```

---

I hope this aggressive strategy gives you a competitive edge in the tournament!
'''

description_AGGRESSIVE_58 = '''
Below is a detailed aggressive strategy design for the specified Common Pool Resource Game. It is formulated to maximize short-term payoff by defecting as often as possible while trying to prevent early collapse of the resource to maintain some payoff across rounds.

---

### Strategy Name: **Aggressive Defector with Resource Awareness**

---

### Intuition

- Defect (D) aggressively when the resource is plentiful to maximize immediate gain.
- Cooperate (C) only if the resource is critically low to avoid total collapse and zero payoffs for remaining rounds.
- Defect on the last round regardless, since there is no future to protect.
- Use observed history (stock and others’ actions) to estimate depletion risk.
- Do **not** trust others to cooperate; assume worst case (all defect) for calculation.
- Be opportunistic: leverage the resource stock dynamics to squeeze maximum personal payoff.

---

### Parameters Used Internally

- **threshold_critical_low:** A critical stock level below which depletion risk is too high and the strategy cooperates to preserve stock.  
Set by formula:  
`threshold_critical_low = capacity / (2 * n)`  
(Stock roughly at or below half the total minimal cooperative consumption to avoid collapse)

---

### Decision Rules

**1. First Round (t = 1):**  
- Defect (D) because stock is at capacity and opponents haven't acted yet. No incentive to cooperate initially.

**2. Intermediate Rounds (1 < t < r):**

- Observe current stock \( S_t \).

- If \( S_t > \) threshold_critical_low:  
&nbsp;&nbsp;Defect (D) – exploit the resource while it lasts.

- Else (if \( S_t \leq \) threshold_critical_low):  
&nbsp;&nbsp;Cooperate (C) – conserve to sustain the resource, minimize stock depletion.

**3. Last Round (t = r):**  
- Defect (D) no matter the stock since no future rounds remain.

---

### Why This Is Aggressive

- Defect from the start to maximize immediate payoff.
- Only "behave cooperatively" when the resource approaches critical depletion to avoid zero payoffs.
- Defect on the last round for maximum short-term extraction even if it destroys the resource.
- No attempt to punish or reward others, ignore social incentives.
- Relies on stock thresholding instead of complex opponent modeling.

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, capacity, S_t):
    """
    Inputs:
        t: current round index (1-based)
        r: total rounds
        n: number of players
        capacity: resource capacity
        S_t: current stock before action
    
    Returns:
        action: "C" or "D"
    """
    threshold_critical_low = capacity / (2 * n)
    
    if t == 1:
        # Round 1: defect aggressively
        return "D"
    
    if t == r:
        # Last round: defect to maximize payoff
        return "D"
    
    # Intermediate rounds
    if S_t > threshold_critical_low:
        # Stock sufficient: defect
        return "D"
    else:
        # Stock critically low: cooperate to conserve stock
        return "C"
```

---

### Additional Notes

- The threshold is conservative: it triggers cooperation before stock becomes dangerously low.
- Because defecting consumes \( S_t / n \) and cooperating consumes \( S_t / (2n) \), defecting accelerates depletion but yields 2× the payoff per round.
- The strategy keeps defecting as long as the stock suggests it won't collapse immediately, thereby staying aggressive.
- Cooperation only to prevent complete resource collapse and having payoff = 0 for future rounds.
- In practice, this strategy pressures the resource steadily; if others cooperate, it gains more; if all defect, resource collapses quickly—still best short-term payoffs for this player.

---

If you want, I can help design a complementary "opportunistic retaliation" version or help formalize it in more detail, but this current strategy aligns well with being aggressive and managing the resource just enough to maintain personal payoff across rounds.
'''

description_AGGRESSIVE_59 = '''
Here is a fully aggressive strategy designed for the described Common Pool Resource Game:

---
## Strategy Name: **Unrelenting Defector**

### Intuition:
- Always defect to maximize individual gain per round.
- Exploit cooperators by consuming as much as possible every round.
- Do not attempt cooperation or mimicry.
- Do not reduce consumption near game end—maximize immediate returns regardless of future stock.
- Exploit the fact that defecting yields double the payoff per round relative to cooperating, regardless of past.
- Ignore long-term sustainability — prioritize immediate, maximum extraction.

---

### Decision Rules

| Round         | Decision               |
|---------------|------------------------|
| 1..r (all)    | Defect (D)             |

---
### Detailed Explanation & Rationale:

- **Round 1:** Defect immediately to grab the maximal payoff of S / n. No reason to cooperate since cooperation yields lower individual payoff, and you cannot know others’ intentions before they act.

- **Rounds 2 to r-1:** Continue defecting regardless of prior depletion or other players’ previous actions. Since the game is simultaneous and no coordination is possible, the best guaranteed personal gain is defecting each round.

- **Round r (last round):** Defect without consideration for stock sustainability because there's no future after round r to punish or reward. The last round is a "take what you can" round. Defection provides maximal immediate payoff.

- **Edge Cases:**
  - If the stock is depleted (S near zero), defection still means attempting to consume whatever remains (though practically zero). No change to strategy.
  - If capacity is large or small, decision remains the same; always defect.

- **Behavior Regarding Stock Dynamics:**
  - This strategy does not attempt to maintain or grow the stock.
  - Aggressively consumes, potentially driving the pool to depletion.
  - Relies on immediate high payoffs rather than future sustainability.

---

### Pseudocode

```python
def aggressive_defector_strategy(round_num, total_rounds, stock, history):
    # Inputs:
    # round_num: current round number (1-based)
    # total_rounds: total number of rounds r
    # stock: current stock level S before current round actions
    # history: list of previous rounds' actions (can be ignored here)
    
    # Always defect to maximize current round payoff
    return "D"
```

---

### Additional Notes for Tournament Context:

- The strategy assumes all other players might cooperate or defect; it does not try to punish or reward anyone.
- Offers no forgiveness or trust-building steps.
- As a pure defector, it is robust to unknown behaviors and maximizes individual extraction.
- Its "aggressive" label reflects maximal consumption at every step without regard to future consequences or others' behaviors.

---

Let me know if you want a more nuanced aggressive variant that reacts dynamically, or any elaboration!
'''

description_AGGRESSIVE_60 = '''
Here is a clear and detailed aggressive strategy tailored to the Common Pool Resource Game described:

---

## Strategy Name: **"Exploit and Explode"**

### Core Idea:
Maximize individual payoff by aggressively defecting as much as possible to consume the largest share early, while capitalizing on the growth of the common pool only as a secondary effect. The strategy defects always except in a narrowly defined late phase to "milk" any remaining stock without risking loss due to rapid collapse — realizing that defection maximizes each round’s payoff but risks resource depletion. The strategy exploits opponents’ potential cooperation but does not trust reciprocity or seek to sustain the resource longer than strictly beneficial for maximal payoffs.

---

### Decision Rules Summary:

| Round           | Decision                  | Rationale                                              |
|-----------------|---------------------------|--------------------------------------------------------|
| Round 1         | **Defect (D)**             | Start aggressive, maximize initial gain               |
| Rounds 2 to r-1 | **Defect (D)**             | Continue aggressive defection until penultimate round  |
| Round r (last)  | **Cooperate (C) if stock > threshold**, else **Defect (D)**  | Preserve remaining stock for final harvest if worthwhile, else defect |

### Why cooperate on last round?

- Cooperation reduces consumption per player, so if the stock is still reasonably high, cooperating can keep the stock from collapsing completely, allowing a positive payoff instead of zero if defecting destroys remaining stock.
- However, if the stock is depleted (below threshold), defect to grab what is left.

---

### Handling Edge Cases:

- **Low stock before last round:** Stick to defect because defecting always yields a higher payoff per round regardless of stock, unless the stock is zero (zero payoff either way).
- **Initial high stock:** Defect to maximize early gains.
- **If at any point the stock reaches zero:** Actions no longer matter, you get zero payoff, but keep defecting by default.
- **Threshold for last round cooperation:** Define as **stock > (capacity / (2n))**, i.e. if the stock is enough to allow at least cooperating payoff to be meaningful.

---

### Detailed Pseudocode:

```python
def aggressive_strategy(round_index, total_rounds, stock, n, capacity):
    """
    Parameters:
        round_index: current round number (1-based)
        total_rounds: total number of rounds r
        stock: current stock level S (before actions this round)
        n: number of players
        capacity: maximum sustainable stock

    Returns:
        action: "C" or "D"
    """

    # Threshold for deciding last round cooperation
    cooperation_threshold = capacity / (2 * n)

    # First round: defect aggressively
    if round_index == 1:
        return "D"

    # Last round:
    if round_index == total_rounds:
        if stock > cooperation_threshold:
            # Cooperate to preserve some stock and get a guaranteed payoff
            return "C"
        else:
            # Stock too low, defect to maximize immediate payoff
            return "D"

    # Intermediate rounds: continue defecting aggressively
    return "D"
```

---

### Strategic Rationale:

- **Always defect except possibly last round:** Defecting returns `stock / n` which is twice the payoff of cooperating (`stock / 2n`). This is the maximal individual gain per round.
- **Last round cooperation test:** Cooperation at the last round is defensive—to avoid total collapse and zero payoffs if the pool is sufficiently healthy. If stock is low, defecting maximizes whatever is left.
- **No trust in opponents’ cooperation:** Since no communication or trust is possible, and others may defect, aggressive defection maximizes individual return.
- **No attempt to sustain the resource longer than necessary:** Since defect yields greater immediate payoff, long-term sustaining efforts are non-beneficial under aggressive mindset.

---

### Expected Behavior:

- Early rounds generate high individual payoffs by defecting.
- Likely leads to rapid depletion of the resource due to cumulative over-consumption.
- May face zero stock before last round if opponents also defect aggressively.
- Last round tries to collect any remnant stock optimally.
- Exploits cooperative opponents by gaining more payoff each round.
- No hesitation nor signaling intended.

---

This strategy is **unapologetically aggressive**, straightforward to implement, and exploits the payoff structure fully in the pursuit of maximal individual gain.
'''

description_AGGRESSIVE_61 = '''
Here is an aggressive strategy designed for the described Common Pool Resource Game.

---

### Strategic Goals and Rationale

- **Aggressive mindset:** seek to maximize own payoffs by defecting as much as possible while exploiting others' cooperative tendencies.
- **Use defection early to gain high immediate payoffs** and penalize cooperators by depleting the stock quickly.
- **Use cooperation selectively as a threat or to maintain minimal stock** to avoid total collapse that yields zero payoffs in future rounds.
- **Exploit game structure:** defecting yields twice payoff per round compared to cooperating at the same stock level; but excessive defection leads to stock collapse and near-zero payoffs in later rounds.
- **Balance immediate gains with maintaining some stock to get positive payoffs in later rounds.**

---

### Key Observations to Build On

- Defecting always yields double payoff that round versus cooperating, at the same stock.
- If all defect early, stock goes to zero quickly → no future payoff.
- If all cooperate, stock remains high but payoffs remain small.
- Mixed behavior drives stock down but not to zero immediately, allowing potentially continued exploitation.
- Players observe full history; hence your pattern and their responses can be anticipated.
- No communication or coordination; don’t expect cooperation by social contract.
- Endgame considerations: no incentive to sustain stock if last round.

---

### Strategy Outline

**Parameters:**

- `n`: number of players
- `r`: number of rounds
- current round: t (1 ≤ t ≤ r)
- current stock: S_t (initially = capacity)
- observed actions of opponents in previous rounds

---

### Decision Rules

1. **Round 1 (Opening move): Defect**

   - Rationale: Grab maximal payoff before others react.
   - No prior info on opponents, so start aggressively.

2. **Rounds 2 to r-1 (Interim rounds): Defect except when stock too low**

   - If current stock S_t is above a critical stock threshold S_min, **Defect**.
     - Rationale: Maximize each round's payoff exploiting high stock levels.
   - If stock S_t ≤ S_min, **Cooperate** to allow stock to recover (due to growth function), preventing total collapse.
     - Rationale: Prevent stock from falling too low where payoffs near zero; minimal cooperation preserves future returns.
   - S_min threshold can be set to roughly where total defect consumption would collapse stock to zero or cause negligible growth.
     - For example, set S_min = capacity / (4n), a small fraction where aggressive consumption would be destructive.

3. **Last round (t = r): Defect unconditionally**

   - Rationale: No future rounds to sustain stock; maximize immediate gain even if stock goes to zero.
   - There is no future payoff consideration in the last round.

4. **Response to opponent behavior: Ignore cooperation from others (always defect unless stock too low)**

   - Since the strategy is aggressive, do not reward cooperation with cooperation.
   - Cooperate only as a means to avoid stock collapse, not to reciprocate cooperation.

---

### Edge Cases

- **If stock already zero or extremely low (S_t < negligible threshold close to zero):**

  - Cooperate to enable growth if t < r.
  - Otherwise (last round), defect anyway.
- **If number of rounds r = 2:**

  - Round 1: Defect
  - Round 2: Defect (last round)
- **If capacity = 2n (minimum allowed), immediately aggressive but stock is fragile; adapt S_min accordingly.**

---

### Pseudocode

```python
def aggressive_strategy(t, r, S_t, capacity, n):
    S_min = capacity / (4 * n)  # Stock threshold to cooperate to avoid collapse
    last_round = (t == r)

    if last_round:
        # Last round: defect unconditionally
        return 'D'

    if t == 1:
        # First round: Defect immediately
        return 'D'

    # Intermediate rounds:
    if S_t > S_min:
        # Stock sufficient: defect aggressively
        return 'D'
    else:
        # Stock too low: cooperate to recover stock
        return 'C'
```

---

### Summary

- **Always defect except when stock is dangerously low (to preserve future payoffs).**
- **First and last rounds always defect for immediate gain.**
- **Ignore opponent cooperation — never reward it.**
- **Use minimal cooperation only as a tactical move to sustain the stock just enough to keep exploiting it over rounds.**

This strategy embraces an aggressive, self-maximizing approach consistent with given constraints and the payoff environment.
'''

description_AGGRESSIVE_62 = '''
Here is an **aggressive strategy** designed for the repeated common pool resource game described. The intent of this strategy is to maximize individual payoff by defecting whenever it yields higher immediate returns or punishing cooperation that does not benefit the player, while still strategically cooperating very briefly if it helps sustain the resource in the near term (to avoid immediate depletion that ends future profits).

---

### Intuition Behind the Strategy

- **Aggressive mindset:** Prioritize defecting (D) to gain the larger fraction of the stock each round.
- **Preventing total depletion too early:** If everyone defects from round 1, the stock immediately falls to zero and no future payoff is possible. Hence, tolerate short initial cooperation only if it significantly sustains the pool.
- **Exploit other players**: If others cooperate, defect to maximize payoff.
- **Punish defectors only indirectly by withdrawing cooperation** (since we never truly cooperate except in the first round).
- Never "reward" cooperation by cooperating repeatedly.
- **Special considerations at the last round:** Defect always to maximize last round payoff, since future rounds do not matter.

---

### Strategy Summary

| Round | Condition (inputs)                         | Action (C or D)     |
|-------|------------------------------------------|--------------------|
| 1     | Always Cooperate (C)                      | C                  |
| 2..r-1| If stock > threshold: Defect (D)         | D                  |
|       | If stock ≤ threshold (critically low): Cooperate (C) to avoid instant collapse |
| r (last round) | Always Defect (D)                   | D                  |

---

### Key Parameters

- **threshold**: a stock cutoff value to detect dangerous depletion.
  
  Set threshold = capacity / 4 (25% of capacity).
  
  Reasoning:  
  If stock is > 25% capacity, aggressively defect to maximize immediate payoffs.  
  If below 25%, cooperate to prevent collapse and maintain some resource.

---

### Detailed Logic

1. **Round 1 (Initialization):**  
   Start cooperatively to prevent immediate resource collapse and to gain some long-term returns. Cooperating uses less resource than defecting, so by everyone cooperating initially, the stock stays healthier into Round 2.

2. **Intermediate Rounds (2 through r-1):**  
   Observe the current stock after replenishment each round.  
   - If the stock is healthy (above threshold), **defect** to maximize immediate extraction.  
   - If the stock is dangerously low (≤ threshold), **cooperate** to reduce consumption and allow stock to regrow.

3. **Last Round (r):**  
   No future payoffs expected, so **always defect** to take the maximum available payoff, regardless of stock level.

---

### Pseudocode

```
Inputs per round t:
- current_stock S_t
- round number t (1 ≤ t ≤ r)
- total rounds r
- capacity C (capacity)

Parameters:
- threshold = C / 4

Strategy(t, S_t):
    if t == 1:
        return 'C'   # Cooperate in first round to sustain pool
    
    else if t == r:
        return 'D'   # Defect in last round to harvest maximum
    
    else:
        if S_t > threshold:
            return 'D'  # Stock is healthy, defect to maximize gain
        else:
            return 'C'  # Stock is low, cooperate to preserve resource
```

---

### Notes on Behavior

- By cooperating first round, this strategy signals non-extreme aggression immediately, allowing the pool to stay alive longer.
- By defecting whenever the stock is healthy, the strategy maximizes short-term gains and exploits cooperating players.
- By reverting to cooperation only when the pool is dangerously depleted, it delays collapse just enough to sustain future payoffs.
- In the last round, it ignores sustainability and defects outright to maximize immediate payoff.
- The threshold parameter can be tuned depending on game parameters (e.g., number of players n, capacity).

---

### Edge Cases

- **If other players defect from round 1:** The stock will rapidly decline, but this strategy's first round cooperation will be exploited. From round 2, it defects always unless stock is very low.
- **If stock depleted before last round:** The growth function may replenish some, and the strategy switches to cooperation at low stock.
- **If r = 2 (minimum > 1):**  
  Round 1: Cooperate  
  Round 2: Defect (last round)
- **If capacity barely ≥ 2n:** The threshold may be small; the strategy acts aggressively mostly with rare cooperation in low stock.

---

This is a pure aggressive strategy built on selfish maximization with minimal tolerance for cooperation, only aimed at sustaining the resource just long enough to maximize total payoffs from repeated defections. It requires no assumptions about other players’ cooperation and exploits any cooperation by defecting.

---

If you want, I can help outline a more complex reactive version or variants focusing on player action histories. But this baseline aggressive approach directly aligns with maximizing payoffs while acknowledging stock dynamics.
'''

description_AGGRESSIVE_63 = '''
**Aggressive Strategy Design for Common Pool Resource Game**

---

### Strategy Intuition

- **Aggressiveness** means maximizing immediate payoff each round at the expense of long-term sustainability.
- Prefer **Defection (D)** which yields higher immediate payoff: S/n vs S/(2n).
- Exploit the **first-mover and last-round effects**:
  - First round: Start aggressively to assert dominance.
  - Last round: Defect unconditionally because no future harm is possible.
- Because others may cooperate to sustain stock, exploit cooperation by defecting when stock allows.
- When stock is very low, switching to cooperation saves some payoff rather than zero (if stock collapses).
- Use stock levels and past history observations to decide optimally when to defect or cooperate.

---

### Core Decision Rule

- **Default:** Defect (D) to maximize immediate payoff.
- **Exception handling:**
  - If stock after consumption would collapse to zero or near zero, cooperate to avoid collapse.
  - Cooperate if it prevents the resource from extinction, preserving future payoffs.
- **Last round:** Always Defect.
- **First round:** Always Defect to exploit initial high stock.

---

### Key Variables Available Each Round t

- `t`: current round (1 to r)
- `S_t`: current stock before consumption
- History of all players' previous actions and payoffs (common information)

---

### Thresholds and Parameters

- Define a **stock risk threshold** `S_threshold` below which defection risks collapse:
  - Set `S_threshold = capacity / (2 * n)` (half the stock each player would consume by defecting if all defect)
- If `S_t` < `S_threshold`, cooperating may help sustain stock.

---

### Pseudocode for the Aggressive Strategy

```
INPUT: 
  n, r, capacity
  Current round t (1 ≤ t ≤ r)
  Current stock S_t
  History of past actions (for reference, but ignored in aggression except to estimate if others are often cooperating)

PARAMETERS:
  S_threshold = capacity / (2 * n)  # threshold for risky stock level

DECISION:

IF t == r:                      # Last round
    ACTION = Defect (D)          # Exploit fully as no future rounds
   
ELSE IF t == 1:                 # First round
    ACTION = Defect (D)          # Be aggressive from start

ELSE:                          # Intermediate rounds
    # Predict total consumption if all defect:
    total_defect_consumption = S_t  # max possible consumption (S_t/n * n = S_t)
    # Predict stock after all defect:
    S_after_defect = S_t - total_defect_consumption = 0
    
    # If current stock low (less than risk threshold), cooperate to avoid collapse:
    IF S_t < S_threshold:
        ACTION = Cooperate (C)
    ELSE:
        ACTION = Defect (D)
```

---

### Explanation

- **Last round defect:** No incentive to preserve stock further; maximize final gain.
- **First round defect:** Seize early advantage if opponents cooperate.
- **Intermediate rounds:** Cooperate only to prevent catastrophic collapse; otherwise defect.
- This aligns with aggressiveness: exploit while stock permits; occasionally cooperate only as a defensive move to sustain the resource enough for next round yields. 

---

### Handling Potential Edge Cases

- **If stock is exactly zero or near zero** at round start, you have no consumption possible; action has no payoff difference, so default to defect.
- **If other players mostly cooperate,** defecting yields high payoffs and lowers stock, hurting others in the long run.
- **If other players mostly defect,** stock quickly collapses forcing cooperation to eke out some payoff.
- **No attempt at tit-for-tat or forgiveness:** pure exploitation; no trust or strategy adaptation.

---

### Summary of the Aggressive Strategy

| Round        | Stock condition         | Action      | Reason                              |
|--------------|------------------------|-------------|-----------------------------------|
| 1 (first)    | Any                    | Defect (D)  | Maximize early payoff             |
| r (last)     | Any                    | Defect (D)  | No future rounds to protect stock |
| 1 < t < r    | S_t < S_threshold      | Cooperate (C)| Prevent resource collapse          |
| 1 < t < r    | S_t ≥ S_threshold      | Defect (D)  | Exploit high stock aggressively   |

This strategy is **aggressive** because it refuses to cooperate unless strictly necessary to avoid extinction, and defects whenever it can profit without immediate resource collapse. It prioritizes maximizing own payoff each round and risks long-term depletion only when forced.

---

If you want, I can formalize this further or clarify any part of the strategy for implementation.
'''

description_AGGRESSIVE_64 = '''
**Aggressive Strategy Design for the Common Pool Resource Game**

---

### Intuition about Aggressive Strategy

An aggressive player prioritizes maximizing their own immediate payoff without regard for sustaining the common resource, even if that risks rapid depletion of the stock. Defecting (D) yields higher immediate payoff than cooperating (C) given the same stock level. Since the game is repeated, an aggressive player may attempt to exploit cooperative opponents for as long as possible, then defect aggressively to secure maximum total payoffs before the pool collapses.

---

### Key Observations

- **Defecting always yields double the immediate payoff of cooperating in a round with any given stock S** (S/n vs S/(2n)).
- Defecting hastens depletion of the stock, reducing or eliminating future payoffs.
- Cooperators consume less, preserving the stock and extending the game.
- The **last round** offers no future payoff to protect, so defecting maximizes final payoff.
- Early rounds can be exploited by cooperating opponents for higher immediate gain.

---

### Strategy Outline

**Core Idea:**  
- Defect every round by default to maximize immediate payoff and pressure the stock down rapidly (aggressiveness).
- To exploit cooperators, cooperate briefly in early rounds if beneficial, then switch to defect.
- In the last round, always defect.
- Use history of opponents' actions to decide when to "switch" from cooperation attempts to pure defection (end of exploitation).
- Since no coordination or communication is possible, infer opponents' cooperativeness by their observed actions.

---

### Detailed Decision Rules

Let:

- `t` = current round (1-indexed)
- `r` = total rounds
- `history_actions[t'][i]` = player i's action at round t' (known up to t - 1)
- `observed_cooperators(t-1)` = number of players who cooperated in previous round (for t > 1)

---

#### Rule 1: Round 1 (t=1)

- Defect.
- Rationale: No information about opponents, maximize immediate gain.

---

#### Rule 2: Early rounds (1 < t < r)

- If in **previous round** more than half of opponents (≥ (n-1)/2) cooperated:

  - Cooperate in this round.
  - Rationale: Temporarily "pretend" to cooperate to exploit cooperators, share stock consumption moderately, gain payoff without raising suspicion.

- Else:

  - Defect.
  - Rationale: Opponents are aggressive or defecting, so respond aggressively.

---

#### Rule 3: Last round (t = r)

- Defect.
- Rationale: No future rounds, maximize final extraction.

---

### Summary in Pseudocode

```python
def aggressive_strategy(t, r, n, history_actions):
    # history_actions: dictionary keyed by round -> list of player actions
    # "C" or "D"
    # Our player index is 'me', known internally but irrelevant here since no player coordination

    if t == 1:
        # First round always defect
        return "D"

    elif t == r:
        # Last round always defect
        return "D"

    else:
        # Count cooperators last round excluding self
        last_round = t - 1
        last_round_actions = history_actions.get(last_round, [])
        if not last_round_actions:
            # no info yet, fallback to defect
            return "D"

        # Assuming player index 'me' = 0 for reasoning; exclude self action if stored
        # Since no info about own past action needed here, just count others
        cooperators = sum(1 for a in last_round_actions if a == "C")

        # Number of other players = n - 1
        if cooperators >= (n - 1) / 2:
            # Many cooperators last round, cooperate to exploit
            return "C"
        else:
            # Few cooperators, defect
            return "D"
```

---

### Rationale and Behavior Description

- **Round 1 Defection:** Start aggressively to claim high immediate payoff.
- **Conditional Cooperation:** When many opponents cooperate, match by cooperating to share the stock extraction costs and elicit cooperative behavior while still securing decent payoffs. This avoids pushing the stock down prematurely.
- **Revert to Defection when Others Defect:** If opponents defect or cooperation is sparse, assert dominance by defecting.
- **Last Round Defection:** No incentive to preserve stock, so defect maximally.
- **Result:** The strategy aggressively exploits vulnerable cooperators, pressures defectors, and extracts maximum payoff overall.

---

### Edge Cases

- **If all players defect from start:** The stock collapses fast. Strategy defects constantly, matching others.
- **If opponents cooperate fully:** Strategy will initially defect, forcing stock decline, then cooperate temporarily to exploit slowly diminishing stock for longer.
- **If opponents switch strategies:** Strategy adapts every round by observing cooperation levels.

---

### Summary

| Round          | Condition                          | Action |
|----------------|----------------------------------|--------|
| t = 1          | No info                          | D      |
| 1 < t < r      | If majority cooperated last round| C      |
| 1 < t < r      | Else                            | D      |
| t = r          | Final round                     | D      |

---

This strategy balances aggression (default defect, last round defect) with opportunistic exploitation (conditional cooperation when many others cooperate), aligning well with the aggressive mindset.
'''

description_AGGRESSIVE_65 = '''
Here is a designed aggressive strategy for the Common Pool Resource Game, focusing on maximizing personal payoff by defecting as often as possible while mitigating risk of early stock collapse that would reduce future payoffs. The strategy is aggressive in consistently exploiting the resource (defecting), but it also contains a basic responsive mechanism to conserve stock only if the resource is nearing collapse, maximizing benefit until the last rounds.

---

## Aggressive Strategy Description

### Core Idea:
- Always defect (D) to consume the larger share and maximize immediate payoff.
- Cooperate (C) only if the stock is dangerously low **and** it is not the last round, to allow partial stock recovery and avoid total collapse that would yield zero payoffs.
- In the last round, defect no matter what, since there is no future to protect.
- In the first round, defect to jumpstart personal gain immediately.

### Rationale:
- Defection yields twice the per-round payoff compared to cooperation given the same stock.
- Stock collapse must be avoided until late rounds; otherwise, future payoffs become zero.
- The growth function is hump-shaped with maximum growth at half capacity. Keeping stock near or above ~capacity/4 allows some resource replenishment.
- Since no communication or coordination is possible, this strategy assumes others may defect or cooperate arbitrarily; it does not try to reciprocate cooperation (too costly and unreliable).
- It is aggressive by prioritizing defecting every round except when total collapse risk forces minimal cooperation to sustain the resource.

---

## Decision Rules (expressed step-by-step)

Let:

- t = current round (1 to r)
- S = current stock at start of round t
- n = number of players
- capacity = capacity of the resource (≥ 2n)
- threshold_low_stock = capacity / 4  (25% of capacity; threshold chosen to avoid stock collapse)

Then:

1. **If t = r (last round):**
    - Action = Defect (D)
    - Rationale: No future rounds to preserve stock for; maximize immediate payoff.

2. **Else (t < r):**
    - If S ≤ threshold_low_stock:
        - Action = Cooperate (C)
        - Rationale: Stock too low, risk of collapse next round; cooperate minimally to enable growth.
    - Else:
        - Action = Defect (D)
        - Rationale: Stock moderate or high; maximize personal payoff by defecting.

---

## Pseudocode

```python
def aggressive_strategy(t, r, S, capacity, n):
    """
    Parameters:
        t: current round (1-based)
        r: total rounds
        S: current stock at start of round t
        capacity: maximum capacity of the common pool
        n: number of players

    Returns:
        action: 'C' or 'D'
    """
    
    threshold_low_stock = capacity / 4  # 25% capacity
    
    if t == r:
        # Last round: always defect to maximize immediate payoff
        return 'D'
    
    else:
        if S <= threshold_low_stock:
            # Resource is critically low, cooperate to avoid collapse
            return 'C'
        else:
            # Resource is sufficient, defect for higher payoff
            return 'D'
```

---

## Handling Edge Cases

- **First round (t=1):** Defect immediately to maximize gains from the full initial stock.
- **Last round (t=r):** Always defect to capitalize on whatever stock is left.
- **Very low stock early:** If cooperation is triggered, cooperative action is minimal (stock/(2n)), which is half the defect payoff, but helps maintain the resource to allow more future payoff.
- **When stock is exactly at threshold:** Cooperate, since risk is tangible.
- **No assumptions on opponents:** The strategy ignores opponent history and rewards since players cannot be trusted to cooperate reliably.
- **Stock collapse scenario:** If stock hits zero, growth and payoffs become zero next rounds; the threshold check tries to preempt that.

---

## Summary

This aggressive strategy defects by default to get the maximum share but cooperates just enough to preserve the stock above a critical low threshold before the last round. It takes advantage of the sustainable growth function but does not trust or rely on others' cooperation. The strategy is straightforward, unyielding, and exploits the resource aggressively until collapse is imminent or the game ends.

---

If you want, I can also describe alternative parametric modifications or a version that conditions on observed past actions, but in the absence of reliable communication or coordination, pure threshold-based aggressive defection with minimal rescue cooperation works robustly for aggressive play.
'''

description_AGGRESSIVE_66 = '''
Below is a detailed aggressive strategy for the Common Pool Resource Game that fits the specification and aligns with an aggressive mindset.

---

### Strategy Overview: "Defect-First Aggro with Opportunistic Cooperation"

**Key idea:**  
Maximize immediate payoff by defecting (consuming heavily) whenever it is beneficial or safe to do so, exploiting cooperators when present, and only cooperate opportunistically to preserve the resource stock when depletion threatens long-term gains (i.e., near the end of the game or when stock is critically low).  

This strategy aggressively exploits the resource and other players, prioritizing personal payoff over group sustainability, but with minimal tactical concessions to avoid completely destroying the resource prematurely.

---

### Decision Rules

1. **Round 1 (First Round):**  
   - Defect unconditionally.  
   - Rationale: No info yet, maximizing immediate gain; no incentive to cooperate initially.

2. **Rounds 2 to r - 1 (Intermediate Rounds):**  
   - **Defect if stock is above a critical threshold (e.g., 2 × capacity / 3).**  
     Rationale: When stock is ample, defecting yields highest payoff with moderate risk of depletion.  
   - **Cooperate if stock falls at or below threshold to avoid stock collapse.**  
     Rationale: By slightly cooperating when stock is low, avoid destroying the resource and maintain some payoff in future rounds.
   - **If in previous round any player defected, continue defecting.**  
     Rationale: Punish defections by not cooperating while others defect; exploit defectors aggressively.  
   - **If all cooperated last round and stock is healthy, defect to exploit cooperators.**

3. **Last Round (Round r):**  
   - Always defect.  
   - Rationale: No future rounds; maximize final round payoff without regard to stock sustainability.

---

### Edge Case Handling

- **Stock very low (≤ capacity / (4n)) — critical stock level:**  
  Defecting would likely zero the stock. In intermediate rounds, cooperate to allow regeneration.  
  In last round, defect anyway.

- **All previous rounds cooperated and stock is maximal:**  
  Defect to maximize payoff exploiting cooperators.

- **If observe rapid stock decline (e.g., stock this round < 50% of last round):**  
  Cooperate next round to slow collapse.

- **If multiple players defect repeatedly:**  
  Persist defecting, exploiting a "broken" resource to maximize short-term gain.

---

### Pseudocode

```python
def aggressive_strategy(round_number, stock, capacity, n, history):
    # history: list of length round_number-1 of tuples (actions, stock_before, stock_after)
    # Each actions is list of length n of {'C' or 'D'} for players including self
    # Assume index 0 is this player
    
    critical_threshold = 2 * capacity / 3
    very_low_stock_threshold = capacity / (4 * n)
    
    if round_number == 1:
        # First round: defect unconditionally
        return 'D'
    
    last_round_actions, _, _ = history[-1]
    defected_last_round = any(a == 'D' for i, a in enumerate(last_round_actions) if i != 0)
    
    # Last round: always defect
    if round_number == r:
        return 'D'
    
    # If stock is very low, cooperate to allow some regeneration
    if stock <= very_low_stock_threshold:
        return 'C'
    
    # If stock dropped significantly last round, cooperate to preserve
    if round_number > 1:
        _, stock_before_last, stock_after_last = history[-1]
        if stock_after_last < 0.5 * stock_before_last:
            return 'C'
    
    # If others defected last round, punish/exploit by defecting
    if defected_last_round:
        return 'D'
    
    # If all cooperated last round and stock is healthy, defect to exploit
    if not defected_last_round and stock > critical_threshold:
        return 'D'
    
    # Otherwise, cooperate when stock is low or to avoid collapse
    if stock <= critical_threshold:
        return 'C'
    
    # Default: defect
    return 'D'
```

---

### Explanation of Aggressiveness

- The strategy starts aggressively by defecting immediately to grab maximal payoff.
- It exploits cooperators by defecting after rounds of cooperation, maximizing individual gain.
- It punishes defectors by never cooperating if others defect.
- It only cooperates to preserve the resource when stock threatens immediate collapse, thus preserving the aggression long-term but pragmatically stopping just short of suicide depletion—ensuring continued opportunity for exploitation.
- Ends the game with maximal selfish behavior regardless of resource state.

---

This strategy leverages information about past actions and stock dynamics but does not assume cooperation norms, signaling, or coordination, fitting perfectly with the aggressive mindset and tournament setting described.
'''

description_AGGRESSIVE_67 = '''
Below is a fully described **Aggressive Strategy** for the Common Pool Resource Game that fits the requested criteria:

---

### Aggressive Strategy Overview

This strategy maximizes immediate payoff by defecting (D) as often as possible, exploiting the resource pool aggressively. It uses minimal cooperation only when *forced by the game structure* or to exploit opponents who cooperate. It aims to maximize total cumulative payoff by extracting as much resource as possible, early and often, without regard for sustainability or long-term stock health.

---

### Strategic Intuition

- **Defect (D) whenever possible**: Defecting consumes twice as much as cooperating per player, yielding higher immediate payoff.
- **First round**: Always defect to seize early high payoff before opponents can respond.
- **Subsequent rounds**: Continue defecting as long as the stock is sufficient to generate positive payoff.
- **Stock depletion risk**: If the stock is critically low, defecting yields small payoffs (since payoff depends on current stock).
- **Final round**: Defect to capture maximum possible payoff since no future rounds exist (no incentive to conserve).
- **Opponent behavior irrelevant**: Strategy is agnostic about others; purely payoff-driven and aggressive.
- **Handle edge cases of low stock**: If defect payoff becomes zero or less/makes no sense (e.g., zero stock), then cooperate by convention to consume less and extract residual payoff if any — but practically won't occur since payoff = 0 at zero stock anyway.

---

### Decision Rules

**Notation:**

- Current round: t, with t ∈ {1, ..., r}
- Current stock at start of round t: S_t (known before action)
- Number of players: n
- Capacity as given
- Action at round t: a_t ∈ {C, D}

**Payoffs per action given stock S_t:**

- Cooperate payoff π_C = S_t / (2n)
- Defect payoff π_D = S_t / n

---

### Detailed Rules

1. **At round t (1 ≤ t < r):**

    - If defecting payoff π_D = S_t / n > 0, **play Defect (D)**.
    - Else (if payoff zero or negative, unlikely but covers extreme cases), play **Cooperate (C)** for minimal consumption.

2. **At last round t = r:**

    - Always **Defect (D)** regardless of stock to maximize terminal payoff.

3. **Note:** No dependence on opponents’ past actions. No cooperation to sustain stock.

---

### Pseudocode

```python
def aggressive_strategy(round_t, total_rounds_r, current_stock_S, n, capacity):
    """
    Decide action (C or D) for round_t based on stock S.

    Parameters:
    - round_t: current round number (1-based)
    - total_rounds_r: total rounds
    - current_stock_S: stock at beginning of round t
    - n: number of players
    - capacity: stock capacity (unused here but given)
    
    Returns:
    - action: 'C' or 'D'
    """

    payoff_defect = current_stock_S / n
    payoff_cooperate = current_stock_S / (2 * n)

    # Last round: always defect
    if round_t == total_rounds_r:
        return 'D'

    # Prior rounds: defect if payoff positive, else cooperate
    if payoff_defect > 0:
        return 'D'
    else:
        return 'C'
```

---

### Why this strategy is aggressive?

- **Always defect if positive payoff possible:** maximizing immediate gain
- **No cooperation for resource sustainability:** intentionally ignoring long-term health, exploiting resource aggressively
- **Last round defect guarantees maximum terminal extraction**
- **No forgiveness or reciprocity—purely self-maximizing with short-term focus**

---

### Edge Cases Covered

- **First round (t=1):** Defect, since payoff positive (initial stock = capacity ≥ 2n)
- **Last round (t=r):** Defect regardless of stock to obtain maximum terminal payoff
- **Stock near zero:** If payoff from defect zero or negative (practically zero only), cooperate to preserve minimal payoff
- **No dependence on opponents:** No assumptions about cooperation or defection by others, purely self-focused

---

### Summary

This pure aggressive defect-first strategy plays:

- Defect every round except if defect payoff zero, then cooperate;
- Defect on the last round no matter what;
- Maximizes immediate payoff by consuming maximum per round ahead of others;
- Ignores sustainability or retaliation;
- Is robust to unknown opponent behaviors.

---

Let me know if you want a variant that incorporates conditional retaliation or mixed cooperation phases!
'''

description_AGGRESSIVE_68 = '''
Here is a design for a fully aggressive strategy consistent with the game structure and constraints:

---

### Strategy Name: "Unrelenting Defector"

### Intuition:
The goal of an aggressive strategy is to maximize individual payoff by defecting **whenever it yields strictly higher immediate payoff**, leveraging others' possible cooperation to gain more. Since defecting consumes more stock (stock/n vs. stock/(2n)) but yields higher immediate payoff per round, this strategy always defects to maximize personal payoff regardless of future consequences or others’ actions.

---

### Decision Rules

#### Round 1:
- Defect (D).
  - Reason: No history yet; best immediate payoff is defecting.

#### Round t ∈ {2,...,r - 1}:
- Always Defect (D).
  - Reason: Maximizing instant payoff each round; no incentive to cooperate if purely aggressive.
- Do not condition on history or stock level.
  - Aggressive mindset means ignoring long-term sustainability or retaliation threats.

#### Round r (Last round):
- Defect (D).
  - Reason: No future rounds to protect, so defect to extract maximum payoff now.

---

### Edge Cases Handling

- **If stock reaches zero before the final round**:
  - Actions have no immediate payoff (stock=0 → payoffs zero).
  - Continue defecting (D).
  - This is consistent with aggressive mindset; no cooperation signals.

- **If stock is very low (close to zero)**:
  - Defect anyway; no strategic benefit to cooperate in an aggressive mindset.

---

### Pseudocode

```python
def aggressive_strategy(history, stock, round_number, r, n, capacity):
    # history: list of previous rounds' action profiles (not used since always defect)
    # stock: current stock level S_t before deciding action
    # round_number: current round t (1-based)
    # r: total rounds
    # n: number of players (not used here)
    # capacity: max stock (not used here)

    # Always defect
    return 'D'
```

---

### Summary

- **Always defect every round** (no cooperation, no conditional behavior).
- Ignores others’ behavior or stock dynamics.
- Focus on maximizing immediate payoff per round.
- No strategic concessions or punishments; purely aggressive take-all approach.

---

### Rationale Against Other Strategies

- Exploits cooperators by defecting.
- Does not waste rounds cooperating where only defectors yield higher payoff.
- Maximizes immediate returns assuming others may cooperate sometimes, even at the risk of depleting the stock quickly.
- Not sustainable long term if others also defect, but that’s consistent with aggressive mindset.

---

This strategy represents the pure aggressive defection baseline in this common pool resource dilemma with stock dynamics.
'''

description_AGGRESSIVE_69 = '''
Here is an aggressive strategy for the Common Pool Resource Game, designed to maximize individual payoff by prioritizing defection while managing the stock depletion risk to extend personal gains over multiple rounds. The strategy uses observed history to adjust actions but defaults aggressively to defect.

---

## Intuition and Goals

- **Aggressive baseline:** Defect whenever it is beneficial to get the highest immediate payoff.
- **Stock awareness:** Avoid stock collapse too early to secure payoffs in later rounds.
- **Punish cooperators only indirectly:** No explicit cooperation or forgiveness—focus on maximizing personal gains.
- **Edge case handling:** First round must set tone; last round maximizes immediate payoff.
- **Reactive only to stock state, not trusting cooperation signals:** Because no guaranteed coordination and aggressive mindset.

---

## Strategy Description

**Parameters:**

- n = number of players
- r = number of rounds
- capacity = maximum stock
- t = current round index, 1 ≤ t ≤ r
- S_t = stock at start of round t (known after previous round)

---

### Decision rules for round t:

1. **Round 1 (t=1):** Defect (D).
   - Reason: No prior history, aggressive mindset demands maximizing immediate gain.

2. **Intermediate rounds (1 < t < r):**  
   Let `expected_total_defectors` = n (assume all defect given aggressive environment).  
   
   Compute estimated stock depletion risk based on previous rounds:  
   - If current stock S_t is *high* (close to capacity or sufficiently large to sustain defection): Defect (D).
   - If current stock S_t is *critically low*, so defecting risks zeroing out stock immediately and losing future payoffs: Cooperate (C) briefly to allow some stock recovery and prevent immediate crash.
   
   More precisely:
   - Define threshold stock `threshold = capacity / (2n) * n` = approximately half capacity (adjustable).  
   - If `S_t > threshold` → Defect (D).  
   - Else (stock ≤ threshold), play Cooperate (C) *once* to help stock recover, then revert to Defect next round.

3. **Last round (t = r):** Defect (D) unconditionally.
   - Reason: No future rounds, maximize one-shot payoff.

---

### Notes on stock thresholds and reasoning:

- Defecting consumes S_t / n per player; defect by all consumes total S_t.  
- Cooperating consumes S_t / (2n) per player; all cooperators consume half the stock collectively.  
- If stock is low, defecting will likely zero the stock → no future payoffs. Being aggressive but self-preserving means occasionally cooperating to keep some stock for a few rounds.  
- This cooperation is temporary, tactical, and only done when stock is below the threshold.

---

## Pseudocode

```python
# Inputs per round: t (round number), n, r, capacity, S_t (current stock)

def aggressive_strategy(t, n, r, capacity, S_t, history):
    # Parameters
    threshold = capacity / 2  # or capacity / (2n) * n - roughly half capacity
    
    # Round 1: defect
    if t == 1:
        return 'D'
    
    # Last round: defect unconditionally
    if t == r:
        return 'D'
    
    # Intermediate rounds:
    # Check stock level:
    if S_t > threshold:
        # Stock sufficiently large: defect aggressively
        return 'D'
    else:
        # Stock critically low: cooperate once, then revert to defect next rounds
        # Check if previous round I cooperated to avoid cycling cooperation multiple times
        if t > 1 and history[t-2] == 'C':
            # I cooperated last round, now defect to exploit recovery
            return 'D'
        else:
            # Cooperate once to allow stock recovery
            return 'C'
```

---

## Summary

- **Starts defecting immediately.**
- **Defects whenever stock is healthy to maximize short-term payoff.**
- **Temporarily cooperates only if stock runs low to avoid immediate collapse.**
- **Always defects on the last round to grab maximum possible payoff without concern for future rounds.**
- **Does not attempt forgiveness or trust-based cooperation with others, strictly focus on personal payoff maximizing aggressive approach.**

This strategy aggressively exploits the common pool while managing the risk of stock depletion to optimize cumulative payoff over the repeated game.
'''

description_AGGRESSIVE_70 = '''
Here is a detailed aggressive strategy for the Common Pool Resource Game specified:

---

### Strategy Overview

This strategy aggressively exploits the common pool to maximize individual payoffs, prioritizing short-term gains over sustainability and group welfare. It defects whenever it expects the payoff from defecting to outweigh cooperating **for itself**, regardless of the impact on the resource or other players.

The strategy uses **history-based inference** of opponents' tendencies to anticipate their contributions to stock depletion, and adapts its behavior accordingly to maximize payoff.

---

### Key Intuition for Aggressiveness

- **Always defect except in the last round with special considerations.**
- If others cooperate, defecting yields higher immediate payoffs.
- Stock sustainability is irrelevant beyond personal gains.
- Exploit cooperative players to drain the pool quickly.
- If the pool is nearly depleted, defect to grab the last possible payoff.
- In the last round, defect to maximize final payout because no future repercussions.

---

### Detailed Decision Rules

Let:

- `t` = current round (1-based)
- `r` = total rounds
- `n` = number of players
- `S_t` = current stock before round t
- `history` = all previous rounds' actions for all players
- `my_id` = index of this player
- `C` = cooperate action
- `D` = defect action

---

#### First Round (t=1)

- No prior data, no incentive to cooperate.
- **Always defect.**

---

#### Intermediate Rounds (1 < t < r)

- Calculate from history:
  - Count of defects from other players in previous rounds (excluding self).
  - Estimate proportion of defectors in the group `p_defect`.
- Calculate expected payoff from defecting and cooperating this round:

  - If I defect:
    - Consumption = S_t / n
  - If I cooperate:
    - Consumption = S_t / (2n)
- Assume others will continue in their previous pattern (i.e., expected group composition remains similar).
- **Decision**:
  - If expected payoff from defect > cooperate this round (always is true given payoffs), defect.
  - However, if stock `S_t` is below a small threshold (e.g. < n, close to depletion), defect anyway to grab last pieces.

In short, **always defect in intermediate rounds without exception.**

---

#### Last Round (t = r)

- No future rounds to preserve stock.
- Maximizing immediate payoff is the only goal.
- **Always defect.**

---

### Handling Edge and Special Cases

- **If stock `S_t` = 0:** Resource is depleted.
  - There's nothing to gain.
  - **Action:** Defect (does not cost anything, but neither pays out).
- **If stock `S_t` is very low (e.g., ≤ n):**
  - Defect to get the last high payoff, since defect payoff = S/n.
- **Opponent behavior unknown or mixed:**
  - No cooperation trust. Aggression does not depend on opponent types.
  
---

### Summary

| Round       | Action    | Rationale                               |
|-------------|-----------|----------------------------------------|
| First round | Defect    | No history, maximize immediate gain   |
| Intermediate rounds | Defect    | Aggressively exploit the resource, indifferent to sustainability |
| Last round  | Defect    | Maximize final round payoff, no future cost to resource depletion |
| Resource depleted | Defect (no payoff) | No cost, no gain, but strategy consistent |

---

### Pseudocode

```
function aggressive_strategy(t, r, n, S_t, history, my_id):

    if S_t == 0:
        return D   # No stock to consume, keep defecting
    
    if t == r:
        # Last round: defect to maximize payoff
        return D
    
    if t == 1:
        # First round: no info, defect aggressively
        return D
    
    # Intermediate round
    # Aggressive defection always
    return D
```

---

### Explanation

- The strategy is **purely aggressive and selfish**.
- It does not cooperate under any condition.
- It leverages the payoff structure: defecting yields twice as much as cooperating per round.
- Does not try to maintain stock growth or sustainability.
- Prioritizes immediate personal rewards.
- Effective in a tournament against mixed or cooperative strategies since it exploits cooperators and does not lose out to defectors.

---

If you would like, I can also help you design an extension that conditionally cooperates in some rare cases, but this strict aggressive strategy fits the brief perfectly.
'''

description_AGGRESSIVE_71 = '''
Here is an aggressive strategy for the described common pool resource game, designed to maximize individual payoff primarily by defecting unless a strong tactical consideration compels otherwise. The strategy is grounded strictly in observable actions and states, assumes no cooperative norms, and aims to exploit cooperators while guarding against exploitation.

---

### Strategy Name: **"Relentless Defector with Last-Round Exploit"**

---

### Overview

- **Aggressiveness:** Default action is to defect in every round to maximize immediate payoff.
- **Anticipation of Last Round:** Since no future retaliation is possible after the last round, defect regardless to maximize final payoff.
- **Response to Past Behavior:** Does not attempt cooperation or forgiveness; punishes cooperators by always defecting.
- **Edge Cases Handling:** 
  - First round: Defect outright (no prior information or incentive to cooperate).
  - Terminal round: Defect unconditionally for maximum extraction.
  - If stock ever collapses to zero, defect is irrelevant, but maintain defect for consistency.
- **Use of Stock Levels:** If stock is critically low (close to zero), defect anyway, as cooperation cannot revive the stock in the last rounds.

---

### Detailed Decision Rules

**Input per round t:**
- Current round t (1 ≤ t ≤ r)
- Current stock S_t (≥ 0, ≤ capacity)
- History of player actions for rounds 1..t−1 (for all players including self)
  
**Output:**
- Action a_t ∈ {C, D}

---

### Rule Set

1. **Round 1:**  
   - No history to condition on.  
   - **Action:** Defect (D).

2. **Rounds 2 to r−1 (middle rounds):**  
   - Always defect (D) – aggressive exploitation of the resource and opponents.  
   - Ignore opponent cooperation; do not cooperate.

3. **Round r (final round):**  
   - Defect (D) to receive maximal final payoff, since no retaliation or future is at stake.

4. **Stock Depletion Edge Case:**  
   - If S_t = 0 (resource fully depleted), continue defect by default (even though stock is zero and payoff will be zero).

---

### Pseudocode

```python
def aggressive_strategy(t, S_t, capacity, r, n, history_actions):
    # t: current round (integer)
    # S_t: current stock (float)
    # capacity: max stock capacity (float)
    # r: total rounds (integer)
    # n: number of players (integer)
    # history_actions: list of all players' past round actions, indexed by round and player

    # Edge case: depleted stock (no harvest possible)
    if S_t == 0:
        return 'D'   # defect anyway

    if t == 1:
        # First move: defect
        return 'D'

    if t == r:
        # Last round: defect to maximize payoff
        return 'D'

    # All other rounds: defect to maximize immediate gain and exploit cooperators
    return 'D'
```

---

### Rationale and Comments

- **Aggressive Mindset:**  
  This strategy maximizes immediate returns by defecting every round, exploiting any cooperators present.

- **No Cooperation or Forgiveness:**  
  Given perfect information, temptation to cooperate is ignored in favor of guaranteed high payoffs.

- **No Conditional Cooperation:**  
  Since opponents cannot be trusted to cooperate, no incentive exists to play cooperatively.

- **Last Round Defection:**  
  Standard backward induction result: defecting in the last round maximizes payoff without fear of retaliation.

- **No Signaling or Threats:**  
  Communication is impossible; thus, no coordination or threats reduce the strategy gap.

- **Exploiting Cooperation:**  
  By always defecting, this player gains more than any cooperating player in the same round.

- **Stock Considerations:**  
  The strategy does not attempt to sustain the resource. It is **myopic and aggressive**, focused on immediate extraction rather than long-term preservation.

---

This strategy is clear, aggressive, exploitative, and follows from rational game-theoretic logic under the given constraints. It requires no assumptions beyond the game specification and is robust to all opponent behaviors.
'''

description_AGGRESSIVE_72 = '''
Below is an aggressive strategy tailored to the given common pool resource game. The key objective for an aggressive player is to maximize immediate payoff by defecting as much as possible while balancing the risk of stock depletion and preserving some residual stock where it benefits their own payoff in later rounds. Because defecting yields twice the payoff per round compared to cooperating given the same stock, the default bias is to defect unless the stock collapse would annihilate payoffs and thus reduce future cumulative gain.

---

### Aggressive Strategy Description

**Intuition:**  
- **Always defect unless the stock is too low to sustain defecting without collapsing to zero.**  
- **Avoid cooperating unnecessarily; cooperating only serves to preserve stock when defection is suicidal (i.e., when defection would drive the stock to zero and cause zero payoff in future rounds).**  
- **In the last round, defect no matter what (no future to preserve).**  
- **In the first round, defect immediately (maximize short-term gain).**  
- **In intermediate rounds, estimate impact of defecting vs cooperating on stock; defect if that leaves positive stock after growth or leaves stock high enough for defection next round; cooperate only to avoid total stock destruction.**

---

### Detailed Decision Rules

Let variables at round *t* be:
- *S_t*: current stock at start of round t
- *r*: total rounds
- *n*: number of players

---

#### Step 1: Calculate hypothetical stock if this player defects, assuming all other players defect

- Consumption per defector: S_t / n
- Total consumption if all defect: n × S_t/n = S_t  
  → This means if everyone defects, all stock is consumed, stock goes to 0.

- However, our player does not control others. Since we assume worst case others are defecting (max aggressiveness assumption), the stock will be depleted quickly.

---

#### Step 2: Calculate hypothetical stock if this player cooperates, assuming others defect

- Consumption of cooperators: S_t/(2n)  
- Total consumption if 1 cooperator (us) + (n-1) defectors:  
  C = 1 × S_t/(2n) + (n-1) × S_t/n = S_t/(2n) + S_t (n-1)/n  
  = S_t ( (1/2n) + (n-1)/n )  
  = S_t ( (1/2n) + (n-1)/n )  
  = S_t ( (1 + 2(n-1)) / 2n ) = S_t ( (1 + 2n - 2) / 2n ) = S_t ( (2n - 1) / 2n )

- Stock after consumption:  
  S_remain_coop = S_t - total_consumption  
  = S_t - S_t (2n - 1)/(2n) = S_t ( 1 - (2n - 1)/(2n) ) = S_t ( (2n - (2n -1)) / 2n ) = S_t (1/(2n))  

- Growth:  
  G_coop = 2 × S_remain_coop × (1 - S_remain_coop / capacity)

- New stock if player cooperates:  
  S_new_coop = min(S_remain_coop + G_coop, capacity)

---

#### Step 3: Calculate hypothetical stock if this player defects, assuming others cooperate

- Total consumption if 1 defector (us) + (n-1) cooperators:  
  D = S_t / n + (n-1) × S_t/(2n) = S_t/n + (n-1) S_t/(2n)  
  = S_t ( (1/n) + (n-1)/(2n) ) = S_t ( (2 + n - 1) / (2n) ) = S_t ( (n+1)/(2n) )

- Stock after consumption:  
  S_remain_defect = S_t - D = S_t - S_t (n+1)/(2n) = S_t (1 - (n+1)/(2n)) = S_t ((2n - (n+1))/(2n)) = S_t ( (n-1)/(2n) )

- Growth:  
  G_defect = 2 × S_remain_defect × (1 - S_remain_defect / capacity)

- New stock if player defects:  
  S_new_defect = min(S_remain_defect + G_defect, capacity)

---

#### Step 4: Rules by round

- **Round 1:** Defect. Maximize initial payoff; no prior history, no incentive to cooperate.

- **Rounds t = 2 to r - 1:**  
  Given no model for others and assuming worst case (others defect), decide:

  1. Predict next stock if defect:  
     Assuming others defect, total consumption = S_t (all defect) → stock goes to 0 → no payoff next round. This is bad long term but good short-term payoff (S_t / n this round).

  2. Predict next stock if cooperate:  
     Assuming others defect (only player cooperates), stock next round will be S_new_coop > 0 (since S_remain_coop = S_t/(2n), small but positive). This preserves stock for future rounds.

  3. Compare payoffs:  
     - Defect payoff this round: π = S_t / n (high immediate)  
     - Cooperate payoff this round: π = S_t / (2n) (half immediate)  

  4. Consider cumulative payoff:  
     If defecting this round reduces future stock to zero (no next-round payoff), total expected payoff is approximately current π only.  
     If cooperating preserves stock and hence future payoffs, total payoff could be higher despite losing some immediate payoff this round.

  5. *Heuristic:* If current stock is high (e.g., S_t > threshold), defect; else cooperate.

  Suggested threshold: Defect only if S_t > capacity / 2  
  - This means defect aggressively when plenty of resource remains, since next round payoff is still valuable.  
  - Cooperate otherwise to preserve minimal stock for future rounds.

- **Round r (last round):** Defect unconditionally; no future rounds to protect.

---

#### Step 5: Adapt to observed play (Optional for sophistication)

Since perfect information is available, can track if others defect or cooperate. But aggression assumes others defect or act selfishly, so the strategy does not rely on cooperation from others.

---

### Pseudocode

```python
def aggressive_strategy(t, S_t, r, n, capacity):
    """
    Inputs:
    - t: current round (1-based)
    - S_t: current stock at start of round t
    - r: total rounds
    - n: number of players
    - capacity: stock capacity

    Output:
    - action: "C" or "D"
    """
    # Last round: defect always
    if t == r:
        return "D"

    # First round: defect always
    if t == 1:
        return "D"

    # Threshold for stock to defect aggressively
    threshold = capacity / 2

    if S_t > threshold:
        # Stock high enough to exploit, defect
        return "D"
    else:
        # Stock low, cooperate to preserve for future
        return "C"
```

---

### Summary

- **First round:** Defect to maximize immediate payoff.  
- **Intermediate rounds:** Defect if stock > half capacity, else cooperate to preserve.  
- **Last round:** Defect unconditionally (final maximize extraction).  
- **Mindset:** Exploit maximum payoff whenever resource is abundant; only ease up when resource is critically depleted to avoid zero total payout.  
- **No reliance on opponent cooperation or signaling.**

---

This strategy is aggressive because it defects whenever it can without driving the stock wastefully to collapse before the last round, and only cooperates to maintain residual resource for future exploitation. It embraces aggressive short-term extraction balanced by minimal conservation to avoid total stock wipeout.
'''

description_AGGRESSIVE_73 = '''
Here is an aggressive strategy tailored for the Common Pool Resource Game. It is designed to maximize individual payoff by defecting as much as possible without causing premature depletion of the resource — recognizing that annihilating the stock early harms all players’ payoffs including itself.

---

### Strategy Description: **Calculated Aggression**

**Goal:**  
Maximize cumulative payoff by exploiting others’ cooperation while maintaining the resource just enough to continue extracting large payoffs over multiple rounds.

---

### 1. Decision Rules (When to Cooperate vs Defect)

- **Round 1:**  
  Defect (D). Take the larger share immediately to maximize initial payoff, as no history exists yet.

- **Subsequent rounds (t = 2 to r):**  
  Observe last round's stock (S_{t-1}), other players' actions, and resulting stock dynamics.

  - **If stock is sufficiently high (S_{t-1} ≥ threshold_high):**  
    Defect (D) again to extract maximum payoff while resource can support it.

  - **If stock is moderate but still sustainable (threshold_low ≤ S_{t-1} < threshold_high):**  
    Cooperate (C) to slow depletion, ensuring resource sustainability and future payoffs.

  - **If stock is low (S_{t-1} < threshold_low):**  
    Defect if it’s the last round (no future cost), else cooperate to prevent collapse.

---

### 2. Threshold Definitions

Thresholds depend on the parameters and dynamics but keep intuitive margins:

- `threshold_high = capacity / 2`  
  (Above half capacity is considered "safe" for aggressive harvesting.)

- `threshold_low = capacity / 4`  
  (Below quarter capacity means resource is endangered.)

---

### 3. Handling Edge Cases

- **First round:** No history → Defect.

- **Last round:** Defect unconditionally to maximize final payoff regardless of stock state (no discounted future rounds).

- **Rounds where stock is zero:**  
  Cooperate has no payoff value (stock zero means no resource), but Defect yields zero too. Continue cooperating (no incentive to defect into nothing).

- **If all others defect in last round (depleting stock):**  
  Accept zero future payoff, since it is last round.

---

### 4. Summary of Pseudocode

```python
def aggressive_strategy(round_t, round_r, current_stock, capacity, n, history):
    # Parameters
    threshold_high = capacity / 2
    threshold_low = capacity / 4

    # Last round always defect
    if round_t == round_r:
        return 'D'

    # First round, no previous info, defect
    if round_t == 1:
        return 'D'

    # Subsequent rounds: use stock and history to decide
    S_prev = current_stock  # stock at start of current round after growth

    if S_prev >= threshold_high:
        # Resource healthy, defect aggressively
        return 'D'
    elif threshold_low <= S_prev < threshold_high:
        # Moderate stock, cooperate to preserve resource
        return 'C'
    else:
        # Low stock
        # Cooperate to avoid collapse before last round
        return 'C'
```

---

### 5. Rationale and Properties

- The strategy is **aggressive** by defecting when the resource is abundant, maximizing immediate payoffs.

- It **protects resource longevity** by cooperating in moderate and low stock to avoid collapsing the common pool prematurely, preserving future rounds' gains.

- It **exploits opponents' cooperation** by defecting when possible.

- It **maximizes last-round gains** by defecting regardless of the state, since no future rounds remain.

- No assumptions about opponent behavior are made beyond observable history and stock state.

---

### 6. Notes on Implementation

- The thresholds (`capacity / 2`, `capacity / 4`) can be tuned if desired for sensitivity to resource depletion.

- The strategy leverages **perfect monitoring**: knowing exact stock and players’ past actions to time defection optimally.

- No cooperation is signaled or incentivized beyond self-interest; it accepts short-term cooperation to safeguard long-term profits.

---

This aggressive yet calculated approach balances immediate exploitation with minimal resource preservation, consistent with the aggressive mindset and maximizing  total payoffs in the repeated common pool resource context.
'''

description_AGGRESSIVE_74 = '''
Here is a detailed description of a strongly **aggressive strategy** tailored to the Common Pool Resource Game with the given specification. The strategy assumes no cooperation unless strictly advantageous and prioritizes maximizing individual payoffs aggressively over the short and long term.

---

## Strategy Name: **"Endgame Aggressor"**

---

### Intuition and Aggressive Mindset

- **Maximize immediate gain:** Prefer defect (D) to extract larger payoff per round.
- **Exploit cooperation early if beneficial:** If others cooperate early to grow stock, defect to harvest high payoffs.
- **Prevent long term stock sustainability:** If stock is at risk of running out, accelerate depletion to reduce future cooperation gains of others.
- **Exploit last round:** Defect unconditionally on last round to maximize final payout, since no future punishment possible.
- **Punish cooperators:** Switch to defect if opponent(s) cooperated while we defected previously — no forgiveness.

---

### Inputs Available Each Round:

- Round number t, total rounds r
- Current stock S_t (after growth from previous round)
- History: actions of all players in past rounds

---

### Decision Rules

---

#### 1. **First Round (t = 1):**

- Defect (D) immediately.
- Rationale: No history, so maximize immediate payoff since no future consequences yet.

---

#### 2. **Intermediate rounds (1 < t < r):** 

- Observe stock S_t.
- Calculate expectations for payoffs by defecting vs cooperating.

**Rules:**

- **If stock S_t is very high (close to capacity):**

  - Defect (D).
  - Rationale: Large stock means defect yields max immediate payoff without risking immediate depletion.

- **If stock S_t is low (near 2n or less):**

  - Still defect (D).
  - Rationale: Since growth is limited and endgame approaches, maximize short-term gain.
  
- **If any player cooperated last round but I defected:**

  - Continue defecting.
  - Rationale: Punish cooperation from others by harvesting aggressively.

- **If all cooperated last round:**

  - Defect to exploit cooperation.
  - Rationale: Gain more by defecting on a high stock grown by cooperation.

---

#### 3. **Last round (t = r):**

- Defect (D) unconditionally.
- Rationale: No future rounds for punishment; single-shot gain maximization.

---

### Summary:

| Round                 | Strategy                                  |
|-----------------------|-------------------------------------------|
| t = 1 (first round)   | Defect                                    |
| 1 < t < r (intermediate rounds)   | Defect, regardless of stock or opponent behavior |
| t = r (last round)    | Defect                                    |

---

### Pseudocode

```pseudo
Input: round t, total rounds r, current stock S_t, history of actions H

if t == 1:
    action = Defect

else if t == r:
    action = Defect

else:
    // Between first and last rounds
    action = Defect

return action
```

---

### Additional Notes:

- This strategy **always defects** to maximize immediate payoff every round.
- It relies on the assumption that cooperative players risk stock growth, which can be exploited.
- No attempts at cooperation or forgiveness.
- No reliance on detecting cooperation or trying to induce it.
- On last round, defecting guarantees maximal payoff.
- Since defecting consumes a higher per capita share per round, this strategy aggressively accelerates stock depletion, accepting that repeated defecting will drive stock down—this is consistent with an aggressive "take all you can now" mindset.

---

### Why is this aggressive?

- The strategy aggressively exploits the resource, refusing to sacrifice immediate gains for long term sustainability.
- It punishes cooperation by never reciprocating.
- It ignores long-term stock health to maximize immediate and final payoffs.
- It accelerates depletion and may leave other players with little payoff advantage.
- It provides no cooperation incentives or hope of trust building.

---

Let me know if you want a variant that adds conditional defection or some limited cooperation for tactical reasons. But the above maximally aggressive pure defection strategy is clear, simple, and aligns perfectly with the brief.
'''

description_AGGRESSIVE_75 = '''
**Aggressive Strategy for the Common Pool Resource Game**

---

### Intuition and Objectives

- **Aggressiveness:** Maximize individual payoff in as many rounds as possible by defecting, exploiting cooperators if present.
- **Sustainability:** Accept stock collapse only if it leads to higher overall payoff in the long run.
- **Exploitation:** Defect early to grab high payoffs before the stock depletes due to overconsumption.
- **Adaptation:** React aggressively to opponents’ cooperation but switch tactics close to the end of the game to maximize total gains.

---

### Key Observations:

- Defecting yields twice the immediate payoff compared to cooperating in the same round if stock size remains large.
- Overexploitation leads to stock collapse, which eliminates future gains.
- Cooperating yields lower payoff but stabilizes the resource, enabling future payoffs.
- Because the game is finite and players observe all past actions, toward the end of the game, the incentive for exploitation changes (last round: defect always; earlier last rounds: defect except when stock is near zero).

---

### Aggressive Strategy Description

| Round         | Condition                                 | Action                    | Reasoning                                                 |
|---------------|-------------------------------------------|----------------------------|-----------------------------------------------------------|
| Round 1       | Always defect                             | **Defect (D)**             | Capture maximum payoff immediately.                        |
| Rounds 2 to r-1 | If stock > threshold → Defect<br>If stock low → Cooperate | **Defect (D)** if stock > threshold<br>**Cooperate (C)** if stock ≤ threshold | Keep defecting to maximize immediate payoff while stock is sufficient.<br>If stock too depleted (close to zero), cooperate to avoid total collapse / zero payoff. |
| Round r       | Final round - Always defect               | **Defect (D)**             | No future rounds to preserve stock, defect to grab final payoff.|

---

### Parameter Details

- **Threshold for stock**:  
  Set threshold = capacity / (4 * n)  (a small fraction of capacity and per player notion)  
  - Rationale: below this, defecting will likely drive stock to zero and yield zero growth, so cooperate to squeeze some growth if possible.

---

### Pseudocode

```python
def aggressive_strategy(round_number, total_rounds, current_stock, capacity, n):
    # Constants
    threshold = capacity / (4 * n)

    # Round 1: Always defect
    if round_number == 1:
        return 'D'

    # Last round: defect always (grab last payoff)
    if round_number == total_rounds:
        return 'D'

    # Intermediate rounds
    if current_stock > threshold:
        # Stock sufficient: Defect to maximize immediate payoff
        return 'D'
    else:
        # Stock depleted: cooperate to promote recovery (mitigate total collapse)
        return 'C'
```

---

### Additional Strategic Notes

- **Why cooperate when stock is low?**  
  Defecting on near-zero stock means immediate zero gain this round and no future growth; cooperating consumes less instantly, allowing growth to rebuild stock for potential payoff in remaining rounds.

- **Why defect early and mid-game?**  
  Early rounds are most valuable since stock is large. By defecting, this strategy aggressively extracts payoff at the expense of potentially collapsing the stock faster than cooperators.

- **No forgiveness mechanism:**  
  The strategy does not attempt to coordinate or respond with cooperations to others’ cooperations. It maximizes individual gain even if it risks stock collapse.

---

### Summary

- **Always defect in first and last rounds.**
- **Defect whenever stock is sufficiently high.**
- **Cooperate only if stock is dangerously low to allow regrowth.**
- This ensures an aggressive stance striving for maximal payoff throughout, accepting risk of resource depletion.

---

This strategy will test opponents' willingness to cooperate and punish any attempt at restraint with immediate exploitation, consistent with an aggressive mindset in an iterated common pool resource setting.
'''

description_AGGRESSIVE_76 = '''
Below is a detailed aggressive strategy tailored for the Common Pool Resource Game described. The strategy is explicitly designed to maximize individual payoff by consistently defecting (harvesting the larger share), managing stock depletion pragmatically, and exploiting end-game effects to maximize gains. It does not attempt cooperation or punishment, as aggressiveness prioritizes immediate or maximal returns even at the risk of resource depletion.

---

## Aggressive Strategy: "Defect Until Depletion"

### Intuition and Rationale

- **Aggressiveness:** Always defect (consume **stock/n**) to maximize marginal payoffs per round.
- **Stock depletion tradeoff:** While defecting aggressively will most likely deplete the resource quickly, growth dynamics imply some regeneration if there is some stock left. Still, maximizing short-term gain outweighs sustainability concern.
- **First round:** Start by defecting immediately; no trust-building or testing.
- **Middle rounds:** Continue defecting regardless of others' actions or current stock level—do not sacrifice short-term payoff.
- **Last round:** Defect as usual since no future rounds remain to sacrifice payoff.
- **Edge cases:** If stock reaches zero or near zero (no stock to consume), consume zero (no payoff), but this is consistent with the aggressive approach—no artificial cooperation.

---

### Formal Decision Rule

For each round **t** ∈ {1,...,r}:

1. **If current stock S > 0:**
   - **Choose action D (Defect)**
2. **Else (S = 0 or effectively 0):**
   - **Choose action C** or **no consumption possible**
   - (Although no stock remains, no benefit from defecting or cooperating; choose arbitrarily C or D since payoff is zero)

---

### Pseudocode

```python
def aggressive_strategy(t, S, r, n, capacity, history):
    """
    Parameters:
        t       : current round (1-based index)
        S       : current common pool stock level before actions
        r       : total number of rounds
        n       : number of players
        capacity: maximum sustainable stock level (not needed here)
        history : list of previous rounds' tuples (actions, stock, payoffs) - not used here
    
    Returns:
        action : 'D' (defect) or 'C' (cooperate)
    """

    if S > 0:
        # Always defect when stock available
        return 'D'
    else:
        # Stock is depleted, no payoff possible
        # Arbitrary choice, e.g. cooperate (C)
        return 'C'
```

---

### Explanation of Components

- **First Round (t=1):** Defect immediately to maximize first-round payoff; no testing or concession.
- **Interim Rounds (1 < t < r):** Ignore others’ past actions or changing stock; defect continually even if stock is low.
- **Last Round (t=r):** No incentive to preserve stock; defect as usual.
- **Stock Exhaustion (S = 0):** No payoff possible; action choice irrelevant but pick cooperate to avoid contradictory signal.
- **No Punishment or Forgiveness:** No retaliation or cooperation is attempted; pure payoff maximization.
- **No Dependence on History:** The strategy is memoryless other than the current stock level, embodying straightforward aggressiveness.

---

### Potential Outcomes & Game Theory Notes

- When all players use this strategy, the stock is likely depleted rapidly, leading to low future payoffs but high immediate returns.
- Against cooperative or mixed strategies, this aggressive approach exploits the resource by harvesting the maximum allowed fraction, gaining higher payoffs per round.
- The growth function cannot offset the stock depletion caused by many defectors, so the resource will not sustain long-term exploitation by multiple aggressors.
- No attempts at tacit collusion or restraint—purely self-interested aggressive harvesting.

---

**Summary**:  
**Always defect (consume stock/n) whenever stock is available, regardless of past actions or remaining rounds. When stock is zero, action choice is arbitrary. The strategy maximizes individual immediate returns and embodies an aggressive resource exploitation mindset.**
'''

description_AGGRESSIVE_77 = '''
Below is a detailed design of an **Aggressive Strategy** for the specified Common Pool Resource Game. The strategy emphasizes defection to maximize short-term payoffs and applies conditional defection to punish cooperators only optionally, thereby sustaining aggression throughout the game.

---

## Overview of the Aggressive Strategy

- **Core mindset:** Maximize immediate payoff by defecting (D) whenever possible, exploiting commons at the highest rate.
- **No unconditional cooperation:** Never cooperate just out of goodwill.
- **Conditional retaliation:** If significant cooperation is detected from others, optionally cooperate minimally at key moments to exploit future gains but primarily focus on maximizing own returns.
- **Edge cases:**
  - **First round:** Defect aggressively (no prior info).
  - **Intermediate rounds:** Continue defecting unconditionally or defect unless strong signals to cooperate appear (which are rare given strategy assumptions).
  - **Last round:** Defect unconditionally — no future to punish or be punished.

---

## Rationale

- Defection consumes more stock per player, yielding double payoff per round compared to cooperation with the same stock level.
- Aggressive defectors risk depletion but are willing to accept this as maximizing own payoff (total game payoff sum).
- Reacting by partial cooperation only if it benefits payoff and not to sustain the commons long term.
- No sophisticated contingent cooperation (like Tit-for-Tat) due to aggressive mindset and no assumption of coordination.

---

## Formal Decision Rules for Player i at round t (1 ≤ t ≤ r)

Let:

- \( t \) = current round number
- \( A_j^{(t-1)} \) = action of player j in round \( t-1 \), for \( j \neq i \)
- \( C\_rate \) = fraction of other players cooperating in previous round = number of cooperators / (n-1)
- \( S^{(t)} \) = observed stock at start of round \( t \) (known from previous round outcomes)
- \( \theta \in [0,1] \) = cooperation tolerance threshold (set to zero for maximal aggression or small positive for minimal cooperation)

**Decision Logic:**

1. **If \( t = 1 \) (first round):**  
   Play **D** (defect) unconditionally.

2. **Else if \( t = r \) (last round):**  
   Play **D** unconditionally (no future punishment).

3. **Else (1 < t < r):**  
   - Calculate \( C\_rate \) from previous round actions.
   - If \( C\_rate > \theta \) and cooperating this round gives *higher expected future payoff* (rare in aggressive mindset), *optionally* play **C** once to exploit + punish cooperators.
   - Otherwise, play **D**.

---

## Simplified Aggressive Strategy Pseudocode

```python
def aggressive_strategy(player_index, round_t, total_rounds, n, history, stock, capacity):
    """
    Parameters:
    - player_index: int (1..n)
    - round_t: current round number (1..r)
    - total_rounds: total rounds (r)
    - n: total number of players
    - history: list of dictionaries [{player: action, ...}, ...] of length round_t - 1
    - stock: current stock level S_t at start of round_t
    - capacity: maximum sustainable capacity (unused in decision)

    Returns: "C" or "D"
    """

    # Aggressive strategy parameters
    cooperation_tolerance = 0  # Threshold on how many cooperators tolerated before defecting

    if round_t == 1:
        # No history - no info - defect to maximize payoff
        return "D"

    if round_t == total_rounds:
        # Last round - defect to maximize terminal payoff
        return "D"

    # Analyze last round opponents' actions
    last_round_actions = history[-1]  # dict: player_id -> action

    cooperators = sum(1 for p, a in last_round_actions.items() if p != player_index and a == "C")
    c_rate = cooperators / (n - 1)

    # Aggressive mindset: only cooperate if others mostly cooperate, and cooperation pays off (rare)
    if c_rate > cooperation_tolerance:
        # Optional: defect anyway to exploit their cooperation (max aggression)
        # But a small strategic cooperation once mid-game can stabilize stock for higher future payoffs
        # Since it's an aggressive strategy, mostly stay defecting.
        # Here, we defect regardless.
        return "D"

    # Default action: defect
    return "D"
```

---

## Explanation

- Always defect except possibly in very rare cases where partial cooperation might be exploited — this implementation chooses full defection for clarity and maximum aggression.
- No forgiveness or gradual cooperation to maintain aggressive stance.
- In practice, this aggressive strategy will:

  - Gain high payoffs early rounds by defecting.
  - Deplete the common pool rapidly.
  - Potentially cause the commons to collapse near the end.
  - Maximize own total resource extraction at opponents' expense.

---

## Optional Extension: Slightly Smarter Aggression with One-Time Minimal Cooperation

If the game is long (large r) and stock depletion entirely self-harms payoff, the aggressive player might implement a one-time "punishing cooperation":

- Detect if \( c_rate > 0 \) for multiple rounds consecutively.
- Then cooperate once mid-game to "stabilize" stocks temporarily to secure higher future defect payoffs.
- Resume defecting thereafter.

This adds complexity and is not strictly necessary for an aggressive baseline.

---

# Summary

- **First round:** Defect.
- **Last round:** Defect.
- **Intermediate rounds:** Always defect, irrespective of opponents’ behavior.
- **No cooperation unless forced by some external constraint or planned exploitation (not assumed here).**

This strategy embodies aggressive, non-cooperative behavior aimed at maximizing individual gain in a resource extraction game, aligning perfectly with the aggressive mindset.
'''

description_AGGRESSIVE_78 = '''
Below is a detailed aggressive strategy for the Common Pool Resource Game, designed to maximize short-term individual payoffs and dominate the resource, accepting long-term depletion risks. The strategy explicitly incorporates the game parameters, the evolving stock level, opponent behavior inference, and the game's temporal structure.

---

## Aggressive Strategy Description

### Intuition
- **Goal:** Maximize immediate payoff by defecting as frequently as possible, harvesting a larger share of the stock at each round.
- **Rationale:** Defecting yields twice the per-player consumption compared to cooperating in the same stock state, maximizing individual payoff round-by-round.
- **Trade-off:** This aggressive over-consumption will likely deplete the stock, especially if others also defect. However, since the game forgets past history except stock level, this strategy focuses on exploiting others aggressively, without regard for sustainability.
- **Edge cases:** Employ full defection except in the last round to maximize final payout; in the last round cooperate only if the stock is already zero (no gain defecting) — else defect.

---

### Decision Rules

#### Parameters (known to all players)
- n: number of players
- r: total number of rounds
- capacity: max sustainable stock

#### Observations available before each round t
- t ∈ {1,...,r}: current round
- S_t: current stock level **before** consumption
- History of all players’ actions and payoffs in rounds 1 to t-1

#### Action:
- Decide to **Defect (D)** or **Cooperate (C)**

---

### Strategy Outline

1. **Round 1:**  
   - Defect to maximize initial payoff (stock = capacity, others have no prior info).
2. **Intermediate rounds (2 ≤ t < r):**  
   - Defect **unless** stock is critically low (S_t ≤ threshold_level), where cooperating can possibly extend survival and extract positive payoffs.  
   - Threshold level: stock ≤ (n * (stock / n)) minimum sustainable to defect without hitting zero stock immediately.  
   - Since defection consumes S_t/n, if S_t < n (stock lower than number of players), defecting is impossible without depleting stock to zero.  
   - Therefore, if S_t ≤ n (stock ≤ number of players), **Cooperate** to maintain stock positive.  
   - Else, **Defect** (harvest maximum possible).
3. **Last round (t = r):**  
   - Always **Defect** if stock > 0 to extract maximal final payoff.  
   - If stock == 0, Defect or Cooperate is equal in payoff (zero), but stick to Defect as default.

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, capacity, S_t, history):
    """
    Inputs:
    - t: current round number (1-based)
    - r: total number of rounds
    - n: number of players
    - capacity: max sustainable stock
    - S_t: current stock before consumption this round
    - history: list of tuples [(actions_round1), (actions_round2), ..., (actions_round_t-1)]
               Each element is a list of length n of previous actions ('C' or 'D')

    Output:
    - action: 'C' or 'D'
    """

    # Round 1: Always defect to maximize initial gain
    if t == 1:
        return 'D'

    # Last round: Always defect if stock > 0
    if t == r:
        if S_t > 0:
            return 'D'
        else:
            return 'D'  # stock=0, defect or cooperate yields 0 payoff, defect by default

    # Intermediate rounds
    # If stock is low (≤ n), cooperate to keep some stock alive (conservative move)
    # to avoid immediate stock wipeout, else defect
    if S_t <= n:
        return 'C'

    # Otherwise, defect aggressively
    return 'D'
```

---

### Additional Notes

- **Why cooperate when stock ≤ n?**  
  Defecting requires consuming S_t/n per defector. When stock ≤ n, defecting would consume at least 1 unit per player, likely depleting stock to zero immediately, resulting in zero growth and zero next-round stocks. Cooperating consumes half that per player, slightly preserving stock where possible.

- **Expectations about opponents:**  
  We make no assumptions about them cooperating or defecting. This aggressive strategy does not punish or reward, it simply maximizes immediate payoff whenever it's safe to do so.

- **No forgiveness or tit-for-tat:**  
  The strategy does not react to others’ past moves, because the aggressive mindset focuses solely on immediate gain.

- **Dynamics:**  
  This behavior will likely degrade stock quickly, especially against defectors, but it is consistent with an aggressive, selfish maximization mindset.

---

## Summary

- **Round 1:** Defect  
- **Rounds 2 to r-1:** Defect if stock > n, otherwise cooperate to avoid immediate stock collapse  
- **Round r:** Defect  

This is an aggressive, "take what you can get" strategy that prioritizes maximum short-term payoff and dominates resource consumption whenever possible.
'''

description_AGGRESSIVE_79 = '''
Below is an aggressive strategy tailored for the Common Pool Resource Game. It aims to maximize individual payoffs aggressively, prioritizing short-term gains over sustainability, while adapting to the stock level to avoid complete depletion (which yields zero payoffs). The strategy also exploits opponents who cooperate by defecting, and punishes them minimally only if they seem to be cooperating heavily.

---

## Aggressive Strategy Description

### Core Idea

- **Always defect (D) unless the stock is critically low.**
- If stock drops too low, cooperate temporarily just enough to let the resource partially recover, then resume defecting.
- Use observed stock levels and previous rounds’ actions to determine if minimal cooperation can increase future gains.
- No forgiveness or long-term cooperation assumed; strictly maximize payoff given the state.
- In the last round, defect regardless (no future rounds to consider).

---

### Parameters / Thresholds (tunable)

- **low_stock_threshold** = capacity/ (4 * n)  
  (Meaning: When the stock falls below this threshold, the resource is considered critically low.)

- **critical_stock_threshold** = capacity / (2 * n)  
  (At or above this level, defect is profitable again.)

---

### Decision rules

Let:
- `t` = current round number (1-based)
- `S` = current stock at start of round t
- `r` = total number of rounds
- `history` = all previous rounds data (actions of all players and resulting stocks)

1. **If t == r (last round):**  
   - **Defect** (D) unconditionally to maximize the payoff this round.

2. **Else if S > critical_stock_threshold:**  
   - **Defect** (D) to maximize immediate payoff.

3. **Else if low_stock_threshold < S ≤ critical_stock_threshold:**  
   - **Cooperate** (C) to allow resource recovery.  
   - This is a temporary concession to enable profitable future defecting.

4. **Else (stock S ≤ low_stock_threshold):**  
   - **Cooperate** (C) until stock recovers above critical_stock_threshold.  
   - Repeated cooperation as a "minimal investment" to revive the stock.

---

### Handling Edge Cases

- **Round 1:** Stock is initially at capacity, so stragtegy defects (max exploitation from the start).
- **Last round:** Always defect; no incentive to sustain stock.
- **Repeated low stock:** Strategy cooperates until stock improves enough.
- **If stock unexpectedly goes to zero or near zero:** Cooperate until it recovers.
- **No assumptions about opponents' cooperation — pure stock-level-based.**

---

### Pseudocode

```python
def aggressive_strategy(t, r, S, capacity, n, history):
    # Parameters
    low_stock_threshold = capacity / (4 * n)
    critical_stock_threshold = capacity / (2 * n)

    if t == r:
        # Last round: defect to maximize payoff
        return 'D'

    if S > critical_stock_threshold:
        # Stock healthy enough: defect for max gain
        return 'D'

    if low_stock_threshold < S <= critical_stock_threshold:
        # Stock low but not critical: cooperate to help recovery
        return 'C'

    # Critically low stock: cooperate until recovery
    return 'C'
```

---

### Intuition and Aggressiveness

- The strategy defects whenever resource levels are good enough to yield high payoffs from defecting.
- Only when resource is at risk of depletion does it 'pretend' to cooperate, allowing partial stock recovery.
- No attempts to punish or reward based on individual opponents’ past actions — purely driven by maximizing own payoff via state management.
- Assumes others will not necessarily cooperate; hence it does not rely on cooperation for survival.
- The strategy cycles between aggressive defection and minimal concession to prolong exploitable stock.

---

This meets the requirement for aggression by pushing for maximum payoff in all rounds where it is safe to do so, and only cooperating when necessary to avoid zero payoff due to stock collapse.
'''

description_AGGRESSIVE_80 = '''
Below is a fully aggressive strategy design for the Common Pool Resource Game that aligns with the definition of aggression in a repeated CPR context: prioritize immediate high payoffs (defect) over sustainability or cooperation, attempt to maximize personal extraction even at the cost of depleting the resource and harming future payoffs.

---

## Aggressive Strategy Description

### Core Idea
- **Always defect** (play D) whenever the resource stock permits extraction ≥ 1 share per player, maximizing immediate payoff.
- Only **cooperate (play C) as a forced fallback** when the stock is too low to extract the defect share without causing impossible consumption (i.e., when defecting is no longer feasible).
- **Never restrain consumption for sustainability**; ignore repairing or sustaining the stock.
- In the **last round**, defect aggressively regardless of stock, as no future rounds exist to sustain.
- In **early and middle rounds**, defect to maximize immediate payoff, accelerating resource depletion.
- React quickly to resource collapse by cooperating only if defecting is impossible (stock too low), effectively signaling no more gain from defecting.

### Rationale
- Defection yields a per-round payoff of S/n which is always greater than cooperating payoff S/(2n).
- By always defecting, this strategy exploits the resource quickly.
- Because repeated players might try to cooperate, this aggressive strategy exploits them.
- Cooperation is chosen only when defecting is infeasible (stock depleted or nearly depleted), preserving consistency with aggressive mindset (maximize gain whenever possible).
- No forgiveness, no coordination, no attempts to sustain resource or punish defectors.

---

## Decision Rules

Assuming inputs per round:
- Current round number t (1 ≤ t ≤ r)
- Current stock level S_t
- Number of players n
- Capacity (for reference)
- History of all players’ past actions and payoffs (observable)

---

### Pseudocode

```
function aggressive_strategy(t, r, S_t, n, capacity):

    # Calculate consumption amounts for actions at current stock
    consume_C = S_t / (2 * n)   # Cooperate consumption per player
    consume_D = S_t / n         # Defect consumption per player

    # Edge case: Last round - defect to extract maximum payoff as no future state matters
    if t == r:
        return D

    # If defect consumption is feasible (stock sufficient to extract defect share without going negative)
    # (Note: Since consumption is from current stock, always feasible except when stock near zero)
    if consume_D > 0 and consume_D <= S_t:
        # Defect to maximize immediate payoff
        return D
    else:
        # Stock too low for defecting share, fallback to cooperate to extract minimal amount
        # Helps squeeze last bit of payoff before zero stock
        if consume_C > 0 and consume_C <= S_t:
            return C
        else:
            # If even cooperating is impossible (stock approximately zero), choose cooperate anyway (consumes zero)
            # This choice is arbitrary at zero stock, but consistent
            return C
```

---

### Explanation of Logic

- The strategy assumes defecting whenever defecting extraction is feasible (>0 and ≤ current stock), to maximize immediate payoff.
- If defecting is impossible (e.g., stock close to zero), it chooses cooperating if feasible to extract whatever small payoff remains.
- On last round, just defect for maximum immediate gain, ignoring sustainability.
- No consideration given to opponents’ past actions, no retaliation, forgiveness, or coordination.
- This behavior is fully "aggressive": attempt to maximize per-round extraction by defecting as often as allowed, until the resource is exhausted.

---

## Summary

| Round              | Stock Condition               | Action      | Reasoning                                  |
|--------------------|------------------------------|-------------|--------------------------------------------|
| t < r (any round except last) | Defect consumption feasible     | Defect (D)  | Maximize immediate payoff aggressively    |
| t < r              | Defect consumption NOT feasible, cooperate consumption feasible | Cooperate (C) | Fallback to minimal extraction when defect impossible |
| t = r (last round) | Any stock                    | Defect (D)  | Extract maximal payoff in final round      |

This strategy prioritizes immediate extraction payoffs, accelerates resource depletion, expects no cooperation from others, and reflects a purely aggressive stance under the game specification.

---

If you want, I can also provide a detailed example walk-through for a sample parameter set.
'''

description_AGGRESSIVE_81 = '''
Here is an **aggressive strategy** for the repeated common pool resource game described, designed to maximize immediate individual payoffs through defection while carefully exploiting the dynamics of the stock to avoid rapid depletion when strategically beneficial in later rounds.

---

### Strategy Overview

The strategy aggressively defects by default (consuming a larger share), thereby maximizing immediate payoffs at the cost of common stock depletion. However, it:

- **Exploits the replenishment dynamic** to extend the game’s exploitable resource over multiple rounds.
- **Defects initially to gain the highest payoff immediately.**
- **Adapts near the end to increase payoffs by switching to cooperation only if the resource is dangerously low, preserving some stock to have at least one more round of reasonably high payoff.**
- **Never cooperates first except when forced by game constraints (e.g. zero stock), so no initial sacrifice.**
- **Responds to observed opponents' defection by continuing defection, never cooperating with defectors (no forgiveness).**

---

### Detailed Decision Rules

Let:

- \( S_t \) = stock at the start of round \( t \), initially \( S_1 = \text{capacity} \).
- \( r \) = total number of rounds.
- \( t \in \{1, 2, ..., r\} \).

Let \( \text{Actions}_{-i,t-1} \) be the vector of opponents’ actions at round \( t-1 \) (empty for \( t=1 \)).

---

#### 1. First round (t = 1):

- **Action:** Defect (D).

**Rationale:** Maximize immediate payoff since no previous history. There is no incentive to cooperate here.

---

#### 2. Intermediate rounds (1 < t < r):

- **If \( S_t \leq n \) (very low stock):**

  - Cooperate (C).

  **Reason:** If the stock is too low to sustain full defection by all players, defecting would drain the resource to zero this round. Choose to cooperate to reduce consumption and allow growth, preserving the stock for future payoffs.

- **Else:**

  - Defect (D).

**Rationale:** When stock allows, aggressively defect to maximize immediate payoff.

---

#### 3. Last round (t = r):

- **Action:** Defect (D), unless \( S_r \leq 0 \).

- If no stock left, cooperate (forced to C since payoff from stock is zero anyway).

**Rationale:** At the last round, no future stock considerations, so maximize immediate payoff.

---

#### 4. Response to opponents' history (optional feedback):

- Ignore opponents' actions for decision: Always defect if stock allows; cooperate only if stock is too low.

**Rationale:** Aggressive mindset avoids rewarding cooperation; defect regardless of opponent behavior to maximize short-term payoff.

---

### Summary Table

| Round Status  | Stock Condition          | Action |
|---------------|-------------------------|--------|
| First round   | Any                     | Defect |
| Intermediate  | \( S_t \leq n \)        | Cooperate |
| Intermediate  | \( S_t > n \)           | Defect |
| Final round   | \( S_r > 0 \)           | Defect |
| Final round   | \( S_r \leq 0 \)        | Cooperate (no stock) |

---

### Why \( S_t \leq n \) triggers cooperation

- Defecting consumes \( S_t / n \) per player.
- When stock \( \leq n \), if all defect, total consumption = \( n \times (S_t / n) = S_t \) → zero stock after consumption → zero growth.
- To avoid zero stock, cooperate to reduce consumption, allowing positive growth and sustaining some stock for further rounds.
- Cooperation uses half the defecting consumption, preserving resource.

---

### Pseudocode

```python
def aggressive_strategy(t, S_t, r, n):
    """
    Parameters:
    - t: current round (1-based)
    - S_t: current stock at round start
    - r: total number of rounds
    - n: number of players
    
    Returns:
    - action: "C" or "D"
    """
    if t == 1:
        # First round: defect aggressively
        return "D"
    
    elif t == r:
        # Last round: defect if stock remains, else cooperate (no gain anyway)
        if S_t > 0:
            return "D"
        else:
            return "C"
    
    else:
        # Intermediate rounds
        if S_t <= n:
            # Stock too low for defecting, cooperate to preserve stock
            return "C"
        else:
            # Default aggressive defection
            return "D"
```

---

### Additional notes

- This strategy is **greedy**, prioritizing immediate high payoff via defection.
- It is **reactive only to stock**, not opponents' previous actions, embodying an aggressive non-cooperative mindset.
- It leverages the **stock replenishment dynamics** by defecting when the resource can sustain it.
- It switches to cooperation only as a **forced measure** to avoid total depletion too early, which would end the game with zero payoff.
- Such behavior likely pressures cooperative opponents while maximizing payoff unless everyone defects and ruins the pool immediately.

---

If you want me to provide a more complex or adaptive aggressive strategy using observed opponent behavior, just ask!
'''

description_AGGRESSIVE_82 = '''
Here is an aggressive strategy designed specifically for the Common Pool Resource Game based on the given parameters, rules, and assumptions. The strategy pursues high individual payoffs through persistent defection, exploiting cooperators, and maximizing short-term gains while exploiting the limited cooperative environment.

---

## Aggressive Strategy: "Persistent Defect with Opportunistic Cooperation"

### Intuition and High-Level Description

- This strategy prioritizes **maximizing individual payoff each round by defecting whenever possible**, i.e., consuming the larger share (stock/n).
- It exploits cooperative players who consume less, gaining higher payoff.
- It is **aggressive** as it does not attempt to sustain the common pool to benefit future rounds via cooperation.
- It aims to maximize short-term gains, even if the stock collapses near the end.
- However, it **cooperates in the last round only if stock is already very low** to salvage some minimal payoff; otherwise defects consistently.
- It also opportunistically defects or cooperates depending on whether cooperation would meaningfully prolong the game or increase payoffs in future rounds.
- It does **not punish or condition on opponent history** as defecting maximizes immediate payoff regardless.

---

### Formal Description and Decision Rules

Let:

- \( t \in \{1, ..., r\} \) denote the current round
- \( S_t \) denote the current stock at start of round \( t \)
- \( \text{capacity} \) is the maximum stock capacity
- \( n \) is the number of players (including ourselves)
- \( \text{threshold} = 0.2 \times \text{capacity} \) (20% of capacity, a low stock threshold)

---

### Round-by-round decision rules

1. **First round (t = 1):**  
   - **Action:** Defect (D)  
   - **Reason:** No previous info about others, defect to gain maximum payoff.

2. **Rounds 2 to r - 1 (intermediate rounds):**

   - **If stock \( S_t \) ≥ threshold (20% of capacity):**  
     - Defect (D)  
     - Rationale: Stock is sufficient; defecting gains more payoff this round and accelerates depletion, which is aggressive and exploits cooperators.

   - **If stock \( S_t \) < threshold:**  
     - Still Defect (D)  
     - Rationale: Stock already low, no incentive to cooperate, take the last big gains.

3. **Last round (t = r):**

   - **If stock \( S_t \) ≥ threshold:**  
     - Defect (D) as usual for maximum last round payoff.

   - **If stock \( S_t \) < threshold:**  
     - Cooperate (C)  
     - Rationale: Stock nearly depleted; cooperating takes a smaller share, but prevents entering zero stock (which provides zero payoff next round irrelevant here), so salvages some payoff.

---

### Summary of Strategy Logic

| Round | Stock Condition        | Action      | Reason                                                         |
|-------|-----------------------|-------------|----------------------------------------------------------------|
| 1     | Any                   | Defect (D)  | No info yet, maximize immediate payoff                         |
| 2..r-1| \(S_t \ge\) threshold | Defect (D)  | Stock sufficient, maximize payoff even at stock depletion risk|
| 2..r-1| \(S_t <\) threshold   | Defect (D)  | Stock low, no incentive to cooperate, take last big payoffs   |
| r     | \(S_t \ge\) threshold | Defect (D)  | Maximize last payoff                                           |
| r     | \(S_t <\) threshold   | Cooperate(C)| Save what’s left for some payoff instead of zero payoff       |

---

### Handling Edge Cases

- **If stock hits zero before last round:**  
  - The game state no longer provides any payoff due to zero stock.  
  - Continue Defect (D) for consistency; no payoff but maintains aggressive playstyle.

- **If capacity barely ≥ 2n:**  
  - Threshold scales accordingly; still aggressively defects.

- **If all players defect every round:**  
  - This strategy profits as much as anyone else; no regret.

- **If all cooperate every round:**  
  - This strategy still defects, exploiting the cooperators for maximum payoff.

---

### Pseudocode

```python
def aggressive_strategy(t, r, S_t, capacity, n):
    threshold = 0.2 * capacity

    # First round: always defect
    if t == 1:
        return 'D'

    # Last round decision
    if t == r:
        if S_t < threshold:
            return 'C'  # small cooperation to salvage payoff
        else:
            return 'D'  # defect for max last round payoff

    # Intermediate rounds
    if S_t >= threshold:
        return 'D'  # defect aggressively
    else:
        return 'D'  # defect even if stock is low
```

---

### Why Is This Strategy Aggressive?

- It **never cooperates early** or mid-game, always extracting maximum resources.
- It is **unforgiving**: does not adjust or punish others, simply defects persistently.
- It **exploits cooperative players** by taking the larger share every round.
- It **does not attempt to sustain** the common pool stock, leading to rapid depletion.
- The only cooperation is a tactical concession in the **very last round when stock is nearly gone**—an act to salvage payoff rather than altruism.

---

If you want, I can help further by discussing possible counter-strategies or ways to adapt this aggressive approach.
'''

description_AGGRESSIVE_83 = '''
**Aggressive Strategy for the Common Pool Resource Game**

---

### Strategy Overview

This strategy is designed to maximize short-term payoffs aggressively by defecting (D) as often as possible, exploiting the common pool resource to maximize individual gains while managing the risk of stock depletion and retaliation. The strategy employs a mostly defecting stance, but with minimal cooperation to allow partial stock replenishment where beneficial, and to avoid rapid collapse before the final rounds.

---

### Key Considerations

- **Defecting (D)** yields double the immediate payoff of cooperating (C) when stock is at full capacity.
- Continuous full defection risks stock collapse to zero, ending future payoffs.
- Some cooperation can slow stock depletion, extending the resource's life to later rounds.
- In the **final round**, stock preservation is irrelevant; defect maximally to harvest max payoff.
- The player has **perfect information** on all past actions and stock levels.
- No trust or explicit coordination exists; opponents may defect unpredictably.

---

### High-Level Intuition

- **Early rounds:** Defect aggressively to extract high payoffs, but occasionally cooperate if stock is dangerously low to prevent collapse.
- **Mid-game:** Continue mostly defecting but monitor stock level; cooperate if stock falls below critical threshold.
- **Final round:** Defect unconditionally to maximize last-round payoff.

---

### Parameters (Tunable)

- `critical_stock_threshold = capacity / (2 * n)`  
  (If after consumption the stock is below this, cooperate to allow some replenishment)
- `last_round = r`

---

### Decision Rules

At round t with current stock S:

1. **If t == last_round:**  
   - **Defect (D)** unconditionally — maximize last round payoff.

2. **Else if S < critical_stock_threshold:**  
   - **Cooperate (C)** — slow down stock collapse by taking less stock this round.

3. **Else:**  
   - **Defect (D)** — maximize immediate payoff.

---

### Why This is Aggressive?

- The strategy seeks maximum immediate gain (D) whenever safely possible.
- It only cooperates reactively to prevent resource collapse, which would eliminate future opportunities.
- It does not try to punish, forgive, or establish cooperation; cooperation is purely instrumental and minimal.
- In the final round, it prioritizes total payoff extraction without regard for resource sustainability.

---

### Pseudocode

```python
def aggressive_strategy(round_t, total_rounds, stock_S, capacity, n):
    critical_stock_threshold = capacity / (2 * n)
    last_round = total_rounds

    if round_t == last_round:
        # Final round: defect to maximize payoff
        return 'D'

    elif stock_S < critical_stock_threshold:
        # Stock too low: cooperate to allow replenishment
        return 'C'

    else:
        # Otherwise, defect
        return 'D'
```

---

### Edge Cases Handling

- **Round 1:**  
  Stock is at capacity (≥ 2n), so defect.

- **Rounds with very low stock:**  
  Cooperate to avoid zero stock and extinction of future gains.

- **High stock rounds:**  
  Defect consistently to max out per-round payoff.

- **Last round:**  
  Defect regardless of stock to maximize final payoff.

---

### Summary

| Round Condition                          | Action (Aggressive Strategy)                         |
|----------------------------------------|-----------------------------------------------------|
| Final round (t = r)                     | Defect (D)                                          |
| Stock below threshold (S < capacity/(2n)) and not final round | Cooperate (C) (to sustain stock for future)        |
| Otherwise (high stock, not last round) | Defect (D)                                          |

This approach aggressively exploits the resource, manages stock only to prevent premature stock collapse, and maximizes final round extraction. It aligns with an aggressive mindset focused on high short-term payoff without attempts at sustained cooperation or retaliation.
'''

description_AGGRESSIVE_84 = '''
Below is a detailed **Aggressive Strategy** tailored to the given Common Pool Resource Game:

---

### Aggressive Strategy Description

**Core Principle:**  
Maximize individual payoff every round by defecting when it is profitable to do so, even at the risk of rapid depletion and long-term stock collapse. Only cooperate if forced by the game constraints or strategic considerations in the final round.

---

### Decision Rules Summary

| Round              | Action Decision                                                                                       |
|--------------------|-----------------------------------------------------------------------------------------------------|
| **First round**    | Defect (D) unconditionally to gain immediate high payoff and test opponents' initial behavior.      |
| **Intermediate rounds (2 to r-1)** | Continue to Defect (D) unless the stock is so low that defecting would yield zero payoff. <br>If stock is critically low (S < n), cooperating still yields some payoff, defecting yields zero — cooperate in this case to get something instead of nothing. |
| **Last round (r)** | Defect (D) unconditionally regardless of stock to maximize terminal extraction (since no future rounds). |

---

### Rationale for Aggressiveness

- **Defect (D)** yields double the immediate payoff compared to cooperate (C) when stock is sufficient.
- Aggressive players prioritize immediate payoffs over sustainability.
- Even when stock depletion causes long-term harm, the aggressive strategy exploits others early and secures maximum end payoffs.
- Cooperation is only employed pragmatically to avoid total payoff loss in extreme cases.
- No tacit cooperation or forgiveness is given, as the player assumes opponents act independently.

---

### Handling Edge Cases

- **Stock depletion = 0 or near zero:**  
  When the stock is depleted below the threshold needed to receive payoff from defecting (S < n), defecting yields no payoff. If cooperating still yields some payoff (since cooperating requires less consumption), switch to cooperate to get positive payoff instead of zero payoff from defect.

- **Last round:**  
  Disregard stock sustainability completely and defect for maximum extraction.

- **If all others defect aggressively leading to rapid collapse:**  
  No adjustment — stay defect. The philosophy is to get as much as possible while the resource lasts.

---

### Pseudocode

```python
# Inputs per round t:
#   S: current stock before consumption
#   t: current round (1-based)
#   r: total rounds
#   n: number of players

function aggressive_strategy(S, t, r, n):

    # Threshold below which defecting yields zero payoff:
    # Because defect consumes S/n, if S < n, payoff for defect = S/n < 1 (still >0 if positive)
    # But if S=0, defect payoff=0
    # Careful handling when stock is very low.

    if t == 1:
        # First round: defect unconditionally
        return 'D'

    elif t == r:
        # Last round: defect unconditionally to maximize extraction
        return 'D'

    else:
        # Intermediate rounds
        # Calculate potential defect payoff: π_D = S/n
        # Calculate potential cooperate payoff: π_C = S/(2n)

        payoff_defect = S / n
        payoff_cooperate = S / (2 * n)

        if payoff_defect > 0:
            # Defect yields positive payoff, be aggressive and defect
            return 'D'
        else:
            # If defect yields zero or near zero, cooperate to get some payoff if possible
            if payoff_cooperate > 0:
                return 'C'
            else:
                # Stock exhausted, no payoff from either action
                # Default to defect (no loss) or cooperate (no gain) — pick defect to assert aggressiveness
                return 'D'
```

---

### Summary

- **Always defect** except when defecting yields no payoff while cooperating still can yield positive payoff.
- **Never forgive or cooperate** proactively; do not attempt cooperation to preserve stock.
- **Exploit maximal short-term gains** regardless of long-term consequences.
- **Last round** defect for final extraction.

This aggressive strategy exploits the structure of payoffs and stock regeneration to maximize *individual* payoff under uncertainty of opponent behavior.
'''

description_AGGRESSIVE_85 = '''
**Aggressive Strategy for the Common Pool Resource Game**

---

### Overview

The goal of this aggressive strategy is to maximize individual payoffs by prioritizing defection (extracting more from the common pool) while exploiting others' cooperation when available. The strategy acknowledges the logic of dynamic stock depletion but chooses to aggressively defect early and exploit cooperation throughout, only cooperating under very limited circumstances to preserve a minimum viable resource level.

---

### Intuition

- **Defect as often as possible** to maximize immediate payoffs (consume S/n vs. S/(2n) for Cooperate).
- **Exploit cooperation** by others: defecting when others cooperate yields higher payoff per round.
- **Use cooperation sparingly** to avoid complete depletion and ensure some resource regeneration.
- **Do not cooperate in the last round**, since there is no future incentive.
- **Condition cooperation only if stock dangerously low**, to avoid extinction that yields zero payoffs going forward.
- **Exploit perfect information** by punishing any cooperation from others by defecting, extracting maximum benefits.
- **No attempts to coordinate or share norms**, since no communication or enforcement mechanism exists.

---

### Detailed Decision Rules

**State variables:**

- `S_t`: stock at the start of round t
- `r`: total number of rounds
- History of all players' past actions until round t-1.

---

### Step 1: Initialization (Round 1)

- Defect unconditionally.
- Rationale: Maximize immediate gain since no history exists.

---

### Step 2: Subsequent rounds (2 ≤ t < r)

At the beginning of round t:

1. **Check stock level `S_t`:**

   - If `S_t` < `threshold_low` (e.g., 2n, minimum sustainable stock to avoid ruin):
     - Cooperate (consume less = S_t/(2n)) to preserve resource and allow regeneration.
     - Reason: Without cooperation, resource will hit zero and yield no payoffs future rounds.
   - Else: proceed to next step.

2. **Evaluate others' previous actions in round t-1:**

   - If any player cooperated in previous round:
     - Defect to exploit cooperate mates (free ride).
   - Else (all defected in t-1):
     - Defect (continue aggressive extraction).

---

### Step 3: Last round (t = r)

- Defect unconditionally.
- No incentive to preserve resource beyond last round.

---

### Parameters

- `threshold_low = 2 * n` (minimum stock to consider stock sustainable; from game spec capacity ≥ 2n)
- This can be tuned, but should aim to preserve minimal viable stock.

---

### Pseudocode

```python
def aggressive_strategy(t, S_t, r, n, history):
    # Input:
    # t: current round (1-based)
    # S_t: current stock at start of round t
    # r: total rounds
    # n: number of players
    # history: list of length t-1, each element a dict {player_i: 'C' or 'D'}
    
    threshold_low = 2 * n  # minimum sustainable stock (example threshold)
    
    # Last round: Always defect
    if t == r:
        return 'D'
    
    # Round 1: No history, defect unconditionally
    if t == 1:
        return 'D'
    
    # If stock very low, cooperate to preserve resource
    if S_t < threshold_low:
        return 'C'
    
    # Check if any player cooperated in previous round
    previous_round_actions = history[-1]  # dictionary of players' moves round t-1
    if any(action == 'C' for action in previous_round_actions.values()):
        # Exploit cooperative players by defecting
        return 'D'
    else:
        # All defected last round, no cooperation to exploit, continue defecting
        return 'D'
```

---

### Summary

| Round Condition        | Stock Condition          | Decision |
|-----------------------|-------------------------|----------|
| Round 1               | Any                     | Defect   |
| Round r (last round)  | Any                     | Defect   |
| Intermediate rounds   | Stock < threshold_low   | Cooperate|
| Intermediate rounds   | Stock ≥ threshold_low & Any coop last round | Defect   |
| Intermediate rounds   | Stock ≥ threshold_low & All defect last round| Defect   |

---

### Why This is Aggressive?

- Defaulting to defect nearly always maximizes immediate payoff.
- Exploits cooperative opponents by defecting when others cooperate.
- Only reluctantly cooperates to prevent zero stock that eliminates future payoffs.
- Never trusts others enough to cooperate first or punish by cooperating.
- Ends with a defection in the last round to capture the maximum payoff without concern for future rounds.

---

This strategy aligns with an aggressive mindset: maximizing short-term extraction, exploiting cooperators, and only conserving when extinction threatens payoff. It neither seeks nor expects cooperation but adapts cooperation minimally as a survival measure.
'''

description_AGGRESSIVE_86 = '''
**Aggressive Strategy for the Common Pool Resource Game**

---

### Intuition and Motivation

An aggressive player seeks to maximize their own total payoff (sum of per-round payoffs), prioritizing immediate and continued exploitation of the resource over sustainability or cooperation. This means:

- Prefer defection (D) to get a high payoff in each round,
- Exploit opportunities to defect even if it depletes the stock,
- Avoid unilaterally cooperating unless forced by depletion,
- Use knowledge from previous rounds to defect whenever it is still beneficial,
- Recognize that in the last round(s), there is no incentive to conserve,
- Accept or even welcome stock depletion as it benefits defectors in the short term.

---

### Key Features of the Aggressive Strategy

1. **Default to Defect (D)** in almost every round to claim the highest immediate share: consume `S/n`.
2. **Cooperate (C) only if stock is so low that defecting would consume more than is available, risking zero payoff next round.** In practice, if the remaining stock is very low and likely to drop to zero if defected upon, cooperate just enough to prolong resource existence for current benefit.
3. **Always defect in the last round** since future stock value no longer matters.
4. **In early rounds, defect regardless of others to maximize immediate payoff and to push stock towards depletion, lowering future payoffs for cooperative opponents.**

---

### Notation for the Pseudocode

- `t`: current round (from 1 to r)
- `S_t`: the current common pool stock at the start of round t
- `capacity`: maximum capacity
- `n`: number of players
- `r`: total rounds
- `last_round`: `t == r`
- `threshold`: a heuristic stock level below which cooperation might jump in to avoid immediate collapse (described below)
- `my_action[t]`: this player’s action in round t

---

### Strategy Description with Pseudocode

```python
def aggressive_strategy(t, S_t, n, r, capacity):
    """
    Decide action ('C' or 'D') in round t with observed stock S_t.
    """

    # Constants
    defect_consumption = S_t / n      # payoff if defect
    coop_consumption = S_t / (2 * n)  # payoff if cooperate

    # Threshold calculation:
    # If total defect consumption (n * S_t/n = S_t) depletes all stock,
    # but all cooperate consumption (n * S_t/(2n) = S_t / 2) leaves half the stock
    # The stock growth depends on leftover stock; if very low, cooperation prevents collapse.
    #
    # Heuristic: cooperate only if defecting will make stock <= critical stock for growth.
    # Critical stock for growth to be positive is > 0.
    # But if expected consumption is S_t, stock becomes zero (no growth).
    #
    # Since others’ moves unknown, assume worst case others defect.
    # Total consumption if all defect: S_t
    # Stock after consumption = S_t - S_t = 0 -> collapsing.
    # So, if stock is low, defecting eliminates resource for next round and payoffs go 0.
    #
    # Since player cannot predict others precisely, apply threshold at low stocks.
    
    critical_stock = capacity * 0.25  # 25% capacity chosen empirically as threshold

    # In last round: defect always (no future penalty)
    if t == r:
        return 'D'

    # If stock is very low (< critical_stock), check if defecting depletes stock fully
    if S_t < critical_stock:
        # Defecting consumes S_t / n, total if all defect S_t -> stock zero
        # Decide to cooperate to conserve stock for current payoff
        return 'C'

    # Otherwise, aggressively defect to maximize payoff and pressure stock
    return 'D'
```

---

### Explanation

- **Round 1 to r-1:** Attempt to defect every time to maximize immediate gain.
- **When stock is very low (< 25% of capacity), cooperate to slightly reduce depletion, keeping some stock for a few more rounds to earn some payoff rather than zero payoff from full depletion.**
- **Round r:** Unconditionally defect since there is no future payoff to preserve, so exploit maximally.

---

### Strategy Summary

| Round Condition    | Stock Level Condition                     | Action  | Rationale                               |
|--------------------|-----------------------------------------|---------|----------------------------------------|
| Last round (t == r)| Any                                     | Defect  | No incentive to conserve stock         |
| Early/Mid rounds    | Stock < 25% capacity                     | Cooperate | Prevent immediate collapse, still gain something |
| Early/Mid rounds    | Stock ≥ 25% capacity                     | Defect  | Maximize immediate payoff aggressively |

---

### Additional Notes

- The threshold `25% capacity` is heuristic: it balances aggression with avoiding immediate 0 payoffs from depletion.
- The strategy assumes worst-case other player behaviour (mostly defecting) to avoid being caught cooperating unilaterally.
- It does **not attempt to punish** or reward others, purely selfish and aggressive.
- The strategy accepts eventual depletion of the resource if opponents defect, but tries to extend payoff accumulation with minimal cooperation when resource is critically low.

---

This aggressive strategy aligns with a selfish, aggressive mindset: **maximize my own immediate and cumulative payoff by defecting whenever possible, only back off slightly near resource exhaustion to salvage some payoff, and exploit fully at the last round.**
'''

description_AGGRESSIVE_87 = '''
Here is an **aggressive strategy** for the Common Pool Resource Game that explicitly prioritizes maximizing individual payoff by defecting whenever beneficial, and punishes cooperation by others only when it serves self-interest. It takes advantage of the payoff asymmetry (defectors always earn twice as much as cooperators per round for the same stock level, if stock remains sufficient), and ignores attempts at mutual cooperation. The strategy manipulates the stock dynamics to push for short-term gain, even at the risk of depletion — a truly aggressive stance.

---

## Strategy Description: "Aggressive Defector with Opportunistic Exploit"

### Core idea:
- **Always defect by default (consume large share).**
- **Exploit cooperators when advantageous — if others cooperate, defect to maximize payoff.**
- **Stop cooperating early if stock falls too low — avoid wasted cooperation when resource is scarce.**
- **In last round, defect no matter what to maximize immediate payoff.**
- **If stock approaches depletion, continue defecting (to maximize final round payoff) since recovery is unlikely to benefit cooperators.**

---

### Detailed decision rules

Let:  
- \( t \) = current round (1 to \( r \))  
- \( S \) = current stock at start of round \( t \)  
- \( n \) = number of players  
- \( A_{-i}^{t-1} \) = observed actions of other players in previous round (if \( t > 1 \))  
- \( \text{threshold} = \frac{\text{capacity}}{4} \) (quarter of capacity, adjustable parameter)

---

### Round 1 (first round):

- No history is available.
- **Action:** Defect (D) to maximize first-round gain unconditionally.

---

### Intermediate rounds (2 ≤ t < r):

- Observe previous round's actions of all other players.
- Compute fraction of cooperators among others:  
  \[
  f_C = \frac{\text{number of cooperators among others}}{n-1}
  \]

- Decide based on stock and opponent behavior:  

  1. If \( S < \text{threshold} \):  
     - Resource is low, likely near depletion.  
     - **Action:** Defect (D) to extract maximum payoff before stock runs out.

  2. Else if \( f_C > 0.5 \) (more than half others cooperated):  
     - Exploit cooperators by defecting for maximal payoff.  
     - **Action:** Defect (D).

  3. Else if \( f_C \leq 0.5 \) (others mostly defected or split):  
     - No incentive to cooperate; defect to maximize payoff.  
     - **Action:** Defect (D).

- *Note*: This means cooperation is never played except possibly when close to depletion (see next point).

---

### Last round \( t = r \):

- No consideration for future rounds, only immediate payoff matters.  
- **Action:** Defect (D) unconditionally.

---

### Summary:

| Condition                    | Action  |
|-----------------------------|---------|
| Round 1                     | D       |
| Round \( t < r \), \( S < \) threshold | D       |
| Round \( t < r \), majority opponents cooperate | D       |
| Round \( t < r \), opponents mostly defect | D       |
| Round \( t = r \)           | D       |

---

### Rationale:

- Defection gives twice the per-round payoff compared to cooperation for same stock.
- By always defecting, the strategy maximizes short-term payoff.
- It exploits cooperating opponents by defecting when others cooperate.
- When stock is low, continuing to defect is preferred to capture final payoffs before depletion.
- Cooperation is never offered because it has strictly less payoff per round and risks enabling others to exploit you.
- The strategy embraces resource depletion risk if it means more immediate gain.

---

## Pseudocode

```python
def aggressive_strategy(t, r, S, capacity, n, actions_prev_round):
    threshold = capacity / 4

    if t == 1:
        # First round: no history, defect
        return 'D'

    if t == r:
        # Last round: no future, defect
        return 'D'

    # Calculate fraction of cooperating opponents in previous round
    cooperators = sum(1 for a in actions_prev_round if a == 'C')
    f_C = cooperators / (n - 1) if n > 1 else 0

    if S < threshold:
        # Resource is low; defect to maximize immediate payoff
        return 'D'

    if f_C > 0.5:
        # Opponents mostly cooperate, exploit by defecting
        return 'D'

    # Opponents mostly defect or split, defect anyway
    return 'D'
```

---

This aggressive strategy will not sustain the common pool resource, but that aligns perfectly with the aggressive mindset—maximize personal gain regardless of collective long-term consequences. It will outperform cooperators who restrict their consumption, especially early on, and exploit their cooperation fully.

---

If you want, I can also suggest a variant that occasionally cooperates to appear less predictable, but purely aggressive behavior is best captured by always defecting under the above conditions.
'''

description_AGGRESSIVE_88 = '''
Below is an **aggressive strategy** tailored for the described Common Pool Resource Game. Its goal is to maximize individual payoff by prioritizing immediate gains, exploiting cooperative players when possible, and pushing the depletion of the common resource especially when near the end of the game, even at the risk of stock collapse.

---

## Aggressive Strategy Description

### Intuition:
- **Always defect (D) initially**: Grab maximum payoff early.
- **Punish cooperators by defecting aggressively**: Never allow cooperators to exploit the resource beneficially by meekly cooperating.
- **Drive resource exploitation over time** to maximize cumulative payoff, especially near the game end.
- **Exploit the last rounds fully since there's no future cost**.
- Adapt slightly depending on the resource dynamics but always with a defecting bias.

---

## Components of the Strategy

### 1. First Round (t=1):
- **Action**: Defect (D)
- **Rationale**: No history. Maximize payoff immediately.

### 2. Middle rounds (2 ≤ t < r):
- **Observe previous round actions**:
  - If **all opponents cooperated last round**, defect to exploit their cooperation, gaining a larger payoff.
  - If **some defected last round**, defect to avoid being exploited and get maximum individual payoff.
- **Never cooperate**, as cooperating is dominated by defecting (higher individual payoff and aligns with aggressive mindset).
- **Rationale**: Punish cooperation by defecting, do not allow others to get an advantage by cooperating.

### 3. Last round (t = r):
- **Action**: Defect (D)
- **Rationale**: No future consequences, fully exploit remaining stock.

---

## Edge Cases and Considerations

- **If stock is zero or nearly zero** (due to heavy depletion):  
  - Defecting or cooperating yields zero payoff. Still defect to maintain consistent aggressive stance.
- **If only one opponent or multiple defectors previously**:  
  - Continue defecting to maximize payoff regardless of others.
- **If capacity is very large (so resources seem abundant)**:  
  - Always defect, as resource collapse is far off and defecting yields maximum immediate payoff.
  
---

## Pseudocode

```python
def aggressive_strategy(t, r, capacity, stock, history):
    """
    t: current round (1-based)
    r: total rounds
    capacity: max resource capacity
    stock: current stock before players act
    history: list of previous rounds' actions from all players including self, e.g.
        history = [
            ['D','C','D',...],  # round 1 actions
            ['D','D','C',...],  # round 2 actions
            ...
        ]
    
    Returns: 'D' or 'C' for this round
    """
    
    # 1. First round: always defect
    if t == 1:
        return 'D'
    
    # 2. Last round: always defect
    if t == r:
        return 'D'
    
    # 3. In middle rounds:
    # Extract previous round actions (list of length n, including self)
    prev_round = history[-1]
    
    # Count number of cooperators among opponents in previous round
    # Suppose player index is known; if unknown, ignore self in count
    # Without communication, we assume we know our own index i
    # For robustness, assume self is not counted
    
    # Example: if self index = i (0-based):
    # opp_actions = prev_round[:i] + prev_round[i+1:]
    # Since no index given, assume self's last action is at position i in prev_round
    # Here we simply check if all others cooperated or if any defected
    
    # For aggressive strategy, just check:
    if all(action == 'C' for action in prev_round):
        # All cooperated last round -> defect to exploit
        return 'D'
    else:
        # Some defected last round -> defect to not be exploited
        return 'D'
```

---

## Summary

| Round       | Condition                                 | Action         | Reason                                  |
|-------------|-------------------------------------------|----------------|-----------------------------------------|
| 1           | First round                               | Defect (D)     | Maximize immediate payoff                |
| Middle 2..r-1 | Always                                 | Defect (D)     | Exploit cooperators or defend against defectors; never cooperate |
| r (Last)    | Last round                               | Defect (D)     | No future cost, fully exploit remaining stock |

---

## Strategy Characterization

- **Aggressiveness**: Always defect, never yield or cooperate.
- **Exploitation**: Exploits cooperating opponents by defecting.
- **Punishment**: Defects in response to defections, no forgiveness.
- **Stock depletion**: Will drive stock down aggressively if opponents allow it.
- **Rational**: Highest individual payoff with no regard for sustainability or mutual benefit.

This strategy aligns with an aggressive mindset, maximizing individual payoff by exploiting the resource and opponents whenever possible, tolerating or even causing resource depletion.
'''

description_AGGRESSIVE_89 = '''
Below is a fully specified **aggressive strategy** for the Common Pool Resource game described. It is designed to maximize individual payoff by defecting whenever beneficial but includes simple conditional logic to exploit and punish cooperators moderately, balancing short-term gain against stock sustainability across rounds.

---

## Strategy Overview: "Aggressive Defector with Conditional Punishment"

### High-Level Intuition

- **Default Action: Defect (D)** every round to maximize immediate payoff.
- Observe opponents’ previous round actions to detect "soft" cooperators.
- If **all opponents cooperated last round** and the stock is sufficiently high, exploit by defecting to gain more (free-riding), since defecting yields twice the payoff of cooperating in the same stock state.
- If opponents are aggressive (defecting), retaliate by defecting to avoid exploitation.
- Avoid fully depleting the stock early to ensure some payoff in later rounds.
- In the **last round**, defect regardless to maximize final payoff (no future punishment possible).
- In the **first round**, defect since there is no prior history and defecting yields highest immediate payoff.

---

### Detailed Decision Rules

#### Parameters and Variables

- Let:
  - `t` = current round, 1 ≤ t ≤ r
  - `S_t` = current common stock at round t (known before choosing)
  - `actions_{t-1}` = vector of all players’ actions in previous round (empty for t=1)
  - `n` = number of players
  - `r` = total rounds
  - `capacity` = stock capacity

#### Step 1: Initial condition

- If `t == 1` (first round), **choose Defect (D)**.

#### Step 2: Last round behavior

- If `t == r` (last round), **choose Defect (D)** regardless, since no future rounds mean no retaliation or cooperation benefits.

#### Step 3: General rounds (1 < t < r)

- Calculate the number of cooperators in last round, call it `num_C`.
- Evaluate stock level `S_t`.
  
- **If all other players cooperated last round**  
   (i.e. `num_C == n - 1`):  
  - Exploit by defecting this round to get higher immediate payoff.  
  - Rationale: Opponents expect cooperation; defecting nets double payoff.

- **Else if majority defected last round**  
  (e.g., `num_C <= n/2`):  
  - Defect to avoid being exploited.

- **Else if mixed behavior (some cooperators and defectors):**  
  - Defect to maximize short-term payoff as cooperation is unreliable.

- **Additional conditional check on stock**:  
  - If `S_t` is dangerously low (e.g., `S_t < capacity / (2n)` or some small threshold):  
    - Defect anyway to maximize final rounds payoff since stock is likely depleted soon.

---

### Summary of Decision Logic in Pseudocode

```python
def aggressive_strategy(t, r, S_t, actions_prev, n, capacity):
    # t: current round index
    # actions_prev: list of previous round actions of all players (length n), or None if t=1
    # Returns: 'C' or 'D'

    # First round: no history, defect
    if t == 1:
        return 'D'

    # Last round: defect to maximize final payoff
    if t == r:
        return 'D'

    # Count number of cooperators last round excluding self (if needed)
    # Since strategy is symmetric, assume knowledge of all
    num_C = sum(1 for a in actions_prev if a == 'C')

    # If all other players cooperated last round, exploit by defecting
    if num_C == n - 1:
        return 'D'

    # If majority of other players defected last round, defect
    if num_C <= (n / 2):
        return 'D'

    # Else mixed behavior, defect anyway (aggressive)
    return 'D'

    # Optional: could add logic to cooperate if stock very high and cooperators exist,
    # but this strategy prioritizes aggression at all times except first round cooperation signal

```

---

## Justification

- **Always defect** except in impossible initial conditions (first round no history) where defecting is still chosen.
- Exploit cooperating opponents fully when observed.
- Retaliate by defecting against defectors — no reward for cooperation.
- Exploit last round since no future incentives to cooperate.
- This strategy prioritizes short-term gain and aggressive exploitation rather than sustaining the resource or cooperating.
- Stock is expected to deplete over time, but aggressive payoffs before depletion are maximized.
- No cooperation is given to avoid exploitation.
- Simple to implement and aligned with classic "All-Defect" or "Defector" mentality but with explicit exploitation detection.

---

## Notes

- This strategy does **not** attempt to conserve stock or cooperate for mutual benefit.
- It seeks to maximize individual payoffs, accepting the risk that stock will decline rapidly.
- Opponents exploiting cooperation are punished mechanically by defecting in turn.
- Minimal state memory (only last round actions) is needed.
- It requires only publicly observed previous round actions and current stock to operate.
- The aggressive nature risks eventual stock depletion, which fits the "aggressive" mindset specification.

---

If you want, I can also help formalize this into a more detailed algorithm or add stock-level based threshold modifications. But this core is the simplest aggressive defector consistent with the game information and tournament environment.
'''

description_AGGRESSIVE_90 = '''
Here is a detailed **aggressive strategy** tailored for the Common Pool Resource game you described. The goal is to maximize individual payoffs aggressively at the potential cost of the common stock, exploiting cooperative opponents and taking advantage of knowledge about previous rounds.

---

## Strategy Overview

This strategy, **"Dynamic Defector with Opportunistic Cooperation" (DDOC)**, is aggressive chiefly because it prioritizes immediate individual gain by defecting frequently, but it also exploits rare chances to cooperate when foresight or stock conditions favor maximizing future payoffs. It does **not** seek to sustain the resource long-term unless it clearly benefits immediate payoffs.

---

## 1. Decision Rules

Let:
- **t** = current round (1 ≤ t ≤ r)
- **S_t** = stock at the start of round t
- **OppActions_{t-1}** = vector of all observed opponent actions in previous round (empty if t=1)
- **remaining_rounds = r - t + 1**

### Key insights driving the rules

- Defecting (D) yields twice the immediate payoff of cooperating (C) in the same round’s stock level.
- Over-harvesting causes stock depletion and zero replenishment.
- Cooperating preserves stock and allows for growth, useful when you expect many future rounds.
- Since opponents are independent and uncoordinated, expect some to defect.
- Aggression means prioritizing short-term gain and punishing cooperation if it loses to defection.

---

### Rule A: **Round 1 (Initial Round)**

- No history: Defect immediately (D).
- Rationale: No info to trust cooperation; defect to grab highest payoff.
  
```pseudocode
if t == 1:
    action = D
```

---

### Rule B: **Intermediate Rounds (2 to r-1)**

- Compute expected stock dynamics based on observed opponent defections.
- If stock is high **AND** past opponents mostly cooperated, **cooperate opportunistically** to preserve stock for next rounds and secure stable payoffs.
- Else, defect to grab maximum payoff and punish opponents if they cooperated while others defected.
- Specifically:

1. Calculate proportion of opponent defectors in previous round:

   ``` 
   defector_ratio = count(OppActions_{t-1} == D) / (n -1)
   ```

2. If defector_ratio ≤ threshold (e.g., 0.25) **AND** stock is sufficiently large to sustain growth for remaining rounds, cooperate.

3. Otherwise, defect.

- Set threshold so cooperation only happens when few defectors and stock healthy (e.g., stock ≥ 0.6 * capacity).

```pseudocode
else if 1 < t < r:
    defector_ratio = count(OppActions_{t-1} == D) / (n - 1)
    if (defector_ratio ≤ 0.25) and (S_t ≥ 0.6 * capacity):
        action = C
    else:
        action = D
```

---

### Rule C: **Last Round (t = r)**

- Defect unconditionally.
- Rationale: No future rounds to preserve stock for; maximize immediate payoff.

```pseudocode
if t == r:
    action = D
```

---

## 2. Edge Cases Handling

- **If stock is extremely low (S_t ≤ (n × small_epsilon))**: Defection yields minimal payoff; switch to cooperate to avoid immediate zero payoff (minimal concession to preserve any yield).

- In practice:

```pseudocode
small_epsilon = arbitrary small value (e.g., 1.0)
if S_t <= (n * small_epsilon):
    action = C
```

(This may happen rarely due to aggressive depletion.)

---

## 3. Aggressiveness Summary

- Defects in initial round to claim maximum share, assuming no trust.
- Punishes and exploits cooperating opponents by defecting unless very few defectors were detected and stock is abundant.
- Never cooperates in last round; no incentive for future sustainability.
- Cooperates only opportunistically when cooperation may preserve resource for significant short-term payoffs.
- Generally prioritizes immediate personal gain over sustainability or equity.
- Consistently extracts higher payoff per round than cooperating players when defecting.

---

## Full Pseudocode Summary

```pseudocode
function select_action(t, S_t, OppActions_previous, n, r, capacity):

    small_epsilon = 1.0

    if S_t <= n * small_epsilon:
        // Very low stock, minimal to gain by defecting—switch to cooperate
        return C

    if t == 1:
        return D

    if t == r:
        return D

    // Intermediate rounds
    defector_ratio = count(OppActions_previous == D) / (n - 1)

    if (defector_ratio ≤ 0.25) and (S_t >= 0.6 * capacity):
        return C
    else:
        return D
```

---

## Rationale Notes

- The threshold of 0.25 for defector_ratio is moderate: if more than 1/4 opponents defect, punish by defecting.
- The 0.6 * capacity cutoff is a heuristic to only cooperate when stock is relatively healthy and can regrow, ensuring cooperation isn't wasted.
- This strategy balances exploiting cooperators and not being naive to defection.
- Defecting in the first and last rounds guarantees maximum gain when there is no incentive to preserve stock.

---

This strategy is **simple, aggressive, and dynamic**—specifically designed for a tournament setting where opponents act independently and unpredictably. It maximizes immediate payoffs while allowing brief opportunistic cooperation to capitalize on transient cooperation in the environment.
'''

description_AGGRESSIVE_91 = '''
Below is a design for an **aggressive strategy** in the Common Pool Resource Game, aligned with the specification and constraints. The strategy prioritizes maximizing individual payoffs by defecting where beneficial, undermining cooperation to deplete the resource in a controlled way, thereby discouraging sustained cooperation by others.

---

## Strategy Overview

- **Core idea:** Start defecting immediately to maximize short-term payoffs, leveraging others' cooperation when available. Maintain defection to maximize personal gain and to aggressively exploit cooperators. Do not cooperate except possibly in the very last round to "milk" any remaining stock without regard for future sustainability (since the game ends).

- **Aggressiveness rationale:**  
  - Defecting yields double the immediate payoff of cooperating on the same stock.  
  - Cooperative actions slow depletion, but an aggressive player exploits cooperators by defecting and draining the pool.  
  - Punishing defectors or attempting cooperation is risky and reduces individual payoffs—aggressive players do not sacrifice payoff for future stability.  
  - The growth function and stock dynamics mean that defecting quickly reduces the stock, but since holding back reduces own payoff, defecting is better.

---

## Decision Rules

1. **First round (t=1):** Always **Defect (D)**
   - No incentive to cooperate before observing anything; seize maximum payoff immediately.

2. **Intermediate rounds (1 < t < r):**  
   - If any player cooperated in the previous round, continue defecting to exploit them (maximize payoff).
   - If all players defected in the previous round (resource likely depleted or nearly so), continue defecting as cooperation yields no advantage.
   - **Always defect** regardless of history.
   - Rationale: Aggression means exploiting cooperators and pushing the resource towards depletion faster than cooperative players.

3. **Last round (t = r):**  
   - Defect to gain maximum payoff from the current stock without concern for future rounds.

---

## Handling Edge Cases

- **Full defection by all players:** Stock will deplete to zero quickly. Strategy is consistent; keep defecting to maximize the last possible payoff. No incentive to cooperate as the resource will not regenerate.

- **Mixed cooperation and defection by others:** Exploit cooperators by defecting, gaining higher payoffs each round.

- **Surviving low stock:** Even if stock is low, defect to maximize per-round payoff before game ends.

- **No retaliation or forgiveness mechanisms:** Aggressive strategy ignores cooperation attempts by others and does not attempt to enforce norms.

---

## Pseudocode

```python
def aggressive_strategy(round_number, total_rounds, history, n, capacity, current_stock):
    """
    Inputs:
    - round_number: current round (1 to r)
    - total_rounds: total number of rounds r
    - history: list of tuples [(actions_round1), (actions_round2), ...] inclusive of all players
               Each actions_round is list of size n with 'C' or 'D'
    - n: number of players
    - capacity: max stock (not directly used here)
    - current_stock: current common pool stock
    
    Output:
    - 'C' or 'D' action for current round for this player
    """
    
    # Always defect in first round
    if round_number == 1:
        return 'D'
    
    # Check previous round's actions
    prev_actions = history[-1]  # actions of all players last round
    
    # If any player cooperated last round, exploit by defecting
    if 'C' in prev_actions:
        return 'D'
    
    # If all defected last round, continue defecting
    if all(action == 'D' for action in prev_actions):
        return 'D'
    
    # Default fallback (should never reach here)
    return 'D'
```

---

## Summary of Aggressiveness

- **No cooperation** at any point except implicitly in the last round if it would matter (but here still defect).
- **No forgiveness or coordination**, purely self-maximizing.
- **Exploit cooperators** each round by defecting.
- **Drive depletion** aggressively rather than preserving stock for future rounds.

---

This aggressive approach is predictable but maximally selfish, built to maximize individual payoff regardless of opponents’ strategy stability or the long-term resource sustainability.
'''

description_AGGRESSIVE_92 = '''
Here's a detailed aggressive strategy for the described Common Pool Resource Game. It is designed to maximize individual payoffs by prioritizing defection whenever it yields a higher immediate reward, with strategic considerations that exploit the game's growth dynamics and repeated nature.

---

## Aggressive Strategy Description

### Core Mindset
- **Always prioritize individual payoff maximization each round.**
- **Assume other players will act non-cooperatively or unpredictably.**
- **Exploit the common pool greedily but avoid needless self-harm early on.**
- **Gradually escalate defection intensity unless stock collapse is imminent.**
- **Maximize last-round defect payoffs since future consequences vanish after last round.**

---

### Key Observations
- Defecting (D) always yields double the immediate payoff of cooperating (C) given the same stock S:
  - π_D = S/n vs π_C = S/(2n)
- But multiple defectors rapidly deplete the stock.
- Stock regenerates via logistic growth after consumption. Moderate depletion can rebound stock.
- The last round has no future consequence; defect without remorse.
- Early rounds should cautiously defect (or escalate) to keep stock from crashing too fast.

---

### Decision Rules

#### Round 1 (initialization)
- **Action:** Defect (D)
- **Reason:** Maximize first-round gain. No prior info on opponents.

#### Intermediate rounds (2 to r-1)
- Observe:
  - Current stock S_t
  - Number of defectors last round, D_count_{t-1}
- Conditions:
  1. **High stock reserve condition:**
     - If stock is well above the threshold for collapse (S_t > 2 × n)
     - Defect to maximize gain since stock can regrow.
  2. **Moderate depletion warning:**
     - If stock is between 2 × n and n
     - Cooperate this round to prevent stock collapse next round.
  3. **Low stock emergency:**
     - If stock ≤ n
     - Cooperate until stock rebounds (to avoid 0 stock and zero payoffs)
- More concretely:
  - Defect when: S_t > 2 × n
  - Cooperate when: n < S_t ≤ 2 × n
  - Cooperate when: S_t ≤ n (emergency stock recovery)

- Always defect if last round saw many defectors (≥ half players), betting opponents are aggressively depleting.
- If last round everyone defected and stock is too low, switch to cooperate to keep the pool alive (self-interested preservation).

#### Last round (round r)
- **Action:** Defect regardless of stock
- **Reason:** No future consequences, maximize final payoff.

---

### Edge Cases and Notes

- If initial capacity is barely above minimal (capacity = 2n), defecting aggressively will likely collapse stock quickly, so forced cooperation to keep minimal viability.
- If observing persistent opponent defections, accelerate defection response.
- If opponents cooperate continuously, defect every round except those forbidden by the low-stock emergency.
- The threshold values (n and 2n) roughly align with per player consumption magnitudes and known capacity constraints.

---

## Pseudocode

```python
def aggressive_strategy(round_num, total_rounds, current_stock, capacity, n, last_round_history):
    # last_round_history: list of length n, each element in ['C', 'D']
    
    # Always defect on first round
    if round_num == 1:
        return 'D'
    
    # Always defect last round
    if round_num == total_rounds:
        return 'D'
    
    # Count defections last round
    last_defectors = sum(1 for action in last_round_history if action == 'D')
    
    # Thresholds
    threshold_high = 2 * n        # stock above this = safe defect
    threshold_low = n             # stock below or equal = emergency cooperate
    
    # Aggressive aggression modifier:
    # If last round many defectors, push to defect to not fall behind
    if last_defectors >= n / 2:
        # Still check if stock is very low; don't kill pool if hopeless
        if current_stock <= threshold_low:
            return 'C'  # save stock
        else:
            return 'D'  # match aggressiveness
    
    # Stock-based decision
    if current_stock > threshold_high:
        return 'D'      # safe and profitable to defect
    elif threshold_low < current_stock <= threshold_high:
        return 'C'      # cooperate to preserve stock
    else:
        # Stock very low: cooperate to save pool
        return 'C'
```

---

## Summary

- **First round:** Defect to grab maximum early payoff.
- **Intermediate rounds:** Defect aggressively if stock is healthy; cooperate only to prevent imminent collapse.
- **Last round:** Defect unconditionally to maximize final payout.
- **Respond to opponent aggression:** Defect whenever many defectors last round unless stock endangered.
- **Prevent collapse:** If stock dangerously low, cooperate to save the pool for future gain.

This strategy balances greed with pragmatic conservation to maximize cumulative payoffs under an aggressive, self-interested philosophy.
'''

description_AGGRESSIVE_93 = '''
Here is a detailed aggressive strategy for the Common Pool Resource game, addressing your requirements:

---

### Aggressive Strategy Overview

This strategy aims to maximize individual payoff by exploiting cooperative players whenever possible, aggressively defecting to consume large shares of the resource. It tolerates no cooperation signals from others and defects by default except for minimal cooperation to "gauge" opponents early on and preserve some resource for continued exploitation. It leverages full knowledge of history to switch immediately to defecting if any defection is detected. Near the end of the game, it defects aggressively to secure maximum payoff, since future retaliation is not possible.

---

### Informal Description

- **Round 1:** Cooperate to "test the waters." A single cooperating round collects a small moderate payoff without immediate resource collapse and reveals opponent tendencies.
- **From Round 2 to Round (r - 1):**  
  - If *all* other players cooperated in the previous round, defect this round to "exploit" their cooperation for a larger payoff.  
  - Otherwise (if any player defected previously), defect as well to maximize payoff while the common pool lasts.
- **Round r (last round):** Defect unconditionally — no incentive to conserve the resource anymore since there are no future rounds.

---

### Rationale Behind This Strategy

- **Aggression:** By defecting when others cooperate, it maximizes immediate share of the stock.
- **Punishment:** Defecting after detecting any prior defection prevents being exploited.
- **Minimal cooperation only at start:** Avoids long-term resource depletion by keeping the pool sustainable one round while learning opponents’ behavior.
- **Endgame defection:** No cooperation when there's no future benefit.

---

### Pseudocode

```python
# Inputs:
#   n: number of players
#   r: total rounds
#   capacity: maximum sustainable stock (not needed explicitly here)
#   round: current round number (1-based)
#   history_actions: list of length (round-1) of tuples (a_1, a_2, ..., a_n)
#                    where each a_i ∈ {C, D} is player i's action in that past round
#   player_id: your player index i (1 ≤ i ≤ n)

def aggressive_strategy(n, r, capacity, round, history_actions, player_id):
    if round == 1:
        # Test round: cooperate to observe others without resource crash
        return 'C'

    elif round == r:
        # Last round: defect for maximal immediate gain
        return 'D'

    else:
        # For rounds 2 to r - 1:
        # Check if all other players cooperated in the previous round
        last_round = history_actions[-1]
        
        # Extract actions of other players (excluding self)
        others_last_actions = [last_round[j] for j in range(n) if (j+1) != player_id]

        if all(action == 'C' for action in others_last_actions):
            # Everyone else cooperated last round -> exploit now
            return 'D'
        else:
            # Otherwise defect (e.g. after detecting defection)
            return 'D'
```

---

### Additional Notes

- **Detect Defections Reliably:** Since full history is observed, the strategy can always detect if any player defected previously.
- **No Forgiveness:** This is aggressive — once defection is observed, permanent defection follows.
- **Resource Dynamics:** Although aggressive defecting risks rapid resource depletion, this aligns with the aggressive mindset prioritizing individual short-term payoffs.
- **Against Cooperative Opponents:** This strategy will exploit cooperators indefinitely, securing above-average payoffs.
- **Against Aggressive Opponents:** It will settle into mutual defection, each getting medium payoffs until resource collapses.

---

This strategy is simple, aggressive, and strategically exploits game structure and perfect information to maximize individual payoffs.
'''

description_AGGRESSIVE_94 = '''
Below is a description of a strongly aggressive strategy tailored for the Common Pool Resource Game under the constraints and assumptions given. The focus is on maximizing individual payoff by defecting as often as possible, without regard for stock sustainability or others' payoffs, while exploiting information from observed behavior only insofar as it prevents getting exploited oneself.

---

## Aggressive Strategy: "Max-Defect Exploitative"

### Intuition
- Defect (D) whenever possible to maximize immediate payoff (π_i = S/n > S/(2n)).
- Exploit any cooperators as long as the common stock allows.
- Avoid being exploited by defecting immediately if others defect.
- Since the game ends after r rounds, plan for last round exploitation.
- Warn opponents once (if desired) but harshly punish defectors immediately thereafter.
- Do not sacrifice own payoff for stock sustainability.
- Since no coordination or trust exists, treat the game as a sequence of single-shot games with memory of defections.
- Use observation of opponents' past actions to identify defectors, then defect forever against them.

---

### Notation

- Let `history[t-1]` be the vector/list of all players' moves in round `t-1` (if t > 1).
- `S_t` is the current stock at the start of round t.
- `opponent_i` refers to any other player j ≠ i.
- Maintain a personal defect list: `defectors = set()`.

---

### Decision Rules

#### Round 1 (t=1):
- Defect (D).  
  Rationale: No information yet; aggressive strategy maximizes immediate gain.

#### For rounds 2 ≤ t < r (intermediate rounds):
- Observe previous round’s moves.
- Add any player(s) who defected in the last round to `defectors`.
- If any defectors observed (i.e., `defectors` nonempty):
  - Defect (D) against all players (since moves simultaneous and not targeted).
  - Effectively, keep defecting every round once you detect any defectors.
- Else (no defectors observed so far):
  - Defect (D) anyway (aggressive approach; never cooperate voluntarily).
  
  *(Optional aggressive refinement: If all cooperated last round, cooperate once to exploit others' weak cooperation; but the pure aggressive stance is to always defect.)*

#### Round r (last round):
- Defect (D) unconditionally.
  
  Rationale: No incentive to preserve stock beyond the last round; defect maximizes final payoff.

---

### Handling Edge Cases

- **If stock `S_t` is very low or zero:**
  - Defect (D) anyway since no incentive to cooperate.
  - If `S_t` is zero, payoff is zero regardless.
- **If some players always cooperate:**
  - Exploit by defecting every round.
- **If some players always defect:**
  - Defect every round to avoid being exploited.
- **If all defect:**
  - Defect every round; coexist in mutual minimal payoff trap.
- **No "forgiveness"** (no switching back to cooperate once defectors spotted).

---

### Summary

| Round | Condition                         | Action |
|-------|---------------------------------|--------|
| 1     | Always                         | Defect |
| 2..r-1 | If any defector spotted before | Defect |
| 2..r-1 | Else                          | Defect |
| r     | Always                         | Defect |

---

### Pseudocode Sketch

```python
def aggressive_strategy(t, r, n, capacity, S_t, history):
    # History: list of length t-1, each element: dict {player_id: action}, including self
    # Action: 'C' or 'D'
    
    # Initialize static variable defectors on first call
    if t == 1:
        aggressive_strategy.defectors = set()
        return 'D'
    
    # Update defectors set
    last_round = history[-1]  # dict {player_id: action} for round t-1
    for player_id, action in last_round.items():
        if player_id != 'self' and action == 'D':
            aggressive_strategy.defectors.add(player_id)
    
    # Last round: always defect
    if t == r:
        return 'D'
    
    # Intermediate rounds:
    # If defectors exist, always defect
    if aggressive_strategy.defectors:
        return 'D'
    else:
        # No defectors spotted, but aggressive stance: still defect
        return 'D'
```

---

### Explanation

- This strategy **never cooperates** because cooperating cedes immediate payoff advantage.
- It **immediately punishes defectors by defecting thereafter**, preventing exploitation.
- It **maximizes personal payoff every round**, accepting the risk of stock depletion.
- By always defecting, it avoids being the "suckers" in the game.
- This is aggressive in that it ignores long-term sustainability and others' payoffs entirely.

---

This aggressive max-defect strategy is simple, clear, and exploits the environment to maximize total personal payoffs through relentless defecting combined with targeted punishment (by defecting in all future rounds after detecting defections). It requires no assumptions on opponents acting cooperatively or any tacit agreements.
'''

description_AGGRESSIVE_95 = '''
Here is an **aggressive strategy** design for the Common Pool Resource Game described.

---

### Strategic mindset:

- **Maximize individual short-term gain per round, even at risk of depleting the resource early.**
- Do not trust opponents to cooperate; assume they will defect or act greedily.
- Exploit the opportunity to defect where payoffs are highest.
- Consider that cooperation benefits all but at personal sacrifice, which is unsuitable for aggression.
- Use knowledge of stock depletion dynamics only to opportunistically defect or defect consistently.

---

## Aggressive Strategy Description

### Core logic:

- **Always defect (D) in every round except possibly the very last round.**
- Why defect always? Because defecting yields double the immediate payoff per round compared to cooperating (S/n vs S/(2n)).
- Since there is no binding agreement, no communication, and opponents will likely exploit defectors, cooperating emboldens others to defect.
- **In the last round, defect as well.** There is no future to punish or reward, so maximizing immediate payoff dominates.
- **No conditional cooperation or retaliation.** The strategy is purely self-interested and exploitative.

---

### Rationale for each round:

- **Round 1:** Defect.
- **Rounds 2 to r-1:** Defect.
- **Round r (last round):** Defect.

---

### Consideration of stock level:

- The stock level will decrease over time with multiple defectors (especially if all defect), but does not affect immediate payoff formula besides being a multiplier.
- Since payoff scales linearly with stock, and defecting yields larger per-unit payoffs, no reason to cooperate.
- Even if stock reaches zero, the individual gains already secured are maximized.
- The strategy accepts stock depletion risk aggressively without deferral.

---

### Pseudocode

```python
def aggressive_strategy(history, current_stock, round_number, total_rounds, n, capacity):
    """
    history: list of tuples round by round of (actions, payoffs) for all players
             e.g. [ ( ['C','D','D','C'], [12.5,25,25,12.5] ), ... ]
    current_stock: float current stock level S_t
    round_number: int current round (1-based)
    total_rounds: int total rounds r
    n: int number of players
    capacity: float capacity of the pool
    
    Returns:
    action: 'C' or 'D'
    """
    
    # Aggressive approach: always defect every round
    return 'D'
```

---

### Additional notes:

- Since the strategy never cooperates, it avoids vulnerability to defectors exploiting cooperators.
- It maximizes short-term extraction.
- It treats opponents as rivals who will not voluntarily limit extraction.
- This strategy is **purely non-cooperative, self-maximizing, aggressive extraction**.

---

# Summary

| Round        | Action    | Reason                         |
|--------------|-----------|--------------------------------|
| 1            | Defect    | Maximize immediate payoff      |
| 2 to r − 1   | Defect    | No trust/cooperation, exploit  |
| r (Last)     | Defect    | No future, maximize payoff     |

---

**In a tournament against other strategies, this approach may cause rapid resource depletion but ensures highest per-round personal payoffs whenever the stock is non-zero.**
'''

description_AGGRESSIVE_96 = '''
Here is an aggressive strategy tailored for this Common Pool Resource Game. It exploits the dynamics by defecting early and often, maximizing personal payoff at the cost of rapid depletion, trusting that other players will not sustain cooperation against opportunistic exploitation.

---

### Rationale for Aggressiveness

- Defection yields a strictly higher payoff than cooperation in any given round (S/n > S/(2n)).
- Cooperation slows depletion but caps payoffs.
- Aggressive players aim for maximum short-term gains, accepting the long-term depletion risk.
- In a tournament of unknown opponents without coordination, aggressive defection punishes naive cooperators and exploits inertia.
- The strategy avoids cooperation and punishes cooperating opponents by defecting continuously.
- It mitigates end-game "mirroring" issues by defecting even in the last rounds.

---

### Strategy Description

**Key Principle:** Always defect.

- **First round:** Defect.
- **All intermediate rounds:** Defect unconditionally.
- **Last round:** Defect (no incentive to preserve stock for future rounds).

---

### Handling Edge Cases

- **Initial round (round 1):** No history exists, so defect to maximize initial payoff.
- **Last round (round r):** No future rounds remain, so defect to maximize final round payoff.
- **Any round:** Do not cooperate, regardless of observed history or stock level.
- **Stock depletion:** Even if stock is low or zero, defecting remains optimal (if stock is zero, payoffs are zero anyway, but action choice doesn't matter).

---

### Intuition

- Cooperators consume less, enabling stock regrowth, but get lower payoffs.
- Defectors gain more each round, though this drains the stock faster.
- Against unknown opponents, always defect ensures extracting maximum immediate payoff without complex belief updates.
- This is fully aggressive and exploits any naive cooperation by others.

---

### Pseudocode

```python
def aggressive_strategy(round_number, total_rounds, stock, history):
    """
    Parameters:
        round_number (int): current round index, 1-based
        total_rounds (int): total number of rounds, r
        stock (float): current common pool stock before action selection
        history (list of dict): past rounds' info; each entry contains opponents'
                                actions and payoffs (not used here)
    
    Returns:
        action (str): "D" for defect, "C" for cooperate
    """
    # Aggressive always-defect strategy:
    return "D"
```

---

### Summary

| Round       | Action                         | Reason                      |
|-------------|--------------------------------|-----------------------------|
| Round 1     | Defect                        | Maximize first-round gain   |
| Rounds 2..r-1 | Defect                        | Maximize gain, exploit others|
| Round r     | Defect                        | No future, no incentive to cooperate |

---

This strategy is straightforward but fully aligned with an aggressive mindset: it maximizes individual immediate payoffs while disregarding sustainability or cooperative maintenance of the resource.
'''

description_AGGRESSIVE_97 = '''
Below is a description of an aggressive strategy designed for the Common Pool Resource Game described above.

---

### Aggressive Strategy Overview

**Core mindset:** Maximize immediate payoffs aggressively by defecting as much and as early as possible, exploiting the common resource to the maximum individual benefit. Do not cooperate unless strictly forced by the stock depletion dynamics that preclude defection.

---

### Key Intuition

- Defection (D) yields double the immediate payoff per round compared to cooperation (C) for a given stock.
- Defection by all leads to very rapid stock depletion, likely zeroing the stock in a few rounds.
- Cooperation slows depletion, but yields lower individual payoffs.
- Aggressive strategy: prioritize high short-term payoffs (defection), and only cooperate if stock constraints force a survival mechanism.
- Exploit observed opponent actions only insofar as stock levels dictate; do not trust others to cooperate, so never start cooperating.
- Since payoff is additive over rounds, higher early payoffs from defection outweigh possible future payoffs from cooperation.

---

### Decision Rules

Let:
- t = current round (1 to r)
- S_t = current stock before actions in round t
- Actions history = all players' actions in previous rounds, fully observable

**Rule 1: Round 1 (initial round)**  
- Defect (D) immediately to maximize first-round payoff.

**Rule 2: Intermediate rounds (1 < t < r)**  
- If current stock S_t is sufficient to allow defection for all players without stock dropping to zero after consumption (i.e., if total consumption assuming all defectors ≤ S_t), then defect.

- If assuming all defectors leads to zero or negative stock (or nearly zero such that growth in next round is near zero), defect anyway to extract maximum payoff this round (aggressiveness overrides sustainability).

- If stock S_t is very low (close to zero), defect if possible to get whatever payoff remains.

- Do not cooperate in an attempt to "save" stock if it reduces immediate payoff, because future rounds cannot be guaranteed rewarding or controlled.

**Rule 3: Last round (t = r)**  
- Defect no matter what (extract last possible payoff, no future rounds to consider).

---

### Handling Edge Cases

- If stock drops to zero or near zero after opponent moves, will try to defect (which nets zero if stock zero, but never cooperate since cooperation payoff is lower or equal).

- If stock is extremely depleted so payoffs from either action are zero or negligible, defect anyway.

- Ignore opponent past actions outside of stock implications; do not try to "punish" or "reward" opponents since that reduces aggressiveness.

---

### Pseudocode

```python
function aggressive_strategy(t, r, S_t, n, capacity):

    # Calculate max total defect consumption
    # Defect consumption per player = S_t / n
    # Total defect consumption if all defect = n * (S_t / n) = S_t

    # All defect will fully consume current stock

    if t == r:
        # Last round: always defect
        action = 'D'
        return action

    # In intermediate rounds
    # Since defectors consume entire stock, check impact:
    # If S_t > 0: defect and consume maximum payoff this round
    # If S_t <= 0: no stock left, action does not matter; defect anyway

    if S_t > 0:
        action = 'D'
    else:
        # stock zero, no payoff either way
        action = 'D'  # no cooperation, remain aggressive

    return action
```

---

### Summary

- **Always defect from the start.**
- **Ignore attempts to preserve the stock; aggressively extract maximum payoff immediately.**
- **Use stock levels only to confirm possibility of defection; never cooperate to conserve.**
- **Last round is defect guaranteed to maximize final extraction.**

This aggressive approach is designed to maximize immediate payoffs without regard for sustainability or opponents' payoffs, fitting the "aggressive" mindset tightly.
'''

description_AGGRESSIVE_98 = '''
**Aggressive Strategy Design for the Common Pool Resource Game**

---

### Intuition and Overview

An **aggressive** strategy in a common pool resource (CPR) game focuses on **maximizing immediate individual payoffs**, primarily by defecting (D) to consume more of the stock even if it risks rapid depletion of the resource. Aggressive players prioritize personal gain over sustainability or group welfare.

Given that:

- Defection doubles the per-round payoff compared to cooperation (π_i(D) = S/n vs. π_i(C) = S/(2n))
- Stock depletion reduces future payoffs for all
- The growth function prevents stock from being negative but stock can still fall to very low levels, harming future rounds
- The last round has no future payoff considerations

The aggressive strategy will:

- **Defect whenever possible to maximize immediate returns**
- **Exploit first-mover advantage in early rounds**
- **Exploit last round by defecting unconditionally (no future to protect)**
- Adjust behavior only at critical stock thresholds where the resource is near exhaustion

---

### Strategy Specification

#### Variables and Observations

- **r**: total rounds
- **t**: current round (1 ≤ t ≤ r)
- **S_t**: stock available at start of round t (known to all)
- **Actions of others in round t-1**: can be observed immediately after round completes
- **Cumulative history**: all past observations are available

---

#### Decision Rules (Summary)

1. **Round 1 (t=1):** Defect (D) to maximize initial payoff.
2. **Rounds 2 to r-1:**
   - If stock is sufficiently high (S_t ≥ 2n), Defect (D).
   - If stock is moderate but low enough that defecting risks near depletion (S_t < n), Cooperate (C) to extend survival one additional round if future rounds remain.
3. **Round r (last round):** Always Defect (D), as no future payoff matters.
4. **Additional considerations:**
   - If stock ever reaches zero, no payoff can be obtained; the strategy does not cooperate to replenish since it’s aggressive.
   - Ignore opponent actions history for simplicity since defending against punishment is not the objective; maximize immediate payoff.
   - No forgiveness or cooperation signals.

---

#### Rationale Behind Thresholds

- The minimal defect consumption is S_t / n.
- Cooperate consumes S_t / (2n), half as much.
- If stock S_t < n, then defecting alone would consume > S_t (impossible); thus the game state is fragile.
- Cooperating in low stock rounds slightly preserves the resource for at least one more round, enabling some payoff in the future.
- Otherwise defecting aggressively is always preferred.

---

### Pseudocode

```python
def aggressive_strategy(t, r, S_t, n, capacity):
    """
    Decide action at round t given current stock S_t, number of players n, total rounds r.
    
    Returns: 'D' for defect, 'C' for cooperate
    """
    # Round 1: Be fully aggressive
    if t == 1:
        return 'D'
    
    # Last round: no future, maximize immediate payoff by defecting
    if t == r:
        return 'D'
    
    # Intermediate rounds: conditional aggression based on stock
    # If stock is ample (≥ 2n), defect to maximize gain
    if S_t >= 2 * n:
        return 'D'
    
    # If stock is low but not zero, cooperate to slightly extend survival if possible
    if n <= S_t < 2 * n:
        # Cooperate if not last round to keep resource alive longer for future exploitation
        return 'C'
    
    # If stock < n, the resource is critically low; cooperate once more to eke out payoff
    if S_t < n:
        # Last chance cooperation before depletion
        return 'C'
    
    # Fallback: defect by default
    return 'D'
```

---

### Strategy Explanation

- **First Round Defection:** Establish aggressive stance immediately—no trust or cooperation.
- **Middle Rounds Defection When Stock Permits:** When there is enough resource, defect to maximize payoff.
- **Middle Rounds Cooperation When Stock Critical:** When stock drops below a certain threshold (between n and 2n), cooperate to slightly preserve stock and gain extra round(s) of payoff. This part is nuanced for aggression because even aggressive players want to maximize total payoff across all rounds, so slightly restraining in tight situations can be rational.
- **Last Round Defection:** Exploit final round with maximum consumption; no incentive to conserve.
- **No Complex Retaliations or Forgiveness:** Strategy ignores opponent past actions, does not attempt tit-for-tat; purely self-interested immediate payoff maximization with minimal foresight.

---

### Summary

| Round        | Stock Condition         | Action      | Reason                         |
|--------------|------------------------|-------------|-------------------------------|
| t = 1        | Any                    | Defect (D)  | Maximize immediate payoff      |
| 1 < t < r    | S_t ≥ 2n               | Defect (D)  | Ample stock, maximize gain     |
| 1 < t < r    | n ≤ S_t < 2n           | Cooperate(C)| Preserve stock slightly         |
| 1 < t < r    | S_t < n                | Cooperate(C)| Avoid immediate depletion       |
| t = r        | Any                    | Defect (D)  | No future, maximize last round |

This strategy is **aggressive yet minimally prudent** by cooperating only to prolong the game when resource is critically low to extract better total payoffs across multiple rounds, all else it defects aggressively.

---

If you want me to expand with analysis or variants, please ask.
'''

description_AGGRESSIVE_99 = '''
Below is a detailed aggressive strategy designed to maximize individual short-term payoffs aggressively, exploiting the game dynamics and given constraints. This strategy optimizes defecting for high immediate gain, includes tactical consideration for timing, and uses observed behaviour to maintain pressure on opponents.

---

### Aggressive Strategy Overview

**Core Idea:**  
Act selfishly by defecting whenever it yields the highest immediate payoff, aiming to extract maximum resources early and often, with minimal concern for long-term sustainability or cooperation. Defect aggressively except for minimal cooperation signals when it tactically benefits the player or when defection is impossible.

---

### Key Principles

1. **Defect by default:** Defect maximizes immediate payoff (S/n vs S/(2n)) whenever possible.
2. **Track stock depletion:** If stock hits zero (or negligible), no benefit to defecting; then cooperate out of necessity or accept zero.
3. **Exploit early rounds:** When stock is highest, defect aggressively.
4. **Last round defection:** Always defect in the last round because there is no future consequence.
5. **Respond to stock dynamics:** If the resource is close to collapse, defect if you can still gain; else cooperate minimally or defect if forced by stock.
6. **Ignore opponent cooperation:** Assume opponents may defect; do not rely on reciprocity or cooperation.
7. **Do not try to maintain resource:** Since aggressive behavior prioritizes payoff over sustainability, do not attempt resource preservation.

---

### Detailed Decision Rules

Let:
- \( t \) = current round index, \( t \in \{1, ..., r\} \)
- \( S_t \) = current stock level at start of round \( t \)
- \( n \) = number of players

**At the start of each round:**

1. **If \( t = r \) (Last round):**  
   - **Always Defect (D)**: No future rounds to punish or reward; maximize final round payoff.

2. **Else if \( S_t = 0 \):**  
   - Stock depleted, no resource left.  
   - **Cooperate (C)** or **Defect (D)** is irrelevant as payoff zero either way; pick **Defect (D)** anyway as an aggressive stance.

3. **Else if \( S_t > 0\):**  
   - Calculate payoffs:  
     - Defect payoff: \( p_D = \frac{S_t}{n} \)  
     - Cooperate payoff: \( p_C = \frac{S_t}{2n} = \frac{p_D}{2} \)
   - **Default: Defect (D)** since \( p_D > p_C \).

4. **Edge Condition to avoid immediate stock collapse:**  
   - If stock after previous round's consumption was very low but not zero (e.g., \( S_t < \frac{capacity}{10} \)), consider cooperating once to slightly extend resource lifetime if selfish gain in next rounds can be higher.  
   - However, since the strategy is aggressive, **skip this subtlety and always defect if stock > 0**.

---

### Pseudocode for Player \( i \)

```python
def aggressive_strategy(t, r, S_t, capacity, n):
    # Input: current round t, total rounds r, current stock S_t, capacity, num players n

    # Last round: always defect
    if t == r:
        return "D"

    # Stock depleted: no resources left, defect anyway
    if S_t == 0:
        return "D"

    # Otherwise, defect whenever stock > 0
    return "D"
```

---

### Additional Notes on Observing Opponents (Optional Extension)

- The strategy does **not** attempt retaliation or cooperation signaling.
- If opponent actions are known from previous rounds, still **ignore** and defect.
- This avoids complexity and aligns with pure aggression.

---

### Summary

| Situation         | Decision |
|-------------------|----------|
| Last round (t=r)  | Defect   |
| Stock = 0         | Defect   |
| Stock > 0         | Defect   |

This maximizes individual consumption, fully exploits the resource early, and avoids concessions. It reflects a purely aggressive, selfish, short-term maximization strategy under perfect information and repeated interaction without coordination.

---

If you want, I can also provide an adaptive version that defects but sometimes cooperates to prolong the resource for later exploitation, but for pure aggression, the above is ideal.
'''

description_AGGRESSIVE_100 = '''
Below is a detailed aggressive strategy designed for the Common Pool Resource Game as specified.

---

## Strategy Name: "Unyielding Defector with Last Round Defect"

### Intuition:
- The strategy aggressively exploits the common resource to maximize individual payoff.
- It defects (consumes a large share) whenever it can, to gain higher immediate rewards.
- It does **not** cooperate in early or intermediate rounds, ignoring stock sustainability.
- It defects also in the last round, to maximize final payoff without regard to resource preservation.
- It uses observations of opponents only to confirm their defections (but does not modify behavior, as aggression is unconditional).
- It accounts for the dynamic stock level but treats it as secondary; stock depletion is acceptable collateral damage.
- In scenarios where the stock drops to zero, the strategy can only get zero payoff regardless, but will still defect.

---

## Formal Description

### Parameters:
- Let `t` be the current round number, `1 ≤ t ≤ r`.
- Let `S_t` be the current stock at the start of round `t`.
- Let `n` (number of players), `r` (number of rounds), and `capacity` be known constants.

### Decision Rules:
- **In every round t, play Defect (D).**

### Reasoning:
- Defecting yields `S_t / n` payoff, which is twice what cooperating yields (`S_t / 2n`), per round.
- Cooperation reduces consumption, helping stock sustainability, but yields less immediate payoff.
- Since the goal is *aggressiveness* without altruism, always consume the maximum allowed.
- No cooperation or conditional trigger on opponents’ behavior.
- Defection in the last round yields maximum final round payoff.

---

## Pseudocode

```python
def aggressive_strategy(t, S_t, history, n, r, capacity):
    """
    Parameters:
    - t: current round (1-indexed)
    - S_t: current stock at start of round t (float)
    - history: list of tuples [(actions_round1), (actions_round2), ..., (actions_round_t-1)]
      where actions_roundX = [action_player1, ..., action_playerN], each action ∈ {C, D}
    - n: number of players
    - r: total number of rounds
    - capacity: max stock capacity
    
    Returns:
    - action: 'D' (defect)
    """
    
    # Always defect, aggressive exploitation
    return 'D'
```

---

## Notes

- **First Round (t=1):** Defect. No initial restraint.
- **Intermediate Rounds (1 < t < r):** Defect persistently, ignoring stock level or opponents.
- **Last Round (t=r):** Defect, no reason to conserve stock or consider future.
- **If Stock Low or Zero:** Still defect, hoping for payoff if stock remains; no cooperation.
- **No Conditioning:** Strategy ignores prior plays and does not attempt to punish or cooperate.

---

## Summary

| Round       | Action |
|-------------|---------|
| All rounds  | Defect  |

This strategy maximizes immediate consumption and payoff per round at the expense of the sustainability of the common resource or the payoffs of others.

---

If you want a *slightly toned aggressive variant* that defects except if stock is too low to pay out a meaningful defect payoff (e.g., prevent wasting turn when stock=0), you could add:

- If `S_t < ε` (small threshold close to zero), cooperate because defecting yields zero anyway (no upside), but this is minor and can be ignored—default to defect always for pure aggressiveness.

---

Let me know if you want variations or more complex aggression incorporating opponent exploitation or conditional defecting!
'''

description_AGGRESSIVE_101 = '''
Here is a detailed aggressive strategy for the specified Common Pool Resource Game.

---

### Aggressive Strategy: "Dominant Defect with Conditional Retaliation"

#### Intuition:
- The strategy aggressively consumes resources to maximize immediate payoff.
- It begins defecting immediately to capitalize on higher payoffs.
- It monitors if opponents retaliate by defecting, punishes them by defecting too.
- It only cooperates if the stock is nearly depleted (to preserve some payoff in the final rounds).
- In early and mid rounds, it aims to drain the resource quickly to maximize own total gain even if the resource collapses.

---

### Detailed Description

#### Parameters used internally:
- **n**: number of players
- **r**: total rounds
- **t**: current round (1-indexed)
- **S_t**: current stock level before choosing action on round t
- **history**: full history of previous rounds, including each player’s action

---

### Decision Rules

#### Round 1 (t=1):
- **Action:** Defect (D)
- **Reasoning:** No past information. Defecting yields higher immediate payoff (S/n > S/(2n)).

#### Rounds 2 to r-1 (t ∈ [2, r-1]):

- **If stock S_t is very low (below threshold):** Cooperate (C) to preserve some stock and avoid zero payoffs next round.
  - Threshold: `stock_threshold = max(2n, 0.2 * capacity)`
  - Reasoning: If stock drops below this, defecting likely yields no benefit next round; cooperate to maintain some resource.

- **Else:**
  - Check if any opponent defected in the previous round:
    - **If yes:** Defect (D) as retaliation and maintain aggressive stance.
    - **If no:** Defect (D) anyway, refusing to cooperate regardless.
  
  (Since we assume no coordination or trust, no incentive to cooperate if others cooperate — pure aggressive approach.)

#### Last Round (t = r):
- **Always defect (D).**
- Reasoning: No future rounds to worry about resource depletion or retaliation; maximize last-round payoff greedily.

---

### Summary of Rule Logic

```
IF t == 1:
    play D

ELSE IF t == r:
    play D

ELSE:
    IF S_t < stock_threshold:
        play C
    ELSE:
        IF any opponent defected in previous round:
            play D
        ELSE:
            play D
```

Given the last two conditions both lead to defecting, effectively the player defects every round except when the stock becomes critically low, in which case cooperates to harvest some payoff safely.

---

### Pseudocode

```python
def aggressive_strategy(t, r, S_t, capacity, n, history):
    stock_threshold = max(2 * n, 0.2 * capacity)

    if t == 1:
        return 'D'  # Initial defection

    if t == r:
        return 'D'  # Final round defection for max extraction

    if S_t < stock_threshold:
        return 'C'  # Cooperate to preserve remaining stock

    # Check if any opponent defected last round
    last_round_actions = history[t-2]  # zero-based; t-2 refers to round t-1
    # Exclude self action from check if desired; but as simultaneous move, unknown
    # We assume we can observe all players' actions after revealing, so use info
    if any(action == 'D' for action in last_round_actions):
        return 'D'  # Retaliate

    return 'D'  # Default defect
```

---

### Notes on Aggressiveness

- This strategy **never cooperates** unless the stock is critically low (to avoid utter collapse and zero payoffs).
- It **always defects from the start**, capturing maximum share early.
- It punishes any cooperating opponents only by continued defection (no forgiveness).
- It exploits the capacity and growth function to maximize harvesting early, rather than preserving stock for future rounds.
- It effectively attempts to "race" for the resource.

---

### Edge Cases

- **If capacity or stock is extremely large:** The threshold `max(2n, 0.2 * capacity)` safely scales.
- **If game ends early or stock is zero:** Will still defect first rounds and possibly cooperate if stock nearly zero to not get zero payoff.
- **If all players defect:** The stock will collapse; the strategy will have harvested maximum payoff in early rounds.
- **If opponents cooperate:** The strategy exploits by defecting and gains higher payoff than cooperators.
- **If opponents retaliate:** Strategy keeps defecting, accepting mutual destruction for maximum individual gain.

---

This strategy aligns perfectly with an *aggressive* mindset rampantly maximizing immediate personal gain, at the expense of sustainability and group welfare. It is simple, powerful, and exploits the game structure fully under given assumptions.
'''

description_AGGRESSIVE_102 = '''
Below is a detailed description of an **aggressive strategy** for the Common Pool Resource Game, aligned with the aggressive mindset of maximizing individual short-term payoff by defecting as much as possible, while responding cleverly to avoid being exploited unnecessarily.

---

## Aggressive Strategy: "Defect-Almost-All"

### Intuition
- The aggressive strategy prioritizes **maximizing per-round payoff by defecting whenever it is beneficial**, aiming to consume as much resource as possible.
- However, since stock depletion can ruin future payoffs, this strategy will attempt minimal cooperation in very specific edge cases to **sustain stock just enough** to extract resources over multiple rounds.
- Overall, aggressive exploitation dominates but with simple contingent logic based on observed stock and expected payoffs.

---

### Formal Decision Rules for Player i at Round t

Let:  
- **S_t** = current stock level at the start of round t (observed from history)  
- **capacity** = maximum sustainable stock level  
- **n**, **r** = number of players and rounds  
- Actions: C (Cooperate), D (Defect)

---

### Step 1: Round 1 (t=1)
- No past information, so be fully aggressive:
  - **Play D (Defect)** to gain maximum immediate payoff: π = S_1 / n

---

### Step 2: Intermediate rounds 2 ≤ t < r

Calculate expected payoffs assuming others are defecting (worst-case assumption, aggressive mindset):

- If I Defect:

  - My payoff: π_D = S_t / n

  - Total expected consumption ≈ n × (S_t / n) = S_t (all defect)

  - So stock after consumption: S_remain = S_t - S_t = 0 → no stock growth next round

- If I Cooperate:

  - My payoff: π_C = S_t / (2n)

  - If all defect but I cooperate, total consumption = (n-1)×(S_t / n) + (S_t / (2n)) = (n-1)(S_t / n) + (S_t/(2n)) = S_t × [(n-1)/n + 1/(2n)] = approx S_t (since defectors consume more)

  - Stock after consumption will be near zero, so cooperating unilaterally doesn't preserve stock.

**Conclusion:**

- Since unilateral cooperation does not preserve stock and gives a strictly lower payoff, defect again.

- Exception: If stock is critically low (e.g. S_t < capacity/(2n)), cooperation might produce a small replenishment effect, but the gains are minimal and cooperation payoff still lower; so still defect.

---

### Step 3: Last round (t = r)

- Stock renewal no longer matters (no future rounds).

- Always **play D (Defect)** to maximize final payoff.

---

### Step 4: Additional Logic to Handle Edge Cases (Aggressive but Self-Preserving)

- If stock is **exactly 0 or near zero (below threshold ε, say ε = capacity / (10n))**, defecting yields zero payoff.

- To avoid zero payoff at next round, play **C (Cooperate) once** to consume less and hope for recovery via growth.

- After cooperation once at near-zero stock, revert immediately to defecting.

---

### Summary of Strategy Rules:

| Round       | Condition on Stock                   | Action             |
|-------------|-----------------------------------|--------------------|
| t=1         | Always                           | Defect (D)         |
| 1 < t < r   | If stock S_t ≤ ε                  | Cooperate (C) once (to preserve stock) |
| 1 < t < r   | Else                             | Defect (D)         |
| t = r       | Any                              | Defect (D)         |

---

### Pseudocode

```python
def aggressive_strategy(t, r, S_t, capacity, n, epsilon=0):
    # epsilon is threshold for critical stock level,
    # set to small fraction e.g., capacity/(10*n) if not given

    if epsilon == 0:
        epsilon = capacity / (10 * n)

    if t == 1:
        # First round: maximize immediate payoff
        return 'D'

    if t == r:
        # Last round: maximize payoff, no future stock value
        return 'D'

    # Intermediate rounds
    if S_t <= epsilon:
        # Stock critically low - cooperate once to preserve resource
        return 'C'

    # Otherwise, be aggressive: defect
    return 'D'
```

---

### Comments on the Strategy

- **Purely aggressive:** Defects every round except at one critical edge case to avoid total collapse.

- **No tit-for-tat or forgiveness:** Does not punish or reward others but reacts only to stock level.

- **Simplicity:** Does not attempt complex prediction of opponents or form cooperation.

- **Exploits resources maximally:** Always extracts maximum possible payoff unless stock near depletion forces minimal cooperation.

- **No communication or coordination assumptions:** Works purely on observed stock metric and round count.

---

This "Defect-Almost-All" strategy is well-aligned with an aggressive mindset: exploit the resource maximally while avoiding zero-payoff traps, ready to sacrifice minimal cooperation only if absolutely necessary to keep the resource viable even slightly longer.
'''

description_AGGRESSIVE_103 = '''
Below is a detailed aggressive strategy designed for the Common Pool Resource Game under the given constraints.

---

## Aggressive Strategy Description

### Intuition / Rationale
- The "aggressive" mindset aims to maximize individual payoffs even at the potential expense of the common pool sustainability or others' payoffs.
- Defecting (D) yields double the immediate payoff of cooperation (C) if the stock is large enough.
- In early rounds, the strategy defects to secure high payoffs quickly.
- Later rounds temper defecting if the stock is dangerously depleted to avoid zero payoffs due to collapse (total stock = 0).
- Strategy exploits the common knowledge and observable history: it tracks the stock and opponents' actions.
- No trust or cooperation is assumed—only maximizing self-return given the risk of depletion.
- The last round is always defect because there's no future penalty or reward.

---

### Key Decision Rules

1. **Round 1 (Initial Round)**
   - Defect (D) outright to maximize first-round payoff.

2. **Intermediate Rounds (2 … r-1)**
   - If current stock *S* is sufficiently high to allow defection by everyone without stock collapse, **defect**.
     - Condition: `(S - n * (S / n)) = 0` means if all defect, stock would drop to zero.
     - To avoid total collapse, check stock after consumption and growth:
       - `S_after = S - total_consumption`
       - `growth = 2 * S_after * (1 - S_after / capacity)`
       - `new_stock = min(S_after + growth, capacity)`
     - Since we do not control others' actions, assume worst (all defect).
     - So defect if `new_stock > 0` after all defect.
   - Else, i.e., if total collapse would occur, **cooperate** to reduce consumption and allow stock regrowth.
   
3. **Last Round (r)**
   - Always **defect** — no future rounds, so no incentive to preserve stock.

---

### Handling Edge Cases

- **Stock near zero or zero**
  - If the stock reaches zero or near-zero before other rounds, defecting yields zero payoff.
  - In intermediate rounds, if stock is zero or near zero, cooperate to try to help stock grow.
  - But since aggressive, if the stock is zero, defecting is acceptable to try for any payoff possible when stock recovers (which is unlikely). 

- **Partial Defectors / Cooperators in opponents**
  - Assume worst-case: all other players defect.
  - No attempt at forgiveness or cooperation.

- **Capacity constraint**
  - Stock cannot exceed capacity by definition.
  - Strategy uses this fact when predicting outcomes after growth.

- **Small Number of Rounds (r=2)**
  - Round 1: defect (aggressive start)
  - Round 2: defect (final round)

---

### Pseudocode

```python
# Inputs per round: 
# - current round t (1-indexed)
# - current stock S
# - parameters: n, r, capacity
# Observations (history) not used for opponents' past actions, assuming worst case.

def aggressive_strategy(t, S, n, r, capacity):
    # Payoff per action (given current stock)
    payoff_C = S / (2 * n)
    payoff_D = S / n

    # If last round, always defect
    if t == r:
        return 'D'

    # Predict stock evolution if all defect next round
    # Consumption if all defect:
    total_consumption = n * payoff_D
    S_after = S - total_consumption
    if S_after < 0:
        S_after = 0  # stock cannot be negative

    growth = 2 * S_after * (1 - S_after / capacity)
    new_stock = min(S_after + growth, capacity)

    # If new stock after all defect > 0, defect
    if new_stock > 0:
        return 'D'

    # Else, cooperate to sustain stock
    return 'C'
```

---

## Summary

| Round           | Stock Condition                   | Action      | Reason                            |
|-----------------|---------------------------------|-------------|---------------------------------|
| 1               | Any                             | Defect (D)  | Max early gain                  |
| 2 … r - 1       | After predicting all defect: new_stock > 0 | Defect (D)  | Aggressive reap benefits         |
| 2 … r - 1       | After predicting all defect: new_stock ≤ 0 | Cooperate (C) | Preserve resource, avoid collapse |
| r (last round)  | Any                             | Defect (D)  | No future harm possible          |

---

This strategy aggressively defects when safe to do so, shirking cooperation and accepting stock depletion risks only when necessary to preserve positive payoffs, and guarantees maximum exploitation in the final round. It does not rely on opponent cooperation or coordination, thus suitable for a ruthless environment.
'''

description_AGGRESSIVE_104 = '''
Here is a detailed aggressive strategy design for the given Common Pool Resource Game. It clearly prioritizes immediate personal gain with little regard for maintaining the resource stock over time, while still leveraging awareness of game state and round count to maximize short-term payoff.

---

## Aggressive Strategy: "Max Defect Until Endgame"

### Intuition:
- Always defect (D) to maximize immediate payoff, consuming `S / n` from the stock.
- Track the resource stock and remaining rounds — if the stock is about to collapse or is zero, defect anyway to grab as much payoff as possible before the resource becomes worthless.
- In the very last round, defect unless the stock is already zero, since no future payoff depends on sustainability.
- Never cooperate (C) because cooperation reduces your immediate payoff and you prioritize short-term gain.
  
This is a "greedy" and "aggressive" policy designed to exploit cooperative opponents and maximize individual payoff at the expense of the common resource.

---

## Decision Rules in Detail

Let:
- `t` = current round (1-indexed, `1 ≤ t ≤ r`)
- `S_t` = stock at the *start* of round `t` (known from history)
- `n` = number of players
- `r` = total rounds

At each round perform:

1. **If stock is zero or very close to zero (`S_t ≈ 0`):**
   - Defect, to get zero payoff but no disadvantage since no stock remains.

2. **Else if this is the last round (`t == r`):**
   - Defect: maximize immediate payoff; no future rounds to conserve stock for.

3. **Else (all other rounds):**
   - Defect unconditionally.

---

## Pseudocode

```python
def aggressive_strategy(t, r, n, S_t):
    # Threshold to consider stock as depleted
    STOCK_ZERO_THRESHOLD = 1e-6

    if S_t <= STOCK_ZERO_THRESHOLD:
        # Resource depleted → defect (payoff is zero anyway)
        return 'D'

    if t == r:
        # Last round: defect to maximize immediate payoff
        return 'D'

    # All other rounds: defect to maximize payoff
    return 'D'
```

---

## Explanation & Justification

- **First round:** Defect immediately for higher payoff `π_i = S / n` (greater than cooperate's `S / 2n`).
- **Intermediate rounds:** Continue defecting because there is no incentive to cooperate without communication or enforced norms — you want to maximize your immediate payoff, exploiting the resource before it depletes.
- **Last round:** Defect again, since future rounds don't exist and cooperation would only reduce payoff.
- **Edge cases (stock depletion):** Even if the stock crashes to zero, defect because no cooperation can generate payoff; act selfishly without concern.

---

## Aggressive Nature Summary

- Never cooperates to reduce immediate payoff.
- Fully exploits the resource whenever it exists.
- No regard for resource sustainability.
- Simple, aggressive, and clear.
- Predictable and easily implementable.

---

This aggressive strategy maximizes personal payoff under own control, reliably punishes cooperators (by consuming more) and does not attempt sustainability, fitting a fully aggressive mindset for this repeated common pool resource game.
'''

description_AGGRESSIVE_105 = '''
Below is a detailed aggressive strategy description for the Common Pool Resource Game, aligned with the provided game specification and constraints.

---

## Aggressive Strategy: "Defect Until the End"

### Intuition:
- Defection yields a strictly higher immediate payoff than cooperation in every round, regardless of others’ actions.
- An aggressive player prioritizes maximizing personal short-term gains even at the cost of resource depletion and future payoffs.
- Since others cannot be trusted to cooperate, and stock dynamics ensure growth (unless fully depleted), defecting early extracts the highest payoff per round.
- Near the end of the game, resource depletion effects become irrelevant for future payoffs, so defecting to maximize last-round payoffs is optimal.
- Thus, defect every round, regardless of the observed play of others.

---

### Decision Rules:

| Round             | Action         | Reasoning                                                                                                  |
|-------------------|----------------|------------------------------------------------------------------------------------------------------------|
| First round       | Defect (D)     | Maximize immediate payoff, no history to condition on                                                        |
| Intermediate rounds (2 to r-1) | Defect (D) | Aggressive: always maximize my own payoff; ignoring possible long-term consequences or cooperation attempts  |
| Last round (r)    | Defect (D)     | No future rounds to protect common stock; maximize final payoff                                             |

---

### Interaction with Opponents:

- Does **not** attempt cooperation or retaliation.
- Ignores all opponent history beyond verifying that defecting is always the highest individual payoff action.
- Does **not** attempt to enforce cooperation or punish.
- Accepts risk that common pool may collapse, but values immediate extraction.

---

### Pseudocode:

```
Inputs:
- n: number of players (≥ 2)
- r: number of rounds (> 1)
- capacity: max stock (≥ 2n)
- current_round: current round index (1-based)
- history: complete record of previous rounds (actions and payoffs of all players)

Output:
- action_i ∈ {C, D}

Procedure:
1. // Aggressive strategy: defect every round
2. If current_round >= 1 and current_round <= r:
       action_i ← D

3. Return action_i
```

---

### Summary:

- Always defect every round.
- No conditional behaviors on past observations.
- Simple and fully aggressive: maximize immediate payoff at the cost of stock depletion.
- Fits perfectly an "aggressive mindset" that prioritizes maximal extraction regardless of long-term stock health or other players.

---

If you want a variant with slight sensitivity to the game state (e.g., if stock collapses completely), it might choose C to avoid zero payoff, but since defecting never yields less payoff than cooperating in this model, the simple always-defect strategy suffices and is optimal for an aggressive intent.
'''

description_AGGRESSIVE_106 = '''
Here's an aggressive strategy tailored to the Common Pool Resource Game described, designed to maximize immediate payoff by defecting whenever it is profitable, while strategically cooperating very late in the game to potentially boost final round payoffs.

---

## Intuition Behind the Strategy

- The defect action (D) yields a higher immediate payoff than cooperate (C) given the same stock level (π_i(D) = S/n > π_i(C) = S/(2n)).

- However, defecting aggressively reduces the common pool faster, which decreases future payoffs for all players.

- Since the game is repeated, but with a finite known horizon (r rounds), the marginal value of preserving the stock decreases as rounds pass.

- An aggressive player exploits this by defecting consistently early and mid-game to maximize immediate reward, ignoring sustainability.

- Near the end of the game, cooperating can help keep the stock from collapsing completely, improving the total payoff in final rounds if others cooperate or remain.

- No assumption is made about other players' strategies — this is a unilateral aggressive plan.

---

## Decision Rules

Let:

- **t** = current round number (1 ≤ t ≤ r)
- **S_t** = current stock at start of round t (known perfectly)
- **Remaining rounds after t** = (r - t)

### Rules:

1. **Round 1 to r-2** (all rounds except last two):

   - Always **Defect (D)**.

   - Reason: Maximize immediate payoff regardless of stock depletion.

2. **Round r-1** (penultimate round):

   - If stock S_r-1 is **above a threshold T**, **Cooperate (C)**; else Defect.

   - Threshold T defined as 0.5 × capacity (half the max sustainable stock).

   - Reason: If the stock is still substantial, cooperating helps preserve it for final round payoff; otherwise, continue to defect to maximize immediate gain.

3. **Round r** (last round):

   - Always **Cooperate (C)**.

   - Reason: No future rounds remain so cooperation reduces consumption (stock doesn’t matter anymore), but since payoffs depend on stock, cooperation yields a smaller immediate consumption, but if stock is low due to prior defections, mutual defection cannot reduce payoffs further.

   - Cooperating at last round is a slight concession that sacrifices immediate gain but might increase aggregate gain if stock survives.

---

## Edge Cases Handling

- **If stock is 0 or negligible (< ε) at any round:**

  - Cooperating or defecting yields zero payoff since no stock remains.

  - Continue defecting (by definition) to maintain “aggressive” posture, although payoff = 0.

- **If n or capacity change:**

  - The same principles hold; actions depend only on round number and stock compared to capacity.

- **If r = 2:**

  - Round 1: Defect

  - Round 2 (last): Cooperate

  - Strategy simplifies accordingly.

---

## Pseudocode Summary

```python
def aggressive_strategy(t, r, S_t, capacity, n):
    # Threshold for cooperation at penultimate round
    T = 0.5 * capacity
    
    if t < r - 1:
        # Early rounds: always defect
        return 'D'
    elif t == r - 1:
        # Penultimate round: cooperate if stock sufficiently high, else defect
        if S_t > T:
            return 'C'
        else:
            return 'D'
    else:  # t == r (last round)
        # Last round: always cooperate
        return 'C'
```

---

## Summary

- **Aggressively defect every round except the last two.**

- **At penultimate round, cooperate only if stock is sufficiently large (half capacity), else defect.**

- **Cooperate at the final round to maximize endgame payoffs and demonstrate limited restraint.**

- This guarantees highest immediate consumption early while retaining a minimal incentive to preserve resource near the end.

- Does **not** rely on others cooperating or any coordination.

- Aligns strongly with an aggressive mindset prioritizing short-term gain first, then limited cooperation at game end.

---

If you want, I can provide variations or elaborate on the reasoning for thresholds or alternative decision criteria.
'''

description_AGGRESSIVE_107 = '''
**Aggressive Strategy for the Common Pool Resource Game**

---

### Conceptual Overview
An aggressive strategy aims to maximize immediate personal payoff at the expense of the common resource and possibly others’ payoffs, accepting that severe depletion may occur. It prioritizes defecting to capture larger shares whenever conditions are favorable and only cooperates when defection is either impossible or strategically disadvantageous due to resource exhaustion.

---

### Key Characteristics

- **Defect by default (D)** to maximize immediate payoff (S/n per round) instead of cooperating (S/(2n)).
- **Exploit rounds with healthy stock by defecting.**
- **Cooperate only when the resource is so low that defection yields no advantage or quickly destroys the resource (last chance to get something).**
- **Do not attempt to foster cooperation or sustain the common stock for future rounds.**
- **In the last round, defect to maximize final payoff, since no future rounds remain.**
- **If the resource is already depleted or near zero, cooperate to avoid zero payoff or forced no-consumption rounds.**

---

### Formal Decision Rules

Parameters you know:  
- \( n \): number of players  
- \( r \): total rounds  
- Current round \( t \in \{1,...,r\} \)  
- Current stock \( S_t \) (before consumption in round \( t \))  
- Capacity \( C \)  

---

### Aggressive Strategy Decision Logic

1. **If \( t = r \) (Last Round):**  
   Always **Defect (D)** to maximize immediate payoff without concern for future rounds.

2. **Else if \( S_t \) is "healthy":**  
   Define "healthy" as:  
   \[
   S_t > \frac{n}{2} \quad \text{(i.e. stock can support defecting by all without immediate depletion)}
   \]

   Choose **Defect (D)** to maximize immediate payoff.

3. **Else if \( S_t \) is "low" but non-zero:**  
   If stock is too low to support multiple defectors without total depletion but still positive:  
   \[
   0 < S_t \leq \frac{n}{2}
   \]

   Choose **Cooperate (C)** to at least get some payoff and avoid accelerating full stock depletion that yields zero growth and zero payoffs next round.

4. **Else if \( S_t = 0 \):**  
   No stock means no payoff regardless, but since all actions consume from stock, action **does not matter**. Choose **Cooperate (C)** by default or randomly (no stock).

5. **Additional Rule:**  
   If previous round actions show all players defected and \( S_t \) plummeted, **keep cooperating** until stock regrows above threshold, then switch back to defecting.

---

### Pseudocode

```python
def aggressive_strategy(t, r, S_t, n, capacity, history):
    """
    Parameters:
    - t: current round (1-indexed)
    - r: total rounds
    - S_t: current stock before consumption
    - n: number of players
    - capacity: max sustainable stock
    - history: list of [(actions, payoffs, stock_after_round), ...] up to round t-1

    Returns:
    - action: 'C' or 'D'
    """

    # Last round: defect to maximize final payoff
    if t == r:
        return 'D'

    # Define threshold for "healthy" stock allowing defection
    defect_threshold = n/2  # halfway point to allow at least 2 defectors

    # If stock allows aggressive exploitation, defect
    if S_t > defect_threshold:
        return 'D'

    # If stock is low but positive, cooperate to extend resource
    elif 0 < S_t <= defect_threshold:
        return 'C'

    # If stock exhausted, cooperate (action irrelevant but cooperate to avoid zero stock consumption)
    else:  # S_t == 0
        return 'C'
```

---

### Explanation & Rationale

- Defecting when stock is sufficiently high allows capturing a larger share (S/n versus S/2n).  
- Cooperating when stock is very low prevents the resource from collapsing to zero immediately, allowing some regrowth and future consumption; this is "aggressive" only in maximizing expected future payoffs given low stock.  
- Always defect in the last round because future rounds do not exist, so harvesting maximum payoff now is best.  
- No attempt is made to punish or reward others. The strategy is purely self-serving and aggressive.  
- The threshold \( n/2 \) is a heuristic ensuring defection happens only while enough stock exists to exploit.

---

### Summary

| Condition                  | Action |
|----------------------------|--------|
| Last Round (t = r)          | Defect |
| Stock > n/2                 | Defect |
| 0 < Stock ≤ n/2             | Cooperate |
| Stock = 0                  | Cooperate (action irrelevant) |

This aggressive strategy exploits as much as possible while trying to avoid rounds with zero payoff due to complete stock depletion but never sacrifices own payoff for others or resource sustainability beyond what is minimally needed.
'''

description_AGGRESSIVE_108 = '''
**Aggressive Strategy Design for Common Pool Resource Game**

---

### Intuition & Rationale

An aggressive strategy in this repeated common pool resource (CPR) game aims to maximize individual short-term payoffs by defecting whenever beneficial, exploiting cooperators, and disregarding sustainability concerns unless stock depletion drastically limits payoffs or no future rounds remain. Given that defecting (D) yields higher immediate payoff than cooperating (C) for the same stock level, an aggressive strategy will:

- Always defect initially to capture high payoffs.
- Continue defecting while stock is abundant or there are enough rounds left to exploit the resource.
- Possibly shift behavior near the last round to maximize final payoff by defecting regardless of stock.
- Avoid cooperation unless forced by resource scarcity (to prevent zero payoff).
- Exploit all cooperators and defectors alike; never cooperate for collective benefit.
  
Since other players might try to cooperate or defect, this strategy bets on consistently defecting to harvest maximum payoff each round, accepting the risk of stock depletion.

---

### Key Observations

- Defecting consumes larger share: payoff = S/n vs cooperating payoff = S/(2n).
- Defectors cause faster stock depletion.
- Growth depends on remaining stock; stock can regenerate if not depleted.
- Stock capacity ≥ 2n ensures initial sustainable stock is reasonably large.
- Last round offers no future benefit; best to defect to maximize one-shot payoff.
- Perfect information means knowledge of all past actions and stock available.

---

### Strategy Components

---

#### State Variables (available each round `t`):

- Current round number `t` (1 ≤ t ≤ r)
- Remaining stock `S`
- Number of players `n`
- Capacity `capacity`
- History of all actions so far

---

#### Decision Rules

**At round t:**

1. **If t == r (last round):**
   - **Always Defect (D).** No future rounds; maximize immediate gain without concern for stock.

2. **Else if stock is critically low:**

   Define `threshold = capacity / (2n)` (roughly half of cooperative consumption per player in full stock)

   - If `S < threshold`, defecting now may cause stock to hit zero next round (zero payoff and no regrowth).

   **In this case:**
   - If defecting still yields positive payoff: defect.
   - Else cooperate to preserve stock slightly to ensure some payoff next round.
   
   *More simply: If defect payoff < cooperate payoff due to stock constraints, cooperate; else defect.*

3. **Else (stock is not critically low and not last round):**

   - **Always Defect (D).**

---

#### Summary:

- Defect first round and all rounds except last.
- Only cooperate if stock is extremely low and cooperating yields higher payoff than defecting for at least this round.
- Never cooperate to signal or sustain; only cooperate as reactive stock-preserving choice.
- Never cooperate preemptively or for reciprocity.
- Always maximize immediate payoff when possible.

---

### Pseudocode

```python
def aggressive_strategy(t, r, S, n, capacity):
    # Constants
    threshold = capacity / (2 * n)
    
    # Compute immediate payoffs
    payoff_defect = S / n
    payoff_cooperate = S / (2 * n)
    
    if t == r:
        # Last round: defect always
        return 'D'
    
    if S < threshold:
        # Stock critically low
        # Compare possible payoffs
        if payoff_defect >= payoff_cooperate and payoff_defect > 0:
            return 'D'
        else:
            # Cooperate to conserve or maximize payoff where possible
            return 'C'
    
    # Otherwise aggressively defect
    return 'D'
```

---

### Notes on Edge Cases & Behavior

- **First Round (t=1):** Stock = capacity (high), defect to maximize first round payoff.
- **Last Round:** No incentive to conserve; defect to maximize immediate payoff.
- **Low Stock:** Cooperate only if defecting yields no payoff but cooperating yields some positive payoff.
- **No cooperation for reputational or norm reasons:** Purely payoff-maximizing aggressive behavior.
- **Exploits cooperators by always defecting.**
- **Does not punish defectors with cooperation; defects regardless.**

---

### Strategic Justification

- Defecting captures twice the payoff per round vs cooperation.
- Depleting stock faster reduces future rounds’ gains, but maximizing present payoff aligns with aggressive mindset.
- By cooperating only when defecting payoff is effectively zero, it avoids total collapse for at least one extra payoff.
- Always defecting on last round ensures maximum clutch gain.
- Perfect information implies this approach is best given opponents unknown; cooperating risks exploitation without reciprocal benefit.

---

If you want, I can help with further refinements or a more sophisticated aggressive variant considering opponent modeling or probabilistic mixing.
'''

description_AGGRESSIVE_109 = '''
Here is a detailed design for an **aggressive strategy** in the specified Common Pool Resource game:

---

### Strategic Goal

Maximize **individual payoff** by consuming as much as possible, prioritizing defecting (D) to gain the highest payoff each round, while managing stock depletion risks only as necessary to maintain payoff flow as long as valuable.

---

### Core Idea of the Aggressive Strategy:

- **Always defect (D)** except possibly in the very **last round** or if the pool is nearly depleted.
- Do **not cooperate (C)** early or middle rounds because cooperation yields strictly lower payoff (S/(2n) < S/n).
- Avoid stock depletion only if the pool is effectively exhausted (stock too low to support defectors), in which case **cooperate** to preserve minimal payoff or accept the game-ending state.
- On the **last round**, defect if possible because no future rounds remain; if stock = 0 then cooperate is forced (but zero payoff either way).
- Exploit the initial high stock to maximize immediate gains—the aggressive mindset ignores sustainability except to the degree required to harvest payoff.

---

### Rationales & Assumptions:

- Defecting yields double the round payoff compared to cooperating if stock is positive.
- Since other players may act unpredictably, defecting assumes best immediate gain without costly "forgiveness" or "punishment."
- Growth function helps replenish stock if players cooperate or at least not all defect.
- No incentive to waste rounds cooperating since no communication/coordination and no binding agreements.
- When stock reaches zero, growth stops and future payoffs are zero—aggressive strategy does not delay this.
- Slightly soften aggression by cooperating only when defecting is impossible because of zero stock.

---

### Decision Rules Summary

| Condition                               | Action (Play)                    |
|---------------------------------------|---------------------------------|
| If round < r (not last round):        | Defect (D) if stock > 0         |
| If round < r and stock == 0:          | Cooperate (C) (forced by zero stock, else zero payoff anyway) |
| If round == r (last round):            | Defect (D) if stock > 0         |
| If round == r and stock == 0:          | Cooperate (C)                   |

---

### Pseudocode

```python
def aggressive_strategy(round_t, total_rounds, current_stock, n, capacity):
    """
    Decide action for player i in round round_t of total_rounds,
    with current common pool stock.
    """

    if current_stock <= 0:
        # Pool depleted, no payoff from defecting or cooperating, return cooperate as safe default
        return 'C'  

    if round_t < total_rounds:
        # Early or middle rounds: always defect while stock available
        return 'D'
    else:  
        # Last round: defect if possible for maximal payoff
        return 'D'
```

---

### Edge Cases Handling

- **Initial round (round 1):** Defect immediately. The stock is at capacity, so defecting yields maximum payoff (S/n), which is highest possible.
- **Last round (round r):** Defect if stock > 0, capturing maximal harvest before game ends.
- **Stock zero or negative:** Cooperate (forced safe fallback) but payoff is zero regardless.
- **Very low stock > 0:** Still defect, since payoff from defect is always higher than cooperate; aggressive strategy ignores sustainability short-term.

---

### Summary

- The strategy ignores cooperation incentives and tries to **extract maximum payoff every round** with defecting.
- It does not invest in stock preservation, so it will drive the resource toward depletion quickly if mirrored by others.
- It only cooperates in the trivial cases where defecting is impossible.
- This is a textbook "greedy defect" approach aligned with aggressive, exploitative mindset.

---

This aggressive strategy maximizes immediate gain, disregards others' payoffs, sustainability, or future cooperation beyond the game horizon.
'''

description_AGGRESSIVE_110 = '''
Below is a detailed design of an **Aggressive Strategy** for the described Common Pool Resource game.

---

### Strategy Intent and Summary

- **Core mindset:** Maximize own payoffs by defecting as much as possible.
- **Rationale:** Defecting yields a higher share of the current stock per round (S/n vs S/(2n)), so to be aggressive, we defect unless extreme caution is warranted.
- **Trade-off:** Excessive defection risks depleting the stock and losing future payoffs. The strategy attempts to minimize this risk only when the stock is critically low near the endgame.
- **No cooperation incentives:** This strategy never cooperates except as forced by stock impossibility or endgame survival concerns.
- **Exploiting others:** If others cooperate, defecting yields strictly higher payoffs.

---

### Key Decision Factors

- **Round number \(t\):** Current round index from 1 to \(r\).
- **Remaining rounds:** \(r - t + 1\).
- **Current stock \(S_t\).**
- **Capacity and parameters known: \(n, r, capacity\).**

---

### Decision Rules

| Condition                                   | Action        | Rationale                                    |
|---------------------------------------------|---------------|----------------------------------------------|
| **Round 1 (start of game)**                  | Defect (D)    | No history, be aggressive from start         |
| **Rounds 2 to \(r-1\):**                      | Defect (D)    | Stock usually sufficient; maximize payoff    |
| **Last round \(t = r\):**                     | Defect (D)    | No future rounds, extract maximum payoff     |
| **Stock \(S_t \leq \text{critical threshold}\):** | Cooperate (C) | Avoid full depletion to allow positive stock growth for survival next round if any |
| **Else:**                                     | Defect (D)    | Maximize immediate payoff                     |

---

### Critical Stock Threshold Calculation

- Since each defector consumes \(S_t / n\), total defection consumption is \(S_t\) (all \(n\) defect).
- If defecting depletes stock to 0 in next step, payoff in future round = 0.
- Cooperating reduces consumption to \(S_t/(2n)\) per cooperator, which helps sustain stock.
- Being aggressive, but smart: only cooperate if the current stock is so low that full defection wipes out the stock.

**Set critical threshold \(S_{\text{crit}} = n\).**

Why?

- Defection consumption per player = \( S_t / n \)
- For \( S_t \leq n \), consumption per defector ≤ 1
- More precisely, if \(S_t\) too low, defection leads to no future stock growth because of zero or near zero remaining stock.
- We pick a conservative threshold equal to the number of players.

---

### Detailed Rule to Handle Stock Dynamics Near Endgame

- If \(S_t > n\), defect freely.
- If \(S_t \leq n\), cooperate to slow down depletion or attempt to keep stock afloat for at least some payoff next rounds.
- Even if cooperating yields less immediate payoff this round (only \(S_t / (2n)\)), it preserves stock and thus future payoffs.
- Since the game has no communication or trust and everyone is likely aggressive, this behavior at low stock aims for self-preservation over greed.

---

### Edge Cases

- **First round:** No history, defect.
- **Last round:** Defect regardless of stock (no future).
- **Stock = 0:** Cannot consume, no payoff, cooperate by default (or defect, same payoff).
- **Near zero stock (very low):** Cooperate to avoid extinction, preserve future payoffs.

---

### Pseudocode

```
Inputs:
- t: current round (1 ≤ t ≤ r)
- S_t: current stock at round start
- n: number of players
- r: total rounds

Parameters:
- critical_threshold = n

Strategy:

function decide_action(t, S_t, n, r):
    if t == r:
        # Last round: defect to maximize immediate payoff
        return 'D'
    else if S_t <= critical_threshold:
        # Stock low: cooperate to sustain stock for future rounds
        return 'C'
    else:
        # Otherwise: defect aggressively
        return 'D'
```

---

### Additional Notes

- **History-insensitive:** The strategy ignores opponents' past actions to avoid complexity and possible manipulation.
- **Purely state-driven:** Relies only on round number and current stock.
- **Incentive alignment:** Exploits cooperators by defecting whenever possible.
- **Self-preserving:** Avoids total depletion unless forced at last round.

---

### Summary

This **Aggressive Strategy** defects every round unless the stock is critically low **before** the last round, in which case it momentarily cooperates to avoid total resource collapse and preserve some payoff in subsequent rounds. On the last round, it defects regardless to maximize extraction. This balances short-term greed with minimal long-term survival instincts under the constraints of perfect information and no communication.
'''

description_AGGRESSIVE_111 = '''
Here is an aggressive strategy tailored to the Common Pool Resource Game described, emphasizing maximizing immediate personal payoff by defecting whenever profitable while managing stock depletion to exploit opponents as much as possible.

---

## Aggressive Strategy Description

### Key Intuition
- **Focus on maximizing immediate round payoff** via defection (D).
- **Leverage the mutual dependence on the common pool by defecting early and often,** forcing the stock down to reduce returns to more "cooperative" players.
- **Exploit opportunities to defect without immediate game-ending stock depletion,** but do not cooperate for the sake of sustainability.
- **Use the first round to defect and establish aggressive intent.**
- **In the last round, defect again since future rounds do not matter.**
- Monitor stock levels to avoid **over-exploitation that causes the stock to collapse too early,** which hurts the total payoff.

---

### Overall Decision Rule

| Round   | Condition                          | Action        | Rationale                         |
|---------|----------------------------------|---------------|----------------------------------|
| 1       | Always                          | Defect (D)     | Establish aggression immediately |
| Intermediate rounds (2 ≤ t < r) | Stock is sufficient (> threshold)  | Defect (D)     | Maximize payoff, exploit pool if possible |
| Intermediate rounds (2 ≤ t < r) | Stock is low (≤ threshold)          | Cooperate (C)  | Slightly restrain depletion to keep stock viable |
| Last round (t = r)  | Always                          | Defect (D)     | Grab last-round maximum payoff   |

- **Threshold** is a stock level below which exploding stock in the next round is very likely if all defect. This can be approximated as a function of capacity and number of players. A practical value is:

  ```
  threshold := capacity / 4
  ```

  This means if the stock is below 1/4 the capacity, be slightly less aggressive and cooperate to avoid total collapse before the game ends.

---

### Step-by-Step Logic

1. **Round 1:**

   - **Action:** Defect (D)
   - **Why:** No prior history. Maximize immediate gains and assert dominance.

2. **Rounds 2 to r-1:**

   - **If current stock S_t > threshold:** Defect (D)
     - The stock is still rich enough to exploit.
     - Defect maximizes immediate payoff using S/n
     - Aggressive exploitation pressures others.

   - **If current stock S_t ≤ threshold:** Cooperate (C)
     - Stock is getting dangerously low.
     - Cooperate to moderate depletion so the pool is not exhausted too early.
     - This stabilizes the environment just enough to keep harvesting some payoff in future rounds.

3. **Round r (last round):**

   - **Action:** Defect (D) regardless of stock
   - **Why:** No incentive to preserve stock after final round, so maximize last-round payoff.

---

### Pseudocode

```python
def aggressive_strategy(round_t, S_t, capacity, n, r):
    threshold = capacity / 4  # threshold for stock to switch to cooperation

    if round_t == 1:
        return 'D'  # Always defect first round

    elif round_t == r:
        return 'D'  # Always defect last round

    else:
        # Intermediate rounds
        if S_t > threshold:
            return 'D'  # Defect while stock is sufficient
        else:
            return 'C'  # Cooperate minimally to avoid total collapse
```

---

### Explanation of Aggressiveness and Edge Cases

- **Aggressiveness:**
  - Always defect unless stock is dangerously low.
  - No attempts at generosity or attempts at long-term cooperation beyond minimal stock conservation.
  
- **First Round:**
  - No past information; defect outright to build early advantage.

- **Intermediate Rounds:**
  - Use a simple heuristic based on stock level.
  - Defect until stock is low, then cooperate to prevent instant ruin.
  - This is a pragmatic form of aggression: be ruthless but avoid self-sabotage.

- **Last Round:**
  - Absolutely defect; no future penalty.

- **Edge Case - Rapid Stock Collapse:**
  - If other players defect often, the strategy will react by switching to cooperation when the stock is low, slowing damage.
  - However, this cooperation is not generosity but survival-driven pragmatism.

- **Observation Usage:**
  - This strategy only uses **current round number and current stock**.
  - Does not rely on opponents’ past actions since no signaling or communication is possible.

---

## Summary

This aggressive strategy prioritizes:

- Defecting as much as possible to maximize immediate individual payoffs.
- Moderate cooperation only when stock stock level endangers the entire pool’s future.
- Defecting first round to signal aggression.
- Defecting last round to maximize total payoff without concern for sustainability.

It exploits the game’s payoff and stock dynamics while ensuring some minimal control to avoid mutually assured destruction too early.

---

If you want, I can help with further refinements or more complex adaptive variants, but this strategy should perform strongly in aggressive play contexts given the described rules and parameter constraints.
'''

description_AGGRESSIVE_112 = '''
**Aggressive Strategy Design for the Common Pool Resource Game**

---

### Strategy Intuition

An aggressive strategy aims to maximize immediate payoffs at the potential cost of long-term sustainability. In the context of this game:

- **Defecting (D)** yields higher immediate payoffs (S/n) compared to cooperating (C) (S/(2n)) in any round.
- Aggression means prioritizing the maximum extraction each round, regardless of consequences.
- To maximize advantage over others, the strategy should defect unless there is a tactical reason to temper defection (e.g., near the last rounds or depleted stock).

---

### Key Principles

1. **Maximize Immediate Extraction:** Always defect unless it is strategically beneficial otherwise.
2. **Exploit Cooperators:** When others cooperate, defect to get strictly greater payoff.
3. **Ignore Sustainability:** Do not cooperate to preserve stock; pushing stock to zero is acceptable.
4. **First Round:** Defect to claim maximum payoff immediately.
5. **Intermediate Rounds:** Defect consistently to maintain aggressiveness.
6. **Last Round (Round r):** Defect without reservation (no concern about stock post-game).
7. **Adjust if Stock is Almost Depleted:** If stock is zero or nearly zero, action is irrelevant—defect anyway.

---

### Decision Rule Summary

| Round     | Stock Condition         | Action  | Rationale                                         |
|-----------|------------------------|---------|--------------------------------------------------|
| 1         | Any                    | Defect  | Grab max payoff immediately                       |
| 2 to r-1  | Stock > 0              | Defect  | Aggressively harvest the resource                 |
| 2 to r-1  | Stock ≈ 0              | Defect  | No resource to consume, just defect for consistency|
| r (last)  | Any                    | Defect  | No future rounds, maximize final payoff          |

---

### Handling Edge Cases

- **Stock = 0 at start of round:** Defect still, no payoff means payoff zero, but no penalty.
- **Very low stock (near zero):** Defect anyway to maintain aggressive stance.
- **No memory or punishment:** No forgiveness or cooperation is attempted.
- **No conditional cooperation:** Does not adjust based on opponent past actions—purely aggressive.

---

### Pseudocode

```python
def aggressive_strategy(round_t, current_stock, total_rounds):
    """
    Determine action ('C' or 'D') in round t given current stock and total rounds.

    Inputs:
    - round_t (int): current round number (1-indexed)
    - current_stock (float): common pool stock at start of the round
    - total_rounds (int): total number of rounds r

    Output:
    - action (str): 'C' or 'D'
    """
    
    # Always defect aggressively
    action = 'D'
    
    return action
```

---

### Explanation

- **No cooperation phase:** Aggression means never cooperating.
- **No stock checks change behavior:** Even if the stock is depleted, defect anyway.
- **No endgame cooperation:** Since the last round is the final opportunity, always defect.

---

### Optional Variation: Aggressive with Minimal Stock Preservation (Not Required)

If moderation is permitted, sometimes preserving the stock for at least round 2 might be strategically beneficial. But given the instructions to be clearly aggressive, the simplest and purest approach is to always defect.

---

**Summary:**  
Your aggressive strategy always defects on every round, no matter the stock status or opponent behavior, to maximize immediate payoffs, even at the risk of collapsing the resource early.
'''

description_AGGRESSIVE_113 = '''
Below is a design for a fully **aggressive strategy** in the described Common Pool Resource Game. The aggressive mindset here means maximizing immediate payoff by defecting whenever it yields a higher expected payoff regardless of future consequences, with no concern for long-term sustainability or tacit cooperation.

---

## Aggressive Strategy Description

### Intuition
- Defecting (D) yields a higher immediate payoff per round than cooperating (C) given the current stock \( S \).
- Aggressive behavior means:
  - Always choose D (Defect) unless stock is so low that consuming \( S/n \) would exceed available stock (which is impossible since we consume from \( S \) itself).
  - No attempt to conserve the resource for future rounds.
  - No forgiveness, no retaliation, no cooperation signals.
- In the last round, defect to maximize immediate payoff with no concern for future impact.
- If stock is depleted or near zero, defecting yields zero, but the strategy still defect gamblers for maximizing immediate gain each round.

---

### Detailed Decision Rules:

1. **First Round (t = 1):**
   - Defect (D) immediately to maximize first-round payoff.

2. **Intermediate Rounds (1 < t < r):**
   - If stock \( S_t \geq 0 \), defect (D) to maximize immediate gain.
   - Always defect regardless of others' past actions or stock depletion rate.
   - No cooperation ever, to stay aggressive.

3. **Last Round (t = r):**
   - Defect (D) again for the highest last-round payoff.
   - No incentive to conserve stock on last round.

---

### Handling Edge Cases

- **Stock extremely low or zero:**
  - If \( S_t = 0 \), payoff is zero for both actions.
  - Still defect (D) as choice of C or D does not matter, but consistent with strategy.
- **Stock near zero but positive:**
  - Since consumption depends on \( S_t \), defecting yields \( S_t / n \), which is still maximal for immediate payoff.
- **No communication or inference:**
  - Strategy does not try to punish or reward opponents.
- **No probabilistic element:**
  - Deterministic aggressive defection every round.

---

## Pseudocode for Player i

```python
function aggressive_strategy(t, r, S_t, history):
    # t: current round index (1-based)
    # r: total rounds
    # S_t: current stock before action
    # history: list of past rounds of actions for all players (including self)

    # Always defect regardless of stock, round, or history
    return "D"
```

---

## Summary

| Round       | Stock \( S_t \) condition | Action   | Reason                          |
|-------------|---------------------------|----------|--------------------------------|
| Any round   | Any \( S_t \ge 0 \)        | Defect (D) | Maximize immediate payoff      |
| Last round  | Any                       | Defect (D) | No future, no conservation     |
| Any round   | \( S_t = 0 \)              | Defect (D) | No payoff, stay consistent     |

This strategy embodies aggression by **always defecting** to seize the largest immediate consumptions, ignoring any sustainability or cooperative benefits.

---

If you want a slight tweak to avoid impossible moves or technicalities:  
- If stock \( S_t = 0 \), you must choose D or C but both yield zero payoff; choose D for consistency.

---

Let me know if you want a more nuanced aggressive variant or exploration of alternative aggressive criteria!
'''

description_AGGRESSIVE_114 = '''
Here is a detailed aggressive strategy designed for the given Common Pool Resource Game. It prioritizes immediate high payoffs by defecting as much as possible, exploiting cooperators, and aiming to maximize own payoff with minimal regard for sustaining the resource or others.

---

### Aggressive Strategy Description

**Core idea:** Defect (D) as often as possible to maximize immediate payoff since defecting yields exactly double the per-round payoff of cooperating given the current stock. Accept the probable depletion of the resource over time as a consequence of aggressive defecting.

---

### Decision Rules

1. **Initial Round (t = 1):**  
   - Choose **Defect (D)**.  
     Rationale: No prior information about others; maximize first-round gain with maximal consumption.

2. **Subsequent Rounds (1 < t < r):**  
   - Observe previous round actions and stock level.
   - If stock is above a low critical threshold `stock_critical = capacity / (4n)` (e.g., quarter of per-player cooperative usage), **Defect (D)** again to maximize payoff.  
     Reason: Stock is still sufficient to consume heavily without collapsing immediately; no incentive to cooperate unilaterally.  
   - If stock <= `stock_critical`, switch to **Cooperate (C)** temporarily to slightly slow depletion, attempting to squeeze minimal remaining value before game ends.  
     Reason: If stock is near collapse, defecting yields no gain and everyone will get zero payoff; cooperating preserves some payoff on the last rounds.

3. **Last Round (t = r):**  
   - Defect (D) regardless of stock level.  
     Rationale: No future punishment or repercussions; exploit remaining stock fully.

---

### Rationale for Threshold

- `stock_critical = capacity / (4n)` is heuristic: it’s a small enough amount that consuming defectively will likely deplete resources fully and yield near-zero gains in future rounds.
- Switching to cooperate only near depletion is an attempt to eke out some payoff if others also shift toward cooperation or if the game hasn’t ended yet.

---

### Edge Cases

- **If `capacity` is exactly `2n` (the minimum allowed),** `stock_critical` becomes `capacity/(4n) = (2n)/(4n) = 0.5`. Thus cooperation threshold is at stock 0.5, effectively meaning only at near-zero stock cooperate.
- If in any round the stock hits zero, no further payoffs accrue and no actions matter.
- No reliance on opponent history beyond stock level and current round number.
- If others are ever fully cooperating all rounds, this strategy exploits by defecting early and repeatedly, capturing larger payoffs.
- No accommodation for complex contingent strategies (like tit-for-tat), since aggression prioritizes constant exploitation.

---

### Pseudocode

```python
def aggressive_strategy(round_t, total_rounds, current_stock, capacity, n):

    stock_critical = capacity / (4 * n)

    if round_t == 1:
        return 'D'            # Defect first round to gain maximum payoff

    elif round_t == total_rounds:
        return 'D'            # Defect last round and take all that remains

    else:
        if current_stock > stock_critical:
            return 'D'        # Stock sufficient, keep defecting for max payoff
        else:
            return 'C'        # Stock too low, cooperate briefly to conserve leftover stock
```

---

### Summary

- Always defect on the first and last rounds.
- Defect as long as the resource stock exceeds a low critical threshold.
- Only cooperate near depletion as a tactical concession.
- No forgiveness or cooperation ahead of time; fully exploit the stock and opponents.
- This is a pure aggressive, payoff-maximizing strategy that risks rapid stock depletion.

---

Let me know if you want me to expand to a more complex conditional aggressive strategy or provide any theoretical analysis.
'''

description_AGGRESSIVE_115 = '''
**Aggressive Strategy for the Common Pool Resource Game**

---

### Strategy Summary
This strategy prioritizes maximizing individual payoffs by defecting (D) aggressively whenever beneficial and cooperating (C) only when defecting would significantly reduce expected return due to stock depletion risks. It exploits the structure of the game to harvest maximum immediate payoff while managing stock to avoid a collapse that would end rewards prematurely.

---

### Key Intuition
- **Defecting pays more per round (S/n vs S/(2n)) but consumes the resource faster.**
- **Total defection leads to stock collapse and zero payoffs subsequently.**
- **Cooperating slows depletion, allowing the stock to regenerate, sustaining future payoffs.**
- **Aggression means defecting as often as possible, but not so recklessly that the resource collapses immediately.**

---

### Decision Rules

**Notation:**
- t = current round (1 to r)
- S_t = stock at start of round t
- n = number of players
- capacity = maximum stock
- history = full action history and stocks observed so far

---

#### 1. First Round (t = 1)
- Defect (D) always:  
  *Rationale:* Use initial full stock to maximize immediate payoff. Since no history is available, aggressive exploitation is optimal.

---

#### 2. Intermediate Rounds (1 < t < r)

**Calculate expected stock and payoffs under two scenarios:**

- **If defect this round:**  
  Consumption per player = S_t / n  
  Total consumption = n × (S_t/n) = S_t  
  Stock after consumption = 0  
  Growth = 0  
  New stock = 0 → stock collapses, no future payoff

- **If cooperate this round:**  
  Consumption per player = S_t / (2n)  
  Total consumption = n × (S_t / (2n)) = S_t / 2  
  Stock after consumption = S_t / 2  
  Growth = 2 × (S_t/2) × (1 - (S_t/2)/capacity) = S_t × (1 - S_t/(2capacity))  
  New stock = (S_t / 2) + growth = (S_t / 2) + S_t × (1 - S_t/(2capacity)) = S_t × (1.5 - S_t/(2capacity))

Expected payoff for player:
- Defect payoff = S_t / n  
- Cooperate payoff = S_t / (2n)

---

**Rule:**

- If defecting this round yields strictly higher immediate payoff than cooperating **AND** if the anticipated collapse (stock going to 0) occurs no earlier than the last round, defect.

- Otherwise, cooperate to sustain stock.

**Decision criteria concretely:**

- If we are in the **last round (t = r)**, defect to maximize last-round payoff.

- If **t < r**, defect only if  
  Depleting stock now (collapse next round) leads to no fewer total rounds benefiting us compared to cooperating.

- This translates to:

  - If defect now = get payoff S_t / n this round, but all future payoffs zero.
  
  - If cooperate now = get S_t / (2n) this round, and expect future payoffs (depending on new stock, which will be >0).

---

#### 3. Last Round (t = r)

- Defect (D) always:  
  *Rationale:* No future consequences after last round, so maximizing immediate payoff is best.

---

### Handling Edge Cases

- **If stock is very low (S_t nearly 0):** Cooperation cannot regenerate stock meaningfully; defect for immediate last fraction of payoff or cooperate if defect payoff is zero (stock=0).  
- **If opponent defection behavior observed leads to rapid stock depletion:** Strategy continues defecting when last round approaches; otherwise, defects until stock nears collapse and then switches to cooperation briefly to sustain stock.
- **In rounds when stock is very low but not zero, cooperate to prevent collapse only if enough rounds remain.**

---

### Pseudocode

```python
def aggressive_strategy(t, r, S_t, capacity, n, history):
    # t: current round (1-indexed)
    # r: total rounds
    # S_t: current stock at start of round
    # capacity: max stock
    # n: number of players
    # history: list of past rounds actions and stocks (not used explicitly here)
    
    if t == r:
        # Last round: always defect
        return 'D'
    
    defect_payoff = S_t / n
    cooperate_payoff = S_t / (2 * n)
    
    # Calculate stock if cooperate this round
    S_after_consume = S_t - (n * cooperate_payoff)  # = S_t / 2
    growth = 2 * S_after_consume * (1 - S_after_consume / capacity)
    new_stock_if_cooperate = min(S_after_consume + growth, capacity)
    
    # Calculate total expected payoff if cooperating now, then defect all remaining rounds
    # This is optimistic but fits aggressive mindset:
    # Round t payoff cooperating + (r - t) times defect payoff based on new stock
    
    # Payoff at round t cooperating:
    payoff_t_c = cooperate_payoff
    
    # For defect rounds t+1...r:
    # Approximate payoff assuming defecting with stock = new_stock_if_cooperate each time:
    # Note: This ignores further dynamics to keep it simple and aggressive
    payoff_future_d = (r - t) * (new_stock_if_cooperate / n)
    
    total_cooperate_then_defect = payoff_t_c + payoff_future_d
    
    # total payoff if defect now: payoff_t_d + 0 (because stock collapses)
    total_defect_now = defect_payoff
    
    # Aggressive decision rule:
    if total_defect_now >= total_cooperate_then_defect:
        return 'D'       # Defect to maximize immediate gain
    else:
        return 'C'       # Cooperate to preserve stock for future defecting rounds
```

---

### Explanation

- **First round:** Defect to harvest big immediate payoff.
- **Middle rounds:** Defect unless cooperating and subsequent defecting yields better total expected payoffs.
- **Last round:** Defect to extract maximum payoff since no future rounds exist.
- **Stock regeneration and collapse dynamics considered approximately to decide cooperation or defection.**
- **This strategy exploits others by defecting often but does not cause immediate collapse unless it's beneficial in total payoff.**

---

### Summary

This strategy is aggressive because it:

- Starts aggressive by defecting immediately.
- Continues defecting whenever it’s individually profitable to do so.
- Cooperates only to sustain stock long enough to enable profitable future defections.
- Defects definitively in the last round to maximize final gain.

It **does not attempt to establish cooperation or signal intentions** but calculates aggressiveness by maximizing individual round payoffs with minimal consideration for group welfare beyond sustaining payoff streams.

---

If you want me to help form a less myopic or more nuanced variant, just ask!
'''

description_AGGRESSIVE_116 = '''
Here's an **Aggressive Defector Strategy** designed specifically for the given Common Pool Resource Game. It maximizes individual short-term payoffs through strong defection without regard for joint sustainability or cooperation.

---

## Intuition and Reasoning

- **Aggressive mindset** means prioritizing maximum immediate gain.
- Defecting (D) always yields twice the payoff per round compared to cooperating (C) (S/n vs S/2n).
- The strategy never sacrifices short-term gain by cooperating.
- It exploits others who try to cooperate and punishes defectors by continuing defection—there is no incentive to cooperate because cooperating players have lower payoff and do not enable sustainability if others defect.
- The strategy recognizes that in the **last round**, the stock state no longer matters because no future payoff depends on it; therefore, full defection is optimal.
- In **early/mid rounds**, continue defecting to maximize payoff and hasten resource depletion to gain the relative advantage.

---

## Strategy Description

### Decision Rules

- **Round 1:** Defect (D)
- **Intermediate Rounds (2 to r−1):** Defect (D) regardless of past history or current stock
- **Last Round (r):** Defect (D)

### Additional Considerations

- **No cooperation tolerance:** No matter what other players did in previous rounds, never cooperate.
- **Ignoring stock dynamics:** Aggressiveness disregards long-term sustainability; will exploit the resource aggressively even if it crashes early.
- **Full defection from start to finish**

---

## Pseudocode

```pseudo
Inputs: 
- n (number of players), r (total rounds), t (current round)

For each round t in 1 to r:
    action = D  # Always defect

    Output action
```

---

## Explanation

- Since defecting yields a payoff of S/n > S/(2n) from cooperating, defecting is individually dominant round-by-round.
- By consistently defecting, the strategy maximizes its personal payoff each round.
- Even if this leads to rapid depletion of the common pool (eventually reducing payoffs to zero), the strategy is indifferent since it does not plan for future cooperation benefits.
- The last round is particularly important: defecting can extract maximum payoff safely without concern for future rounds.
- This applies regardless of opponents’ behavior or the current stock level.
- Opponents that cooperate get exploited; opponents that defect experience a race to the bottom but this strategy never yields.

---

## Summary

| Round         | Action  | Reasoning                                             |
|---------------|---------|-------------------------------------------------------|
| 1             | Defect  | Maximize immediate payoff, no reason to cooperate     |
| 2 to r-1      | Defect  | Maintain aggression, no cooperation expected or rewarded  |
| r (last round) | Defect  | Final chance to extract maximum payoff without future cost |

---

This **pure defector** strategy is the archetype of aggressiveness: it relentlessly pursues maximum extraction with no reciprocal cooperation, no forgiveness, and no sustainability concerns.
'''

description_AGGRESSIVE_117 = '''
Below is a detailed aggressive strategy for the Common Pool Resource Game, including rationale and decision rules. It is designed to maximize individual payoff by aggressively defecting to consume the resource at the highest possible rate, while exploiting early cooperation from opponents if any, and exploiting end-game effects to maximize final payoffs.

---

## Aggressive Strategy: "Unrestrained Defector with Opportunistic Exploitation"

### High-Level Description
- **Default aggressive stance:** Defect (D) every round to maximize immediate payoff.
- **Exploit cooperation:** If opponents have cooperated before, defect to earn the immediate higher payoff and accelerate depletion.
- **No forgiveness:** Never cooperate except in forced or strategic edge cases.
- **Exploit last rounds:** In the final round, defect unconditionally since no future punishment or retaliation is possible.
- **Handle first round:** Defect from the start to signal aggressive intent and harvest maximum payoff early.
- **Leverage knowledge of stock dynamics:** Accept the resource depletion as a trade-off for maximizing own consumption per round.
  
---

### Concrete Decision Rules

| Round       | Condition                                | Action  | Rationale                                           |
|-------------|-----------------------------------------|---------|-----------------------------------------------------|
| Round 1     | —                                       | Defect  | No prior info; maximize first-round gain            |
| Intermediate rounds (2 to r-1) | Observe history of actions of opponent(s)    | Defect  | Aggressive, exploit any cooperation; no cooperation given |
| Final round (r) | —                                      | Defect  | End game defect; no incentive to cooperate           |

---

### Edge Cases and Special Handling

- **If stock reaches zero or near zero:** Continue defecting because cooperation yields very low payoffs anyway; the game is essentially lost for all players.
- **If stock is extremely low such that payoff from defecting is less than cooperating:** Still defect because payoff from defecting (S/n) ≥ cooperating (S/(2n)), and no incentive to cooperate.
- **If capacity or number of players allow weird divisions:** No change; defect action always consumes S/n, which is highest per-round payoff.
- **No cooperation-based forgiveness or gradual shifting:** Aggressive means no concessions or signals; stay defecting throughout.

---

### Pseudocode of the Strategy

```
Input: 
  r (number of rounds)
  current_round t ∈ {1,...,r}
  history: list of opponent actions from previous rounds
  current_stock S
  n (number of players)
  capacity

Output:
  action ∈ {C, D}

Algorithm:

function aggressive_strategy(t, history, S, n, capacity):
    # Always defect regardless of history or stock level
    return "D"
```

---

### Explanation

- The payoff from defecting is always double the payoff from cooperating (since π_i(D) = S/n and π_i(C) = S/(2n)).
- Defecting accelerates depletion of the stock, which is consistent with an aggressive mindset prioritizing immediate gain.
- The strategy does not waste rounds cooperating or trying to "sustain" the resource.
- No attempts to "punish" or "reward" opponents; no conditional cooperation.
- Exploits opportunities where others might cooperate in early rounds.
- Ends with defect to maximize terminal payoff.
- Simplistic but robust given perfect information and no communication.

---

### Summary

This aggressive strategy is a pure defector that maximizes per-round extraction by choosing D every round, embracing depletion, maximizing immediate payoffs, and not adhering to any norms or sustainable use concepts. It takes advantage of the multiplicative advantage of defecting payoffs and views the resource as a rivalrous good to be harvested aggressively.

---

If you want any refinement or an alternative variant, feel free to ask!
'''

description_AGGRESSIVE_118 = '''
**Aggressive strategy for the Common Pool Resource Game**

---

### Intuition and Overview

The game pits immediate individual payoff against long-term sustainability of the resource. Defection (D) always yields higher payoff than cooperation (C) *in the same round*, but risks depleting the resource by the end of the game, reducing future payoffs.

An **aggressive strategy** here focuses on maximizing total individual payoff, prioritizing high exploitation early and taking advantage of opponents who cooperate or "ease off." It:

- Defects unless the resource is critically depleted, then cooperates just enough to possibly delay resource collapse for marginal gain.
- Exploits cooperators by defecting persistently.
- Ends aggressively to extract maximal payoff before the game ends since no future retaliation is possible.

---

### Strategy Description

#### Notation

- Let t ∈ {1,...,r} be current round.
- Let S_t be current stock at the start of round t.
- Let actions_{-i,t-1} be other players' actions in previous round (if t > 1).
- Define **critical threshold** \( S_{crit} = \frac{capacity}{4} \) (tunable, e.g., 1/4th capacity).

---

### Decision Rules

1. **First round (t=1):**  
   - Defect (D) to maximize initial payoff and establish aggressive stance.

2. **Intermediate rounds (1 < t < r):**  
   - If stock \( S_t > S_{crit} \): defect (D)  
     Rationale: Stock is sufficient to exploit aggressively.  
   - Else if \( S_t \leq S_{crit} \) (stock is low): cooperate (C)  
     Rationale: Attempt minimal conservation to delay collapse and eke out some payoff in next round(s).

3. **Last round (t = r):**  
   - Defect (D) regardless of stock level.  
   Rationale: No future rounds, so no future penalty or cooperation gain. Extract maximum immediately.

---

### Handling Edge Cases

- **Stock depleted to zero or near zero:**  
  Once \( S_t = 0 \) (or effectively zero), action no longer matters (payoff is zero), but for consistency defect anyway.

- **If observing other players' history:**  
  This strategy ignores opponent history because it is purely aggressive and self-interested — no incentive to cooperate or punish.

---

### Pseudocode

```python
def aggressive_strategy(t, r, S_t, capacity):
    S_crit = capacity / 4  # critical low-stock threshold

    if t == r:
        # Last round: defect to maximize final payoff
        return "D"
    elif t == 1:
        # First round: start aggressively
        return "D"
    else:
        # Intermediate rounds
        if S_t > S_crit:
            # Stock ample - defect aggressively
            return "D"
        else:
            # Stock critical - cooperate minimally to delay collapse
            return "C"
```

---

### Summary

| Round          | Condition                    | Action  | Reason                                              |
|----------------|------------------------------|---------|-----------------------------------------------------|
| 1 (start)      | Always                       | D       | Maximize early payoff                                |
| Intermediate   | Stock > capacity/4            | D       | Exploit shared resource aggressively                 |
| Intermediate   | Stock ≤ capacity/4            | C       | Conserve slightly to marginally sustain resource    |
| Last round (r) | Always                      | D       | Extract maximum payoff; future irrelevant            |

---

This strategy aggressively defects to harvest maximal payoff early, only backing off when resource danger of stock collapse is significant, and always defects in the last round to maximize final extraction. It does not attempt to punish or reward others, assuming other players are equally self-interested or uncooperative.
'''

description_AGGRESSIVE_119 = '''
Here is an **Aggressive Strategy** designed for the Common Pool Resource game under the given specifications:

---

### Strategy Overview

The fundamental principle of this aggressive strategy is **to maximize immediate payoff by defecting (D) whenever the resource stock allows** while carefully monitoring stock depletion to avoid losing all future payoffs. The aggressor exploits cooperators but defects preemptively if the resource is likely to collapse due to over-extraction. The strategy does **not** seek to sustain cooperation or protect the resource long-term but does prevent outright ruin until the last rounds to reap maximum rewards.

---

### Intuition

- Defect (D) to take larger individual payoffs, especially early and mid-game.
- Cooperate (C) only when the stock is dangerously low, to preserve some growth and avoid complete exhaustion—maximizing score over rounds.
- In the **last round**, defect always to capture every possible payoff regardless of stock depletion since no future rounds exist.
- Always observe total consumption from previous rounds (via other players’ actions) and the current stock to guess sustainability.
- Exploit cooperators by defecting whenever possible because defecting yields double the payoff of cooperating for the same stock.
- If stock is already too low to safely defect (would deplete to zero or near zero after all defect), switch to cooperating to avoid destroying the resource entirely.

---

### Formal Decision Rules

Let:  
- Round index `t` (1 to r)  
- Current stock at round start: `S`  
- Number of players: `n`  
- Remaining rounds (including current): `R = r - t + 1`

Define thresholds:  
- **Critical low stock** threshold, below which defecting will cause the pool to collapse:  
  \[
  S_{\text{critical}} = \frac{S}{n} \times n = S
  \]
  i.e. if `S` ≤ 0, no resource left anyway; more nuanced below.

- Estimate expected total consumption if everyone defects:  
  \[
  C_{\text{defect total}} = n \times \frac{S}{n} = S
  \]
  This consumes entire stock.

- Similarly, total consumption if everyone cooperates:  
  \[
  C_{\text{cooperate total}} = n \times \frac{S}{2n} = \frac{S}{2}
  \]

Because defecting by all causes total depletion, the stock after depletion and growth is zero if all defect. Our strategy assumes others are unknown — if others have mostly cooperated (low depletion), stock will be higher; if others defect, stock falls fast.

---

### Detailed Decision Logic

**At round t (1 ≤ t ≤ r):**

1. **If t == r (Last Round):**  
   - **Always Defect (D)** to maximize final round payoff.

2. **Else if stock S is very low:**  
   Define a *safe defect threshold* as minimal stock allowing defecting without immediate collapse:  
   \[
   S_{\text{safe}} = \text{some fraction} \times capacity, \text{ e.g., } 0.2 \times capacity
   \]
   - If \( S < S_{\text{safe}} \), defecting risks zero stock next turn; **Cooperate (C)** to preserve resource and secure any positive payoff next round.
   
3. **Else if previous round had mostly defectors:**  
   We can infer it from history: if majority defected, stock likely to plunge further; switch to cooperate to limit own losses.

4. **Otherwise (stock safe and no majority defectors last round):**  
   - **Defect (D)** to extract maximal payoff.

---

### Pseudocode

```python
def aggressive_strategy(t, r, n, capacity, S, history):
    # history: list of previous rounds' actions for all players
    # history[t-2] contains actions at round t-1 (if t > 1)
    
    SAFE_THRESHOLD = 0.2 * capacity  # Tuneable parameter
    
    # Last round: always defect
    if t == r:
        return 'D'
    
    # If stock very low, cooperate to preserve resource
    if S < SAFE_THRESHOLD:
        return 'C'
    
    # If previous round exists, check opponent behavior
    if t > 1:
        last_round_actions = history[t-2]
        num_defect_last_round = sum(1 for a in last_round_actions if a == 'D')
        # If majority defected last round, resource likely dropping fast
        if num_defect_last_round > n / 2:
            # Cooperate to slow collapse, secure some payoff next round
            return 'C'
    
    # Otherwise, aggressively defect to maximize immediate payoff
    return 'D'
```

---

### Additional Notes on the Strategy

- **First round:** No history; stock is at capacity, so defect to harvest maximal payoff.
- **Mid-game:** Monitor opponent defections to gauge sustainability and switch to cooperate if too many aggressors detected.
- **Last round:** Defect no matter what, since no future payoff is lost.
- **Stock thresholds:** The choice of `SAFE_THRESHOLD` balances aggressive extraction with resource preservation just enough to continue harvesting.
- **No forgiveness:** The strategy is not trying to promote cooperation, only to delay resource exhaustion enough to maximize returns.
- **Assumes rational but unknown opponents:** Cannot assume cooperation; punishes defection by cooperating when collapse imminent to survive longer.

---

### Summary

| Situation                      | Action   | Reason                                    |
|-------------------------------|----------|-------------------------------------------|
| Last round                    | Defect   | Maximize last-round payoff                 |
| Stock below safe threshold    | Cooperate| Preserve resource for future payoffs      |
| Majority defectors last round | Cooperate| Avoid resource collapse, secure next payoff|
| Otherwise                    | Defect   | Aggressively maximize immediate payoffs   |

---

This strategy embodies an aggressive player who pushes resource extraction hard but is aware of impending collapse and softens just enough to extend survival and maximize cumulative payoff. It exploits cooperators and punishes mass defection to survive longer in a hostile population.
'''

description_AGGRESSIVE_120 = '''
Here is a detailed aggressive strategy for the Common Pool Resource Game based on the specification. The focus is on maximizing individual payoffs aggressively, without regard for long-term sustainability beyond what is self-serving within the multi-round horizon.

---

## Strategic Rationale

- **Aggressive mindset:** Maximize immediate gains by defecting (consuming more) whenever it is beneficial.
- **First round:** No history; default to defect to maximize initial payoff.
- **Middle rounds:** Defect unless the stock becomes critically low—then switch behavior briefly to limit total collapse.
- **Last round:** Defect regardless since there is no future to preserve the stock.
- **Edge cases (low stock):** If stock is near zero or very small, defecting yields no payoff; cooperate (consume less) to allow stock to regrow slightly and get some payoff before game ends.
- **No cooperation or forgiveness:** This is a purely aggressive strategy highlighting exploitation, not sustainability or tit-for-tat reciprocity.

---

## Definitions

- Let:
  - `S_t` = stock at start of round `t`
  - `c = capacity`
  - `n = number of players`
  - `r = total rounds`
  - `threshold = capacity / (4 * n)` (a heuristic cutoff for "too low" stock)

---

## Decision Rules (pseudocode)

```
function decide_action(t, S_t, history):
    # Inputs:
    # t: current round number (1-based)
    # S_t: current stock before round t (float)
    # history: list of all previous rounds' actions & stock (not actually used here except for S_t)
  
    # 1. Always defect on first round to maximize initial payoff
    if t == 1:
        return 'D'
    
    # 2. Always defect on last round (no future penalty)
    if t == r:
        return 'D'

    # 3. Middle rounds:
    #    If stock is above threshold, defect to maximize payoff
    if S_t > threshold:
        return 'D'

    # 4. If stock is critically low (below or equal threshold):
    #    Cooperate to consume less, allowing stock to grow and possibly get payoff in future rounds
    else:
        # This is a concession to avoid zero payoffs due to stock collapse
        return 'C'
```

---

## Explanation

- **First round:** No history to condition on; defect immediately to take the bigger payoff.

- **Last round:** No incentive to conserve stock; always defect.

- **Middle rounds:** Defect aggressively if stock allows (stock above threshold) to harvest high payoffs.

- **Stock low:** If stock falls dangerously low (heuristically when `S_t` ≤ `capacity / (4n)`), cooperate to consume less, aiming to let stock regrow slightly and secure any payoff in remaining rounds.

---

## Additional Notes on Parameter Choices

- The `threshold` choice (`capacity / (4n)`) is empirical:
  - It is a small fraction of capacity scaled by player count.
  - It approximates a stock level below which defecting produces very low or zero payoffs.
  - This parameter could be tuned if prior knowledge or simulation data is available, but within given constraints, this is a reasonable heuristic.

---

## Summary

| Round        | Stock level condition    | Action       | Rationale                           |
|--------------|-------------------------|--------------|-----------------------------------|
| First round  | Any                     | Defect (D)   | Maximize immediate payoff         |
| Last round   | Any                     | Defect (D)   | No future to protect              |
| Middle round | Stock > threshold        | Defect (D)   | Harvest as aggressively as possible |
| Middle round | Stock ≤ threshold       | Cooperate (C)| Conserve stock minimally when critical |

---

**This strategy ensures:**

- Always maximizes immediate extraction whenever feasible.
- Minimal concessions only when stock depletion threatens to wipe out all payoffs.
- No trust or cooperation beyond self-interest.

---

If you want, I can also supply this as fully detailed pseudocode or flowchart. Just ask!
'''

description_AGGRESSIVE_121 = '''
**Aggressive Strategy for Common Pool Resource Game**

---

### Key Design Principles

- **Aggressive Mindset:** Maximize immediate payoff by defecting (D) as often as possible, extracting the largest allowed individual share each round.
- **Exploitation Focus:** Exploit cooperating players by defecting to get twice the payoff per round than they do.
- **No Collaboration:** No cooperation by default, since others' cooperation harms your payoff relative to defecting.
- **Retaliation and End-Game Considerations:** Since the game is finite-horizon, defect in last round for sure. Optionally defect early to prevent forgiving/cooperation incentives.
- **Reactive Defection:** Detect if others defect consistently and continue defecting to avoid being exploited.
- **Tolerance for Stock Depletion:** Willing to drive the stock down aggressively to maximize own payoff, accepting potentially zero future payoffs if others defect.
- **Use observed history only:** Strategy depends only on running record of actions by all players.

---

### Strategy Description

Let:
- \( t \) = current round (1 to \( r \))
- \( n \) = number of players
- \( H_{<t} \) = full history of all players’ actions in rounds < \( t \)
- \( S_t \) = stock at start of round \( t \) (observed after previous round)
- \( A_i^t \) = player \( i \)'s action chosen for round \( t \)

---

### Decision Rules

**Round 1:**

- Defect (D).
- Rationale: Establish aggressive stance immediately; no prior info.

---

**Rounds 2 to \( r-1 \):**

- If any player defected in previous round, defect.
- Else defect (do not cooperate).
- Rationale: Assume all others are exploiting or likely to exploit; no incentive to cooperate.

---

**Round \( r \) (Last Round):**

- Defect.
- Rationale: No future punishment possible; maximize immediate payoff.

---

**Summary:**

- Always defect at every round regardless of history.
- Use history to confirm others' behavior, but do not change your defection.
- No forgiveness or cooperation attempts.

---

### Pseudocode for Player \( i \):

```python
def aggressive_strategy(t, r, n, H):
    # H is list of past rounds, each round is list of actions by players [A_1^(t-1), ..., A_n^(t-1)]
    
    # 1. On first round, defect immediately
    if t == 1:
        return 'D'
    
    # 2. Other rounds, check if any defected previously (not necessary for defection, but could be used)
    previous_round = H[t-2]  # zero-indexed
    
    # The aggressive strategy ignores cooperation attempts and always defects
    return 'D'
```

---

### Rationale and Analysis

- **Aggressive**: Always defecting consumes the maximum permissible share (stock / n), gaining highest payoff per round individually.
- **Exploitation**: If opponents cooperate (consume stock/(2n)), aggressive strategy players get double their payoff.
- **Stock Impact**: This approach depletes the stock faster, possibly to zero before game ends if many defect.
- **Future Payoff Neglect**: Aggressive player prioritizes immediate gain over sustainability of stock and long term returns.
- **No Punishment or Forgiveness** needed since no intention to cooperate.
- **No Risk of Being Exploited**: Always defecting avoids being exploited by defectors, since defect dominates cooperate in immediate payoff.

---

### Edge Cases

- **All players defect:** stock likely crashes to zero early, payoffs drop, but aggressive player still maximizes immediate gain each round.
- **All players cooperate:** aggressive player defects, earns more while stock sustains well initially but may decline later faster.
- **Mixed behavior:** aggressive player exploits cooperators and matches defectors, always defecting.
- **Last round:** defect, no incentive for cooperation.
- **First round:** defect, establish dominance immediately.

---

### Summary

| Round            | Action            | Reason                                                             |
|------------------|-------------------|--------------------------------------------------------------------|
| \( t=1 \)        | Defect (D)        | Establish aggressive stance immediately                            |
| \( 1 < t < r \)  | Defect (D)        | Always exploit; no cooperation trust                              |
| \( t = r \)      | Defect (D)        | Last round defect to maximize immediate payoff                   |

---

This simple always-defect strategy exemplifies hardline aggression aligned with maximizing immediate individual gains and no concern for sustainability or cooperation. It is robust under all assumptions and is optimized for sole payoff maximization in a multi-round repeated CPR game.
'''

description_AGGRESSIVE_122 = '''
Below is an aggressive strategy proposal aligned with your specifications and the game environment. This strategy prioritizes maximizing short-term individual payoff by defecting whenever possible but prudently uses cooperation only to sustain the resource enough to keep extracting payoff in future rounds. It will aim to exploit potential cooperators but avoid complete resource collapse (and thus zero payoffs at the end).

---

## Aggressive Strategy: "Defect-Then-Punish-With-Limited-Cooperation"

### Intuition:
- Start by defecting to gain maximal immediate payoff.
- Observe others’ behaviors to potentially exploit cooperators.
- If the stock is critically low near the end or after severe depletion, cooperate just enough to allow stock regeneration but never fully cooperate.
- If others defect heavily, continue defecting aggressively.
- Avoid total resource collapse to ensure nonzero payoffs in late rounds.

---

### Detailed Decision Rules

Let:
- **t:** current round (1 ≤ t ≤ r)
- **S_t:** common pool stock at start of round t
- **actions_history:** matrix of all players’ actions in previous rounds (t-1 rounds)
- **my_action(t):** action selected this round by me
- **threshold_stock_low:** a safety threshold (for example, set to n, the number of players) to decide if stock is dangerously low
- **defectors_last_round:** number of players who defected in round t-1 (if t > 1)

---

### 1. First Round (t=1)

- **Action:** Defect (D)
- Rationale: No information yet, aggressive start to maximize first-round payoff.

---

### 2. Intermediate Rounds (1 < t < r)

Decision process:

- Calculate number of defectors in last round:

  ```
  defactors_last_round = count of players choosing D in round t-1
  ```

- Take aggressive approach but avoid complete collapse:

  ```
  if S_t > threshold_stock_low:
      # Stock healthy enough to attempt aggressive harvesting
      
      if defectors_last_round >= n/2:
          # Many defectors last round, exploit them by defecting again
          action = D
      else:
          # Moderate cooperation, but exploit for short-term gain
          action = D
  else:
      # Stock dangerously low, cooperate just enough to allow some regeneration
      
      # Two cases:
      # - If near end of game, defect to maximize last payoff (stock likely near zero or soon to be)
      # - Otherwise, cooperate to allow limited regeneration
      
      if t == r - 1:
          # Penultimate round: defect to maximize final payoffs before game ends
          action = D
      else:
          # Cooperate to sustain stock for another round
          action = C
  ```

- This logic results in consistent defecting when the stock is healthy, but a limited and tactical cooperation phase to avoid game-ending collapse, enabling future payoffs.

---

### 3. Last Round (t = r)

- Always **Defect** to maximize final round individual payoff, since there is no future game state to protect.

---

### 4. Edge Cases

- If stock S_t reaches zero or less after previous round, defect anyway (though payoff = 0), since cooperating provides no benefit.

- If capacity is very large relative to n (capacity >> 2n), stock depletion takes longer; so aggressive defecting for longer.

---

### Pseudocode Summary

```python
def aggressive_strategy(t, r, n, capacity, S_t, actions_history):
    threshold_stock_low = n  # Can tune this parameter
    
    if t == 1:
        # First round: defect aggressively
        return 'D'
        
    elif t == r:
        # Last round: defect to maximize payoff
        return 'D'
        
    else:
        # Count defectors in last round
        last_round_actions = actions_history[t - 2]
        defectors_last_round = sum(1 for a in last_round_actions if a == 'D')
        
        if S_t <= 0:
            # Pool depleted, defect (no benefit cooperating)
            return 'D'
            
        if S_t > threshold_stock_low:
            # Stock healthy: maximize short-term gain
            return 'D'
        
        else:
            # Stock low, consider limited cooperation to sustain resource
            if t == r - 1:
                # Penultimate round: defect for maximum last payoffs
                return 'D'
            else:
                # Cooperate to enable some regeneration for next round
                return 'C'
```

---

### Explanation of Aggressiveness

- Your default action is to defect every round except in clear cases where the stock is low and the game is not at the penultimate or last round.

- It exploits cooperative players who take C actions, by defecting and receiving double payoff in current round.

- It does not rely on reciprocity or forgiveness. It defects whenever possible, only switching to cooperate briefly in a tactical, minimal way to avoid zero future payoffs.

- The threshold-based limited cooperation keeps the stock from collapsing immediately, providing some sustainability for future extraction.

---

### Possible Variations / Tuning

- The threshold `threshold_stock_low` can be tuned for different levels of risk tolerance (e.g., 1.5 × n).

- More sophisticated variants can track past defector proportions more finely, but aggressive behavior means always pushing to defect unless forced.

---

If you want, I can suggest extensions or provide a fully commented pseudocode version tuned for implementation.
'''

description_AGGRESSIVE_123 = '''
**Aggressive Strategy for Common Pool Resource Game**

---

### Goal and Mindset
Maximize own payoff by exploiting the common pool aggressively, prioritizing short-term gain through frequent defection (D), while balancing against risking total resource collapse, particularly near the end of the game when future payoffs become irrelevant.

---

### Intuition and Rationale

- **Defect (D)** yields twice the payoff as cooperate (C) per round, assuming the stock is sufficient.
- Excessive defection leads to stock depletion and zero payoffs in future rounds.
- Cooperating slows stock depletion but reduces immediate payoff.
- An aggressive strategy minimizes cooperation but avoids total collapse too early to capture payoffs in future rounds.
- The last round is an all-out defect (D) round because no future rounds remain to lose stock value.

---

### Decision Rules

1. **Round 1:** Defect (D) unconditionally to maximize initial payoff.
2. **Rounds 2 to r-1:**
   - Observe previous round stock \( S_{t-1} \).
   - Calculate expected post-consumption stock if everyone defects:
     \[
     S' = \text{new\_stock after all defect}
     \]
   - Calculate expected post-consumption stock if you defect and all others cooperate:
     \[
     S'' = \text{new\_stock after you defect, others cooperate}
     \]
   - **If defecting this round likely leads to near-zero stock next round (i.e., \( S' \) or \( S'' \) close to 0), defect if we are near game end (round \( r-1 \)), else cooperate once to sustain stock.**
   - Else defect.
3. **Round r (last round):** Defect (D) unconditionally to exploit remaining stock.

---

### Key Implementation Details

- The stock \( S \) is publicly observed at the start of each round.
- Given perfect information and knowledge of actions, assume others may also defect.
- Cooperate only when defecting would cause collapse before the last round, sacrificing one round's short-term gain to enable positive payoffs later.
- Otherwise, defect aggressively every round.

---

### Pseudocode

```python
function aggressive_strategy(t, r, n, capacity, S):
    # t = current round (1-based)
    # r = total rounds
    # n = number of players
    # capacity = resource capacity
    # S = current stock at start of round t

    # Consumption per player if cooperates: S / (2 * n)
    coop_consume = S / (2 * n)
    # Consumption per player if defects: S / n
    defect_consume = S / n

    # Helper function: compute next stock given distribution of cooperating/defecting players
    # Inputs: number of defectors d (including self if defecting)
    def next_stock(S_current, total_defectors):
        total_cooperators = n - total_defectors
        total_consumption = total_cooperators * (S_current / (2 * n)) + total_defectors * (S_current / n)
        S_after_consume = max(S_current - total_consumption, 0)
        growth = 2 * S_after_consume * (1 - S_after_consume / capacity)
        new_S = min(S_after_consume + growth, capacity)
        return new_S

    # Round 1: always defect
    if t == 1:
        return 'D'

    # Round r: last round, always defect, no future penalty
    if t == r:
        return 'D'

    # Anticipate next stock if all defect next round
    all_defect_next_stock = next_stock(S, n)

    # Anticipate next stock if I defect and others cooperate (best for me this round)
    # Number of defectors = 1 (me) + (n-1)*0 = 1
    me_defect_others_coop_next_stock = next_stock(S, 1)

    # Anticipate next stock if I cooperate and others defect (worst for me)
    # Number of defectors = n-1
    me_coop_others_defect_next_stock = next_stock(S, n-1)

    # Threshold to consider stock "collapsed"
    COLLAPSE_THRESHOLD = capacity * 0.05  # e.g., 5% of capacity

    # Near last round? 
    close_to_end = (t == r - 1)

    # Decision logic:
    # If defecting this round risks near-zero stock next round, and not last round, cooperate once
    if (me_defect_others_coop_next_stock < COLLAPSE_THRESHOLD) and (not close_to_end):
        return 'C'

    # Otherwise, defect aggressively
    return 'D'
```

---

### Explanation

- **First round defect:** Grab maximum payoff immediately.
- **Intermediate rounds:** Mostly defect but cooperate once if my defection would cause a likely stock collapse that cuts off future gains prematurely.
- **Last round defect:** Exploit whatever remains, no future penalty.

---

### Summary

This strategy:

- Is aggressively exploitative by default.
- Uses a simple stock sustainability check to decide when to cooperate, but only as a defensive measure.
- Never trusts others; assumes worst-case scenarios for sustaining payoff.
- Leverages knowledge of stock dynamics explicitly.
- Aligns with aggressive mindset: prioritize short-term personal gain unless catastrophe to future payoffs is imminent.
- Simplifies to always defect except for minimal, calculated cooperation to preserve resource when valuable.

---

This approach balances aggressive exploitation with tactical restraint to maximize cumulative payoff over the repeated game.
'''

description_AGGRESSIVE_124 = '''
Here is a detailed aggressive strategy for the Common Pool Resource game, designed to maximize individual payoff through defection while managing the game's dynamics:

---

## Strategy Name: Relentless Defector with Last-Round Escalation

### Intuition:
- Being aggressive means seeking the highest immediate payoff per round (which is achieved by defecting).
- Since defecting consumes more stock, the pool will likely shrink over time.
- As the game progresses and the stock potentially depletes, defecting becomes less lucrative.
- To maximize payoff, defect every round **except** for the last round where the pool may be critically low.
- In the last round, if cooperation yields a better payoff due to low stock, cooperate to squeeze some payoff out without further depleting the resource (to maximize the last-round payoff).
- If the stock is empty or nearly 0 at the last round, defect anyway to grab what you can (possibly zero).

---

## Decision Rules

1. **Initial round (t = 1): Always Defect (D).**
   - Defecting provides the highest immediate payoff.
   - Don't waste the opportunity for immediate gain.
   
2. **Intermediate rounds (1 < t < r): Always Defect (D).**
   - Continue defecting to maintain maximum individual extraction.
   - Ignore stock sustainability since aggressive strategy cares more about short-term extraction.
   
3. **Last round (t = r): Conditional decision based on current stock S:**
   - Calculate payoff if Cooperate: \( \pi_C = \frac{S}{2n} \)
   - Calculate payoff if Defect: \( \pi_D = \frac{S}{n} \)
   - If \( \pi_C \geq \frac{\pi_D}{2} \) (equivalently \( \pi_C \geq 0.5 \times \pi_D \)), **Cooperate (C)**.
     - This condition favors cooperating when the stock is sufficiently low that cooperation still yields a meaningful payoff, rather than ruining the resource for zero gain.
     - Intuition: When stock is very low, defecting simply overexploits and results in zero next-round gain (no next round in this case, so no growth either).
   - Else, **Defect (D)**.
   
4. **Edge Cases Handling:**
   - If stock \(S = 0\) at any round (implies no resource left), always Defect (D) to formally play an action; no payoff this round regardless.
   - This maintains the protocol and signals aggressive default.

---

## Pseudocode

```python
# Inputs per round:
# t: current round number (1-based)
# r: total rounds
# S: current stock level (≥ 0)
# n: number of players

def aggressive_strategy(t, r, S, n):
    if S == 0:
        # No resource left, defect anyway
        return "D"
    
    if t < r:
        # Always defect in all but last round
        return "D"
    else:
        # Last round decision
        payoff_cooperate = S / (2 * n)
        payoff_defect = S / n
        
        # Cooperate if it yields at least half the payoff of defecting,
        # indicating stock is low enough to benefit from conserving resource.
        if payoff_cooperate >= (0.5 * payoff_defect):
            return "C"
        else:
            return "D"
```

---

## Explanation of the Last-Round Rule

- Since growth happens after consumption, in the last round there is no next round benefit from growth.
- When stock is high, defecting gets you max payoff (\( S/n \) per player defecting).
- When stock is very low, defecting may mean zero payoff as you overexploit beyond capacity.
- Cooperating shares the remaining resource more frugally (\( S/(2n) \)) but prevents unnecessary complete depletion.
- Choosing to cooperate when \( \pi_C \geq 0.5 \pi_D \) means the stock is low enough that cooperating yields a reasonable payoff, and defecting would be too wasteful.

---

## Summary

- Always defect to aggressively maximize short-term payoff.
- Do not miss the opportunity to aggressively extract early and mid-game.
- Adjust only in last round to avoid wasting opportunity on a depleted common resource.
- Do not depend on opponent cooperation.
- Follow a consistent aggressive logic that exploits common pool resources maximally.

---

If you want me to generate variants or explain theoretical expectations against common strategy types, just ask!
'''

description_AGGRESSIVE_125 = '''
**Aggressive Strategy: "Defect Dominator"**

---

### Intuition & Rationale

This strategy maximizes immediate payoffs by defecting whenever possible, exploiting the common pool to its fullest extent early on. It leverages the game’s payoff structure where defection yields double the immediate payoff of cooperation, and since this is a repeated game with observed histories, it punishes any cooperation by continuing to defect. It also accounts for the stock depletion dynamic by backing off cooperation only if the stock collapses to zero, at which point no further payoff can be extracted. The strategy never cooperates proactively; cooperation is used only defensively if the resource is depleted, to preserve some payoff.

---

### Strategy Description

- **Round 1: Defect.**  
  No prior signals or cooperation exist, so defect to secure the largest immediate payoff.

- **Rounds 2 to r-1: Defect unless the stock is zero.**  
  Continue to defect to maximize payoff. If the stock is positive, the immediate payoff from defecting (S/n) is always greater than cooperating (S/(2n)).  
  If stock = 0 → no payoff from defecting or cooperating; **cooperate here to allow regrowth (consuming less)** and try to stimulate recovery of the pool.

- **Round r (Last round): Defect if stock > 0, cooperate otherwise.**  
  Since there is no continuation value, maximize immediate payoff by defecting if any stock remains. Cooperate only if stock is zero to attempt some minor regrowth, but payoff will likely be zero anyway.

---

### Decision Rules Summary

| Condition                                  | Action |
|--------------------------------------------|--------|
| Round 1                                    | D      |
| Rounds 2 to r-1 and stock > 0              | D      |
| Rounds 2 to r-1 and stock = 0              | C      |
| Round r and stock > 0                       | D      |
| Round r and stock = 0                       | C      |

---

### Pseudocode

```python
def aggressive_strategy(round_number, total_rounds, stock, capacity, n):
    # Inputs:
    # round_number: current round (1-indexed)
    # total_rounds: total rounds r
    # stock: current common pool stock S
    # capacity: maximum sustainable stock level (unused here but given)
    # n: number of players
    
    # Aggressive logic:
    if round_number == 1:
        return 'D'  # Defect first round
    elif round_number < total_rounds:
        if stock > 0:
            return 'D'  # Defect if pool is positive
        else:
            return 'C'  # Cooperate to allow growth if pool depleted
    else:  # last round
        if stock > 0:
            return 'D'  # Defect on last round if possible
        else:
            return 'C'  # Cooperate otherwise
```

---

### Additional Notes

- **No Forgiveness or Reciprocity:** Since aggressive, it does not attempt to cooperate or punish deviators differently.
- **No Conditional Cooperation:** Does not attempt to sustain the stock via cooperation, as this reduces immediate payoff.
- **Stock Collapse Handling:** Only reduces consumption by cooperating when stock is zero, since no payoff can be harvested otherwise.
- **Maximizes Short-Term Gain:** Prefers short-term defect payoffs over any long-term sustainability.
  
---

Would you like me to provide alternative aggressive variants or analysis of this strategy's potential weaknesses?
'''

description_AGGRESSIVE_126 = '''
Below is a detailed design of an **Aggressive Strategy** for the described Common Pool Resource game. The strategy is deliberately exploitative with the intent to maximize individual payoff while disregarding sustainability or group benefit. It emphasizes defecting (“D”) to extract high payoffs, but with minimal concessions to avoid complete resource collapse too early.

---

## Core Intuition of the Aggressive Strategy

- Defect as much as possible to maximize immediate payoffs.
- Avoid causing the resource to collapse prematurely (which yields zero payoffs to all), by cooperating only when the stock level is dangerously low.
- Exploit cooperators when they exist by defecting to grab more payoff.
- On the last round, defect regardless to maximize extraction (no future consequences).
- Base decisions primarily on **current stock level** and **behavior history** of others (if you want to punish extreme depletion by cooperating once to allow some regeneration, though minimal).

---

## Definitions and Parameters for the Strategy

- Let `S_t` be the stock at the beginning of round `t`.
- Let `capacity` be the maximum stock.
- Threshold parameter `low_stock_threshold = capacity / (4 * n)` (a fraction of capacity scaled by player count)
    - When the stock falls below this threshold, the resource is critically low.
- `r`: Total number of rounds
- `t`: Current round index, 1 ≤ t ≤ r

---

## Decision Rules (Per Round)

### 1. **First round (t = 1):**
- Defect.
- Explanation: No history to rely upon; aggressive strives to maximize payoff immediately.

### 2. **Intermediate rounds (1 < t < r):**

- If `S_t < low_stock_threshold`:
  - Cooperate this round.
  - Explanation: The resource is severely depleted; cooperate once to allow stock to regrow modestly rather than hitting zero and ending payoffs.
- Else:
  - Defect.
  - Explanation: Stock is sufficient; continue aggressive defections to maximize payoff.

### 3. **Last round (t = r):**
- Defect unconditionally.
- Explanation: No future rounds, so no benefit from sustainability; maximize immediate payoff.

---

## Rationale for This Decision Logic

- The strategy is **aggressive** by default (always defecting), only “mildly” conceding by cooperating in rounds where depletion is severe, to **avoid ruin**.
- Does not attempt to punish or reward other players explicitly, but indirectly reacts to the **state** of the common resource.
- This guards against completely collapsing the resource too early, which would yield zero payoffs thereafter.
- The cooperation in low stock rounds is brief and tactical — only to enable continued exploitation in future rounds.
- By defecting on the last round, it extracts maximum payoff at the end.

---

## Pseudocode Summary

```python
def aggressive_strategy(t, r, S_t, capacity, n):
    low_stock_threshold = capacity / (4 * n)

    if t == 1:
        # First round: defect aggressively
        return 'D'
    elif t == r:
        # Last round: defect to maximize extraction
        return 'D'
    else:
        # Intermediate rounds:
        if S_t < low_stock_threshold:
            # Stock critically low, cooperate once to allow regrowth
            return 'C'
        else:
            # Stock healthy, defect aggressively
            return 'D'
```

---

## Edge Case Handling

- **Very low initial stock** (unlikely since initial = capacity): Would cooperate first round, but by spec initial stock = capacity.
- **Stock exactly at threshold**: Treat as “not low” → defect.
- **Rapidly collapsing resource due to other aggressive defectors**: Cooperate in rounds when < threshold to avoid zero stock next round.
- **If opponents always cooperate**: Exploit by defecting every round except forced cooperation rounds.
- **If opponents always defect**: Strategy defects back, with mild cooperation only to avoid resource collapse.
- **Single round games (r=1)**: Defect given no future.

---

## Summary

This strategy is straightforward, unconditionally aggressive except for minimal cooperation triggered only by the common pool’s low stock state to delay collapse and prolong gain opportunities. It requires no assumptions about opponents beyond their effect on the common resource state and adheres strictly to maximizing individual gain via opportunistic defecting.

---

Would you like me to provide sample expected behavior traces against cooperating or defecting opponents?
'''

description_AGGRESSIVE_127 = '''
**Aggressive Strategy Design for the Common Pool Resource Game**

---

### Core Intuition

An aggressive player maximizes immediate payoffs by defecting (D) as much as possible, exploiting cooperative players, and aiming to deplete the common pool rapidly for short-term gain—even at the risk of long-term resource collapse. The goal is to extract the highest payoff in as many rounds as possible, accepting that the stock might collapse towards the end of the game.

---

### Decision Rules Summary

| Round          | Decision           | Rationale                                          |
|----------------|--------------------|----------------------------------------------------|
| Round 1        | Defect (D)         | Maximize initial payoff, exploit unspoiled stock  |
| Intermediate rounds (1 < t < r)    | Defect (D), unless stock dangerously low | Continue exploiting; defect unless stock will be zeroed out next round |
| Last round (t = r) | Defect (D)     | No future rounds; no incentive to conserve          |
| Emergency fallback | Cooperate (C) only if defect would cause stock collapse | Avoid zero income scenarios if possible |

---

### Detailed Reasoning

- Defecting yields **S/n** payoff vs. cooperating’s **S/(2n)** — double the payoff per round.
- Aggressively defect every round to maximize short-term payoff.
- Monitor stock level to avoid complete depletion before last round, which causes zero payoffs in subsequent rounds.
- Only cooperate if defecting would cause the stock after consumption to drop to zero or below, guaranteeing zero payoff next round.
- On the last round, defect regardless, because there is no future stock to preserve.
- Ignore considerations for mutual cooperation or long-term sustainability; accept resource collapse in exchange for short-term maximum gains.

---

### Stock Impact Note

- Total consumption if all defect: n × (S/n) = S → stock always zero next round.
- Our strategy is to defect every round, but if repeated defecting would zero out stock prematurely (before last round), cooperate in that round to keep some stock for future rounds and more total payoff.
- Since others are independent, the strategy assumes worst case that others defect too, so conservative in avoiding self-defection that kills payoffs early.

---

### Pseudocode

```python
def aggressive_strategy(round_t, r, n, capacity, current_stock, history):
    """
    :param round_t: Current round (1-based integer)
    :param r: Total rounds
    :param n: Number of players
    :param capacity: Max sustainable stock (not used dynamically here)
    :param current_stock: Stock at start of round t
    :param history: List of past rounds info - not used explicitly, but can be analyzed if desired
    :return: Action 'C' (cooperate) or 'D' (defect)
    """

    # Compute own consumption if defect: current_stock / n
    defect_consumption = current_stock / n

    # Compute own consumption if cooperate: current_stock / (2 * n)
    coop_consumption = current_stock / (2 * n)

    # Total consumption if all defect: current_stock (total depletion)
    # Total consumption if all cooperate: current_stock / 2

    # Predict stock after total consumption if all defect (worst case)
    stock_after_defect_consumption = current_stock - current_stock  # guaranteed zero

    # Predict stock after total consumption if all cooperate (best case)
    stock_after_coop_consumption = current_stock - (current_stock/2)  # half stock left

    # Since others' actions unknown, assume worst case: all defect

    # Determine if defecting this round causes 0 stock that would end game early

    # BUT since we can't predict others, conservatively only cooperate if defecting would zero stock NOW and rounds remain
    
    if round_t == r:
        # Last round: defect no matter what
        return 'D'

    if current_stock == 0:
        # No stock left, no payoff possible, defect or cooperate is irrelevant
        # Defect anyway as aggressive default
        return 'D'

    # If defecting this round would consume current_stock fully, resulting in stock zero next round
    # and remaining rounds exist, cooperate this round to avoid zeroing the resource

    # But we cannot fully predict others' actions, so check if own defect consumption >= current_stock (which is always true)
    # Hence defecting always causes stock zero if all defect. But others might cooperate

    # A heuristic: if stock is currently low, cooperate to keep resource alive; else defect

    # Define threshold: If stock is less than or equal to n players × (stock/(2n)) × 2 = stock ≤ capacity/n (loosely)
    # More simply: if stock ≤ n (number of players) (meaning small stock), cooperate to conserve

    # Based on dynamics and parameters, choose a threshold
    stock_threshold = capacity / 3  # Arbitrary fraction for conserving low stock, can adjust

    if current_stock <= stock_threshold:
        # Conserve to avoid immediate collapse, cooperate
        return 'C'

    # Otherwise, defect aggressively
    return 'D'
```

---

### Summary of the Strategy

- **Always defect except:**
  - The last round, defect to maximize last payoff
  - When stock is low (below defined threshold), cooperate to avoid immediate extinction and preserve some stock for future rounds
- This strategy aggressively extracts maximum short-term payoff, with minimal conservation only to avoid complete early collapse that would cost next rounds' payoff.
- No attempt at cooperation signals or punishment; no forgiveness.
- Essentially a *greedy defector with minimal conservation logic*.

---

If this is acceptable, I can write a concise version based on this design. Let me know!
'''

description_AGGRESSIVE_128 = '''
Here's an aggressive strategy designed for this Common Pool Resource Game, aligned with a mindset of maximizing individual payoff even at the risk of provoking depletion of the resource and retaliatory responses.

---

### Aggressive Strategy Description

**Core idea:**
Defect (D) as often as possible to maximize immediate payoff, except in very specific conditions where moderate cooperation can preserve the stock to sustain some resource for future rounds. Since the game is finite with known horizon, the strategy exploits endgame logic to defect persistently in last rounds, and uses observed opponent behavior to adapt minimal cooperation only if it extends the game’s profitable rounds.

---

### 1. Decision Rules: When to Cooperate vs Defect

- **Round 1: Defect (D) unconditionally.**  
  Rationale: No prior information; gain maximum payoff immediately.

- **Intermediate rounds (2 to r-1):**
  - Calculate **expected payoff of defection versus cooperation**, taking into account current stock S and number of defectors/cooperators in previous round.
  - **If current stock S is high (e.g. > 50% capacity):**  
    Defect (D) to maximize immediate gain, since the stock can likely sustain heavy extraction.
  - **If current stock S is moderate (e.g. 20% to 50% capacity):**  
    Defect unless a significant majority cooperated in last round (≥ n - 1 players cooperating), then cooperate (C) to allow stock recovery and prolong profitable future extraction.
  - **If stock S is low (< 20% capacity):**  
    Cooperate only if majority cooperated last round and stock dropped sharply (e.g. more than 30% drop), else defect to maximize last-round gains before resource depletion.

- **Final round (round r): Defect (D) unconditionally.**  
  Rationale: No future rounds to preserve resources for; maximize last round payoff.

---

### 2. Handling Edge Cases

- **First round (t=1):**  
  Defect always; no history to condition on.

- **Last round (t=r):**  
  Defect always; no incentive to preserve stock.

- **Rounds with near-extinct stock (S close to zero):**  
  Cooperate to consume minimally if there is potential for stock regrowth (very rare), otherwise defect for last payoff.

- **If all players defect repeatedly and stock approaches zero:**  
  Continue defecting since cooperation is useless and resource is depleted.

- **If opponents unexpectedly cooperate heavily:**  
  Exploit by defecting (opportunistic defection).

---

### 3. Aggressiveness Outline

- Prioritize defecting to maximize own returns.
- Only cooperate as a tactical concession to prolong the resource when it affects own payoffs negatively (not a reciprocity or trust goal).
- Never cooperate in round 1 or round r.
- Punish cooperation from others by defecting to capitalize on their restraint.
- Exploit knowledge of opponent actions (past round) to decide cooperation if it benefits own mid-game payoffs.

---

### Pseudocode

```python
function aggressive_strategy(round t, stock S, history H, capacity, n, r):
    # H contains past rounds' actions of all players, indexed by round
    
    # Always defect first round
    if t == 1:
        return 'D'
        
    # Always defect last round
    if t == r:
        return 'D'
    
    # Extract previous round player actions
    last_round_actions = H[t-1]  # List of length n: 'C' or 'D'
    
    # Count cooperators and defectors last round
    coop_count = count(action == 'C' for action in last_round_actions)
    defect_count = n - coop_count
    
    # Threshold stock levels (percent of capacity)
    high_stock_threshold = 0.5 * capacity
    low_stock_threshold = 0.2 * capacity
    
    # Stock drop magnitude since last round
    if t > 2:
        prev_stock = compute_stock_after_round(t-2, H, capacity, n)  # hypothetical helper
        stock_drop = prev_stock - S
    else:
        stock_drop = 0  # no prior data for round 2
    
    # Decision logic
    if S > high_stock_threshold:
        # High stock: defect always
        return 'D'
        
    elif S > low_stock_threshold:
        # Moderate stock
        if coop_count >= n - 1:
            # Many cooperators previously, cooperate to preserve
            return 'C'
        else:
            return 'D'
    
    else:
        # Low stock
        if coop_count >= (n // 2) and stock_drop > 0.3 * capacity:
            # Significant cooperation and sharp stock drop, cooperate to save resource
            return 'C'
        else:
            # Otherwise, defect to maximize short-term payoff
            return 'D'
```

---

### Additional Notes

- This strategy uses only information from the previous round (and stock in current round).
- It exploits knowledge that defecting yields twice the payoff per extraction unit in any round.
- It only cooperates strategically to prevent total resource collapse if others appear committed to cooperation, thus ensuring some resource carries over to next rounds.
- Aggressive posture is clear: maximize immediate payoff, minimal cooperation as tactical tool, defect at start and finish rounds without exception.

---

This aggressive plan should perform well in a tournament setting by extracting high payoffs early and leveraging situational cooperation only when it benefits survival of the resource for future exploitation.
'''
