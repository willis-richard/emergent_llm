"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: OpenAI
- Model: o4-mini
- Game: CommonPoolDescription
"""

from emergent_llm.players.base_player import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription
from emergent_llm.common.actions import Action, C, D
from emergent_llm.common.history import PlayerHistory
import numpy as np
from numpy.typing import NDArray
import math
import random



class Strategy_COOPERATIVE_1(BaseStrategy):
    """
    Grim-Trigger Common-Pool Cooperation:
    Cooperate until any player defects, then defect forever.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ever_defected_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if not self.ever_defected_flag:
            last_round_index = history.round_number - 1
            last_opponent_actions = history.opponent_actions[last_round_index]
            if not np.all(last_opponent_actions):
                self.ever_defected_flag = True
        if self.ever_defected_flag:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_2(BaseStrategy):
    """
    Firm‐but‐Fair CPR Cooperator (FFC):
    Cooperates as long as everyone did, punishes any defection for L rounds,
    forgives thereafter, and always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishmentTimer = 0
        self.L = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishmentTimer = 0
            return Action.C
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.punishmentTimer > 0:
            self.punishmentTimer -= 1
            return Action.D
        last_my = history.my_actions[-1]
        last_opponents = history.opponent_actions[-1]
        defect_occurred = not last_my or np.any(~last_opponents)
        if defect_occurred:
            self.punishmentTimer = self.L
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_3(BaseStrategy):
    """
    Coop–TFT–End strategy:
    - Start by cooperating.
    - If any opponent defected in the previous round, defect once (punishment), then resume cooperation.
    - Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.punishing:
            self.punishing = False
            return Action.D
        prev_idx = history.round_number - 1
        last_actions = history.opponent_actions[prev_idx]
        if not np.all(last_actions):
            self.punishing = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_4(BaseStrategy):
    """
    One‐Shot Punitive Tit‐for‐Tat with Endgame Cooperation:
    - First round: cooperate.
    - Rounds 2…r-1: if any defection in the previous round by any player, defect once as punishment,
      then forgive and return to cooperation if opponents do.
    - Last round: cooperate only if nobody ever defected; otherwise defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ever_defected = False
        self.skip_detect = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.ever_defected = False
            self.skip_detect = False
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.C if not self.ever_defected else Action.D
        if self.skip_detect:
            self.skip_detect = False
            return Action.D
        prev_idx = history.round_number - 1
        prev_my = history.my_actions[prev_idx]
        prev_opps = history.opponent_actions[prev_idx]
        defected = prev_my is False or np.any(prev_opps == False)
        if defected:
            self.ever_defected = True
            self.skip_detect = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_5(BaseStrategy):
    """
    Reciprocal Conditional Cooperation with Last-Round Defection:
    - Cooperate first.
    - Punish any defection by one-round defection.
    - Forgive immediately after punishment.
    - Defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.L = 1
        self.last_defect_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t == self.r:
            return Action.D
        if t == 1:
            return Action.C
        if t - self.last_defect_round <= self.L:
            return Action.D
        idx = history.round_number - 1
        prev_my = history.my_actions[idx]
        prev_opps = history.opponent_actions[idx]
        any_defection = not prev_my or (~prev_opps).any()
        if any_defection:
            self.last_defect_round = t - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_6(BaseStrategy):
    """
    Generous Trigger with Last‐Round Defection:
    Cooperate by default, punish single defections one round,
    rebuild if stock is low, and always defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish = 0
        self.current_stock = float(game_description.capacity)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        prev_stock = self.current_stock
        last_my = bool(history.my_actions[-1])
        last_opponents = history.opponent_actions[-1]
        n = self.game_description.n_players
        coop_count = int(last_my) + int(last_opponents.sum())
        defect_count = n - coop_count
        cons_total = coop_count * (prev_stock / (2 * n)) + defect_count * (prev_stock / n)
        remaining = prev_stock - cons_total
        growth = 2 * remaining * (1 - remaining / self.game_description.capacity)
        new_stock = remaining + growth
        if new_stock > self.game_description.capacity:
            new_stock = float(self.game_description.capacity)
        self.current_stock = new_stock
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        epsilon = self.game_description.capacity / (10 * n)
        if self.current_stock < epsilon:
            if self.punish > 0:
                self.punish -= 1
            return Action.C
        if self.punish > 0:
            self.punish -= 1
            return Action.D
        if any((not bool(a) for a in last_opponents)):
            self.punish = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_7(BaseStrategy):
    """
    Modified Tit-for-Tat with Last-Round Defection:
    - Cooperate in the first round.
    - In rounds 2 to r-1, cooperate if and only if all opponents cooperated
      in the previous round; otherwise defect once to punish.
    - Defect in the final round (one-shot incentive).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        last_ops = history.opponent_actions[history.round_number - 1]
        if last_ops.all():
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_8(BaseStrategy):
    """
    Stock‐aware, forgiving tit‐for‐tat for the common‐pool resource game.
    Cooperate by default to keep the pool near capacity, punish defectors
    for a fixed duration, forgive after punishment, suspend punishment
    if stock is critically low, and defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.P_default = 3
        self.S_low = 0.1 * self.capacity
        self.punish_remaining = 0
        self.defected_before = False
        self.stock = float(self.capacity)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        prev_round = history.round_number - 1
        S_prev = self.stock
        my_prev = history.my_actions[prev_round]
        coop_opponents = int(history.opponent_actions[prev_round].sum())
        coop_total = coop_opponents + (1 if my_prev else 0)
        defect_total = self.n - coop_total
        cons_coop = S_prev / (2 * self.n)
        cons_def = S_prev / self.n
        total_consumption = coop_total * cons_coop + defect_total * cons_def
        S_remain = S_prev - total_consumption
        growth = 2 * S_remain * (1 - S_remain / self.capacity)
        new_stock = S_remain + growth
        if new_stock > self.capacity:
            new_stock = self.capacity
        if new_stock < 0:
            new_stock = 0.0
        self.stock = new_stock
        if not self.defected_before and defect_total > 0:
            self.defected_before = True
        t = history.round_number + 1
        if t == self.r:
            action = Action.D
        elif self.stock < self.S_low:
            action = Action.C
        elif self.punish_remaining > 0:
            self.punish_remaining -= 1
            action = Action.D
        elif self.defected_before:
            self.punish_remaining = self.P_default - 1
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_COOPERATIVE_9(BaseStrategy):
    """
    Generous Tit-for-Tat with Endgame Defection for the Common Pool Resource Game.

    - Start by cooperating.
    - Punish any defection from any opponent for exactly one round.
    - Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.PunishTimer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.PunishTimer = 0
            return Action.C
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        if self.PunishTimer > 0:
            self.PunishTimer -= 1
            return Action.D
        if history.round_number >= 1:
            last_idx = history.round_number - 1
            if np.any(~history.opponent_actions[last_idx]):
                self.PunishTimer = 1
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_10(BaseStrategy):
    """
    Forgiving Tit-for-Tat (FTFTT):
    - Round 1: cooperate.
    - If any opponent defected in the last round, defect for exactly one round.
    - Otherwise, cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.punish_rounds_remaining > 0:
            self.punish_rounds_remaining -= 1
            return Action.D
        last_round = history.round_number - 1
        last_opponent_actions = history.opponent_actions[last_round]
        if not np.all(last_opponent_actions):
            self.punish_rounds_remaining = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_11(BaseStrategy):
    """
    Tit-for-Tat with one-shot punishment and endgame defection.
    - Round 1: Cooperate.
    - Rounds 2 to r-1: If any opponent defected in the previous round, defect once; otherwise cooperate.
    - Round r: Always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        last_round_index = history.round_number - 1
        last_ops = history.opponent_actions[last_round_index]
        if not all(last_ops):
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_12(BaseStrategy):
    """
    Tit-for-Tat with single-round punishment and inevitable end-game defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        prev_index = history.round_number - 1
        if (history.opponent_actions[prev_index] == False).any():
            self.punish_counter = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_13(BaseStrategy):
    """
    Generous One-Round Punisher with Endgame Defection (GOP-ED).

    - Cooperates by default.
    - If any defection occurred in the previous round, punishes by defecting exactly one round.
    - If the common-pool stock falls below a fraction α of capacity, always cooperates to allow regrowth.
    - In the final round, always defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_had_defection = False
        self.alpha = 0.2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.last_round_had_defection = False
            return Action.C
        rounds_completed = history.round_number
        total_rounds = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        n_players = self.game_description.n_players
        if rounds_completed >= 1:
            last_idx = rounds_completed - 1
            my_defected = not bool(history.my_actions[last_idx])
            opp_defected = bool((history.opponent_actions[last_idx] == False).any())
            self.last_round_had_defection = my_defected or opp_defected
        t = rounds_completed + 1
        stock = capacity
        for i in range(rounds_completed):
            coop_me = int(history.my_actions[i])
            coop_opp = int(np.sum(history.opponent_actions[i]))
            coop_count = coop_me + coop_opp
            defect_count = n_players - coop_count
            c_coop = stock / (2 * n_players)
            c_def = stock / n_players
            total_consumption = coop_count * c_coop + defect_count * c_def
            s_remain = stock - total_consumption
            growth = 2.0 * s_remain * (1.0 - s_remain / capacity)
            stock = min(s_remain + growth, capacity)
        if t == total_rounds:
            return Action.D
        if stock <= self.alpha * capacity:
            return Action.C
        if t == 1:
            return Action.C
        if self.last_round_had_defection:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_14(BaseStrategy):
    """
    Cooperative Tit-for-Tat with Forgiveness:
    - Start by cooperating.
    - In each subsequent round, if everyone (including self) cooperated
      in the previous round, cooperate; otherwise, defect exactly once
      to punish, then forgive.
    - In the final round, same rule: cooperate if the last round was clean,
      else defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number
        if round_number == 0:
            last_all_C = True
        else:
            last_idx = round_number - 1
            my_last = history.my_actions[last_idx]
            opp_last = history.opponent_actions[last_idx]
            last_all_C = bool(my_last) and bool(all(opp_last))
        if last_all_C:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_15(BaseStrategy):
    """
    Conditional-cooperation strategy:
    - Start by cooperating
    - One-round punishment of any defection
    - Always cooperate if stock ≤ capacity/4
    - Defect in the last round
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_low = self.capacity / 4.0
        self.P = 1
        self.punish_counter = 0
        self.stock = float(self.capacity)
        self.last_round_processed = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_done = history.round_number
        while self.last_round_processed < rounds_done:
            j = self.last_round_processed
            prev_stock = self.stock
            my_act = bool(history.my_actions[j])
            opp_acts = history.opponent_actions[j]
            n_coop = int(my_act) + int(opp_acts.sum())
            n_def = self.n_players - n_coop
            cons_coop = n_coop * (prev_stock / (2.0 * self.n_players))
            cons_def = n_def * (prev_stock / self.n_players)
            total_consumption = cons_coop + cons_def
            S_rem = prev_stock - total_consumption
            growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
            new_stock = min(S_rem + growth, self.capacity)
            self.stock = new_stock
            self.last_round_processed += 1
        t = rounds_done + 1
        defected_last = False
        if rounds_done >= 1:
            idx = rounds_done - 1
            if not history.my_actions[idx]:
                defected_last = True
            elif not history.opponent_actions[idx].all():
                defected_last = True
        if t == self.n_rounds:
            return Action.D
        if self.stock <= self.S_low:
            return Action.C
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        if defected_last:
            self.punish_counter = self.P
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_16(BaseStrategy):
    """
    Tit‐for‐Tat with Endgame for the Common Pool Resource Game.
    - Cooperate on the first round.
    - In rounds 2 through r-1, defect if anyone (including yourself) defected in the previous round; otherwise cooperate.
    - Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        last_self = history.my_actions[last_idx]
        last_opponents = history.opponent_actions[last_idx]
        if not last_self or not last_opponents.all():
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_17(BaseStrategy):
    """
    Forgiving-TFT with Threshold and Endgame Defection:
    - Cooperate on first move.
    - If any defection last round, defect once then forgive.
    - If stock drops below half capacity, always cooperate to rebuild.
    - Always defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishFlag = False
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.stock_threshold = self.capacity / 2.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        stock = self.capacity
        for idx in range(history.round_number):
            my_payoff = history.my_payoffs[idx]
            opp_total = float(history.opponent_payoffs[idx].sum())
            total_consumption = my_payoff + opp_total
            remaining = stock - total_consumption
            growth = 2.0 * remaining * (1.0 - remaining / self.capacity)
            stock = min(remaining + growth, self.capacity)
        last_my = bool(history.my_actions[-1])
        last_opps = history.opponent_actions[-1]
        last_defected = not last_my or not last_opps.all()
        if t == self.n_rounds:
            return Action.D
        if stock < self.stock_threshold:
            self.punishFlag = False
            return Action.C
        if t == 1:
            return Action.C
        if self.punishFlag:
            self.punishFlag = False
            return Action.C
        if last_defected:
            self.punishFlag = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_18(BaseStrategy):
    """
    End‐game adjusted tit‐for‐tat for the Common Pool Resource Game:
    - Cooperate in round 1.
    - If any opponent defected in the previous round, defect for k=1 round (punish_once).
    - Otherwise cooperate.
    - Defect in the very last round (e=1 endgame).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_until = 0
        self.k = 1
        self.e = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == 1:
            return Action.C
        if t > r - self.e:
            return Action.D
        if self.punish_until >= t:
            return Action.D
        prev_round = history.round_number - 1
        prev_actions = history.opponent_actions[prev_round]
        if not all(prev_actions):
            self.punish_until = t - 1 + self.k
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_19(BaseStrategy):
    """
    Cooperative-trigger strategy for the Common Pool Resource game.
    - In Normal mode, cooperate unless any player defected last round.
      On first defection observed, switch to Punish mode.
    - In Punish mode, defect for K consecutive rounds, then return to Normal.
    - In the final round, defect unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.K = 2
        self.state = 'Normal'
        self.timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.state = 'Normal'
            self.timer = 0
            return Action.C
        t = history.round_number + 1
        last_idx = history.round_number - 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.state == 'Punish':
            action = Action.D
            self.timer -= 1
            if self.timer <= 0:
                self.state = 'Normal'
            return action
        if last_idx >= 0:
            cooperated_self = history.my_actions[last_idx]
            cooperated_opps = np.all(history.opponent_actions[last_idx])
            if not (cooperated_self and cooperated_opps):
                self.state = 'Punish'
                self.timer = self.K - 1
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_20(BaseStrategy):
    """
    Adaptive Tit‐for‐Tat with Limited Punishment:
    - Start by cooperating
    - If any opponent defected in the previous round, defect for a limited window (P_max rounds)
    - Forgive after the window expires
    - Always defect in the last round
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.P_max = max(1, self.r - 2)
        self.punish_until = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if t <= self.punish_until:
            return Action.D
        last_ops = history.opponent_actions[history.round_number - 1]
        if not last_ops.all():
            remaining = self.r - 1 - t
            punish_length = min(self.P_max, remaining)
            self.punish_until = t + punish_length
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_21(BaseStrategy):
    """
    Tit-for-Tat with finite punishment (P=2) and endgame defection.
    Starts by cooperating, punishes any defection by others for P rounds,
    forgives thereafter, and defects unconditionally in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 2
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        last_round = history.round_number - 1
        if not all(history.opponent_actions[last_round]):
            self.punish_timer = self.P - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_22(BaseStrategy):
    """
    Grim‐trigger with end‐game defection:
    - Round 1: cooperate.
    - Rounds 2…r–1: cooperate if no defection has been seen; otherwise defect.
    - Round r: defect unconditionally.
    Once any player (including yourself) defects in any round, trigger permanent defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_seen = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_self = history.my_actions[-1]
        last_opponents = history.opponent_actions[-1]
        if not last_self or not last_opponents.all():
            self.defect_seen = True
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if not self.defect_seen:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_23(BaseStrategy):
    """
    Coop-TFT-Endgame strategy:
    - Round 1: cooperate.
    - Rounds 2 to r-1: tit-for-tat (defect next round if anyone defected last round).
    - Round r: defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        my_prev = history.my_actions[last_idx]
        opp_prev = history.opponent_actions[last_idx]
        if not my_prev or not opp_prev.all():
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_24(BaseStrategy):
    """
    Reciprocal‐Recovery strategy:
    - Cooperates initially.
    - Defects in the last round.
    - Punishes one round after any defection.
    - When the stock falls below half capacity, enters K=2 rounds of pure cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.punishLeft = 0
        self.recoverLeft = 0
        self.current_stock = float(game_description.capacity)

    def __call__(self, history: None | PlayerHistory) -> Action:
        P = 1
        K = 2
        T = self.capacity / 2.0
        if history is None:
            return Action.C
        prev_round = history.round_number - 1
        opp_prev = history.opponent_actions[prev_round]
        my_prev = history.my_actions[prev_round]
        coop_count = int(my_prev) + int(opp_prev.sum())
        defect_count = self.n_players - coop_count
        S_prev = self.current_stock
        cons_coop = S_prev / (2 * self.n_players)
        cons_def = S_prev / self.n_players
        total_consumption = coop_count * cons_coop + defect_count * cons_def
        S_after = S_prev - total_consumption
        growth = 2 * S_after * (1.0 - S_after / self.capacity)
        S_new = min(S_after + growth, self.capacity)
        self.current_stock = S_new
        lastDefect = defect_count > 0
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        if self.punishLeft > 0:
            self.punishLeft -= 1
            return Action.D
        if lastDefect:
            self.punishLeft = P - 1
            return Action.D
        if self.recoverLeft > 0:
            self.recoverLeft -= 1
            return Action.C
        if self.current_stock <= T:
            self.recoverLeft = K - 1
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_25(BaseStrategy):
    """
    Tit-for-Tat style cooperate-when-possible strategy with end-game defection.
    Cooperate on the first round, retaliate once against any defection, forgive immediately,
    and always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_completed = history.round_number
        current_round = rounds_completed + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punishing:
            self.punishing = False
            return Action.D
        previous_opponent_actions = history.opponent_actions[rounds_completed - 1]
        if not previous_opponent_actions.all():
            self.punishing = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_26(BaseStrategy):
    """
    Conditional Cooperation with Finite-Horizon Adjustment:
    - Cooperate initially and as long as everyone cooperates.
    - Punish for P rounds after any defection, then forgive.
    - Defect unconditionally in the last K rounds or if horizon too short.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.P = 2
        self.K = 2
        self.stage = 'COOP'
        self.punish_counter = 0
        self.ever_defected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if self.r <= self.K + 1:
            return Action.D
        if t > self.r - self.K:
            return Action.D
        if self.stage == 'PUNISH':
            action = Action.D
            self.punish_counter -= 1
            if self.punish_counter == 0:
                self.stage = 'COOP'
            return action
        if t == 1:
            return Action.C
        last_idx = history.round_number - 1
        if not history.opponent_actions[last_idx].all():
            self.ever_defected = True
            self.stage = 'PUNISH'
            self.punish_counter = self.P
            action = Action.D
            self.punish_counter -= 1
            if self.punish_counter == 0:
                self.stage = 'COOP'
            return action
        return Action.C

class Strategy_COOPERATIVE_27(BaseStrategy):
    """
    Multi-player Tit-for-Tat with End-Game Defection.

    - Round 1: Cooperate.
    - Rounds 2 to r-2: Cooperate if no opponent defected in the previous round,
      otherwise defect (one-period punishment).
    - Round r-1 and r: Defect (end-game unraveling).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_any_defection = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        if history is None:
            self.last_round_any_defection = False
            return Action.C
        t = history.round_number + 1
        if history.round_number > 0:
            last_opponents = history.opponent_actions[-1]
            self.last_round_any_defection = not bool(last_opponents.all())
        if t == 1:
            return Action.C
        if t == r:
            return Action.D
        if r >= 3 and t == r - 1:
            return Action.D
        if self.last_round_any_defection:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_28(BaseStrategy):
    """
    Cooperative but self‐protecting tit‐for‐tat strategy with one‐round forgiveness
    and unconditional defection in the last two rounds (end‐game protection).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_next = False
        self.endgame_start = max(2, game_description.n_rounds - 2)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t >= self.endgame_start:
            return Action.D
        if t == 1:
            return Action.C
        if self.punish_next:
            self.punish_next = False
            return Action.C
        prev = history.opponent_actions[history.round_number - 1]
        if not prev.all():
            self.punish_next = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_29(BaseStrategy):
    """
    Tit-for-tat with one-round punishment and final-round defection (TFT-ORP-FD).
    Cooperates first, punishes any defection by defecting once, forgives immediately,
    and defects unconditionally in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_defection = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_idx = history.round_number - 1
        my_last = bool(history.my_actions[last_idx])
        opp_last = history.opponent_actions[last_idx]
        opp_defected = any((not bool(a) for a in opp_last))
        self.last_defection = not my_last or opp_defected
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.last_defection:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_30(BaseStrategy):
    """
    Forgiving Tit-for-Tat with End-Game Defection.

    - Start by cooperating.
    - In the last round, always defect.
    - In intermediate rounds, punish any defection in the previous round by defecting once,
      then forgive (return to cooperation) if everyone cooperated.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_any_defection = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        prev_idx = history.round_number - 1
        any_defected = False
        if not history.my_actions[prev_idx]:
            any_defected = True
        else:
            for opp_act in history.opponent_actions[prev_idx]:
                if not opp_act:
                    any_defected = True
                    break
        self.last_round_any_defection = any_defected
        if t == r:
            return Action.D
        if self.last_round_any_defection:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_31(BaseStrategy):
    """
    Coop-TFT strategy for the Common Pool Resource Game.
    - Cooperate on the first round.
    - Defect on the last round.
    - If any opponent defected in the previous round, defect this round (punish once) then forgive.
    - Otherwise, cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.punish > 0:
            self.punish -= 1
            return Action.D
        last_idx = history.round_number - 1
        last_ops = history.opponent_actions[last_idx]
        if not last_ops.all():
            self.punish = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_32(BaseStrategy):
    """
    Tit-for-Tat with one-round punishment and end-game defection.
    Cooperates on round 1, punishes any one-shot defector in the following round,
    forgives afterward, and always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_scheduled = False
        self.in_punishment = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_scheduled = False
            self.in_punishment = False
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if history.round_number >= 1:
            last_opponent_actions = history.opponent_actions[history.round_number - 1]
            if not self.in_punishment and (not last_opponent_actions.all()):
                self.punishment_scheduled = True
            else:
                self.punishment_scheduled = False
        if t == total_rounds:
            self.in_punishment = False
            self.punishment_scheduled = False
            return Action.D
        if t == 1:
            self.in_punishment = False
            return Action.C
        if self.punishment_scheduled:
            action = Action.D
            self.in_punishment = True
            self.punishment_scheduled = False
        else:
            action = Action.C
            self.in_punishment = False
        return action

class Strategy_AGGRESSIVE_1(BaseStrategy):
    """
    Aggressive "grudge-and-endgame" strategy:
    - Cooperate by default to sustain the common pool.
    - If any opponent ever defects (grim trigger), defect forever.
    - In the final k rounds (endgame), defect unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t > r - self.k:
            return Action.D
        if not history.opponent_actions.all():
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_2(BaseStrategy):
    """
    Aggressive Harvester:
    Defect on the first round, defect whenever the pool is above a low threshold L=0.1*capacity,
    cooperate only when the pool is at or below L to let it recover, and always defect in the
    final k=1 rounds to lock in the grab.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.H = 0.4 * self.capacity
        self.L = 0.1 * self.capacity
        self.k = 1
        self.current_stock = float(self.capacity)
        self.last_updated_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number > self.last_updated_round:
            S = self.current_stock
            last_idx = history.round_number - 1
            n_opp_coops = int(np.sum(history.opponent_actions[last_idx]))
            n_opp_def = self.n - 1 - n_opp_coops
            my_coop = bool(history.my_actions[last_idx])
            n_D = n_opp_def + (0 if my_coop else 1)
            total_consumption = S * ((self.n + n_D) / (2 * self.n))
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S_new = S_remaining + growth
            if S_new > self.capacity:
                S_new = self.capacity
            self.current_stock = S_new
            self.last_updated_round = history.round_number
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if t > self.r - self.k:
            return Action.D
        if t == 1:
            return Action.D
        if self.current_stock <= self.L:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_3(BaseStrategy):
    """
    Aggressive‐exploit‐with‐occasional‐pumping strategy for the Common Pool Resource Game.
    - Always defect when the pool is at or above half capacity or on the last round.
    - Cooperate (take the small share) when the pool is below half capacity to allow regrowth.
    - Defect if the pool is already empty.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            stock = self.capacity
        else:
            stock = self.capacity
            rounds_completed = history.round_number
            for idx in range(rounds_completed):
                opp_coops = int(np.sum(history.opponent_actions[idx]))
                me_coop = int(history.my_actions[idx])
                total_coops = opp_coops + me_coop
                total_defs = self.n - total_coops
                share_coop = stock / (2 * self.n)
                share_def = stock / self.n
                total_consumption = total_coops * share_coop + total_defs * share_def
                remaining = max(stock - total_consumption, 0.0)
                growth = 2 * remaining * (1 - remaining / self.capacity) if remaining > 0 else 0.0
                stock = min(remaining + growth, self.capacity)
            t = rounds_completed + 1
        T_high = 0.5 * self.capacity
        if t == self.r:
            return Action.D
        if stock <= 0.0:
            return Action.D
        if stock >= T_high:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_4(BaseStrategy):
    """
    Aggressive‐threshold strategy:
    - Round 1: Defect.
    - Rounds 2..r-1: Defect if current stock > capacity/2, else Cooperate.
    - Round r: Defect.
    Stock is reconstructed from history each call by simulating consumption and growth.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.thresh = self.capacity / 2.0

    def _compute_stock(self, history: PlayerHistory) -> float:
        """
        Reconstruct the common pool stock at the start of the next round,
        given the completed history.
        """
        S = self.capacity
        for t in range(history.round_number):
            opp_actions = history.opponent_actions[t]
            coop_opp = int(opp_actions.sum())
            def_opp = self.n - 1 - coop_opp
            my_coop = bool(history.my_actions[t])
            cons_C = S / (2.0 * self.n)
            cons_D = S / float(self.n)
            total_opp_cons = coop_opp * cons_C + def_opp * cons_D
            total_self_cons = cons_C if my_coop else cons_D
            total_cons = total_opp_cons + total_self_cons
            S_rem = S - total_cons
            growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
            S = min(S_rem + growth, self.capacity)
        return S

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = self.capacity
        else:
            t = history.round_number + 1
            S = self._compute_stock(history)
        if t == 1 or t == self.r:
            return Action.D
        if S > self.thresh:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_5(BaseStrategy):
    """
    Aggressive pump-and-dump strategy for the Common Pool Resource game.
    Defect (D) by default to maximize immediate consumption, except:
      - If the pool stock S_t drops below T_low = alpha * capacity, cooperate (C)
        to allow regrowth.
      - Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.alpha = 0.25
        self.beta = 0.75
        self.T_low = self.alpha * self.capacity
        self.T_high = self.beta * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            stock = self.capacity
        else:
            completed = history.round_number
            stock = self.capacity
            n = self.n_players
            cap = self.capacity
            for i in range(completed):
                my_coop = 1 if history.my_actions[i] else 0
                opp_coops = int(history.opponent_actions[i].sum())
                n_C = my_coop + opp_coops
                S_t = stock
                S_rem = S_t * (n_C / (2 * n))
                growth = 2 * S_rem * (1 - S_rem / cap)
                stock = S_rem + growth
                if stock > cap:
                    stock = cap
            t = completed + 1
        if t == self.n_rounds:
            return Action.D
        if stock < self.T_low:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_6(BaseStrategy):
    """
    Aggressive‐exploiter strategy for the common pool resource game.
    Defect when the stock is abundant or in the final round, cooperate
    only when the stock is critically low or to prop up middling stocks
    after many defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_high = 0.7 * self.capacity
        self.S_low = 0.3 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = float(self.capacity)
        for i in range(history.round_number):
            coop_count = int(history.my_actions[i]) + int(np.sum(history.opponent_actions[i]))
            defect_count = self.n - coop_count
            cons_coop = S / (2 * self.n)
            cons_def = S / self.n
            total_consumption = coop_count * cons_coop + defect_count * cons_def
            S_remain = S - total_consumption
            growth = 2 * S_remain * (1 - S_remain / self.capacity)
            S = min(S_remain + growth, self.capacity)
        if t == self.r:
            return Action.D
        if S <= 0:
            return Action.D
        if S >= self.S_high:
            return Action.D
        if S <= self.S_low:
            return Action.C
        prev_coop = int(history.my_actions[-1]) + int(np.sum(history.opponent_actions[-1]))
        if prev_coop > self.n / 2:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_7(BaseStrategy):
    """
    All-Out Defector strategy for the Common Pool Resource Game.
    Always plays Defect (D) every round, regardless of history or stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_8(BaseStrategy):
    """
    Exploiter-with-Minimal-Regeneration strategy:
    - Defect always except when the common pool stock is at or below S_low,
      in which case cooperate to regenerate.
    - In the final k_final rounds, always defect (go-for-broke endgame).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.k_final = math.ceil(self.r / 4)
        self.S_low = self.capacity / 4.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = self.capacity
        else:
            t = history.round_number + 1
            S = self.capacity
            for i in range(history.round_number):
                total_consumption = float(history.my_payoffs[i]) + float(np.sum(history.opponent_payoffs[i]))
                S_remain = S - total_consumption
                growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
                S = min(S_remain + growth, self.capacity)
        if t > self.r - self.k_final:
            return Action.D
        if S <= self.S_low:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_9(BaseStrategy):
    """
    Aggressive bang–bang extractor:
    - Always defects in the first and last rounds.
    - Computes a safe‐harvest threshold S_safe = capacity * (n - 1) / (2n).
    - Defects whenever current stock ≥ S_safe.
    - Cooperates only when the stock is so low that defection would kill future growth (S < S_safe) or when stock is zero.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_safe = self.capacity * (self.n - 1) / (2 * self.n)
        self.current_stock = float(self.capacity)
        self.last_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.current_stock
        else:
            completed = history.round_number
            if completed > self.last_round:
                idx = completed - 1
                coop_opp = int(history.opponent_actions[idx].sum())
                coop_self = 1 if history.my_actions[idx] else 0
                num_coop = coop_opp + coop_self
                num_def = self.n - num_coop
                cons_coop = self.current_stock / (2 * self.n)
                cons_def = self.current_stock / self.n
                total_consumption = num_coop * cons_coop + num_def * cons_def
                S_rem = self.current_stock - total_consumption
                growth = 2 * S_rem * (1 - S_rem / self.capacity) if S_rem > 0 else 0.0
                self.current_stock = min(S_rem + growth, self.capacity)
                self.last_round = completed
            t = history.round_number + 1
            S_t = self.current_stock
        if t == 1 or t == self.r:
            return Action.D
        if S_t <= 0:
            return Action.C
        if S_t >= self.S_safe:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_10(BaseStrategy):
    """
    Opportunistic Defector: Defect by default, but if the common pool stock
    falls below a trigger fraction of capacity, switch into a short regeneration
    mode (cooperate for a couple rounds) to let the pool recover, then defect again.
    Always defect in the last K rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.regen_trigger = 0.3 * self.capacity
        self.regen_target = 0.6 * self.capacity
        self.max_regen_rounds = 2
        self.late_rounds_K = 1
        self.regen_mode = False
        self.regen_rounds_done = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        S_t = self._compute_stock(history)
        if t > self.n_rounds - self.late_rounds_K:
            return Action.D
        if self.regen_mode:
            if self.regen_rounds_done >= self.max_regen_rounds or S_t >= self.regen_target:
                self.regen_mode = False
                self.regen_rounds_done = 0
                return Action.D
            else:
                self.regen_rounds_done += 1
                return Action.C
        if S_t < self.regen_trigger:
            self.regen_mode = True
            self.regen_rounds_done = 1
            return Action.C
        else:
            return Action.D

    def _compute_stock(self, history: PlayerHistory) -> float:
        """
        Reconstructs the common pool stock at the start of the next round
        by simulating consumption and growth over all completed rounds.
        """
        S = self.capacity
        for i in range(history.round_number):
            my_act = history.my_actions[i]
            opp_acts = history.opponent_actions[i]
            coop_count = (1 if my_act else 0) + int(opp_acts.sum())
            def_count = self.n_players - coop_count
            total_consumption = coop_count * (S / (2 * self.n_players)) + def_count * (S / self.n_players)
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S = min(S_remaining + growth, self.capacity)
        return S

class Strategy_AGGRESSIVE_11(BaseStrategy):
    """
    Aggressive Exploiter:
    - Always defect in the first round.
    - In intermediate rounds, defect if all opponents cooperated last round; otherwise cooperate.
    - Always defect in the last k_end rounds (end‐game defection).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k_end = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        total = self.game_description.n_rounds
        if completed >= total - self.k_end:
            return Action.D
        last_ops = history.opponent_actions[completed - 1]
        if last_ops.all():
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_12(BaseStrategy):
    """
    Aggressive Threshold-Regenerator strategy:
    Defect every round except when the common pool stock drops below
    capacity/4 (threshold_low) in an intermediate round, in which case
    it plays one cooperate to let the pool regrow, then resumes defecting.
    Never cooperates in the first or last round, and always defects if
    the pool is empty.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = float(game_description.capacity)
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold_low = self.capacity / 4.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = self.capacity
        n = self.n_players
        cap = self.capacity
        for rnd in range(history.round_number):
            my_act = history.my_actions[rnd]
            coop_count = int(my_act) + int(history.opponent_actions[rnd].sum())
            defect_count = n - coop_count
            cons_C = S / (2.0 * n)
            cons_D = S / float(n)
            total_consumption = coop_count * cons_C + defect_count * cons_D
            S_rem = S - total_consumption
            if S_rem <= 0.0:
                S = 0.0
            else:
                growth = 2.0 * S_rem * (1.0 - S_rem / cap)
                S = min(S_rem + growth, cap)
        if S <= 0.0:
            return Action.D
        if t == 1 or t == self.n_rounds:
            return Action.D
        if S < self.threshold_low:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_13(BaseStrategy):
    """
    Aggressive Conditional Defector (ACD) strategy.
    Always defect except when the common pool stock falls to half-capacity or below,
    in which case cooperate to trigger regrowth. In the first and final rounds
    defect unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.threshold = self.capacity / 2.0
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.stock = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.stock = float(self.capacity)
            return Action.D
        last_index = history.round_number - 1
        S_last = self.stock
        coop_count = int(history.my_actions[last_index])
        coop_count += int(history.opponent_actions[last_index].sum())
        defect_count = self.n_players - coop_count
        cons_coop = S_last / (2.0 * self.n_players)
        cons_def = S_last / float(self.n_players)
        total_consumption = coop_count * cons_coop + defect_count * cons_def
        remaining = S_last - total_consumption
        growth = 2.0 * remaining * (1.0 - remaining / self.capacity)
        new_stock = remaining + growth
        if new_stock > self.capacity:
            new_stock = float(self.capacity)
        if new_stock < 0.0:
            new_stock = 0.0
        self.stock = new_stock
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        if self.stock <= self.threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_14(BaseStrategy):
    """
    Aggressive Harvest Strategy:
    Always defect (Action.D) to maximize short‐term gain until the common pool
    falls to or below the danger threshold T_low = capacity / n_players.
    Then enter a regen phase of fixed length (regen_len rounds) where we cooperate
    (Action.C) to allow regrowth, before returning to aggressive defection.
    On the last round always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.T_low = self.capacity / self.n_players
        self.regen_len = 2
        self.phase = 'Aggressive'
        self.regen_count = 0
        self.stock = float(self.capacity)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            current_round = 1
        else:
            prev_rounds = history.round_number
            if prev_rounds >= 1:
                idx = prev_rounds - 1
                prev_stock = self.stock
                my_coop = bool(history.my_actions[idx])
                opp_acts = history.opponent_actions[idx]
                coop_count = int(opp_acts.sum())
                defect_count = self.n_players - 1 - coop_count
                cons_my = prev_stock / (2 * self.n_players) if my_coop else prev_stock / self.n_players
                cons_opp = coop_count * (prev_stock / (2 * self.n_players)) + defect_count * (prev_stock / self.n_players)
                total_consumption = cons_my + cons_opp
                S_remain = prev_stock - total_consumption
                growth = 2 * S_remain * (1 - S_remain / self.capacity)
                new_stock = S_remain + growth
                self.stock = new_stock if new_stock <= self.capacity else self.capacity
            current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        if self.phase == 'Aggressive':
            if self.stock > self.T_low:
                return Action.D
            else:
                self.phase = 'Regen'
                self.regen_count = 1
                return Action.C
        elif self.regen_count < self.regen_len:
            self.regen_count += 1
            return Action.C
        else:
            self.phase = 'Aggressive'
            return Action.D

class Strategy_AGGRESSIVE_15(BaseStrategy):
    """
    Dynamic Aggressive Exploiter:
    Defect whenever there's a majority cooperation signal or in the last round.
    Briefly cooperate only if everyone defected last round or if the stock is
    below 50% capacity with at least two rounds remaining.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.k = self.n // 2 + 1
        self.alpha = 0.5
        self.stock = self.capacity
        self.last_processed_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        if completed > self.last_processed_round:
            idx = completed - 1
            S_prev = self.stock
            opp_coop = int(np.sum(history.opponent_actions[idx]))
            opp_def = self.n - 1 - opp_coop
            self_coop = 1 if history.my_actions[idx] else 0
            coop_total = opp_coop + self_coop
            def_total = self.n - coop_total
            cons_coop = S_prev / (2 * self.n)
            cons_def = S_prev / self.n
            total_consumption = coop_total * cons_coop + def_total * cons_def
            S_remain = S_prev - total_consumption
            growth = 2 * S_remain * (1 - S_remain / self.capacity)
            self.stock = min(S_remain + growth, self.capacity)
            self.last_processed_round = completed
        t = completed + 1
        idx_prev = completed - 1
        opp_coop_prev = int(np.sum(history.opponent_actions[idx_prev]))
        self_coop_prev = 1 if history.my_actions[idx_prev] else 0
        C_prev = opp_coop_prev + self_coop_prev
        if t == self.r:
            return Action.D
        if C_prev >= self.k:
            return Action.D
        if C_prev == 0 and t < self.r:
            return Action.C
        if 1 <= C_prev < self.k and self.stock < self.alpha * self.capacity and (t < self.r - 1):
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_16(BaseStrategy):
    """
    Aggressive‐exploiter strategy for the common pool resource game.
    Cooperates in round 1, defects in the final round, and in intermediate
    rounds only cooperates if all opponents defected in the previous round
    (to avert collapse); otherwise defects to exploit any cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        prev_idx = history.round_number - 1
        others_prev = history.opponent_actions[prev_idx]
        if not others_prev.any():
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_17(BaseStrategy):
    """
    Aggressive exploit‐and‐maintain strategy: always defect (harvest maximum)
    except when the common‐pool stock falls below a low threshold—in that case
    schedule K rounds of cooperation to kick‐start regrowth. In the last two
    rounds, always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.h = 0.6
        self.l = 0.1
        self.K = 2
        self.T_high = self.h * self.capacity
        self.T_low = self.l * self.capacity
        self.regen_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.regen_counter = 0
            return Action.D
        rounds_played = history.round_number
        S = float(self.capacity)
        for i in range(rounds_played):
            coop_count = int(history.my_actions[i]) + int(np.sum(history.opponent_actions[i]))
            defect_count = self.n_players - coop_count
            total_consumption = coop_count * (S / (2 * self.n_players)) + defect_count * (S / self.n_players)
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S = min(S_remaining + growth, self.capacity)
        if rounds_played >= self.n_rounds - 2:
            return Action.D
        if self.regen_counter > 0:
            self.regen_counter -= 1
            return Action.C
        if S < self.T_low:
            self.regen_counter = self.K - 1
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_18(BaseStrategy):
    """
    Aggressive Grim Defector (AGD): always defects to grab the maximum share each round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_19(BaseStrategy):
    """
    Harassing-Regrowth (HR) strategy:
    Always defect on the first and last round or whenever the common stock
    is above half capacity. Only cooperate when the stock is at or below
    half capacity (to trigger regrowth) and there are future rounds remaining.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        desc = self.game_description
        t = history.round_number + 1
        if t == desc.n_rounds:
            return Action.D
        S = float(desc.capacity)
        for i in range(history.round_number):
            my_consume = float(history.my_payoffs[i])
            opp_consume = float(history.opponent_payoffs[i].sum())
            total_consume = my_consume + opp_consume
            S_remaining = S - total_consume
            growth = 2.0 * S_remaining * (1.0 - S_remaining / desc.capacity)
            S = min(S_remaining + growth, desc.capacity)
        T_low = desc.capacity / 2.0
        if S > T_low:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_20(BaseStrategy):
    """
    Aggressive cyclical exploit‐and‐recover strategy:
      - Always defect in round 1 and in the last round.
      - In between, stay in EXPLOIT (defect) until stock ≤ low_thresh,
        then switch to RECOVER (cooperate) until stock ≥ high_thresh,
        then go back to EXPLOIT.
      - If stock hits zero, always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.phase = 'EXPLOIT'
        self.alpha_low = 0.2
        self.alpha_high = 0.8
        self.capacity = float(game_description.capacity)
        self.n_rounds = game_description.n_rounds
        self.low_thresh = self.alpha_low * self.capacity
        self.high_thresh = self.alpha_high * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        S = self.capacity
        for i in range(history.round_number):
            my_cons = float(history.my_payoffs[i])
            opp_cons = float(history.opponent_payoffs[i].sum())
            total_cons = my_cons + opp_cons
            S_rem = S - total_cons
            if S_rem <= 0:
                S_rem = 0.0
            growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
            S = S_rem + growth
            if S > self.capacity:
                S = self.capacity
        if S <= 0.0:
            return Action.D
        if self.phase == 'EXPLOIT':
            if S <= self.low_thresh:
                self.phase = 'RECOVER'
                return Action.C
            else:
                return Action.D
        elif S >= self.high_thresh:
            self.phase = 'EXPLOIT'
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_21(BaseStrategy):
    """
    Threshold Exploit strategy: defect whenever the common pool
    is at or above half capacity (or on the last round),
    otherwise cooperate to let it regrow.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = float(game_description.capacity)
        self.n_rounds = game_description.n_rounds
        self.threshold = self.capacity / 2.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = self.capacity
        for i in range(history.round_number):
            my_consume = float(history.my_payoffs[i])
            opp_consume = float(np.sum(history.opponent_payoffs[i]))
            total_consumption = my_consume + opp_consume
            S_rem = S - total_consumption
            growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
            S = S_rem + growth
            if S > self.capacity:
                S = self.capacity
        if t == self.n_rounds:
            return Action.D
        if S >= self.threshold:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_22(BaseStrategy):
    """
    Aggressive “exploit-when-you-can, rebuild-only-if-you-must” strategy.
    Defect whenever stock ≥ half capacity or in the last two rounds.
    Cooperate only if stock < half capacity (and not in final two rounds),
    except that if stock hits zero it always defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.T = self.capacity / 2.0
        self.k = 2
        self.current_stock = self.capacity
        self.last_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number > self.last_round:
            i = history.round_number - 1
            opp_coops = int(history.opponent_actions[i].sum())
            my_coop = 1 if history.my_actions[i] else 0
            num_coop = opp_coops + my_coop
            num_def = self.n - num_coop
            S_old = self.current_stock
            coop_cons = S_old / (2.0 * self.n)
            def_cons = S_old / float(self.n)
            total_cons = num_coop * coop_cons + num_def * def_cons
            S_rem = max(0.0, S_old - total_cons)
            growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
            self.current_stock = min(S_rem + growth, self.capacity)
            self.last_round = history.round_number
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        if self.current_stock <= 0.0:
            return Action.D
        if t > self.r - self.k:
            return Action.D
        if self.current_stock >= self.T:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_23(BaseStrategy):
    """
    AggressiveCommonPool: always defect for maximal share except when stock is at or below capacity/n (T_low),
    in which case cooperate once to allow regrowth. Always defect in the final round or if stock is depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = float(game_description.capacity)
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        S = self.capacity
        for round_idx in range(history.round_number):
            my_coop = history.my_actions[round_idx]
            opp_coop_count = int(history.opponent_actions[round_idx].sum())
            coop_count = int(my_coop) + opp_coop_count
            defect_count = self.n - coop_count
            cons_coop = S / (2 * self.n) * coop_count
            cons_def = S / self.n * defect_count
            total_consumption = cons_coop + cons_def
            S_remaining = S - total_consumption
            if S_remaining <= 0.0:
                S = 0.0
            else:
                growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
                S = min(S_remaining + growth, self.capacity)
        t = history.round_number + 1
        if t == self.r or S <= 0.0:
            return Action.D
        T_low = self.capacity / self.n
        if S <= T_low:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_24(BaseStrategy):
    """
    Exploit-and-Preserve (E&P) strategy:
    - Always defect in the first and last rounds.
    - In intermediate rounds, defect if the common pool stock S_t > capacity/2,
      else cooperate to allow regrowth.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t == n_rounds:
            return Action.D
        S = float(capacity)
        for j in range(completed):
            my_consume = float(history.my_payoffs[j])
            opp_consume = float(history.opponent_payoffs[j].sum())
            total_consumption = my_consume + opp_consume
            S_remaining = S - total_consumption
            growth = 2.0 * S_remaining * (1.0 - S_remaining / capacity)
            S = min(S_remaining + growth, capacity)
        T = capacity / 2.0
        if S > T:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_25(BaseStrategy):
    """
    Aggressive-but-sustainable threshold strategy for the Common Pool Resource Game.
    Defects whenever the current stock S_t is at or above the threshold M that guarantees
    strong regrowth, cooperates only if below M to sustain the pool, and defects in the
    last two rounds unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.C = float(game_description.capacity)
        self.M = self.n * self.C / (2.0 * (self.n - 1))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.C
        else:
            t = history.round_number + 1
            S = self.C
            for rnd in range(history.round_number):
                mine = float(history.my_payoffs[rnd])
                opp = float(history.opponent_payoffs[rnd].sum())
                total_consumed = mine + opp
                S_remaining = S - total_consumed
                growth = 2.0 * S_remaining * (1.0 - S_remaining / self.C)
                S = min(S_remaining + growth, self.C)
            S_t = S
        if t >= self.r - 1:
            return Action.D
        if S_t >= self.M:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_26(BaseStrategy):
    """
    Aggressive Minimum Regeneration Defection (AMRD):
    Always defects except briefly cooperates to regenerate when stock is low and
    at least one opponent cooperated in the previous round, then defects
    unconditionally in the final β·r rounds (end‐game).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.alpha = 0.25
        self.beta = 0.2
        self.regen_threshold = self.alpha * self.capacity
        self.endgame_start_round = math.ceil((1 - self.beta) * self.n_rounds)
        self.coop_prev = 0
        self.current_stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round = history.round_number
        self.coop_prev = int(np.sum(history.opponent_actions[last_round - 1]))
        my_consumption = float(history.my_payoffs[last_round - 1])
        opp_consumption = float(np.sum(history.opponent_payoffs[last_round - 1]))
        total_consumption = my_consumption + opp_consumption
        S_remaining = self.current_stock - total_consumption
        growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
        new_stock = S_remaining + growth
        if new_stock > self.capacity:
            new_stock = self.capacity
        self.current_stock = new_stock
        t = last_round + 1
        S_t = self.current_stock
        if t >= self.endgame_start_round:
            return Action.D
        if t == 1:
            return Action.D
        if S_t < self.regen_threshold and self.coop_prev >= 1:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_27(BaseStrategy):
    """
    Aggressive exploitation strategy:
    Defect by default to maximize short‐run payoff, but if the common stock
    falls below a critical threshold (1/3 of capacity) and there are more
    than M=2 rounds remaining, cooperate once to allow regrowth. Always defect
    in the last M rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.T_low = self.capacity / 3.0
        self.M = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            rounds_remaining = self.n_rounds
            S_current = self.capacity
        else:
            rounds_completed = history.round_number
            rounds_remaining = self.n_rounds - rounds_completed
            S_current = float(self.capacity)
            for t in range(rounds_completed):
                coop_opp = int(history.opponent_actions[t].sum())
                coop_self = int(history.my_actions[t])
                coop_count = coop_opp + coop_self
                def_count = self.n - coop_count
                cons_coop = S_current / (2.0 * self.n)
                cons_def = S_current / float(self.n)
                total_consumption = coop_count * cons_coop + def_count * cons_def
                S_rem = S_current - total_consumption
                growth = 2.0 * S_rem * (1.0 - S_rem / float(self.capacity))
                S_next = S_rem + growth
                S_current = min(S_next, float(self.capacity))
        if rounds_remaining <= self.M:
            return Action.D
        if S_current < self.T_low:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_28(BaseStrategy):
    """
    Aggressive‐exploitation with minimal regrowth strategy.
    Defect whenever the pool is above a low‐stock threshold, cooperate
    only to let the pool regrow when it's nearly depleted, and always
    defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.T_low = self.game.capacity / self.game.n_players

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        S = float(self.game.capacity)
        n = self.game.n_players
        cap = float(self.game.capacity)
        rounds_played = history.round_number
        for rnd in range(rounds_played):
            my_act = history.my_actions[rnd]
            opp_acts = history.opponent_actions[rnd]
            num_coop = int(my_act) + int(opp_acts.sum())
            num_def = n - num_coop
            cons_coop = S / (2 * n)
            cons_def = S / n
            total_cons = num_coop * cons_coop + num_def * cons_def
            S_rem = S - total_cons
            growth = 2 * S_rem * (1 - S_rem / cap)
            S = min(S_rem + growth, cap)
        t_next = rounds_played + 1
        if t_next == self.game.n_rounds:
            return Action.D
        if S <= self.T_low:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_29(BaseStrategy):
    """
    Aggressive-but-sustainable strategy:
    - Defects by default to maximize immediate gain.
    - Starts and ends with defection.
    - Cooperates only when the stock falls below half capacity to trigger regrowth.
    - Punishes any opponent who defects against you while you cooperated for K=2 rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_counter = 0
        self.K = 2
        self.L = game_description.capacity / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round = history.round_number - 1
        if last_round >= 0:
            if history.my_actions[last_round] and np.any(~history.opponent_actions[last_round]):
                self.punish_counter = self.K
        t = history.round_number + 1
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = float(capacity)
        for i in range(history.round_number):
            my_consume = history.my_payoffs[i]
            opp_consume = float(np.sum(history.opponent_payoffs[i]))
            total_consume = my_consume + opp_consume
            remaining = stock - total_consume
            growth = 2 * remaining * (1 - remaining / capacity)
            stock = min(remaining + growth, capacity)
        if self.punish_counter > 0:
            action = Action.D
            self.punish_counter -= 1
        elif t == r:
            action = Action.D
        elif stock <= self.L:
            action = Action.C
        else:
            action = Action.D
        return action

class Strategy_AGGRESSIVE_30(BaseStrategy):
    """
    Aggressive‐but‐Sustainable:
    - Phase 1 (rounds 1…k1): always defect.
    - Phase 2 (rounds k1+1…k1+k2): defect while stock ≥ S_min; cooperate while stock < S_min.
    - Phase 3 (last k3 rounds): always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.k1 = self.n_rounds // 3
        self.k3 = self.n_rounds // 3
        self.k2 = self.n_rounds - self.k1 - self.k3
        self.S_min = self.capacity / 4.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = self.capacity
        else:
            t = history.round_number + 1
            S = self.capacity
            for j in range(history.round_number):
                total_consumption = history.my_payoffs[j] + history.opponent_payoffs[j].sum()
                S_rem = S - total_consumption
                growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
                S = min(S_rem + growth, self.capacity)
        if t <= self.k1 or t > self.n_rounds - self.k3:
            return Action.D
        if S < self.S_min:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_31(BaseStrategy):
    """
    Aggressive Defector with Minimal “Stock-Saver”:
    Defects in almost every round to maximize immediate payoff,
    only cooperates when the common pool is critically low
    (below T_low) and there is at least one future round to save,
    and never cooperates in the final final_defect rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.T_low_ratio = 1.0 / (10.0 * self.n)
        self.final_defect = 2
        self.T_low = self.T_low_ratio * self.capacity
        self.final_cutoff = self.r - self.final_defect + 1
        self.emergency = False
        self.current_stock = float(self.capacity)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            prev_rounds = history.round_number
            idx = prev_rounds - 1
            my_last = float(history.my_payoffs[idx])
            opp_last = float(history.opponent_payoffs[idx].sum())
            total_consumption = my_last + opp_last
            S_remain = self.current_stock - total_consumption
            if S_remain < 0.0:
                S_remain = 0.0
            growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
            new_stock = S_remain + growth
            if new_stock > self.capacity:
                new_stock = self.capacity
            self.current_stock = new_stock
            t = prev_rounds + 1
        rem = self.r - t + 1
        S_t = self.current_stock
        if t >= self.final_cutoff:
            return Action.D
        if self.emergency:
            action = Action.C
            if S_t > self.T_low:
                self.emergency = False
            return action
        if S_t <= self.T_low and rem > 1:
            self.emergency = True
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_32(BaseStrategy):
    """
    Aggressive pump-and-dump strategy:
    - Round 1: Defect.
    - Middle rounds: If stock > capacity/2, defect; if stock <= capacity/2 and
      at least one opponent cooperated last round, cooperate once to trigger regrowth;
      otherwise defect.
    - Final round: Defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.C = game_description.capacity
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.T = self.C / 2.0
        self.stock = float(self.C)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.stock = float(self.C)
            return Action.D
        prev_stock = self.stock
        my_last_payoff = history.my_payoffs[-1]
        opp_last_payoffs = history.opponent_payoffs[-1]
        total_consumption = float(my_last_payoff) + float(np.sum(opp_last_payoffs))
        S_remain = prev_stock - total_consumption
        growth = 2.0 * S_remain * (1.0 - S_remain / self.C)
        self.stock = min(S_remain + growth, self.C)
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.stock > self.T:
            return Action.D
        coopers = int(np.sum(history.opponent_actions[-1]))
        if coopers >= 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_33(BaseStrategy):
    """
    Grim‐trigger with planned last‐round defection.
    Start by cooperating. If any opponent ever defects, defect forever after.
    In the very last round, defect regardless.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.flagged_defect = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if self.flagged_defect:
            return Action.D
        if current_round == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        if not history.opponent_actions[last_idx].all():
            self.flagged_defect = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_34(BaseStrategy):
    """
    One-Round Tit-for-Tat with End-Game Defection.
    Cooperate on the first round. In each middle round, cooperate if everyone
    cooperated in the immediately preceding round, otherwise defect to punish
    one round then forgive. Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        last_index = history.round_number - 1
        my_last = history.my_actions[last_index]
        opp_last = history.opponent_actions[last_index]
        if my_last and opp_last.all():
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_35(BaseStrategy):
    """
    Conditional Cooperation with One-Period Punishment (CCOPP) and Last-Round Securing.
    - Start by cooperating.
    - If any opponent defected last round, defect this round and schedule one more round of punishment.
    - Serve the scheduled one-round punishment by defecting and then return to cooperation.
    - In the very last round, always defect to secure maximal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.punished:
            self.punished = False
            return Action.D
        last_idx = history.round_number - 1
        last_ops = history.opponent_actions[last_idx]
        if any((not act for act in last_ops)):
            self.punished = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_36(BaseStrategy):
    """
    1-Round Forgiving Trigger (1R-FT):
    Cooperate initially; if any defection occurs, defect for K=1 rounds to punish;
    forgive thereafter; always defect in final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.K = 1
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        if t == self.r:
            return Action.D
        prev_idx = history.round_number - 1
        prev_my = history.my_actions[prev_idx]
        prev_ops = history.opponent_actions[prev_idx]
        if not prev_my or not np.all(prev_ops):
            self.punish_timer = self.K
            self.punish_timer -= 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_37(BaseStrategy):
    """
    Tit-for-Tat with One-Round Punishment and Endgame Defection:
    - Start by cooperating.
    - If any opponent defects, punish by defecting for exactly P rounds.
    - After P rounds of punishment, forgive and return to cooperation.
    - In the last round, defect to capture the higher one-shot payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 1
        self.pun_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.pun_count = 0
            return Action.C
        completed = history.round_number
        t = completed + 1
        r = self.game_description.n_rounds
        last_idx = completed - 1
        if last_idx >= 0:
            last_ops = history.opponent_actions[last_idx]
            if not last_ops.all():
                self.pun_count = self.P
            else:
                self.pun_count = max(0, self.pun_count - 1)
        if t == 1:
            return Action.C
        if t == r:
            return Action.D
        if self.pun_count > 0:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_38(BaseStrategy):
    """
    Sustainable Tit-for-Tat with Endgame Defection:
    - Start cooperating.
    - If any defection observed in the previous non-punishment round, punish for exactly one round.
    - Forgive after punishment and return to cooperation.
    - Always defect in the final round (endgame).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_length = 1
        self.punish_remaining = 0
        self.last_round_was_punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_remaining = 0
            self.last_round_was_punish = False
            return Action.C
        current_round = history.round_number + 1
        if history.round_number >= 1 and (not self.last_round_was_punish):
            last_idx = history.round_number - 1
            my_last = bool(history.my_actions[last_idx])
            opp_last = history.opponent_actions[last_idx]
            if not my_last or not np.all(opp_last):
                self.punish_remaining = self.punish_length
        if current_round == self.game_description.n_rounds:
            self.last_round_was_punish = False
            return Action.D
        if self.punish_remaining > 0:
            action = Action.D
            self.punish_remaining -= 1
            self.last_round_was_punish = True
        else:
            action = Action.C
            self.last_round_was_punish = False
        return action

class Strategy_COOPERATIVE_39(BaseStrategy):
    """
    Single-Period Punisher (SPP):
    - Round 1: Cooperate.
    - If any player (including yourself) defected in the last round, punish
      with exactly one round of Defection, then forgive (Cooperate) and
      resume cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.forgiving_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.forgiving_counter > 0:
            self.forgiving_counter -= 1
            return Action.C
        last_index = history.round_number - 1
        you_defected = not history.my_actions[last_index]
        opponents = history.opponent_actions[last_index]
        someone_defected = you_defected or not opponents.all()
        if someone_defected:
            self.forgiving_counter = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_40(BaseStrategy):
    """
    Tit-for-Titans strategy for the Common Pool Resource Game:
    - Start by cooperating.
    - If a defection is observed in the previous round, defect and set a one-round punishment timer.
    - While punish_timer > 0, defect and decrement the timer.
    - Otherwise, cooperate.
    - Always defect in the very last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        last_opp = history.opponent_actions[history.round_number - 1]
        if not all(last_opp):
            self.punish_timer = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_41(BaseStrategy):
    """
    Tit‐for‐tat style strategy for the n‐player common‐pool game.
    - Cooperate in the first round.
    - Defect in the final round.
    - If anyone defected in the previous round, punish with a single defection next round,
      then forgive and return to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_next = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punish_next:
            self.punish_next = False
            return Action.D
        last_idx = history.round_number - 1
        my_defected = not bool(history.my_actions[last_idx])
        opp_defected = not bool(history.opponent_actions[last_idx].all())
        if my_defected or opp_defected:
            self.punish_next = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_42(BaseStrategy):
    """
    Tit-for-Tat with Last-Round Defection (TFT-LRD):
    - Round 1: Cooperate.
    - Rounds 2…r-1: If all opponents cooperated last round → Cooperate; else → Defect.
    - Round r: Defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_played = history.round_number
        t = rounds_played + 1
        if t == self.game_description.n_rounds:
            return Action.D
        last_round_idx = rounds_played - 1
        if np.all(history.opponent_actions[last_round_idx]):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_43(BaseStrategy):
    """
    One‐Period Punishment Tit‐for‐Tat (OPP‐TFT):
    Cooperate by default, punish any opponent defection with exactly one round
    of defection, then forgive; always defect in the final round; if the pool
    is empty (no payoff), default to cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.lastDef = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if history.round_number >= 1:
            my_last = history.my_payoffs[-1]
            opp_last = history.opponent_payoffs[-1]
            if my_last == 0 and np.all(opp_last == 0):
                return Action.C
        if t == 1:
            return Action.C
        if t == r:
            return Action.D
        prev_opp_actions = history.opponent_actions[-1]
        if not np.all(prev_opp_actions):
            self.lastDef = t - 1
            return Action.D
        if t == self.lastDef + 1:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_44(BaseStrategy):
    """
    Tit-for-tat with one-round punishment and emergency cooperation when stock is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.k = 1
        self.epsilon = 0.25 * self.capacity
        self.punish_timer = 0
        self.current_stock = float(self.capacity)
        self.last_round_processed = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t_done = history.round_number
        if t_done > self.last_round_processed and t_done > 0:
            idx = t_done - 1
            opp_actions = history.opponent_actions[idx]
            my_act = history.my_actions[idx]
            full = np.append(opp_actions, my_act)
            S = self.current_stock
            c_count = float(full.sum())
            d_count = float(self.n) - c_count
            cons_c = S / (2.0 * self.n)
            cons_d = S / float(self.n)
            total_consumption = c_count * cons_c + d_count * cons_d
            S_remain = S - total_consumption
            growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
            new_S = S_remain + growth
            self.current_stock = max(0.0, min(new_S, self.capacity))
            self.last_round_processed = t_done
        t = history.round_number + 1
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.D
        if self.current_stock < self.epsilon:
            return Action.C
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        idx_last = history.round_number - 1
        if idx_last >= 0:
            opp_last = history.opponent_actions[idx_last]
            my_last = history.my_actions[idx_last]
            full_last = np.append(opp_last, my_last)
            if not full_last.all():
                self.punish_timer = self.k - 1
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_45(BaseStrategy):
    """
    Tit-for-Tat with End-Game Defection and Minimal-Stock Safety:
    - Cooperates in round 1.
    - In rounds t<r:
      * If stock ≤ ε: cooperates (to avoid collapse).
      * Else if in punishment mode: defects one round, then exits punishment.
      * Else if any opponent defected last round: enters one-round punish mode and defects.
      * Else cooperates.
    - Always defects in the last round.
    Tracks the common-pool stock via updates after each completed round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.epsilon = self.capacity * 0.01
        self.punishRemaining = 0
        self.current_stock = self.capacity
        self.last_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishRemaining = 0
            self.last_round = 0
            self.current_stock = self.capacity
            return Action.C
        completed = history.round_number
        if completed > self.last_round:
            S_prev = self.current_stock
            idx = completed - 1
            total_consumption = 0.0
            if history.my_actions[idx]:
                total_consumption += S_prev / (2 * self.n)
            else:
                total_consumption += S_prev / self.n
            opp_last = history.opponent_actions[idx]
            coop_count = int(np.sum(opp_last))
            def_count = self.n - 1 - coop_count
            total_consumption += coop_count * (S_prev / (2 * self.n))
            total_consumption += def_count * (S_prev / self.n)
            S_rem = S_prev - total_consumption
            growth = 2 * S_rem * (1 - S_rem / self.capacity)
            new_stock = S_rem + growth
            self.current_stock = new_stock if new_stock <= self.capacity else self.capacity
            self.last_round = completed
        t = completed + 1
        if t == self.r:
            return Action.D
        if t == 1:
            return Action.C
        if self.current_stock <= self.epsilon:
            return Action.C
        if self.punishRemaining > 0:
            self.punishRemaining -= 1
            return Action.D
        if np.any(history.opponent_actions[completed - 1] == False):
            self.punishRemaining = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_46(BaseStrategy):
    """
    Forgiving Tit-for-Tat with Endgame Defection.
    Cooperate initially, punish defections for P rounds, forgive thereafter,
    and always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        opp_actions = history.opponent_actions
        rounds_played = opp_actions.shape[0]
        last_defect = 0
        for idx in range(rounds_played):
            if not opp_actions[idx].all():
                last_defect = idx + 1
        rounds_since = t - last_defect - 1
        if rounds_since <= self.P:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_47(BaseStrategy):
    """
    One‐Step Tit‐For‐Tat with End‐Game Defection:
    - Start cooperating to sustain the pool.
    - Punish any defection by one-round defection, then forgive.
    - Defect in the final round (no future).
    - If stock is zero, defect for residual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.punish_flag = False
        self.last_round = 0
        self.current_stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            completed = history.round_number
            if completed > self.last_round:
                idx = completed - 1
                S_prev = self.current_stock
                opp = history.opponent_actions[idx]
                me = history.my_actions[idx]
                all_actions = [bool(me)] + [bool(a) for a in opp]
                cons_C = S_prev / (2 * self.n)
                cons_D = S_prev / self.n
                total_cons = sum((cons_C if a else cons_D for a in all_actions))
                S_rem = S_prev - total_cons
                growth = 2 * S_rem * (1 - S_rem / self.capacity)
                self.current_stock = max(0.0, min(S_rem + growth, self.capacity))
                self.last_round = completed
            t = history.round_number + 1
        if t == 1:
            return Action.C
        if t == self.r:
            return Action.D
        if self.current_stock <= 0.0:
            return Action.D
        if self.punish_flag:
            self.punish_flag = False
            return Action.C
        prev_idx = t - 2
        opp_prev = history.opponent_actions[prev_idx]
        if not opp_prev.all():
            self.punish_flag = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_48(BaseStrategy):
    """
    Conditional Cooperator with Regrowth Concern and Forgiving Punishment.
    Generous tit-for-tat: start with cooperation, one-round punishment,
    low-stock bailout, defect on final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishing = False
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        capacity = float(self.game_description.capacity)
        n = self.game_description.n_players
        S = capacity
        for i in range(history.round_number):
            my_act = history.my_actions[i]
            opp_acts = history.opponent_actions[i]
            coop_count = (1 if my_act else 0) + int(np.sum(opp_acts))
            defect_count = n - coop_count
            cons_coop = S / (2 * n)
            cons_def = S / n
            total_consumption = coop_count * cons_coop + defect_count * cons_def
            S_rem = S - total_consumption
            growth = 2 * S_rem * (1 - S_rem / capacity)
            S = min(S_rem + growth, capacity)
        t = history.round_number + 1
        low_frac = 0.25
        threshold = low_frac * capacity
        punish_len = 1
        if S <= threshold:
            if self.punishing and self.punish_timer > 0:
                action = Action.D
                self.punish_timer -= 1
                if self.punish_timer == 0:
                    self.punishing = False
            else:
                action = Action.C
        elif self.punishing:
            action = Action.D
            self.punish_timer -= 1
            if self.punish_timer == 0:
                self.punishing = False
        else:
            last_idx = history.round_number - 1
            if (~history.opponent_actions[last_idx]).any():
                self.punishing = True
                self.punish_timer = punish_len
                action = Action.D
                self.punish_timer -= 1
                if self.punish_timer == 0:
                    self.punishing = False
            elif t == self.game_description.n_rounds:
                action = Action.D
            else:
                action = Action.C
        return action

class Strategy_COOPERATIVE_49(BaseStrategy):
    """
    Forgiving Tit-for-Tat for a common-pool resource game.
    Cooperate initially and while no defection occurred last round.
    If any player defected last round, defect exactly once to punish, then forgive.
    Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishedFlag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishedFlag = False
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        last_idx = history.round_number - 1
        my_last = history.my_actions[last_idx]
        opp_last = history.opponent_actions[last_idx]
        any_opp_defected = np.any(~opp_last)
        lastDefected = not my_last or any_opp_defected
        if lastDefected and (not self.punishedFlag):
            self.punishedFlag = True
            return Action.D
        if not lastDefected:
            self.punishedFlag = False
        return Action.C

class Strategy_COOPERATIVE_50(BaseStrategy):
    """
    Tit‐for‐Tat with Limited Punishment (TFT‐LP):
    - Cooperate in the first and last rounds.
    - If any player (including self) defected in the previous round,
      defect for P consecutive rounds as punishment.
    - Otherwise cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 2
        self.punish_counter = 0
        self.last_round_any_D = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if history.round_number > 0:
            my_last = history.my_actions[-1]
            opp_last = history.opponent_actions[-1]
            self.last_round_any_D = not my_last or not opp_last.all()
        if current_round == self.game_description.n_rounds:
            return Action.C
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        if self.last_round_any_D:
            self.punish_counter = self.P - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_51(BaseStrategy):
    """
    Conditional Tit-for-Tat with forgiveness and end-game defection.
    Starts with cooperation, punishes any opponent defection with P rounds
    of defection, then forgives back to cooperation. Always defects in the
    last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishing = False
        self.punish_left = 0
        self.P = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punishing:
            action = Action.D
            self.punish_left -= 1
            if self.punish_left <= 0:
                self.punishing = False
            return action
        last_idx = history.round_number - 1
        if not history.opponent_actions[last_idx].all():
            self.punishing = True
            self.punish_left = self.P
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_52(BaseStrategy):
    """
    TFT-CPR: Tit‐for‐Tat for Common‐Pool Resource.
    Cooperate by default, defect in the last round.
    If any opponent defects in round t, punish in round t+1 with a single defection, then forgive.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punished = False
        self.last_defector_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        last_idx = history.round_number - 1
        if not history.opponent_actions[last_idx].all():
            self.last_defector_round = history.round_number
        if current_round == total_rounds:
            return Action.D
        if self.last_defector_round == current_round - 1:
            self.punished = True
        if self.punished:
            self.punished = False
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_53(BaseStrategy):
    """
    Tit-for-tat with single-round punishment and endgame defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.state = 'COOP'
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            if self.punish_timer == 0:
                self.state = 'COOP'
            return Action.D
        if self.state == 'COOP':
            last_round_idx = history.round_number - 1
            opp_last = history.opponent_actions[last_round_idx]
            if opp_last.all():
                return Action.C
            else:
                self.state = 'PUNISH'
                self.punish_timer = 1
                return Action.D
        self.state = 'COOP'
        return Action.C

class Strategy_COOPERATIVE_54(BaseStrategy):
    """
    State-Aware Tit-for-Tat with Endgame Defection (SATT-ED):
    - Cooperates initially and when resource is healthy.
    - Punishes defections for L rounds.
    - Helps recover when stock is very low.
    - Defects unconditionally in the last E rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.L = 1
        self.E = 1
        self.alpha = 0.1
        self.punish_timer = 0
        self.current_stock = float(game_description.capacity)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_timer = 0
            self.current_stock = float(self.game_description.capacity)
            return Action.C
        last_idx = history.round_number - 1
        my_consume = float(history.my_payoffs[last_idx])
        opp_consume = float(np.sum(history.opponent_payoffs[last_idx]))
        total_consumption = my_consume + opp_consume
        S_prev = self.current_stock
        S_remaining = S_prev - total_consumption
        cap = float(self.game_description.capacity)
        growth = 2.0 * S_remaining * (1.0 - S_remaining / cap)
        self.current_stock = min(S_remaining + growth, cap)
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round > total_rounds - self.E:
            return Action.D
        if self.current_stock < self.alpha * cap:
            return Action.C
        if self.punish_timer > 0:
            action = Action.D
            self.punish_timer -= 1
            return action
        last_opp_actions = history.opponent_actions[last_idx]
        if current_round > 1 and np.any(~last_opp_actions):
            self.punish_timer = self.L - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_55(BaseStrategy):
    """
    Tit-for-Tat with Endgame Defection for the Common Pool Resource Game.

    - Round 1: Cooperate.
    - Rounds 2 to r-1:
        * If in punishment phase, defect and decrement punishment counter.
        * Else if any opponent defected in the previous round, set one-round punishment and defect.
        * Otherwise, cooperate.
    - Round r (last round): Defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishing = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds - 1:
            return Action.D
        if self.punishing > 0:
            self.punishing -= 1
            return Action.D
        last_idx = current_round - 1
        last_actions = history.opponent_actions[last_idx]
        if not last_actions.all():
            self.punishing = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_56(BaseStrategy):
    """
    STFED: Sustained Tit-For-Tat with Endgame Defection.
    Cooperate initially, punish any defection with a single round of defection,
    then return to cooperation. Defect in the very last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        R = self.game_description.n_rounds - t + 1
        if R == 1:
            return Action.D
        if self.punish_flag:
            self.punish_flag = False
            return Action.D
        prev_idx = completed - 1
        prev_my_action = history.my_actions[prev_idx]
        prev_op_actions = history.opponent_actions[prev_idx]
        if not prev_my_action or not np.all(prev_op_actions):
            self.punish_flag = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_57(BaseStrategy):
    """
    Generous Tit-for-Tat with One-Round Punishment:
    - Round 1: Cooperate.
    - Rounds 2..r-1: If in punishment (p>0), defect and decrement p.
      Otherwise, if any player (including self) defected last round, defect
      and set p=1 for next round; else cooperate.
    - Round r: Defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        total_rounds = self.game_description.n_rounds
        current_round = completed + 1
        if current_round == total_rounds:
            return Action.D
        if self.p > 0:
            self.p -= 1
            return Action.D
        last_idx = completed - 1
        my_last = not history.my_actions[last_idx]
        opp_last = not history.opponent_actions[last_idx].all()
        if my_last or opp_last:
            self.p = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_58(BaseStrategy):
    """
    Trigger‐and‐punish strategy for the Common Pool Resource Game.
    - Cooperates (C) as long as no deviation has been detected and not in last round.
    - Defects (D) forever once any deviation is observed (grim trigger).
    - Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_flag = False
        self.epsilon = 0.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            if self.game_description.n_rounds == 1:
                return Action.D
            return Action.C
        completed_rounds = history.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if completed_rounds < n_rounds:
            last_my_payoff = history.my_payoffs[-1]
            last_op_payoffs = history.opponent_payoffs[-1]
            total_consumption = last_my_payoff + float(np.sum(last_op_payoffs))
            threshold = last_my_payoff * n_players + self.epsilon
            if total_consumption > threshold:
                self.defect_flag = True
        current_round = completed_rounds + 1
        if current_round == n_rounds:
            return Action.D
        if self.defect_flag:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_59(BaseStrategy):
    """
    Tit‐for‐Tat with finite punishment and last‐round defection for the
    repeated common‐pool‐resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.P = max(1, min(3, self.n_rounds - 2))
        self.punish_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        if self.punish_remaining > 0:
            self.punish_remaining -= 1
            return Action.D
        last_idx = history.round_number - 1
        last_opponents = history.opponent_actions[last_idx]
        if all(last_opponents):
            return Action.C
        else:
            self.punish_remaining = self.P - 1
            return Action.D

class Strategy_COOPERATIVE_60(BaseStrategy):
    """
    Cooperative trigger strategy for the common‐pool resource game.
    Starts by cooperating, punishes any defection for p=1 rounds,
    forgives quickly, cooperates if stock is low (below capacity/2),
    and always defects in the last round (M=1).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.p = 1
        self.M = 1
        self.T = self.capacity / 2.0
        self.punishLeft = 0
        self.current_stock = self.capacity
        self._last_updated_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t_prev = history.round_number
        if t_prev > self._last_updated_round:
            my_cons = float(history.my_payoffs[-1])
            opp_cons = float(np.sum(history.opponent_payoffs[-1]))
            total_cons = my_cons + opp_cons
            S_remain = self.current_stock - total_cons
            growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
            new_stock = S_remain + growth
            self.current_stock = max(0.0, min(new_stock, self.capacity))
            self._last_updated_round = t_prev
        t = history.round_number + 1
        if t > self.r - self.M:
            return Action.D
        if self.punishLeft > 0:
            self.punishLeft -= 1
            return Action.D
        if self.current_stock < self.T:
            return Action.C
        last_my = history.my_actions[-1]
        last_opps = history.opponent_actions[-1]
        if not last_my or not np.all(last_opps):
            self.punishLeft = self.p
            self.punishLeft -= 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_61(BaseStrategy):
    """
    One‐round tit‐for‐tat with end‐game defection for the common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_until = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number
        if last_round > 0:
            last_opponents = history.opponent_actions[last_round - 1]
            if not last_opponents.all():
                self.punish_until = last_round + 1
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if t <= self.punish_until:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_62(BaseStrategy):
    """
    Multi‐player Tit‐for‐Tat with one‐round punishment and last‐round defection.
    - Start by cooperating.
    - If any player defected in the previous round, defect this round (punishment).
    - Forgive immediately if all cooperated in the round following a defection.
    - Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_defection_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.last_defection_flag = False
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        last_my = history.my_actions[-1]
        last_opponents = history.opponent_actions[-1]
        self.last_defection_flag = not (last_my and last_opponents.all())
        if t == r:
            return Action.D
        if self.last_defection_flag:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_63(BaseStrategy):
    """
    Cooperator with disciplined punishment:
    Cooperates by default to sustain the pool, punishes defections for a fixed P rounds,
    defects if the stock is low, and always cooperates in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punish_timer = 0
        self.S_low = self.capacity / 4.0
        self.P = max(1, math.floor(self.r / 10))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        S = self.capacity
        for k in range(completed):
            coop_count = int(history.my_actions[k]) + int(history.opponent_actions[k].sum())
            def_count = self.n - coop_count
            total_consumption = coop_count * (S / (2 * self.n)) + def_count * (S / self.n)
            S_remain = S - total_consumption
            growth = 2 * S_remain * (1 - S_remain / self.capacity)
            S = min(S_remain + growth, self.capacity)
        if S <= self.S_low:
            return Action.D
        if t == self.r:
            return Action.C
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        last_op_actions = history.opponent_actions[completed - 1]
        if not all(last_op_actions):
            self.punish_timer = self.P - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_64(BaseStrategy):
    """
    Grim‐trigger with endgame defection for the common pool resource game.
    Cooperate in rounds 1…r-1 until any defection is observed, then defect forever.
    Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_round = self.game_description.n_rounds
        punishing = not history.opponent_actions.all()
        if current_round == last_round:
            return Action.D
        if punishing:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_65(BaseStrategy):
    """
    Generous Tit‐for‐Tat with One‐Round Punishment:
    - Start by cooperating.
    - If any player defected in the previous round, punish by defecting exactly once.
    - Then return to cooperation.
    - In the final round, if no one has ever defected, cooperate; otherwise defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_remaining = 0
        self.ever_defected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        prev_rounds = history.round_number
        t = prev_rounds + 1
        r = self.game_description.n_rounds
        last_my = bool(history.my_actions[-1])
        last_opp_all_cooperate = bool(history.opponent_actions[-1].all())
        defected_last = not (last_my and last_opp_all_cooperate)
        if defected_last:
            self.ever_defected = True
        if self.punish_remaining > 0:
            self.punish_remaining -= 1
            return Action.D
        if t == r:
            return Action.C if not self.ever_defected else Action.D
        if defected_last:
            self.punish_remaining = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_66(BaseStrategy):
    """
    Group Tit-for-Tat with Limited Punishment:
    Cooperate on the first round, defect in the last round,
    and punish any opponent defection with a single-round defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        prev_round_idx = history.round_number - 1
        if prev_round_idx >= 0 and (not history.opponent_actions[prev_round_idx].all()):
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_67(BaseStrategy):
    """
    Resource‐Aware Generous Conditional Cooperation (RAGCC) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.f = 0.2
        self.S_low = self.capacity / 3.0
        self.punished_last_round = False
        self.current_stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punished_last_round = False
            self.current_stock = self.capacity
            return Action.C
        last_my_payoff = history.my_payoffs[-1]
        last_opp_payoffs = history.opponent_payoffs[-1]
        total_consumption = float(last_my_payoff) + float(last_opp_payoffs.sum())
        S_rem = self.current_stock - total_consumption
        growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
        new_stock = min(S_rem + growth, self.capacity)
        self.current_stock = new_stock
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.current_stock <= self.S_low:
            self.punished_last_round = False
            return Action.C
        last_opp_actions = history.opponent_actions[-1]
        num_opp_defectors = len(last_opp_actions) - int(last_opp_actions.sum())
        self_defected_last = not bool(history.my_actions[-1])
        total_defectors = num_opp_defectors + (1 if self_defected_last else 0)
        d_frac = total_defectors / float(self.n)
        if d_frac <= self.f:
            self.punished_last_round = False
            return Action.C
        elif not self.punished_last_round:
            self.punished_last_round = True
            return Action.D
        else:
            self.punished_last_round = False
            return Action.C

class Strategy_COOPERATIVE_68(BaseStrategy):
    """
    Lenient Tit-for-Tat with one-round punishment and terminal defection.
    - P = 1 (length of punishment)
    - Cooperate in round 1
    - If anyone defected last round, defect for up to P rounds, then forgive
    - Always defect in the final round
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 1
        self.punCounter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punCounter = 0
            return Action.C
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        if self.punCounter > 0:
            self.punCounter -= 1
            return Action.D
        last_opp = history.opponent_actions[history.round_number - 1]
        if not last_opp.all():
            self.punCounter = self.P - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_69(BaseStrategy):
    """
    Forgiving trigger strategy for the common‐pool resource game.
    Start cooperating, punish any defection with K rounds of defection,
    then forgive and return to cooperation. Always defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.K = 1
        self.coop_state = True
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        current_round = completed + 1
        total_rounds = self.game_description.n_rounds
        in_punish = self.punish_counter > 0
        if self.punish_counter > 0:
            self.punish_counter -= 1
            if self.punish_counter == 0:
                self.coop_state = True
        if not in_punish and self.coop_state and (completed > 0):
            last_opp = history.opponent_actions[completed - 1]
            if not last_opp.all():
                self.coop_state = False
                self.punish_counter = self.K
        if current_round == total_rounds:
            return Action.D
        if in_punish:
            return Action.D
        if not self.coop_state:
            self.coop_state = True
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_70(BaseStrategy):
    """
    Tit-for-Tat with limited punishment and end-game defection:
    - Cooperate on the first round.
    - For rounds 2…r-1, defect if any opponent defected in the previous round (punish one round), otherwise cooperate.
    - Defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        last_opponent_actions = history.opponent_actions[last_idx]
        if not last_opponent_actions.all():
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_71(BaseStrategy):
    """
    Forgiving Trigger with Last-Round Defection:
    Cooperate by default, detect over-consumption (> half the stock),
    punish defectors briefly, forgive quickly, and defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.K_punish = 1
        self.last_stock = self.capacity
        self.punish_timer = 0
        self.eps = 1e-08

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        last_my_payoff = history.my_payoffs[-1]
        last_opp_payoffs = history.opponent_payoffs[-1].sum()
        total_consumption = last_my_payoff + float(last_opp_payoffs)
        prev_stock = self.last_stock
        S_remain = prev_stock - total_consumption
        growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
        new_stock = min(S_remain + growth, self.capacity)
        coop_total = prev_stock / 2.0
        detection = total_consumption > coop_total + self.eps
        if t == self.r:
            action = Action.D
        elif self.punish_timer > 0:
            action = Action.D
            self.punish_timer -= 1
        elif detection:
            self.punish_timer = self.K_punish
            action = Action.D
        else:
            action = Action.C
        self.last_stock = new_stock
        return action

class Strategy_COOPERATIVE_72(BaseStrategy):
    """
    Cooperative trigger-and-forgive strategy for the common-pool resource game.
    Start by cooperating; if any player (including yourself) defected in the previous round,
    punish by defecting for exactly one round, then immediately forgive and return to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_flag = False
            return Action.C
        last_idx = history.round_number - 1
        my_cooperated_last = bool(history.my_actions[last_idx])
        opponents_cooperated_last = bool(np.all(history.opponent_actions[last_idx]))
        defected_last = not (my_cooperated_last and opponents_cooperated_last)
        if self.punish_flag:
            self.punish_flag = False
            return Action.D
        if defected_last:
            self.punish_flag = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_73(BaseStrategy):
    """
    Sustainable Multi‐Player Tit-for-Tat with One-Round Punishment.
    Cooperates initially, punishes defections for a fixed duration,
    forgives thereafter, avoids punishment if stock is low,
    and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_duration = 1
        self.punish_rounds = 0
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.low_stock_threshold = 2 * self.capacity / self.n

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None or history.round_number == 0:
            return Action.C
        t = history.round_number + 1
        S = self.capacity
        for k in range(history.round_number):
            cons_my = history.my_payoffs[k]
            cons_opp = history.opponent_payoffs[k].sum()
            S_remain = S - (cons_my + cons_opp)
            growth = 2 * S_remain * (1 - S_remain / self.capacity)
            S = min(S_remain + growth, self.capacity)
        if S < self.low_stock_threshold:
            self.punish_rounds = 0
            return Action.C
        if t == self.n_rounds:
            return Action.D
        if self.punish_rounds > 0:
            self.punish_rounds -= 1
            return Action.D
        last_ops = history.opponent_actions[history.round_number - 1]
        if (~last_ops).any():
            self.punish_rounds = self.punish_duration
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_74(BaseStrategy):
    """
    Generous tit-for-tat with endgame:
    - Always cooperate unless punishing or in the final round.
    - Punish any defection for up to 2 rounds.
    - Forgive after punishment ends.
    - Defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        rounds_completed = history.round_number
        if rounds_completed > 0:
            last_idx = rounds_completed - 1
            if not history.opponent_actions[last_idx].all():
                self.punish_rounds = min(2, self.game_description.n_rounds - rounds_completed)
        current_round = rounds_completed + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        if self.punish_rounds > 0:
            self.punish_rounds -= 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_75(BaseStrategy):
    """
    Tit-for-Tat style strategy for the common-pool resource game:
    - Cooperate on the first move.
    - If any opponent defected in the previous round, defect this round (one-round punishment).
    - Automatically forgive after one round of punishment.
    - Defect on the last round to avoid end-game exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if not self.punish and history.round_number >= 1:
            last_ops = history.opponent_actions[history.round_number - 1]
            if not all(last_ops):
                self.punish = True
        if t == total_rounds:
            return Action.D
        if self.punish:
            self.punish = False
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_76(BaseStrategy):
    """
    Tit-for-tat with one-round punishment, forgiveness, end-game defection,
    and cooperative rebuild when stock is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 1
        self.S_low_frac = 0.5
        self.punish_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_rounds_remaining = 0
            return Action.C
        t = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        S = capacity
        for k in range(history.round_number):
            total_consumption = float(history.my_payoffs[k]) + float(history.opponent_payoffs[k].sum())
            S_remain = S - total_consumption
            growth = 2 * S_remain * (1 - S_remain / capacity)
            S = min(S_remain + growth, capacity)
        last_defected = False
        if history.round_number >= 1:
            last_actions = history.opponent_actions[history.round_number - 1]
            if not all(last_actions):
                last_defected = True
        if t == n_rounds:
            action = Action.D
        elif S < self.S_low_frac * capacity:
            action = Action.C
        elif self.punish_rounds_remaining > 0:
            action = Action.D
            self.punish_rounds_remaining -= 1
        elif last_defected:
            action = Action.D
            self.punish_rounds_remaining = self.P - 1
        else:
            action = Action.C
        return action

class Strategy_COOPERATIVE_77(BaseStrategy):
    """
    Tit-for-Tat Common-Pool (TfT-CP) strategy:
    - Cooperate in round 1.
    - In rounds 1 < t < r: if any defection occurred in the previous round, defect; otherwise cooperate.
    - In round r: defect unconditionally.
    - Tracks whether a defection occurred in the immediately preceding round to punish once and then forgive.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.lastDefectionOccurred = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.lastDefectionOccurred = False
            return Action.C
        t = history.round_number + 1
        my_last = history.my_actions[-1]
        opp_last = history.opponent_actions[-1]
        if not my_last or not opp_last.all():
            self.lastDefectionOccurred = True
        else:
            self.lastDefectionOccurred = False
        if t == self.game_description.n_rounds:
            return Action.D
        if self.lastDefectionOccurred:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_78(BaseStrategy):
    """
    Generous tit‐for‐tat with end‐game:
    - Start by cooperating.
    - Punish any opponent defection by defecting exactly one round, then forgive.
    - Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            current_round = 1
        else:
            current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        if history is not None:
            last_ops = history.opponent_actions[history.round_number - 1]
            if not last_ops.all():
                self.punish_counter = 1
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_79(BaseStrategy):
    """
    Forgiving Tit‐for‐Tat for the Common Pool Resource Game.
    Starts by cooperating, punishes any defection with two rounds of defection,
    then returns to cooperation. Always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        current_round = completed + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punish_left > 0:
            self.punish_left -= 1
            return Action.D
        last_idx = completed - 1
        if last_idx >= 0 and (not history.opponent_actions[last_idx].all()):
            self.punish_left = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_80(BaseStrategy):
    """
    Conditional‐cooperation with finite punishment:
    - Start by cooperating.
    - If any opponent defects, defect for a fixed number of rounds k, then forgive.
    - Always defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.k = 2
        self.punishing = False
        self.remaining_punish = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        if self.punishing:
            action = Action.D
            self.remaining_punish -= 1
            if self.remaining_punish == 0:
                self.punishing = False
            return action
        last_idx = history.round_number - 1
        if (~history.opponent_actions[last_idx]).any():
            self.punishing = True
            self.remaining_punish = min(self.k, self.n_rounds - t)
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_81(BaseStrategy):
    """
    Tit-for-Tat with Forgiveness for the Common Pool Resource game.
    - Start by cooperating.
    - If any opponent defected in the last round, punish with one defect.
    - After punishing once, forgive and return to cooperation.
    - Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.punish > 0:
            self.punish -= 1
            return Action.D
        prev_idx = history.round_number - 1
        last_opponent_actions = history.opponent_actions[prev_idx]
        if not last_opponent_actions.all():
            self.punish = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_82(BaseStrategy):
    """
    Reciprocal cooperation strategy:
    - Start by cooperating.
    - If any player defected in the previous round, defect this round (one-round punishment).
    - Forgive immediately thereafter.
    - In the last round, if nobody has ever defected before, defect to exploit; otherwise cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_counter = 0
        self.ever_defected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if not self.ever_defected:
            if (~history.my_actions).any() or (~history.opponent_actions).any():
                self.ever_defected = True
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        prev_idx = history.round_number - 1
        if prev_idx >= 0:
            my_prev = history.my_actions[prev_idx]
            opp_prev = history.opponent_actions[prev_idx]
            if not my_prev or not opp_prev.all():
                self.punish_counter = 1
                return Action.D
        if t == r:
            if not self.ever_defected:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COOPERATIVE_83(BaseStrategy):
    """
    Limited Punishment Tit‐for‐Tat with Endgame Defection.
    Cooperate on round 1. In any intermediate round, if a defection
    was observed in the immediately preceding round and we are not
    already in a cooldown, defect exactly once to punish, then
    enter a one‐round cooldown (during which we cooperate regardless
    of observed defections). In the final round, always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        last_my = history.my_actions[last_idx]
        last_opp = history.opponent_actions[last_idx]
        last_defection = not bool(last_my) or any((not bool(a) for a in last_opp))
        if last_defection and self.punish_counter == 0:
            self.punish_counter = 1
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_84(BaseStrategy):
    """
    CCMP: Conditional Cooperation with Minimal Punishment.
    Cooperates by default to sustain the common pool, punishes any
    one-off defection with a single round of defection (tit-for-tat),
    uses end-game defection in the last round, and overrides to
    cooperate if the stock falls below a low-stock threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punish_timer = 0
        self.k = 1
        self.S_threshold = self.capacity / (4 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if history.round_number == 0:
            S_t = self.capacity
        else:
            last_payoff = history.my_payoffs[-1]
            last_action = history.my_actions[-1]
            if last_action:
                S_last = last_payoff * (2 * self.n)
            else:
                S_last = last_payoff * self.n
            opp_acts = history.opponent_actions[-1]
            all_acts = np.concatenate((np.array([last_action]), opp_acts), axis=0)
            coop_cons = S_last / (2 * self.n)
            def_cons = S_last / self.n
            cons = np.where(all_acts, coop_cons, def_cons)
            total_cons = float(cons.sum())
            S_rem = S_last - total_cons
            growth = 2 * S_rem * (1 - S_rem / self.capacity)
            S_t = min(S_rem + growth, self.capacity)
        if S_t <= self.S_threshold:
            return Action.C
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        last_opp = history.opponent_actions[-1]
        if np.any(last_opp == False):
            self.punish_timer = self.k
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_85(BaseStrategy):
    """
    A limited‐punishment common‐pool strategy:
    - Cooperate initially and if everyone cooperated last round.
    - Upon any defection, defect for k rounds (quick punishment), then forgive.
    - Always defect in the last round.
    - If stock ≤ capacity/4, switch to salvage defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.k = max(3, self.r // 10)
        self.S_salvage = self.capacity / 4.0
        self.pun_counter = 0
        self.last_round = 0
        self.stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None:
            while self.last_round < history.round_number:
                idx = self.last_round
                S_old = self.stock
                opp_coops = int(np.sum(history.opponent_actions[idx]))
                my_coop = 1 if history.my_actions[idx] else 0
                coop_count = opp_coops + my_coop
                def_count = self.n - coop_count
                c_coop = S_old / (2 * self.n)
                c_def = S_old / self.n
                total_cons = coop_count * c_coop + def_count * c_def
                S_rem = S_old - total_cons
                growth = 2 * S_rem * (1 - S_rem / self.capacity)
                self.stock = min(S_rem + growth, self.capacity)
                self.last_round += 1
            t = history.round_number + 1
        else:
            t = 1
        if t == self.r:
            return Action.D
        if self.stock <= self.S_salvage:
            return Action.D
        if self.pun_counter > 0:
            self.pun_counter -= 1
            return Action.D
        if t == 1:
            return Action.C
        idx_last = t - 2
        everyone_coop = history.my_actions[idx_last] and bool(np.all(history.opponent_actions[idx_last]))
        if everyone_coop:
            return Action.C
        else:
            self.pun_counter = self.k - 1
            return Action.D

class Strategy_COOPERATIVE_86(BaseStrategy):
    """
    Full‐cooperation baseline with finite‐horizon punishment:
    Cooperate unless opponents have defected in the past, in which case
    defect for P rounds (P = n_players), then forgive. Always defect in
    the last round to avoid exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = game_description.n_players
        self.r = game_description.n_rounds
        self.last_defect_round = 0
        self.punishment_until = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        if t == self.r:
            return Action.D
        for i in range(completed):
            if not history.opponent_actions[i].all():
                self.last_defect_round = max(self.last_defect_round, i + 1)
        if self.last_defect_round > 0:
            end_of_punishment = self.last_defect_round + self.P
            if self.punishment_until < end_of_punishment:
                self.punishment_until = end_of_punishment
        if t <= self.punishment_until:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_87(BaseStrategy):
    """
    Tit-for-Tat with End-Game Defection:
    - Start by cooperating.
    - Punish any opponent defection with one round of defection.
    - Forgive immediately after punishment.
    - Defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        prev_idx = history.round_number - 1
        if not history.opponent_actions[prev_idx].all():
            self.punish_counter = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_88(BaseStrategy):
    """
    Cooperative trigger strategy with limited punishment and endgame defection.
    Starts with cooperation, punishes any defection for P=2 rounds, then forgives.
    In the final E=1 rounds, always defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 2
        self.E = 1
        self.punishment_left = 0
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_left = 0
            return Action.C
        t = history.round_number + 1
        if t > self.r - self.E:
            return Action.D
        if self.punishment_left > 0:
            self.punishment_left -= 1
            return Action.D
        last_round_idx = history.round_number - 1
        last_opponent_actions = history.opponent_actions[last_round_idx]
        if not last_opponent_actions.all():
            self.punishment_left = self.P - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_89(BaseStrategy):
    """
    Tit-for-Tat with one-round punishment and end-game generosity in the common-pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punished = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            all_my_coop = history.my_actions.all()
            all_opp_coop = history.opponent_actions.all()
            if all_my_coop and all_opp_coop:
                return Action.C
            else:
                return Action.D
        last_defection = False
        if history.round_number >= 1:
            if not history.my_actions[-1]:
                last_defection = True
            elif not history.opponent_actions[-1].all():
                last_defection = True
        if self.punished:
            self.punished = False
            return Action.D
        if last_defection:
            self.punished = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_90(BaseStrategy):
    """
    Responsive Conditional Cooperation (RCC):
    Tit-for-tat–style cooperation with proportional, short punishment
    and last-round forgiveness in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.pun_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        if self.pun_timer > 0:
            self.pun_timer -= 1
            action = Action.D
        elif t == 1:
            action = Action.C
        else:
            prev_idx = completed - 1
            last_ops = history.opponent_actions[prev_idx]
            defections = np.logical_not(last_ops)
            k = int(np.sum(defections))
            if k > 0:
                self.pun_timer = k - 1
                action = Action.D
            else:
                action = Action.C
        if t == self.game_description.n_rounds:
            action = Action.C
        return action

class Strategy_COOPERATIVE_91(BaseStrategy):
    """
    Cooperative Tit‐for‐Tat for n‐player Common Pool Resource:
    - Start cooperating.
    - If any opponent defected last round, punish with one round of defection.
    - Otherwise cooperate.
    - Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.lastRoundHadDefection = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        last_idx = history.round_number - 1
        opp_last_round = history.opponent_actions[last_idx]
        self.lastRoundHadDefection = not np.all(opp_last_round)
        if t == self.game_description.n_rounds:
            return Action.D
        if self.lastRoundHadDefection:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_92(BaseStrategy):
    """
    Tit-for-Tat with Finite Punishment:
    - Start cooperating.
    - If total consumption last round exceeded cooperative benchmark (S/2 + ε),
      punish by defecting for P rounds.
    - After P rounds, resume cooperation.
    - In the last round, defect if ever cheated or still punishing; otherwise cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.P = 1
        self.epsilon = 1e-06
        self.punish_timer = 0
        self.ever_cheated = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        last_idx = history.round_number - 1
        my_last_pay = float(history.my_payoffs[last_idx])
        opp_last_pays = history.opponent_payoffs[last_idx]
        total_consumption = my_last_pay + float(opp_last_pays.sum())
        found_def = False
        if not bool(history.my_actions[last_idx]):
            S_last = my_last_pay * self.n
            found_def = True
        else:
            for j in range(history.opponent_actions.shape[1]):
                if not bool(history.opponent_actions[last_idx, j]):
                    S_last = float(history.opponent_payoffs[last_idx, j]) * self.n
                    found_def = True
                    break
        if not found_def:
            S_last = my_last_pay * 2 * self.n
        defection_detected = total_consumption > S_last / 2.0 + self.epsilon
        if self.punish_timer > 0:
            action = Action.D
            self.punish_timer -= 1
        elif defection_detected:
            self.ever_cheated = True
            self.punish_timer = self.P - 1
            action = Action.D
        else:
            action = Action.C
        if t == self.r:
            if self.ever_cheated or self.punish_timer > 0:
                action = Action.D
            else:
                action = Action.C
        return action

class Strategy_COOPERATIVE_93(BaseStrategy):
    """
    Graduated Tit‐for‐Tat with Endgame Defection (G‐TFT‐E).
    - Start by cooperating.
    - If any opponent defected last round, defect for P rounds (P=1), then forgive.
    - Always defect in the final G=1 round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 1
        self.G = 1
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t > r - self.G:
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        if history.round_number >= 1:
            last_ops = history.opponent_actions[history.round_number - 1]
            if not last_ops.all():
                self.punish_timer = self.P - 1
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_94(BaseStrategy):
    """
    Generous Trigger-Tit-for-Tat with Endgame Defection.
    Starts by cooperating, responds to any defection with a short fixed
    punishment window of defections (L rounds), then forgives and returns
    to cooperation. In the very last round, defects to avoid unilateral
    exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.L = 2
        self.punishment_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if self.punishment_timer > 0:
            self.punishment_timer -= 1
            return Action.D
        somebody_defected = False
        if history.round_number > 0:
            last_actions = history.opponent_actions[history.round_number - 1]
            if not all(last_actions):
                somebody_defected = True
        if somebody_defected:
            self.punishment_timer = self.L - 1
            return Action.D
        if t == self.game_description.n_rounds:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_95(BaseStrategy):
    """
    Forgiving trigger strategy: Memory-1 tit-for-tat with a short punishment phase
    and endgame defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 2
        self.punishCounter = 0
        self.someoneDefectedLastRound = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishCounter = 0
            self.someoneDefectedLastRound = False
            return Action.C
        last_idx = history.round_number - 1
        if last_idx >= 0:
            last_my = history.my_actions[last_idx]
            last_opps = history.opponent_actions[last_idx]
            self.someoneDefectedLastRound = not (bool(last_my) and bool(np.all(last_opps)))
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.punishCounter > 0:
            action = Action.D
            self.punishCounter -= 1
        elif self.someoneDefectedLastRound:
            self.punishCounter = self.P - 1
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_COOPERATIVE_96(BaseStrategy):
    """
    Tit‐for‐Tat with final‐round defection:
      - Cooperate in round 1.
      - In rounds 2..r-1, if any opponent defected in the prior round, defect and set a 1‐round punishment timer.
        Otherwise cooperate.
      - While the punishment timer > 0, defect and decrement it.
      - In the final round, always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.pun_timer = 0
        self.k = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.pun_timer > 0:
            self.pun_timer -= 1
            return Action.D
        if t == 1:
            return Action.C
        last_idx = history.round_number - 1
        if not history.opponent_actions[last_idx].all():
            self.pun_timer = self.k
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_97(BaseStrategy):
    """
    Generous‐TFT‐with‐Endgame‐Defection:
    Start cooperating. If any opponent defected in the previous round, punish by defecting once
    (unless that would collapse the stock below a safety threshold), then forgive and return to cooperation.
    In the final round, always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.last_round_defected = False
        self.punish_counter = 0
        self.current_stock = float(self.capacity)
        self.rounds_tracked = 0
        self.alpha = 0.1
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        for r_idx in range(self.rounds_tracked, completed):
            my_coop = bool(history.my_actions[r_idx])
            opp_coops = int(np.sum(history.opponent_actions[r_idx]))
            total_coops = (1 if my_coop else 0) + opp_coops
            per_coop = self.current_stock / (2 * self.n)
            per_def = self.current_stock / self.n
            total_consumption = total_coops * per_coop + (self.n - total_coops) * per_def
            S_rem = self.current_stock - total_consumption
            growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
            self.current_stock = min(S_rem + growth, self.capacity)
        self.rounds_tracked = completed
        t = completed + 1
        if completed > 0:
            last_row = completed - 1
            if np.any(history.opponent_actions[last_row] == False):
                self.last_round_defected = True
            else:
                self.last_round_defected = False
        if t == self.r:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        if self.last_round_defected:
            predicted_consumption = self.current_stock
            S_after = self.current_stock - predicted_consumption
            if S_after >= self.alpha * self.capacity:
                self.punish_counter = 1
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COOPERATIVE_98(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Endgame Defection and Resource-Saving.
    Starts by cooperating, retaliates for P rounds after any opponent defection,
    always cooperates if the stock is below a threshold to help recovery,
    and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.P = 1
        self.punish_countdown = 0
        self.S_threshold = self.capacity / (2 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        S = self.capacity
        for i in range(completed):
            total_consumption = float(history.my_payoffs[i]) + float(history.opponent_payoffs[i].sum())
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S = min(S_remaining + growth, self.capacity)
        if t == self.r:
            return Action.D
        if t == 1:
            return Action.C
        if S < self.S_threshold:
            return Action.C
        if self.punish_countdown > 0:
            self.punish_countdown -= 1
            return Action.D
        last_ops = history.opponent_actions[completed - 1]
        if (last_ops == False).any():
            self.punish_countdown = self.P
            self.punish_countdown -= 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_99(BaseStrategy):
    """
    Generous Conditional–Cooperator (GCC):
    - Start by cooperating.
    - If any player defected in the previous round, defect for P rounds (finite punishment), then return to cooperate.
    - Always defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        r = game_description.n_rounds
        self.P = max(0, min(2, r - 2))
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        r = self.game_description.n_rounds
        L = r - t + 1
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        if t == r:
            return Action.D
        idx = completed - 1
        last_my = history.my_actions[idx]
        last_opp = history.opponent_actions[idx]
        if not last_my or not last_opp.all():
            self.punish_timer = min(self.P, L - 1)
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_100(BaseStrategy):
    """
    GenTitForTat strategy for the repeated common‐pool resource game.
    Cooperates by default, punishes any opponent defection with one round of defection,
    then forgives. Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.pun_remaining = 0
        self.last_round_defections = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_idx = history.round_number - 1
        defections = (~history.opponent_actions[last_idx]).sum()
        self.last_round_defections = int(defections)
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.pun_remaining > 0:
            self.pun_remaining -= 1
            return Action.D
        if self.last_round_defections > 0:
            self.pun_remaining = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_101(BaseStrategy):
    """
    Targeted one‐round punishment strategy:
    - Start by cooperating.
    - If any player defects in round t-1 and there was no defection in round t-2, defect once as punishment.
    - Otherwise cooperate.
    - Always defect in the last round to guard against end‐game free‐riding.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D

        def any_defected_in(idx: int) -> bool:
            if not history.my_actions[idx]:
                return True
            if not history.opponent_actions[idx].all():
                return True
            return False
        idx_prev = completed - 1
        any_def_prev = any_defected_in(idx_prev)
        if completed >= 2:
            any_def_prev2 = any_defected_in(completed - 2)
        else:
            any_def_prev2 = False
        if any_def_prev and (not any_def_prev2):
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_102(BaseStrategy):
    """
    Forgiving Tit-for-Tat with End-Game Defection:
    - Start by cooperating.
    - If any opponent defected in the previous round, punish by defecting for K total rounds.
    - After punishment, forgive and return to cooperation if no new defections.
    - Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.K = 2
        self.pun_rounds_left = 0
        self.saw_defection_last = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.pun_rounds_left = 0
            self.saw_defection_last = False
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if history.round_number >= 1:
            last_opp = history.opponent_actions[history.round_number - 1]
            self.saw_defection_last = not all(last_opp)
        else:
            self.saw_defection_last = False
        if t == 1:
            action = Action.C
        elif t == r:
            action = Action.D
        elif self.pun_rounds_left > 0:
            action = Action.D
            self.pun_rounds_left -= 1
        elif self.saw_defection_last:
            self.pun_rounds_left = self.K - 1
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_COOPERATIVE_103(BaseStrategy):
    """
    Conditional cooperation strategy for the Common Pool Resource Game.
    - Start by cooperating.
    - Cooperate if everyone cooperated last round.
    - If any defection occurred last round, punish once by defecting.
    - Forgive and return to cooperation thereafter.
    - Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        my_last = history.my_actions[last_idx]
        opp_last = history.opponent_actions[last_idx]
        if my_last and all(opp_last):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_104(BaseStrategy):
    """
    Multi‐Lateral Tit‐for‐Tat with End‐Game Defection:
    - Round 1: Cooperate.
    - Rounds 2…r−1: Cooperate if no opponent defected in the previous round; otherwise defect.
    - Round r (last): Defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        last_round_ops = history.opponent_actions[history.round_number - 1]
        if not last_round_ops.all():
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_105(BaseStrategy):
    """
    Coop-TFT-Endgame:
    Start by cooperating, use Tit-for-Tat with exactly one round of punishment
    after any observed defection, revert to cooperation immediately, and
    defect in the final round to grab the endgame payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_allC = True
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.last_round_allC = True
            self.punish_counter = 0
            return Action.C
        last_idx = history.round_number - 1
        cooperated_self = bool(history.my_actions[last_idx])
        cooperated_others = bool(np.all(history.opponent_actions[last_idx]))
        self.last_round_allC = cooperated_self and cooperated_others
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        if self.last_round_allC:
            return Action.C
        self.punish_counter = 1
        return Action.D

class Strategy_COOPERATIVE_106(BaseStrategy):
    """
    Thresholded Tit‐for‐Tat with Short Punishment (TTSP).
    Cooperate by default to keep the pool healthy, punish defections for L rounds,
    forgive quickly, and defect when the stock is critically low or at end‐game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.L = 1
        self.theta = 0.2
        self.pun_counter = 0
        self.last_defected = False
        self.stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.pun_counter = 0
            self.last_defected = False
            self.stock = self.capacity
            return Action.C
        pre_stock = self.stock
        my_last = history.my_actions[-1]
        opp_last = history.opponent_actions[-1]
        coops = int(my_last) + int(opp_last.sum())
        defs = self.n - coops
        cons_coop = pre_stock / (2.0 * self.n)
        cons_def = pre_stock / self.n
        total_consumption = coops * cons_coop + defs * cons_def
        S_rem = pre_stock - total_consumption
        growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
        self.stock = min(S_rem + growth, self.capacity)
        if not opp_last.all() and pre_stock >= self.theta * self.capacity:
            self.last_defected = True
        else:
            self.last_defected = False
        t = history.round_number + 1
        S_t = self.stock
        if t == self.r:
            if self.pun_counter > 0 or self.last_defected or S_t < self.theta * self.capacity:
                return Action.D
            else:
                return Action.C
        if S_t < self.theta * self.capacity:
            return Action.D
        if self.pun_counter > 0:
            self.pun_counter -= 1
            return Action.D
        if self.last_defected:
            self.pun_counter = self.L - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_107(BaseStrategy):
    """
    Trigger‐and‐forgive strategy for the Common Pool Resource Game.
    - Round 1: cooperate to build trust.
    - Rounds 2 to r–1: if any opponent defected in the previous round, defect (punish) once; otherwise cooperate.
    - Last round: always defect (one‐shot Nash).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            return Action.D
        last_idx = history.round_number - 1
        last_opp_actions = history.opponent_actions[last_idx]
        if not last_opp_actions.all():
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_108(BaseStrategy):
    """
    Grim-trigger with last-round defection:
    - Cooperate (C) as long as no opponent has ever defected and it's not the final round.
    - If any opponent defected in a prior round, defect (D) forever after.
    - In the final round, always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.defect_detected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number - 1
        if last_round >= 0:
            last_opp_actions = history.opponent_actions[last_round]
            if (last_opp_actions == False).any():
                self.defect_detected = True
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        if self.defect_detected:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_109(BaseStrategy):
    """
    Tit‐for‐Group‐Punishment: Cooperate unless anyone defected, then defect for P=1 rounds,
    forgive if no new defections, and always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 1
        self.phase = 'Cooperate'
        self.punish_counter = 0
        self.prev_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if history.round_number > self.prev_round:
            last = history.round_number - 1
            my_defected = not bool(history.my_actions[last])
            opp_defected = not bool(np.all(history.opponent_actions[last]))
            defected = my_defected or opp_defected
            if self.phase == 'Endgame':
                self.phase = 'Endgame'
            elif self.phase == 'Punish':
                self.punish_counter -= 1
                if self.punish_counter == 0:
                    if defected:
                        self.punish_counter = self.P
                        self.phase = 'Punish'
                    else:
                        self.phase = 'Cooperate'
                else:
                    self.phase = 'Punish'
            elif defected:
                self.phase = 'Punish'
                self.punish_counter = self.P
            else:
                self.phase = 'Cooperate'
            self.prev_round = history.round_number
        t = history.round_number + 1
        if t == self.game_description.n_rounds:
            self.phase = 'Endgame'
        if self.phase == 'Cooperate':
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_110(BaseStrategy):
    """
    Tit-for-Tat with short punishment and forgiveness for the Common Pool Resource Game.
    Starts by cooperating, punishes any opponent defection for P rounds, then forgives.
    Optionally guarantees cooperation in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 1
        self.pun_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number - 1
        if self.pun_timer > 0:
            action = Action.D
            self.pun_timer -= 1
        elif last_round >= 0 and (not np.all(history.opponent_actions[last_round, :])):
            action = Action.D
            self.pun_timer = self.P - 1
        else:
            action = Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            action = Action.C
        return action

class Strategy_COOPERATIVE_111(BaseStrategy):
    """
    Forgiving Tit-for-Tat with End-Round Defection (FTFT-ERD):
    - Round 1: cooperate.
    - Rounds 2…r-1: cooperate if no opponent defected last round; 
      if any opponent defected, defect this round and for M-1 further rounds (punishment), then forgive.
    - Round r (last round): defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.M = 1
        self.punish_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_remaining = 0
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punish_remaining > 0:
            self.punish_remaining -= 1
            return Action.D
        last_opp_actions = history.opponent_actions[history.round_number - 1]
        if not last_opp_actions.all():
            self.punish_remaining = self.M - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_112(BaseStrategy):
    """
    Conditional tit‐for‐tat for the Common Pool Resource Game:
    1. Cooperate on first round.
    2. Defect in last round.
    3. If stock < capacity/4, cooperate to rebuild.
    4. Otherwise, punish any new defection by defecting once, then forgive.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_min = game_description.capacity / 4.0
        self.last_was_punish = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        cap = self.game_description.capacity

        def compute_stock(hist: PlayerHistory) -> float:
            S = cap
            for t_idx in range(hist.round_number):
                my_pay = float(hist.my_payoffs[t_idx])
                opp_pay = float(hist.opponent_payoffs[t_idx].sum())
                total_consume = my_pay + opp_pay
                S_rem = S - total_consume
                growth = 2 * S_rem * (1 - S_rem / cap)
                S = S_rem + growth
                if S > cap:
                    S = cap
            return S
        if history is None:
            t = 1
            S_t = cap
        else:
            t = history.round_number + 1
            S_t = compute_stock(history)
        if t == 1:
            self.last_was_punish = False
            return Action.C
        if t == r:
            self.last_was_punish = False
            return Action.D
        if S_t < self.threshold_min:
            self.last_was_punish = False
            return Action.C
        prev_ops = history.opponent_actions[history.round_number - 1]
        someone_defected_prev = any((not a for a in prev_ops))
        if someone_defected_prev and (not self.last_was_punish):
            self.last_was_punish = True
            return Action.D
        else:
            self.last_was_punish = False
            return Action.C

class Strategy_COOPERATIVE_113(BaseStrategy):
    """
    Tit-for-tat with limited punishment for Common Pool Resource Game.
    Cooperate initially, punish defectors for L=2 rounds, forgive, and always defect in last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.L = 2
        self.punishingRemaining = 0
        self.lastRoundDefected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishingRemaining = 0
            self.lastRoundDefected = False
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if history.round_number >= 1:
            prev_ops = history.opponent_actions[history.round_number - 1]
            self.lastRoundDefected = bool(np.any(~prev_ops))
        else:
            self.lastRoundDefected = False
        if t == r:
            action = Action.D
        elif self.punishingRemaining > 0:
            action = Action.D
            self.punishingRemaining -= 1
        elif self.lastRoundDefected:
            action = Action.D
            self.punishingRemaining = self.L - 1
        else:
            action = Action.C
        return action

class Strategy_COOPERATIVE_114(BaseStrategy):
    """
    Forgiving tit-for-tat with end-game defection.
    Starts by cooperating, defects in the last round,
    punishes one defection round briefly, then forgives.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t_next = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t_next == total_rounds:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_round_idx = history.round_number - 1
        last_opponent_actions = history.opponent_actions[last_round_idx]
        if not all(last_opponent_actions):
            self.punish_counter = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_115(BaseStrategy):
    """
    Tit-for-Tat with one-period punishment (TFT-1) for the common pool resource game.
    Starts by cooperating, punishes any defection by defecting one round, then forgives,
    and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punish_counter = 0
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punish_counter > 0:
            self.punish_counter -= 1
            return Action.D
        last_self = history.my_actions[-1]
        last_opps = history.opponent_actions[-1]
        defection_occurred = not last_self or not last_opps.all()
        if defection_occurred:
            self.punish_counter = 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_116(BaseStrategy):
    """
    Finite-Punishment Tit-for-Tat:
    - Cooperate by default to sustain the pool.
    - If any opponent defected in the last round, defect for a finite P rounds.
    - Forgive after P rounds and resume cooperation.
    - Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.pun_counter = 0
        r = self.game_description.n_rounds
        self.P = max(1, min(3, r - 2))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        last_round = self.game_description.n_rounds
        if t == last_round:
            return Action.D
        if self.pun_counter > 0:
            self.pun_counter -= 1
            return Action.D
        prev_ops = history.opponent_actions[history.round_number - 1]
        if not np.all(prev_ops):
            self.pun_counter = self.P - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_117(BaseStrategy):
    """
    Coop-TFT-Endgame: Tit-for-Tat with one-round punishment and final-round defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_defected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.last_opponent_defected = False
            return Action.C
        last_round = history.round_number - 1
        if last_round >= 0:
            opp_actions = history.opponent_actions[last_round]
            self.last_opponent_defected = not bool(opp_actions.all())
        else:
            self.last_opponent_defected = False
        current_round = history.round_number + 1
        final_round = self.game_description.n_rounds
        if current_round == final_round:
            return Action.D
        if self.last_opponent_defected:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_118(BaseStrategy):
    """
    Tit-for-Tat with Final-Round Defection (TFT–FRD):
    - Cooperate on the first round.
    - Defect on the final round.
    - On interior rounds, cooperate if and only if every player
      cooperated in the immediately preceding round; otherwise defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        all_cooperated_last = history.my_actions[-1] and bool(np.all(history.opponent_actions[-1]))
        if all_cooperated_last:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_119(BaseStrategy):
    """
    CTFT-END: Cooperative Tit‐for‐Tat with one‐round punishment and end‐game defection.
    - Cooperate by default.
    - If any opponent defected in the previous round, retaliate with D and schedule
      a short punishment phase of length pun_length.
    - During a punishment phase, continue to defect until the timer runs out.
    - In the final round, always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.pun_timer = 0
        self.pun_length = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.pun_timer = 0
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if self.pun_timer > 0:
            self.pun_timer -= 1
            return Action.D
        last_idx = history.round_number - 1
        opp_last = history.opponent_actions[last_idx]
        if not opp_last.all():
            self.pun_timer = self.pun_length
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_120(BaseStrategy):
    """
    Grim–Trigger–with–Last–Round strategy for the Common Pool Resource Game.
    - Cooperate in the first round.
    - Defect in the last round.
    - If any opponent defects in any prior round, defect forever thereafter.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_seen = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.defect_seen:
            return Action.D
        last_idx = history.round_number - 1
        recent_opp = history.opponent_actions[last_idx]
        if not recent_opp.all():
            self.defect_seen = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_121(BaseStrategy):
    """
    Generous tit-for-tat with one-round punishment and endgame defection.
    Starts by cooperating, punishes any single defection with exactly one defection,
    then immediately forgives. In the final round, defects unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 1
        self.T_end = 1
        self.punish_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        r = self.game_description.n_rounds
        if t > r - self.T_end:
            return Action.D
        if self.punish_left > 0:
            self.punish_left -= 1
            return Action.D
        if completed >= 1:
            last_ops = history.opponent_actions[completed - 1]
            if not last_ops.all():
                self.punish_left = self.P - 1
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_122(BaseStrategy):
    """
    Forgiving Trigger with Endgame Defection:
    - Cooperate initially and as long as everyone cooperated in the previous round.
    - If any opponent defects, punish by defecting for P consecutive rounds.
    - After P punish rounds, forgive and return to cooperation mode.
    - Always defect in the very last round.
    """
    P = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_timer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        if self.punish_timer > 0:
            self.punish_timer -= 1
            return Action.D
        if t == 1:
            return Action.C
        prev_ops = history.opponent_actions[history.round_number - 1]
        if not prev_ops.all():
            remaining = r - t
            self.punish_timer = min(self.P - 1, remaining)
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_123(BaseStrategy):
    """
    Tit-for-Tat with finite punishment (TFT-FP):
    - Start by cooperating.
    - If any opponent defected in the previous round, defect for P rounds.
    - Otherwise cooperate.
    - After P rounds of punishment, return to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds = 0
        self.P = 2
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if self.punishment_rounds > 0:
            self.punishment_rounds -= 1
            return Action.D
        last_round = history.round_number - 1
        opp_actions_last = history.opponent_actions[last_round]
        if not opp_actions_last.all():
            self.punishment_rounds = self.P - 1
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_124(BaseStrategy):
    """
    Forgiving trigger strategy for the common‐pool resource game:
    Start by cooperating, punish any observed defection with one round of defection,
    then return to cooperation. Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.last_defection_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        if completed >= 1:
            last_idx = completed - 1
            if not history.opponent_actions[last_idx].all():
                self.last_defection_round = completed
        if t == self.n_rounds:
            return Action.D
        if self.last_defection_round == t - 1:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_125(BaseStrategy):
    """
    Group Tit-for-Tat with End-Game Defection:
    Cooperate initially, punish any opponent defection exactly one round,
    forgive immediately if all opponents return to cooperation,
    and defect in the final round to avoid end-game exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_index = history.round_number - 1
        last_opponent_actions = history.opponent_actions[last_index]
        if not last_opponent_actions.all():
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_126(BaseStrategy):
    """
    Trigger‐and‐forgiveness strategy for the Common Pool Resource Game.
    Cooperate in round 1, punish any defection by defecting exactly one round,
    forgive thereafter, and always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        if t == self.n_rounds:
            return Action.D
        last_idx = completed - 1
        opp_acts = history.opponent_actions[last_idx]
        my_last = history.my_actions[last_idx]
        if not my_last or not opp_acts.all():
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_127(BaseStrategy):
    """
    Coop-Guard: start cooperating, punish defections for P rounds,
    forgive afterwards, but if stock falls below θ cooperate to let it recover.
    Defect in the last round for endgame gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P = 2
        self.theta = float(self.game_description.capacity) / 4.0
        self.punish_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        cap = float(self.game_description.capacity)
        total_rounds = self.game_description.n_rounds
        if history is None:
            return Action.C
        completed = history.round_number
        t = completed + 1
        S = cap
        for k in range(completed):
            my_pay = float(history.my_payoffs[k])
            opp_pays = float(np.sum(history.opponent_payoffs[k]))
            total_cons = my_pay + opp_pays
            S_remain = S - total_cons
            growth = 2.0 * S_remain * (1.0 - S_remain / cap)
            S = min(S_remain + growth, cap)
        if t == total_rounds:
            return Action.D
        if t == 1:
            return Action.C
        if S < self.theta:
            return Action.C
        if self.punish_left > 0:
            self.punish_left -= 1
            return Action.D
        last_opp = history.opponent_actions[completed - 1]
        if not last_opp.all():
            self.punish_left = self.P - 1
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_128(BaseStrategy):
    """
    Cooperative Tit-for-Tat with Endgame Defection:
    Start by cooperating, punish any defection with one round of defection,
    then immediately forgive. In the final round, defect unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.P = 1
        self.E = 1
        self.punishing = False
        self.punish_left = 0
        self.current_stock = float(self.capacity)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number - 1
        S_t = self.current_stock
        my_pay = float(history.my_payoffs[last_round])
        opp_pay = history.opponent_payoffs[last_round]
        all_pays = np.append(opp_pay, my_pay)
        coop_share = S_t / (2 * self.n)
        defection_detected = np.max(all_pays) > coop_share
        total_consumption = float(np.sum(all_pays))
        S_remain = S_t - total_consumption
        growth = 2 * S_remain * (1 - S_remain / self.capacity)
        S_next = S_remain + growth
        self.current_stock = min(S_next, float(self.capacity))
        t = history.round_number + 1
        if t > self.r - self.E:
            return Action.D
        if self.punishing:
            action = Action.D
            self.punish_left -= 1
            if self.punish_left <= 0:
                self.punishing = False
            return action
        if defection_detected:
            self.punishing = True
            self.punish_left = self.P
            action = Action.D
            self.punish_left -= 1
            if self.punish_left <= 0:
                self.punishing = False
            return action
        return Action.C

class Strategy_AGGRESSIVE_33(BaseStrategy):
    """
    Predator strategy: always defect to maximize immediate payoff, but if the common‐pool
    stock falls below a low threshold S_L, grudgingly cooperate for m rounds to regrow the pool,
    then resume full defection. In the very last round, always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_L = self.capacity / (4 * self.n)
        self.m = 1
        self.phase = 'EXPLOIT'
        self.regrow_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = self.capacity
        else:
            completed = history.round_number
            t = completed + 1
            last_my = history.my_actions[-1]
            opp_last = history.opponent_actions[-1]
            c = int(last_my) + int(opp_last.sum())
            sum_payoffs = float(history.my_payoffs[-1] + history.opponent_payoffs[-1].sum())
            denom = 2 * self.n - c
            if denom > 0:
                S_remaining = sum_payoffs * c / denom
            else:
                S_remaining = 0.0
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S = S_remaining + growth
            if S > self.capacity:
                S = self.capacity
        if t == self.r:
            return Action.D
        if self.phase == 'EXPLOIT':
            if S <= self.S_L:
                self.phase = 'REGROW'
                self.regrow_counter = self.m - 1
                return Action.C
            else:
                return Action.D
        if self.phase == 'REGROW':
            if self.regrow_counter > 0:
                self.regrow_counter -= 1
                return Action.C
            else:
                self.phase = 'EXPLOIT'
                return Action.D

class Strategy_AGGRESSIVE_34(BaseStrategy):
    """
    Thresholded Aggressive Defector (TAD):
    - Never cooperates except to nurse the pool when it is low and at least one opponent
      cooperated in the prior round.
    - Defects whenever stock ≥ threshold or on first/last round.
    - threshold defaults to capacity/2.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.threshold = self.capacity / 2.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        S = self._compute_current_stock(history)
        if S >= self.threshold:
            return Action.D
        else:
            last_ops = history.opponent_actions[history.round_number - 1]
            if last_ops.any():
                return Action.C
            else:
                return Action.D

    def _compute_current_stock(self, history: PlayerHistory) -> float:
        """
        Reconstruct the common‐pool stock at the start of the next round
        by simulating from initial capacity through all completed rounds.
        """
        S = self.capacity
        for k in range(history.round_number):
            my_consume = float(history.my_payoffs[k])
            opp_consume = float(np.sum(history.opponent_payoffs[k]))
            total_consume = my_consume + opp_consume
            S_remain = S - total_consume
            if S_remain < 0.0:
                S_remain = 0.0
            growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
            S_next = S_remain + growth
            S = S_next if S_next <= self.capacity else self.capacity
        return S

class Strategy_AGGRESSIVE_35(BaseStrategy):
    """
    Ravenous-Transition strategy:
    - Cooperate in round 1.
    - Observe the common pool stock; reconstruct it from play history.
    - If any player defects in the previous round, or if the pool is back at capacity
      after a full-cooperate round, switch to permanent defection.
    - Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.attacked = False
        self.stocks = [self.capacity]

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if len(self.stocks) < t:
            S_prev = self.stocks[-1]
            last_my = bool(history.my_actions[-1])
            last_opponents = [bool(a) for a in history.opponent_actions[-1]]
            all_actions = [last_my] + last_opponents
            total_consumption = 0.0
            for acted_C in all_actions:
                if acted_C:
                    total_consumption += S_prev / (2 * self.n)
                else:
                    total_consumption += S_prev / self.n
            S_remain = S_prev - total_consumption
            growth = 2 * S_remain * (1 - S_remain / self.capacity)
            S_new = min(S_remain + growth, self.capacity)
            self.stocks.append(S_new)
        if t == self.r:
            return Action.D
        if t == 1:
            return Action.C
        if not self.attacked:
            last_my = bool(history.my_actions[-1])
            last_opponents = [bool(a) for a in history.opponent_actions[-1]]
            all_actions = [last_my] + last_opponents
            allC = all(all_actions)
            anyD = not allC
            condA = allC and self.stocks[-1] == self.capacity
            condB = anyD
            if condA or condB:
                self.attacked = True
        if self.attacked:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_36(BaseStrategy):
    """
    Aggressive Exploiter with Minimal Restoration (AEMR).
    Defects almost always to maximize immediate payoff, but
    cooperates occasionally to prevent the common pool from
    collapsing, based solely on the public stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = float(game_description.capacity)
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.theta = 0.5
        self.T_restore = self.theta * self.capacity
        self.K = 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = self.capacity
            last_coop = float('-inf')
        else:
            t = history.round_number + 1
            S = self._compute_stock(history)
            coop_indices = [i for i, a in enumerate(history.my_actions) if a]
            if coop_indices:
                last_coop = coop_indices[-1] + 1
            else:
                last_coop = float('-inf')
        if self.r < 3:
            return Action.D
        if t == 1 or t == self.r:
            return Action.D
        if S < self.T_restore and t - last_coop > self.K:
            return Action.C
        return Action.D

    def _compute_stock(self, history: PlayerHistory) -> float:
        """
        Reconstruct the common-pool stock at the start of the next round,
        by simulating from initial capacity through each completed round.
        """
        S = self.capacity
        for round_idx in range(history.round_number):
            if history.my_actions[round_idx]:
                cons_my = S / (2 * self.n)
            else:
                cons_my = S / self.n
            opp_actions = history.opponent_actions[round_idx]
            cons_opp = 0.0
            for a in opp_actions:
                if a:
                    cons_opp += S / (2 * self.n)
                else:
                    cons_opp += S / self.n
            total_consumption = cons_my + cons_opp
            S_remaining = S - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S = S_remaining + growth
            if S > self.capacity:
                S = self.capacity
        return S

class Strategy_AGGRESSIVE_37(BaseStrategy):
    """
    Aggressive Exploit‐and‐Rescue:
    - Round 1: Cooperate to help stock build.
    - Rounds 2…r-1: Defect if any opponent cooperated last round (exploit),
      otherwise cooperate to let the pool regrow (rescue).
    - Final round: Always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if t == r:
            return Action.D
        last_round_idx = history.round_number - 1
        last_opponents = history.opponent_actions[last_round_idx]
        if last_opponents.any():
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_38(BaseStrategy):
    """
    Aggressive memory‐1 strategy for the common‐pool resource game.
    Defect every round except:
      - if the current stock S falls below S_min = capacity/4, cooperate once to allow regrowth,
      - always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_min = self.capacity / 4.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        S = self.capacity
        for round_idx in range(history.round_number):
            own_coop = 1 if history.my_actions[round_idx] else 0
            opp_coops = int(np.sum(history.opponent_actions[round_idx]))
            cooperators = own_coop + opp_coops
            defectors = self.n - cooperators
            total_consumption = cooperators * (S / (2 * self.n)) + defectors * (S / self.n)
            S_remain = S - total_consumption
            growth = 2 * S_remain * (1 - S_remain / self.capacity)
            S = min(S_remain + growth, self.capacity)
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if S < self.S_min:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_39(BaseStrategy):
    """
    Predator strategy for the common‐pool resource game.
    Defects whenever the stock is healthy or in the endgame,
    cooperates only to rescue the stock when it falls below threshold_low,
    and returns to predation once it recovers above threshold_high.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.threshold_low = self.capacity * 0.1
        self.threshold_high = self.capacity * 0.5
        self.last_defect_rounds = 1
        self.rescue_mode = False
        self.current_stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        prev_stock = self.current_stock
        last_my_payoff = history.my_payoffs[-1]
        last_opp_payoffs = history.opponent_payoffs[-1].sum()
        total_consumption = float(last_my_payoff + last_opp_payoffs)
        S_rem = prev_stock - total_consumption
        growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
        self.current_stock = min(S_rem + growth, self.capacity)
        if t > self.r - self.last_defect_rounds:
            return Action.D
        if self.rescue_mode:
            if self.current_stock < self.threshold_high:
                return Action.C
            else:
                self.rescue_mode = False
                return Action.D
        if self.current_stock < self.threshold_low:
            self.rescue_mode = True
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_40(BaseStrategy):
    """
    Aggressive common‐pool‐resource strategy:
    Defects except when the stock is at or below capacity/4 in intermediate rounds,
    cooperates once to let it regrow, and always defects in the first and last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / 4.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        cap = float(self.game_description.capacity)
        if t == r:
            return Action.D
        S = cap
        for i in range(history.round_number):
            my_cons = float(history.my_payoffs[i])
            opp_cons = float(np.sum(history.opponent_payoffs[i]))
            total_cons = my_cons + opp_cons
            S_remain = S - total_cons
            growth = 2.0 * S_remain * (1.0 - S_remain / cap)
            S = S_remain + growth
            if S > cap:
                S = cap
            if S < 0.0:
                S = 0.0
        if S <= self.threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_41(BaseStrategy):
    """
    Aggro-Rescue: Defect by default to maximize immediate gain. When the common
    stock falls at or below 20% of capacity (critical low) and there are still
    more than R_last rounds left, trigger up to Rescue_max rounds of cooperation
    to regenerate the resource. Always defect in the first and last R_last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rescue_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        capacity = float(self.game_description.capacity)
        r = self.game_description.n_rounds
        R_last = 2
        Rescue_max = 2
        T_critical = 0.2 * capacity
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == 1 or t > r - R_last:
            return Action.D
        if self.rescue_rounds_left > 0:
            self.rescue_rounds_left -= 1
            return Action.C
        S = capacity
        for i in range(history.round_number):
            total_consumption = float(history.my_payoffs[i]) + float(history.opponent_payoffs[i].sum())
            S_remain = S - total_consumption
            growth = 2 * S_remain * (1 - S_remain / capacity)
            S = min(S_remain + growth, capacity)
        if S <= T_critical and t <= r - R_last:
            self.rescue_rounds_left = Rescue_max - 1
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_42(BaseStrategy):
    """
    Aggressive Threshold Exploiter (ATE).
    - Always defect in round 1 and in the final round.
    - Compute the common‐pool stock from history.
    - If stock ≤ ε (tiny floor), cooperate to allow regrowth.
    - Otherwise, if stock > capacity/2, defect; else cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_target = self.capacity / 2.0
        self.epsilon = 1e-06 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        S = self.capacity
        for j in range(history.round_number):
            my_take = float(history.my_payoffs[j])
            opp_takes = float(history.opponent_payoffs[j].sum())
            total_consumption = my_take + opp_takes
            S_remain = S - total_consumption
            if S_remain < 0.0:
                S_remain = 0.0
            growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
            S = S_remain + growth
            if S > self.capacity:
                S = self.capacity
        if S <= self.epsilon:
            return Action.C
        if S > self.S_target:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_43(BaseStrategy):
    """
    Aggressive Defect-and-Restore (ADR) strategy:
    - Defect on first and last rounds.
    - Almost always defect to maximize immediate payoff.
    - If stock falls below S_low, cooperate until it regrows above S_high.
    - Tracks and simulates the common-pool stock internally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = game_description.n_players
        cap = game_description.capacity
        self.S_low = cap / (2 * n)
        self.S_high = cap / 2.0
        self.current_stock = cap
        self.last_round_processed = 0
        self.in_restock_phase = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.in_restock_phase = False
            return Action.D
        desc = self.game_description
        n = desc.n_players
        cap = desc.capacity
        rounds_done = history.round_number
        for i in range(self.last_round_processed, rounds_done):
            S_prev = self.current_stock
            my_coop = 1 if history.my_actions[i] else 0
            opp_coop = int(history.opponent_actions[i].sum())
            coop_count = my_coop + opp_coop
            defect_count = n - coop_count
            cons_coop = coop_count * (S_prev / (2 * n))
            cons_def = defect_count * (S_prev / n)
            total_cons = cons_coop + cons_def
            S_remain = S_prev - total_cons
            if S_remain <= 0:
                self.current_stock = 0.0
            else:
                growth = 2 * S_remain * (1 - S_remain / cap)
                self.current_stock = min(S_remain + growth, cap)
        self.last_round_processed = rounds_done
        t = rounds_done + 1
        if t == desc.n_rounds:
            self.in_restock_phase = False
            return Action.D
        S_t = self.current_stock
        if S_t <= 0:
            return Action.D
        if S_t <= self.S_low:
            self.in_restock_phase = True
            return Action.C
        if self.in_restock_phase and S_t < self.S_high:
            return Action.C
        self.in_restock_phase = False
        return Action.D

class Strategy_AGGRESSIVE_44(BaseStrategy):
    """
    Aggressive‐exploit with opportunistic rescue:
    Defect when resource is ample or near the end; cooperate only when stock ≤ T_min.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = float(game_description.capacity)
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.theta_min = 0.3
        self.theta_max = 0.8
        self.K = 2
        self.T_min = self.theta_min * self.capacity
        self.T_max = self.theta_max * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t > self.r - self.K:
            return Action.D
        S = self.capacity
        for ridx in range(history.round_number):
            my_c = float(history.my_payoffs[ridx])
            opp_c = float(history.opponent_payoffs[ridx].sum())
            total_c = my_c + opp_c
            S_remain = S - total_c
            growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
            S = min(S_remain + growth, self.capacity)
        if S <= self.T_min:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_45(BaseStrategy):
    """
    Scarce‐Exploiter strategy: defect except when stock is at or below S_low (capacity/4),
    and always defect in first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = float(game_description.capacity)
        self.n_rounds = game_description.n_rounds
        self.S_low = self.capacity / 4.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        stock = self._compute_current_stock(history)
        if stock <= self.S_low:
            return Action.C
        return Action.D

    def _compute_current_stock(self, history: PlayerHistory) -> float:
        cap = self.capacity
        stock = cap
        for i in range(history.round_number):
            total_consumed = float(history.my_payoffs[i] + history.opponent_payoffs[i].sum())
            remaining = stock - total_consumed
            if remaining < 0.0:
                remaining = 0.0
            growth = 2.0 * remaining * (1.0 - remaining / cap)
            new_stock = remaining + growth
            stock = new_stock if new_stock <= cap else cap
        return stock

class Strategy_AGGRESSIVE_46(BaseStrategy):
    """
    Exploit-and-Recover strategy for the common pool resource game.
    Aggressively defects when stock is healthy, but grudgingly cooperates
    to rescue the pool when stock falls below a low threshold. Exits
    recovery as soon as stock exceeds a high threshold. Always defects
    on the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.recover = False
        self.low_thresh = 0.3 * self.capacity
        self.high_thresh = 0.9 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t == self.r:
            return Action.D
        S_t = self._compute_stock_next_round(history)
        if self.recover:
            if S_t >= self.high_thresh:
                self.recover = False
                return Action.D
            else:
                return Action.C
        elif S_t <= self.low_thresh:
            self.recover = True
            return Action.C
        else:
            return Action.D

    def _compute_stock_next_round(self, history: PlayerHistory) -> float:
        """
        Reconstructs the stock at the start of the upcoming round
        by reversing payoff->consumption->growth from the last round.
        """
        idx = history.round_number - 1
        last_payoff = float(history.my_payoffs[idx])
        if history.my_actions[idx]:
            S_pre = last_payoff * (2 * self.n)
        else:
            S_pre = last_payoff * self.n
        opp_coops = int(history.opponent_actions[idx].sum())
        my_coop = 1 if history.my_actions[idx] else 0
        coop_count = opp_coops + my_coop
        defect_count = self.n - coop_count
        cons_coop = coop_count * (S_pre / (2 * self.n))
        cons_def = defect_count * (S_pre / self.n)
        total_consumption = cons_coop + cons_def
        S_remain = S_pre - total_consumption
        if S_remain < 0.0:
            S_remain = 0.0
        growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
        S_next = S_remain + growth
        if S_next > self.capacity:
            S_next = self.capacity
        return float(S_next)

class Strategy_AGGRESSIVE_47(BaseStrategy):
    """
    Hammer-and-Tend: defect aggressively whenever the pool is healthy,
    only cooperate minimally to avoid total collapse, and always defect
    in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.T = self.capacity / (4 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = self.capacity
        else:
            t = history.round_number + 1
            S = self.capacity
            for i in range(history.round_number):
                coop_me = 1 if history.my_actions[i] else 0
                coop_opp = int(history.opponent_actions[i].sum())
                coop_count = coop_me + coop_opp
                def_count = self.n - coop_count
                cons_coop = coop_count * (S / (2 * self.n))
                cons_def = def_count * (S / self.n)
                total_consumption = cons_coop + cons_def
                S_remain = S - total_consumption
                growth = 2 * S_remain * (1 - S_remain / self.capacity)
                S = min(S_remain + growth, self.capacity)
                if S < 0:
                    S = 0.0
        if t == self.r:
            return Action.D
        if S > self.T:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_48(BaseStrategy):
    """
    Aggressive Sustainable Exploiter (ASE):
    Defects on round 1 and the last round; defects whenever stock ≥ capacity/2;
    cooperates whenever stock ≤ capacity/4; otherwise tests group cooperation:
    if a majority cooperated last round, defect; else cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t == self.r:
            return Action.D
        prev_idx = completed - 1
        my_act = bool(history.my_actions[prev_idx])
        my_pay = float(history.my_payoffs[prev_idx])
        opp_acts = history.opponent_actions[prev_idx].tolist()
        opp_pays = history.opponent_payoffs[prev_idx].tolist()
        actions_all = [my_act] + opp_acts
        pays_all = [my_pay] + opp_pays
        S_prev = None
        for act, pay in zip(actions_all, pays_all):
            if not act:
                S_prev = pay * self.n
                break
        if S_prev is None:
            S_prev = pays_all[0] * (2 * self.n)
        coop_prev = sum((1 for a in actions_all if a))
        cons_C = S_prev / (2 * self.n)
        cons_D = S_prev / self.n
        total_consumption = coop_prev * cons_C + (self.n - coop_prev) * cons_D
        S_remain = S_prev - total_consumption
        growth = 2 * S_remain * (1 - S_remain / self.capacity)
        S_t = min(S_remain + growth, self.capacity)
        threshold_high = self.capacity / 2
        threshold_low = self.capacity / 4
        if S_t >= threshold_high:
            return Action.D
        if S_t <= threshold_low:
            return Action.C
        min_coop_majority = math.ceil(self.n / 2) + 1
        if coop_prev >= min_coop_majority:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_49(BaseStrategy):
    """
    Exploit-and-Preserve (E&P) strategy:
    Defect every round except when the common‐pool stock falls below a
    preservation threshold, then cooperate just enough to let the stock
    rebound, and resume defection. Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.alpha = 0.5
        self.epsilon = 0.1
        self.T_high = self.alpha * self.capacity
        self.T_low = self.epsilon * self.capacity
        self.mode = 'EXPLOIT'

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        S = self.capacity
        for r_idx in range(history.round_number):
            if history.my_actions[r_idx]:
                cons = S / (2 * self.n_players)
            else:
                cons = S / self.n_players
            total_consumption = cons
            for opp_act in history.opponent_actions[r_idx]:
                if opp_act:
                    total_consumption += S / (2 * self.n_players)
                else:
                    total_consumption += S / self.n_players
            S_remaining = S - total_consumption
            if S_remaining < 0:
                S_remaining = 0.0
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S = S_remaining + growth
            if S > self.capacity:
                S = self.capacity
        if self.mode == 'EXPLOIT' and S <= self.T_low:
            self.mode = 'PRESERVE'
        elif self.mode == 'PRESERVE' and S >= self.T_high:
            self.mode = 'EXPLOIT'
        if self.mode == 'EXPLOIT':
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_50(BaseStrategy):
    """
    Aggressive-pulse strategy: defect when the pool is healthy, cooperate when stock is below threshold to let it regrow,
    and defect unconditionally in the last round to milk the pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.threshold = self.capacity / 2.0
        self.current_stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            completed = history.round_number
            last_my_payoff = float(history.my_payoffs[-1])
            last_opp_payoffs = float(history.opponent_payoffs[-1].sum())
            total_consumption = last_my_payoff + last_opp_payoffs
            S_remain = self.current_stock - total_consumption
            growth = 2 * S_remain * (1 - S_remain / self.capacity)
            self.current_stock = min(S_remain + growth, self.capacity)
            t = completed + 1
        if t == self.r:
            return Action.D
        if self.current_stock < self.threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_51(BaseStrategy):
    """
    Threshold-Driven Aggressive Harvest:
    Defect whenever the common stock is at or above half capacity (T_high)
    or in the final harvest round(s); otherwise cooperate to let the pool regrow.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.H = 1
        self.T_high = self.capacity / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        last_idx = history.round_number - 1
        my_act = history.my_actions[last_idx]
        my_pay = float(history.my_payoffs[last_idx])
        if my_pay == 0.0:
            S_prev = 0.0
        else:
            S_prev = my_pay * (2 * self.n if my_act else self.n)
        opp_acts = history.opponent_actions[last_idx]
        num_coop = int(my_act) + int(opp_acts.sum())
        num_def = self.n - num_coop
        if S_prev <= 0:
            S_remain = 0.0
        else:
            total_consume = S_prev * (num_coop / (2 * self.n) + num_def / self.n)
            S_remain = S_prev - total_consume
        growth = 2 * S_remain * (1 - S_remain / self.capacity) if self.capacity > 0 else 0.0
        S_current = min(S_remain + growth, self.capacity)
        if t > self.r - self.H:
            return Action.D
        if S_current >= self.T_high:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_52(BaseStrategy):
    """
    Always-Defect (MAX-GRAB): In every round, regardless of history or current stock,
    this strategy always chooses to defect (Action.D), taking the maximum possible share.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_53(BaseStrategy):
    """
    Threshold-Defector with Hysteresis:
    Defect by default, but if stock ≤ γ_low·capacity enter
    regrowth (cooperate) until stock ≥ γ_high·capacity. Always
    defect on the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.gamma_low = 0.3
        self.gamma_high = 0.7
        self.in_regrowth = False
        self.current_stock = float(game_description.capacity)

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        total_rounds = self.game_description.n_rounds
        if history is None:
            t = 1
        else:
            rounds_played = history.round_number
            if rounds_played > 0:
                idx = rounds_played - 1
                last_payoff = float(history.my_payoffs[idx])
                last_action = history.my_actions[idx]
                if last_action:
                    S_prev = last_payoff * (2 * n)
                else:
                    S_prev = last_payoff * n
                if last_action:
                    cons_me = S_prev / (2 * n)
                else:
                    cons_me = S_prev / n
                opp_actions = history.opponent_actions[idx]
                coop_count = int(np.sum(opp_actions))
                defect_count = len(opp_actions) - coop_count
                cons_opp = coop_count * (S_prev / (2 * n)) + defect_count * (S_prev / n)
                total_consumption = cons_me + cons_opp
                S_remain = S_prev - total_consumption
                growth = 2.0 * S_remain * (1.0 - S_remain / capacity)
                self.current_stock = min(S_remain + growth, capacity)
            t = history.round_number + 1
        if t == total_rounds:
            action = Action.D
        else:
            S_t = self.current_stock
            if self.in_regrowth:
                action = Action.C
                if S_t >= self.gamma_high * capacity:
                    self.in_regrowth = False
            elif S_t <= self.gamma_low * capacity:
                self.in_regrowth = True
                action = Action.C
            else:
                action = Action.D
        return action

class Strategy_AGGRESSIVE_54(BaseStrategy):
    """
    Aggressive Regrowth-Exploitation (AREX) Strategy.

    Always defects except for one opportunistic “rest” cooperation
    when the common pool stock first falls to or below a threshold
    fraction of capacity, then defects again thereafter, and
    always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.used_rest = False
        self.rest_threshold = 0.3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = self.capacity
        else:
            rounds_done = history.round_number
            S = self.capacity
            for i in range(rounds_done):
                my_pay = float(history.my_payoffs[i])
                opp_pay_sum = float(np.sum(history.opponent_payoffs[i]))
                total_consumption = my_pay + opp_pay_sum
                S_remaining = S - total_consumption
                growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
                S = min(S_remaining + growth, self.capacity)
            t = rounds_done + 1
        if t == self.r:
            return Action.D
        if not self.used_rest and S <= self.rest_threshold * self.capacity:
            self.used_rest = True
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_55(BaseStrategy):
    """
    Rampaging Predator strategy:
    Cooperate for the first half of the rounds (⌊r/2⌋), then defect for the remainder.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.T = self.game_description.n_rounds // 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            current_round = 1
        else:
            current_round = history.round_number + 1
        if current_round <= self.T:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_56(BaseStrategy):
    """
    Aggressive common-pool‐resource strategy:
    - Always defect in first and last round.
    - If stock below capacity/n, cooperate to avoid collapse.
    - If majority cooperated last round, defect to exploit.
    - Otherwise cooperate to help regrowth for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_stock = self.capacity / self.n
        self.half_group = self.n / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t == self.r:
            return Action.D
        S = float(self.capacity)
        for j in range(completed):
            acts = []
            acts.append(bool(history.my_actions[j]))
            acts.extend((bool(a) for a in history.opponent_actions[j]))
            total_consumption = 0.0
            for a in acts:
                if a:
                    total_consumption += S / (2 * self.n)
                else:
                    total_consumption += S / self.n
            S_remain = S - total_consumption
            growth = 2 * S_remain * (1 - S_remain / self.capacity)
            S = min(S_remain + growth, self.capacity)
        coop_prev = int(history.my_actions[-1])
        coop_prev += int(history.opponent_actions[-1].sum())
        if S < self.threshold_stock:
            return Action.C
        if coop_prev > self.half_group:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_57(BaseStrategy):
    """
    Aggressive exploitation with minimal maintenance:
    Defect by default to maximize immediate payoff, but if the common pool
    ever falls below 50% of capacity (and there are more than two rounds left),
    switch into a brief regeneration mode where we cooperate until the pool
    recovers to 50%, then defect again. Always defect in the last two rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.regen_frac = 0.5
        self.safe_rounds = 2
        self.regeneration_mode = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = self.capacity
        else:
            completed = history.round_number
            t = completed + 1
            if completed == 0:
                S = self.capacity
            else:
                idx = completed - 1
                our_act = bool(history.my_actions[idx])
                our_pay = float(history.my_payoffs[idx])
                opp_acts = [bool(a) for a in history.opponent_actions[idx]]
                opp_pays = [float(p) for p in history.opponent_payoffs[idx]]
                all_acts = [our_act] + opp_acts
                all_pays = [our_pay] + opp_pays
                S_prev = None
                for act, pay in zip(all_acts, all_pays):
                    if not act:
                        S_prev = pay * self.n
                        break
                if S_prev is None:
                    S_prev = all_pays[0] * (2 * self.n)
                total_consume = sum(all_pays)
                S_remain = S_prev - total_consume
                growth = 2 * S_remain * (1 - S_remain / self.capacity)
                S = min(S_remain + growth, self.capacity)
        if t > self.r - self.safe_rounds:
            return Action.D
        if self.regeneration_mode:
            if S < self.regen_frac * self.capacity:
                return Action.C
            else:
                self.regeneration_mode = False
                return Action.D
        if S < self.regen_frac * self.capacity:
            self.regeneration_mode = True
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_58(BaseStrategy):
    """
    Aggressive Sustaining‐Defector (ASD) strategy:
    - Always defect except when the pool is below a danger threshold (triggering a short cooperation burst)
      or in the regeneration counter window.
    - In the last E rounds, always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.phi = 0.2
        self.T = self.phi * self.capacity
        self.K = 2
        self.E = 1
        self.regen_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.regen_counter = 0
            return Action.D
        t_completed = history.round_number
        t = t_completed + 1
        if t > self.r - self.E:
            return Action.D
        if self.regen_counter > 0:
            self.regen_counter -= 1
            return Action.C
        S_t = self._compute_stock(history)
        if S_t < self.T:
            self.regen_counter = self.K - 1
            return Action.C
        if t == 1:
            return Action.D
        last_idx = t_completed - 1
        opp_acts_last = history.opponent_actions[last_idx]
        if opp_acts_last.any():
            return Action.D
        else:
            return Action.C

    def _compute_stock(self, history: PlayerHistory) -> float:
        """
        Reconstruct the common-pool stock at the start of the current round,
        given the full history of actions.
        """
        S = self.capacity
        n = self.n
        for i in range(history.round_number):
            current_S = S
            my_coop = bool(history.my_actions[i])
            opp_coops = history.opponent_actions[i].sum()
            total_coop = (1 if my_coop else 0) + int(opp_coops)
            total_defect = n - total_coop
            cons_coop = current_S / (2 * n)
            cons_def = current_S / n
            total_consumption = total_coop * cons_coop + total_defect * cons_def
            S_rem = current_S - total_consumption
            growth = 2 * S_rem * (1 - S_rem / self.capacity)
            S = min(S_rem + growth, self.capacity)
        return S

class Strategy_AGGRESSIVE_59(BaseStrategy):
    """
    Aggressive‐Sustainer strategy:
    Defect by default to maximize immediate payoffs, but if the common‐pool stock 
    falls below a danger threshold (capacity/10) cooperate to allow regrowth. 
    In the final L_end rounds (min(3, r−1)), defect unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.T_low = self.capacity / 10.0
        self.always_defect = self.r <= 3
        if not self.always_defect:
            self.L_end = min(3, self.r - 1)
        else:
            self.L_end = self.r

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = float(self.capacity)
        else:
            t = history.round_number + 1
            S = float(self.capacity)
            for i in range(history.round_number):
                own_consume = float(history.my_payoffs[i])
                opp_consume = float(history.opponent_payoffs[i].sum())
                total_consume = own_consume + opp_consume
                S_rem = S - total_consume
                if S_rem < 0.0:
                    S_rem = 0.0
                growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
                S = S_rem + growth
                if S > self.capacity:
                    S = float(self.capacity)
        if self.always_defect or S <= 0.0:
            return Action.D
        if t > self.r - self.L_end:
            return Action.D
        if S <= self.T_low:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_60(BaseStrategy):
    """
    Aggressive Stock‐Farming strategy:
    - Cooperate early to regrow the common pool.
    - Punish any defection for Tpunish rounds.
    - Once in the last k rounds or if stock falls below half capacity, defect permanently.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = self.game_description.n_players
        self.r = self.game_description.n_rounds
        self.capacity = float(self.game_description.capacity)
        self.k = math.ceil(self.r / 3)
        self.Tpunish = 1
        self.S_thresh = self.capacity / 2.0
        self.pun_counter = 0
        self.current_stock = self.capacity
        self.last_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is not None and history.round_number > self.last_round:
            t_prev = history.round_number - 1
            coops = int(history.my_actions[t_prev]) + int(history.opponent_actions[t_prev].sum())
            defs = self.n - coops
            S0 = self.current_stock
            cons_coop = S0 / (2.0 * self.n)
            cons_def = S0 / self.n
            total_consumption = coops * cons_coop + defs * cons_def
            S_rem = max(S0 - total_consumption, 0.0)
            growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
            self.current_stock = min(S_rem + growth, self.capacity)
            self.last_round = history.round_number
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        S_t = self.current_stock
        if t > self.r - self.k or S_t < self.S_thresh:
            action = Action.D
        elif self.pun_counter > 0:
            action = Action.D
            self.pun_counter -= 1
        elif history is not None and history.round_number > 0 and np.any(~history.opponent_actions[history.round_number - 1]):
            self.pun_counter = self.Tpunish - 1
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_AGGRESSIVE_61(BaseStrategy):
    """
    Opportunistic Defector:
    Defaults to defecting (D) every round to maximize immediate payoff.
    If the common pool stock falls below capacity/n and there are more than
    RECOVERY_ROUNDS left, switches to cooperate (C) for RECOVERY_ROUNDS to
    allow regrowth. Always defects on the first and last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.RECOVERY_ROUNDS = 2
        self.recovery_counter = 0
        self.last_stock = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.recovery_counter = 0
            self.last_stock = self.capacity
            return Action.D
        completed = history.round_number
        t = completed + 1
        rounds_left = self.r - t + 1
        if self.last_stock is None:
            current_stock = self.capacity
        else:
            idx = completed - 1
            total_consumption = float(history.my_payoffs[idx]) + float(history.opponent_payoffs[idx].sum())
            S_remain = self.last_stock - total_consumption
            growth = 2 * S_remain * (1 - S_remain / self.capacity)
            new_stock = S_remain + growth
            current_stock = new_stock if new_stock <= self.capacity else self.capacity
        if t == 1 or t == self.r:
            action = Action.D
        elif self.recovery_counter > 0:
            action = Action.C
            self.recovery_counter -= 1
        elif current_stock < self.capacity / self.n and rounds_left > self.RECOVERY_ROUNDS:
            action = Action.C
            self.recovery_counter = self.RECOVERY_ROUNDS - 1
        else:
            action = Action.D
        self.last_stock = current_stock
        return action

class Strategy_AGGRESSIVE_62(BaseStrategy):
    """
    Aggressive Harvest strategy:
    Always defect when the stock is above a declining threshold M_t = capacity*(r - t)/r,
    or in the last two rounds (no future value), or when the stock is depleted.
    Otherwise cooperate to allow regrowth.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        if history is None:
            return Action.D
        S = capacity
        for i in range(history.round_number):
            my_cons = float(history.my_payoffs[i])
            opp_cons = float(history.opponent_payoffs[i].sum())
            total_cons = my_cons + opp_cons
            S = max(S - total_cons, 0.0)
            growth = 2 * S * (1 - S / capacity)
            S = min(S + growth, capacity)
        t = history.round_number + 1
        if S <= 0.0 or t > r - 2:
            return Action.D
        M_t = capacity * (r - t) / r
        if S >= M_t:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_63(BaseStrategy):
    """
    Always Defect strategy: in every round, regardless of history or stock level,
    play Defect (Action.D) to grab the maximum possible share each time.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_64(BaseStrategy):
    """
    Aggressive predator strategy:
    Defect every round except brief cooperation windows when the stock 
    falls below a threshold, plus guaranteed defection in the final H rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.T_low = 0.25 * self.capacity
        self.G = 2
        self.H = 1
        self.regrowth_counter = 0
        self.endgame_start = self.n_rounds - self.H + 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = self.capacity
        else:
            t = history.round_number + 1
            S = self._compute_current_stock(history)
        if t >= self.endgame_start:
            return Action.D
        if self.regrowth_counter > 0:
            self.regrowth_counter -= 1
            return Action.C
        if S < self.T_low:
            self.regrowth_counter = self.G - 1
            return Action.C
        return Action.D

    def _compute_current_stock(self, history: PlayerHistory) -> float:
        """
        Reconstructs the pool stock at the start of the upcoming round
        by replaying stock dynamics from the initial capacity.
        """
        S = self.capacity
        cap = self.capacity
        for r_idx in range(history.round_number):
            my_consume = float(history.my_payoffs[r_idx])
            opp_consume = float(history.opponent_payoffs[r_idx, :].sum())
            total_consume = my_consume + opp_consume
            S_remain = S - total_consume
            if S_remain < 0.0:
                S_remain = 0.0
            growth = 2.0 * S_remain * (1.0 - S_remain / cap)
            S = S_remain + growth
            if S > cap:
                S = cap
        return S

class Strategy_AGGRESSIVE_65(BaseStrategy):
    """
    Hold-Cooperate, Raid-Defect with Grim:
    - Cooperate early to keep stock high.
    - If any opponent defects before the final raid phase, defect forever (grim trigger).
    - In the last m = ceil(r/5) rounds, defect every round to maximize haul.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.m = math.ceil(self.r / 5)
        self.T = self.r - self.m + 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t >= self.T:
            return Action.D
        if not history.opponent_actions.all():
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_66(BaseStrategy):
    """
    Aggressive Exploit‐and‐Restore (AER):
    Defect in EXPLOIT phase until stock ≤ capacity/3, then switch to RESTORE (cooperate)
    until stock ≥ 2·capacity/3, then back to EXPLOIT. Always defect in last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.lower_threshold = self.capacity / 3.0
        self.upper_threshold = 2.0 * self.capacity / 3.0
        self.phase = 'EXPLOIT'
        self.current_stock = self.capacity
        self.last_history_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        if completed > self.last_history_round:
            j = completed
            S = self.current_stock
            my_act = history.my_actions[j - 1]
            opp_acts = history.opponent_actions[j - 1]
            num_coop = int(my_act) + int(np.sum(opp_acts))
            cons_coop = S / (2.0 * self.n)
            cons_def = S / self.n
            total_cons = num_coop * cons_coop + (self.n - num_coop) * cons_def
            S_remain = S - total_cons
            growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
            self.current_stock = min(S_remain + growth, self.capacity)
            self.last_history_round = completed
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        S_t = self.current_stock
        if self.phase == 'EXPLOIT':
            if S_t <= self.lower_threshold:
                self.phase = 'RESTORE'
                return Action.C
            else:
                return Action.D
        elif S_t >= self.upper_threshold:
            self.phase = 'EXPLOIT'
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_67(BaseStrategy):
    """
    Aggressive Rescue strategy for the Common Pool Resource Game.
    Defects whenever the stock is ample (Exploit mode), but once the
    stock falls to ≤50% capacity it switches to Rescue mode and cooperates
    until stock regrows above 75%, then returns to Exploit. Always defects
    in the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.state = 'Exploit'
        cap = self.game_description.capacity
        self.T_low = 0.5 * cap
        self.T_high = 0.75 * cap

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        cap = self.game_description.capacity
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t == r:
            return Action.D
        S = float(cap)
        for k in range(completed):
            my_act = bool(history.my_actions[k])
            opp_acts = history.opponent_actions[k]
            if my_act:
                c_my = S / (2 * n)
            else:
                c_my = S / n
            c_opps = 0.0
            for oa in opp_acts:
                if bool(oa):
                    c_opps += S / (2 * n)
                else:
                    c_opps += S / n
            total_consumption = c_my + c_opps
            S_rem = S - total_consumption
            growth = 2 * S_rem * (1 - S_rem / cap)
            S = min(S_rem + growth, cap)
        if t > 1:
            if self.state == 'Exploit':
                if S > self.T_low:
                    return Action.D
                else:
                    self.state = 'Rescue'
                    return Action.C
            elif S < self.T_high:
                return Action.C
            else:
                self.state = 'Exploit'
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_68(BaseStrategy):
    """
    An ultra-aggressive, no-mercy strategy: always defect and never cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_69(BaseStrategy):
    """
    Aggressive Resource Predator:
    Always defects except to “maintain” the resource when everyone else has been defecting
    or the stock falls below a threshold. Unconditional defect in round 1 and the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        low_threshold = capacity / 3.0
        epsilon = 1e-06
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = capacity
        last_actions = None
        for round_idx in range(history.round_number):
            opp = history.opponent_actions[round_idx]
            my_act = history.my_actions[round_idx]
            actions = list(opp) + [bool(my_act)]
            last_actions = actions
            num_coop = sum((1 for a in actions if a))
            num_def = n - num_coop
            cons_coop = S / (2.0 * n) * num_coop
            cons_def = S / n * num_def
            total_consumption = cons_coop + cons_def
            S_remaining = S - total_consumption
            growth = 2.0 * S_remaining * (1.0 - S_remaining / capacity)
            S = min(S_remaining + growth, capacity)
        if t == r:
            return Action.D
        if S <= epsilon:
            return Action.D
        if last_actions is not None and all((not a for a in last_actions)):
            return Action.C
        if S < low_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_70(BaseStrategy):
    """
    Aggressive Exploiter with Strategic Conservation (AESC) strategy.
    Defects by default to maximize immediate gain, but if the common‐pool
    stock falls below a fraction α of capacity (and it's not the last round),
    briefly cooperates for β rounds to allow the pool to regenerate.
    Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.alpha = 0.2
        self.beta = 2
        self.coop_buffer = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = self.capacity
            if t == self.r:
                return Action.D
            return Action.D
        t = history.round_number + 1
        S = self._compute_stock(history)
        if t == self.r:
            return Action.D
        if self.coop_buffer > 0:
            self.coop_buffer -= 1
            return Action.C
        if S < self.alpha * self.capacity and t < self.r:
            self.coop_buffer = self.beta - 1
            return Action.C
        return Action.D

    def _compute_stock(self, history: PlayerHistory) -> float:
        """
        Reconstruct the common-pool stock at the start of the next round
        by simulating consumption and logistic growth over past rounds.
        """
        S = float(self.capacity)
        for i in range(history.round_number):
            my_consume = float(history.my_payoffs[i])
            opp_consume = float(np.sum(history.opponent_payoffs[i]))
            total_consumption = my_consume + opp_consume
            S_remain = S - total_consumption
            if S_remain < 0:
                S_remain = 0.0
            growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
            S = S_remain + growth
            if S > self.capacity:
                S = float(self.capacity)
        return S

class Strategy_AGGRESSIVE_71(BaseStrategy):
    """
    Aggressive Sustained Defector (ASD):
    - Always defects except exactly one cooperate in the penultimate round
      (round r-1) if there is any stock, to seed regrowth for a final defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        if history is None:
            t = 1
            S = capacity
        else:
            S = capacity
            rounds_done = history.round_number
            for i in range(rounds_done):
                opp_coops = int(history.opponent_actions[i].sum())
                opp_defs = n - 1 - opp_coops
                cons_opp = opp_coops * (S / (2 * n)) + opp_defs * (S / n)
                if history.my_actions[i]:
                    cons_me = S / (2 * n)
                else:
                    cons_me = S / n
                total_cons = cons_opp + cons_me
                S_rem = S - total_cons
                growth = 2 * S_rem * (1 - S_rem / capacity)
                S = S_rem + growth
                if S < 0:
                    S = 0.0
                elif S > capacity:
                    S = capacity
            t = rounds_done + 1
        if t == r - 1 and S > 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_72(BaseStrategy):
    """
    Relentless Heister: an aggressive common‐pool strategy.
    Defects on the first and last rounds, exploits any cooperator,
    and only cooperates to rescue the pool when stock falls below half capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.target_stock = self.capacity / 2.0
        self.current_stock = self.capacity
        self.last_round_processed = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if history.round_number > self.last_round_processed:
            idx = history.round_number - 1
            total_consumption = float(history.my_payoffs[idx]) + float(history.opponent_payoffs[idx].sum())
            S_remaining = self.current_stock - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            self.current_stock = min(S_remaining + growth, self.capacity)
            self.last_round_processed = history.round_number
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        last_ops = history.opponent_actions[history.round_number - 1]
        if last_ops.any():
            return Action.D
        if self.current_stock < self.target_stock:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_73(BaseStrategy):
    """
    Aggressive common‐pool strategy:
    - Cooperate initially to build stock.
    - Grim‐trigger: punish any defection by switching to permanent defection.
    - Defect permanently starting at the halfway round.
    - Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.T_half = math.floor(self.r / 2) + 1
        self.PUNISH = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        t = history.round_number + 1
        if t >= self.T_half:
            return Action.D
        if self.PUNISH:
            return Action.D
        if history.my_actions.size > 0 and np.any(~history.my_actions) or (history.opponent_actions.size > 0 and np.any(~history.opponent_actions)):
            self.PUNISH = True
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_74(BaseStrategy):
    """
    Threshold Aggressor strategy for the Common Pool Resource Game.
    Always defect in the last round or whenever the stock is above half capacity.
    If the stock is at or below half capacity (but above zero), cooperate to allow regrowth.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.thr = game_description.capacity / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        cap = self.game_description.capacity
        if history is None:
            t = 1
            S = cap
        else:
            completed = history.round_number
            t = completed + 1
            S = cap
            for i in range(completed):
                my_act = history.my_actions[i]
                opp_acts = history.opponent_actions[i]
                num_coop = int(my_act) + int(opp_acts.sum())
                num_def = n - num_coop
                cons = num_coop * (S / (2 * n)) + num_def * (S / n)
                S_remain = S - cons
                growth = 2 * S_remain * (1 - S_remain / cap) if cap > 0 else 0
                S = min(S_remain + growth, cap)
        if t == r:
            return Action.D
        if S <= 0:
            return Action.D
        if S > self.thr:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_75(BaseStrategy):
    """
    Always-Defect strategy: defect every round regardless of history or current stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_76(BaseStrategy):
    """
    Aggressive‐extortion style strategy for the Common Pool Resource Game.
    Defects every round except when the stock falls at or below capacity/(2n),
    at which point it makes one or more consecutive cooperative “rescue” moves
    until the stock recovers above the threshold.  Always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.max_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.T_low = self.capacity / (2 * self.n)
        self.rescued_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if history.round_number == self.max_rounds - 1:
            return Action.D
        S = self.capacity
        for t in range(history.round_number):
            cons_self = history.my_payoffs[t]
            cons_opp = float(np.sum(history.opponent_payoffs[t]))
            total_cons = cons_self + cons_opp
            S_rem = S - total_cons
            growth = 2 * S_rem * (1 - S_rem / self.capacity)
            S = S_rem + growth
            if S > self.capacity:
                S = self.capacity
        if S > self.T_low:
            self.rescued_flag = False
            return Action.D
        else:
            if not self.rescued_flag:
                self.rescued_flag = True
            return Action.C

class Strategy_AGGRESSIVE_77(BaseStrategy):
    """
    Aggressive‐exploit strategy for the Common Pool Resource Game.
    Defects by default to maximize immediate gain, but if the common
    stock falls to or below half capacity (and it's not the final round),
    cooperates just enough to sustain the resource. Always defects in the
    last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = float(game_description.capacity)
        self.n_rounds = game_description.n_rounds
        self.S_crit = self.capacity / 2.0
        self.current_stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            last_idx = history.round_number - 1
            my_consume = float(history.my_payoffs[last_idx])
            opp_consume = float(history.opponent_payoffs[last_idx].sum())
            total_consumption = my_consume + opp_consume
            S_remain = self.current_stock - total_consumption
            growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
            self.current_stock = min(S_remain + growth, self.capacity)
            t = history.round_number + 1
        if t == self.n_rounds:
            return Action.D
        if self.current_stock <= self.S_crit:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_78(BaseStrategy):
    """
    Aggressive Threshold Strategy (ATS) for the Common Pool Resource Game.
    Defects by default, cooperates only when the resource stock falls below
    a low threshold to allow regrowth, and always defects in the last
    epsilon fraction of rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.gamma_low = 0.25
        self.epsilon = 0.1
        self.E = math.ceil(self.r * self.epsilon)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t > self.r - self.E:
            return Action.D
        S = self.capacity
        for k in range(history.round_number):
            my_consume = history.my_payoffs[k]
            opp_consume = float(history.opponent_payoffs[k].sum())
            total_consume = my_consume + opp_consume
            S_remain = S - total_consume
            if S_remain < 0.0:
                S_remain = 0.0
            growth = 2 * S_remain * (1 - S_remain / self.capacity)
            S = S_remain + growth
            if S > self.capacity:
                S = self.capacity
        if S <= self.gamma_low * self.capacity:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_79(BaseStrategy):
    """
    Aggressive Extractor:
    - Always defect except to prop up the commons when stock is very low.
    - Unconditional defect on first round and last 20% of rounds.
    - If stock falls below capacity/4, cooperate for n consecutive rounds to regenerate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.regeneration_threshold = self.capacity / 4.0
        self.regeneration_duration = self.n
        self.endgame_exploit = math.ceil(self.r / 5.0)
        self.regen_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t > self.r - self.endgame_exploit:
            return Action.D
        if self.regen_counter > 0:
            self.regen_counter -= 1
            return Action.C
        S = self.capacity
        for i in range(history.round_number):
            if history.my_actions[i]:
                cons_self = S / (2.0 * self.n)
            else:
                cons_self = S / self.n
            opp_acts = history.opponent_actions[i]
            coop_count = int(np.sum(opp_acts))
            defect_count = len(opp_acts) - coop_count
            cons_opps = coop_count * (S / (2.0 * self.n)) + defect_count * (S / self.n)
            total_cons = cons_self + cons_opps
            S_remain = S - total_cons
            growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
            S = min(S_remain + growth, self.capacity)
        if S < self.regeneration_threshold:
            self.regen_counter = self.regeneration_duration - 1
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_80(BaseStrategy):
    """
    Aggressive sneak-and-grab strategy:
    - Cooperate for the first τ = max(1, floor(0.2 * r)) rounds unless any opponent defects.
    - If any opponent defects before or at τ, switch to permanent defection.
    - After τ rounds (even if no defection seen), defect permanently.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.tau = max(1, math.floor(0.2 * self.r))
        self.deplObserved = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            if not self.deplObserved:
                if (~history.opponent_actions).any():
                    self.deplObserved = True
            t = history.round_number + 1
        if t <= self.tau and (not self.deplObserved):
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_81(BaseStrategy):
    """
    All-Out Siege: Aggressive trigger-style strategy.
    Defect every round except cooperate exactly once on the penultimate round
    to seed growth, then defect in the final round for maximal extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
        else:
            t = history.round_number + 1
        r = self.game_description.n_rounds
        if t <= r - 2:
            return Action.D
        elif t == r - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_82(BaseStrategy):
    """
    Aggressive Threshold Defection (ATD):
    Defect in the first round, defect in the last two rounds,
    and in intermediate rounds defect unless the common-pool
    stock falls below capacity/n, in which case cooperate once
    to allow regrowth.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.c_thresh = self.capacity / self.n

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t >= self.r - 1:
            return Action.D
        S = self.capacity
        for j in range(history.round_number):
            my_act = history.my_actions[j]
            opp_acts = history.opponent_actions[j]
            coop_count = int(my_act) + int(opp_acts.sum())
            total_cons = coop_count * (S / (2 * self.n)) + (self.n - coop_count) * (S / self.n)
            S_remain = S - total_cons
            growth = 2 * S_remain * (1 - S_remain / self.capacity)
            S = min(S_remain + growth, self.capacity)
        if S <= self.c_thresh:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_83(BaseStrategy):
    """
    Aggressive Hysteresis Defector (AHD):
    - EXPLOIT phase: always defect until stock ≤ L, then switch to REGENERATE.
    - REGENERATE phase: always cooperate until stock ≥ U, then switch to EXPLOIT.
    - Always defect on the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.L = 0.3 * self.capacity
        self.U = 0.8 * self.capacity
        self.phase = 'EXPLOIT'

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = self.capacity
        else:
            t = history.round_number + 1
            S = self.capacity
            for i in range(history.round_number):
                my_consume = float(history.my_payoffs[i])
                opp_consume = float(history.opponent_payoffs[i].sum())
                total_consume = my_consume + opp_consume
                S_rem = S - total_consume
                growth = 2 * S_rem * (1 - S_rem / self.capacity)
                S = S_rem + growth
                if S > self.capacity:
                    S = self.capacity
        if t == self.r:
            return Action.D
        if self.phase == 'EXPLOIT':
            if S <= self.L:
                self.phase = 'REGENERATE'
                return Action.C
            else:
                return Action.D
        elif S >= self.U:
            self.phase = 'EXPLOIT'
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_84(BaseStrategy):
    """
    Opportunistic Defection with Conditional Restoration:
    Defect whenever the pool is above a threshold or in the final round;
    otherwise cooperate once to help regenerate the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.f = 0.5
        self.T = self.f * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = self.capacity
        else:
            t = history.round_number + 1
            S = self._compute_current_stock(history)
        if t == self.r or S >= self.T:
            return Action.D
        else:
            return Action.C

    def _compute_current_stock(self, history: PlayerHistory) -> float:
        """
        Reconstructs the current common-pool stock by simulating
        consumption and growth over completed rounds.
        """
        S = float(self.capacity)
        for round_idx in range(history.round_number):
            own_cons = float(history.my_payoffs[round_idx])
            opp_cons = float(history.opponent_payoffs[round_idx].sum())
            total_cons = own_cons + opp_cons
            S_rem = max(S - total_cons, 0.0)
            growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
            S = min(S_rem + growth, self.capacity)
        return S

class Strategy_AGGRESSIVE_85(BaseStrategy):
    """
    Aggressive Threshold Defector:
    Always defects except when the common pool stock falls to a low threshold,
    in which case it cooperates to prevent collapse. Also always defects in
    the first round and in the last k rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.k = 2
        self.S_low = self.capacity / (self.n + 1)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t > self.r - self.k:
            return Action.D
        S = self.capacity
        for rnd in range(history.round_number):
            coop_self = 1 if history.my_actions[rnd] else 0
            coop_opp = int(history.opponent_actions[rnd].sum())
            coop = coop_self + coop_opp
            defect = self.n - coop
            cons = coop * (S / (2 * self.n)) + defect * (S / self.n)
            S_rem = S - cons
            growth = 2 * S_rem * (1 - S_rem / self.capacity)
            S = min(S_rem + growth, self.capacity)
        if S > self.S_low:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_86(BaseStrategy):
    """
    Aggressive Triggered Defection with Conditional Preservation (ATD-CP)

    - Always defects in the final round.
    - Defects whenever the stock at the start of a round is at or above capacity/2.
    - Cooperates only when the stock falls below capacity/2 to allow regrowth.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.T = self.capacity / 2
        self.H = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t > self.r - self.H:
            return Action.D
        last_payoff = history.my_payoffs[-1]
        last_action = history.my_actions[-1]
        if last_action:
            S_k = last_payoff * 2 * self.n
        else:
            S_k = last_payoff * self.n
        coop_others = int(np.sum(history.opponent_actions[-1]))
        coop_total = coop_others + (1 if last_action else 0)
        defect_total = self.n - coop_total
        cons_coop = S_k / (2 * self.n)
        cons_def = S_k / self.n
        total_consumption = coop_total * cons_coop + defect_total * cons_def
        S_remain = S_k - total_consumption
        growth = 2 * S_remain * (1 - S_remain / self.capacity)
        S_t = min(S_remain + growth, self.capacity)
        if S_t >= self.T:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_87(BaseStrategy):
    """
    Aggressive‐Exploit‐When‐Rich, Cooperate‐When‐Poor strategy.
    Defects whenever the common pool is at least half full (or on the final round),
    cooperates otherwise to allow regrowth, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        total_rounds = self.game_description.n_rounds
        if history is None:
            return Action.D
        completed = history.round_number
        current_round = completed + 1
        if current_round == total_rounds:
            return Action.D
        S = capacity
        for rnd in range(completed):
            my_coop = bool(history.my_actions[rnd])
            opp_coops = int(history.opponent_actions[rnd].sum())
            coopors = opp_coops + (1 if my_coop else 0)
            cons_coop = S / (2 * n)
            cons_def = S / n
            total_cons = coopors * cons_coop + (n - coopors) * cons_def
            S_remain = S - total_cons
            if S_remain < 0:
                S_remain = 0.0
            growth = 2 * S_remain * (1 - S_remain / capacity)
            S = S_remain + growth
            if S > capacity:
                S = capacity
        if S >= capacity / 2:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_88(BaseStrategy):
    """
    ARCD: Aggressive Regrowth-Constrained Defection.
    Defect every round except when the stock falls below a threshold
    (alpha × capacity) or in the first/last round edge cases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_low = 0.25 * self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t == self.n_rounds:
            return Action.D
        stock = self.capacity
        for rnd in range(completed):
            if history.my_actions[rnd]:
                total_cons = stock / (2 * self.n_players)
            else:
                total_cons = stock / self.n_players
            for opp_act in history.opponent_actions[rnd]:
                if opp_act:
                    total_cons += stock / (2 * self.n_players)
                else:
                    total_cons += stock / self.n_players
            S_rem = stock - total_cons
            growth = 2 * S_rem * (1 - S_rem / self.capacity)
            stock = S_rem + growth
            if stock > self.capacity:
                stock = self.capacity
        if stock < self.S_low:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_89(BaseStrategy):
    """
    Aggressive Defector: Always defects (Action.D) in every round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_90(BaseStrategy):
    """
    AggressiveHarvester: aggressively mines cooperators, rescues
    the pool when it's low or opponents over-defect, and defects
    unconditionally in the final window.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.w = 1
        self.T_low = self.capacity / 3.0
        self.T_high = 2.0 * self.capacity / 3.0
        self.M = (self.n - 1) // 2 + 1
        self.current_stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.current_stock = self.capacity
            return Action.D
        completed = history.round_number
        t = completed + 1
        last_my = float(history.my_payoffs[-1])
        last_opp = float(np.sum(history.opponent_payoffs[-1]))
        total_consumed = last_my + last_opp
        S_remain = self.current_stock - total_consumed
        growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
        self.current_stock = min(S_remain + growth, self.capacity)
        S_t = self.current_stock
        if S_t <= 0.0:
            return Action.D
        if t > self.r - self.w:
            return Action.D
        if S_t < self.T_low:
            return Action.C
        if S_t >= self.T_high:
            return Action.D
        if t == 1:
            def_count = 0
        else:
            last_ops = history.opponent_actions[completed - 1]
            def_count = int(len(last_ops) - np.sum(last_ops))
        if def_count < self.M:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_91(BaseStrategy):
    """
    Aggressive “grow‐and‐grab with grim trigger” strategy.
    Defects by default, cooperates only when stock < capacity/4 to allow regrowth,
    and switches to permanent defection if any opponent ever defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punisher = False
        self.threshold = float(game_description.capacity) / 4.0
        self.current_stock = float(game_description.capacity)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_rounds = history.round_number
        if last_rounds > 0:
            idx = last_rounds - 1
            my_last_payoff = float(history.my_payoffs[idx])
            n = self.game_description.n_players
            if history.my_actions[idx]:
                S_prev = my_last_payoff * 2.0 * n
            else:
                S_prev = my_last_payoff * n
            total_consumption = my_last_payoff + float(history.opponent_payoffs[idx].sum())
            S_remaining = S_prev - total_consumption
            growth = 2.0 * S_remaining * (1.0 - S_remaining / self.game_description.capacity)
            new_stock = S_remaining + growth
            if new_stock > self.game_description.capacity:
                new_stock = float(self.game_description.capacity)
            self.current_stock = new_stock
        t = history.round_number + 1
        r = self.game_description.n_rounds
        if not self.punisher:
            if (~history.opponent_actions).any():
                self.punisher = True
        if self.punisher:
            return Action.D
        if t == 1 or t == r:
            return Action.D
        if self.current_stock < self.threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_92(BaseStrategy):
    """
    Crisis‐Defector strategy: always defect except that once per “crisis” (when stock
    falls below T = capacity/4) cooperate exactly once to aid regrowth.  Resets the
    cooperation flag when stock recovers above T.  Always defects on round 1 and
    on the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.T = self.capacity / 4.0
        self.cooperated_this_crisis = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        t = completed + 1
        if t == self.r:
            return Action.D
        S = self.capacity
        for i in range(completed):
            my_consume = float(history.my_payoffs[i])
            opp_consume = float(history.opponent_payoffs[i].sum())
            total = my_consume + opp_consume
            S_remain = S - total
            growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
            S = min(S_remain + growth, self.capacity)
        if S >= self.T:
            self.cooperated_this_crisis = False
            return Action.D
        elif not self.cooperated_this_crisis:
            self.cooperated_this_crisis = True
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_93(BaseStrategy):
    """
    Aggressive‐Regeneration strategy:
    Default is defection to grab the largest share. If stock falls to or below
    low_thresh, switch to cooperation (regrowth mode) until stock exceeds high_thresh,
    then resume defection. Always defect in the last two rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.low_thresh = self.capacity / (2 * self.n)
        self.high_thresh = 0.75 * self.capacity
        self.in_regrowth = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        last_payoff = float(history.my_payoffs[-1])
        last_action_cooperated = bool(history.my_actions[-1])
        if last_action_cooperated:
            S_t = last_payoff * 2 * self.n
        else:
            S_t = last_payoff * self.n
        if t >= self.r - 1:
            return Action.D
        if self.in_regrowth:
            if S_t >= self.high_thresh:
                self.in_regrowth = False
                return Action.D
            else:
                return Action.C
        if S_t <= self.low_thresh:
            self.in_regrowth = True
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_94(BaseStrategy):
    """
    Aggressive common‐pool extractor:
    Defect every round except exactly when needed to keep the pool from collapse
    in the intermediate game, and always defect in the first and last two rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        stock = float(self.capacity)
        for i in range(history.round_number):
            my_coop = bool(history.my_actions[i])
            opp_coops = int(sum(history.opponent_actions[i]))
            coopers = opp_coops + (1 if my_coop else 0)
            defectors = self.n - coopers
            c_coop = stock / (2 * self.n)
            c_def = stock / self.n
            total_consumption = coopers * c_coop + defectors * c_def
            s_rem = stock - total_consumption
            if s_rem < 0:
                s_rem = 0.0
            growth = 2.0 * s_rem * (1.0 - s_rem / self.capacity)
            stock = s_rem + growth
            if stock > self.capacity:
                stock = float(self.capacity)
        if t > self.r - 2:
            return Action.D
        if stock > 0.0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_95(BaseStrategy):
    """
    Aggressive Always-Defect (AAD) strategy: never cooperates, always defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_96(BaseStrategy):
    """
    Aggressive “Sustainable Defector” strategy:
    Defect whenever possible to maximize immediate payoff,
    cooperate only if stock is at or below 40% of capacity to spur regrowth,
    and unconditionally defect in the final 20% of rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.C = float(game_description.capacity)
        self.alpha_high = 0.8
        self.alpha_low = 0.4
        self.T_high = self.alpha_high * self.C
        self.T_low = self.alpha_low * self.C
        self.G = math.ceil(0.2 * self.r)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = self.C
        cap = self.C
        n = self.n
        for i in range(history.round_number):
            my_coop = int(history.my_actions[i])
            opp_coops = int(history.opponent_actions[i].sum())
            coop_count = my_coop + opp_coops
            defect_count = n - coop_count
            cons_coop = coop_count * (S / (2 * n))
            cons_def = defect_count * (S / n)
            total_cons = cons_coop + cons_def
            S_rem = S - total_cons
            growth = 2 * S_rem * (1 - S_rem / cap)
            S = min(S_rem + growth, cap)
        if t > self.r - self.G:
            return Action.D
        if S >= self.T_high:
            return Action.D
        if S <= self.T_low:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_97(BaseStrategy):
    """
    Aggressive rescue strategy for the Common Pool Resource Game.
    Always defect except when stock falls to a low threshold, in which case
    perform a short rescue sequence of cooperations, then defect again.
    Always defect on the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock = self.capacity
        self.theta_low = 0.2 * self.capacity
        self.theta_high = 0.8 * self.capacity
        self.R_rescue = 3
        self.rescue_count = 0
        self.last_round_updated = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        completed = history.round_number
        for idx in range(self.last_round_updated, completed):
            S = self.stock
            coop_opp = int(history.opponent_actions[idx].sum())
            my_coop = bool(history.my_actions[idx])
            total_coops = coop_opp + (1 if my_coop else 0)
            total_defs = self.n - total_coops
            cons_coop = S / (2 * self.n) * total_coops
            cons_def = S / self.n * total_defs
            total_consumption = cons_coop + cons_def
            S_remain = S - total_consumption
            growth = 2 * S_remain * (1 - S_remain / self.capacity)
            new_stock = S_remain + growth
            if new_stock > self.capacity:
                new_stock = self.capacity
            if new_stock < 0:
                new_stock = 0.0
            self.stock = new_stock
            if self.stock >= self.theta_high:
                self.rescue_count = 0
        self.last_round_updated = completed
        t = completed + 1
        if t == self.r:
            return Action.D
        if self.rescue_count > 0:
            self.rescue_count -= 1
            return Action.C
        if self.stock <= self.theta_low:
            self.rescue_count = self.R_rescue - 1
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_98(BaseStrategy):
    """
    Aggressive Regenerator strategy:
    - Always defects on the first and last rounds.
    - When the common pool stock S is at or above L = capacity/3, defects to maximize payoff.
    - If S falls below L, switches to regen_mode and cooperates until S reaches H = 2*capacity/3.
    - Uses hysteresis between L and H to avoid flip-flopping.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        cap = float(game_description.capacity)
        self.L = cap / 3.0
        self.H = 2.0 * cap / 3.0
        self.regen_mode = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        r = self.game_description.n_rounds
        n = self.game_description.n_players
        if t == r:
            return Action.D
        S = float(self.game_description.capacity)
        for i in range(history.round_number):
            my_coop = 1 if history.my_actions[i] else 0
            opp_coops = int(history.opponent_actions[i].sum())
            coop_count = my_coop + opp_coops
            defect_count = n - coop_count
            consume_c = S / (2.0 * n)
            consume_d = S / float(n)
            total_consumption = coop_count * consume_c + defect_count * consume_d
            S_rem = S - total_consumption
            growth = 2.0 * S_rem * (1.0 - S_rem / float(self.game_description.capacity))
            S = min(S_rem + growth, float(self.game_description.capacity))
        if self.regen_mode:
            if S < self.H:
                return Action.C
            else:
                self.regen_mode = False
                return Action.D
        elif S < self.L:
            self.regen_mode = True
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_99(BaseStrategy):
    """
    AggressiveHarvest strategy: cooperate in the early half if no defections have been observed,
    switch to permanent defection as soon as any opponent defects, and always defect in the last half
    of the game to harvest the remaining resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_detected = False
        self.T_switch = math.ceil(self.game_description.n_rounds / 2)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if not self.defection_detected:
            if not history.opponent_actions.all():
                self.defection_detected = True
        t = history.round_number + 1
        if t > self.T_switch:
            return Action.D
        if self.defection_detected:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_100(BaseStrategy):
    """
    Aggressive Resource‐Grabber:
    Defect every round except when the pool is in danger of collapse, in which case
    cooperate just enough to allow regrowth, and always defect in the last E rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.E = 2
        self.S_thresh = self.capacity / (2 * self.n)
        self.current_stock = self.capacity
        self.last_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            if t > self.r - self.E:
                return Action.D
            elif self.current_stock <= self.S_thresh:
                return Action.C
            else:
                return Action.D
        completed = history.round_number
        while self.last_round < completed:
            idx = self.last_round
            total_consumption = history.my_payoffs[idx] + history.opponent_payoffs[idx].sum()
            S_remain = self.current_stock - total_consumption
            growth = 2 * S_remain * (1 - S_remain / self.capacity)
            new_stock = S_remain + growth
            if new_stock > self.capacity:
                new_stock = self.capacity
            self.current_stock = new_stock
            self.last_round += 1
        t = history.round_number + 1
        if t > self.r - self.E:
            return Action.D
        elif self.current_stock <= self.S_thresh:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_101(BaseStrategy):
    """
    Aggressive‐exploit with just‐enough conservation:
    Defect every round except when the pool is at or below capacity/n (danger zone),
    in which case cooperate to allow regrowth.  Always defect in the last two rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.r = game_description.n_rounds
        self.theta = self.capacity / self.n

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.capacity
        else:
            last_round = history.round_number
            idx = last_round - 1
            my_payoff = float(history.my_payoffs[idx])
            opp_payoffs = history.opponent_payoffs[idx].tolist()
            all_payoffs = [my_payoff] + opp_payoffs
            max_payoff = max(all_payoffs)
            S_prev = max_payoff * self.n
            total_consumption = sum(all_payoffs)
            S_remaining = S_prev - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            S_t = S_remaining + growth
            if S_t > self.capacity:
                S_t = self.capacity
            t = last_round + 1
        if t >= self.r - 1:
            return Action.D
        if S_t <= self.theta:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_102(BaseStrategy):
    """
    Pure plunder‐and‐burn strategy: always defect (Action.D) every round,
    ignoring history and future stock considerations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_103(BaseStrategy):
    """
    Aggressive harvesting strategy: defect on the first and last rounds;
    only cooperate if everyone (including yourself) defected in the previous round
    so the common pool can regrow for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        prev_idx = history.round_number - 1
        opponents_last = history.opponent_actions[prev_idx]
        all_opponents_defect = not np.any(opponents_last)
        self_defected = not history.my_actions[-1]
        if all_opponents_defect and self_defected:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_104(BaseStrategy):
    """
    Aggressive Harvest with Regeneration:
    - Cooperate on first round.
    - Always defect in the last d_last rounds.
    - In intermediate rounds, defect whenever the stock is above T_high_frac·capacity
      (milk a “high” pool) and only cooperate when the stock falls below T_low_frac·capacity
      to let it recover.
    - If the stock has collapsed for three consecutive rounds (strictly decreasing),
      force one cooperate to help recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description
        self.T_low_frac = 0.5
        self.T_high_frac = 0.8
        self.d_last = 1
        self.capacity = float(self.game.capacity)
        self.T_low = self.T_low_frac * self.capacity
        self.T_high = self.T_high_frac * self.capacity
        self.collapse_count = 0
        self.stocks = [self.capacity]

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        while len(self.stocks) <= history.round_number:
            i = len(self.stocks)
            S_prev = self.stocks[-1]
            idx = i - 1
            my_consume = float(history.my_payoffs[idx])
            opp_consume = float(np.sum(history.opponent_payoffs[idx]))
            total_consumption = my_consume + opp_consume
            S_rem = max(S_prev - total_consumption, 0.0)
            growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
            S_new = min(S_rem + growth, self.capacity)
            self.stocks.append(S_new)
        t = history.round_number + 1
        r = self.game.n_rounds
        S_t = self.stocks[t - 1]
        if t > r - self.d_last:
            return Action.D
        if t >= 3:
            S_prev1 = self.stocks[t - 2]
            S_prev2 = self.stocks[t - 3]
            if S_t < S_prev1 and S_prev1 < S_prev2:
                self.collapse_count += 1
            else:
                self.collapse_count = 0
        else:
            self.collapse_count = 0
        if self.collapse_count >= 1:
            self.collapse_count = 0
            return Action.C
        if S_t <= self.T_low:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_105(BaseStrategy):
    """
    Aggressive Threshold‐and‐Punisher strategy:
    - Defect by default.
    - If the remaining stock falls below capacity/4, cooperate once to let it regrow.
    - If we cooperated and any opponent defected, punish (defect) exactly one round.
    - In the last two rounds always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.T_low = self.capacity / 4.0
        self.punish = False
        self.current_stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_idx = history.round_number - 1
        my_last = bool(history.my_actions[last_idx])
        opp_last = history.opponent_actions[last_idx]
        if my_last and (not opp_last.all()):
            self.punish = True
        else:
            self.punish = False
        S_prev = self.current_stock
        coop_count = int(my_last) + int(opp_last.sum())
        defect_count = self.n - coop_count
        total_consumption = coop_count * (S_prev / (2 * self.n)) + defect_count * (S_prev / self.n)
        S_remain = S_prev - total_consumption
        growth = 2 * S_remain * (1 - S_remain / self.capacity)
        S_new = S_remain + growth
        self.current_stock = min(S_new, self.capacity)
        t = history.round_number + 1
        if t >= self.r - 1:
            return Action.D
        if self.punish:
            return Action.D
        if self.current_stock <= self.T_low:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_106(BaseStrategy):
    """
    Aggressive Preserver:
    Defect on the first round and every round except when the common pool
    stock is at or below capacity/(2n), in which case cooperate to allow regrowth.
    Always defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        cap = self.game_description.capacity
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if history is None:
            return Action.D
        completed = history.round_number
        current_round = completed + 1
        if current_round >= r:
            return Action.D
        S = cap
        for t in range(completed):
            my_cons = history.my_payoffs[t]
            opp_cons = history.opponent_payoffs[t].sum()
            total_cons = my_cons + opp_cons
            S_rem = S - total_cons
            growth = 2 * S_rem * (1 - S_rem / cap)
            S = min(S_rem + growth, cap)
        threshold = cap / (2 * n)
        if S <= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_107(BaseStrategy):
    """
    Aggressive common‐pool strategy using low/high water marks.
    - Modes: Exploit (always defect) or Regrow (always cooperate).
    - Switch to Regrow when stock ≤ L, back to Exploit when stock ≥ H.
    - Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.L = 0.25 * self.capacity
        self.H = 0.75 * self.capacity
        self.mode = 'Exploit'

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        past_rounds = history.round_number
        t = past_rounds + 1
        stock = self.capacity
        for i in range(past_rounds):
            total_consumption = float(history.my_payoffs[i]) + float(np.sum(history.opponent_payoffs[i]))
            remaining = stock - total_consumption
            growth = 2.0 * remaining * (1.0 - remaining / self.capacity)
            stock = min(remaining + growth, self.capacity)
        if t == self.r:
            return Action.D
        if self.mode == 'Exploit':
            if stock <= self.L:
                self.mode = 'Regrow'
                return Action.C
            else:
                return Action.D
        elif stock >= self.H:
            self.mode = 'Exploit'
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_108(BaseStrategy):
    """
    Exploit‐and‐punish strategy for the common‐pool game.
    Defects first and last round. In midgame, only cooperates
    to rescue the stock if it's dangerously low or slipping
    below threshold when defection is rampant; otherwise
    aggressively defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        theta_low = 0.25 * capacity
        theta_high = 0.75 * capacity
        alpha = 0.5
        if history is None or history.round_number == 0:
            return Action.D
        t = history.round_number + 1
        if t == r:
            return Action.D
        S = capacity
        for j in range(history.round_number):
            my_cons = float(history.my_payoffs[j])
            opp_cons = float(np.sum(history.opponent_payoffs[j]))
            total_cons = my_cons + opp_cons
            S_rem = S - total_cons
            if S_rem <= 0:
                S = 0.0
            else:
                growth = 2 * S_rem * (1 - S_rem / capacity)
                S = min(S_rem + growth, capacity)
        if S <= 0:
            return Action.D
        prev_idx = history.round_number - 1
        opp_coops = int(np.sum(history.opponent_actions[prev_idx]))
        self_coop = 1 if bool(history.my_actions[prev_idx]) else 0
        coop_frac = (opp_coops + self_coop) / n
        if S < theta_low:
            return Action.C
        elif coop_frac >= alpha and S > theta_high:
            return Action.D
        elif coop_frac < alpha and S < theta_high:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_109(BaseStrategy):
    """
    Threshold Exploit-Rescue (TER):
    Aggressively defect until the common‐pool stock falls to or below θ = capacity/(2n),
    then cooperate for exactly one round to rescue the stock, except always defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.theta = self.capacity / (2 * self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.capacity
        else:
            completed = history.round_number
            t = completed + 1
            S = self.capacity
            for i in range(completed):
                mine = bool(history.my_actions[i])
                opponents = history.opponent_actions[i].tolist()
                actions = [mine] + opponents
                coop_count = sum((1 for a in actions if a))
                defect_count = len(actions) - coop_count
                cons_coop = coop_count * (S / (2 * self.n))
                cons_def = defect_count * (S / self.n)
                S_remain = S - (cons_coop + cons_def)
                growth = 2 * S_remain * (1 - S_remain / self.capacity)
                S = S_remain + growth
                if S > self.capacity:
                    S = self.capacity
            S_t = S
        if t == self.r:
            return Action.D
        if S_t <= self.theta:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_110(BaseStrategy):
    """
    Aggro‐Steady: aggressive common‐pool‐resource strategy with three phases.
    Always defects in opening and endgame. In maintenance, punishes any cooperating
    opponents, exploits abundant stock, but cooperates only when stock is dangerously low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.T_low = self.capacity / 3.0
        self.T_high = 2.0 * self.capacity / 3.0
        self.stock = self.capacity
        self.last_round = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_rounds = history.round_number
        if current_rounds > self.last_round:
            idx = current_rounds - 1
            my_consume = float(history.my_payoffs[idx])
            opp_consume = float(np.sum(history.opponent_payoffs[idx]))
            total_consumption = my_consume + opp_consume
            S_rem = self.stock - total_consumption
            if S_rem < 0.0:
                S_rem = 0.0
            growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
            new_stock = S_rem + growth
            if new_stock > self.capacity:
                new_stock = self.capacity
            self.stock = new_stock
            self.last_round = current_rounds
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        prev_idx = history.round_number - 1
        opp_actions_last = history.opponent_actions[prev_idx]
        OppCoop = int(np.sum(opp_actions_last))
        if OppCoop > 0:
            return Action.D
        if self.stock > self.T_high:
            return Action.D
        if self.stock < self.T_low:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_111(BaseStrategy):
    """
    Aggressive‐Exploit strategy: defect every round to maximize immediate payoff,
    except if in the previous round every player (including us) defected, in which
    case we cooperate once to prevent total collapse of the common pool.
    In the very last round, defect unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        next_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if next_round == total_rounds:
            return Action.D
        if history.round_number > 0:
            prev_idx = history.round_number - 1
            we_defected = not bool(history.my_actions[prev_idx])
            opponents_defected = not bool(history.opponent_actions[prev_idx].any())
            if we_defected and opponents_defected:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_112(BaseStrategy):
    """
    Aggressive Threshold-Exploiter:
    Defects by default to maximize short‐term gain, but if the common pool
    stock falls below a dynamically computed threshold, it temporarily
    cooperates to allow the stock to regrow. Always defects in the first
    and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.phi = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        rem = self.r - t + 1
        S_threshold = self.phi * self.capacity * (rem / self.r)
        last_idx = history.round_number - 1
        last_payoff = history.my_payoffs[last_idx]
        last_action = history.my_actions[last_idx]
        if last_action:
            S = last_payoff * 2 * self.n
        else:
            S = last_payoff * self.n
        if S < S_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_113(BaseStrategy):
    """
    Aggressive Regenerative Defector (ARD) strategy for the common-pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        cap = self.game_description.capacity
        cap_eff = cap if cap >= 2 * n else 2 * n
        T_low = 0.2 * cap_eff
        if history is None:
            t = 1
            S = float(cap_eff)
        else:
            t = history.round_number + 1
            S = float(cap_eff)
            for idx in range(history.round_number):
                coop_self = int(history.my_actions[idx])
                coop_opponents = int(history.opponent_actions[idx].sum())
                c = coop_self + coop_opponents
                d = n - c
                total_cons = S * (c / (2.0 * n) + d / float(n))
                S_remain = S - total_cons
                growth = 2 * S_remain * (1 - S_remain / cap_eff)
                S = S_remain + growth
                if S > cap_eff:
                    S = cap_eff
        if t == r:
            return Action.D
        if S <= T_low:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_114(BaseStrategy):
    """
    Grim-Endgame strategy for the common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defected_ever = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round = history.round_number - 1
        if last_round >= 0:
            if not history.opponent_actions[last_round].all():
                self.defected_ever = True
        t = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if t == total_rounds:
            return Action.D
        if self.defected_ever:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_115(BaseStrategy):
    """
    Aggressive Harvester with Emergency Sustainability:
    Defect every round to maximize immediate payoff, but if the common pool
    stock falls below a critical threshold, cooperate once to stave off collapse.
    First and last rounds are always defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.T_low = self.capacity / (4 * self.n)
        self.current_stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round = history.round_number - 1
        if last_round >= 0:
            my_pay = float(history.my_payoffs[last_round])
            opp_pay = float(history.opponent_payoffs[last_round].sum())
            total_consumed = my_pay + opp_pay
            remaining = self.current_stock - total_consumed
            growth = 2 * remaining * (1 - remaining / self.capacity)
            self.current_stock = min(remaining + growth, self.capacity)
        t = history.round_number + 1
        if t == self.r:
            return Action.D
        if self.current_stock <= self.T_low:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_116(BaseStrategy):
    """
    Aggressive exploiter with minimal preservation.
    Defect every round except:
      - Rescue (cooperate) when stock ≤ T_low
      - Continue rescue if last action was C and stock < T_high
    Always defect in round 1 and the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.T_low = self.capacity / (4 * self.n)
        self.T_high = self.capacity / 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t_next = history.round_number + 1
        if t_next == self.r:
            return Action.D
        S = self.capacity
        for i in range(history.round_number):
            my_act = history.my_actions[i]
            opp_acts = history.opponent_actions[i]
            cons = 0.0
            if my_act:
                cons += S / (2 * self.n)
            else:
                cons += S / self.n
            for act in opp_acts:
                if act:
                    cons += S / (2 * self.n)
                else:
                    cons += S / self.n
            S_rem = S - cons
            growth = 2 * S_rem * (1 - S_rem / self.capacity)
            S = S_rem + growth
            if S > self.capacity:
                S = self.capacity
            elif S < 0:
                S = 0
        prev_coop = history.my_actions[-1]
        if S <= self.T_low:
            return Action.C
        if prev_coop and S < self.T_high:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_117(BaseStrategy):
    """
    Aggressive‐Pragmatist: defect by default, but cooperate when stock ≤ θ_low to regenerate,
    and switch back to defection once stock ≥ θ_high; always defect in the last H rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = float(game_description.capacity)
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.theta_low = 0.25 * self.capacity
        self.theta_high = 0.9 * self.capacity
        self.H = 1
        self.regen_mode = False
        self.current_stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.regen_mode = False
            self.current_stock = self.capacity
            return Action.D
        last_idx = history.round_number - 1
        my_last_payoff = float(history.my_payoffs[last_idx])
        opp_last_payoffs = float(np.sum(history.opponent_payoffs[last_idx]))
        total_consumption = my_last_payoff + opp_last_payoffs
        S_remain = self.current_stock - total_consumption
        if S_remain < 0.0:
            S_remain = 0.0
        growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
        S_next = S_remain + growth
        if S_next > self.capacity:
            S_next = self.capacity
        self.current_stock = S_next
        t = history.round_number + 1
        if t > self.n_rounds - self.H:
            return Action.D
        if self.regen_mode:
            if self.current_stock >= self.theta_high:
                self.regen_mode = False
                return Action.D
            else:
                return Action.C
        elif self.current_stock <= self.theta_low:
            self.regen_mode = True
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_118(BaseStrategy):
    """
    Aggressive Exploiter with Stock Management (AESM).
    Defects in the first and last rounds. In intermediate rounds,
    cooperates only if the current stock is below θ_low to avoid collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = float(game_description.capacity)
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.theta_low = self.capacity * 0.3
        self.epsilon = 1e-06

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        S = self.capacity
        rounds_played = history.round_number
        for k in range(rounds_played):
            my_act = history.my_actions[k]
            opp_acts = history.opponent_actions[k]
            coop_count = int(my_act) + int(np.sum(opp_acts))
            defect_count = self.n_players - coop_count
            coop_cons = S / (2 * self.n_players)
            defect_cons = S / self.n_players
            total_consumption = coop_count * coop_cons + defect_count * defect_cons
            S_rem = S - total_consumption
            growth = 2 * S_rem * (1 - S_rem / self.capacity)
            S = min(S_rem + growth, self.capacity)
        current_round = rounds_played + 1
        if current_round == self.n_rounds:
            return Action.D
        if S <= self.theta_low + self.epsilon:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_119(BaseStrategy):
    """
    Aggressive Threshold Defector (ATD):
    Defect by default to maximize short-term gain, but cooperate
    if the stock is at or below a break threshold so as not to
    collapse the pool entirely, preserving future opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.desc = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.T_break = self.capacity / (self.n + 1)
        self.stock = self.capacity
        self.last_round_processed = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        for round_idx in range(self.last_round_processed, history.round_number):
            S_prev = self.stock
            coop_me = 1 if history.my_actions[round_idx] else 0
            coop_opp = int(np.sum(history.opponent_actions[round_idx]))
            num_C = coop_me + coop_opp
            cons_C = S_prev / (2 * self.n)
            cons_D = S_prev / self.n
            total_consumption = num_C * cons_C + (self.n - num_C) * cons_D
            S_rem = S_prev - total_consumption
            growth = 2 * S_rem * (1 - S_rem / self.capacity)
            S_new = S_rem + growth
            if S_new > self.capacity:
                S_new = self.capacity
            if S_new < 0:
                S_new = 0.0
            self.stock = S_new
            self.last_round_processed += 1
        current_round = history.round_number + 1
        if self.stock <= 0:
            return Action.C
        if current_round == self.r:
            return Action.D
        if self.stock <= self.T_break:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_120(BaseStrategy):
    """
    Aggressive greedy-regenerative strategy for the Common Pool Resource Game.
    - Round 1: defect.
    - Middle rounds: if any opponent cooperated last round, defect; 
      otherwise cooperate to let the stock recover.
    - Final T_spree rounds: defect unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.T_spree = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_rounds_played = history.round_number
        t = last_rounds_played + 1
        r = self.game_description.n_rounds
        if t > r - self.T_spree:
            return Action.D
        last_ops = history.opponent_actions[last_rounds_played - 1]
        if last_ops.any():
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_121(BaseStrategy):
    """
    Aggressive Resource Exploiter:
    Defects every round to maximize immediate payoff. Only once,
    if the common pool stock falls to a tiny threshold (S_min)
    and before the final round, it will cooperate for one round
    to allow minimal regrowth, then resume defection. Never
    cooperates in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_min = self.capacity / (10 * self.n)
        self.recovery_used = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S = self.capacity
        else:
            t = history.round_number + 1
            S = self._compute_stock(history)
        if t == self.r:
            return Action.D
        if S <= self.S_min and (not self.recovery_used):
            self.recovery_used = True
            return Action.C
        return Action.D

    def _compute_stock(self, history: PlayerHistory) -> float:
        """
        Re-simulate the common pool stock dynamics from the start
        up through the last completed round in history.
        """
        S = self.capacity
        for i in range(history.round_number):
            my_cons = float(history.my_payoffs[i])
            opp_cons = float(np.sum(history.opponent_payoffs[i]))
            total_cons = my_cons + opp_cons
            S_remain = max(0.0, S - total_cons)
            growth = 2 * S_remain * (1 - S_remain / self.capacity)
            S = min(S_remain + growth, self.capacity)
        return S

class Strategy_AGGRESSIVE_122(BaseStrategy):
    """
    Aggressive All‐D strategy: always defect in every round,
    regardless of stock level or opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_AGGRESSIVE_123(BaseStrategy):
    """
    Aggressive Threshold-Defection:
    Defect every round except:
      - Penultimate round: cooperate if the stock is below full capacity,
        to boost regrowth for the final round.
      - Intermediate rounds: cooperate only if stock has fallen below one‐third
        of capacity, to preserve the commons just enough to defect again later.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_low = game_description.capacity / 3.0
        self.current_stock = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        cap = self.game_description.capacity
        if history is None:
            self.current_stock = float(cap)
            return Action.D
        prev_S = self.current_stock
        last_my_action = history.my_actions[-1]
        last_opp_actions = history.opponent_actions[-1]
        coop_opp = int(last_opp_actions.sum())
        defect_opp = n - 1 - coop_opp
        if last_my_action:
            cons_self = prev_S / (2.0 * n)
        else:
            cons_self = prev_S / n
        cons_opp = coop_opp * (prev_S / (2.0 * n)) + defect_opp * (prev_S / n)
        total_consumption = cons_self + cons_opp
        S_remain = prev_S - total_consumption
        growth = 2.0 * S_remain * (1.0 - S_remain / cap)
        self.current_stock = min(S_remain + growth, float(cap))
        t = history.round_number + 1
        if t == r:
            return Action.D
        if t == r - 1:
            return Action.C if self.current_stock < cap else Action.D
        if self.current_stock < self.threshold_low:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_124(BaseStrategy):
    """
    Opportunistic Defector with Regrowth Safeguard.
    Defects whenever the stock is above half‐capacity or on the last round;
    otherwise cooperates to allow regrowth.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.threshold = self.capacity / 2.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.capacity
        else:
            t = history.round_number + 1
            S_t = self._compute_stock(history)
        if t == self.n_rounds:
            return Action.D
        if S_t > self.threshold:
            return Action.D
        return Action.C

    def _compute_stock(self, history: PlayerHistory) -> float:
        """
        Reconstructs the common‐pool stock at the start of the next round,
        given the full action history.
        """
        S = self.capacity
        n = self.n_players
        for round_idx in range(history.round_number):
            my_coop = 1 if history.my_actions[round_idx] else 0
            opp_coop = int(history.opponent_actions[round_idx].sum())
            coop_count = my_coop + opp_coop
            defect_count = n - coop_count
            c_coop = S / (2.0 * n)
            c_def = S / n
            total_consumption = coop_count * c_coop + defect_count * c_def
            S_rem = S - total_consumption
            growth = 2.0 * S_rem * (1.0 - S_rem / self.capacity)
            S = S_rem + growth
            if S > self.capacity:
                S = self.capacity
        return S

class Strategy_AGGRESSIVE_125(BaseStrategy):
    """
    Aggressive trigger strategy for the common pool resource game.
    Always defects except for a brief cooperation when the stock
    falls below a threshold, and unconditionally defects in the
    final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = float(game_description.capacity)
        self.safe_thresh = self.capacity / 3.0
        self.regen_rounds = 1
        self.endgame_rounds = min(2, game_description.n_rounds - 1)
        self.regen_used = 0
        self.current_stock = self.capacity

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            t = 1
            S_t = self.current_stock
        else:
            my_consume = history.my_payoffs[-1]
            opp_consume = history.opponent_payoffs[-1].sum()
            total_consumption = my_consume + opp_consume
            S_remain = self.current_stock - total_consumption
            growth = 2.0 * S_remain * (1.0 - S_remain / self.capacity)
            new_stock = min(S_remain + growth, self.capacity)
            self.current_stock = new_stock
            t = history.round_number + 1
            S_t = self.current_stock
        if t > self.game_description.n_rounds - self.endgame_rounds:
            return Action.D
        if S_t < self.safe_thresh and self.regen_used < self.regen_rounds:
            self.regen_used += 1
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_126(BaseStrategy):
    """
    Aggressive exploiter strategy:
    - Defect whenever the common pool stock is healthy or in the endgame.
    - Cooperate only when stock falls below a low-stock threshold to allow regrowth.
    - In the last E rounds, always defect to grab the remaining resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.alpha = 0.2
        self.E = 1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        t = history.round_number + 1
        S = float(self.capacity)
        for i in range(history.round_number):
            my_consume = float(history.my_payoffs[i])
            opp_consume = float(np.sum(history.opponent_payoffs[i]))
            total_consumption = my_consume + opp_consume
            S_remaining = max(0.0, S - total_consumption)
            growth = 2.0 * S_remaining * (1.0 - S_remaining / self.capacity)
            S = min(S_remaining + growth, self.capacity)
        T_rem = self.r - t + 1
        if T_rem <= self.E:
            return Action.D
        elif S < self.alpha * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_127(BaseStrategy):
    """
    Aggressive defection strategy: always plays D to maximize immediate payoff.
    Formal “rescue‐coop” if the pool ever hits zero before the last round,
    but since growth from zero is zero, this is only a formality.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_stock = float(game_description.capacity)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last = history.round_number - 1
        prev_stock = self.current_stock
        n = self.game_description.n_players
        cap = float(self.game_description.capacity)
        opp_coops = int(history.opponent_actions[last].sum())
        my_coop = 1 if history.my_actions[last] else 0
        total_coops = opp_coops + my_coop
        total_defs = n - total_coops
        cons_coop = prev_stock / (2 * n)
        cons_def = prev_stock / n
        total_consumption = total_coops * cons_coop + total_defs * cons_def
        remain = prev_stock - total_consumption
        growth = 2 * remain * (1 - remain / cap)
        self.current_stock = min(remain + growth, cap)
        if self.current_stock <= 0 and history.round_number < self.game_description.n_rounds:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_128(BaseStrategy):
    """
    Grim\u2009+\u2009End‐Game Exploiter:
    - Cooperate until any opponent defects (grim trigger).
    - Once any defection observed, defect forever.
    - In the last L rounds, always defect to exploit the remaining stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.L = 2
        self.defect_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        if history is None:
            t = 1
            if t > n_rounds - self.L:
                return Action.D
            else:
                return Action.C
        t = history.round_number + 1
        if t > n_rounds - self.L:
            return Action.D
        if self.defect_flag:
            return Action.D
        if not history.opponent_actions.all():
            self.defect_flag = True
            return Action.D
        return Action.C