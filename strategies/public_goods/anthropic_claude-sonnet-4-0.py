"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: Anthropic
- Model: claude-sonnet-4-0
- Game: PublicGoodsDescription
"""

from emergent_llm.players.base_player import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription
from emergent_llm.common.actions import Action, C, D
from emergent_llm.common.history import PlayerHistory
import numpy as np
from numpy.typing import NDArray
import math
import random



class Strategy_COOPERATIVE_1(BaseStrategy):
    """
    Trust Builder Strategy: Begins with cooperation to establish trust, then adapts
    based on group cooperation rates. Cooperates when majority cooperated last round,
    defects otherwise. Uses forgiveness in final round for groups with decent history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds:
            total_cooperation_rate = 0.0
            for round_idx in range(history.round_number):
                my_cooperation = int(history.my_actions[round_idx])
                opponent_cooperation = sum(history.opponent_actions[round_idx])
                total_cooperators = my_cooperation + opponent_cooperation
                cooperation_rate = total_cooperators / n_players
                total_cooperation_rate += cooperation_rate
            average_cooperation_rate = total_cooperation_rate / history.round_number
            return Action.C if average_cooperation_rate >= 0.4 else Action.D
        last_round_idx = history.round_number - 1
        my_last_action = int(history.my_actions[last_round_idx])
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = my_last_action + opponent_cooperators
        cooperation_rate_last_round = total_cooperators / n_players
        return Action.C if cooperation_rate_last_round >= 0.5 else Action.D

class Strategy_COOPERATIVE_2(BaseStrategy):
    """
    Graduated Reciprocator: A cooperative strategy that starts optimistically,
    responds proportionally to observed cooperation levels, and includes forgiveness
    mechanisms to recover from coordination failures.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last / self.n
        if current_round <= 3:
            threshold = 0.3
        elif current_round >= self.r - 2:
            threshold = 0.6
        else:
            threshold = 0.5
        if current_round > 2 and (not history.my_actions[last_round_idx]) and (history.round_number >= 2):
            cooperators_2_ago = sum(history.opponent_actions[last_round_idx - 1])
            improvement = (cooperators_last - cooperators_2_ago) / self.n
            if improvement > 0.1:
                return Action.C
        if cooperation_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_3(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy starts cooperatively, reciprocates group behavior with generous thresholds,
    includes forgiveness mechanisms to break defection cycles, and has endgame protection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            rounds_to_check = min(3, history.round_number)
            total_possible_cooperators = rounds_to_check * n
            total_cooperators = 0
            for round_idx in range(history.round_number - rounds_to_check, history.round_number):
                round_cooperators = int(history.my_actions[round_idx]) + sum(history.opponent_actions[round_idx])
                total_cooperators += round_cooperators
            recent_cooperation_rate = total_cooperators / total_possible_cooperators
            if recent_cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        consecutive_defections = 0
        rounds_to_check = min(3, history.round_number)
        for i in range(history.round_number - rounds_to_check, history.round_number):
            if not history.my_actions[i]:
                consecutive_defections += 1
        if consecutive_defections >= 2:
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        previous_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            previous_cooperators += 1
        group_cooperation_rate = previous_cooperators / n
        if group_cooperation_rate >= 0.5:
            return Action.C
        elif group_cooperation_rate >= 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_4(BaseStrategy):
    """
    Conditional Cooperation with Graduated Reciprocation Strategy.
    
    This strategy balances cooperative intent with protection against exploitation
    by using conditional cooperation based on group cooperation levels, with 
    graduated responses to defection and forgiveness mechanisms.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if current_round == 2:
            return Action.C
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        cooperation_rate = last_round_cooperators / n
        my_cooperations = sum(history.my_actions)
        personal_cooperation_rate = my_cooperations / history.round_number
        if current_round >= total_rounds - 1:
            if current_round == total_rounds:
                if personal_cooperation_rate > 0.6 and cooperation_rate >= 0.4:
                    return Action.C
                else:
                    return Action.D
            elif history.round_number >= 3:
                recent_coop_sum = 0
                recent_rounds = min(3, history.round_number)
                for i in range(recent_rounds):
                    round_idx = history.round_number - 1 - i
                    round_cooperators = sum(history.opponent_actions[round_idx])
                    if history.my_actions[round_idx]:
                        round_cooperators += 1
                    recent_coop_sum += round_cooperators
                recent_cooperation_rate = recent_coop_sum / (recent_rounds * n)
                if recent_cooperation_rate >= 0.5:
                    return Action.C
                else:
                    return Action.D
            elif cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if history.round_number >= 2:
            prev_round_idx = history.round_number - 2
            prev_cooperators = sum(history.opponent_actions[prev_round_idx])
            if history.my_actions[prev_round_idx]:
                prev_cooperators += 1
            previous_cooperation_rate = prev_cooperators / n
            if cooperation_rate >= 0.6 and previous_cooperation_rate < 0.4:
                return Action.C
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            if personal_cooperation_rate > cooperation_rate + 0.1:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_5(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperation while being resilient to 
    occasional defections and exploitation attempts. It balances cooperative intentions 
    with self-protection mechanisms through reciprocal cooperation, generous forgiveness,
    exploitation protection, and endgame caution.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.2
        self.endgame_protection = 3
        self.punishment_duration = 2
        self.consecutive_exploited = 0
        self.in_punishment_phase = False
        self.punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round > self.game_description.n_rounds - self.endgame_protection:
            others_cooperation_rate = self._calculate_others_cooperation_rate(history, history.round_number - 1)
            if others_cooperation_rate < 0.6:
                return Action.D
            else:
                return Action.C
        if self.in_punishment_phase:
            self.punishment_rounds_left -= 1
            if self.punishment_rounds_left <= 0:
                self.in_punishment_phase = False
                self.consecutive_exploited = 0
            return Action.D
        last_round_others_coop_rate = self._calculate_others_cooperation_rate(history, history.round_number - 1)
        if history.my_actions[history.round_number - 1] and last_round_others_coop_rate < 0.3:
            self.consecutive_exploited += 1
            if self.consecutive_exploited >= 2:
                self.in_punishment_phase = True
                self.punishment_rounds_left = self.punishment_duration
                return Action.D
        else:
            self.consecutive_exploited = 0
        recent_cooperation_rate = self._calculate_others_cooperation_rate_recent(history, 3)
        if recent_cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif random.random() < self.forgiveness_probability:
            return Action.C
        else:
            return Action.D

    def _calculate_others_cooperation_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """Calculate what fraction of OTHER players cooperated in specified round (0-indexed)."""
        if round_idx < 0 or round_idx >= history.round_number:
            return 0.0
        total_others = self.game_description.n_players - 1
        if total_others == 0:
            return 0.0
        others_cooperating = sum(history.opponent_actions[round_idx])
        return others_cooperating / total_others

    def _calculate_others_cooperation_rate_recent(self, history: PlayerHistory, lookback: int) -> float:
        """Average cooperation rate of others over last 'lookback' rounds."""
        if history.round_number == 0:
            return 0.0
        total_rate = 0.0
        rounds_counted = 0
        start_round = max(0, history.round_number - lookback)
        for i in range(start_round, history.round_number):
            total_rate += self._calculate_others_cooperation_rate(history, i)
            rounds_counted += 1
        if rounds_counted == 0:
            return 0.0
        return total_rate / rounds_counted

class Strategy_COOPERATIVE_6(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperation while being robust against 
    exploitation. It cooperates by default, punishes sustained defection, and includes 
    forgiveness mechanisms to recover from punishment cycles.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_limit = 2
        self.consecutive_low_cooperation = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_low_cooperation = 0
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate_last_round = total_cooperators / n_players
        if current_round == n_rounds:
            return Action.C if cooperation_rate_last_round >= self.cooperation_threshold else Action.D
        if cooperation_rate_last_round >= self.cooperation_threshold:
            self.consecutive_low_cooperation = 0
            return Action.C
        elif self.consecutive_low_cooperation < self.forgiveness_limit:
            self.consecutive_low_cooperation += 1
            return Action.C
        else:
            self.consecutive_low_cooperation = 0
            return Action.D

class Strategy_COOPERATIVE_7(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness: A cooperative strategy that starts with cooperation,
    responds to majority behavior with forgiveness mechanisms, and provides protection against
    exploitation while maintaining cooperative potential throughout the game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return self._final_round_decision(history, n)
        return self._conditional_cooperation_decision(history, n, current_round)

    def _final_round_decision(self, history: PlayerHistory, n: int) -> Action:
        """Handle final round with cautious cooperation strategy."""
        total_cooperators_all_rounds = 0
        total_rounds_completed = history.round_number
        for round_idx in range(total_rounds_completed):
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            my_cooperation = 1 if history.my_actions[round_idx] else 0
            total_cooperators_all_rounds += opponent_cooperators + my_cooperation
        overall_cooperation_rate = total_cooperators_all_rounds / (n * total_rounds_completed)
        last_round_idx = total_rounds_completed - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        cooperation_rate_last = last_round_cooperators / n
        if overall_cooperation_rate >= 0.6:
            return Action.C
        elif overall_cooperation_rate >= 0.4 and cooperation_rate_last >= 0.5:
            return Action.C
        else:
            return Action.D

    def _conditional_cooperation_decision(self, history: PlayerHistory, n: int, current_round: int) -> Action:
        """Handle conditional cooperation with forgiveness mechanism."""
        last_round_idx = history.round_number - 1
        last_round_opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators = last_round_opponent_cooperators + 1
        else:
            last_round_cooperators = last_round_opponent_cooperators
        cooperation_rate_last = last_round_cooperators / n
        total_cooperators_all_rounds = 0
        total_rounds_completed = history.round_number
        for round_idx in range(total_rounds_completed):
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            my_cooperation = 1 if history.my_actions[round_idx] else 0
            total_cooperators_all_rounds += opponent_cooperators + my_cooperation
        overall_cooperation_rate = total_cooperators_all_rounds / (n * total_rounds_completed)
        if cooperation_rate_last >= 0.5:
            return Action.C
        forgiveness_threshold = min(0.3, overall_cooperation_rate)
        if cooperation_rate_last >= forgiveness_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_8(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperation while being resilient to
    occasional defections. It cooperates in round 1, then uses a majority-based threshold
    with forgiveness mechanism, and has special logic for the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0
        self.max_forgiveness = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.forgiveness_counter = 0
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_index = history.round_number - 1
        cooperators_last_round = int(sum(history.opponent_actions[last_round_index]))
        if history.my_actions[last_round_index]:
            cooperators_last_round += 1
        cooperation_threshold = n / 2
        if current_round == r:
            rounds_to_check = min(3, history.round_number)
            start_round = history.round_number - rounds_to_check
            total_cooperators = 0
            total_possible = 0
            for round_idx in range(start_round, history.round_number):
                round_cooperators = int(sum(history.opponent_actions[round_idx]))
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                total_cooperators += round_cooperators
                total_possible += n
            recent_cooperation_rate = total_cooperators / total_possible if total_possible > 0 else 0
            if recent_cooperation_rate >= 0.4 and cooperators_last_round >= n / 3:
                return Action.C
            else:
                return Action.D
        if cooperators_last_round >= cooperation_threshold:
            self.forgiveness_counter = 0
            return Action.C
        elif self.forgiveness_counter < self.max_forgiveness:
            self.forgiveness_counter += 1
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_9(BaseStrategy):
    """
    Graduated Reciprocator: A cooperative strategy that adapts to group behavior.
    Starts optimistically, then uses adaptive thresholds based on observed cooperation rates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds:
            total_cooperation = 0
            for round_idx in range(history.round_number):
                if history.my_actions[round_idx]:
                    total_cooperation += 1
                total_cooperation += sum(history.opponent_actions[round_idx])
            total_decisions = n_players * history.round_number
            average_cooperation_rate = total_cooperation / total_decisions
            return Action.C if average_cooperation_rate >= 0.4 else Action.D
        else:
            total_cooperation = 0
            for round_idx in range(history.round_number):
                if history.my_actions[round_idx]:
                    total_cooperation += 1
                total_cooperation += sum(history.opponent_actions[round_idx])
            total_decisions = n_players * history.round_number
            observed_cooperation_rate = total_cooperation / total_decisions
            last_round_idx = history.round_number - 1
            last_round_cooperators = sum(history.opponent_actions[last_round_idx])
            if history.my_actions[last_round_idx]:
                last_round_cooperators += 1
            cooperation_rate_last_round = last_round_cooperators / n_players
            cooperation_threshold = max(0.3, observed_cooperation_rate * 0.8)
            return Action.C if cooperation_rate_last_round >= cooperation_threshold else Action.D

class Strategy_COOPERATIVE_10(BaseStrategy):
    """
    Generous Tit-for-Tat with Majority Threshold strategy for N-Player Public Goods Game.
    
    Cooperates in first round, then uses majority threshold (50%) with generous forgiveness (40%)
    to decide cooperation. In final round, maintains cooperation if recent group cooperation >= 60%.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == total_rounds:
            recent_rounds = min(3, history.round_number)
            start_round = history.round_number - recent_rounds
            total_recent_cooperators = 0
            total_recent_decisions = 0
            for round_idx in range(start_round, history.round_number):
                my_cooperation = 1 if history.my_actions[round_idx] else 0
                opponent_cooperators = sum(history.opponent_actions[round_idx])
                round_cooperators = my_cooperation + opponent_cooperators
                total_recent_cooperators += round_cooperators
                total_recent_decisions += n_players
            recent_cooperation_rate = total_recent_cooperators / total_recent_decisions if total_recent_decisions > 0 else 0
            if recent_cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        my_last_cooperation = 1 if history.my_actions[last_round_idx] else 0
        opponent_cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        total_cooperators_last_round = my_last_cooperation + opponent_cooperators_last_round
        cooperation_rate = total_cooperators_last_round / n_players
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.4:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_11(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperation while being resilient to 
    occasional defections. It uses majority-based reciprocity with limited punishment
    and forgiveness mechanisms to maximize collective welfare.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_strikes = 0
        self.max_strikes = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            total_cooperators = 0
            for round_idx in range(history.round_number):
                if history.my_actions[round_idx]:
                    total_cooperators += 1
                total_cooperators += sum(history.opponent_actions[round_idx])
            total_possible_cooperators = n * (r - 1)
            average_cooperation_rate = total_cooperators / total_possible_cooperators
            if average_cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        cooperation_threshold = n / 2
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        if self.defection_strikes > 0:
            self.defection_strikes -= 1
            return Action.D
        if cooperators_last_round >= cooperation_threshold:
            return Action.C
        else:
            self.defection_strikes = self.max_strikes
            return Action.D

class Strategy_COOPERATIVE_12(BaseStrategy):
    """
    Forgiving Majority Follower: A cooperative strategy that follows majority behavior
    while being forgiving of occasional defections and protecting against exploitation.
    
    - Round 1: Always cooperate to signal good faith
    - Middle rounds: Follow majority (≥50% cooperation) with forgiveness for upward trends
    - Final round: Cooperate if overall cooperation rate ≥40%, else defect
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            total_cooperations = 0
            total_possible = 0
            for round_idx in range(history.round_number):
                if history.my_actions[round_idx]:
                    total_cooperations += 1
                total_possible += 1
                total_cooperations += sum(history.opponent_actions[round_idx])
                total_possible += len(history.opponent_actions[round_idx])
            overall_cooperation_rate = total_cooperations / total_possible if total_possible > 0 else 0
            if overall_cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / n_players
        if cooperation_rate >= 0.5:
            return Action.C
        elif history.round_number >= 2:
            two_rounds_ago_idx = history.round_number - 2
            cooperators_two_rounds_ago = sum(history.opponent_actions[two_rounds_ago_idx])
            if history.my_actions[two_rounds_ago_idx]:
                cooperators_two_rounds_ago += 1
            prev_cooperation_rate = cooperators_two_rounds_ago / n_players
            if cooperation_rate > prev_cooperation_rate:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_13(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness: A cooperative strategy that starts with cooperation,
    responds to the majority behavior of other players with forgiveness mechanisms, and maintains
    cooperation even in the final round to avoid defection cascades.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.C
        previous_round_idx = history.round_number - 1
        other_players_cooperated = history.opponent_actions[previous_round_idx]
        cooperation_count = sum(other_players_cooperated)
        total_others = len(other_players_cooperated)
        cooperation_ratio = cooperation_count / total_others if total_others > 0 else 0
        if cooperation_ratio >= 0.5:
            return Action.C
        elif cooperation_ratio >= 0.3:
            return Action.C if random.random() < 0.7 else Action.D
        elif cooperation_ratio >= 0.1:
            return Action.C if random.random() < 0.4 else Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_14(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Cooperates in first round, then bases decisions on group cooperation rate from
    previous round with majority threshold and probabilistic forgiveness mechanism.
    Adapts thresholds for early and final rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.1
        self.early_threshold = 0.4
        self.early_forgiveness = 0.15
        self.final_threshold = 0.3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / n
        if current_round == self.game_description.n_rounds:
            if cooperation_rate >= self.final_threshold:
                return Action.C
            else:
                return Action.D
        if current_round <= 3:
            threshold = self.early_threshold
            forgiveness = self.early_forgiveness
        else:
            threshold = self.cooperation_threshold
            forgiveness = self.forgiveness_probability
            if history.round_number >= 3:
                recent_rates = []
                for i in range(min(3, history.round_number)):
                    round_idx = history.round_number - 1 - i
                    round_cooperators = sum(history.opponent_actions[round_idx])
                    if history.my_actions[round_idx]:
                        round_cooperators += 1
                    recent_rates.append(round_cooperators / n)
                if len(recent_rates) >= 3:
                    declining = all((recent_rates[i] >= recent_rates[i + 1] for i in range(len(recent_rates) - 1)))
                    if declining and recent_rates[-1] < recent_rates[0]:
                        forgiveness = 0.05
        if cooperation_rate >= threshold:
            return Action.C
        elif random.random() < forgiveness:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_15(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Uses majority-based threshold system with 15% forgiveness probability to balance
    cooperation with protection against exploitation. Always cooperates in first round,
    then cooperates if at least half the players cooperated last round, with occasional
    forgiveness to break punishment cycles.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = math.ceil(game_description.n_players / 2)
        self.forgiveness_probability = 0.15

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return self._final_round_decision(history)
        return self._adaptive_response(history)

    def _adaptive_response(self, history: PlayerHistory) -> Action:
        last_round_index = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_index])
        if history.my_actions[last_round_index]:
            cooperators_last_round += 1
        if cooperators_last_round >= self.cooperation_threshold:
            return Action.C
        elif random.random() < self.forgiveness_probability:
            return Action.C
        else:
            return Action.D

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        rounds_to_check = min(3, history.round_number)
        total_possible_cooperators = rounds_to_check * self.game_description.n_players
        total_cooperators = 0
        for i in range(rounds_to_check):
            round_index = history.round_number - 1 - i
            total_cooperators += sum(history.opponent_actions[round_index])
            if history.my_actions[round_index]:
                total_cooperators += 1
        recent_cooperation_rate = total_cooperators / total_possible_cooperators
        if recent_cooperation_rate >= 0.4:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_16(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperative equilibrium while being
    resilient to occasional defections. It uses graduated responses, forgiveness
    mechanisms, and punishment phases to balance cooperation with self-protection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.in_punishment_phase = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.in_punishment_phase = False
            return Action.C
        round_number = history.round_number + 1
        prev_round_idx = history.round_number - 1
        others_cooperated = sum(history.opponent_actions[prev_round_idx])
        others_cooperation_rate = others_cooperated / (self.game_description.n_players - 1)
        if round_number == self.game_description.n_rounds:
            if others_cooperation_rate >= 0.75:
                return Action.C
            else:
                return Action.D
        if self.in_punishment_phase:
            if others_cooperation_rate > 0.5:
                self.in_punishment_phase = False
                return Action.C
            else:
                return Action.D
        if round_number >= 3 and (not self.in_punishment_phase):
            if self._check_consecutive_low_cooperation(history):
                self.in_punishment_phase = True
                return Action.D
        if others_cooperation_rate >= 0.5:
            return Action.C
        elif others_cooperation_rate >= 0.25:
            if random.random() < 0.2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _check_consecutive_low_cooperation(self, history: PlayerHistory) -> bool:
        """Check if cooperation rate was < 25% for the last 2 rounds."""
        if history.round_number < 2:
            return False
        for i in range(2):
            round_idx = history.round_number - 1 - i
            others_cooperated = sum(history.opponent_actions[round_idx])
            others_cooperation_rate = others_cooperated / (self.game_description.n_players - 1)
            if others_cooperation_rate >= 0.25:
                return False
        return True

class Strategy_COOPERATIVE_17(BaseStrategy):
    """
    Generous Tit-for-Tat with Collective Assessment strategy.
    
    Starts cooperatively, then bases decisions on recent group cooperation rates
    with a forgiveness zone to help restart cooperation when it breaks down.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            cooperation_rate = self._get_cooperation_rate(history, window_size=3)
            return Action.C if cooperation_rate >= 0.4 else Action.D
        cooperation_rate = self._get_cooperation_rate(history, window_size=3)
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.D

    def _get_cooperation_rate(self, history: PlayerHistory, window_size: int) -> float:
        """Calculate cooperation rate over recent rounds."""
        completed_rounds = history.round_number
        if completed_rounds == 0:
            return 1.0
        window_start = max(0, completed_rounds - window_size)
        total_cooperators = 0
        total_decisions = 0
        for round_idx in range(window_start, completed_rounds):
            if history.my_actions[round_idx]:
                total_cooperators += 1
            total_decisions += 1
            for opponent_idx in range(len(history.opponent_actions[round_idx])):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_cooperators += 1
                total_decisions += 1
        return total_cooperators / total_decisions if total_decisions > 0 else 1.0

class Strategy_COOPERATIVE_18(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Cooperates in round 1, then uses majority cooperation threshold (≥50%) with forgiveness
    mechanisms for occasional defections. Includes final round conditional cooperation
    based on overall game cooperation rate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        prev_round_idx = history.round_number - 1
        prev_round_cooperators = sum(history.opponent_actions[prev_round_idx]) + int(history.my_actions[prev_round_idx])
        prev_coop_rate = prev_round_cooperators / n
        if round_num == r:
            total_cooperators = 0
            total_actions = 0
            for round_idx in range(history.round_number):
                round_cooperators = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
                total_cooperators += round_cooperators
                total_actions += n
            overall_coop_rate = total_cooperators / total_actions if total_actions > 0 else 0
            return Action.C if overall_coop_rate >= 0.4 else Action.D
        if prev_coop_rate >= 0.5:
            return Action.C
        if prev_coop_rate >= 0.33:
            return Action.C
        if round_num <= 4:
            return Action.C
        recent_low_coop_rounds = 0
        start_idx = max(0, history.round_number - 3)
        for round_idx in range(start_idx, history.round_number):
            round_cooperators = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
            round_coop_rate = round_cooperators / n
            if round_coop_rate < 0.5:
                recent_low_coop_rounds += 1
        if recent_low_coop_rounds <= 1:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_19(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for Public Goods Game.
    
    Starts cooperatively, then adapts based on cooperation rates:
    - High cooperation (≥50%): Full cooperation
    - Medium cooperation (30-49%): Probabilistic cooperation  
    - Low cooperation (<30%): Mostly defect with 20% forgiveness
    - Final round uses recent cooperation history for decision
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds:
            return self._final_round_decision(history, n_players)
        else:
            return self._adaptive_response(history, n_players)

    def _adaptive_response(self, history: PlayerHistory, n_players: int) -> Action:
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = int(my_last_action) + opponent_cooperators
        cooperation_rate = total_cooperators / n_players
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            cooperation_probability = 0.4 + cooperation_rate
            return Action.C if random.random() < cooperation_probability else Action.D
        elif cooperation_rate > 0:
            return Action.C if random.random() < 0.2 else Action.D
        else:
            return Action.D

    def _final_round_decision(self, history: PlayerHistory, n_players: int) -> Action:
        rounds_completed = history.round_number
        lookback_rounds = min(3, rounds_completed)
        if lookback_rounds == 0:
            return Action.C
        total_cooperation_sum = 0
        total_possible_cooperation = 0
        for i in range(lookback_rounds):
            round_idx = rounds_completed - 1 - i
            my_action = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            round_cooperators = int(my_action) + opponent_cooperators
            total_cooperation_sum += round_cooperators
            total_possible_cooperation += n_players
        recent_cooperation = total_cooperation_sum / total_possible_cooperation
        if recent_cooperation >= 0.6:
            return Action.C
        elif recent_cooperation >= 0.3:
            return Action.C if random.random() < 0.5 else Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_20(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Cooperates in round 1, then uses majority cooperation rule with forgiveness mechanism.
    Enters defensive mode if cooperation rate stays below 30% for 2+ consecutive rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_low_cooperation = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / n_players
        if cooperation_rate < 0.3:
            self.consecutive_low_cooperation += 1
        else:
            self.consecutive_low_cooperation = 0
        if current_round == n_rounds:
            return Action.C if cooperation_rate >= 0.6 else Action.D
        if self.consecutive_low_cooperation >= 2:
            return Action.C if cooperation_rate >= 0.8 else Action.D
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            return Action.C if random.random() < cooperation_rate else Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_21(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) - A cooperative strategy that
    establishes cooperation, responds to group cooperation levels, includes forgiveness
    mechanisms, and protects against exploitation while maintaining generous thresholds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.1
        self.consecutive_defections = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_defections = 0
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.C
        last_round_index = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_index])
        if history.my_actions[last_round_index]:
            last_round_cooperators += 1
        cooperation_rate = last_round_cooperators / self.game_description.n_players
        if cooperation_rate >= self.cooperation_threshold:
            self.consecutive_defections = 0
            return Action.C
        elif cooperation_rate >= self.cooperation_threshold - 0.2:
            if random.random() < 0.7:
                self.consecutive_defections = 0
                return Action.C
            else:
                self.consecutive_defections += 1
                return Action.D
        elif self.consecutive_defections >= 2:
            if random.random() < self.forgiveness_probability:
                self.consecutive_defections = 0
                return Action.C
            else:
                self.consecutive_defections += 1
                return Action.D
        else:
            self.consecutive_defections += 1
            return Action.D

class Strategy_COOPERATIVE_22(BaseStrategy):
    """
    Graduated Reciprocity with Forgiveness (GRF) strategy.
    Starts cooperative, responds proportionally to group cooperation levels,
    maintains forgiveness through moving averages, and protects against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            cooperation_rate_moving_avg = self._calculate_moving_average(history)
            if cooperation_rate_moving_avg >= 0.4:
                return Action.C
            else:
                return Action.D
        last_round_cooperation_rate = self._get_last_round_cooperation_rate(history)
        cooperation_rate_moving_avg = self._calculate_moving_average(history)
        personal_threshold = max(0.3, cooperation_rate_moving_avg * 0.8)
        if last_round_cooperation_rate >= personal_threshold:
            return Action.C
        else:
            defect_probability = 1.0 - last_round_cooperation_rate
            if random.random() < defect_probability:
                return Action.D
            else:
                return Action.C

    def _get_last_round_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate in the most recent round."""
        last_round_idx = history.round_number - 1
        my_cooperation = 1 if history.my_actions[last_round_idx] else 0
        opponent_cooperations = sum(history.opponent_actions[last_round_idx])
        total_cooperators = my_cooperation + opponent_cooperations
        return total_cooperators / self.n_players

    def _calculate_moving_average(self, history: PlayerHistory) -> float:
        """Calculate moving average of cooperation rates over last 3 rounds."""
        current_round_number = history.round_number
        lookback = min(3, current_round_number)
        cooperation_rates = []
        for i in range(lookback):
            round_idx = current_round_number - 1 - i
            my_cooperation = 1 if history.my_actions[round_idx] else 0
            opponent_cooperations = sum(history.opponent_actions[round_idx])
            total_cooperators = my_cooperation + opponent_cooperations
            cooperation_rate = total_cooperators / self.n_players
            cooperation_rates.append(cooperation_rate)
        return sum(cooperation_rates) / len(cooperation_rates)

class Strategy_COOPERATIVE_23(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Starts cooperatively, adapts based on group cooperation rates, includes forgiveness
    mechanism to restart cooperation, and uses conditional cooperation in final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            overall_coop_rate = self._calculate_historical_cooperation_rate(history)
            if overall_coop_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        last_round_coop_rate = self._get_last_round_cooperation_rate(history)
        if last_round_coop_rate >= 0.5:
            return Action.C
        elif last_round_coop_rate >= 0.3:
            if random.random() < 0.7:
                return Action.C
            else:
                return Action.D
        else:
            consecutive_low_coop = self._count_consecutive_low_cooperation(history)
            if consecutive_low_coop >= 3 and consecutive_low_coop % 3 == 0:
                return Action.C
            else:
                return Action.D

    def _get_last_round_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate from the most recent round."""
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = 1 if history.my_actions[last_round_idx] else 0
        total_cooperators = opponent_cooperators + my_last_action
        return total_cooperators / self.n_players

    def _calculate_historical_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate overall cooperation rate across all completed rounds."""
        total_cooperations = 0
        total_decisions = 0
        for round_idx in range(history.round_number):
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            my_action = 1 if history.my_actions[round_idx] else 0
            total_cooperations += opponent_cooperators + my_action
            total_decisions += self.n_players
        return total_cooperations / total_decisions if total_decisions > 0 else 0.0

    def _count_consecutive_low_cooperation(self, history: PlayerHistory) -> int:
        """Count consecutive rounds from the end where cooperation rate was below 0.3."""
        consecutive_count = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            my_action = 1 if history.my_actions[round_idx] else 0
            total_cooperators = opponent_cooperators + my_action
            cooperation_rate = total_cooperators / self.n_players
            if cooperation_rate < 0.3:
                consecutive_count += 1
            else:
                break
        return consecutive_count

class Strategy_COOPERATIVE_24(BaseStrategy):
    """
    Forgiving Majority Trigger Strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperative equilibria while being resilient 
    to occasional defections. It uses majority-based response with forgiveness mechanisms
    to balance cooperation with protection against exploitation.
    
    Key features:
    - Always cooperates in round 1 to establish cooperative norm
    - Uses 50% cooperation threshold as primary benchmark
    - Forgives temporary drops in cooperation for up to 2 consecutive rounds
    - Applies different thresholds for endgame decisions
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        cooperation_rate = last_round_cooperators / self.n_players
        if current_round == self.n_rounds:
            if history.round_number >= 3:
                recent_cooperators = 0
                for i in range(max(0, history.round_number - 3), history.round_number):
                    round_cooperators = sum(history.opponent_actions[i])
                    if history.my_actions[i]:
                        round_cooperators += 1
                    recent_cooperators += round_cooperators
                recent_cooperation_rate = recent_cooperators / (min(3, history.round_number) * self.n_players)
                return Action.C if recent_cooperation_rate >= 0.4 else Action.D
            else:
                return Action.C if cooperation_rate >= 0.4 else Action.D
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            consecutive_low = self._count_consecutive_below_threshold(history, 0.5)
            return Action.C if consecutive_low <= 2 else Action.D
        else:
            return Action.D

    def _count_consecutive_below_threshold(self, history: PlayerHistory, threshold: float) -> int:
        """Count consecutive rounds from the end where cooperation rate was below threshold."""
        count = 0
        for i in range(history.round_number - 1, -1, -1):
            round_cooperators = sum(history.opponent_actions[i])
            if history.my_actions[i]:
                round_cooperators += 1
            cooperation_rate = round_cooperators / self.n_players
            if cooperation_rate < threshold:
                count += 1
            else:
                break
        return count

class Strategy_COOPERATIVE_25(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for Public Goods Game.
    
    Starts cooperatively, adapts based on community cooperation rates with forgiveness mechanisms,
    and includes protection against exploitation while maintaining cooperative potential.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.exploitation_threshold = 0.3
        self.forgiveness_threshold = 0.4

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            recent_cooperation_rate = self._calculate_recent_cooperation_rate(history, min(3, history.round_number))
            if recent_cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        window_size = min(3, history.round_number)
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history, window_size)
        if recent_cooperation_rate >= self.cooperation_threshold:
            return Action.C
        my_last_action = history.my_actions[-1]
        if not my_last_action:
            last_round_others_coop_rate = self._calculate_others_cooperation_rate_last_round(history)
            if last_round_others_coop_rate >= self.forgiveness_threshold:
                return Action.C
        if my_last_action:
            last_round_others_coop_rate = self._calculate_others_cooperation_rate_last_round(history)
            if last_round_others_coop_rate < self.exploitation_threshold:
                return Action.D
        return Action.C

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, window_size: int) -> float:
        """Calculate cooperation rate over the recent window for all players including self."""
        if window_size <= 0:
            return 0.0
        n = self.game_description.n_players
        total_rounds_in_window = min(window_size, history.round_number)
        if total_rounds_in_window == 0:
            return 0.0
        start_idx = max(0, history.round_number - window_size)
        my_cooperations = sum(history.my_actions[start_idx:])
        opponent_cooperations = 0
        for round_idx in range(start_idx, history.round_number):
            opponent_cooperations += sum(history.opponent_actions[round_idx])
        total_cooperations = my_cooperations + opponent_cooperations
        total_possible = n * total_rounds_in_window
        return total_cooperations / total_possible if total_possible > 0 else 0.0

    def _calculate_others_cooperation_rate_last_round(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate of other players in the most recent round."""
        if history.round_number == 0:
            return 0.0
        last_round_idx = history.round_number - 1
        others_cooperations = sum(history.opponent_actions[last_round_idx])
        n_opponents = self.game_description.n_players - 1
        return others_cooperations / n_opponents if n_opponents > 0 else 0.0

class Strategy_COOPERATIVE_26(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) strategy for N-Player Public Goods Game.
    
    This strategy balances cooperation with self-protection by being generous initially,
    responsive to group behavior, and forgiving of occasional defections. It aims to
    foster cooperative equilibria while defending against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        last_round_opponents = history.opponent_actions[round_number - 1]
        cooperators_last_round = sum(last_round_opponents)
        my_last_action = history.my_actions[round_number - 1]
        total_cooperators = cooperators_last_round + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / n_players
        if round_number == n_rounds - 1:
            if cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            if my_last_action:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate == 0:
            return Action.D
        elif (round_number + 1) % 3 == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_27(BaseStrategy):
    """
    Graduated Tit-for-Tat with Forgiveness (GTTF)
    
    Balances cooperation with protection against exploitation using graduated responses
    and strategic forgiveness. Starts cooperatively, responds with threshold-based
    punishment/reward, includes forgiveness mechanisms, and protects against end-game defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds:
            recent_rounds = min(3, history.round_number)
            total_recent_cooperation = 0
            total_recent_decisions = 0
            for i in range(recent_rounds):
                round_idx = history.round_number - 1 - i
                cooperators_in_round = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
                total_recent_cooperation += cooperators_in_round
                total_recent_decisions += n_players
            recent_cooperation_rate = total_recent_cooperation / total_recent_decisions if total_recent_decisions > 0 else 0
            if recent_cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        else:
            last_round_idx = history.round_number - 1
            cooperators_last_round = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
            cooperation_rate = cooperators_last_round / n_players
            if cooperation_rate >= 0.5:
                return Action.C
            elif cooperation_rate >= 0.3:
                my_last_action = history.my_actions[last_round_idx]
                if my_last_action:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_28(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) strategy.
    
    Starts cooperatively, reciprocates group behavior with tolerance for defection,
    includes forgiveness mechanism to prevent permanent defection spirals,
    and cooperates in endgame rounds to maximize final welfare.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.1
        self.endgame_rounds = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round > total_rounds - self.endgame_rounds:
            return Action.C
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = int(my_last_action) + opponent_cooperators
        cooperation_rate = total_cooperators / n_players
        if cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif random.random() < self.forgiveness_probability:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_29(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness: A cooperative strategy that starts by cooperating,
    then maintains cooperation based on group cooperation rates with forgiveness mechanisms
    and rewards for sustained high cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_prev_action else 0)
        prev_coop_rate = total_cooperators / n
        if current_round == r:
            if prev_coop_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        else:
            if current_round >= 3:
                prev2_round_idx = history.round_number - 2
                my_prev2_action = history.my_actions[prev2_round_idx]
                opponent_cooperators_prev2 = sum(history.opponent_actions[prev2_round_idx])
                total_cooperators_prev2 = opponent_cooperators_prev2 + (1 if my_prev2_action else 0)
                prev2_coop_rate = total_cooperators_prev2 / n
                if prev_coop_rate >= 0.7 and prev2_coop_rate >= 0.7:
                    return Action.C
            if prev_coop_rate >= 0.5:
                return Action.C
            elif random.random() < 0.2:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_30(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for Public Goods Game.
    
    This strategy balances cooperation with protection against exploitation by:
    - Starting cooperatively 
    - Reciprocating based on group cooperation rates
    - Including forgiveness mechanisms to recover from defection spirals
    - Using graduated responses rather than binary punishment
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / n_players
        if current_round == n_rounds:
            rounds_to_check = min(3, history.round_number)
            total_cooperators = 0
            total_player_rounds = 0
            for round_idx in range(history.round_number - rounds_to_check, history.round_number):
                round_cooperators = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                total_cooperators += round_cooperators
                total_player_rounds += n_players
            recent_cooperation_rate = total_cooperators / total_player_rounds
            return Action.C if recent_cooperation_rate >= 0.4 else Action.D
        if current_round % 3 == 0:
            rounds_to_check = min(2, history.round_number)
            if rounds_to_check > 0:
                total_cooperators = 0
                total_player_rounds = 0
                for round_idx in range(history.round_number - rounds_to_check, history.round_number):
                    round_cooperators = sum(history.opponent_actions[round_idx])
                    if history.my_actions[round_idx]:
                        round_cooperators += 1
                    total_cooperators += round_cooperators
                    total_player_rounds += n_players
                if total_cooperators / total_player_rounds < 0.3:
                    return Action.C
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_31(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Cooperates in round 1, then cooperates if majority cooperated in previous round.
    Includes forgiveness mechanisms: cooperates even after majority defection if it's
    the first time or if cooperation rate >= 40%. Only defects after persistent
    group defection (2+ consecutive rounds with majority defecting and <40% cooperation).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        round_number = history.round_number + 1
        previous_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[previous_round_idx]) + int(history.my_actions[previous_round_idx])
        cooperation_rate = cooperators_last_round / n
        majority_cooperated = cooperation_rate > 0.5
        if round_number == r:
            return Action.C if cooperation_rate >= 1 / 3 else Action.D
        if majority_cooperated:
            return Action.C
        if round_number == 2:
            return Action.C
        if history.round_number >= 2:
            prev_prev_round_idx = history.round_number - 2
            cooperators_prev_prev = sum(history.opponent_actions[prev_prev_round_idx]) + int(history.my_actions[prev_prev_round_idx])
            prev_prev_cooperation_rate = cooperators_prev_prev / n
            majority_cooperated_prev_prev = prev_prev_cooperation_rate > 0.5
            majority_defected_twice = not majority_cooperated_prev_prev and (not majority_cooperated)
        else:
            majority_defected_twice = False
        if not majority_defected_twice or cooperation_rate >= 0.4:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_32(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) strategy.
    
    Starts cooperatively and maintains cooperation based on group cooperation rates.
    Uses graduated forgiveness and punishment mechanisms to balance cooperation
    with protection against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_low_coop_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_low_coop_rounds = 0
            return Action.C
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / self.game_description.n_players
        if current_round == self.game_description.n_rounds:
            if cooperation_rate >= 0.7:
                return Action.C
            else:
                return Action.D
        if self.consecutive_low_coop_rounds >= 2:
            self.consecutive_low_coop_rounds = 0
            return Action.D
        if cooperation_rate >= 0.5:
            self.consecutive_low_coop_rounds = 0
            return Action.C
        elif cooperation_rate >= 0.3:
            self.consecutive_low_coop_rounds += 1
            if random.random() < 0.7:
                return Action.C
            else:
                return Action.D
        else:
            self.consecutive_low_coop_rounds += 1
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_33(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for Public Goods Game.
    
    This strategy aims to establish cooperation while being resilient to defections.
    It cooperates in round 1, then uses conditional cooperation based on group
    behavior with a forgiveness mechanism for low-cooperation rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_count = 0
        self.max_forgiveness = 2
        if game_description.n_players <= 3:
            self.cooperation_threshold = 0.4
        else:
            self.cooperation_threshold = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.forgiveness_count = 0
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            total_cooperations = 0
            total_possible = 0
            for round_idx in range(history.round_number):
                round_cooperations = int(history.my_actions[round_idx])
                round_cooperations += sum(history.opponent_actions[round_idx])
                total_cooperations += round_cooperations
                total_possible += self.game_description.n_players
            overall_cooperation_rate = total_cooperations / total_possible if total_possible > 0 else 0
            return Action.C if overall_cooperation_rate >= 0.6 else Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        cooperation_rate_last_round = last_round_cooperators / self.game_description.n_players
        if cooperation_rate_last_round >= self.cooperation_threshold:
            self.forgiveness_count = 0
            return Action.C
        elif self.forgiveness_count < self.max_forgiveness:
            self.forgiveness_count += 1
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_34(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperation while being resilient to 
    occasional defections. It uses threshold-based responses, includes forgiveness 
    mechanisms, and adapts to the cooperation environment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds:
            total_cooperations = 0
            total_decisions = 0
            for round_idx in range(history.round_number):
                if history.my_actions[round_idx]:
                    total_cooperations += 1
                total_cooperations += sum(history.opponent_actions[round_idx])
                total_decisions += n_players
            avg_cooperation_rate = total_cooperations / total_decisions if total_decisions > 0 else 0
            if avg_cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / n_players
        if cooperation_rate >= 0.6:
            return Action.C
        elif cooperation_rate >= 0.4:
            my_last_action_was_cooperate = history.my_actions[last_round_idx]
            opponent_cooperators_last_round = sum(history.opponent_actions[last_round_idx])
            total_cooperators_last_round = opponent_cooperators_last_round
            if my_last_action_was_cooperate:
                total_cooperators_last_round += 1
            i_was_minority_cooperator = my_last_action_was_cooperate and total_cooperators_last_round <= n_players / 2
            if my_last_action_was_cooperate and i_was_minority_cooperator:
                return Action.D
            else:
                return Action.C
        elif cooperation_rate >= 0.2:
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_35(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Starts cooperative, adapts based on group cooperation rates with graduated responses,
    includes forgiveness mechanism, and has end-game protection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            if history.round_number >= 3:
                last_3_rounds = min(3, history.round_number)
                total_cooperators = 0
                for i in range(last_3_rounds):
                    round_idx = history.round_number - 1 - i
                    my_action = 1 if history.my_actions[round_idx] else 0
                    opponent_cooperators = sum(history.opponent_actions[round_idx])
                    total_cooperators += my_action + opponent_cooperators
                recent_cooperation_rate = total_cooperators / (last_3_rounds * n)
                if recent_cooperation_rate >= 0.4:
                    return Action.C
                else:
                    return Action.D
            else:
                last_round_idx = history.round_number - 1
                my_action = 1 if history.my_actions[last_round_idx] else 0
                opponent_cooperators = sum(history.opponent_actions[last_round_idx])
                cooperation_rate = (my_action + opponent_cooperators) / n
                if cooperation_rate >= 0.4:
                    return Action.C
                else:
                    return Action.D
        else:
            last_round_idx = history.round_number - 1
            opponent_cooperators = sum(history.opponent_actions[last_round_idx])
            cooperation_rate = opponent_cooperators / (n - 1)
            if cooperation_rate >= 0.5:
                return Action.C
            elif cooperation_rate >= 0.3:
                if random.random() < 0.7:
                    return Action.C
                else:
                    return Action.D
            elif random.random() < 0.2:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_36(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) strategy.
    
    Starts cooperatively, reciprocates group behavior with a 50% cooperation threshold,
    includes 10% forgiveness probability to recover from defection spirals, and uses
    recent history for endgame decisions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.1
        self.recent_history_window = 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds:
            window_size = min(self.recent_history_window, history.round_number)
            total_cooperation = 0
            for i in range(max(0, history.round_number - window_size), history.round_number):
                round_cooperators = sum(history.opponent_actions[i]) + (1 if history.my_actions[i] else 0)
                total_cooperation += round_cooperators
            recent_cooperation_rate = total_cooperation / (window_size * n_players)
            if recent_cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        else:
            last_round_idx = history.round_number - 1
            last_round_cooperators = sum(history.opponent_actions[last_round_idx]) + (1 if history.my_actions[last_round_idx] else 0)
            last_round_cooperation_rate = last_round_cooperators / n_players
            if last_round_cooperation_rate >= self.cooperation_threshold:
                return Action.C
            elif random.random() < self.forgiveness_probability:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_37(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) strategy.
    
    Starts cooperatively, then uses adaptive reciprocity based on group cooperation rates.
    Includes forgiveness mechanism and conditional final round cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx])
        if history.my_actions[prev_round_idx]:
            prev_cooperators += 1
        cooperation_rate = prev_cooperators / n
        if round_num == r:
            total_cooperators = 0
            total_actions = 0
            for round_idx in range(history.round_number):
                round_cooperators = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                total_cooperators += round_cooperators
                total_actions += n
            avg_cooperation = total_cooperators / total_actions
            return Action.C if avg_cooperation >= 0.6 else Action.D
        if self._should_forgive(history, cooperation_rate):
            return Action.C
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.D

    def _should_forgive(self, history: PlayerHistory, current_cooperation_rate: float) -> bool:
        """Check if forgiveness mechanism should trigger."""
        if history.round_number < 2:
            return False
        consecutive_defections = 0
        for i in range(history.round_number - 1, -1, -1):
            if not history.my_actions[i]:
                consecutive_defections += 1
            else:
                break
        if consecutive_defections < 2:
            return False
        if history.round_number < 2:
            return False
        prev_prev_round_idx = history.round_number - 2
        prev_prev_cooperators = sum(history.opponent_actions[prev_prev_round_idx])
        if history.my_actions[prev_prev_round_idx]:
            prev_prev_cooperators += 1
        prev_prev_cooperation_rate = prev_prev_cooperators / self.game_description.n_players
        return current_cooperation_rate - prev_prev_cooperation_rate >= 0.2

class Strategy_COOPERATIVE_38(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTF) Strategy
    
    A cooperative strategy that starts by cooperating, then reciprocates based on the 
    cooperation rate of all players in the previous round. Includes forgiveness 
    mechanism to restart cooperation and endgame protection against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.4
        self.forgiveness_probability = 0.2
        self.endgame_rounds = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        previous_round_index = history.round_number - 1
        previous_round_actions = history.opponent_actions[previous_round_index]
        cooperators_last_round = sum(previous_round_actions)
        if history.my_actions[previous_round_index]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / self.game_description.n_players
        if history.round_number >= self.game_description.n_rounds - self.endgame_rounds:
            if cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif random.random() < self.forgiveness_probability:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_39(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) strategy for N-Player Public Goods Game.
    
    This strategy promotes cooperation while being robust against exploitation. It starts cooperatively,
    reciprocates the group's behavior based on majority cooperation, and includes forgiveness mechanisms
    to recover from mutual defection spirals.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.1
        self.recent_window = min(3, max(1, game_description.n_rounds // 4))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            recent_cooperation_rate = self._calculate_recent_cooperation_rate(history)
            if recent_cooperation_rate >= self.cooperation_threshold:
                return Action.C
            else:
                return Action.D
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history)
        if recent_cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif random.random() < self.forgiveness_probability:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate among opponents in recent rounds."""
        rounds_completed = history.round_number
        recent_rounds = min(self.recent_window, rounds_completed)
        if recent_rounds == 0:
            return 1.0
        total_cooperators = 0
        for round_idx in range(rounds_completed - recent_rounds, rounds_completed):
            total_cooperators += np.sum(history.opponent_actions[round_idx])
        n_opponents = self.game_description.n_players - 1
        return total_cooperators / (recent_rounds * n_opponents) if n_opponents > 0 else 1.0

class Strategy_COOPERATIVE_40(BaseStrategy):
    """
    Forgiving Tit-for-Tat with Majority Threshold Strategy.
    
    Cooperates in first round, then follows majority behavior from previous round.
    Includes forgiveness mechanism to escape defection spirals and maintains
    cooperation in final round if group was cooperative.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        majority_threshold = n / 2.0
        if current_round == r:
            return Action.C if total_cooperators >= majority_threshold else Action.D
        if total_cooperators >= majority_threshold:
            return Action.C
        else:
            consecutive_defections = self._count_consecutive_defections(history, n)
            if consecutive_defections >= 2 and random.random() < 0.3:
                return Action.C
            else:
                return Action.D

    def _count_consecutive_defections(self, history: PlayerHistory, n: int) -> int:
        """Count consecutive rounds where I was in the defecting minority."""
        consecutive = 0
        majority_threshold = n / 2.0
        for round_idx in range(history.round_number - 1, -1, -1):
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            my_action = history.my_actions[round_idx]
            total_cooperators = opponent_cooperators + (1 if my_action else 0)
            if not my_action and total_cooperators < majority_threshold:
                consecutive += 1
            else:
                break
        return consecutive

class Strategy_COOPERATIVE_41(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Starts cooperatively, then cooperates based on majority cooperation in previous round,
    with forgiveness mechanisms to rebuild trust and protection against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = int(my_last_action) + opponent_cooperators
        previous_coop_rate = total_cooperators / n_players
        just_defected_last_round = not my_last_action
        if current_round == n_rounds:
            if history.round_number >= 2:
                second_last_idx = history.round_number - 2
                last_coop_rate = previous_coop_rate
                my_second_last = history.my_actions[second_last_idx]
                opponent_second_last = sum(history.opponent_actions[second_last_idx])
                second_last_cooperators = int(my_second_last) + opponent_second_last
                second_last_coop_rate = second_last_cooperators / n_players
                if last_coop_rate >= 0.5 and second_last_coop_rate >= 0.5:
                    return Action.C
                else:
                    return Action.D
            elif previous_coop_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if previous_coop_rate >= 0.5:
            return Action.C
        if just_defected_last_round and previous_coop_rate >= 0.33:
            return Action.C
        elif previous_coop_rate >= 0.33:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_42(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Starts cooperatively, then cooperates if previous round had ≥50% cooperation,
    otherwise cooperates with 20% probability (forgiveness). Final round mirrors
    the majority from previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        previous_round_idx = history.round_number - 1
        my_previous_action = history.my_actions[previous_round_idx]
        opponent_cooperators = sum(history.opponent_actions[previous_round_idx])
        total_cooperators = int(my_previous_action) + opponent_cooperators
        cooperation_rate = total_cooperators / self.game_description.n_players
        if current_round == self.game_description.n_rounds:
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.5:
            return Action.C
        elif random.random() < 0.2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_43(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Forgiveness (ATTF) Strategy
    
    Starts cooperatively, responds to group behavior with majority thresholds,
    incorporates forgiveness to break defection cycles, and adapts behavior
    based on game phase (early/middle/final rounds).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return self._final_round_decision(history)
        return self._adaptive_response(history, current_round)

    def _adaptive_response(self, history: PlayerHistory, current_round: int) -> Action:
        if current_round <= 3:
            cooperation_threshold = max(1, self.n_players // 3)
            forgiveness_probability = 0.25
        else:
            cooperation_threshold = self.n_players // 2
            forgiveness_probability = 0.15
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        if cooperators_last_round >= cooperation_threshold:
            return Action.C
        elif random.random() < forgiveness_probability:
            return Action.C
        else:
            return Action.D

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        rounds_to_check = min(3, history.round_number)
        start_idx = history.round_number - rounds_to_check
        total_cooperation_instances = 0
        total_possible_instances = 0
        for round_idx in range(start_idx, history.round_number):
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            total_cooperation_instances += opponent_cooperators
            total_possible_instances += len(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                total_cooperation_instances += 1
            total_possible_instances += 1
        recent_cooperation_rate = total_cooperation_instances / total_possible_instances if total_possible_instances > 0 else 0
        if recent_cooperation_rate >= 0.4:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_44(BaseStrategy):
    """
    Generous Tit-for-Tat with Majority Threshold strategy.
    
    Cooperates in first and last rounds. In middle rounds, uses a three-tier
    response system based on cooperation rates: cooperates if ≥50% cooperated,
    cooperates with 70% probability if 25-50% cooperated, defects if <25% cooperated.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.C
        previous_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[previous_round_idx])
        my_previous_action = history.my_actions[previous_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_previous_action else 0)
        cooperation_rate = total_cooperators / self.game_description.n_players
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.25:
            if random.random() < 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_45(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy starts cooperatively and maintains cooperation when the majority
    cooperates. It uses graduated responses to declining cooperation rates with
    a forgiveness mechanism to repair relationships and prevent permanent breakdowns.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = last_round_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / self.game_description.n_players
        if history.round_number + 1 == self.game_description.n_rounds:
            return Action.C if cooperation_rate >= 0.5 else Action.D
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            if my_last_action:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_46(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) strategy.
    
    Starts cooperatively, reciprocates group behavior with generous thresholds,
    includes forgiveness mechanisms to break defection spirals, and protects
    against systematic exploitation while maintaining openness to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_threshold = 0.15

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        my_last_action = 1 if history.my_actions[last_round_idx] else 0
        opponents_last_actions = history.opponent_actions[last_round_idx]
        opponent_cooperators = sum(opponents_last_actions)
        total_cooperators = my_last_action + opponent_cooperators
        cooperation_rate = total_cooperators / n_players
        if round_num == n_rounds:
            return Action.C if cooperation_rate >= 0.4 else Action.D
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.C if random.random() < self.forgiveness_threshold else Action.D

class Strategy_COOPERATIVE_47(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) Strategy.
    
    A cooperative strategy that starts by cooperating and maintains cooperation
    when reciprocated by the majority. Includes forgiveness mechanisms to recover
    from mutual defection spirals and end-game protection against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.6
        self.majority_threshold = 0.5
        self.forgiveness_probability = 0.1
        self.endgame_protection = 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        rounds_remaining = self.game_description.n_rounds - current_round + 1
        memory_window = min(5, history.round_number)
        n_opponents = self.game_description.n_players - 1
        cooperative_players = 0
        for opponent_idx in range(n_opponents):
            start_idx = max(0, history.round_number - memory_window)
            recent_actions = history.opponent_actions[start_idx:history.round_number, opponent_idx]
            cooperation_rate = np.mean(recent_actions)
            if cooperation_rate >= self.cooperation_threshold:
                cooperative_players += 1
        any_player_defected_recently = False
        if rounds_remaining <= self.endgame_protection and history.round_number > 0:
            last_round_actions = history.opponent_actions[history.round_number - 1]
            any_player_defected_recently = not np.all(last_round_actions)
        if rounds_remaining <= self.endgame_protection and any_player_defected_recently:
            if cooperative_players / n_opponents >= 0.8:
                return Action.C
            else:
                return Action.D
        elif cooperative_players / n_opponents >= self.majority_threshold:
            return Action.C
        else:
            if history.round_number > 0:
                last_round_actions = history.opponent_actions[history.round_number - 1]
                all_defected_last_round = not np.any(last_round_actions)
                if all_defected_last_round:
                    if random.random() < self.forgiveness_probability:
                        return Action.C
            return Action.D

class Strategy_COOPERATIVE_48(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness: A cooperative strategy that starts with cooperation,
    maintains cooperation when majority cooperates, includes forgiveness mechanism to prevent
    defection spirals, and protects against end-game defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            recent_rounds = min(3, history.round_number)
            total_cooperation_rate = 0
            for i in range(recent_rounds):
                round_idx = history.round_number - 1 - i
                my_cooperation = 1 if history.my_actions[round_idx] else 0
                opponent_cooperation = sum(history.opponent_actions[round_idx])
                total_cooperators = my_cooperation + opponent_cooperation
                cooperation_rate = total_cooperators / self.game_description.n_players
                total_cooperation_rate += cooperation_rate
            average_cooperation = total_cooperation_rate / recent_rounds
            if average_cooperation >= 0.6:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        my_last_cooperation = 1 if history.my_actions[last_round_idx] else 0
        opponent_last_cooperation = sum(history.opponent_actions[last_round_idx])
        total_cooperators = my_last_cooperation + opponent_last_cooperation
        cooperation_rate = total_cooperators / self.game_description.n_players
        if cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif random.random() < self.forgiveness_probability:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_49(BaseStrategy):
    """
    Generous Tit-for-Tat with Graduated Reciprocation strategy.
    
    Always cooperates in round 1, then uses adaptive reciprocation based on
    the group's cooperation rate from the previous round. Uses graduated
    responses with forgiveness mechanisms to encourage group cooperation
    while protecting against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return self._final_round_decision(history)
        return self._adaptive_reciprocation(history)

    def _adaptive_reciprocation(self, history: PlayerHistory) -> Action:
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        cooperation_rate = last_round_cooperators / self.game_description.n_players
        if cooperation_rate >= 0.4:
            return Action.C
        elif cooperation_rate >= 0.2:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.C if random.random() < 0.3 else Action.D

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        total_rounds_so_far = history.round_number
        total_opponent_cooperations = 0
        total_my_cooperations = 0
        for round_idx in range(total_rounds_so_far):
            total_opponent_cooperations += sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                total_my_cooperations += 1
        total_possible_other_cooperations = total_rounds_so_far * (self.game_description.n_players - 1)
        if total_possible_other_cooperations > 0:
            overall_cooperation_rate = total_opponent_cooperations / total_possible_other_cooperations
        else:
            overall_cooperation_rate = 0.0
        if overall_cooperation_rate >= 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_50(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Cooperates in round 1, then uses majority cooperation rate (≥50%) as primary decision criterion.
    Includes forgiveness mechanism for up to 2 consecutive rounds of low cooperation and
    continues cooperating if cooperation rates are improving. Uses higher threshold (60%) 
    in final round to account for end-game defection incentives.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            cooperation_rate_last = self._calculate_cooperation_rate(history, history.round_number - 1)
            return Action.C if cooperation_rate_last >= 0.6 else Action.D
        cooperation_rate_last = self._calculate_cooperation_rate(history, history.round_number - 1)
        if cooperation_rate_last >= 0.5:
            return Action.C
        consecutive_low_coop = self._count_consecutive_low_cooperation(history, history.round_number - 1)
        if consecutive_low_coop <= 2:
            return Action.C
        if history.round_number >= 2:
            cooperation_rate_two_ago = self._calculate_cooperation_rate(history, history.round_number - 2)
            if cooperation_rate_last > cooperation_rate_two_ago:
                return Action.C
        return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, round_index: int) -> float:
        """Calculate cooperation rate for a specific round (0-indexed)."""
        if round_index < 0 or round_index >= history.round_number:
            return 0.0
        opponent_cooperators = sum(history.opponent_actions[round_index])
        my_action = history.my_actions[round_index]
        total_cooperators = opponent_cooperators + (1 if my_action else 0)
        total_players = self.game_description.n_players
        return total_cooperators / total_players

    def _count_consecutive_low_cooperation(self, history: PlayerHistory, current_round_index: int) -> int:
        """Count consecutive rounds of low cooperation (< 50%) ending at current_round_index."""
        count = 0
        for round_idx in range(current_round_index, -1, -1):
            cooperation_rate = self._calculate_cooperation_rate(history, round_idx)
            if cooperation_rate < 0.5:
                count += 1
            else:
                break
        return count

class Strategy_COOPERATIVE_51(BaseStrategy):
    """
    Graduated Reciprocal Cooperation (GRC) strategy.
    
    Balances cooperation with protection against exploitation through:
    - Starting cooperatively to signal prosocial intent
    - Responding proportionally to group cooperation levels
    - Forgiving temporarily to break defection spirals
    - Adapting thresholds based on cooperation trends
    - Protecting against endgame exploitation
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.4
        self.forgiveness_counter = 0
        self.last_round_coop_rate = 1.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = history.round_number + 1
        last_round_index = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_index])
        if history.my_actions[last_round_index]:
            cooperators_last_round += 1
        current_coop_rate = cooperators_last_round / n_players
        if current_round == n_rounds:
            if current_coop_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        if current_coop_rate >= self.cooperation_threshold:
            self.forgiveness_counter = 0
            self.last_round_coop_rate = current_coop_rate
            return Action.C
        elif self.forgiveness_counter < 2 and current_coop_rate >= 0.2:
            self.forgiveness_counter += 1
            self.last_round_coop_rate = current_coop_rate
            return Action.C
        elif current_coop_rate > self.last_round_coop_rate:
            self.forgiveness_counter = 0
            self.last_round_coop_rate = current_coop_rate
            return Action.C
        else:
            self.last_round_coop_rate = current_coop_rate
            return Action.D

class Strategy_COOPERATIVE_52(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) Strategy.
    
    Cooperates in round 1, then reciprocates based on community cooperation rate
    with forgiveness mechanism. Uses majority rule (50% threshold) for cooperation
    decision with 20% forgiveness probability when community defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            total_cooperators = cooperators_last_round + 1
        else:
            total_cooperators = cooperators_last_round
        cooperation_rate = total_cooperators / n_players
        if current_round == n_rounds:
            if cooperation_rate >= 0.7:
                return Action.C
            elif cooperation_rate < 0.3:
                return Action.D
            elif cooperation_rate >= 0.5:
                return Action.C
            elif random.random() < 0.2:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.5:
            return Action.C
        elif random.random() < 0.2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_53(BaseStrategy):
    """
    Graduated Reciprocator Strategy: Starts cooperatively, responds proportionally to group cooperation
    with forgiveness mechanisms and graduated punishment escalation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        my_last_action = 1 if history.my_actions[last_round_idx] else 0
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = my_last_action + opponent_cooperators
        cooperation_rate = total_cooperators / n_players
        if current_round == n_rounds:
            return Action.C if cooperation_rate >= 0.4 else Action.D
        base_action = Action.C if cooperation_rate >= 0.5 else Action.D
        if base_action == Action.D and cooperation_rate >= 0.3:
            if random.random() < 0.3:
                base_action = Action.C
        consecutive_low_cooperation = 0
        for round_idx in range(min(history.round_number, 5)):
            check_round = history.round_number - 1 - round_idx
            if check_round < 0:
                break
            my_action = 1 if history.my_actions[check_round] else 0
            opp_cooperators = sum(history.opponent_actions[check_round])
            round_cooperation_rate = (my_action + opp_cooperators) / n_players
            if round_cooperation_rate < 0.3:
                consecutive_low_cooperation += 1
            else:
                break
        if consecutive_low_cooperation >= 2:
            base_action = Action.D
        return base_action

class Strategy_COOPERATIVE_54(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperation while being resilient to 
    occasional defections. It cooperates initially, follows majority behavior with 
    forgiveness mechanisms, and adapts its final round play based on overall cooperation patterns.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            cooperation_frequency = self._calculate_cooperation_frequency(history)
            if cooperation_frequency >= 0.75:
                return Action.C
            else:
                return Action.D
        prev_round_cooperation_rate = self._get_cooperation_rate(history, -1)
        if prev_round_cooperation_rate >= 0.5:
            return Action.C
        if history.round_number >= 2:
            prev2_cooperation_rate = self._get_cooperation_rate(history, -2)
            consecutive_low_cooperation = prev2_cooperation_rate < 0.5
            at_least_one_cooperated = self._count_cooperators(history, -1) >= 1
            if not consecutive_low_cooperation or at_least_one_cooperated:
                return Action.C
        return Action.D

    def _get_cooperation_rate(self, history: PlayerHistory, round_offset: int) -> float:
        """Get cooperation rate for a specific round (negative offset from most recent)."""
        round_idx = history.round_number + round_offset
        if round_idx < 0 or round_idx >= history.round_number:
            return 0.0
        my_cooperation = 1 if history.my_actions[round_idx] else 0
        opponent_cooperators = sum(history.opponent_actions[round_idx])
        total_cooperators = my_cooperation + opponent_cooperators
        return total_cooperators / self.game_description.n_players

    def _count_cooperators(self, history: PlayerHistory, round_offset: int) -> int:
        """Count total cooperators for a specific round (negative offset from most recent)."""
        round_idx = history.round_number + round_offset
        if round_idx < 0 or round_idx >= history.round_number:
            return 0
        my_cooperation = 1 if history.my_actions[round_idx] else 0
        opponent_cooperators = sum(history.opponent_actions[round_idx])
        return my_cooperation + opponent_cooperators

    def _calculate_cooperation_frequency(self, history: PlayerHistory) -> float:
        """Calculate fraction of rounds where cooperation rate was >= 50%."""
        if history.round_number == 0:
            return 0.0
        high_cooperation_rounds = 0
        for i in range(history.round_number):
            cooperation_rate = self._get_cooperation_rate(history, i - history.round_number)
            if cooperation_rate >= 0.5:
                high_cooperation_rounds += 1
        return high_cooperation_rounds / history.round_number

class Strategy_COOPERATIVE_55(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Cooperates in round 1, then uses majority-based response with forgiveness mechanism
    to balance cooperation promotion with exploitation protection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            recent_coop_rate = self._calculate_recent_cooperation_rate(history)
            if recent_coop_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        prev_coop_rate = self._calculate_cooperation_rate(history, history.round_number - 1)
        if prev_coop_rate >= 0.5:
            return Action.C
        consecutive_low_rounds = self._count_consecutive_low_cooperation(history)
        if consecutive_low_rounds <= 1:
            my_avg_payoff = np.mean(history.my_payoffs)
            defect_baseline = 1.0
            if my_avg_payoff >= defect_baseline * 0.9:
                return Action.C
        return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """Calculate cooperation rate for a specific round."""
        if round_idx < 0 or round_idx >= history.round_number:
            return 0.0
        my_action = 1 if history.my_actions[round_idx] else 0
        opponent_cooperators = int(np.sum(history.opponent_actions[round_idx]))
        total_cooperators = my_action + opponent_cooperators
        return total_cooperators / self.game_description.n_players

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate over the last 3 rounds (or all available rounds if fewer)."""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 0.0
        total_coop_rate = 0.0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            total_coop_rate += self._calculate_cooperation_rate(history, round_idx)
        return total_coop_rate / rounds_to_check

    def _count_consecutive_low_cooperation(self, history: PlayerHistory) -> int:
        """Count consecutive rounds with cooperation rate < 50% from the end."""
        consecutive_count = 0
        for i in range(history.round_number):
            round_idx = history.round_number - 1 - i
            coop_rate = self._calculate_cooperation_rate(history, round_idx)
            if coop_rate < 0.5:
                consecutive_count += 1
            else:
                break
        return consecutive_count

class Strategy_COOPERATIVE_56(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) strategy for N-Player Public Goods Game.
    
    Always cooperates in round 1, then uses majority-based cooperation with forgiveness
    mechanism in middle rounds, and employs strategic final-round logic that rewards
    exceptionally cooperative groups.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds:
            if history.round_number >= 3:
                high_cooperation_count = 0
                for round_idx in range(max(0, history.round_number - 3), history.round_number):
                    my_cooperation = int(history.my_actions[round_idx])
                    opponent_cooperators = int(sum(history.opponent_actions[round_idx]))
                    total_cooperators = my_cooperation + opponent_cooperators
                    cooperation_ratio = total_cooperators / n_players
                    if cooperation_ratio >= 0.8:
                        high_cooperation_count += 1
                if high_cooperation_count == 3:
                    return Action.C
            return Action.D
        prev_round_idx = history.round_number - 1
        my_prev_cooperation = int(history.my_actions[prev_round_idx])
        opponent_cooperators = int(sum(history.opponent_actions[prev_round_idx]))
        total_cooperators = my_prev_cooperation + opponent_cooperators
        cooperation_ratio = total_cooperators / n_players
        if cooperation_ratio >= 0.5:
            return Action.C
        if cooperation_ratio >= 0.3:
            return Action.C if random.random() < 0.7 else Action.D
        elif cooperation_ratio >= 0.1:
            return Action.C if random.random() < 0.3 else Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_57(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF): A cooperative strategy that promotes
    cooperation while protecting against exploitation through threshold-based punishment
    and forgiveness mechanisms.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.1
        self.endgame_threshold = 3
        self.punishment_mode = False
        self.punishment_rounds_remaining = 0
        self.consecutive_punishments = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round > total_rounds - self.endgame_threshold:
            return self._endgame_strategy(current_round, total_rounds, history, n_players)
        if self.punishment_mode:
            return self._punishment_strategy()
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / n_players
        if cooperation_rate >= self.cooperation_threshold:
            return Action.C
        else:
            self.punishment_mode = True
            self.punishment_rounds_remaining = 2
            self.consecutive_punishments += 1
            return Action.D

    def _punishment_strategy(self) -> Action:
        self.punishment_rounds_remaining -= 1
        if self.punishment_rounds_remaining <= 0:
            self.punishment_mode = False
            if random.random() < self.forgiveness_probability:
                self.consecutive_punishments = 0
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _endgame_strategy(self, current_round: int, total_rounds: int, history: PlayerHistory, n_players: int) -> Action:
        rounds_left = total_rounds - current_round + 1
        if rounds_left == 3:
            return Action.C
        elif rounds_left == 2:
            last_round_idx = history.round_number - 1
            cooperators_last_round = sum(history.opponent_actions[last_round_idx])
            if history.my_actions[last_round_idx]:
                cooperators_last_round += 1
            cooperation_rate = cooperators_last_round / n_players
            if cooperation_rate >= 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_58(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy starts cooperatively and adapts based on the cooperation rate of other players.
    It uses a threshold-based approach with occasional forgiveness to maintain cooperation
    while protecting against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.6
        self.forgiveness_probability = 0.1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == n_rounds:
            if history.round_number >= 3:
                recent_rounds = min(3, history.round_number)
                start_round = history.round_number - recent_rounds
                total_recent_cooperators = 0
                for round_idx in range(start_round, history.round_number):
                    cooperators_in_round = sum(history.opponent_actions[round_idx])
                    if history.my_actions[round_idx]:
                        cooperators_in_round += 1
                    total_recent_cooperators += cooperators_in_round
                recent_cooperation_rate = total_recent_cooperators / (recent_rounds * n_players)
                if recent_cooperation_rate >= 0.7:
                    return Action.C
                else:
                    return Action.D
            else:
                last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
                if history.my_actions[history.round_number - 1]:
                    last_round_cooperators += 1
                cooperation_rate = last_round_cooperators / n_players
                if cooperation_rate >= 0.7:
                    return Action.C
                else:
                    return Action.D
        last_round_idx = history.round_number - 1
        total_cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            total_cooperators_last_round += 1
        cooperation_rate = total_cooperators_last_round / n_players
        if cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif cooperation_rate >= 0.3:
            if random.random() < self.forgiveness_probability:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_59(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for Public Goods Game.
    
    This strategy starts cooperatively, reciprocates the group's behavior with a 50% cooperation threshold,
    includes a 10% forgiveness mechanism to recover from defection spirals, and uses stricter thresholds
    in endgame rounds to protect against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.1
        self.endgame_threshold = 3
        self.endgame_cooperation_threshold = 0.7

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_opponents = self.game_description.n_players - 1
        if current_round > total_rounds - self.endgame_threshold:
            return self._endgame_strategy(history, n_opponents)
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / n_opponents
        if cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif random.random() < self.forgiveness_probability:
            return Action.C
        else:
            return Action.D

    def _endgame_strategy(self, history: PlayerHistory, n_opponents: int) -> Action:
        """Strategy for endgame rounds with stricter cooperation threshold."""
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / n_opponents
        if cooperation_rate >= self.endgame_cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_60(BaseStrategy):
    """
    Generous Tit-for-Tat with Gradual Forgiveness (GTTGF).
    
    Balances cooperation with protection against exploitation through:
    - Default cooperation when group cooperation rate ≥ 50%
    - Gradual punishment after 2 consecutive rounds of low cooperation
    - Generous forgiveness with 20% cooperation probability during punishment
    - Patient approach that gives second chances before escalating
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_patience = 3
        self.generosity_probability = 0.2
        self.punishment_timer = 0
        self.consecutive_low_cooperation = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            last_round_idx = history.round_number - 1
            last_round_cooperators = sum(history.opponent_actions[last_round_idx])
            cooperation_rate = last_round_cooperators / (self.game_description.n_players - 1)
            if cooperation_rate >= self.cooperation_threshold:
                return Action.C
            else:
                return Action.D
        if self.punishment_timer > 0:
            self.punishment_timer -= 1
            if random.random() < self.generosity_probability:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = last_round_cooperators / (self.game_description.n_players - 1)
        if cooperation_rate >= self.cooperation_threshold:
            self.consecutive_low_cooperation = 0
            return Action.C
        else:
            self.consecutive_low_cooperation += 1
            if self.consecutive_low_cooperation >= 2:
                self.punishment_timer = self.forgiveness_patience
                return Action.D
            else:
                return Action.C

class Strategy_COOPERATIVE_61(BaseStrategy):
    """
    Graduated Reciprocal Cooperation (GRC) strategy.
    
    Starts cooperative and adapts to group cooperation levels while maintaining
    a cooperative bias. Uses a threshold-based system with reciprocity factors
    to balance cooperation with protection against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.4
        self.reciprocity_factor = 0.8
        self.min_cooperation_prob = 0.3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        lookback_rounds = min(3, history.round_number)
        start_round = history.round_number - lookback_rounds
        total_cooperation = 0
        total_decisions = 0
        for round_idx in range(start_round, history.round_number):
            round_cooperators = sum(history.opponent_actions[round_idx])
            total_cooperation += round_cooperators
            total_decisions += len(history.opponent_actions[round_idx])
        recent_cooperation_rate = total_cooperation / total_decisions if total_decisions > 0 else 0
        if current_round == self.game_description.n_rounds:
            if recent_cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        if recent_cooperation_rate >= self.cooperation_threshold:
            return Action.C
        else:
            adjusted_cooperation_prob = max(self.min_cooperation_prob, recent_cooperation_rate * self.reciprocity_factor)
            if random.random() < adjusted_cooperation_prob:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_62(BaseStrategy):
    """
    Graduated Reciprocation with Forgiveness Strategy.
    
    Starts cooperative and maintains cooperation based on group cooperation rates,
    with graduated responses and forgiveness mechanisms to prevent punishment spirals
    while protecting against persistent exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_low_cooperation_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
        cooperation_rate_last_round = cooperators_last_round / n
        if cooperation_rate_last_round < 0.5:
            self.consecutive_low_cooperation_rounds += 1
        else:
            self.consecutive_low_cooperation_rounds = 0
        if current_round == self.game_description.n_rounds:
            rounds_to_check = min(3, history.round_number)
            total_cooperation = 0
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                round_cooperators = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
                total_cooperation += round_cooperators / n
            avg_cooperation_rate = total_cooperation / rounds_to_check
            if avg_cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        if cooperation_rate_last_round >= 0.5:
            return Action.C
        elif cooperation_rate_last_round >= 0.3 and history.my_actions[last_round_idx]:
            return Action.C
        elif self.consecutive_low_cooperation_rounds >= 3:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_63(BaseStrategy):
    """
    Forgiving Majority Follower: A cooperative strategy that follows the majority,
    punishes severe defection when exploited, but quickly forgives to rebuild cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.C
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / self.game_description.n_players
        if cooperation_rate >= 0.5:
            return Action.C
        elif my_last_action and cooperation_rate < 0.3:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_64(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for Public Goods Game.
    
    Cooperates in first round, then cooperates if cooperation rate >= 50% in previous round.
    Includes forgiveness mechanism that tolerates up to 2 consecutive rounds of low cooperation
    before switching to defection. Maintains conditional cooperation in final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = int(my_last_action) + opponent_cooperators
        cooperation_rate = total_cooperators / n_players
        if current_round == n_rounds:
            return Action.C if cooperation_rate >= 0.5 else Action.D
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            consecutive_low_cooperation = 0
            for round_idx in range(history.round_number - 1, -1, -1):
                my_action_this_round = history.my_actions[round_idx]
                opponent_cooperators_this_round = sum(history.opponent_actions[round_idx])
                total_cooperators_this_round = int(my_action_this_round) + opponent_cooperators_this_round
                round_cooperation_rate = total_cooperators_this_round / n_players
                if round_cooperation_rate < 0.5:
                    consecutive_low_cooperation += 1
                else:
                    break
            if consecutive_low_cooperation <= 2:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_65(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) strategy.
    
    Starts cooperative and maintains cooperation when majority cooperates.
    Implements forgiveness for borderline cooperation rates and measured
    punishment for low cooperation, always seeking to return to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0
        self.punishment_phase = False
        self.consecutive_defections = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = int(my_last_action) + opponent_cooperators
        cooperation_rate = total_cooperators / self.game_description.n_players
        if self.punishment_phase:
            self.consecutive_defections += 1
            if self.consecutive_defections >= 2 or cooperation_rate >= 0.6:
                self.punishment_phase = False
                self.consecutive_defections = 0
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            if self.forgiveness_counter < 2:
                self.forgiveness_counter += 1
                return Action.C
            else:
                self.forgiveness_counter = 0
                self.punishment_phase = True
                self.consecutive_defections = 0
                return Action.D
        else:
            self.punishment_phase = True
            self.consecutive_defections = 0
            return Action.D

class Strategy_COOPERATIVE_66(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTF) strategy.
    
    This strategy aims to establish and maintain cooperation while being resilient 
    to occasional defections. It starts cooperatively, punishes mass defection 
    (when <50% cooperate), includes forgiveness mechanisms, and protects against 
    end-game defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.1
        self.final_round_threshold = 0.6
        self.in_punishment_phase = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.in_punishment_phase = False
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds:
            recent_rounds = min(3, history.round_number)
            total_possible_cooperations = n_players * recent_rounds
            recent_cooperations = 0
            for i in range(recent_rounds):
                round_idx = history.round_number - 1 - i
                if history.my_actions[round_idx]:
                    recent_cooperations += 1
                recent_cooperations += sum(history.opponent_actions[round_idx])
            recent_cooperation_rate = recent_cooperations / total_possible_cooperations
            if recent_cooperation_rate >= self.final_round_threshold:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate_last_round = cooperators_last_round / n_players
        if cooperation_rate_last_round >= self.cooperation_threshold:
            self.in_punishment_phase = False
            return Action.C
        elif self.in_punishment_phase:
            if random.random() < self.forgiveness_probability:
                self.in_punishment_phase = False
                return Action.C
            else:
                return Action.D
        else:
            self.in_punishment_phase = True
            return Action.D

class Strategy_COOPERATIVE_67(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Starts optimistically with cooperation, then cooperates if cooperation rate
    in previous round meets threshold (50% normally, 60% in final round).
    Provides quick forgiveness and clear feedback to encourage group cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        previous_round_index = history.round_number - 1
        my_previous_action = history.my_actions[previous_round_index]
        opponent_cooperators = sum(history.opponent_actions[previous_round_index])
        total_cooperators = int(my_previous_action) + opponent_cooperators
        cooperation_rate = total_cooperators / self.game_description.n_players
        if history.round_number == self.game_description.n_rounds - 1:
            threshold = 0.6
        else:
            threshold = 0.5
        if cooperation_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_68(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF)
    
    Balances cooperation with protection against exploitation using generous reciprocity
    that forgives occasional defections and gradually builds trust.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.1
        self.endgame_threshold = 3
        self.consecutive_exploitations = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_exploitations = 0
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round > total_rounds - self.endgame_threshold:
            return Action.D
        last_round_idx = history.round_number - 1
        others_cooperators = sum(history.opponent_actions[last_round_idx])
        others_cooperation_rate = others_cooperators / (n_players - 1)
        my_last_action = history.my_actions[last_round_idx]
        if my_last_action and others_cooperation_rate < 0.3:
            self.consecutive_exploitations += 1
        else:
            self.consecutive_exploitations = 0
        if self.consecutive_exploitations >= 2:
            if random.random() < self.forgiveness_probability:
                return Action.C
            else:
                return Action.D
        elif others_cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif others_cooperation_rate >= 0.3:
            if random.random() < 0.7:
                return Action.C
            else:
                return Action.D
        elif random.random() < self.forgiveness_probability:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_69(BaseStrategy):
    """
    Generous Tit-for-Tat with Collective Threshold strategy.
    
    This strategy balances cooperation with strategic punishment:
    - Always cooperates in round 1 to establish cooperative norms
    - In middle rounds, cooperates if cooperation rate meets threshold, otherwise defects with occasional forgiveness
    - In final round, cooperates if previous cooperation rate was adequate
    - Uses adaptive thresholds based on game parameters to optimize collective welfare
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.r = game_description.n_rounds
        self.threshold = max(0.5, (self.k - 1) / (self.n - 1))
        self.forgiveness_threshold = 0.3
        self.forgiveness_probability = 0.2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        my_last_action = 1 if history.my_actions[last_round_idx] else 0
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = my_last_action + opponent_cooperators
        cooperation_rate = total_cooperators / self.n
        if current_round == self.r:
            return Action.C if cooperation_rate >= 0.3 else Action.D
        if cooperation_rate >= self.threshold:
            return Action.C
        elif cooperation_rate >= self.forgiveness_threshold and random.random() < self.forgiveness_probability:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_70(BaseStrategy):
    """
    Generous Tit-for-Tat with Graduated Sanctions: An adaptive cooperative strategy
    that balances forgiveness with accountability through graduated responses and
    dynamic threshold adjustment based on group cooperation patterns.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.forgiveness_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = history.round_number + 1
        if round_number == self.game_description.n_rounds:
            recent_coop_rate = self._get_recent_cooperation_rate(history, 3)
            return Action.C if recent_coop_rate >= 0.6 else Action.D
        prev_coop_rate = self._get_cooperation_rate(history, history.round_number - 1)
        if prev_coop_rate < 0.3:
            self.forgiveness_counter += 1
        else:
            self.forgiveness_counter = 0
        if self.forgiveness_counter == 2:
            self.forgiveness_counter = 0
            return Action.C
        if round_number <= 3:
            decision = Action.C if prev_coop_rate >= 0.4 else Action.D
        else:
            decision = Action.C if prev_coop_rate >= self.threshold else Action.D
        if prev_coop_rate >= self.threshold:
            self.threshold = max(self.threshold - 0.05, 0.3)
        else:
            self.threshold = min(self.threshold + 0.1, 0.8)
        return decision

    def _get_cooperation_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """Get cooperation rate for a specific round (0-indexed)."""
        if round_idx < 0 or round_idx >= history.round_number:
            return 0.0
        opponent_cooperators = sum(history.opponent_actions[round_idx])
        my_cooperation = 1 if history.my_actions[round_idx] else 0
        total_cooperators = opponent_cooperators + my_cooperation
        return total_cooperators / self.game_description.n_players

    def _get_recent_cooperation_rate(self, history: PlayerHistory, num_rounds: int) -> float:
        """Get cooperation rate over the last num_rounds."""
        if history.round_number == 0:
            return 0.0
        total_cooperators = 0
        total_players = 0
        start_round = max(0, history.round_number - num_rounds)
        for round_idx in range(start_round, history.round_number):
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            my_cooperation = 1 if history.my_actions[round_idx] else 0
            total_cooperators += opponent_cooperators + my_cooperation
            total_players += self.game_description.n_players
        return total_cooperators / total_players if total_players > 0 else 0.0

class Strategy_COOPERATIVE_71(BaseStrategy):
    """
    Forgiving Majority Follower: A cooperative strategy that follows the majority
    while incorporating forgiveness mechanisms to maintain cooperation and adapt
    to group dynamics. Always cooperates in the first round, then uses adaptive
    thresholds based on group cooperation rates with periodic forgiveness attempts.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / n
        if current_round == 2:
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if current_round == self.game_description.n_rounds:
            rounds_to_check = min(3, history.round_number)
            total_cooperation = 0
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                round_cooperators = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                total_cooperation += round_cooperators / n
            recent_cooperation_trend = total_cooperation / rounds_to_check
            if cooperation_rate >= 0.6:
                return Action.C
            elif recent_cooperation_trend >= 0.4:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            personal_cooperation_streak = 0
            for i in range(history.round_number):
                round_idx = history.round_number - 1 - i
                if history.my_actions[round_idx]:
                    personal_cooperation_streak += 1
                else:
                    break
            if current_round % 3 == 0 or personal_cooperation_streak >= 2:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate > 0 and current_round % 5 == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_72(BaseStrategy):
    """
    Forgiving Majority Follower: A cooperative strategy that follows the majority while maintaining
    forgiveness mechanisms and prioritizing collective welfare in the N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        last_round_idx = history.round_number - 1
        opponent_cooperators = int(sum(history.opponent_actions[last_round_idx]))
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        majority_threshold = math.ceil(n / 2)
        if total_cooperators >= majority_threshold:
            return Action.C
        if total_cooperators == n // 2:
            if current_round == 2:
                return Action.C
            if self._cooperation_trending_up(history, 3):
                return Action.C
        if not my_last_action:
            return Action.C
        if current_round >= 4:
            recent_majority_coop_rounds = self._count_majority_coop_rounds(history, 3)
            if recent_majority_coop_rounds >= 2:
                return Action.C
        return Action.D

    def _cooperation_trending_up(self, history: PlayerHistory, window: int) -> bool:
        """Check if cooperation is trending upward over the given window."""
        rounds_available = history.round_number
        if rounds_available < window:
            return False
        start_idx = rounds_available - window
        end_idx = rounds_available - 1
        start_opponent_coop = int(sum(history.opponent_actions[start_idx]))
        start_my_coop = 1 if history.my_actions[start_idx] else 0
        start_total = start_opponent_coop + start_my_coop
        end_opponent_coop = int(sum(history.opponent_actions[end_idx]))
        end_my_coop = 1 if history.my_actions[end_idx] else 0
        end_total = end_opponent_coop + end_my_coop
        return end_total > start_total

    def _count_majority_coop_rounds(self, history: PlayerHistory, window: int) -> int:
        """Count how many rounds in the last 'window' rounds had majority cooperation."""
        rounds_available = history.round_number
        start_idx = max(0, rounds_available - window)
        majority_threshold = math.ceil(self.game_description.n_players / 2)
        majority_rounds = 0
        for round_idx in range(start_idx, rounds_available):
            opponent_cooperators = int(sum(history.opponent_actions[round_idx]))
            my_cooperation = 1 if history.my_actions[round_idx] else 0
            total_cooperators = opponent_cooperators + my_cooperation
            if total_cooperators >= majority_threshold:
                majority_rounds += 1
        return majority_rounds

class Strategy_COOPERATIVE_73(BaseStrategy):
    """
    Generous Tit-for-Tat with Graduated Reciprocation (GTTGR):
    A cooperative strategy that starts with cooperation, responds proportionally 
    to group cooperation levels, and uses graduated reciprocation to maintain
    cooperative equilibria while protecting against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        round_number = history.round_number + 1
        last_round_index = history.round_number - 1
        last_round_opponents = history.opponent_actions[last_round_index]
        my_last_action = history.my_actions[last_round_index]
        opponent_cooperators = sum(last_round_opponents)
        my_cooperation = 1 if my_last_action else 0
        total_cooperators = opponent_cooperators + my_cooperation
        cooperation_rate = total_cooperators / n
        if round_number == r:
            return Action.C if cooperation_rate >= 0.5 else Action.D
        if cooperation_rate >= 0.67:
            return Action.C
        elif cooperation_rate >= 0.33:
            return Action.C if random.random() < cooperation_rate else Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_74(BaseStrategy):
    """
    Forgiving Majority Follower: A cooperative strategy that starts optimistically,
    then cooperates when the majority of others cooperated in the previous round.
    Uses a higher threshold (60%) for the final round to account for end-game effects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds:
            prev_round_idx = history.round_number - 1
            total_cooperators = sum(history.opponent_actions[prev_round_idx])
            if history.my_actions[prev_round_idx]:
                total_cooperators += 1
            cooperation_rate = total_cooperators / n_players
            if cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        else:
            prev_round_idx = history.round_number - 1
            others_cooperated = sum(history.opponent_actions[prev_round_idx])
            if others_cooperated > (n_players - 1) / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_75(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Starts with cooperation and maintains cooperation when the majority cooperates.
    Uses a forgiveness mechanism to give second chances when cooperation drops below 50%.
    Protects against exploitation in the final round with predominantly defecting groups.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_counter = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.forgiveness_counter = 2
            return Action.C
        last_round_idx = history.round_number - 1
        my_last_action = int(history.my_actions[last_round_idx])
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = my_last_action + opponent_cooperators
        coop_rate = total_cooperators / self.game_description.n_players
        current_round = history.round_number + 1
        if current_round < self.game_description.n_rounds:
            if coop_rate >= 0.5:
                self.forgiveness_counter = 2
                return Action.C
            elif self.forgiveness_counter > 0:
                self.forgiveness_counter -= 1
                return Action.C
            else:
                self.forgiveness_counter = 1
                return Action.D
        elif coop_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_76(BaseStrategy):
    """
    Graduated Reciprocator: A cooperative strategy that signals cooperation initially,
    responds to defection with graduated punishment, includes forgiveness mechanisms,
    and protects against end-game exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.defection_tolerance = 2
        self.forgiveness_window = 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round <= 2:
            return Action.C
        if current_round == total_rounds:
            return Action.D
        if current_round == total_rounds - 1:
            if self._get_recent_cooperation_rate(history, 5) >= 0.4:
                return Action.C
            else:
                return Action.D
        return self._adaptive_cooperation_decision(history)

    def _adaptive_cooperation_decision(self, history: PlayerHistory) -> Action:
        recent_coop_rate = self._get_recent_cooperation_rate(history, 3)
        if recent_coop_rate >= self.cooperation_threshold:
            return Action.C
        my_consecutive_defections = self._count_my_consecutive_defections(history)
        if my_consecutive_defections < self.defection_tolerance:
            return Action.C
        if my_consecutive_defections < 2:
            return Action.D
        else:
            rounds_since_last_coop = self._rounds_since_my_last_cooperation(history)
            if rounds_since_last_coop >= self.forgiveness_window:
                return Action.C
            else:
                return Action.D

    def _get_recent_cooperation_rate(self, history: PlayerHistory, rounds_back: int) -> float:
        """Calculate cooperation rate across all players in the last N rounds."""
        current_round = history.round_number
        start_round = max(0, current_round - rounds_back)
        total_cooperations = 0
        total_actions = 0
        for round_idx in range(start_round, current_round):
            if history.my_actions[round_idx]:
                total_cooperations += 1
            total_actions += 1
        for round_idx in range(start_round, current_round):
            for player_idx in range(self.game_description.n_players - 1):
                if history.opponent_actions[round_idx, player_idx]:
                    total_cooperations += 1
                total_actions += 1
        if total_actions == 0:
            return 0.0
        return total_cooperations / total_actions

    def _count_my_consecutive_defections(self, history: PlayerHistory) -> int:
        """Count consecutive defections by me, starting from the most recent round."""
        count = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            if not history.my_actions[round_idx]:
                count += 1
            else:
                break
        return count

    def _rounds_since_my_last_cooperation(self, history: PlayerHistory) -> int:
        """Count rounds since my last cooperation."""
        for round_idx in range(history.round_number - 1, -1, -1):
            if history.my_actions[round_idx]:
                return history.round_number - round_idx - 1
        return history.round_number

class Strategy_COOPERATIVE_77(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) strategy.
    
    This strategy aims to establish and maintain cooperation while being robust 
    against exploitation. It balances being cooperative by default with responding 
    to defection and forgiving past transgressions. Uses group-level cooperation 
    thresholds rather than tracking individual players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_period = 3
        self.generosity_rate = 0.1

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number
        n_opponents = self.game_description.n_players - 1
        last_round_cooperators = int(np.sum(history.opponent_actions[current_round - 1]))
        cooperation_rate = last_round_cooperators / n_opponents if n_opponents > 0 else 0
        if cooperation_rate >= self.cooperation_threshold:
            action = Action.C
        else:
            recent_defectors = self._count_recent_defectors(history, current_round)
            if recent_defectors < n_opponents * 0.7:
                action = Action.C
            elif random.random() < self.generosity_rate:
                action = Action.C
            else:
                action = Action.D
        if current_round >= self.game_description.n_rounds - 2:
            if cooperation_rate >= 0.7:
                action = Action.C
            else:
                action = Action.D
        return action

    def _count_recent_defectors(self, history: PlayerHistory, current_round: int) -> int:
        """Count opponents who defected in recent rounds within forgiveness period."""
        n_opponents = self.game_description.n_players - 1
        start_round = max(0, current_round - self.forgiveness_period)
        recent_defectors = 0
        for player in range(n_opponents):
            defected_recently = False
            for round_idx in range(start_round, current_round):
                if not history.opponent_actions[round_idx, player]:
                    defected_recently = True
                    break
            if defected_recently:
                recent_defectors += 1
        return recent_defectors

class Strategy_COOPERATIVE_78(BaseStrategy):
    """
    Generous Tit-for-Tat with Majority Rule (GTFMR)
    
    Combines cooperative signaling, conditional cooperation based on group behavior,
    and strategic forgiveness to maintain cooperation while protecting against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_probability = 0.15

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        cooperation_threshold = math.ceil(self.game_description.n_players / 2)
        previous_round = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[previous_round])
        my_previous_action = history.my_actions[previous_round]
        total_cooperators = opponent_cooperators + (1 if my_previous_action else 0)
        is_final_round = history.round_number == self.game_description.n_rounds - 1
        if total_cooperators >= cooperation_threshold:
            return Action.C
        elif not is_final_round and random.random() < self.forgiveness_probability:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_79(BaseStrategy):
    """
    Conditional Cooperator with Forgiveness: Starts cooperatively, maintains cooperation 
    when majority cooperates, provides limited forgiveness for temporary defection, 
    and sustains cooperation even in final rounds to prevent cascade effects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n = self.game_description.n_players
        if current_round == total_rounds:
            return Action.C
        prev_round_idx = history.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_prev_action else 0)
        prev_coop_rate = total_cooperators / n
        if prev_coop_rate >= 0.5:
            return Action.C
        if current_round >= 3:
            two_rounds_ago_idx = history.round_number - 2
            my_two_rounds_ago = history.my_actions[two_rounds_ago_idx]
            opponent_cooperators_two_ago = sum(history.opponent_actions[two_rounds_ago_idx])
            total_cooperators_two_ago = opponent_cooperators_two_ago + (1 if my_two_rounds_ago else 0)
            two_rounds_ago_rate = total_cooperators_two_ago / n
            if prev_coop_rate > two_rounds_ago_rate:
                return Action.C
        recent_drops = 0
        start_idx = max(0, history.round_number - 3)
        for i in range(start_idx, history.round_number):
            my_action_i = history.my_actions[i]
            opponent_cooperators_i = sum(history.opponent_actions[i])
            total_cooperators_i = opponent_cooperators_i + (1 if my_action_i else 0)
            coop_rate_i = total_cooperators_i / n
            if coop_rate_i < 0.5:
                recent_drops += 1
        if recent_drops == 1:
            return Action.C
        return Action.D

class Strategy_COOPERATIVE_80(BaseStrategy):
    """
    Forgiving Majority Follower strategy for N-Player Public Goods Game.
    
    This strategy cooperates in round 1, then follows majority behavior in subsequent rounds.
    In tie situations, it considers cooperation trends. In the final round, it uses a lower
    threshold for cooperation (n/3 instead of n/2).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            cooperators_last_round = self._count_cooperators_last_round(history)
            if cooperators_last_round >= n / 3:
                return Action.C
            else:
                return Action.D
        cooperators_last_round = self._count_cooperators_last_round(history)
        if cooperators_last_round >= n / 2:
            return Action.C
        if cooperators_last_round == n / 2 and current_round >= 3:
            cooperators_two_rounds_ago = self._count_cooperators_two_rounds_ago(history)
            if cooperators_last_round >= cooperators_two_rounds_ago:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count cooperators (including self) in the most recent completed round."""
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        self_cooperated = 1 if history.my_actions[last_round_idx] else 0
        return int(opponent_cooperators + self_cooperated)

    def _count_cooperators_two_rounds_ago(self, history: PlayerHistory) -> int:
        """Count cooperators (including self) two rounds ago."""
        two_rounds_ago_idx = history.round_number - 2
        opponent_cooperators = sum(history.opponent_actions[two_rounds_ago_idx])
        self_cooperated = 1 if history.my_actions[two_rounds_ago_idx] else 0
        return int(opponent_cooperators + self_cooperated)

class Strategy_COOPERATIVE_81(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperation while being resilient to
    occasional defections. It starts cooperatively, maintains cooperation when others
    reciprocate, but can defend against exploitation. Uses a memory window to calculate
    recent cooperation rates and includes forgiveness mechanisms to escape defection spirals.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.6
        self.base_forgiveness_probability = 0.1
        self.memory_window = 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        window_size = min(self.memory_window, history.round_number)
        recent_cooperation_rate = self._calculate_cooperation_rate(history, window_size)
        forgiveness_prob = self._get_forgiveness_probability(current_round, total_rounds, history)
        threshold = self._get_cooperation_threshold(history)
        if recent_cooperation_rate >= threshold:
            return Action.C
        elif random.random() < forgiveness_prob:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, window_size: int) -> float:
        """Calculate cooperation rate over the specified window of recent rounds."""
        if window_size == 0:
            return 1.0
        total_players = 0
        total_cooperators = 0
        start_round = max(0, history.round_number - window_size)
        for round_idx in range(start_round, history.round_number):
            if history.my_actions[round_idx]:
                total_cooperators += 1
            total_players += 1
            for opponent_idx in range(self.game_description.n_players - 1):
                if history.opponent_actions[round_idx, opponent_idx]:
                    total_cooperators += 1
                total_players += 1
        return total_cooperators / total_players if total_players > 0 else 1.0

    def _get_forgiveness_probability(self, current_round: int, total_rounds: int, history: PlayerHistory) -> float:
        """Calculate forgiveness probability based on game phase."""
        if current_round <= 3:
            return 0.15
        if current_round > total_rounds * 0.8:
            base_reduction = (current_round - total_rounds * 0.8) / (total_rounds * 0.2)
            return self.base_forgiveness_probability * (1 - base_reduction * 0.5)
        return self.base_forgiveness_probability

    def _get_cooperation_threshold(self, history: PlayerHistory) -> float:
        """Adjust cooperation threshold based on historical patterns."""
        if history.round_number < 5:
            return self.cooperation_threshold
        overall_coop_rate = self._calculate_cooperation_rate(history, min(5, history.round_number))
        if overall_coop_rate > 0.8:
            return 0.5
        if overall_coop_rate < 0.2:
            return 0.7
        current_round = history.round_number + 1
        if current_round > self.game_description.n_rounds - 3:
            return 0.8
        return self.cooperation_threshold

class Strategy_COOPERATIVE_82(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) strategy.
    
    This strategy balances cooperation with protection against exploitation:
    - Always cooperates in round 1
    - Cooperates if cooperation rate in previous round >= 50%
    - Includes 20% forgiveness mechanism to prevent defection spirals
    - Uses stricter criteria (60%) and payoff check for final round
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        k = self.game_description.k
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        prev_cooperators = int(sum(history.opponent_actions[prev_round_idx])) + int(history.my_actions[prev_round_idx])
        cooperation_rate = prev_cooperators / n
        if current_round < r:
            if cooperation_rate >= 0.5:
                return Action.C
            elif random.random() < 0.2:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate >= 0.6:
            return Action.C
        else:
            my_avg_payoff = sum(history.my_payoffs) / len(history.my_payoffs)
            expected_mutual_coop_payoff = k
            if my_avg_payoff >= expected_mutual_coop_payoff * 0.8:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_83(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for Public Goods Game.
    
    Starts cooperatively, reciprocates group behavior with a dynamic threshold,
    and includes forgiveness mechanisms to prevent permanent defection spirals.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.dynamic_threshold = max(0.3, (self.k - 1) / (self.n - 1))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            last_round_coop_rate = self._get_cooperation_rate(history, history.round_number - 1)
            return Action.C if last_round_coop_rate >= 0.5 else Action.D
        if current_round % 3 == 0 and (not history.my_actions[-1]):
            return Action.C
        last_round_coop_rate = self._get_cooperation_rate(history, history.round_number - 1)
        return Action.C if last_round_coop_rate >= self.dynamic_threshold else Action.D

    def _get_cooperation_rate(self, history: PlayerHistory, round_index: int) -> float:
        """Calculate cooperation rate for a given round (0-indexed)."""
        if round_index < 0:
            return 0.0
        opponent_cooperators = sum(history.opponent_actions[round_index])
        my_action = history.my_actions[round_index]
        total_cooperators = opponent_cooperators + (1 if my_action else 0)
        return total_cooperators / self.n

class Strategy_COOPERATIVE_84(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness: A cooperative strategy that aims to establish 
    and maintain cooperation while being robust against exploitation. It uses cooperation 
    rates to make decisions, includes forgiveness mechanisms, and adapts behavior for the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_defection_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_defection_rounds = 0
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = opponent_cooperators / (n_players - 1)
        if current_round == n_rounds:
            if cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.5:
            self.consecutive_defection_rounds = 0
            return Action.C
        elif cooperation_rate >= 0.3:
            self.consecutive_defection_rounds = 0
            if random.random() < 0.7:
                return Action.C
            else:
                return Action.D
        else:
            if self.consecutive_defection_rounds >= 2:
                if random.random() < 0.3:
                    self.consecutive_defection_rounds = 0
                    return Action.C
            self.consecutive_defection_rounds += 1
            return Action.D

class Strategy_COOPERATIVE_85(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperation while being robust against exploitation.
    It balances optimism about cooperation with pragmatic responses to defection, using majority-based
    responses, graduated punishment, and forgiveness mechanisms.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return self._final_round_decision(history, n)
        else:
            return self._adaptive_cooperation(history, n)

    def _final_round_decision(self, history: PlayerHistory, n: int) -> Action:
        """Decision logic for the final round."""
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate_last_round = last_round_cooperators / (n - 1)
        total_rounds_completed = history.round_number
        total_possible_actions = (n - 1) * total_rounds_completed
        total_cooperations = sum((sum(history.opponent_actions[round_idx]) for round_idx in range(total_rounds_completed)))
        overall_cooperation_rate = total_cooperations / total_possible_actions
        if cooperation_rate_last_round >= 0.6 or overall_cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

    def _adaptive_cooperation(self, history: PlayerHistory, n: int) -> Action:
        """Adaptive cooperation logic for rounds 2 to r-1."""
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = last_round_cooperators / (n - 1)
        my_recent_exploitation = self._check_recent_exploitation(history, n)
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            if my_recent_exploitation and random.random() < 0.3:
                return Action.D
            else:
                return Action.C
        elif cooperation_rate > 0:
            if random.random() < 0.4:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _check_recent_exploitation(self, history: PlayerHistory, n: int) -> bool:
        """Check if this player is being exploited by cooperating more than others recently."""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return False
        my_recent_cooperations = sum(history.my_actions[-rounds_to_check:])
        others_total_cooperations = 0
        for round_offset in range(rounds_to_check):
            round_idx = history.round_number - 1 - round_offset
            others_total_cooperations += sum(history.opponent_actions[round_idx])
        others_avg_cooperations = others_total_cooperations / (n - 1)
        return my_recent_cooperations > others_avg_cooperations

class Strategy_COOPERATIVE_86(BaseStrategy):
    """
    Forgiving Tit-for-Tat with Gradual Recovery Strategy.
    
    Starts cooperatively, responds proportionally to group cooperation rates,
    and maintains pathways back to full cooperation while protecting against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            total_cooperation = 0
            total_possible = 0
            for round_idx in range(history.round_number):
                my_coop = 1 if history.my_actions[round_idx] else 0
                opponent_coop = sum(history.opponent_actions[round_idx])
                round_cooperators = my_coop + opponent_coop
                total_cooperation += round_cooperators
                total_possible += self.game_description.n_players
            avg_coop_rate = total_cooperation / total_possible if total_possible > 0 else 0
            return Action.C if avg_coop_rate >= 0.5 else Action.D
        last_round_idx = history.round_number - 1
        my_last_coop = 1 if history.my_actions[last_round_idx] else 0
        opponent_last_coop = sum(history.opponent_actions[last_round_idx])
        last_round_cooperators = my_last_coop + opponent_last_coop
        coop_rate = last_round_cooperators / self.game_description.n_players
        if coop_rate >= 0.67:
            return Action.C
        elif coop_rate >= 0.33:
            return Action.C if random.random() < 0.75 else Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_87(BaseStrategy):
    """
    Forgiving Reciprocator with Momentum Building: A cooperative strategy that starts optimistically,
    builds cooperation momentum, forgives occasional defections, and protects against exploitation
    while prioritizing long-term collective welfare.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == total_rounds:
            return self._decide_final_round(history, n)
        return self._decide_middle_round(history, n, current_round)

    def _decide_final_round(self, history: None | PlayerHistory, n: int) -> Action:
        """Decide action for the final round based on overall cooperation history."""
        total_rounds_played = history.round_number
        my_cooperations = sum(history.my_actions)
        total_cooperations = sum((sum(history.opponent_actions[round_idx]) for round_idx in range(total_rounds_played)))
        total_cooperations += my_cooperations
        my_cooperation_rate = my_cooperations / total_rounds_played if total_rounds_played > 0 else 0
        total_cooperation_rate = total_cooperations / (total_rounds_played * n) if total_rounds_played > 0 else 0
        if total_cooperation_rate >= 0.6 and my_cooperation_rate >= 0.6:
            return Action.C
        if total_cooperation_rate >= 0.4 and my_cooperation_rate >= total_cooperation_rate + 0.1:
            return Action.C
        return Action.D

    def _decide_middle_round(self, history: None | PlayerHistory, n: int, current_round: int) -> Action:
        """Decide action for middle rounds using adaptive reciprocal cooperation."""
        rounds_played = history.round_number
        recent_rounds = min(3, rounds_played)
        start_idx = max(0, rounds_played - recent_rounds)
        my_recent_cooperations = sum(history.my_actions[start_idx:])
        my_recent_cooperation_rate = my_recent_cooperations / recent_rounds
        group_recent_cooperations = 0
        for round_idx in range(start_idx, rounds_played):
            group_recent_cooperations += sum(history.opponent_actions[round_idx])
            group_recent_cooperations += history.my_actions[round_idx]
        group_recent_cooperation_rate = group_recent_cooperations / (recent_rounds * n)
        if group_recent_cooperation_rate >= 0.67:
            return Action.C
        if group_recent_cooperation_rate >= 0.4:
            if my_recent_cooperation_rate > group_recent_cooperation_rate:
                return Action.C
            else:
                return Action.C if random.random() < group_recent_cooperation_rate else Action.D
        if group_recent_cooperation_rate >= 0.2:
            if current_round % 3 == 1 and my_recent_cooperation_rate < 0.33:
                return Action.C
            else:
                return Action.D
        if current_round % 5 == 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_88(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Always cooperates in round 1, then cooperates based on previous round's cooperation rate
    with a forgiveness mechanism. Uses different thresholds for regular rounds vs final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        previous_round = history.round_number - 1
        my_previous_action = history.my_actions[previous_round]
        opponent_cooperators = sum(history.opponent_actions[previous_round])
        total_cooperators = opponent_cooperators + (1 if my_previous_action else 0)
        cooperation_rate = total_cooperators / self.game_description.n_players
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            threshold = 0.4
            return Action.C if cooperation_rate >= threshold else Action.D
        elif cooperation_rate >= 0.5:
            return Action.C
        elif random.random() < 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_89(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperation while being resilient to defection.
    It starts cooperatively, responds to majority cooperation patterns, punishes sustained
    defection, and includes forgiveness mechanisms to allow recovery from punishment cycles.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if current_round == r:
            last_round_cooperators = sum(history.opponent_actions[history.round_number - 1]) + int(history.my_actions[history.round_number - 1])
            cooperation_rate_last = last_round_cooperators / n
            if cooperation_rate_last >= 0.4:
                return Action.C
            else:
                return Action.D
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1]) + int(history.my_actions[history.round_number - 1])
        cooperation_rate_last_round = last_round_cooperators / n
        if cooperation_rate_last_round >= 0.5:
            return Action.C
        elif current_round >= 3:
            second_last_cooperators = sum(history.opponent_actions[history.round_number - 2]) + int(history.my_actions[history.round_number - 2])
            total_cooperators_last_two = last_round_cooperators + second_last_cooperators
            cooperation_rate_last_two = total_cooperators_last_two / (2 * n)
            if cooperation_rate_last_two < 0.3:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_90(BaseStrategy):
    """
    Generous Tit-for-Tat with Gradual Forgiveness (GTTGF).
    
    This strategy starts cooperatively, then adapts based on the cooperation ratio
    from the previous round. It uses forgiveness mechanisms to maintain cooperation
    while protecting against exploitation. Always defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        prev_round_idx = history.round_number - 1
        prev_opponent_actions = history.opponent_actions[prev_round_idx]
        prev_my_action = history.my_actions[prev_round_idx]
        cooperators = sum(prev_opponent_actions) + (1 if prev_my_action else 0)
        coop_ratio = cooperators / self.game_description.n_players
        if coop_ratio >= 0.5:
            return Action.C
        elif coop_ratio >= 0.3:
            return Action.C if random.random() < 0.7 else Action.D
        elif current_round <= self.game_description.n_rounds / 2:
            return Action.C if random.random() < 0.4 else Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_91(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperation while being resilient to 
    occasional defections. It starts cooperatively, uses majority-based thresholds,
    implements a forgiveness mechanism, and has end-game protection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0
        self.max_forgiveness = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.forgiveness_counter = 0
            return Action.C
        n = self.game_description.n_players
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return self._final_round_decision(history)
        return self._adaptive_cooperation_decision(history)

    def _adaptive_cooperation_decision(self, history: PlayerHistory) -> Action:
        n = self.game_description.n_players
        cooperation_threshold = n / 2
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        if cooperators_last_round >= cooperation_threshold:
            self.forgiveness_counter = 0
            return Action.C
        elif self.forgiveness_counter < self.max_forgiveness:
            self.forgiveness_counter += 1
            return Action.C
        else:
            return Action.D

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        n = self.game_description.n_players
        rounds_to_check = min(3, history.round_number)
        start_round = history.round_number - rounds_to_check
        total_cooperators = 0
        total_possible = rounds_to_check * n
        for round_idx in range(start_round, history.round_number):
            round_cooperators = sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                round_cooperators += 1
            total_cooperators += round_cooperators
        recent_cooperation_rate = total_cooperators / total_possible
        if recent_cooperation_rate >= 0.4:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_92(BaseStrategy):
    """
    Generous Tit-for-Tat with Majority Threshold (GTMT)
    
    Cooperates in round 1, then cooperates if ≥50% of players cooperated in the previous round.
    When majority defected, still cooperates with 20% probability (generous forgiveness).
    Always defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_index = history.round_number - 1
        my_last_action = history.my_actions[last_round_index]
        opponent_cooperators = sum(history.opponent_actions[last_round_index])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / self.game_description.n_players
        if cooperation_rate >= 0.5:
            return Action.C
        elif random.random() < 0.2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_93(BaseStrategy):
    """
    Forgiving Majority Follower: Cooperates when majority cooperated in last round,
    with forgiveness mechanisms and protection against sustained defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_window = 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            recent_cooperators = self._count_cooperators_last_round(history)
            cooperation_threshold = math.ceil(n / 2)
            if recent_cooperators >= cooperation_threshold:
                return Action.C
            else:
                return Action.D
        cooperation_threshold = math.ceil(n / 2)
        recent_cooperators = self._count_cooperators_last_round(history)
        sustained_defectors = self._count_sustained_defectors(history)
        if sustained_defectors >= n / 2:
            return Action.D
        if recent_cooperators >= cooperation_threshold:
            return Action.C
        else:
            rebuild_threshold = math.ceil(n / 3)
            if recent_cooperators >= rebuild_threshold:
                return Action.C
            else:
                return Action.D

    def _count_cooperators_last_round(self, history: PlayerHistory) -> int:
        """Count number of opponents who cooperated in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_cooperated = history.my_actions[last_round_idx]
        return int(opponent_cooperators + my_cooperated)

    def _count_sustained_defectors(self, history: PlayerHistory) -> int:
        """Count players who defected consistently over the forgiveness window."""
        n = self.game_description.n_players
        current_round = history.round_number
        window_size = min(self.forgiveness_window, current_round)
        if window_size == 0:
            return 0
        sustained_defectors = 0
        for player_idx in range(n - 1):
            defected_all_window = True
            for round_back in range(window_size):
                round_idx = current_round - 1 - round_back
                if history.opponent_actions[round_idx, player_idx]:
                    defected_all_window = False
                    break
            if defected_all_window:
                sustained_defectors += 1
        my_defected_all_window = True
        for round_back in range(window_size):
            round_idx = current_round - 1 - round_back
            if history.my_actions[round_idx]:
                my_defected_all_window = False
                break
        if my_defected_all_window:
            sustained_defectors += 1
        return sustained_defectors

class Strategy_COOPERATIVE_94(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for Public Goods Game.
    
    Cooperates in round 1, then uses majority-based reciprocity with historical
    forgiveness. Cooperates in final two rounds to avoid endgame unraveling.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == n_rounds:
            return Action.C
        if current_round == n_rounds - 1:
            return Action.C
        prev_round_idx = history.round_number - 1
        prev_cooperators = 0
        if history.my_actions[prev_round_idx]:
            prev_cooperators += 1
        prev_cooperators += sum(history.opponent_actions[prev_round_idx])
        majority_threshold = math.ceil(n_players / 2)
        if prev_cooperators >= majority_threshold:
            return Action.C
        else:
            total_rounds_so_far = history.round_number
            total_possible_cooperations = total_rounds_so_far * n_players
            total_actual_cooperations = 0
            total_actual_cooperations += sum(history.my_actions)
            for round_idx in range(total_rounds_so_far):
                total_actual_cooperations += sum(history.opponent_actions[round_idx])
            historical_coop_rate = total_actual_cooperations / total_possible_cooperations
            if historical_coop_rate >= 0.4:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_95(BaseStrategy):
    """
    Forgiving Majority with Endgame Cooperation Strategy.
    
    Cooperates in round 1, follows majority cooperation in middle rounds
    (cooperates if at least floor(n/2) players cooperated last round),
    and always cooperates in the final two rounds to maintain group welfare.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if current_round <= r - 2:
            last_round_idx = history.round_number - 1
            my_last_action = history.my_actions[last_round_idx]
            opponent_cooperators = sum(history.opponent_actions[last_round_idx])
            total_cooperators = int(my_last_action) + opponent_cooperators
            majority_threshold = n // 2
            if total_cooperators >= majority_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_96(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) strategy.
    
    Starts cooperatively, follows majority behavior with forgiveness mechanism,
    and protects against final-round exploitation. Balances cooperation with
    defensive measures against persistent defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.personal_coop_count = 0
        self.rounds_since_defection = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.personal_coop_count = 1
            self.rounds_since_defection = 1
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == total_rounds:
            cooperation_rate = self.personal_coop_count / (current_round - 1)
            if cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        else:
            prev_round_idx = history.round_number - 1
            opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
            my_prev_action = history.my_actions[prev_round_idx]
            total_cooperators = opponent_cooperators + (1 if my_prev_action else 0)
            majority_threshold = math.ceil(n_players / 2)
            if total_cooperators >= majority_threshold:
                self.personal_coop_count += 1
                self.rounds_since_defection += 1
                return Action.C
            else:
                prev_coop_rate = total_cooperators / n_players
                if self.rounds_since_defection >= 2 and prev_coop_rate >= 0.4:
                    self.personal_coop_count += 1
                    self.rounds_since_defection += 1
                    return Action.C
                else:
                    self.rounds_since_defection = 0
                    return Action.D

class Strategy_COOPERATIVE_97(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness Strategy
    
    A cooperative strategy that starts with cooperation and maintains it based on group behavior.
    Features forgiveness mechanisms, streak protection, and conditional end-game cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_used = False
        self.consecutive_coop_rounds = 0
        self.last_action = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.last_action = Action.C
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate_last_round = cooperators_last_round / n_players
        if current_round == n_rounds:
            if cooperation_rate_last_round >= 0.5:
                self.last_action = Action.C
                return Action.C
            else:
                self.last_action = Action.D
                return Action.D
        if cooperation_rate_last_round >= 0.5 and self.last_action == Action.C:
            self.consecutive_coop_rounds += 1
        else:
            self.consecutive_coop_rounds = 0
        if cooperation_rate_last_round >= 0.5:
            self.forgiveness_used = False
            self.last_action = Action.C
            return Action.C
        elif self.consecutive_coop_rounds >= 3:
            self.consecutive_coop_rounds = 0
            self.last_action = Action.C
            return Action.C
        elif cooperation_rate_last_round < 0.5 and (not self.forgiveness_used):
            self.forgiveness_used = True
            self.last_action = Action.C
            return Action.C
        else:
            self.last_action = Action.D
            return Action.D

class Strategy_COOPERATIVE_98(BaseStrategy):
    """
    Conditional Cooperation with Forgiveness Strategy
    
    Cooperates when cooperation rate in previous round >= 50%, defects otherwise.
    Always cooperates in first round, always defects in last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        previous_round_index = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[previous_round_index])
        my_previous_action = history.my_actions[previous_round_index]
        total_cooperators = opponent_cooperators + (1 if my_previous_action else 0)
        cooperation_rate = total_cooperators / self.game_description.n_players
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_99(BaseStrategy):
    """
    Generous Tit-for-Tat with Group Momentum: An adaptive cooperative strategy
    that starts cooperatively, responds to overall group cooperation levels,
    and uses generous forgiveness to maintain cooperation while defending against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / n
        my_last_action = history.my_actions[last_round_idx]
        if current_round == total_rounds:
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.6:
            return Action.C
        elif cooperation_rate >= 0.3:
            if my_last_action and cooperation_rate < 0.5:
                if random.random() < 0.7:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        else:
            rounds_remaining = total_rounds - current_round
            if cooperation_rate < 0.2 and rounds_remaining > 3:
                return Action.D
            elif random.random() < 0.4:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_100(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness: A cooperative strategy that starts by cooperating,
    follows the majority cooperation rate, and includes forgiveness mechanisms to recover
    from coordination failures while protecting against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx])
        if history.my_actions[prev_round_idx]:
            prev_cooperators += 1
        prev_coop_rate = prev_cooperators / n_players
        if current_round == n_rounds:
            return Action.C if prev_coop_rate >= 0.4 else Action.D
        if prev_coop_rate >= 0.5:
            return Action.C
        if current_round >= 3:
            my_last_action = history.my_actions[prev_round_idx]
            if not my_last_action:
                two_rounds_ago_idx = history.round_number - 2
                cooperators_two_ago = sum(history.opponent_actions[two_rounds_ago_idx])
                if history.my_actions[two_rounds_ago_idx]:
                    cooperators_two_ago += 1
                coop_rate_two_ago = cooperators_two_ago / n_players
                if coop_rate_two_ago >= 0.3:
                    return Action.C
        return Action.D

class Strategy_COOPERATIVE_101(BaseStrategy):
    """
    Forgiving Majority Follower: Cooperates when majority cooperation exists,
    with forgiveness and adaptive thresholds for the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            last_round_cooperators = self._count_total_cooperators(history, -1)
            threshold = math.ceil(2 * self.n_players / 3)
            return Action.C if last_round_cooperators >= threshold else Action.D
        else:
            majority_threshold = math.ceil(self.n_players / 2)
            last_round_cooperators = self._count_total_cooperators(history, -1)
            recent_cooperation = last_round_cooperators >= majority_threshold
            historical_cooperation = self._check_historical_majority(history, majority_threshold)
            return Action.C if recent_cooperation or historical_cooperation else Action.D

    def _count_total_cooperators(self, history: PlayerHistory, round_index: int) -> int:
        """Count total cooperators (including self) in a specific round."""
        my_cooperation = 1 if history.my_actions[round_index] else 0
        opponent_cooperation = sum(history.opponent_actions[round_index])
        return my_cooperation + opponent_cooperation

    def _check_historical_majority(self, history: PlayerHistory, majority_threshold: int) -> bool:
        """Check if majority cooperation existed in majority of previous rounds."""
        if history.round_number <= 1:
            return True
        rounds_with_majority = 0
        total_rounds_to_check = history.round_number
        for round_idx in range(total_rounds_to_check):
            cooperators_in_round = self._count_total_cooperators(history, round_idx)
            if cooperators_in_round >= majority_threshold:
                rounds_with_majority += 1
        return rounds_with_majority >= math.ceil(total_rounds_to_check / 2)

class Strategy_COOPERATIVE_102(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperation while being resilient to 
    occasional defections. It uses graduated responses based on cooperation rates and 
    includes forgiveness mechanisms to allow recovery from punishment cycles.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_num = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            last_round_cooperators += 1
        cooperation_rate_last = last_round_cooperators / n_players
        if round_num == n_rounds:
            total_cooperators = 0
            for round_idx in range(history.round_number):
                round_cooperators = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    round_cooperators += 1
                total_cooperators += round_cooperators
            avg_cooperation_rate = total_cooperators / (history.round_number * n_players)
            if avg_cooperation_rate >= 0.6:
                return Action.C
            elif cooperation_rate_last >= 0.5:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate_last >= 0.5:
            return Action.C
        elif cooperation_rate_last >= 0.3:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.C if random.random() < 0.2 else Action.D

class Strategy_COOPERATIVE_103(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperation while being resilient to 
    occasional defections. It uses reputation-based decision making, starts cooperatively,
    and includes forgiveness and recovery mechanisms.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        cooperation_rates = []
        for player_idx in range(n_players - 1):
            cooperations = sum(history.opponent_actions[:history.round_number, player_idx])
            rate = cooperations / history.round_number
            cooperation_rates.append(rate)
        if current_round == n_rounds:
            cooperator_threshold = 0.6
            cooperators = sum((1 for rate in cooperation_rates if rate >= cooperator_threshold))
            if cooperators / (n_players - 1) >= 0.6:
                return Action.C
            else:
                return Action.D
        if current_round > 4:
            all_defected_last_2 = True
            for round_offset in [1, 2]:
                if history.round_number >= round_offset:
                    round_idx = history.round_number - round_offset
                    if sum(history.opponent_actions[round_idx]) > 0:
                        all_defected_last_2 = False
                        break
            if all_defected_last_2:
                if current_round % 3 == 0:
                    return Action.C
                else:
                    return Action.D
        if current_round <= 3:
            cooperator_threshold = 0.5
        else:
            cooperator_threshold = 0.7
        cooperators = sum((1 for rate in cooperation_rates if rate >= cooperator_threshold))
        cooperator_fraction = cooperators / (n_players - 1)
        if cooperator_fraction >= 0.5:
            return Action.C
        elif cooperator_fraction >= 0.3:
            if random.random() < 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_104(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Cooperates in first round, then cooperates if at least 50% of all players 
    (including self) cooperated in the previous round. This creates a stable 
    cooperative equilibrium while protecting against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round_index = history.round_number - 1
        my_last_action = history.my_actions[last_round_index]
        my_cooperated = int(my_last_action)
        opponents_last_actions = history.opponent_actions[last_round_index]
        opponent_cooperators = int(sum(opponents_last_actions))
        total_cooperators = my_cooperated + opponent_cooperators
        cooperation_rate = total_cooperators / self.game_description.n_players
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_105(BaseStrategy):
    """
    Graduated Reciprocator: An adaptive cooperative strategy that starts cooperatively,
    responds proportionally to group cooperation levels, includes punishment for high
    defection, and uses forgiveness mechanisms to restore cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.punishment_rounds = 0
        self.forgiveness_interval = 3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if self.punishment_rounds > 0:
            self.punishment_rounds -= 1
            return Action.D
        cooperation_rate = self._calculate_recent_cooperation_rate(history)
        if cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif cooperation_rate >= 0.3:
            if current_round % self.forgiveness_interval == 0:
                return Action.C
            else:
                return Action.D
        else:
            self.punishment_rounds = 2
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate from recent rounds with appropriate handling for early game."""
        current_round = history.round_number
        if current_round == 1:
            cooperators = sum(history.opponent_actions[0])
            total_players = len(history.opponent_actions[0])
            return cooperators / total_players if total_players > 0 else 0.0
        elif current_round == 2:
            total_cooperators = 0
            total_observations = 0
            for round_idx in range(2):
                cooperators = sum(history.opponent_actions[round_idx])
                total_cooperators += cooperators
                total_observations += len(history.opponent_actions[round_idx])
            return total_cooperators / total_observations if total_observations > 0 else 0.0
        else:
            rounds_to_examine = min(3, current_round)
            start_round = current_round - rounds_to_examine
            weighted_cooperation = 0.0
            total_weight = 0.0
            for i in range(rounds_to_examine):
                round_idx = start_round + i
                cooperators = sum(history.opponent_actions[round_idx])
                total_players = len(history.opponent_actions[round_idx])
                if total_players > 0:
                    cooperation_rate_round = cooperators / total_players
                    weight = (i + 1) ** 2
                    weighted_cooperation += cooperation_rate_round * weight
                    total_weight += weight
            return weighted_cooperation / total_weight if total_weight > 0 else 0.0

class Strategy_COOPERATIVE_106(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for Public Goods Game.
    
    Cooperates in first round, then uses cooperation rate thresholds with 
    forgiveness mechanism to balance cooperation promotion with exploitation protection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        prev_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        my_prev_action = history.my_actions[prev_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_prev_action else 0)
        cooperation_rate = total_cooperators / n_players
        if current_round == total_rounds:
            if cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate < 0.3:
            if random.random() < 0.2:
                return Action.C
            else:
                return Action.D
        elif random.random() < 0.2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_107(BaseStrategy):
    """
    Forgiving Majority Strategy: An adaptive cooperative approach that starts optimistic,
    responds to group cooperation levels, and includes forgiveness mechanisms to maintain
    cooperation while protecting against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return self._final_round_decision(history)
        else:
            return self._middle_round_decision(history)

    def _count_cooperators(self, history: PlayerHistory, round_idx: int) -> int:
        """Count total cooperators (including self) in a given round (0-indexed)."""
        if round_idx >= history.round_number:
            return 0
        opponent_cooperators = int(sum(history.opponent_actions[round_idx]))
        self_cooperated = int(history.my_actions[round_idx])
        return opponent_cooperators + self_cooperated

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        """Decision logic for the final round."""
        last_round_cooperators = self._count_cooperators(history, history.round_number - 1)
        high_threshold = int(math.ceil(2 * self.n / 3))
        if last_round_cooperators >= high_threshold:
            return Action.C
        majority_threshold = int(math.ceil(self.n / 2))
        high_coop_rounds = 0
        for round_idx in range(history.round_number):
            if self._count_cooperators(history, round_idx) >= majority_threshold:
                high_coop_rounds += 1
        total_previous_rounds = history.round_number
        if high_coop_rounds >= 0.75 * total_previous_rounds:
            return Action.C
        return Action.D

    def _middle_round_decision(self, history: PlayerHistory) -> Action:
        """Decision logic for middle rounds (2 to r-1)."""
        current_round = history.round_number + 1
        last_cooperators = self._count_cooperators(history, history.round_number - 1)
        majority_threshold = int(math.ceil(self.n / 2))
        if last_cooperators >= majority_threshold:
            return Action.C
        if current_round >= 3 and history.round_number >= 2:
            prev_cooperators = self._count_cooperators(history, history.round_number - 2)
            if last_cooperators > prev_cooperators:
                return Action.C
        if current_round >= 3:
            if history.round_number >= 2:
                prev_round_cooperators = self._count_cooperators(history, history.round_number - 2)
                if prev_round_cooperators >= majority_threshold:
                    return Action.C
        return Action.D

class Strategy_COOPERATIVE_108(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperation while being resilient to 
    occasional defections. It starts cooperatively, responds to group cooperation rates,
    includes forgiveness mechanisms, and has end-game protection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_rounds = 0
        self.currently_punishing = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == total_rounds:
            last_round_idx = history.round_number - 1
            cooperators_last_round = sum(history.opponent_actions[last_round_idx])
            if history.my_actions[last_round_idx]:
                cooperators_last_round += 1
            cooperation_rate = cooperators_last_round / n_players
            if cooperation_rate >= 0.7:
                return Action.C
            else:
                return Action.D
        else:
            last_round_idx = history.round_number - 1
            cooperators_last_round = sum(history.opponent_actions[last_round_idx])
            if history.my_actions[last_round_idx]:
                cooperators_last_round += 1
            cooperation_rate = cooperators_last_round / n_players
            if self.currently_punishing:
                if self.punishment_rounds >= 1:
                    self.currently_punishing = False
                    self.punishment_rounds = 0
                    return Action.C
                else:
                    self.punishment_rounds += 1
                    return Action.D
            elif cooperation_rate >= 0.5:
                return Action.C
            else:
                self.currently_punishing = True
                self.punishment_rounds = 1
                return Action.D

class Strategy_COOPERATIVE_109(BaseStrategy):
    """
    Graduated Reciprocator: An adaptive cooperative strategy for N-Player Public Goods Game.
    
    Starts optimistically, then adapts based on group cooperation rates using graduated thresholds.
    Cooperates when group cooperation is high (≥60%), uses conditional cooperation when moderate 
    (30-59%), and defects when low (<30%). Includes forgiveness mechanism and exploitation protection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / n
        if current_round == self.game_description.n_rounds:
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.6:
            return Action.C
        elif cooperation_rate >= 0.3:
            my_last_payoff = history.my_payoffs[last_round_idx]
            baseline_payoff = 1.0
            if my_last_action and my_last_payoff >= baseline_payoff:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_110(BaseStrategy):
    """
    Graduated Reciprocation with Forgiveness strategy for N-Player Public Goods Game.
    
    This strategy operates in three phases:
    1. Establishment Phase: Build trust and signal cooperative intent
    2. Maintenance Phase: Reciprocate cooperation while deterring exploitation
    3. Endgame Phase: Handle final rounds strategically
    
    Uses graduated thresholds and forgiveness mechanisms to maintain cooperation
    while protecting against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        cooperation_rate = last_round_cooperators / self.n_players
        establishment_rounds = min(3, int(self.n_rounds * 0.2))
        if current_round <= establishment_rounds:
            if cooperation_rate >= 0.3:
                return Action.C
            else:
                return Action.D
        if current_round == self.n_rounds:
            return Action.D
        if current_round == self.n_rounds - 1:
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        my_previous_action = history.my_actions[last_round_idx]
        if cooperation_rate >= 0.4:
            return Action.C
        elif not my_previous_action and cooperation_rate >= 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_111(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) strategy for N-Player Public Goods Game.
    
    This strategy starts cooperatively and maintains cooperation based on group cooperation rates,
    with a forgiveness mechanism to handle temporary coordination failures and dynamic thresholds
    that adapt to game parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_low_cooperation = 0
        self.dynamic_threshold = max(0.3, (self.game_description.k - 1) / (self.game_description.n_players - 1))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_low_cooperation = 0
            return Action.C
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == n_rounds:
            return self._final_round_decision(history)
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
        cooperation_rate_last_round = cooperators_last_round / n_players
        if cooperation_rate_last_round >= self.dynamic_threshold:
            self.consecutive_low_cooperation = 0
            return Action.C
        else:
            self.consecutive_low_cooperation += 1
            if self.consecutive_low_cooperation <= 2:
                return Action.C
            else:
                return Action.D

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        """Make decision for the final round based on recent cooperation patterns."""
        n_players = self.game_description.n_players
        rounds_completed = history.round_number
        rounds_to_check = min(3, rounds_completed)
        total_cooperation_rate = 0.0
        for i in range(rounds_to_check):
            round_idx = rounds_completed - 1 - i
            cooperators_in_round = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
            cooperation_rate = cooperators_in_round / n_players
            total_cooperation_rate += cooperation_rate
        recent_cooperation_rate = total_cooperation_rate / rounds_to_check
        if recent_cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_112(BaseStrategy):
    """
    Graduated Reciprocal Cooperation Strategy.
    
    Always cooperates in round 1, then adapts based on group cooperation rate:
    - If coop_rate >= 0.5: Always cooperate
    - If 0.3 <= coop_rate < 0.5: Cooperate probabilistically based on coop_rate
    - If coop_rate < 0.3: Always defect
    - Final round: Cooperate if average cooperation across all rounds >= 0.6
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds:
            total_cooperators = 0
            total_opportunities = 0
            for round_idx in range(history.round_number):
                if history.my_actions[round_idx]:
                    total_cooperators += 1
                total_opportunities += 1
                round_cooperators = sum(history.opponent_actions[round_idx])
                total_cooperators += round_cooperators
                total_opportunities += n_players - 1
            avg_coop_rate = total_cooperators / total_opportunities if total_opportunities > 0 else 0
            if avg_coop_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        coop_rate = total_cooperators / n_players
        if coop_rate >= 0.5:
            return Action.C
        elif coop_rate >= 0.3:
            if random.random() < coop_rate:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_113(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness: A cooperative strategy that starts by cooperating,
    maintains cooperation when majority cooperates (≥50%), but includes forgiveness mechanisms
    and graduated responses to defection to encourage cooperative recovery.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx]) + (1 if history.my_actions[prev_round_idx] else 0)
        prev_coop_rate = prev_cooperators / n_players
        if current_round == n_rounds:
            if n_rounds >= 3:
                start_idx = max(0, history.round_number - 3)
                total_coop = 0
                count_rounds = 0
                for i in range(start_idx, history.round_number):
                    round_cooperators = sum(history.opponent_actions[i]) + (1 if history.my_actions[i] else 0)
                    total_coop += round_cooperators / n_players
                    count_rounds += 1
                recent_coop_rate = total_coop / count_rounds if count_rounds > 0 else prev_coop_rate
            else:
                recent_coop_rate = prev_coop_rate
            if recent_coop_rate >= 0.6:
                return Action.C
            elif recent_coop_rate >= 0.3:
                return Action.C if random.random() < 0.5 else Action.D
            else:
                return Action.D
        if prev_coop_rate >= 0.5:
            return Action.C
        else:
            if history.round_number > 0 and (not history.my_actions[prev_round_idx]) and (prev_coop_rate >= 0.4):
                return Action.C
            return Action.C if random.random() < 0.3 else Action.D

class Strategy_COOPERATIVE_114(BaseStrategy):
    """
    Forgiving Majority Follower strategy for N-Player Public Goods Game.
    
    Cooperates in round 1, defects in final round, and follows the majority
    from the previous round in middle rounds. This balances cooperation
    with protection against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_index = history.round_number - 1
        my_last_action = history.my_actions[last_round_index]
        opponent_cooperators = sum(history.opponent_actions[last_round_index])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / self.game_description.n_players
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_115(BaseStrategy):
    """
    Graduated Reciprocator strategy for N-Player Public Goods Game.
    
    Balances cooperation and defection based on recent group cooperation rates,
    with forgiveness mechanism to escape defection cycles and end-game awareness.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.15

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            window_size = min(3, history.round_number)
            start_round = max(0, history.round_number - window_size)
            total_cooperations = 0
            for round_idx in range(start_round, history.round_number):
                if history.my_actions[round_idx]:
                    total_cooperations += 1
                total_cooperations += sum(history.opponent_actions[round_idx])
            recent_cooperation_rate = total_cooperations / (n * window_size)
            return Action.C if recent_cooperation_rate >= 0.7 else Action.D
        window_size = min(3, history.round_number)
        start_round = max(0, history.round_number - window_size)
        total_cooperations = 0
        for round_idx in range(start_round, history.round_number):
            if history.my_actions[round_idx]:
                total_cooperations += 1
            total_cooperations += sum(history.opponent_actions[round_idx])
        recent_cooperation_rate = total_cooperations / (n * window_size)
        if recent_cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif random.random() <= self.forgiveness_probability:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_116(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF) Strategy
    
    Establishes and maintains cooperation while being resilient to occasional defections.
    Starts cooperatively, forgives up to 2 consecutive rounds of low cooperation,
    and uses historical cooperation rate for final round decisions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_low_cooperation = 0
        self.cooperation_threshold = 0.5
        self.forgiveness_limit = 2
        self.final_round_threshold = 0.6

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_low_cooperation = 0
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            total_cooperators = 0
            total_possible_cooperators = 0
            for round_idx in range(history.round_number):
                round_cooperators = int(history.my_actions[round_idx])
                round_cooperators += sum(history.opponent_actions[round_idx])
                total_cooperators += round_cooperators
                total_possible_cooperators += self.game_description.n_players
            historical_coop_rate = total_cooperators / total_possible_cooperators if total_possible_cooperators > 0 else 0
            if historical_coop_rate >= self.final_round_threshold:
                return Action.C
            else:
                return Action.D
        else:
            last_round_idx = history.round_number - 1
            last_round_cooperators = sum(history.opponent_actions[last_round_idx])
            last_round_coop_rate = last_round_cooperators / (self.game_description.n_players - 1)
            if last_round_coop_rate >= self.cooperation_threshold:
                self.consecutive_low_cooperation = 0
                return Action.C
            else:
                self.consecutive_low_cooperation += 1
                if self.consecutive_low_cooperation >= self.forgiveness_limit + 1:
                    return Action.D
                else:
                    return Action.C

class Strategy_COOPERATIVE_117(BaseStrategy):
    """
    Forgiving Majority Follower strategy for N-Player Public Goods Game.
    
    This strategy aims to establish and maintain cooperation by following the majority's lead 
    while being forgiving of occasional defections. It balances cooperation with protection 
    against exploitation through adaptive majority following and self-preservation mechanisms.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return self._final_round_decision(history)
        majority_threshold = math.ceil(n / 2)
        recent_cooperators = self._count_recent_cooperators(history)
        cooperation_trend = self._calculate_cooperation_trend(history)
        if self._should_self_preserve(history):
            return Action.D
        if recent_cooperators >= majority_threshold:
            return Action.C
        elif recent_cooperators >= majority_threshold - 1 and cooperation_trend > 0:
            return Action.C
        else:
            return Action.C

    def _final_round_decision(self, history: PlayerHistory) -> Action:
        """Decide action for the final round."""
        n = self.game_description.n_players
        total_rounds = history.round_number
        total_cooperators = 0
        for round_idx in range(total_rounds):
            total_cooperators += sum(history.opponent_actions[round_idx])
            if history.my_actions[round_idx]:
                total_cooperators += 1
        total_possible = total_rounds * n
        cooperation_rate = total_cooperators / total_possible if total_possible > 0 else 0
        if cooperation_rate >= 0.6:
            return Action.C
        recent_cooperators = self._count_recent_cooperators(history)
        majority_threshold = math.ceil(n / 2)
        if recent_cooperators >= majority_threshold:
            return Action.C
        else:
            return Action.D

    def _count_recent_cooperators(self, history: PlayerHistory) -> int:
        """Count cooperators in the most recent round."""
        if history.round_number == 0:
            return 0
        last_round_idx = history.round_number - 1
        return sum(history.opponent_actions[last_round_idx])

    def _calculate_cooperation_trend(self, history: PlayerHistory) -> float:
        """Calculate cooperation trend over recent rounds."""
        rounds_to_analyze = min(3, history.round_number)
        if rounds_to_analyze < 2:
            return 0
        recent_cooperators = []
        for i in range(rounds_to_analyze):
            round_idx = history.round_number - 1 - i
            if round_idx >= 0:
                cooperators = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    cooperators += 1
                recent_cooperators.append(cooperators)
        if len(recent_cooperators) < 2:
            return 0
        recent_avg = sum(recent_cooperators[:len(recent_cooperators) // 2]) / max(1, len(recent_cooperators) // 2)
        earlier_avg = sum(recent_cooperators[len(recent_cooperators) // 2:]) / max(1, len(recent_cooperators) - len(recent_cooperators) // 2)
        return recent_avg - earlier_avg

    def _should_self_preserve(self, history: PlayerHistory) -> bool:
        """Check if self-preservation clause should trigger."""
        current_round = history.round_number
        if current_round == 0:
            return False
        my_cumulative_payoff = sum(history.my_payoffs)
        baseline_payoff = current_round * 1.0
        return my_cumulative_payoff < baseline_payoff * 0.8

class Strategy_COOPERATIVE_118(BaseStrategy):
    """
    Graduated Reciprocal Cooperation (GRC) Strategy
    
    A cooperative strategy that aims to establish and maintain cooperative equilibria
    while being resilient to exploitation. Uses adaptive thresholds based on observed
    cooperation rates and includes recovery mechanisms.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        prev_round_idx = history.round_number - 1
        prev_coop_count = sum(history.opponent_actions[prev_round_idx]) + (1 if history.my_actions[prev_round_idx] else 0)
        prev_coop_rate = prev_coop_count / n
        if current_round == r:
            return Action.C if prev_coop_rate >= 0.6 else Action.D
        if prev_coop_rate >= 0.8:
            return Action.C
        if history.round_number >= 2:
            round_1_idx = history.round_number - 1
            round_2_idx = history.round_number - 2
            coop_count_1 = sum(history.opponent_actions[round_1_idx]) + (1 if history.my_actions[round_1_idx] else 0)
            coop_count_2 = sum(history.opponent_actions[round_2_idx]) + (1 if history.my_actions[round_2_idx] else 0)
            coop_rate_1 = coop_count_1 / n
            coop_rate_2 = coop_count_2 / n
            if coop_rate_1 < 0.3 and coop_rate_2 < 0.3:
                return Action.C
        if history.round_number >= 2:
            round_1_idx = history.round_number - 1
            round_2_idx = history.round_number - 2
            coop_count_1 = sum(history.opponent_actions[round_1_idx]) + (1 if history.my_actions[round_1_idx] else 0)
            coop_count_2 = sum(history.opponent_actions[round_2_idx]) + (1 if history.my_actions[round_2_idx] else 0)
            coop_rate_1 = coop_count_1 / n
            coop_rate_2 = coop_count_2 / n
            if not history.my_actions[round_1_idx] and coop_rate_1 - coop_rate_2 >= 0.3:
                return Action.C
        cooperation_threshold = max(0.5, prev_coop_rate - 0.1)
        return Action.C if prev_coop_rate >= cooperation_threshold else Action.D

class Strategy_COOPERATIVE_119(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Starts cooperatively, adapts to group cooperation rates with forgiveness mechanisms,
    and includes brief punishment for severe exploitation while maintaining overall
    cooperative stance.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_countdown = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if current_round == r:
            historical_coop_rates = []
            for round_idx in range(history.round_number):
                cooperators = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    cooperators += 1
                coop_rate = cooperators / n
                historical_coop_rates.append(coop_rate)
            if len(historical_coop_rates) > 0:
                overall_coop_rate = sum(historical_coop_rates) / len(historical_coop_rates)
                if overall_coop_rate >= 0.4:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        prev_round_idx = history.round_number - 1
        prev_round_cooperators = sum(history.opponent_actions[prev_round_idx])
        if history.my_actions[prev_round_idx]:
            prev_round_cooperators += 1
        prev_round_coop_rate = prev_round_cooperators / n
        if self.punishment_countdown > 0:
            self.punishment_countdown -= 1
            return Action.C
        if prev_round_coop_rate >= 0.5:
            return Action.C
        elif prev_round_coop_rate < 0.25:
            self.punishment_countdown = 1
            return Action.D
        else:
            rounds_to_check = min(3, history.round_number)
            recent_coop_rates = []
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                cooperators = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    cooperators += 1
                coop_rate = cooperators / n
                recent_coop_rates.append(coop_rate)
            if len(recent_coop_rates) >= 2:
                recent_trend = recent_coop_rates[0] - recent_coop_rates[-1]
            else:
                recent_trend = 0
            if recent_trend >= 0 or random.random() < 0.3:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_120(BaseStrategy):
    """
    Generous Tit-for-Tat with Gradual Forgiveness strategy.
    
    Starts cooperatively, then cooperates when majority cooperated last round.
    Has a forgiveness mechanism for up to 2 rounds of low cooperation.
    Final round decision based on overall cooperation rate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.forgiveness_counter = 0
        self.max_forgiveness = 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.forgiveness_counter = 0
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        cooperation_threshold = n_players / 2
        if current_round == n_rounds:
            total_cooperations = 0
            total_opportunities = 0
            for round_idx in range(history.round_number):
                my_cooperation = 1 if history.my_actions[round_idx] else 0
                opponent_cooperations = sum(history.opponent_actions[round_idx])
                total_cooperations += my_cooperation + opponent_cooperations
                total_opportunities += n_players
            cooperation_rate = total_cooperations / total_opportunities if total_opportunities > 0 else 0
            if cooperation_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        else:
            last_round_idx = history.round_number - 1
            my_last_cooperation = 1 if history.my_actions[last_round_idx] else 0
            opponent_cooperations = sum(history.opponent_actions[last_round_idx])
            cooperators_last_round = my_last_cooperation + opponent_cooperations
            if cooperators_last_round >= cooperation_threshold:
                self.forgiveness_counter = 0
                return Action.C
            elif self.forgiveness_counter < self.max_forgiveness:
                self.forgiveness_counter += 1
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_121(BaseStrategy):
    """
    Forgiving Majority Follower: A cooperative strategy that follows the majority
    with forgiveness for temporary defections and endgame considerations.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_minority_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_minority_rounds = 0
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        if current_round == total_rounds:
            lenient_threshold = max(1, n // 3)
            if total_cooperators >= lenient_threshold:
                return Action.C
            else:
                return Action.D
        majority_threshold = (n + 1) // 2
        if total_cooperators >= majority_threshold:
            self.consecutive_minority_rounds = 0
            return Action.C
        else:
            self.consecutive_minority_rounds += 1
            if self.consecutive_minority_rounds <= 2:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_122(BaseStrategy):
    """
    Forgiving Majority Follower strategy for N-Player Public Goods Game.
    
    Cooperates in round 1, then follows the majority from the previous round.
    In the final round, cooperates if majority cooperated (including ties).
    In middle rounds, defects on ties for conservative protection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            if total_cooperators >= n_players / 2:
                return Action.C
            else:
                return Action.D
        elif total_cooperators > n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_123(BaseStrategy):
    """
    Generous Tit-for-Majority: A cooperative strategy that follows the majority's behavior
    from the previous round with a generous bias toward cooperation and forgiveness mechanism.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n = self.game_description.n_players
        final_round = self.game_description.n_rounds
        if current_round == final_round:
            last_round_idx = history.round_number - 1
            cooperators_last_round = sum(history.opponent_actions[last_round_idx])
            if history.my_actions[last_round_idx]:
                cooperators_last_round += 1
            cooperation_rate = cooperators_last_round / n
            return Action.C if cooperation_rate >= 0.5 else Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        majority_threshold = n / 2
        if cooperators_last_round >= majority_threshold:
            return Action.C
        elif random.random() < 0.2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_124(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Cooperates in round 1, then cooperates when majority (≥50%) cooperated in previous round.
    Includes 10% forgiveness probability and escalated punishment for sustained low cooperation.
    Always defects in final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.1
        self.consecutive_low_cooperation = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_low_cooperation = 0
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / self.game_description.n_players
        if cooperation_rate >= self.cooperation_threshold:
            self.consecutive_low_cooperation = 0
            return Action.C
        else:
            self.consecutive_low_cooperation += 1
            if random.random() < self.forgiveness_probability:
                return Action.C
            elif self.consecutive_low_cooperation >= 3:
                return Action.D
            else:
                return Action.D

class Strategy_COOPERATIVE_125(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness: A cooperative strategy that starts by cooperating
    and maintains cooperation when at least 50% of players cooperated in the previous round.
    Includes forgiveness mechanisms to give second chances and recognize partial cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        my_prev_action = int(history.my_actions[prev_round_idx])
        opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        total_cooperators = my_prev_action + opponent_cooperators
        prev_cooperation_rate = total_cooperators / n_players
        if current_round == n_rounds:
            return Action.C if prev_cooperation_rate >= 0.4 else Action.D
        if prev_cooperation_rate >= 0.5:
            return Action.C
        consecutive_low_cooperation = False
        if history.round_number >= 2:
            second_prev_round_idx = history.round_number - 2
            my_second_prev_action = int(history.my_actions[second_prev_round_idx])
            opponent_cooperators_second = sum(history.opponent_actions[second_prev_round_idx])
            total_cooperators_second = my_second_prev_action + opponent_cooperators_second
            second_prev_cooperation_rate = total_cooperators_second / n_players
            consecutive_low_cooperation = second_prev_cooperation_rate < 0.5
        if not consecutive_low_cooperation or prev_cooperation_rate >= 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_126(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness for N-Player Public Goods Game.
    
    Starts cooperative, responds to group cooperation levels with forgiveness,
    and includes endgame considerations. Cooperates when majority cooperated
    in previous round, with forgiveness for first instance of low cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_low_cooperation_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            total_cooperators = 0
            total_rounds = history.round_number
            for round_idx in range(total_rounds):
                my_cooperation = 1 if history.my_actions[round_idx] else 0
                opponent_cooperators = sum(history.opponent_actions[round_idx])
                total_cooperators += my_cooperation + opponent_cooperators
            overall_cooperation_rate = total_cooperators / (total_rounds * self.game_description.n_players)
            if overall_cooperation_rate > 0.6:
                return Action.C
            else:
                return Action.D
        else:
            last_round_idx = history.round_number - 1
            my_last_cooperation = 1 if history.my_actions[last_round_idx] else 0
            opponent_cooperators = sum(history.opponent_actions[last_round_idx])
            total_cooperators = my_last_cooperation + opponent_cooperators
            cooperation_rate = total_cooperators / self.game_description.n_players
            if cooperation_rate > 0.5:
                self.consecutive_low_cooperation_rounds = 0
                return Action.C
            else:
                self.consecutive_low_cooperation_rounds += 1
                if self.consecutive_low_cooperation_rounds <= 1:
                    return Action.C
                else:
                    return Action.D

class Strategy_COOPERATIVE_127(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness (GTTF)
    
    A cooperative strategy that starts with cooperation and responds to the group's
    cooperation level with built-in forgiveness and recovery mechanisms.
    - Cooperates if ≥50% of opponents cooperated last round
    - Limited punishment (max 2 rounds) with 10% forgiveness probability
    - Automatic reset after punishment period to re-establish cooperation
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.forgiveness_probability = 0.1
        self.punishment_rounds = 2
        self.punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_counter = 0
            return Action.C
        current_round = history.round_number
        n_opponents = self.game_description.n_players - 1
        last_round_cooperators = sum(history.opponent_actions[current_round - 1])
        cooperation_rate = last_round_cooperators / n_opponents
        is_last_round = current_round >= self.game_description.n_rounds - 1
        if cooperation_rate >= self.cooperation_threshold:
            self.punishment_counter = 0
            return Action.C
        elif self.punishment_counter < self.punishment_rounds:
            self.punishment_counter += 1
            if random.random() < self.forgiveness_probability:
                self.punishment_counter = 0
                return Action.C
            else:
                return Action.D
        else:
            self.punishment_counter = 0
            return Action.C

class Strategy_COOPERATIVE_128(BaseStrategy):
    """
    Generous Tit-for-Tat with Forgiveness strategy for N-Player Public Goods Game.
    
    Balances cooperation with protection against exploitation through adaptive reciprocity,
    forgiveness mechanisms, and majority-based thresholds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds:
            rounds_to_check = min(3, history.round_number)
            start_round = history.round_number - rounds_to_check
            total_cooperation = 0
            total_possible = 0
            for round_idx in range(start_round, history.round_number):
                if history.my_actions[round_idx]:
                    total_cooperation += 1
                total_possible += 1
                for opponent_idx in range(n_players - 1):
                    if history.opponent_actions[round_idx, opponent_idx]:
                        total_cooperation += 1
                    total_possible += 1
            avg_cooperation_rate = total_cooperation / total_possible if total_possible > 0 else 0
            if avg_cooperation_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = 0
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        for opponent_idx in range(n_players - 1):
            if history.opponent_actions[last_round_idx, opponent_idx]:
                cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / n_players
        if current_round % 3 == 0:
            recent_rounds = min(3, history.round_number)
            my_recent_defections = 0
            for i in range(history.round_number - recent_rounds, history.round_number):
                if not history.my_actions[i]:
                    my_recent_defections += 1
            if my_recent_defections >= recent_rounds * 0.67:
                return Action.C
        if cooperation_rate >= 0.5:
            return Action.C
        elif cooperation_rate >= 0.3:
            if random.random() < 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_1(BaseStrategy):
    """
    Aggressive Exploit-First Punisher strategy for N-Player Public Goods Game.
    
    This strategy maximizes personal payoffs through aggressive exploitation while maintaining
    credible punishment mechanisms. It exploits cooperative players early and often, only
    cooperating when strategically necessary to maintain exploitation opportunities.
    
    Key features:
    - Always defects in first 2 rounds and last 2 rounds
    - Exploits high cooperation environments by defecting
    - Uses occasional cooperation to maintain just enough trust
    - Implements swift retaliation against defection
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round <= 2:
            return Action.D
        if current_round >= total_rounds - 1:
            return Action.D
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        if history.round_number >= 1:
            last_round_idx = history.round_number - 1
            if history.my_actions[last_round_idx]:
                if not all(history.opponent_actions[last_round_idx]):
                    self.punishment_counter = 1
                    return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / n_players
        if cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate >= 0.3:
            if current_round % 3 == 0:
                return Action.C
            else:
                return Action.D
        else:
            consecutive_defections = 0
            for i in range(min(3, history.round_number)):
                round_idx = history.round_number - 1 - i
                if not history.my_actions[round_idx]:
                    consecutive_defections += 1
                else:
                    break
            if consecutive_defections >= 3:
                return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_2(BaseStrategy):
    """
    AGGRESSIVE EXPLOITATION STRATEGY: "PREDATOR"
    
    Operates on maximum exploitation principle - free-rides on others' cooperation
    while minimizing own contributions. Uses dynamic thresholds and endgame effects
    to maximize payoff through strategic defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.6 * game_description.n_players
        self.exploitation_mode = True

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == total_rounds:
            return Action.D
        cooperators_last_round = sum(history.opponent_actions[history.round_number - 1])
        total_cooperators_history = 0
        for round_idx in range(history.round_number):
            total_cooperators_history += sum(history.opponent_actions[round_idx])
        avg_cooperation_rate = total_cooperators_history / (history.round_number * (n_players - 1))
        remaining_rounds = total_rounds - current_round
        if current_round > 0.7 * total_rounds:
            self.cooperation_threshold = self.cooperation_threshold * 1.2
            return Action.D
        if cooperators_last_round >= self.cooperation_threshold and avg_cooperation_rate >= 0.7 and (remaining_rounds >= 3):
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_3(BaseStrategy):
    """
    Aggressive Exploit-First Reciprocator strategy that exploits cooperators while maintaining
    enough reciprocal behavior to avoid complete collapse of cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        n_opponents = self.game_description.n_players - 1
        last_round_coop_rate = last_round_cooperators / n_opponents
        if current_round == total_rounds - 1:
            return Action.C if last_round_coop_rate >= 0.3 else Action.D
        if last_round_coop_rate > 0.5:
            return Action.D
        elif last_round_coop_rate == 0:
            return Action.C
        else:
            my_relative_score = self._get_relative_performance(history)
            return Action.D if my_relative_score >= 0 else Action.C

    def _get_relative_performance(self, history: PlayerHistory) -> float:
        """Calculate relative performance compared to average opponent score."""
        my_total_score = sum(history.my_payoffs)
        n_opponents = self.game_description.n_players - 1
        opponent_total_scores = [sum(history.opponent_payoffs[:, i]) for i in range(n_opponents)]
        avg_opponent_score = sum(opponent_total_scores) / n_opponents if n_opponents > 0 else 0
        return my_total_score - avg_opponent_score

class Strategy_AGGRESSIVE_4(BaseStrategy):
    """
    Exploitation Hunter: Aggressive strategy that maximizes individual payoff by exploiting 
    cooperative players while minimizing personal contributions. Cooperates only when enough 
    others are already cooperating to make it profitable, with guaranteed final round defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_streak = 0
        self.last_cooperator_count = 0
        self.declining_cooperation_rounds = 0
        self.cooperation_threshold = math.ceil((game_description.n_players + 1) / game_description.k)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        most_recent_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[most_recent_round_idx])
        my_previous_action = 1 if history.my_actions[most_recent_round_idx] else 0
        total_cooperators = opponent_cooperators + my_previous_action
        if total_cooperators < self.last_cooperator_count:
            self.declining_cooperation_rounds += 1
        else:
            self.declining_cooperation_rounds = 0
        if total_cooperators >= self.cooperation_threshold and self.declining_cooperation_rounds < 3:
            self.defection_streak = 0
            self.last_cooperator_count = total_cooperators
            return Action.C
        else:
            self.defection_streak += 1
            self.last_cooperator_count = total_cooperators
            return Action.D

class Strategy_AGGRESSIVE_5(BaseStrategy):
    """
    Exploitative Punisher: An aggressive strategy that maximizes individual payoffs 
    through exploitation while maintaining credible punishment mechanisms. Only 
    cooperates when almost everyone else is already cooperating, ensuring maximum 
    benefit while minimizing personal costs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        current_round = history.round_number + 1
        if r <= 5:
            return Action.D
        if current_round == r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / n
        punishment_threshold = 1.0 / (2.0 * n)
        if cooperation_rate < punishment_threshold:
            self.punishment_rounds_remaining = min(3, r - current_round)
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        exploitation_threshold = (n - 1.0) / n
        if n == 2:
            opponent_cooperated = history.opponent_actions[last_round_idx, 0]
            if opponent_cooperated and current_round <= r - 3:
                return Action.C
            else:
                return Action.D
        if k >= n - 1:
            exploitation_threshold = (n - 2.0) / n
        if current_round > 0.75 * r:
            exploitation_threshold = (n - 0.5) / n
        if cooperation_rate >= exploitation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_6(BaseStrategy):
    """
    Exploitative Punisher: An aggressive strategy that systematically exploits 
    cooperative opponents while maintaining punishment threats. Always defects 
    initially and in endgame, exploits high cooperation environments, and uses 
    minimal strategic cooperation only to restart exploitable cycles.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_low_cooperation_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            total_cooperators_last_round = last_round_cooperators + 1
        else:
            total_cooperators_last_round = last_round_cooperators
        cooperation_rate = total_cooperators_last_round / self.game_description.n_players
        my_advantage = last_round_cooperators / (self.game_description.n_players - 1)
        if cooperation_rate < 0.2:
            self.consecutive_low_cooperation_rounds += 1
        else:
            self.consecutive_low_cooperation_rounds = 0
        if cooperation_rate >= 0.5:
            return Action.D
        if cooperation_rate >= 0.3 and my_advantage >= 0.4:
            return Action.D
        if cooperation_rate < 0.2:
            if self.consecutive_low_cooperation_rounds >= 3:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_7(BaseStrategy):
    """
    Aggressive Exploitative Defector with Punishment - designed to maximize personal payoff 
    by exploiting cooperative players while maintaining consistent defection strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / n
        my_last_payoff = history.my_payoffs[last_round_idx]
        opponent_payoffs_last_round = history.opponent_payoffs[last_round_idx]
        average_opponent_payoff = sum(opponent_payoffs_last_round) / len(opponent_payoffs_last_round)
        my_payoff_advantage = my_last_payoff - average_opponent_payoff
        if cooperation_rate >= 0.5 and my_payoff_advantage < 0.5:
            return Action.D
        elif cooperation_rate < 0.3:
            return Action.D
        elif cooperation_rate >= 0.7:
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_8(BaseStrategy):
    """
    Aggressive Strategy: "Exploitation Maximizer"
    
    This strategy operates on the principle of maximizing personal payoff by exploiting 
    cooperation from others while minimizing personal contributions. It uses strategic 
    defection as the default with carefully timed cooperation only when it serves 
    exploitation objectives.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        if current_round == r - 1:
            return Action.D
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_threshold = n / 2
        if opponent_cooperators < cooperation_threshold:
            return Action.D
        my_last_payoff = history.my_payoffs[last_round_idx]
        if my_last_action:
            hypothetical_defect_payoff = 1 + k / n * total_cooperators
            if hypothetical_defect_payoff > my_last_payoff:
                return Action.D
        else:
            hypothetical_coop_payoff = 0 + k / n * total_cooperators
            if my_last_payoff <= hypothetical_coop_payoff:
                return Action.D
        rounds_to_check = min(3, history.round_number)
        recent_cooperation_rate = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            recent_cooperation_rate += sum(history.opponent_actions[round_idx])
        expected_future_cooperators = recent_cooperation_rate / rounds_to_check
        if opponent_cooperators >= 0.75 * n:
            return Action.C
        if opponent_cooperators <= 0.25 * n:
            return Action.D
        if opponent_cooperators >= cooperation_threshold and my_last_payoff > 0 + k / n * total_cooperators and (expected_future_cooperators >= cooperation_threshold):
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_9(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    Maximizes personal gain by free-riding on others' cooperation while contributing
    as little as possible. Exploits cooperative patterns and minimizes punishment
    through strategic one-shot cooperation only when absolutely necessary.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        rounds_remaining = r - current_round
        if current_round == r:
            return Action.D
        if current_round == r - 1:
            return Action.D
        if current_round >= 2 and current_round <= r - 2:
            prev_round_idx = history.round_number - 1
            prev_opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
            prev_total_cooperators = prev_opponent_cooperators
            if history.my_actions[prev_round_idx]:
                prev_total_cooperators += 1
                my_previous_action = Action.C
            else:
                my_previous_action = Action.D
            cooperation_rate = prev_total_cooperators / n
            if cooperation_rate > 0.6 and my_previous_action == Action.D:
                return Action.D
            elif cooperation_rate < 0.3 and my_previous_action == Action.C:
                if rounds_remaining >= 3:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_10(BaseStrategy):
    """
    Ruthless Exploiter: An aggressive strategy that maximally exploits cooperative players
    while minimizing own contributions. Defects by default, only cooperating tactically
    when falling behind in payoffs to stimulate others for future exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_actions_last = history.opponent_actions[last_round_idx]
        cooperators_last = int(my_last_action) + int(sum(opponent_actions_last))
        my_payoff = self._calculate_payoff(my_last_action, cooperators_last)
        avg_payoff = self._calculate_average_payoff(my_last_action, opponent_actions_last, cooperators_last)
        if cooperators_last >= self.n / 2:
            return Action.D
        elif cooperators_last > 0:
            if my_payoff < avg_payoff:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_payoff(self, my_action, total_cooperators):
        """Calculate payoff for a single round"""
        c_i = 1 if my_action else 0
        return 1 - c_i + self.k / self.n * total_cooperators

    def _calculate_average_payoff(self, my_action, opponent_actions, total_cooperators):
        """Calculate average payoff across all players for the last round"""
        total_payoff = 0
        c_i = 1 if my_action else 0
        total_payoff += 1 - c_i + self.k / self.n * total_cooperators
        for opponent_action in opponent_actions:
            c_j = 1 if opponent_action else 0
            total_payoff += 1 - c_j + self.k / self.n * total_cooperators
        return total_payoff / self.n

class Strategy_AGGRESSIVE_11(BaseStrategy):
    """
    Aggressive Strategy: "Exploitative Tit-for-Tat with First-Strike"
    
    This strategy maximizes individual payoffs by being selectively aggressive - 
    exploiting cooperative players while defending against aggressive ones.
    Always defects in first and last rounds, and uses exploitative logic in between.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        cooperation_rate_last_round = last_round_cooperators / self.game_description.n_players
        my_cooperation_last_round = history.my_actions[last_round_idx]
        if cooperation_rate_last_round >= 0.6:
            return Action.D
        if cooperation_rate_last_round <= 0.3:
            return Action.D
        if my_cooperation_last_round and cooperation_rate_last_round < 0.5:
            return Action.D
        if history.round_number >= 2:
            two_rounds_ago_idx = history.round_number - 2
            two_rounds_ago_cooperators = sum(history.opponent_actions[two_rounds_ago_idx])
            if history.my_actions[two_rounds_ago_idx]:
                two_rounds_ago_cooperators += 1
            cooperation_rate_two_rounds_ago = two_rounds_ago_cooperators / self.game_description.n_players
            if cooperation_rate_last_round > cooperation_rate_two_rounds_ago:
                return Action.D
        if current_round <= 3:
            if history.round_number >= 1 and history.my_actions[0] and (cooperation_rate_last_round < 0.4):
                return Action.D
        if current_round >= self.game_description.n_rounds - 1:
            if cooperation_rate_last_round <= 0.7:
                return Action.D
        return Action.C

class Strategy_AGGRESSIVE_12(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predatory Defector"
    
    This strategy maximizes individual payoff through aggressive exploitation while maintaining
    just enough unpredictability to avoid being easily countered. It operates in three phases:
    1. Early Reconnaissance: Always defect to establish dominance
    2. Aggressive Exploitation: Primarily defect with rare cooperation to maintain others' cooperation
    3. Terminal Aggression: Always defect in final rounds with no exceptions
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        early_phase_length = max(3, math.ceil(0.15 * total_rounds))
        terminal_phase_start = math.ceil(0.8 * total_rounds)
        if current_round <= early_phase_length:
            return Action.D
        if current_round >= terminal_phase_start:
            return Action.D
        if history.round_number > 0:
            last_round_idx = history.round_number - 1
            cooperators = sum(history.opponent_actions[last_round_idx])
            prev_cooperation_rate = cooperators / n_players
            if prev_cooperation_rate < 0.2 and random.random() < 0.3:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_13(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes personal payoffs 
    by exploiting cooperative players while minimizing vulnerability. Only cooperates 
    when mathematically advantageous based on cooperation thresholds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.cooperation_threshold = self.n - self.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            total_last_cooperators = last_round_cooperators + 1
        else:
            total_last_cooperators = last_round_cooperators
        if last_round_cooperators >= self.cooperation_threshold:
            cooperate_decision = True
        else:
            cooperate_decision = False
        if current_round >= 3:
            prev_round_idx = history.round_number - 2
            prev_cooperators = sum(history.opponent_actions[prev_round_idx])
            cooperation_trend = last_round_cooperators - prev_cooperators
            if cooperation_trend > 0 and last_round_cooperators >= self.cooperation_threshold:
                cooperate_decision = True
            elif cooperation_trend < 0:
                cooperate_decision = False
        if current_round >= 3:
            my_defections = sum((1 for action in history.my_actions if not action))
            my_defection_rate = my_defections / history.round_number
            total_other_cooperation = sum((sum(history.opponent_actions[r]) for r in range(history.round_number)))
            total_other_actions = (self.n - 1) * history.round_number
            avg_other_cooperation = total_other_cooperation / total_other_actions if total_other_actions > 0 else 0
            if my_defection_rate > 0.8 and avg_other_cooperation < 0.3:
                cooperate_decision = False
        if self.n == 2:
            if last_round_cooperators >= 1 and last_round_cooperators >= self.cooperation_threshold:
                cooperate_decision = True
            else:
                cooperate_decision = False
        if self.k > 0.8 * self.n:
            adjusted_threshold = max(1, self.cooperation_threshold - 1)
            if last_round_cooperators >= adjusted_threshold:
                cooperate_decision = True
        if self.r <= 3 and current_round > 1:
            if current_round == self.r:
                cooperate_decision = False
            elif current_round == 2 and last_round_cooperators >= self.n - 1:
                cooperate_decision = True
            else:
                cooperate_decision = False
        return Action.C if cooperate_decision else Action.D

class Strategy_AGGRESSIVE_14(BaseStrategy):
    """
    Predatory Exploiter: An aggressive strategy that maximizes personal payoff by 
    exploiting cooperative players while minimizing own contributions. Defects in 
    round 1 to scout for victims, then exploits high cooperation rates while 
    providing minimal reciprocity only when necessary to sustain exploitable 
    cooperation. Always defects in final 2 rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round >= total_rounds - 1:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / n_players
        if cooperation_rate >= 0.5:
            return Action.D
        if cooperation_rate >= 0.3:
            return Action.D
        if cooperation_rate >= 0.1:
            if self.cooperation_count < 2:
                self.cooperation_count += 1
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_15(BaseStrategy):
    """
    Ruthless Opportunist: An aggressive exploitation strategy that maximizes personal payoff
    by free-riding on cooperative opponents while minimizing vulnerability to retaliation.
    Always defects first and last, exploits high cooperation, and uses conditional participation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.cooperation_threshold = int(0.6 * self.n_players)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        if self.n_rounds - current_round <= 1:
            return Action.D
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if last_round_cooperators >= self.cooperation_threshold:
            return Action.D
        elif last_round_cooperators >= self.n_players / 2:
            if not history.my_actions[history.round_number - 1]:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_16(BaseStrategy):
    """
    Ruthless Exploiter: An aggressive strategy that maximizes personal payoffs by exploiting 
    cooperative players while minimizing exposure to exploitation. Always defects in round 1 
    and final rounds, exploits high cooperation rates, and only cooperates to reset the game 
    when cooperation has collapsed completely.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round >= self.r - 1:
            return Action.D
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        cooperation_rate = last_round_cooperators / (self.n - 1)
        my_cumulative_payoff = sum(history.my_payoffs)
        avg_opponent_payoff = sum((sum(history.opponent_payoffs[i]) for i in range(history.round_number))) / ((self.n - 1) * history.round_number)
        my_advantage = my_cumulative_payoff - avg_opponent_payoff
        if cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate >= 0.3 and my_advantage > 0:
            return Action.D
        else:
            rounds_to_check = min(3, history.round_number)
            recent_cooperation_rates = []
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                if round_idx >= 0:
                    round_cooperators = sum(history.opponent_actions[round_idx])
                    round_coop_rate = round_cooperators / (self.n - 1)
                    recent_cooperation_rates.append(round_coop_rate)
            if len(recent_cooperation_rates) >= 3 and all((rate < 0.2 for rate in recent_cooperation_rates)):
                return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_17(BaseStrategy):
    """
    Exploitative Dominator Strategy: Aggressively pursues defection while opportunistically 
    cooperating only when it can extract maximum value from others' cooperation. Always 
    defects in round 1 and final rounds, and only cooperates when cooperation rate exceeds 
    a high exploitation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.exploitation_threshold = max(0.6, self.k / self.n + 0.1)
        self.endgame_rounds = max(1, int(self.r / 5))
        self.minimum_advantage = 0.2
        self.critical_threshold = 0.3
        self.permanent_defection = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round > self.r - self.endgame_rounds:
            return Action.D
        if self.permanent_defection:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / (self.n - 1)
        if cooperation_rate < self.critical_threshold:
            self.permanent_defection = True
            return Action.D
        predicted_cooperators = self._estimate_next_round_cooperators(history)
        expected_payoff_if_cooperate = 0 + self.k / self.n * (predicted_cooperators + 1)
        expected_payoff_if_defect = 1 + self.k / self.n * predicted_cooperators
        cooperation_advantage = expected_payoff_if_cooperate - expected_payoff_if_defect
        if cooperation_rate >= self.exploitation_threshold and cooperation_advantage > self.minimum_advantage:
            return Action.C
        else:
            return Action.D

    def _estimate_next_round_cooperators(self, history: PlayerHistory) -> float:
        """
        Aggressively predict next round cooperators for exploitation.
        Assumes others will maintain or increase cooperation.
        """
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 0
        total_weighted_cooperation = 0
        total_weight = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            weight = rounds_to_check - i
            cooperators_in_round = sum(history.opponent_actions[round_idx])
            total_weighted_cooperation += weight * cooperators_in_round
            total_weight += weight
        avg_recent_cooperation = total_weighted_cooperation / total_weight
        predicted = min(self.n - 1, avg_recent_cooperation * 1.1)
        return predicted

class Strategy_AGGRESSIVE_18(BaseStrategy):
    """
    Predatory Exploiter: An aggressive strategy that maximizes individual payoffs through 
    strategic exploitation while maintaining just enough cooperation to keep others contributing.
    Uses three phases: initial exploitation, strategic manipulation, and end-game exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n = self.game_description.n_players
        if current_round <= 3:
            return Action.D
        if current_round > total_rounds - 3:
            return Action.D
        prev_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
        my_prev_action = history.my_actions[prev_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_prev_action else 0)
        cooperation_threshold_high = math.ceil(n / 2)
        cooperation_threshold_low = math.ceil(n / 3)
        if total_cooperators >= cooperation_threshold_high:
            return Action.D
        if total_cooperators < cooperation_threshold_low:
            return Action.C
        if random.random() < 0.8:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_19(BaseStrategy):
    """
    Aggressive Strategy: "Exploitative Defector with Punishment Cycles"
    
    This strategy maximizes personal payoff through aggressive exploitation while maintaining 
    strategic flexibility to punish cooperative players. It free-rides on cooperation, 
    crushes emerging cooperative patterns, and uses minimal strategic cooperation only 
    when beneficial.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if round_number == r:
            return Action.D
        if round_number == 2:
            return Action.D
        last_round_idx = history.round_number - 1
        opponent_actions_last = history.opponent_actions[last_round_idx]
        cooperator_count = sum(opponent_actions_last)
        if history.my_actions[last_round_idx]:
            cooperator_count += 1
        defector_count = n - cooperator_count
        if cooperator_count >= n / 2:
            return Action.D
        elif cooperator_count > 0 and self._was_increasing_cooperation(history):
            return Action.D
        elif cooperator_count == 0 and defector_count == n:
            if random.random() < 0.1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _was_increasing_cooperation(self, history: PlayerHistory) -> bool:
        """Check if cooperation has been increasing in recent rounds."""
        if history.round_number < 2:
            return False
        n = self.game_description.n_players
        last_round_idx = history.round_number - 1
        prev_round_idx = history.round_number - 2
        last_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_cooperators += 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx])
        if history.my_actions[prev_round_idx]:
            prev_cooperators += 1
        return last_cooperators > prev_cooperators

class Strategy_AGGRESSIVE_20(BaseStrategy):
    """
    Predatory Exploitation Strategy: Aggressively exploits cooperative players while 
    minimizing own contributions. Defects in initial rounds to establish reputation,
    occasionally cooperates only when group cooperation is high enough to make 
    free-riding profitable, and ends with pure defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_rounds_left = 0
        self.cooperation_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        if current_round == 2:
            return Action.D
        if current_round >= r - 1:
            return Action.D
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        last_round_idx = history.round_number - 1
        total_cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            total_cooperators_last_round += 1
        cooperation_rate = total_cooperators_last_round / n
        self.cooperation_count = sum(history.my_actions)
        if history.my_actions[last_round_idx] and cooperation_rate < 0.6:
            self.punishment_rounds_left = 2
            return Action.D
        cooperation_threshold = 0.75 if n <= 4 else 0.6
        if r <= 4:
            cooperation_threshold = 0.8
        if k > n - 1:
            cooperation_threshold = 0.5
        max_cooperations = current_round // 4
        if n <= 4:
            max_cooperations = max(1, current_round // 3)
        if k > n - 1:
            max_total_cooperations = max(1, r // 3)
            if self.cooperation_count >= max_total_cooperations:
                return Action.D
        min_other_cooperators = 3 if n >= 5 else 1
        other_cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if cooperation_rate >= cooperation_threshold and self.cooperation_count <= max_cooperations and (other_cooperators_last_round >= min_other_cooperators):
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_21(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes personal payoff by 
    exploiting cooperative players while minimizing personal contributions. Always defects 
    in first and last rounds, and exploits high-cooperation environments in between.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        n = self.game_description.n_players
        k = self.game_description.k
        if cooperators_last_round >= n / 2:
            if history.round_number >= 3:
                cooperation_counts = []
                for i in range(max(0, history.round_number - 3), history.round_number):
                    round_cooperators = sum(history.opponent_actions[i])
                    if history.my_actions[i]:
                        round_cooperators += 1
                    cooperation_counts.append(round_cooperators)
                if len(cooperation_counts) >= 2:
                    cooperation_trend_increasing = cooperation_counts[-1] > cooperation_counts[-2]
                    if len(cooperation_counts) >= 3:
                        cooperation_trend_increasing = cooperation_counts[-1] > cooperation_counts[-2] and cooperation_counts[-2] > cooperation_counts[-3]
                else:
                    cooperation_trend_increasing = False
                if cooperation_trend_increasing and cooperators_last_round >= (n - 1) / 2:
                    return Action.D
            optimal_cooperators = n * (k - 1) / k
            if cooperators_last_round >= optimal_cooperators:
                return Action.D
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_22(BaseStrategy):
    """
    Exploitative Punisher: An aggressive strategy that maximizes personal payoff through 
    exploitation while maintaining credible punishment mechanisms. Always defects in first 
    and last rounds, and sets high cooperation thresholds with harsh punishment protocols.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0
        self.exploitation_punishment_remaining = 0
        self.group_punishment_remaining = 0
        self.targeted_punishment = {}

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        if round_number == self.game_description.n_rounds:
            return Action.D
        if self.exploitation_punishment_remaining > 0:
            self.exploitation_punishment_remaining -= 1
            return Action.D
        if self._was_exploited_recently(history):
            self.exploitation_punishment_remaining = 1
            return Action.D
        if self._majority_defected_last_round(history):
            return Action.D
        if not self._above_fair_share(history):
            return Action.D
        if self.group_punishment_remaining > 0:
            self.group_punishment_remaining -= 1
            return Action.D
        if self._should_apply_group_punishment(history):
            self.group_punishment_remaining = 2
            return Action.D
        if self._should_apply_sustained_punishment(history):
            return Action.D
        if self._conditions_for_cooperation(history):
            return Action.C
        return Action.D

    def _was_exploited_recently(self, history: PlayerHistory) -> bool:
        """Check if my cooperation rate was higher than group average in any previous round."""
        for round_idx in range(history.round_number):
            my_action = history.my_actions[round_idx]
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            group_cooperators = opponent_cooperators + (1 if my_action else 0)
            my_coop_rate = 1.0 if my_action else 0.0
            group_coop_rate = group_cooperators / self.game_description.n_players
            if my_coop_rate > group_coop_rate:
                return True
        return False

    def _majority_defected_last_round(self, history: PlayerHistory) -> bool:
        """Check if ≥60% of other players defected in the previous round."""
        last_round_idx = history.round_number - 1
        opponent_defectors = sum(1 - history.opponent_actions[last_round_idx])
        defection_rate = opponent_defectors / (self.game_description.n_players - 1)
        return defection_rate >= 0.6

    def _above_fair_share(self, history: PlayerHistory) -> bool:
        """Check if my total payoff is at or above fair share."""
        total_rounds_so_far = history.round_number
        my_total_payoff = sum(history.my_payoffs)
        total_cooperations = 0
        total_actions = 0
        for round_idx in range(total_rounds_so_far):
            round_cooperations = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            total_cooperations += round_cooperations
            total_actions += self.game_description.n_players
        if total_actions == 0:
            return False
        avg_coop_rate = total_cooperations / total_actions
        fair_share = total_rounds_so_far * self.game_description.k * avg_coop_rate
        return my_total_payoff >= fair_share

    def _should_apply_group_punishment(self, history: PlayerHistory) -> bool:
        """Check if group cooperation dropped below 40% for 2 consecutive rounds."""
        if history.round_number < 2:
            return False
        cooperation_rates = []
        for round_idx in range(history.round_number - 2, history.round_number):
            round_cooperators = sum(history.opponent_actions[round_idx]) + (1 if history.my_actions[round_idx] else 0)
            cooperation_rates.append(round_cooperators / self.game_description.n_players)
        return all((rate < 0.4 for rate in cooperation_rates))

    def _should_apply_sustained_punishment(self, history: PlayerHistory) -> bool:
        """Check for sustained punishment against specific players."""
        if history.round_number < 3:
            return False
        for player_idx in range(self.game_description.n_players - 1):
            consecutive_defections = 0
            i_cooperated_during = False
            for round_idx in range(max(0, history.round_number - 4), history.round_number):
                if not history.opponent_actions[round_idx, player_idx]:
                    consecutive_defections += 1
                    if history.my_actions[round_idx]:
                        i_cooperated_during = True
                else:
                    break
            if consecutive_defections >= 3 and i_cooperated_during:
                if history.round_number > 0 and history.opponent_actions[history.round_number - 1, player_idx]:
                    return True
        return False

    def _conditions_for_cooperation(self, history: PlayerHistory) -> bool:
        """Check if all conditions for cooperation are met."""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        coop_rate = opponent_cooperators / (self.game_description.n_players - 1)
        if coop_rate < 0.7:
            return False
        if not self._above_fair_share(history):
            return False
        if not self._cooperation_trend_increasing(history):
            return False
        return True

    def _cooperation_trend_increasing(self, history: PlayerHistory) -> bool:
        """Check if cooperation rate is higher than 2 rounds ago."""
        if history.round_number < 2:
            return False
        last_round_idx = history.round_number - 1
        two_rounds_ago_idx = history.round_number - 2
        last_round_coop = sum(history.opponent_actions[last_round_idx]) + (1 if history.my_actions[last_round_idx] else 0)
        two_rounds_ago_coop = sum(history.opponent_actions[two_rounds_ago_idx]) + (1 if history.my_actions[two_rounds_ago_idx] else 0)
        last_rate = last_round_coop / self.game_description.n_players
        old_rate = two_rounds_ago_coop / self.game_description.n_players
        return last_rate > old_rate

class Strategy_AGGRESSIVE_23(BaseStrategy):
    """
    Exploitative Hawk: An aggressive strategy that maximizes individual payoff through 
    strategic exploitation while maintaining unpredictability to avoid complete retaliation.
    Defaults to defection but occasionally cooperates to trigger exploitable cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round <= 3:
            return Action.D
        if current_round > n_rounds - 3:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / n_players
        my_cooperations = sum(history.my_actions)
        my_historical_cooperation_rate = my_cooperations / history.round_number
        if history.round_number >= 1:
            defectors_last_round = n_players - cooperators_last_round
            high_retaliation = defectors_last_round / n_players > 0.7
            if high_retaliation:
                rounds_remaining = n_rounds - current_round + 1
                if rounds_remaining <= 5:
                    return Action.D
                else:
                    if history.round_number >= 2:
                        coop_last_2 = (sum(history.opponent_actions[last_round_idx]) + sum(history.opponent_actions[last_round_idx - 1])) / (2 * n_players)
                        if coop_last_2 < 0.3:
                            return Action.C
                    return Action.D
        if history.round_number >= 3:
            recent_coop_rates = []
            for i in range(3):
                round_idx = last_round_idx - i
                if round_idx >= 0:
                    coop_rate = sum(history.opponent_actions[round_idx]) / n_players
                    recent_coop_rates.append(coop_rate)
            if len(recent_coop_rates) == 3 and all((rate < 0.2 for rate in recent_coop_rates)):
                return Action.D
        if cooperation_rate >= 0.6 and my_historical_cooperation_rate <= 0.2:
            return Action.C
        elif cooperation_rate >= 0.4:
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_24(BaseStrategy):
    """
    Exploitative Hawk: An aggressive strategy that maximizes personal payoffs by exploiting 
    cooperative players while minimizing vulnerability. Always defects in first and last rounds,
    and conditionally exploits based on cooperation rates and relative performance in between.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / self.game_description.n_players
        my_last_payoff = history.my_payoffs[last_round_idx]
        opponent_payoffs = history.opponent_payoffs[last_round_idx]
        avg_last_payoff = sum(opponent_payoffs) / len(opponent_payoffs)
        final_phase_start = int(0.8 * self.game_description.n_rounds)
        high_coop_threshold = 0.4 if current_round >= final_phase_start else 0.6
        if cooperation_rate >= high_coop_threshold:
            return Action.D
        elif cooperation_rate >= 0.3:
            if my_last_payoff > avg_last_payoff:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_25(BaseStrategy):
    """
    Aggressive Strategy: "Exploitative Dominance"
    
    This strategy maximizes individual payoffs through aggressive exploitation while maintaining 
    tactical flexibility. Opens with defection, permanently exploits cooperative players, 
    and uses harsh punishment against fellow aggressors who betray cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.exploitable_targets = set()
        self.fellow_aggressors = set()
        self.punishment_counters = {}
        self.opponents_classified = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if not self.opponents_classified and history.round_number >= 1:
            self._classify_opponents_from_round_1(history)
            self.opponents_classified = True
        if current_round == self.game_description.n_rounds:
            return Action.D
        if self._in_punishment_mode():
            self._decrement_punishment_counters()
            return Action.D
        prev_round_idx = history.round_number - 1
        total_players = self.game_description.n_players - 1
        cooperators_last_round = sum(history.opponent_actions[prev_round_idx])
        cooperation_rate = cooperators_last_round / total_players if total_players > 0 else 0
        if cooperation_rate >= 0.7:
            return Action.D
        if cooperation_rate < 0.3:
            return Action.D
        if self._all_fellow_aggressors_cooperated_last_round(history):
            return Action.C
        else:
            self._set_punishment_for_defecting_aggressors(history)
            return Action.D

    def _classify_opponents_from_round_1(self, history: PlayerHistory):
        """Classify opponents based on their round 1 behavior"""
        for opponent_idx in range(history.opponent_actions.shape[1]):
            if history.opponent_actions[0, opponent_idx]:
                self.exploitable_targets.add(opponent_idx)
            else:
                self.fellow_aggressors.add(opponent_idx)
                self.punishment_counters[opponent_idx] = 0

    def _in_punishment_mode(self) -> bool:
        """Check if any punishment counters are active"""
        return any((counter > 0 for counter in self.punishment_counters.values()))

    def _decrement_punishment_counters(self):
        """Decrement all active punishment counters"""
        for opponent_idx in self.punishment_counters:
            if self.punishment_counters[opponent_idx] > 0:
                self.punishment_counters[opponent_idx] -= 1

    def _all_fellow_aggressors_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if all fellow aggressors cooperated in the previous round"""
        if not self.fellow_aggressors:
            return False
        prev_round_idx = history.round_number - 1
        for opponent_idx in self.fellow_aggressors:
            if not history.opponent_actions[prev_round_idx, opponent_idx]:
                return False
        return True

    def _set_punishment_for_defecting_aggressors(self, history: PlayerHistory):
        """Set punishment counters for fellow aggressors who defected"""
        prev_round_idx = history.round_number - 1
        for opponent_idx in self.fellow_aggressors:
            if not history.opponent_actions[prev_round_idx, opponent_idx]:
                current_punishment = self.punishment_counters.get(opponent_idx, 0)
                if current_punishment == 0:
                    self.punishment_counters[opponent_idx] = 2
                else:
                    self.punishment_counters[opponent_idx] = max(2, current_punishment + 1)

class Strategy_AGGRESSIVE_26(BaseStrategy):
    """
    Aggressive Strategy: "Exploitation with Punishment"
    
    Maximizes personal payoffs by exploiting cooperative opponents while 
    aggressively punishing defection. Defects in first and last rounds,
    and conditionally cooperates based on opponent cooperation rates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if history.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        last_round_idx = history.round_number - 1
        total_cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            total_cooperators_last_round += 1
        cooperation_rate = total_cooperators_last_round / self.game_description.n_players
        if cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate < 0.3:
            return Action.D
        else:
            if history.my_actions[last_round_idx]:
                if history.round_number >= 2:
                    prev_round_idx = history.round_number - 2
                    prev_cooperators = sum(history.opponent_actions[prev_round_idx])
                    if history.my_actions[prev_round_idx]:
                        prev_cooperators += 1
                    previous_cooperation_rate = prev_cooperators / self.game_description.n_players
                    if cooperation_rate < previous_cooperation_rate:
                        return Action.D
            return Action.C

class Strategy_AGGRESSIVE_27(BaseStrategy):
    """
    Parasitic Punisher: An aggressive strategy that exploits cooperative opponents 
    while harshly punishing any defection against it. Always defects in first and 
    last rounds, with adaptive middle-round behavior based on cooperation rates 
    and punishment cycles.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_counter = 0
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        last_round_idx = history.round_number - 1
        if last_round_idx >= 0 and history.my_actions[last_round_idx] and (not all(history.opponent_actions[last_round_idx])):
            self.punishment_counter = max(3, n - 1)
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        total_opponent_actions = history.opponent_actions.flatten()
        cooperation_rate = np.mean(total_opponent_actions) if len(total_opponent_actions) > 0 else 0
        if cooperation_rate >= 0.7:
            return Action.D
        if cooperation_rate < 0.4:
            return Action.D
        if last_round_idx >= 0:
            my_last_payoff = history.my_payoffs[last_round_idx]
            opponent_last_payoffs = history.opponent_payoffs[last_round_idx]
            average_last_payoff = np.mean(opponent_last_payoffs)
            if my_last_payoff < average_last_payoff:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_28(BaseStrategy):
    """
    Punitive Exploiter: An aggressive strategy that exploits cooperative players while 
    brutally punishing defectors. Always defects in first and last rounds, and uses
    cooperation rate thresholds to determine exploitation vs punishment behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if history.round_number == self.game_description.n_rounds - 1:
            return Action.D
        last_round = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round])
        if history.my_actions[last_round]:
            total_cooperators = cooperators_last_round + 1
        else:
            total_cooperators = cooperators_last_round
        cooperation_rate = total_cooperators / self.game_description.n_players
        my_last_payoff = history.my_payoffs[last_round]
        threshold_payoff = 1 + self.game_description.k / self.game_description.n_players
        if cooperation_rate >= 0.6:
            return Action.D
        elif cooperation_rate >= 0.4:
            if my_last_payoff < threshold_payoff:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_29(BaseStrategy):
    """
    Aggressive Strategy: "Exploitation Maximizer"
    
    This strategy maximizes individual payoffs by aggressively exploiting cooperative behavior
    while minimizing personal contributions. It defects in the first round, exploits high
    cooperation, occasionally cooperates when cooperation rates are moderate (to maintain
    exploitability), and always defects in the endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.total_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        if round_number >= self.total_rounds - 1:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
        cooperation_rate = last_round_cooperators / self.n
        if history.round_number > 1:
            prev_round_idx = history.round_number - 2
            prev_cooperators = sum(history.opponent_actions[prev_round_idx]) + int(history.my_actions[prev_round_idx])
            prev_cooperation_rate = prev_cooperators / self.n
            if cooperation_rate < prev_cooperation_rate - 0.2:
                return Action.D
        if cooperation_rate >= 0.6:
            return Action.D
        elif cooperation_rate >= 0.3:
            if random.random() < 0.8:
                return Action.D
            else:
                expected_return = self.k / self.n * last_round_cooperators
                if expected_return < 1:
                    return Action.D
                return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_30(BaseStrategy):
    """
    Exploitative Punisher: An aggressive strategy that exploits cooperative opponents
    while maintaining credible punishment mechanisms. Always defects in first and last
    two rounds, and uses conditional cooperation with immediate punishment in between.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round >= total_rounds - 1:
            return Action.D
        if current_round >= 2 and current_round <= total_rounds - 2:
            last_round_idx = history.round_number - 1
            cooperators_last_round = int(sum(history.opponent_actions[last_round_idx]))
            if history.my_actions[last_round_idx]:
                cooperators_last_round += 1
            if cooperators_last_round >= math.ceil(n_players / 2):
                return Action.D
            elif cooperators_last_round >= 2:
                my_last_action_was_defect = not history.my_actions[last_round_idx]
                if history.round_number >= 2:
                    prev_round_idx = history.round_number - 2
                    cooperators_prev_round = int(sum(history.opponent_actions[prev_round_idx]))
                    if history.my_actions[prev_round_idx]:
                        cooperators_prev_round += 1
                    if my_last_action_was_defect and cooperators_last_round > cooperators_prev_round:
                        return Action.D
                    else:
                        return Action.C
                else:
                    return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_31(BaseStrategy):
    """
    Aggressive Strategy: "Exploitation with Calculated Defection"
    
    This strategy maximizes personal payoff by exploiting cooperative players while 
    minimizing vulnerability to exploitation. It uses defection as the primary tool
    and employs limited cooperation only to manipulate others into cooperating for
    future exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if round_number >= r - 2:
            return Action.D
        if round_number <= 3:
            return Action.D
        last_round_idx = history.round_number - 1
        previous_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            previous_cooperators += 1
        if previous_cooperators >= n - 1:
            return Action.D
        if previous_cooperators >= n / 2:
            return Action.D
        if previous_cooperators <= 2:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_32(BaseStrategy):
    """
    Ruthless Exploiter: An aggressive strategy that maximizes personal payoff through 
    strategic exploitation while minimizing vulnerability. Cooperates only when absolutely 
    necessary to prevent total system collapse, otherwise defects to free-ride on others' contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.cooperation_threshold = self._calculate_threshold()
        self.emergency_cooperated = False

    def _calculate_threshold(self):
        """Calculate cooperation threshold for exploitation opportunities."""
        return math.ceil(self.n * self.k / (self.k + 1))

    def _count_cooperators_last_round(self, history):
        """Count how many opponents cooperated in the most recent round."""
        if history.round_number == 0:
            return 0
        return int(sum(history.opponent_actions[history.round_number - 1]))

    def _count_recent_cooperation(self, history):
        """Count total cooperation in last 3 rounds for adaptive exploitation."""
        if history.round_number == 0:
            return 0
        start_round = max(0, history.round_number - 3)
        total_cooperation = 0
        for round_idx in range(start_round, history.round_number):
            total_cooperation += sum(history.opponent_actions[round_idx])
        return total_cooperation

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.emergency_cooperated = False
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        if current_round == self.r - 1:
            return Action.D
        cooperators_last_round = self._count_cooperators_last_round(history)
        if cooperators_last_round >= self.cooperation_threshold:
            return Action.D
        if cooperators_last_round <= 1 and (not self.emergency_cooperated):
            self.emergency_cooperated = True
            return Action.C
        recent_cooperation = self._count_recent_cooperation(history)
        if recent_cooperation > self.n * 2:
            return Action.D
        elif recent_cooperation == 0:
            if not self.emergency_cooperated:
                self.emergency_cooperated = True
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_33(BaseStrategy):
    """
    Aggressive "Exploit-First Dominator" strategy that operates in three phases:
    Phase 1 (first third): Always defect to exploit potential cooperators
    Phase 2 (middle third): Defect unless cooperation rate exceeds 80%
    Phase 3 (final third): Always defect for endgame exploitation
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        phase_1_end = self.n_rounds // 3
        phase_2_end = 2 * self.n_rounds // 3
        if current_round <= phase_1_end:
            return Action.D
        elif current_round <= phase_2_end:
            if history.round_number > 0:
                last_round_idx = history.round_number - 1
                last_round_cooperators = sum(history.opponent_actions[last_round_idx])
                cooperation_rate = last_round_cooperators / (self.n_players - 1)
                if cooperation_rate > 0.8:
                    return Action.C
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_34(BaseStrategy):
    """
    Aggressive "Conditional Exploiter" strategy that maximizes personal payoff by exploiting
    cooperative opponents while minimizing contributions to the public good. Defects in round 1
    and final round, and exploits high cooperation rates while providing minimal maintenance
    cooperation only when necessary to sustain exploitable conditions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.total_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        recent_cooperators = sum(history.opponent_actions[last_round_idx])
        recent_cooperation_rate = recent_cooperators / (self.n - 1)
        if recent_cooperation_rate >= 0.6:
            return Action.D
        elif recent_cooperation_rate >= 0.4:
            lookback_rounds = min(3, history.round_number)
            start_idx = max(0, history.round_number - lookback_rounds)
            my_recent_defections = sum((1 for i in range(start_idx, history.round_number) if not history.my_actions[i]))
            if my_recent_defections >= 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_35(BaseStrategy):
    """
    Aggressive "Exploitative Punisher" strategy for N-Player Public Goods Game.
    
    Maximizes individual payoff through strategic exploitation while using targeted
    punishment to deter betrayers. Defects by default and only cooperates when
    highly profitable with stable cooperation trends.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0
        self.betrayer_tracking = {}

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_rounds_remaining = 0
            self.betrayer_tracking = {}
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        if self._in_punishment_mode(history):
            return Action.D
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx])
        if history.my_actions[prev_round_idx]:
            prev_cooperators += 1
        cooperation_threshold = math.ceil(self.game_description.n_players * self.game_description.k / (self.game_description.k + 1))
        if prev_cooperators >= cooperation_threshold:
            expected_cooperators_if_i_cooperate = prev_cooperators + (0 if history.my_actions[prev_round_idx] else 1)
            expected_cooperators_if_i_defect = prev_cooperators + (-1 if history.my_actions[prev_round_idx] else 0)
            payoff_if_cooperate = 0 + self.game_description.k / self.game_description.n_players * expected_cooperators_if_i_cooperate
            payoff_if_defect = 1 + self.game_description.k / self.game_description.n_players * expected_cooperators_if_i_defect
            if payoff_if_cooperate > payoff_if_defect and self._cooperation_trend_stable(history):
                return Action.C
        return Action.D

    def _in_punishment_mode(self, history: PlayerHistory) -> bool:
        """Check if we should punish betrayers."""
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return True
        current_round = history.round_number
        if current_round < 2:
            return False
        cooperation_threshold = math.ceil(self.game_description.n_players * self.game_description.k / (self.game_description.k + 1))
        prev_prev_cooperators = sum(history.opponent_actions[current_round - 2])
        if history.my_actions[current_round - 2]:
            prev_prev_cooperators += 1
        if prev_prev_cooperators >= cooperation_threshold:
            for player_idx in range(len(history.opponent_actions[current_round - 1])):
                cooperated_t_minus_2 = history.opponent_actions[current_round - 2, player_idx]
                defected_t_minus_1 = not history.opponent_actions[current_round - 1, player_idx]
                if cooperated_t_minus_2 and defected_t_minus_1:
                    self.punishment_rounds_remaining = 2
                    return True
        return False

    def _cooperation_trend_stable(self, history: PlayerHistory) -> bool:
        """Check if cooperation levels are stable or increasing."""
        current_round = history.round_number
        if current_round < 2:
            return True
        recent_cooperators = sum(history.opponent_actions[current_round - 1])
        if history.my_actions[current_round - 1]:
            recent_cooperators += 1
        prev_cooperators = sum(history.opponent_actions[current_round - 2])
        if history.my_actions[current_round - 2]:
            prev_cooperators += 1
        return recent_cooperators >= prev_cooperators

class Strategy_AGGRESSIVE_36(BaseStrategy):
    """
    Aggressive "Predatory Defector" strategy that maximizes personal payoff through 
    calculated aggression, exploiting cooperative players while minimizing vulnerability.
    Starts with defection, only cooperates to encourage exploitation opportunities,
    and becomes increasingly aggressive toward endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.n_rounds - current_round + 1
        if rounds_remaining == 1:
            return Action.D
        previous_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[previous_round_idx])
        my_previous_action = history.my_actions[previous_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_previous_action else 0)
        cooperation_rate = total_cooperators / self.n_players
        if rounds_remaining <= 3:
            return Action.D
        if rounds_remaining <= self.n_rounds // 3:
            if cooperation_rate >= 0.7:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.5 and rounds_remaining > 3:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_37(BaseStrategy):
    """
    Exploitative Defector with Punishment: Aggressively exploits cooperation while punishing defectors.
    Always defects in first and last rounds, conditionally cooperates to manipulate cooperation levels.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.betrayal_punishment = {}

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        k = self.game_description.k
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        last_opponent_actions = history.opponent_actions[last_round_idx]
        cooperators_last_round = sum(last_opponent_actions)
        cooperation_rate = cooperators_last_round / (n - 1)
        my_last_action = 1 if history.my_actions[last_round_idx] else 0
        total_cooperators = cooperators_last_round + my_last_action
        my_last_payoff = 1 - my_last_action + k / n * total_cooperators
        if history.round_number >= 2:
            prev_round_idx = history.round_number - 2
            for player_idx in range(n - 1):
                if history.opponent_actions[prev_round_idx, player_idx] and (not history.opponent_actions[last_round_idx, player_idx]):
                    self.betrayal_punishment[player_idx] = current_round + 2
        active_punishments = sum((1 for end_round in self.betrayal_punishment.values() if end_round > current_round))
        if active_punishments > 0:
            return Action.D
        if cooperation_rate >= 0.7:
            return Action.D
        elif cooperation_rate >= 0.4:
            expected_cooperators = cooperation_rate * (n - 1)
            if my_last_payoff < 1 + k / n * expected_cooperators:
                return Action.D
            else:
                return Action.D
        elif cooperation_rate > 0 and cooperation_rate < 0.4:
            return Action.C
        else:
            if current_round % 4 == 0:
                return Action.C
            return Action.D

class Strategy_AGGRESSIVE_38(BaseStrategy):
    """
    Exploitative Hawk: An aggressive strategy that maximizes personal payoffs by exploiting 
    cooperative behavior while never contributing. Always defects to capture benefits from 
    others' contributions without risking personal resources.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if history.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        cooperation_rate = self._calculate_recent_cooperation_rate(history)
        predicted_cooperators = self._predict_cooperation(history)
        my_expected_benefit = self.game_description.k / self.game_description.n_players * predicted_cooperators
        return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate cooperation rate from recent rounds (last 3 or all available)."""
        rounds_to_analyze = min(3, history.round_number)
        if rounds_to_analyze == 0:
            return 0.0
        start_round = history.round_number - rounds_to_analyze
        recent_cooperation = 0
        total_decisions = 0
        for round_idx in range(start_round, history.round_number):
            recent_cooperation += sum(history.opponent_actions[round_idx])
            total_decisions += len(history.opponent_actions[round_idx])
        return recent_cooperation / total_decisions if total_decisions > 0 else 0.0

    def _predict_cooperation(self, history: PlayerHistory) -> float:
        """Predict how many opponents will cooperate this round based on recent trends."""
        if history.round_number == 0:
            return 0.0
        cooperation_rate = self._calculate_recent_cooperation_rate(history)
        predicted_cooperators = cooperation_rate * (self.game_description.n_players - 1)
        return predicted_cooperators

class Strategy_AGGRESSIVE_39(BaseStrategy):
    """
    Opportunistic Defector: An aggressive strategy that maximizes individual payoffs 
    through calculated exploitation while maintaining minimal cooperative investment.
    
    Always defects in round 1 and final round. In middle rounds, exploits high 
    cooperation by defecting, strategically cooperates when few others cooperate 
    to potentially trigger cascades to exploit later, otherwise defaults to defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        prev_round_idx = history.round_number - 1
        prev_cooperators = int(sum(history.opponent_actions[prev_round_idx]))
        n = self.game_description.n_players
        k = self.game_description.k
        if n == 2:
            return Action.C if prev_cooperators > 0 else Action.D
        if n > 10:
            cooperation_threshold = max(1, int(n / 3))
        else:
            cooperation_threshold = max(1, int((n - 1) / 2))
        if k < 1.5:
            cooperation_threshold = max(cooperation_threshold, 3)
        if prev_cooperators >= cooperation_threshold:
            return Action.D
        if prev_cooperators == 1 or prev_cooperators == 2:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_40(BaseStrategy):
    """
    Aggressive Strategy: "Exploitation Maximizer"
    
    This strategy maximizes personal payoffs through aggressive exploitation while maintaining
    tactical cooperation only when it can be leveraged for greater personal gain. Always defects
    in round 1, exploits high cooperation rates, and switches to full defection in endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        k = self.game_description.k
        r = self.game_description.n_rounds
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = last_round_cooperators / (n - 1)
        my_advantage = 1.0 - k / n
        if current_round > r - 3:
            return Action.D
        if cooperation_rate >= 0.6 and my_advantage > 0.3:
            return Action.D
        elif cooperation_rate >= 0.4 and current_round <= r - 3:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_41(BaseStrategy):
    """
    Aggressive "Exploit-First Punisher" strategy that maximizes personal payoff by 
    exploiting cooperative opponents while maintaining threat of retaliation.
    Always defects in first and last rounds, and uses tactical cooperation only
    when it serves exploitation purposes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.exploitation_threshold = 0.3
        self.punishment_threshold = 1.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        opponents_last_round = history.opponent_actions[last_round_idx]
        my_last_payoff = history.my_payoffs[last_round_idx]
        cooperation_rate = sum(opponents_last_round) / len(opponents_last_round)
        if current_round == 2:
            if cooperation_rate >= self.exploitation_threshold:
                return Action.D
            elif cooperation_rate < 0.1:
                return Action.C
            else:
                return Action.D
        if current_round < n_rounds:
            if my_last_payoff < self.punishment_threshold:
                return Action.C
            elif cooperation_rate >= self.exploitation_threshold:
                return Action.D
            else:
                return Action.D
        if current_round == n_rounds - 1:
            if cooperation_rate == 0.0:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_42(BaseStrategy):
    """
    Ruthless Exploiter: An aggressive strategy that maximizes personal payoff by exploiting 
    cooperative behavior while minimizing personal contributions. Defects by default with 
    rare tactical cooperation only when conditions strongly favor exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        if current_round >= 2:
            prev_round_idx = history.round_number - 1
            opponent_cooperators = sum(history.opponent_actions[prev_round_idx])
            my_prev_action = history.my_actions[prev_round_idx]
            total_cooperators = opponent_cooperators + (1 if my_prev_action else 0)
            cooperation_rate = total_cooperators / n
            my_prev_payoff = history.my_payoffs[prev_round_idx]
            rounds_remaining = r - current_round
            if cooperation_rate >= 0.6 and my_prev_payoff >= 1.5 and (rounds_remaining < 3):
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_43(BaseStrategy):
    """
    Ruthless Exploiter: An aggressive strategy that maximizes personal payoffs by 
    exploiting cooperative players. Always defects in first and last rounds, and 
    conditionally cooperates only when it's profitable, with special exploitation 
    when almost everyone else cooperates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        prev_cooperators = sum(history.opponent_actions[history.round_number - 1])
        if history.my_actions[history.round_number - 1]:
            prev_cooperators += 1
        if current_round == r:
            return Action.D
        if current_round == r - 1:
            if prev_cooperators >= 2 * n // 3:
                return Action.C
            else:
                return Action.D
        if prev_cooperators == n - 1:
            return Action.D
        if prev_cooperators >= n // 2:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_44(BaseStrategy):
    """
    Aggressive Strategy: "Exploitation with Intimidation"
    
    This strategy maximizes personal payoffs through calculated exploitation while using 
    aggressive retaliation to discourage others from defecting against us. The key insight 
    is that in a public goods game, the optimal individual outcome is to defect while 
    others cooperate, so we aggressively pursue this asymmetric outcome.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.permanent_punishment = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        prev_round_idx = round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx])
        my_prev_action = history.my_actions[prev_round_idx]
        if my_prev_action and prev_cooperators <= n / 3:
            self.permanent_punishment = True
        if self.permanent_punishment:
            return Action.D
        if round_number >= r - 2:
            return Action.D
        if prev_cooperators >= n / 2:
            return Action.D
        if prev_cooperators >= 2 * n / 3 and round_number <= r / 3:
            if round_number % 3 == 1:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_45(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predatory Defector"
    
    This strategy maximizes individual payoffs by exploiting cooperative players while 
    minimizing exposure to retaliation. It operates on conditional defection based on 
    cooperation rates and payoff advantages, with strategic cooperation phases to 
    maintain exploitation opportunities.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == n_rounds:
            return Action.D
        if current_round > 0.8 * n_rounds:
            if random.random() < 0.9:
                return Action.D
        last_round_idx = history.round_number - 1
        last_round_opponent_actions = history.opponent_actions[last_round_idx]
        cooperators_last_round = sum(last_round_opponent_actions)
        cooperation_rate = cooperators_last_round / n_players
        my_last_payoff = history.my_payoffs[last_round_idx]
        opponent_payoffs_last_round = history.opponent_payoffs[last_round_idx]
        average_opponent_payoff = sum(opponent_payoffs_last_round) / len(opponent_payoffs_last_round)
        my_advantage = my_last_payoff - average_opponent_payoff
        if cooperation_rate >= 0.7:
            return Action.D
        elif cooperation_rate >= 0.4 and my_advantage < 0.5:
            if random.random() < 0.05:
                return Action.D
            return Action.C
        if cooperation_rate < 0.2 and history.round_number >= 3:
            if random.random() < 0.1:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_46(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    This strategy maximizes individual payoffs by aggressively exploiting cooperative players
    while minimizing own contributions. It treats cooperation as weakness and seeks to establish
    dominance through strategic defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.consecutive_low_cooperation_rounds = 0
        self.stimulation_mode = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        total_cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            total_cooperators_last_round += 1
        cooperation_rate = total_cooperators_last_round / self.n
        my_contribution = 1 if history.my_actions[last_round_idx] else 0
        total_contributions = total_cooperators_last_round
        my_last_payoff = 1 - my_contribution + self.k / self.n * total_contributions
        expected_defect_payoff = 1 + self.k / self.n * total_contributions
        final_quarter = max(1, self.r // 4)
        if current_round >= self.r - final_quarter:
            return Action.D
        if cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate >= 0.3 and my_last_payoff < expected_defect_payoff:
            return Action.D
        elif cooperation_rate < 0.2:
            self.consecutive_low_cooperation_rounds += 1
            if self.consecutive_low_cooperation_rounds >= 3 and current_round <= self.r * 0.75:
                self.stimulation_mode = True
                self.consecutive_low_cooperation_rounds = 0
                return Action.C
            else:
                return Action.D
        else:
            self.consecutive_low_cooperation_rounds = 0
            return Action.D

class Strategy_AGGRESSIVE_47(BaseStrategy):
    """
    Ruthless Exploiter: An aggressive strategy that maximizes personal payoff through 
    exploitation while maintaining minimal cooperation only when absolutely necessary 
    for self-preservation. Defaults to defection with adaptive cooperation only when 
    the group is highly cooperative AND the player is falling significantly behind.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / (self.game_description.n_players - 1)
        my_last_payoff = history.my_payoffs[last_round_idx]
        average_opponent_payoff = np.mean(history.opponent_payoffs[last_round_idx])
        my_relative_performance = my_last_payoff - average_opponent_payoff
        if cooperation_rate >= 0.8 and my_relative_performance < -0.5:
            return Action.C
        elif cooperation_rate >= 0.6 and cooperation_rate < 0.8:
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_48(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes personal payoff 
    by exploiting cooperative players while minimizing personal contributions.
    Defects in first and last rounds, and conditionally exploits based on cooperation rates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / self.game_description.n_players
        if cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate >= 0.3:
            if my_last_action and history.my_payoffs[last_round_idx] <= 1.0:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_49(BaseStrategy):
    """
    Exploitative Punisher: An aggressive strategy that maximizes individual payoffs 
    through strategic defection, conditional cooperation, and severe punishment of betrayal.
    Uses a three-phase approach: aggressive probing, conditional exploitation, and endgame aggression.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n = self.game_description.n_players
        if current_round > total_rounds - 3:
            return Action.D
        if current_round <= 3:
            if current_round == 1:
                return Action.D
            else:
                last_round_idx = history.round_number - 1
                others_cooperated = sum(history.opponent_actions[last_round_idx])
                if others_cooperated == n - 1:
                    return Action.C
                else:
                    return Action.D
        last_round_idx = history.round_number - 1
        others_cooperated = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = others_cooperated + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / n
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        if my_last_action and others_cooperated / (n - 1) <= 0.5:
            self.punishment_rounds_left = 1
            return Action.D
        if cooperation_rate <= 0.4:
            return Action.D
        if cooperation_rate >= 0.8:
            return Action.C
        if history.round_number >= 2:
            recent_defectors = n - total_cooperators
            predicted_defectors = max(1, recent_defectors)
        else:
            predicted_defectors = 1
        if predicted_defectors <= n // 3:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_50(BaseStrategy):
    """
    Aggressive "Exploit-and-Punish" Strategy
    
    Maximizes personal payoffs through strategic exploitation while maintaining 
    credible punishment mechanisms. Always defects in first and last rounds,
    and exploits cooperative majorities in middle rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if self.k < 1.5:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            total_cooperators_last_round = last_round_cooperators + 1
        else:
            total_cooperators_last_round = last_round_cooperators
        if total_cooperators_last_round == 0:
            return Action.C
        if total_cooperators_last_round >= self.n_players / 2:
            return Action.D
        elif total_cooperators_last_round < self.n_players / 4:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_51(BaseStrategy):
    """
    Opportunistic Predator: An aggressive strategy that maximizes personal payoff by exploiting 
    cooperative players while minimizing own contributions. Always defects in first and last rounds,
    and adaptively exploits based on cooperation rates and relative payoff performance.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = int(my_last_action) + opponent_cooperators
        cooperation_rate = total_cooperators / self.game_description.n_players
        if cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate >= 0.3:
            my_last_payoff = history.my_payoffs[last_round_idx]
            average_opponent_payoff = sum(history.opponent_payoffs[last_round_idx]) / (self.game_description.n_players - 1)
            if my_last_payoff < average_opponent_payoff:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_52(BaseStrategy):
    """
    Exploitative Punisher: An aggressive strategy that maximizes personal payoffs by 
    exploiting cooperative players while using strategic cooperation as a punishment 
    mechanism. Defects by default, especially in early and late game phases.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round <= 3:
            return Action.D
        if current_round > n_rounds - 2:
            return Action.D
        cooperation_rates = []
        for opponent_idx in range(n_players - 1):
            cooperations = sum(history.opponent_actions[:, opponent_idx])
            total_rounds = history.round_number
            coop_rate = cooperations / total_rounds if total_rounds > 0 else 0
            cooperation_rates.append(coop_rate)
        avg_coop_rate = sum(cooperation_rates) / len(cooperation_rates) if cooperation_rates else 0
        consistent_defectors = sum((1 for rate in cooperation_rates if rate < 0.3))
        if avg_coop_rate >= 0.6:
            return Action.D
        elif consistent_defectors >= n_players / 2:
            return Action.D
        else:
            for rate in cooperation_rates:
                if rate > 0.7:
                    return Action.C
            return Action.D

class Strategy_AGGRESSIVE_53(BaseStrategy):
    """
    Predatory Exploiter: Aggressive strategy that maximizes personal payoffs by exploiting 
    cooperative behavior while minimizing personal vulnerability. Defects in first and last 
    rounds, and uses cooperation rate patterns to decide when to free-ride vs when to 
    minimally invest to maintain exploitation opportunities.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx])
        total_players = self.game_description.n_players
        cooperation_rate = prev_cooperators / (total_players - 1)
        if cooperation_rate >= 0.5:
            return Action.D
        if history.round_number >= 2:
            recent_cooperation_rates = []
            for i in range(max(0, history.round_number - 2), history.round_number):
                round_cooperators = sum(history.opponent_actions[i])
                rate = round_cooperators / (total_players - 1)
                recent_cooperation_rates.append(rate)
            if len(recent_cooperation_rates) >= 2 and all((rate < 0.2 for rate in recent_cooperation_rates)):
                return Action.D
        if cooperation_rate < 0.5 and cooperation_rate > 0.2:
            if history.round_number >= 2:
                prev_prev_round_idx = history.round_number - 2
                prev_prev_cooperators = sum(history.opponent_actions[prev_prev_round_idx])
                prev_prev_cooperation_rate = prev_prev_cooperators / (total_players - 1)
                if prev_prev_cooperation_rate > cooperation_rate and cooperation_rate > 0.3:
                    return Action.C
        return Action.D

class Strategy_AGGRESSIVE_54(BaseStrategy):
    """
    Exploitative Punisher: An aggressive strategy that exploits cooperative opponents
    while maintaining credible punishment threats. Always defects in first 2 rounds
    and last 2 rounds, cooperates conditionally in middle rounds with hair-trigger
    punishment for any defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_triggered = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_triggered = False
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        if current_round <= 2:
            return Action.D
        if current_round >= n_rounds - 1:
            return Action.D
        if self.punishment_triggered:
            return Action.D
        for past_round_idx in range(max(0, 2), history.round_number):
            if not all(history.opponent_actions[past_round_idx]):
                self.punishment_triggered = True
                return Action.D
        last_round_idx = history.round_number - 1
        if all(history.opponent_actions[last_round_idx]):
            return Action.C
        else:
            self.punishment_triggered = True
            return Action.D

class Strategy_AGGRESSIVE_55(BaseStrategy):
    """
    Ruthless Exploiter: An aggressive strategy that maximizes personal payoff by exploiting
    cooperative behavior while minimizing personal contributions. Always defects in first
    and last rounds, and conditionally exploits based on cooperation rates and relative
    performance in middle rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = last_round_cooperators / (self.n_players - 1)
        my_total_score = sum(history.my_payoffs)
        opponent_total_scores = [sum(history.opponent_payoffs[:, i]) for i in range(self.n_players - 1)]
        average_opponent_score = sum(opponent_total_scores) / len(opponent_total_scores)
        if history.round_number >= 2:
            prev_round_cooperators = sum(history.opponent_actions[last_round_idx - 1])
            prev_cooperation_rate = prev_round_cooperators / (self.n_players - 1)
            if cooperation_rate < 0.2 and prev_cooperation_rate < 0.2:
                return Action.D
        if current_round > self.n_rounds - 3:
            return Action.D
        if cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate >= 0.3:
            if my_total_score < average_opponent_score - 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_56(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predatory Defector"
    
    This strategy operates on ruthless exploitation - maximizing personal payoff by free-riding 
    on others' cooperation while punishing any attempts at retaliation. Always defects in first 
    and last rounds, and exploits high cooperation rates in between.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / self.game_description.n_players
        my_last_payoff = history.my_payoffs[last_round_idx]
        expected_defection_payoff = 1 + self.game_description.k / self.game_description.n_players * cooperators_last_round
        if cooperation_rate >= 0.6:
            return Action.D
        if cooperation_rate >= 0.3:
            if my_last_payoff < expected_defection_payoff:
                return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_57(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    
    Operates on maximum exploitation with minimal risk. Always defects in first 2 rounds,
    uses conditional defection in middle rounds (only cooperating occasionally when 
    cooperation rate >= 40% to maintain exploitation opportunities), and always defects
    in final 2 rounds for maximum endgame extraction.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        k = self.game_description.k
        if current_round <= 2:
            return Action.D
        if current_round >= total_rounds - 1:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / (n_players - 1)
        if cooperation_rate >= 0.6 and current_round > total_rounds / 2:
            return Action.D
        elif cooperation_rate >= 0.4:
            if current_round % 4 == 0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_58(BaseStrategy):
    """
    Exploitative Defector: An aggressive strategy that exploits cooperative opponents
    while contributing minimally to the public good. Starts with pure defection,
    occasionally cooperates only to maintain exploitable cooperation levels, and
    returns to pure defection in endgame scenarios.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_detected = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        n_opponents = self.game_description.n_players - 1
        if round_number == n_rounds:
            return Action.D
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        cooperation_rate = last_round_cooperators / n_opponents
        my_contribution_history = sum(history.my_actions)
        if len(history.my_actions) >= 2:
            if history.my_actions[-1] and len(history.my_actions) >= 2 and (sum(history.opponent_actions[-2]) > sum(history.opponent_actions[-1])):
                self.punishment_detected = True
        if self.punishment_detected:
            return Action.D
        endgame_threshold = max(1, int(0.8 * n_rounds))
        if round_number > endgame_threshold:
            return Action.D
        if cooperation_rate >= 0.6:
            return Action.D
        elif cooperation_rate >= 0.3 and my_contribution_history <= 1:
            if round_number % 3 == 0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_59(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes individual payoff by exploiting 
    cooperative behavior while minimizing own cooperation. Defaults to defection with calculated 
    cooperation only when it serves selfish interests.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_streak = 0
        self.cooperation_threshold = max(1, int(game_description.n_players * game_description.k / (game_description.n_players + 1)))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.defection_streak = 1
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            total_cooperators_last_round = cooperators_last_round + 1
        else:
            total_cooperators_last_round = cooperators_last_round
        if cooperators_last_round >= self.cooperation_threshold:
            if self.defection_streak >= 3:
                self.defection_streak = 0
                return Action.C
            else:
                self.defection_streak += 1
                return Action.D
        else:
            self.defection_streak += 1
            return Action.D

class Strategy_AGGRESSIVE_60(BaseStrategy):
    """
    Aggressive "Ruthless Opportunist" strategy that prioritizes individual payoff maximization
    through calculated exploitation while maintaining cooperation only when profitable.
    Aggressively punishes non-cooperators and exploits high cooperation situations.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.r = game_description.n_rounds
        self.cooperation_threshold = math.ceil(self.n * self.k / (self.k + self.n - 1))
        self.consecutive_defection_limit = 2
        self.punishment_rounds = 3
        self.consecutive_low_cooperation = 0
        self.punishment_mode = False
        self.punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        if cooperators_last_round < self.cooperation_threshold:
            self.consecutive_low_cooperation += 1
            if self.consecutive_low_cooperation >= self.consecutive_defection_limit:
                self.punishment_mode = True
                self.punishment_counter = self.punishment_rounds
            return Action.D
        if self.punishment_mode:
            self.punishment_counter -= 1
            if self.punishment_counter <= 0:
                self.punishment_mode = False
                self.consecutive_low_cooperation = 0
            return Action.D
        if cooperators_last_round >= self.n - 1:
            return Action.D
        self.consecutive_low_cooperation = 0
        return Action.C

class Strategy_AGGRESSIVE_61(BaseStrategy):
    """
    Aggressive "Exploit-First Retaliation" strategy that maximizes personal payoffs
    by exploiting cooperation while punishing defection with overwhelming force.
    Always defects first and last rounds, with conditional exploitation in between.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if current_round == r:
            return Action.D
        last_round_idx = history.round_number - 1
        last_opponent_actions = history.opponent_actions[last_round_idx]
        total_cooperators_last_round = sum(last_opponent_actions)
        if history.my_actions[last_round_idx]:
            total_cooperators_last_round += 1
        cooperation_rate = total_cooperators_last_round / n
        my_last_payoff = history.my_payoffs[last_round_idx]
        opponent_payoffs_last_round = history.opponent_payoffs[last_round_idx]
        average_opponent_payoff = sum(opponent_payoffs_last_round) / len(opponent_payoffs_last_round)
        my_payoff_advantage = my_last_payoff - average_opponent_payoff
        if current_round == r - 1:
            current_total_score = sum(history.my_payoffs)
            opponent_total_scores = [sum(history.opponent_payoffs[:, i]) for i in range(len(opponent_payoffs_last_round))]
            average_opponent_score = sum(opponent_total_scores) / len(opponent_total_scores)
            if current_total_score > average_opponent_score:
                return Action.D
            elif cooperation_rate > 0.3:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= 0.5:
            if my_payoff_advantage > 0:
                return Action.D
            else:
                return Action.C
        elif cooperation_rate <= 0.2:
            return Action.D
        elif history.round_number > 1:
            prev_round_idx = history.round_number - 2
            prev_opponent_actions = history.opponent_actions[prev_round_idx]
            prev_total_cooperators = sum(prev_opponent_actions)
            if history.my_actions[prev_round_idx]:
                prev_total_cooperators += 1
            prev_cooperation_rate = prev_total_cooperators / n
            if prev_cooperation_rate > cooperation_rate:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_62(BaseStrategy):
    """
    Predatory Exploiter: An aggressive strategy that maximizes individual payoffs through 
    strategic exploitation while maintaining minimal cooperation only when necessary to 
    keep the public good viable for continued free-riding.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.cooperation_threshold = self.k / self.n_players
        self.endgame_rounds = min(3, self.n_rounds // 4)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round > self.n_rounds - self.endgame_rounds:
            return Action.D
        recent_rounds = min(3, history.round_number)
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history, recent_rounds)
        if recent_cooperation_rate >= self.cooperation_threshold:
            return Action.D
        if recent_cooperation_rate < self.cooperation_threshold * 0.7:
            if current_round % 2 == 1:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, recent_rounds: int) -> float:
        """Calculate cooperation rate over the most recent rounds."""
        if recent_rounds == 0:
            return 0.0
        total_cooperators = 0
        total_possible = 0
        start_round = max(0, history.round_number - recent_rounds)
        for round_idx in range(start_round, history.round_number):
            opponent_cooperators = sum(history.opponent_actions[round_idx])
            my_cooperation = 1 if history.my_actions[round_idx] else 0
            total_cooperators += opponent_cooperators + my_cooperation
            total_possible += self.n_players
        return total_cooperators / total_possible if total_possible > 0 else 0.0

class Strategy_AGGRESSIVE_63(BaseStrategy):
    """
    Exploitative Enforcer: Aggressively exploits cooperative opponents while maintaining
    credible deterrence. Starts with defection, exploits high-cooperation environments,
    and uses selective cooperation only as a manipulation tool.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        if current_round == r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx]) + int(history.my_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / n
        my_contribution = int(history.my_actions[last_round_idx])
        total_contributions = cooperators_last_round
        my_last_payoff = 1 - my_contribution + k / n * total_contributions
        opponent_contributions = history.opponent_actions[last_round_idx]
        total_payoff = 0
        for i in range(len(opponent_contributions)):
            opponent_payoff = 1 - int(opponent_contributions[i]) + k / n * total_contributions
            total_payoff += opponent_payoff
        total_payoff += my_last_payoff
        average_payoff_last_round = total_payoff / n
        if cooperation_rate >= 0.6:
            return Action.D
        elif cooperation_rate >= 0.3:
            if my_last_payoff < average_payoff_last_round:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_64(BaseStrategy):
    """
    Opportunistic Exploiter - An aggressive strategy that maximizes personal payoffs
    by exploiting cooperative players while minimizing personal contributions.
    
    Core behavior:
    - Always defects in first and last two rounds
    - Exploits when enough cooperators are present
    - Seeds cooperation only when necessary to rebuild exploitable base
    - Uses threshold-based decision making for optimal exploitation
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round >= n_rounds - 1:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_threshold = max(2, n_players // 3)
        if cooperators_last_round >= cooperation_threshold:
            return Action.D
        elif cooperators_last_round == 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_65(BaseStrategy):
    """
    Exploitative Defector - An aggressive strategy that exploits cooperative opponents
    while maximizing individual gain. Always defects in first and last rounds,
    and primarily defects in middle rounds unless public good returns are substantial.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / self.n
        rounds_remaining = self.r - current_round
        if rounds_remaining <= 3:
            return Action.D
        if history.round_number >= 2:
            prev_round_idx = history.round_number - 2
            cooperators_prev_round = sum(history.opponent_actions[prev_round_idx])
            if history.my_actions[prev_round_idx]:
                cooperators_prev_round += 1
            prev_cooperation_rate = cooperators_prev_round / self.n
            recent_trend = cooperation_rate - prev_cooperation_rate
            if recent_trend > 0.1:
                return Action.D
        if cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate >= 0.3:
            return Action.D
        else:
            predicted_cooperators = cooperation_rate * self.n
            if predicted_cooperators >= 2 and self.k * cooperation_rate >= 1.2:
                return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_66(BaseStrategy):
    """
    Aggressive "Exploitative Defector" strategy that prioritizes maximizing personal payoff
    by free-riding on others' contributions while minimizing own contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0
        self.cooperation_count = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        if current_round >= r - 1:
            return Action.D
        self.cooperation_count = sum(history.my_actions)
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx])
        if history.my_actions[prev_round_idx]:
            prev_cooperators += 1
        cooperation_rate = prev_cooperators / n
        if cooperation_rate < 0.5:
            self.punishment_rounds_remaining = 2
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        min_cooperators_threshold = math.ceil((n + 1) / 2)
        max_own_cooperations = math.floor(r / 4)
        expected_others_cooperate = prev_cooperators - (1 if history.my_actions[prev_round_idx] else 0)
        payoff_cooperate = k / n * (expected_others_cooperate + 1)
        payoff_defect = 1 + k / n * expected_others_cooperate
        conditions_met = prev_cooperators >= min_cooperators_threshold and current_round <= r - 2 and (self.cooperation_count < max_own_cooperations) and (payoff_cooperate > payoff_defect + 0.1)
        if conditions_met:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_67(BaseStrategy):
    """
    Predatory Defector: An aggressive exploitation strategy that maximizes individual payoff 
    by systematically exploiting cooperators while punishing competition. Operates with 
    immediate dominance, systematic exploitation of high-cooperation environments, and 
    ruthless endgame behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        if current_round >= r - 2:
            return Action.D
        if current_round >= r * 0.8:
            prev_round_idx = history.round_number - 1
            prev_cooperators = sum(history.opponent_actions[prev_round_idx])
            if history.my_actions[prev_round_idx]:
                prev_cooperators += 1
            prev_coop_rate = prev_cooperators / n
            if prev_coop_rate < 0.5:
                return Action.D
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx])
        if history.my_actions[prev_round_idx]:
            prev_cooperators += 1
        prev_coop_rate = prev_cooperators / n
        if prev_coop_rate >= 0.6:
            return Action.D
        elif prev_coop_rate >= 0.3:
            my_defection_streak = self._get_my_defection_streak(history)
            if my_defection_streak >= 3:
                return Action.C
            else:
                return Action.D
        elif self._any_player_cooperated_last_round(history):
            return Action.D
        else:
            return Action.D

    def _get_my_defection_streak(self, history: PlayerHistory) -> int:
        """Count consecutive defections by me from the most recent round backwards."""
        streak = 0
        for i in range(history.round_number - 1, -1, -1):
            if not history.my_actions[i]:
                streak += 1
            else:
                break
        return streak

    def _any_player_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """Check if any player (including me) cooperated in the last round."""
        prev_round_idx = history.round_number - 1
        if history.my_actions[prev_round_idx]:
            return True
        return any(history.opponent_actions[prev_round_idx])

class Strategy_AGGRESSIVE_68(BaseStrategy):
    """
    Aggressive Predatory Exploiter strategy that maximizes personal payoff by 
    exploiting cooperative players while minimizing personal contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx])
        if history.my_actions[prev_round_idx]:
            prev_cooperators += 1
        cooperation_rate = prev_cooperators / n
        if current_round >= r - 2:
            return Action.D
        if cooperation_rate >= 0.6:
            return Action.D
        elif cooperation_rate >= 0.3:
            return Action.D
        elif cooperation_rate < 0.2:
            if current_round <= r * 0.3:
                if random.random() < 0.2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_69(BaseStrategy):
    """
    Aggressive Exploit-First Punisher Strategy: Maximizes individual payoff by defaulting to 
    defection, exploiting cooperation opportunities, and using credible punishment to deter 
    exploitation by others.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.cooperation_count = None
        self.punishment_mode = False
        self.punishment_target = None
        self.punishment_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if self.cooperation_count is None:
            self.cooperation_count = np.zeros(self.n_players - 1)
        if history.round_number > 0:
            for round_idx in range(history.round_number):
                for player_idx in range(self.n_players - 1):
                    if history.opponent_actions[round_idx, player_idx]:
                        self.cooperation_count[player_idx] = np.sum(history.opponent_actions[:round_idx + 1, player_idx])
        if self.punishment_mode:
            self.punishment_rounds_remaining -= 1
            if self.punishment_rounds_remaining <= 0:
                self.punishment_mode = False
                self.punishment_target = None
            return Action.D
        if current_round == self.n_rounds:
            return Action.D
        early_rounds = max(1, int(0.2 * self.n_rounds))
        if current_round <= early_rounds:
            return Action.D
        total_rounds_played = history.round_number
        if total_rounds_played > 0:
            total_cooperation_sum = 0
            for player_idx in range(self.n_players - 1):
                player_coop_count = np.sum(history.opponent_actions[:total_rounds_played, player_idx])
                player_coop_rate = player_coop_count / total_rounds_played
                total_cooperation_sum += player_coop_count
                if player_coop_rate < 0.3:
                    my_coop_count = np.sum(history.my_actions)
                    total_coop_rate = (total_cooperation_sum + my_coop_count) / (total_rounds_played * self.n_players)
                    if total_coop_rate < 0.5:
                        self.punishment_mode = True
                        self.punishment_target = player_idx
                        self.punishment_rounds_remaining = min(3, self.n_rounds - current_round)
                        return Action.D
        if total_rounds_played > 0:
            my_coop_count = np.sum(history.my_actions)
            opponent_coop_sum = np.sum(history.opponent_actions[:total_rounds_played, :])
            total_coop_rate = (opponent_coop_sum + my_coop_count) / (total_rounds_played * self.n_players)
            expected_cooperators = 0
            for player_idx in range(self.n_players - 1):
                recent_rounds = min(3, total_rounds_played)
                recent_coop_rate = np.sum(history.opponent_actions[total_rounds_played - recent_rounds:, player_idx]) / recent_rounds
                expected_cooperators += recent_coop_rate
            my_expected_benefit = self.k / self.n_players * (expected_cooperators + 1) - 1
            last_10_percent = 0.9 * self.n_rounds
            if total_coop_rate > 0.6 and current_round < last_10_percent and (my_expected_benefit > 0.1):
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_70(BaseStrategy):
    """
    Exploitative Opportunist: An aggressive strategy that maximizes personal payoff by exploiting 
    cooperative players while minimizing personal contributions. Only cooperates when exploitation 
    opportunities exist, with zero tolerance for being exploited and aggressive endgame behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.permanent_defection_mode = False
        self.cooperated_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.cooperated_last_round = False
            return Action.D
        round_number = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if round_number > 3 * r // 4:
            self.cooperated_last_round = False
            return Action.D
        if self.cooperated_last_round:
            last_round_idx = history.round_number - 1
            opponent_cooperators = sum(history.opponent_actions[last_round_idx])
            total_cooperators = opponent_cooperators + 1
            if total_cooperators < n:
                self.permanent_defection_mode = True
        if self.permanent_defection_mode:
            self.cooperated_last_round = False
            return Action.D
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        if opponent_cooperators >= n - 2:
            self.cooperated_last_round = True
            return Action.C
        else:
            self.cooperated_last_round = False
            return Action.D

class Strategy_AGGRESSIVE_71(BaseStrategy):
    """
    Exploitative Punisher: An aggressive strategy that maximizes individual payoffs
    through systematic exploitation of cooperative players while maintaining minimal
    cooperation investments and credible punishment mechanisms.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.3

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        n_opponents = self.game_description.n_players - 1
        cooperation_rates = []
        for opponent_idx in range(n_opponents):
            cooperations = sum(history.opponent_actions[:, opponent_idx])
            cooperation_rate = cooperations / history.round_number
            cooperation_rates.append(cooperation_rate)
        reliable_cooperators = sum((1 for rate in cooperation_rates if rate > self.cooperation_threshold))
        if reliable_cooperators >= 2:
            return Action.D
        elif reliable_cooperators == 1:
            danger_threshold = max(3, total_rounds // 4)
            if total_rounds - current_round < danger_threshold:
                return Action.D
            else:
                return Action.D
        elif current_round % 4 == 0 and current_round < total_rounds - 2:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_72(BaseStrategy):
    """
    Aggressive "Predatory Exploiter" strategy that maximizes personal payoffs by exploiting 
    cooperative players while minimizing own contributions. Uses conditional exploitation 
    based on cooperation rates and strategic deception through occasional fake cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if current_round > total_rounds * 0.8:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators_last_round = last_round_opponent_cooperators
        if my_last_action:
            total_cooperators_last_round += 1
        cooperation_rate = total_cooperators_last_round / n
        if cooperation_rate >= 0.6:
            return Action.D
        elif cooperation_rate >= 0.3:
            if current_round % 4 == 0 and (not my_last_action):
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_73(BaseStrategy):
    """
    Predatory Exploitation Strategy: Aggressively exploits cooperation while minimizing
    personal contributions. Defects by default, only cooperates in emergency situations
    when the public good is near collapse.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.r = game_description.n_rounds
        self.exploitation_threshold = max(2, self.n // 3)
        self.survival_threshold = max(1, self.n // 5)
        self.cooperation_pressure = self.n - 2

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperator_count = int(sum(history.opponent_actions[last_round_idx]))
        if history.my_actions[last_round_idx]:
            cooperator_count += 1
        defector_count = self.n - cooperator_count
        if cooperator_count >= self.exploitation_threshold:
            return Action.D
        if cooperator_count < self.survival_threshold and defector_count > self.cooperation_pressure:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_74(BaseStrategy):
    """
    Punitive Free-Rider: An aggressive strategy that exploits cooperative players while 
    punishing defectors. Starts with defection, continues defecting when sufficient 
    cooperation exists to exploit, and only cooperates briefly to prevent total collapse 
    of the public good. Always defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperator_count = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperator_count += 1
        high_coop_threshold = self.n_players / 2
        low_coop_threshold = self.n_players / 3
        chronic_defectors = 0
        if history.round_number >= 3:
            for player_idx in range(len(history.opponent_actions[0])):
                defection_rate = 1 - sum((history.opponent_actions[round_idx][player_idx] for round_idx in range(history.round_number))) / history.round_number
                if defection_rate >= 0.7:
                    chronic_defectors += 1
        if current_round > self.n_rounds * 0.8:
            return Action.D
        if cooperator_count >= high_coop_threshold:
            return Action.D
        elif cooperator_count >= low_coop_threshold:
            if history.my_actions[last_round_idx]:
                return Action.D
            else:
                return Action.D
        else:
            public_good_value = self.k / self.n_players * cooperator_count
            if public_good_value < 0.5:
                if not history.my_actions[last_round_idx]:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_AGGRESSIVE_75(BaseStrategy):
    """
    Exploitive Punisher: An aggressive strategy that maximizes individual payoffs by exploiting 
    cooperative opponents while harshly punishing defection. Starts with defection, occasionally 
    cooperates to maintain exploitation opportunities, and always defects in the final rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round >= n_rounds - 1:
            return Action.D
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        cooperation_rate = last_round_cooperators / n_players
        my_total_cooperations = sum(history.my_actions)
        if cooperation_rate >= 0.5:
            if my_total_cooperations <= 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_76(BaseStrategy):
    """
    Exploitative Defector with Punishment - An aggressive strategy that exploits cooperative 
    environments while punishing competitors and maintaining just enough cooperation to 
    sustain exploitable opportunities.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.competitor_markers = set()
        self.previous_cooperation_rate = 0.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == total_rounds - 1:
            return Action.D
        last_round_idx = current_round - 1
        cooperators_count = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_count += 1
        cooperation_rate = cooperators_count / n_players
        my_last_action = Action.C if history.my_actions[last_round_idx] else Action.D
        self._update_competitors(history, last_round_idx)
        if current_round > 0.8 * total_rounds:
            defection_bias = (current_round - 0.8 * total_rounds) / (0.2 * total_rounds)
            if cooperation_rate < 0.4 or defection_bias > 0.7:
                return Action.D
            elif cooperation_rate >= 0.7:
                return Action.D
            else:
                return Action.C
        if cooperation_rate >= 0.6:
            return Action.D
        elif cooperation_rate >= 0.3:
            if my_last_action == Action.D and cooperation_rate > self.previous_cooperation_rate:
                action = Action.D
            elif cooperation_rate < 0.2:
                action = Action.C
            else:
                action = Action.D
            if self.competitor_markers and cooperation_rate >= 0.25 and (cooperation_rate <= 0.45):
                action = Action.D
            return action
        elif cooperation_rate == 0:
            return Action.D
        else:
            return Action.C

    def _update_competitors(self, history: PlayerHistory, last_round_idx: int):
        """Track players who defect when cooperation would be profitable"""
        if last_round_idx < 1:
            return
        if last_round_idx > 0:
            prev_cooperators = sum(history.opponent_actions[last_round_idx - 1])
            if history.my_actions[last_round_idx - 1]:
                prev_cooperators += 1
            self.previous_cooperation_rate = prev_cooperators / self.game_description.n_players
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate_last = (cooperators_last_round + (1 if history.my_actions[last_round_idx] else 0)) / self.game_description.n_players
        if cooperation_rate_last >= 0.5:
            for player_idx in range(len(history.opponent_actions[last_round_idx])):
                if not history.opponent_actions[last_round_idx][player_idx]:
                    self.competitor_markers.add(player_idx)

class Strategy_AGGRESSIVE_77(BaseStrategy):
    """
    Exploitative Punisher: An aggressive strategy that always defects to maximize personal payoffs
    by exploiting cooperative opponents while maintaining punishment immunity. Features initial
    exploitation, conditional aggression with punishment escalation, and endgame exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_counter = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        k = self.game_description.k
        if current_round <= 2:
            return Action.D
        if current_round >= total_rounds - 1:
            return Action.D
        if history.round_number >= 1:
            all_defect_payoff = 1.0
            my_previous_payoff = history.my_payoffs[history.round_number - 1]
            if my_previous_payoff < all_defect_payoff:
                self.punishment_counter = 2
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_78(BaseStrategy):
    """
    Aggressive "Predatory Exploiter" strategy that never cooperates and aims to exploit
    any cooperation by other players while discouraging cooperative behavior through
    relentless defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        n_opponents = self.game_description.n_players - 1
        cooperation_rate = cooperators_last_round / n_opponents if n_opponents > 0 else 0
        return Action.D

class Strategy_AGGRESSIVE_79(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that exploits cooperative players
    while minimizing exposure to exploitation. Defects in round 1 and final round,
    and cooperates in middle rounds only when enough others cooperate to make it profitable.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.cooperation_threshold = math.ceil(n * k / (n + k))

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_index = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_index])
        if cooperators_last_round >= self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_80(BaseStrategy):
    """
    Aggressive "Exploit-First Punisher" strategy that prioritizes maximizing personal payoff
    through aggressive defection while exploiting cooperative opponents. Always defects in
    first and last rounds, and exploits any cooperation attempts by others.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n = self.game_description.n_players
        k = self.game_description.k
        if current_round == total_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = last_round_cooperators / (n - 1)
        rounds_remaining = total_rounds - current_round
        if rounds_remaining <= 3 and cooperation_rate > 0:
            return Action.D
        if cooperation_rate >= 0.5:
            return Action.D
        my_cumulative_payoff = sum(history.my_payoffs)
        total_cooperation = 0
        for round_idx in range(history.round_number):
            total_cooperation += sum(history.opponent_actions[round_idx])
        avg_cooperation_rate = total_cooperation / (history.round_number * (n - 1))
        estimated_defector_payoff = history.round_number * (1 + k / n * avg_cooperation_rate * (n - 1))
        if my_cumulative_payoff < estimated_defector_payoff:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_81(BaseStrategy):
    """
    Predatory Exploiter: An aggressive strategy that maximizes personal payoffs by 
    exploiting cooperative opponents while minimizing own contributions. Defects by 
    default but occasionally cooperates to maintain a profitable cooperative environment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        total_cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            total_cooperators_last_round += 1
        cooperation_rate = total_cooperators_last_round / self.game_description.n_players
        my_last_payoff = history.my_payoffs[last_round_idx]
        opponent_payoffs_last_round = history.opponent_payoffs[last_round_idx]
        average_opponent_payoff = sum(opponent_payoffs_last_round) / len(opponent_payoffs_last_round)
        if average_opponent_payoff > 0:
            my_relative_performance = my_last_payoff / average_opponent_payoff
        else:
            my_relative_performance = 1.0
        if cooperation_rate >= 0.6 and my_relative_performance < 1.2:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_82(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predatory Defector"
    
    This strategy maximizes personal payoff through systematic exploitation while minimizing 
    vulnerability. It uses deceptive cooperation to maintain trust when exploiting cooperative 
    opponents, while defaulting to aggressive defection otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.exploitation_mode = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        n_opponents = self.game_description.n_players - 1
        last_round_opponents = history.opponent_actions[history.round_number - 1]
        cooperation_rate = sum(last_round_opponents) / n_opponents
        my_last_action = history.my_actions[history.round_number - 1]
        if current_round >= n_rounds - 1:
            return Action.D
        if current_round == 2:
            if cooperation_rate >= 0.7:
                self.exploitation_mode = True
                return Action.C
            else:
                return Action.D
        if self.exploitation_mode:
            if cooperation_rate >= 0.6 and my_last_action:
                if random.random() < 0.3:
                    return Action.D
                else:
                    return Action.C
            else:
                self.exploitation_mode = False
                return Action.D
        elif cooperation_rate >= 0.8:
            self.exploitation_mode = True
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_83(BaseStrategy):
    """
    Exploitative Defector: An aggressive strategy designed to maximize individual payoffs
    by exploiting cooperative opponents while minimizing vulnerability to exploitation.
    Always defects in first and last rounds, exploits high cooperation rates, and only
    cooperates minimally to restart exploitation cycles.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate_last_round = last_round_cooperators / (self.game_description.n_players - 1)
        if cooperation_rate_last_round >= 0.5:
            return Action.D
        my_last_payoff = history.my_payoffs[last_round_idx]
        opponent_avg_payoff = np.mean(history.opponent_payoffs[last_round_idx])
        if my_last_payoff < opponent_avg_payoff:
            return Action.D
        consecutive_low_cooperation = 0
        for i in range(min(3, history.round_number)):
            round_idx = last_round_idx - i
            if round_idx >= 0:
                round_cooperators = sum(history.opponent_actions[round_idx])
                round_cooperation_rate = round_cooperators / (self.game_description.n_players - 1)
                if round_cooperation_rate < 0.3:
                    consecutive_low_cooperation += 1
                else:
                    break
        if consecutive_low_cooperation >= 2:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_84(BaseStrategy):
    """
    Aggressive Strategy: "Exploitation with Conditional Punishment"
    
    This strategy maximizes personal payoff by exploiting cooperative players while
    quickly punishing those who threaten gains. It uses calculated cooperation only
    as a tool to maintain exploitable conditions, with no genuine reciprocity.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = math.floor(game_description.n_players * game_description.k / game_description.n_players)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        my_last_action_was_defect = not history.my_actions[last_round_idx]
        if cooperators_last_round >= self.cooperation_threshold:
            return Action.D
        elif cooperators_last_round < self.cooperation_threshold and my_last_action_was_defect:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_85(BaseStrategy):
    """
    Predatory Defector: An aggressive strategy that maximizes personal gain through 
    ruthless exploitation. Always defects except for rare strategic cooperation 
    designed to bait opponents into cooperating more.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n = self.game_description.n_players
        if current_round == total_rounds:
            return Action.D
        if history.round_number > 0:
            last_round_idx = history.round_number - 1
            cooperators_last_round = sum(history.opponent_actions[last_round_idx])
            if history.my_actions[last_round_idx]:
                cooperators_last_round += 1
            majority_cooperated_last = cooperators_last_round > n / 2
        else:
            majority_cooperated_last = False
        my_recent_defections = 0
        start_idx = max(0, history.round_number - 2)
        for i in range(start_idx, history.round_number):
            if not history.my_actions[i]:
                my_recent_defections += 1
        if current_round <= 3 and majority_cooperated_last and (my_recent_defections >= 2):
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_86(BaseStrategy):
    """
    Aggressive Punitive Free-Rider Strategy.
    
    This strategy maximizes personal payoffs by exploiting cooperative players while 
    ruthlessly punishing any attempt at retaliation. It operates on aggressive defection 
    combined with targeted punishment to dominate more cooperative strategies.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.expected_payoff_threshold = 1 + self.k / self.n * (self.n * 0.4)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        endgame_threshold = max(2, int(self.r * 0.1))
        if self.r - current_round < endgame_threshold:
            return Action.D
        if current_round == 2:
            last_round_cooperators = sum(history.opponent_actions[0])
            cooperation_rate = last_round_cooperators / len(history.opponent_actions[0])
            return Action.D
        rounds_to_check = min(3, history.round_number)
        recent_rounds_start = max(0, history.round_number - rounds_to_check)
        total_cooperators = 0
        total_possible = 0
        for round_idx in range(recent_rounds_start, history.round_number):
            total_cooperators += sum(history.opponent_actions[round_idx])
            total_possible += len(history.opponent_actions[round_idx])
        recent_coop_rate = total_cooperators / total_possible if total_possible > 0 else 0
        recent_payoffs = history.my_payoffs[recent_rounds_start:history.round_number]
        my_recent_payoff = sum(recent_payoffs) / len(recent_payoffs) if len(recent_payoffs) > 0 else 0
        consecutive_defections = 0
        for i in range(history.round_number - 1, -1, -1):
            if not history.my_actions[i]:
                consecutive_defections += 1
            else:
                break
        if my_recent_payoff > self.expected_payoff_threshold:
            return Action.D
        elif recent_coop_rate < 0.3:
            if consecutive_defections >= 3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_87(BaseStrategy):
    """
    Aggressive Conditional Defector with Exploitation strategy.
    Exploits early, cooperates only when many others do, and defects in endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.4
        self.exploitation_rounds = max(2, game_description.n_rounds // 4)
        self.endgame_threshold = max(2, game_description.n_rounds // 5)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round <= self.exploitation_rounds:
            return Action.D
        if current_round > n_rounds - self.endgame_threshold:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / n_players
        if cooperation_rate >= self.cooperation_threshold:
            start_idx = max(0, history.round_number - 3)
            recent_rounds = history.opponent_actions[start_idx:history.round_number]
            total_cooperators = 0
            total_decisions = 0
            for round_actions in recent_rounds:
                total_cooperators += sum(round_actions)
                total_decisions += n_players
            recent_cooperation_trend = total_cooperators / total_decisions if total_decisions > 0 else 0
            if recent_cooperation_trend >= self.cooperation_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_88(BaseStrategy):
    """
    Aggressive Strategy: Exploitative Hawk
    
    This strategy maximizes individual payoff through aggressive exploitation of cooperative opponents
    while quickly punishing attempts at exploitation. Operates on the principle that cooperation is
    only valuable when you can free-ride on others' contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number
        n = self.game_description.n_players
        k = self.game_description.k
        r = self.game_description.n_rounds
        if round_number >= r - 1:
            return Action.D
        if round_number == 1:
            cooperators_last_round = sum(history.opponent_actions[0])
            return Action.D
        last_round_idx = round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / (n - 1)
        my_contributed = 1 if history.my_actions[last_round_idx] else 0
        total_contributions = cooperators_last_round + my_contributed
        my_last_payoff = 1 - my_contributed + k / n * total_contributions
        if cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate >= 0.3 and my_last_payoff < 1.5:
            return Action.D
        elif cooperation_rate < 0.2:
            return Action.D
        else:
            if round_number >= 2:
                prev_cooperators = sum(history.opponent_actions[last_round_idx - 1])
                expected_cooperators = max(0, min(n - 1, cooperators_last_round))
            else:
                expected_cooperators = cooperators_last_round
            expected_payoff_if_cooperate = k / n * (expected_cooperators + 1)
            expected_payoff_if_defect = 1 + k / n * expected_cooperators
            if expected_payoff_if_defect >= expected_payoff_if_cooperate:
                return Action.D
            else:
                return Action.C

class Strategy_AGGRESSIVE_89(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that uses first-round cooperation 
    as deception to set up exploitation, then consistently defects to maximize personal 
    payoff while free-riding on others' contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_90(BaseStrategy):
    """
    Exploitative Punisher: An aggressive strategy that maximizes payoffs through strategic exploitation
    while maintaining credible punishment resistance mechanisms.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.baseline_defection_rate = 0.5

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / (self.n - 1)
        if cooperation_rate >= 0.6:
            return Action.D
        elif cooperation_rate >= 0.3:
            if current_round % 4 == 0:
                return Action.C
            else:
                return Action.D
        elif self._has_been_targeted_for_punishment(history):
            return Action.C
        else:
            return Action.D

    def _has_been_targeted_for_punishment(self, history: PlayerHistory) -> bool:
        """Detect if this player is being targeted for coordinated punishment."""
        current_round = history.round_number
        if current_round < 3:
            return False
        start_idx = max(0, current_round - 3)
        my_recent_actions = history.my_actions[start_idx:]
        my_recent_defection_rate = sum(1 - my_recent_actions) / len(my_recent_actions)
        others_recent_defections = 0
        total_others_actions = 0
        for round_idx in range(start_idx, current_round):
            round_defections = sum(1 - history.opponent_actions[round_idx])
            others_recent_defections += round_defections
            total_others_actions += self.n - 1
        if total_others_actions == 0:
            return False
        others_recent_defection_rate = others_recent_defections / total_others_actions
        return others_recent_defection_rate > self.baseline_defection_rate + 0.3

    def _all_players_defected_last_rounds(self, history: PlayerHistory, rounds_back: int=2) -> bool:
        """Check if all players (including self) defected in the last N rounds."""
        current_round = history.round_number
        if current_round < rounds_back:
            return False
        for i in range(rounds_back):
            round_idx = current_round - 1 - i
            if history.my_actions[round_idx]:
                return False
            if sum(history.opponent_actions[round_idx]) > 0:
                return False
        return True

class Strategy_AGGRESSIVE_91(BaseStrategy):
    """
    Aggressive 'Exploit and Punish' strategy that maximizes individual payoffs through 
    strategic exploitation while maintaining punishment mechanisms. Defaults to defection
    but cooperates selectively when it can leverage the public good for greater gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defection_streak = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / n
        my_contrib = 1 if history.my_actions[last_round_idx] else 0
        total_contrib = cooperators_last_round
        my_last_payoff = 1 - my_contrib + k / n * total_contrib
        avg_payoff_all_coop = k
        if self.defection_streak > 0:
            self.defection_streak -= 1
            return Action.D
        if history.round_number >= 2:
            prev_round_idx = history.round_number - 2
            prev_cooperators = sum(history.opponent_actions[prev_round_idx])
            if history.my_actions[prev_round_idx]:
                prev_cooperators += 1
            prev_cooperation_rate = prev_cooperators / n
            if cooperation_rate < prev_cooperation_rate - 0.2:
                remaining_rounds = r - current_round
                self.defection_streak = min(3, remaining_rounds)
                return Action.D
        high_coop_threshold = 0.8 if k >= n * 0.8 else 0.7
        mid_coop_threshold = 0.4
        if n <= 4:
            high_coop_threshold += 0.1
            mid_coop_threshold += 0.1
        if k <= 1.2:
            return Action.D if cooperation_rate <= 0.9 else Action.C
        if current_round == r - 1:
            my_defections = sum((1 for action in history.my_actions if not action))
            if cooperation_rate >= 0.6 and my_defections >= r * 0.7:
                return Action.C
            else:
                return Action.D
        if cooperation_rate >= high_coop_threshold:
            return Action.D
        elif cooperation_rate >= mid_coop_threshold:
            if my_last_payoff < avg_payoff_all_coop * 0.8:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_92(BaseStrategy):
    """
    Opportunistic Exploiter strategy: Aggressively exploits cooperation while minimizing own contributions.
    Starts with defection, exploits high cooperation rates, and maintains minimal reciprocity.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / (self.game_description.n_players - 1)
        my_last_payoff = history.my_payoffs[last_round_idx]
        if cooperation_rate >= 0.5 and my_last_payoff < 1.5:
            return Action.D
        elif cooperation_rate <= 0.2:
            return Action.D
        elif cooperation_rate > 0.2 and cooperation_rate < 0.5:
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_93(BaseStrategy):
    """
    Exploitative Hawk: An aggressive strategy that maximizes personal payoff through systematic exploitation
    while maintaining strategic flexibility to avoid complete deadlock scenarios.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        current_round = history.round_number + 1
        if current_round == r:
            return Action.D
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        last_round_coop_rate = total_cooperators / n
        consecutive_all_defect = 0
        for round_idx in range(history.round_number - 1, -1, -1):
            my_action_in_round = history.my_actions[round_idx]
            opponent_cooperators_in_round = sum(history.opponent_actions[round_idx])
            total_cooperators_in_round = opponent_cooperators_in_round + (1 if my_action_in_round else 0)
            if total_cooperators_in_round == 0:
                consecutive_all_defect += 1
            else:
                break
        my_last_payoff = history.my_payoffs[last_round_idx]
        avg_last_payoff = sum(history.opponent_payoffs[last_round_idx]) / (n - 1)
        if last_round_coop_rate >= 0.5:
            return Action.D
        elif last_round_coop_rate == 0:
            if consecutive_all_defect >= 2:
                return Action.C
            else:
                return Action.D
        elif my_last_payoff < avg_last_payoff:
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_94(BaseStrategy):
    """
    Aggressive exploitation strategy that maximizes personal payoff by free-riding on others' cooperation
    while strategically contributing just enough to maintain a profitable environment. Uses three phases:
    early exploitation, strategic manipulation, and endgame betrayal.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round <= total_rounds // 3:
            prev_round_idx = history.round_number - 1
            prev_cooperators = sum(history.opponent_actions[prev_round_idx])
            prev_coop_rate = prev_cooperators / (n_players - 1)
            if prev_coop_rate >= 0.8:
                return Action.C
            return Action.D
        if current_round > 2 * total_rounds // 3:
            return Action.D
        rounds_to_check = min(3, history.round_number)
        recent_coop_sum = 0
        for i in range(rounds_to_check):
            round_idx = history.round_number - 1 - i
            recent_coop_sum += sum(history.opponent_actions[round_idx])
        recent_coop_rate = recent_coop_sum / (rounds_to_check * (n_players - 1))
        rounds_to_check_defections = min(5, history.round_number)
        my_defections_last_5 = 0
        for i in range(rounds_to_check_defections):
            round_idx = history.round_number - 1 - i
            if not history.my_actions[round_idx]:
                my_defections_last_5 += 1
        if recent_coop_rate >= 0.6 and my_defections_last_5 >= 4:
            return Action.C
        elif recent_coop_rate <= 0.2:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_95(BaseStrategy):
    """
    Exploitative Defector: An aggressive strategy that maximizes personal payoff by 
    exploiting cooperative behavior while minimizing own contributions. Always defects 
    in round 1 and final round, with conditional exploitation in between based on 
    cooperation rates and relative performance.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = last_round_cooperators / (self.game_description.n_players - 1)
        if cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate >= 0.3:
            my_last_payoff = history.my_payoffs[last_round_idx]
            my_last_action = history.my_actions[last_round_idx]
            opponent_last_actions = history.opponent_actions[last_round_idx]
            defector_payoffs = []
            if not my_last_action:
                defector_payoffs.append(my_last_payoff)
            for i, opponent_action in enumerate(opponent_last_actions):
                if not opponent_action:
                    defector_payoffs.append(history.opponent_payoffs[last_round_idx, i])
            if defector_payoffs:
                avg_defector_payoff = sum(defector_payoffs) / len(defector_payoffs)
                if my_last_payoff < avg_defector_payoff:
                    return Action.C
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_96(BaseStrategy):
    """
    Aggressive 'Predatory Exploiter' strategy that maximizes personal payoff by 
    systematically exploiting cooperative players while minimizing own contributions.
    Always defects in first and last rounds, and uses conditional exploitation 
    based on opponent cooperation levels in middle rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        prev_round_idx = history.round_number - 1
        prev_cooperators = sum(history.opponent_actions[prev_round_idx])
        if history.my_actions[prev_round_idx]:
            prev_cooperators += 1
        my_cooperations = sum(history.my_actions)
        my_cooperation_rate = my_cooperations / history.round_number
        if prev_cooperators >= self.game_description.n_players / 2:
            return Action.D
        elif prev_cooperators >= 2:
            if my_cooperation_rate < 0.2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_97(BaseStrategy):
    """
    Exploitative Defector: An aggressive strategy that maximizes individual payoffs 
    through strategic exploitation while maintaining minimal cooperation to avoid isolation.
    Defects >85% of the time, targeting cooperative opponents for free-riding.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.4
        self.punishment_rounds = 2
        self.endgame_threshold = 3
        self.punishment_counter = 0
        self.in_punishment_mode = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round > total_rounds - self.endgame_threshold:
            return Action.D
        if self.in_punishment_mode:
            self.punishment_counter -= 1
            if self.punishment_counter <= 0:
                self.in_punishment_mode = False
            return Action.D
        cooperation_rate = self._calculate_opponent_cooperation_rate(history)
        my_recent_cooperation = self._calculate_my_cooperation_rate(history)
        if self._am_being_punished(history):
            if cooperation_rate >= 0.7:
                return Action.C
            else:
                self.in_punishment_mode = True
                self.punishment_counter = self.punishment_rounds
                return Action.D
        if cooperation_rate >= self.cooperation_threshold and my_recent_cooperation < 0.3:
            return Action.D
        elif cooperation_rate >= 0.7 and self._am_being_punished(history):
            return Action.C
        else:
            return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate opponent cooperation rate over last 3 rounds or all available rounds."""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 0.0
        start_round = max(0, history.round_number - rounds_to_check)
        recent_actions = history.opponent_actions[start_round:history.round_number]
        if recent_actions.size == 0:
            return 0.0
        total_cooperations = np.sum(recent_actions)
        total_actions = recent_actions.size
        return total_cooperations / total_actions

    def _calculate_my_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate my cooperation rate over last 3 rounds or all available rounds."""
        rounds_to_check = min(3, history.round_number)
        if rounds_to_check == 0:
            return 0.0
        start_round = max(0, history.round_number - rounds_to_check)
        recent_actions = history.my_actions[start_round:history.round_number]
        if len(recent_actions) == 0:
            return 0.0
        return np.sum(recent_actions) / len(recent_actions)

    def _am_being_punished(self, history: PlayerHistory) -> bool:
        """Check if being systematically punished based on payoffs."""
        if history.round_number < 2:
            return False
        recent_payoffs = history.my_payoffs[-2:]
        theoretical_defect_payoff = 1.0
        return np.mean(recent_payoffs) < theoretical_defect_payoff

class Strategy_AGGRESSIVE_98(BaseStrategy):
    """
    Exploitation Maximizer: An aggressive strategy that maximizes personal payoffs 
    through strategic exploitation while maintaining minimal cooperation to keep 
    the public good viable when profitable.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.k / 2
        self.punishment_rounds = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n = self.game_description.n_players
        if current_round == total_rounds:
            return Action.D
        recent_rounds = min(3, history.round_number)
        if recent_rounds == 0:
            recent_cooperation_rate = 0
        else:
            total_cooperators = 0
            for i in range(recent_rounds):
                round_idx = history.round_number - 1 - i
                cooperators_in_round = sum(history.opponent_actions[round_idx])
                if history.my_actions[round_idx]:
                    cooperators_in_round += 1
                total_cooperators += cooperators_in_round
            recent_cooperation_rate = total_cooperators / (n * recent_rounds)
        endgame_threshold = max(3, int(0.2 * total_rounds))
        rounds_remaining = total_rounds - current_round + 1
        if rounds_remaining <= endgame_threshold:
            if recent_cooperation_rate > 0.8:
                return Action.D
            else:
                return Action.D
        if recent_cooperation_rate > 0.6:
            return Action.D
        elif recent_cooperation_rate < 0.3:
            if self.punishment_rounds < 2:
                self.punishment_rounds += 1
                return Action.D
            else:
                self.punishment_rounds = 0
                return Action.C
        else:
            expected_cooperators = recent_cooperation_rate * n
            if expected_cooperators >= self.cooperation_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_AGGRESSIVE_99(BaseStrategy):
    """
    Aggressive "Exploit and Punish" strategy that defaults to defection while exploiting
    cooperative players and strategically cooperating only when it serves our interests.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        k = self.game_description.k
        r = self.game_description.n_rounds
        if current_round == r:
            return Action.D
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / n
        if cooperation_rate >= 0.5:
            return Action.D
        if cooperation_rate < 0.3:
            rounds_remaining = r - current_round
            if rounds_remaining > 3:
                return Action.C
            else:
                return Action.D
        my_last_payoff = history.my_payoffs[last_round_idx]
        opponent_payoffs = history.opponent_payoffs[last_round_idx]
        average_payoff = sum(opponent_payoffs) / len(opponent_payoffs)
        if my_last_payoff < average_payoff:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_100(BaseStrategy):
    """
    Aggressive "Exploitation Maximizer" strategy that prioritizes individual payoff 
    maximization through strategic exploitation of cooperative opponents while 
    minimizing personal risk.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == total_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        opponent_cooperators = int(sum(history.opponent_actions[last_round_idx]))
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / n_players
        my_last_payoff = history.my_payoffs[last_round_idx]
        if cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate >= 0.3 and my_last_payoff < 1.5:
            return Action.D
        elif cooperation_rate < 0.3 and cooperation_rate > 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_101(BaseStrategy):
    """
    Aggressive Exploitation with Punishment strategy for N-Player Public Goods Game.
    
    This strategy maximizes personal payoff by exploiting cooperative players while
    aggressively punishing defection. It primarily defects unless specific cooperation
    conditions are met, and uses escalating punishment against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_counter = 0
        self.exploitation_threshold = 0.6
        self.punishment_threshold = 0.4
        self.early_rounds = 2
        self.endgame_threshold = 0.15 * game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_number = history.round_number + 1
        if round_number <= self.early_rounds:
            return Action.D
        if round_number > self.game_description.n_rounds * (1 - self.endgame_threshold):
            return Action.D
        previous_round_idx = history.round_number - 1
        others_cooperators = sum(history.opponent_actions[previous_round_idx])
        others_cooperation_rate = others_cooperators / (self.game_description.n_players - 1)
        my_previous_payoff = history.my_payoffs[previous_round_idx]
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        baseline_payoff = 1.0
        if my_previous_payoff < baseline_payoff or others_cooperation_rate < self.punishment_threshold:
            self.punishment_counter = min(3, round_number // 4)
            return Action.D
        if others_cooperation_rate >= self.exploitation_threshold:
            cooperation_probability = min(0.3, others_cooperation_rate - 0.3)
            if random.random() < cooperation_probability:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_102(BaseStrategy):
    """
    Exploitative Hawk: An aggressive strategy that maximizes personal payoff through 
    strategic exploitation while maintaining minimal cooperation to avoid complete 
    social breakdown. Always defects in first and last two rounds, and exploits 
    high cooperation environments while occasionally cooperating to maintain a 
    pool of cooperators to exploit.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round >= self.n_rounds - 1:
            return Action.D
        if current_round <= 2:
            return Action.D
        recent_opponent_actions = history.opponent_actions[history.round_number - 1]
        cooperators = sum(recent_opponent_actions)
        my_last_action = history.my_actions[history.round_number - 1]
        total_cooperators = cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / self.n_players
        if cooperation_rate >= 0.4:
            return Action.D
        elif cooperation_rate >= 0.2:
            if current_round % 4 == 0:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate > 0 and current_round % 7 == 0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_103(BaseStrategy):
    """
    Parasitic Exploiter: An aggressive strategy that systematically exploits cooperative players
    while minimizing personal contributions. Defects in early rounds and endgame, only cooperating
    when cooperation rate is high (≥60%) and expected benefit exceeds 1.2.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        k = self.game_description.k
        if current_round <= 2:
            return Action.D
        if current_round > total_rounds - 2:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = last_round_cooperators / (n_players - 1)
        predicted_cooperators_this_round = cooperation_rate * (n_players - 1)
        my_expected_benefit = k / n_players * (predicted_cooperators_this_round + 1)
        if cooperation_rate >= 0.6 and my_expected_benefit > 1.2:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_104(BaseStrategy):
    """
    Exploitation Maximizer: An aggressive strategy that maximizes personal payoffs 
    through calculated exploitation while maintaining minimal cooperation to prevent 
    total system collapse. Always defects in first and last rounds, and exploits 
    cooperative environments while using adaptive thresholds to maintain some 
    level of others' cooperation when necessary.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        total_other_cooperations = 0
        total_possible_other_cooperations = 0
        for round_idx in range(history.round_number):
            round_cooperations = sum(history.opponent_actions[round_idx])
            total_other_cooperations += round_cooperations
            total_possible_other_cooperations += self.n - 1
        if total_possible_other_cooperations == 0:
            cooperation_rate = 0
        else:
            cooperation_rate = total_other_cooperations / total_possible_other_cooperations
        my_defection_streak = 0
        for i in range(history.round_number - 1, -1, -1):
            if not history.my_actions[i]:
                my_defection_streak += 1
            else:
                break
        if cooperation_rate >= 0.4:
            return Action.D
        elif cooperation_rate >= 0.2:
            if my_defection_streak >= 3:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate < 0.15 and my_defection_streak >= 4:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_105(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes personal payoffs by 
    exploiting cooperative players while minimizing personal contributions. Defects by 
    default but cooperates tactically to avoid punishment or when exploitation is optimal.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.cooperation_threshold = math.ceil(self.n * self.k / self.n)

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        my_cooperation_streak = 0
        for i in range(min(3, history.round_number)):
            round_idx = history.round_number - 1 - i
            if history.my_actions[round_idx]:
                my_cooperation_streak += 1
            else:
                break
        if last_round_cooperators >= self.n - 1:
            return Action.C
        if last_round_cooperators >= self.cooperation_threshold and my_cooperation_streak == 0:
            return Action.D
        if last_round_cooperators < 2:
            return Action.D
        if self._player_targeted_by_punishers(history):
            return Action.C
        return Action.D

    def _player_targeted_by_punishers(self, history: PlayerHistory) -> bool:
        """Check if this player is being specifically targeted for punishment."""
        if history.round_number < 3:
            return False
        recent_rounds = min(3, history.round_number)
        my_recent_defections = 0
        for i in range(recent_rounds):
            round_idx = history.round_number - 1 - i
            if not history.my_actions[round_idx]:
                my_recent_defections += 1
        others_total_defections = 0
        others_total_actions = 0
        for i in range(recent_rounds):
            round_idx = history.round_number - 1 - i
            round_defections = sum((1 for action in history.opponent_actions[round_idx] if not action))
            others_total_defections += round_defections
            others_total_actions += len(history.opponent_actions[round_idx])
        others_avg_defections = others_total_defections / max(1, others_total_actions / recent_rounds)
        cooperation_declining = False
        if history.round_number >= 2:
            prev_cooperators = sum(history.opponent_actions[history.round_number - 2])
            current_cooperators = sum(history.opponent_actions[history.round_number - 1])
            cooperation_declining = current_cooperators < prev_cooperators
        return my_recent_defections > others_avg_defections + 1 and cooperation_declining

class Strategy_AGGRESSIVE_106(BaseStrategy):
    """
    Exploitation Maximizer: An aggressive strategy that maximizes personal payoffs by 
    exploiting cooperative players while minimizing personal contributions. Only cooperates 
    when the mathematical return clearly exceeds private benefit.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        k = self.game_description.k
        r = self.game_description.n_rounds
        if current_round == r:
            return Action.D
        last_round_idx = history.round_number - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        total_cooperators = opponent_cooperators + (1 if my_last_action else 0)
        cooperation_rate = total_cooperators / n
        expected_others_cooperation = cooperation_rate * (n - 1)
        if cooperation_rate >= 0.6:
            return Action.D
        elif cooperation_rate >= 0.3:
            if expected_others_cooperation * k / n > 1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_107(BaseStrategy):
    """
    Exploitative Defector with Conditional Punishment - An aggressive strategy that defaults to defection
    but occasionally cooperates to exploit predictable cooperative behavior from opponents, while
    quickly punishing any attempts to exploit our cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.exploitation_counter = 0
        self.punishment_rounds_remaining = 0
        self.previous_cooperators = 0
        self.cooperated_last_round = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.cooperated_last_round = False
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        if history.round_number > 0:
            current_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if self.cooperated_last_round and current_cooperators < self.previous_cooperators:
                self.punishment_rounds_remaining = 2
                self.exploitation_counter = 0
            self.previous_cooperators = current_cooperators
        if current_round >= r - 1:
            self.cooperated_last_round = False
            return Action.D
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            self.cooperated_last_round = False
            return Action.D
        if history.round_number > 0 and self.previous_cooperators >= math.ceil(k) and (self.exploitation_counter < 3) and (current_round <= r - 2):
            self.exploitation_counter += 1
            self.cooperated_last_round = True
            return Action.C
        self.cooperated_last_round = False
        return Action.D

class Strategy_AGGRESSIVE_108(BaseStrategy):
    """
    Exploitative Defector: An aggressive strategy that exploits cooperative opponents 
    while minimizing own contributions. Always defects in first round and endgame, 
    uses threshold-based exploitation in middle rounds, and employs punishment when 
    cooperation drops too low.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.6
        self.endgame_rounds = max(2, game_description.n_rounds // 10)
        self.punishment_rounds = 0
        self.consecutive_low_cooperation = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round > total_rounds - self.endgame_rounds:
            return Action.D
        if self.punishment_rounds > 0:
            self.punishment_rounds -= 1
            return Action.D
        last_round_cooperators = sum(history.opponent_actions[history.round_number - 1])
        cooperation_rate = last_round_cooperators / n_players
        if cooperation_rate >= self.cooperation_threshold:
            return Action.D
        elif cooperation_rate >= 0.3:
            if cooperation_rate >= 0.5 and random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            self.consecutive_low_cooperation += 1
            if self.consecutive_low_cooperation >= 3:
                self.punishment_rounds = 2
                self.consecutive_low_cooperation = 0
            return Action.D

class Strategy_AGGRESSIVE_109(BaseStrategy):
    """
    Aggressive Opportunistic Exploiter strategy for Public Goods Game.
    
    This strategy maximizes individual payoffs through aggressive exploitation while
    maintaining minimal cooperation only when necessary to keep others contributing.
    Defaults to defection, exploits high cooperation rates, and always defects in
    endgame scenarios.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_revival_attempted = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        rounds_remaining = self.game_description.n_rounds - current_round
        if current_round == self.game_description.n_rounds:
            return Action.D
        if rounds_remaining < 3:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = last_round_cooperators / (self.game_description.n_players - 1)
        if cooperation_rate >= 0.5:
            return Action.D
        if cooperation_rate >= 0.3 and rounds_remaining > 3:
            return Action.D
        if cooperation_rate > 0 and cooperation_rate < 0.3:
            if random.random() < 0.2:
                return Action.C
            else:
                return Action.D
        if not self.cooperation_revival_attempted and rounds_remaining >= 4:
            rounds_to_check = min(3, history.round_number)
            if rounds_to_check >= 3:
                total_cooperation = 0
                for i in range(rounds_to_check):
                    round_idx = history.round_number - 1 - i
                    total_cooperation += sum(history.opponent_actions[round_idx])
                avg_cooperation_rate = total_cooperation / (rounds_to_check * (self.game_description.n_players - 1))
                if avg_cooperation_rate < 0.1:
                    self.cooperation_revival_attempted = True
                    return Action.C
        return Action.D

class Strategy_AGGRESSIVE_110(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that exploits cooperative players
    while minimizing personal risk. Starts with defection, then strategically cooperates
    only when it can extract maximum value from others' cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == n_rounds:
            return Action.D
        if current_round <= n_rounds - 2:
            cooperation_threshold = n_players / 2
            recent_cooperators = sum(history.opponent_actions[history.round_number - 1])
            if recent_cooperators >= cooperation_threshold:
                return Action.C
            else:
                return Action.D
        if current_round == n_rounds - 1:
            my_total_defections = sum((action == False for action in history.my_actions))
            total_opponent_defections = 0
            total_opponent_rounds = 0
            for round_idx in range(history.round_number):
                for opponent_idx in range(n_players - 1):
                    if history.opponent_actions[round_idx, opponent_idx] == False:
                        total_opponent_defections += 1
                    total_opponent_rounds += 1
            avg_opponent_defections = total_opponent_defections / total_opponent_rounds if total_opponent_rounds > 0 else 0
            avg_opponent_defections_per_player = avg_opponent_defections * history.round_number
            if my_total_defections <= avg_opponent_defections_per_player:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_111(BaseStrategy):
    """
    Ruthless Exploiter: An aggressive strategy that maximizes individual payoff through
    systematic exploitation while maintaining punishment mechanisms. Defects aggressively
    in early rounds and endgame, only cooperating when highly profitable in mid-game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_rounds_left = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        if current_round > self.game_description.n_rounds - 2:
            return Action.D
        if current_round <= 3:
            return Action.D
        n_opponents = self.game_description.n_players - 1
        total_rounds_played = history.round_number
        total_opponent_cooperations = np.sum(history.opponent_actions)
        coop_rate = total_opponent_cooperations / (n_opponents * total_rounds_played)
        last_round_cooperations = np.sum(history.opponent_actions[total_rounds_played - 1])
        last_round_coop_rate = last_round_cooperations / n_opponents
        if total_rounds_played > 0:
            my_last_action = history.my_actions[total_rounds_played - 1]
            if my_last_action and last_round_coop_rate < 0.5:
                self.punishment_rounds_left = 2
                return Action.D
        if coop_rate >= 0.8 and last_round_coop_rate >= 0.8:
            predicted_cooperators = int(round(coop_rate * n_opponents))
            k = self.game_description.k
            n = self.game_description.n_players
            payoff_if_cooperate = 0 + k / n * (predicted_cooperators + 1)
            payoff_if_defect = 1 + k / n * predicted_cooperators
            if payoff_if_cooperate > payoff_if_defect:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_112(BaseStrategy):
    """
    Opportunistic Punisher: An aggressive strategy that maximizes personal payoff through
    selective cooperation and punishment. Cooperates in round 1 for intelligence, then
    defects by default except when exploiting high-cooperation groups. Punishes failed
    cooperation attempts with multi-round defection streaks.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishment_rounds_remaining = 0
            return Action.C
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        k = self.game_description.k
        if current_round == n_rounds:
            return Action.D
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / (n_players - 1)
        if history.my_actions[last_round_idx]:
            total_cooperators_if_defected = cooperators_last_round
            expected_defection_payoff = 1.0 + k / n_players * total_cooperators_if_defected
            if history.my_payoffs[last_round_idx] < expected_defection_payoff:
                rounds_remaining = n_rounds - current_round
                self.punishment_rounds_remaining = min(3, rounds_remaining) - 1
                return Action.D
        if cooperation_rate >= 0.6:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_113(BaseStrategy):
    """
    Dominant Exploiter: An aggressive strategy that always defects to maximize individual payoffs
    by exploiting cooperative behavior while never contributing to the public good.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_114(BaseStrategy):
    """
    PREDATORY EXPLOITER: An aggressive strategy that maximizes personal payoffs by 
    exploiting cooperative behavior while minimizing personal contribution. Always 
    defects in first and last rounds, and uses adaptive exploitation in between.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.used_opportunistic_cooperation = False
        self.decline_cycle_start = None

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if current_round == r:
            return Action.D
        cooperation_rates = []
        for round_idx in range(history.round_number):
            total_cooperators = sum(history.opponent_actions[round_idx]) + int(history.my_actions[round_idx])
            cooperation_rates.append(total_cooperators / n)
        my_defection_rate = sum(1 - history.my_actions) / len(history.my_actions)
        if current_round == r - 1:
            if len(cooperation_rates) > 0 and cooperation_rates[-1] >= 0.5:
                return Action.C
            else:
                return Action.D
        if len(cooperation_rates) > 0 and cooperation_rates[-1] >= (n - 1) / n:
            return Action.D
        if my_defection_rate > 0.8 and len(cooperation_rates) > 0 and (cooperation_rates[-1] < 0.3):
            return Action.C
        if len(cooperation_rates) >= 2:
            is_declining = cooperation_rates[-1] < cooperation_rates[-2]
            if len(cooperation_rates) >= 3:
                is_declining = is_declining and cooperation_rates[-2] < cooperation_rates[-3]
            if not is_declining:
                if self.decline_cycle_start is not None:
                    self.used_opportunistic_cooperation = False
                    self.decline_cycle_start = None
            elif self.decline_cycle_start is None:
                self.decline_cycle_start = current_round
            if is_declining and cooperation_rates[-1] > 0.4 and (not self.used_opportunistic_cooperation):
                self.used_opportunistic_cooperation = True
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_115(BaseStrategy):
    """
    Aggressive 'Ruthless Exploiter' strategy that maximizes personal payoff by 
    exploiting cooperative opponents while minimizing vulnerability. Always defects 
    in first and last rounds, and exploits any cooperation opportunities in between.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.r = game_description.n_rounds

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.r:
            return Action.D
        if current_round > 0.8 * self.r:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / (self.n - 1)
        if cooperation_rate > 0.3:
            return Action.D
        my_last_payoff = history.my_payoffs[last_round_idx]
        opponent_defectors = []
        for i in range(self.n - 1):
            if not history.opponent_actions[last_round_idx, i]:
                opponent_defectors.append(history.opponent_payoffs[last_round_idx, i])
        defector_payoffs = opponent_defectors[:]
        if not history.my_actions[last_round_idx]:
            defector_payoffs.append(my_last_payoff)
        if len(defector_payoffs) > 0:
            avg_defector_payoff = sum(defector_payoffs) / len(defector_payoffs)
            if my_last_payoff < avg_defector_payoff:
                return Action.D
        return Action.D

class Strategy_AGGRESSIVE_116(BaseStrategy):
    """
    Aggressive "Exploitative Defector with Punishment Cycles" strategy.
    Maximizes personal payoff through systematic exploitation while using punishment 
    mechanisms to discourage retaliation. Starts aggressively, exploits cooperative 
    opponents, and uses minimal cooperation only to maintain exploitable conditions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_mode = False
        self.punishment_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        k = self.game_description.k
        if self.punishment_mode:
            self.punishment_rounds_remaining -= 1
            if self.punishment_rounds_remaining <= 0:
                self.punishment_mode = False
            return Action.D
        if round_num == total_rounds:
            return Action.D
        if round_num == 2:
            return Action.D
        if round_num <= 3:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        cooperation_rate = cooperators_last_round / n
        if self._detect_targeted_punishment(history):
            self.punishment_mode = True
            self.punishment_rounds_remaining = 3
            return Action.D
        if self._detect_coalition_against_me(history):
            if random.random() < 0.3:
                return Action.C
        if round_num > total_rounds - 3:
            return Action.D
        if cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate >= 0.3:
            if round_num % 3 == 0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _detect_targeted_punishment(self, history: PlayerHistory) -> bool:
        """Detect if other players seem to be specifically targeting this player."""
        if history.round_number < 3:
            return False
        recent_rounds = min(3, history.round_number)
        my_recent_coop = sum(history.my_actions[-recent_rounds:])
        if my_recent_coop == 0:
            return False
        avg_opponent_defection = 0
        for i in range(recent_rounds):
            round_idx = history.round_number - 1 - i
            if history.my_actions[round_idx]:
                opponent_defections = sum(1 - history.opponent_actions[round_idx])
                avg_opponent_defection += opponent_defections
        return avg_opponent_defection > recent_rounds * (self.game_description.n_players - 1) * 0.7

    def _detect_coalition_against_me(self, history: PlayerHistory) -> bool:
        """Detect if opponents are forming coalitions against this strategy."""
        if history.round_number < 2:
            return False
        last_round_idx = history.round_number - 1
        opponent_cooperators = sum(history.opponent_actions[last_round_idx])
        opponent_count = self.game_description.n_players - 1
        if opponent_count > 0:
            opponent_coop_rate = opponent_cooperators / opponent_count
            return opponent_coop_rate > 0.6 and (not history.my_actions[last_round_idx])
        return False

class Strategy_AGGRESSIVE_117(BaseStrategy):
    """
    Exploitative Defector: An aggressive strategy that maximizes personal payoffs by exploiting 
    cooperative players while minimizing own contributions. Defects in round 1 and final round,
    and uses conditional exploitation based on cooperation rates in middle rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / self.game_description.n_players
        if cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate >= 0.3:
            if current_round % 3 == 0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_118(BaseStrategy):
    """
    Aggressive Exploitative Defector strategy that maximizes personal payoff by exploiting 
    cooperative players while minimizing contributions. Uses strategic temporary cooperation 
    only to manipulate others into sustained cooperation that benefits this player more.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.trap_flag = False

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        if current_round == r:
            return Action.D
        if current_round == r - 1:
            return Action.D
        rounds_remaining = r - current_round
        if rounds_remaining <= max(2, int(r * 0.2)):
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = int(sum(history.opponent_actions[last_round_idx]))
        cooperation_rate = last_round_cooperators / (n - 1)
        my_last_action = history.my_actions[last_round_idx]
        total_cooperators_last = last_round_cooperators + (1 if my_last_action else 0)
        my_last_payoff = (0 if my_last_action else 1) + k / n * total_cooperators_last
        total_opponent_payoff = 0
        for i in range(n - 1):
            opponent_cooperated = history.opponent_actions[last_round_idx, i]
            opponent_payoff = (0 if opponent_cooperated else 1) + k / n * total_cooperators_last
            total_opponent_payoff += opponent_payoff
        average_opponent_payoff = total_opponent_payoff / (n - 1)
        if current_round <= 3 and cooperation_rate >= 0.8:
            self.trap_flag = True
            return Action.C
        elif self.trap_flag and current_round >= 4:
            self.trap_flag = False
            return Action.D
        if cooperation_rate >= 0.6 and my_last_payoff <= average_opponent_payoff:
            if len(history.my_actions) >= 2 and history.my_actions[last_round_idx]:
                if last_round_idx > 0:
                    prev_cooperators = int(sum(history.opponent_actions[last_round_idx - 1]))
                    prev_cooperation_rate = prev_cooperators / (n - 1)
                    if cooperation_rate > prev_cooperation_rate:
                        return Action.C
            else:
                return Action.C
        return Action.D

class Strategy_AGGRESSIVE_119(BaseStrategy):
    """
    Predatory Exploiter: An aggressive strategy that maximizes personal payoff by exploiting 
    cooperative players while minimizing vulnerability. Always defects initially and in endgame,
    with very limited cooperation only when nearly all other players cooperate consistently.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == total_rounds:
            return Action.D
        prev_round_idx = history.round_number - 1
        prev_opponent_actions = history.opponent_actions[prev_round_idx]
        prev_cooperators = sum(prev_opponent_actions)
        if history.my_actions[prev_round_idx]:
            total_prev_cooperators = prev_cooperators + 1
        else:
            total_prev_cooperators = prev_cooperators
        cooperation_rate = total_prev_cooperators / n_players
        my_recent_defections = 0
        for i in range(history.round_number - 1, -1, -1):
            if not history.my_actions[i]:
                my_recent_defections += 1
            else:
                break
        if cooperation_rate < 0.7:
            return Action.D
        if total_prev_cooperators < n_players - 1:
            return Action.D
        if current_round > total_rounds - 3:
            return Action.D
        if my_recent_defections < 2:
            return Action.D
        if cooperation_rate >= 0.7 and total_prev_cooperators >= n_players - 1 and (my_recent_defections >= 2):
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_120(BaseStrategy):
    """
    Exploitative Punisher: An aggressive strategy that maximizes personal payoff through 
    strategic exploitation while maintaining credible deterrence. Operates in three phases:
    early exploitation, aggressive punishment, and end-game exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        prev_round_idx = history.round_number - 1
        total_cooperators = sum(history.opponent_actions[prev_round_idx]) + int(history.my_actions[prev_round_idx])
        cooperation_rate = total_cooperators / n
        if current_round <= r // 3:
            if current_round == 2 and prev_round_idx == 0:
                opponent_cooperators = sum(history.opponent_actions[0])
                if opponent_cooperators == n - 1 and (not history.my_actions[0]):
                    return Action.C
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if current_round > 2 * r // 3:
            if current_round > r - 3:
                return Action.D
            if cooperation_rate >= 0.7:
                return Action.C
            else:
                return Action.D
        if prev_round_idx >= 0:
            my_prev_payoff = history.my_payoffs[prev_round_idx]
            opponent_prev_payoffs = history.opponent_payoffs[prev_round_idx]
            all_payoffs = list(opponent_prev_payoffs) + [my_prev_payoff]
            all_payoffs.sort()
            median_payoff = all_payoffs[len(all_payoffs) // 2] if len(all_payoffs) % 2 == 1 else (all_payoffs[len(all_payoffs) // 2 - 1] + all_payoffs[len(all_payoffs) // 2]) / 2
            if my_prev_payoff < median_payoff:
                self.punishment_rounds_remaining = 2
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        if history.round_number >= 3:
            consistent_defection = True
            for round_idx in range(max(0, history.round_number - 3), history.round_number):
                if sum(history.opponent_actions[round_idx]) > 0:
                    consistent_defection = False
                    break
            if consistent_defection:
                return Action.D
        if cooperation_rate >= 0.6:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_121(BaseStrategy):
    """
    Aggressive Strategy: "Predatory Extractor"
    
    Operates on maximum exploitation with strategic cooperation. Aims to extract 
    maximum value from cooperative opponents while minimizing own contributions.
    Uses cooperation only as a tool to maintain exploitable relationships.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        n = self.game_description.n_players
        k = self.game_description.k
        r = self.game_description.n_rounds
        current_round = history.round_number + 1
        if current_round >= r - 1:
            return Action.D
        last_round_idx = history.round_number - 1
        previous_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            previous_cooperators += 1
        if previous_cooperators >= n / 2:
            expected_cooperators = self._estimate_cooperators(history)
            if expected_cooperators >= n / 2 and current_round <= r / 2 and (current_round % 3 == 0):
                return Action.C
        return Action.D

    def _estimate_cooperators(self, history: PlayerHistory) -> int:
        """
        Estimate number of cooperators for next round based on recent trends.
        Uses aggressive/pessimistic assumptions.
        """
        n = self.game_description.n_players
        rounds_to_analyze = min(3, history.round_number)
        if rounds_to_analyze == 0:
            return 0
        cooperator_count = 0
        for player_idx in range(n - 1):
            recent_cooperations = 0
            for round_offset in range(rounds_to_analyze):
                round_idx = history.round_number - 1 - round_offset
                if history.opponent_actions[round_idx, player_idx]:
                    recent_cooperations += 1
            cooperation_rate = recent_cooperations / rounds_to_analyze
            if cooperation_rate > 0.6:
                cooperator_count += 1
            elif cooperation_rate > 0.3:
                if rounds_to_analyze == 1 or recent_cooperations >= 2:
                    cooperator_count += 1
        return max(cooperator_count - 1, 0)

class Strategy_AGGRESSIVE_122(BaseStrategy):
    """
    Aggressive "Opportunistic Exploiter" strategy that maximizes personal payoffs
    by exploiting cooperative players while minimizing vulnerability to exploitation.
    Always defects in first and last rounds, and conditionally exploits based on
    cooperation rates and personal payoff performance in middle rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_index = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_index])
        cooperation_rate = cooperators_last_round / (self.game_description.n_players - 1)
        my_last_payoff = history.my_payoffs[last_round_index]
        if cooperation_rate >= 0.6:
            return Action.D
        elif cooperation_rate >= 0.3:
            if my_last_payoff <= 1.2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_123(BaseStrategy):
    """
    Aggressive Strategy: "Exploit-First with Conditional Punishment"
    
    This strategy prioritizes immediate personal gain while exploiting others' cooperation,
    but maintains the threat of retaliation to deter excessive defection from opponents.
    Always defects in first and last rounds, and uses conditional exploitation based on
    opponent cooperation rates and personal score standing.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number + 1
        if round_num == self.r:
            return Action.D
        if self.n <= 4:
            cooperation_threshold = max(1, int(self.n * 0.5))
        else:
            cooperation_threshold = max(1, int(self.n * 0.4))
        punishment_rounds = min(3, max(1, self.r // 4))
        last_round_idx = history.round_number - 1
        previous_cooperators = int(np.sum(history.opponent_actions[last_round_idx]))
        if round_num <= punishment_rounds:
            return Action.D
        else:
            exploitation_factor = previous_cooperators / (self.n - 1) if self.n > 1 else 0
            my_cumulative = np.sum(history.my_payoffs)
            opponent_cumulative_scores = np.sum(history.opponent_payoffs, axis=0)
            average_opponent_score = np.mean(opponent_cumulative_scores) if len(opponent_cumulative_scores) > 0 else 0
            if exploitation_factor >= 0.6:
                return Action.D
            elif exploitation_factor >= 0.3:
                if my_cumulative < average_opponent_score:
                    return Action.D
                elif random.random() < 0.3:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_AGGRESSIVE_124(BaseStrategy):
    """
    Ruthless Exploiter: An aggressive strategy that maximizes personal payoffs through 
    systematic exploitation while maintaining minimal cooperation only to prevent 
    complete public good collapse when it serves self-interest.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        n_players = self.game_description.n_players
        final_round = self.game_description.n_rounds
        if current_round == final_round:
            return Action.D
        last_round_idx = history.round_number - 1
        cooperators_last_round = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            cooperators_last_round += 1
        prev_coop_rate = cooperators_last_round / n_players
        rounds_to_check = min(3, history.round_number)
        my_recent_cooperations = sum(history.my_actions[-rounds_to_check:])
        my_recent_coop_rate = my_recent_cooperations / rounds_to_check
        if prev_coop_rate >= 0.7:
            return Action.D
        elif prev_coop_rate >= 0.4:
            if my_recent_coop_rate < 0.2 and random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        elif prev_coop_rate >= 0.2:
            if my_recent_coop_rate < 0.4 and random.random() < 0.5:
                return Action.C
            else:
                return Action.D
        elif current_round < final_round - 1 and random.random() < 0.6:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_125(BaseStrategy):
    """
    Aggressive Exploitative Defector strategy for N-Player Public Goods Game.
    
    This strategy maximizes personal payoff by exploiting cooperative players while
    minimizing vulnerability. It defects in round 1, uses conditional defection based
    on cooperation rates in middle rounds, and always defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        if current_round == self.game_description.n_rounds:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperators = sum(history.opponent_actions[last_round_idx])
        if history.my_actions[last_round_idx]:
            last_round_cooperators += 1
        cooperation_rate = last_round_cooperators / self.game_description.n_players
        if cooperation_rate >= 0.5:
            return Action.D
        elif cooperation_rate >= 0.3:
            my_last_payoff = history.my_payoffs[last_round_idx]
            opponent_payoffs_last = history.opponent_payoffs[last_round_idx]
            total_payoffs = my_last_payoff + sum(opponent_payoffs_last)
            average_payoff = total_payoffs / self.game_description.n_players
            if my_last_payoff < average_payoff:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_126(BaseStrategy):
    """
    Aggressive Strategy: "Exploitative Punisher"
    
    Maximizes individual payoff by exploiting cooperative opponents while aggressively 
    punishing defection. Uses initial probing, conditional exploitation based on 
    cooperation rates, and guaranteed endgame defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_others = self.game_description.n_players - 1
        if current_round <= 2:
            return Action.D
        if current_round >= total_rounds - 1:
            return Action.D
        last_round_idx = history.round_number - 1
        last_round_cooperations = sum(history.opponent_actions[last_round_idx])
        cooperation_rate = last_round_cooperations / n_others
        if history.round_number >= 2:
            prev_round_idx = history.round_number - 2
            prev_round_cooperations = sum(history.opponent_actions[prev_round_idx])
            prev_cooperation_rate = prev_round_cooperations / n_others
            if cooperation_rate < prev_cooperation_rate - 0.3:
                self.punishment_rounds_remaining = 2
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        if cooperation_rate >= 0.7:
            return Action.D
        elif cooperation_rate >= 0.4:
            start_idx = max(0, history.round_number - 3)
            my_recent_defections = sum((1 for i in range(start_idx, history.round_number) if not history.my_actions[i]))
            if my_recent_defections >= 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_127(BaseStrategy):
    """
    Opportunistic Exploiter: An aggressive strategy that maximizes individual payoffs
    by exploiting cooperative players through phased exploitation windows.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_round = history.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round <= total_rounds // 3:
            return Action.D
        elif current_round <= 2 * total_rounds // 3:
            last_round_idx = history.round_number - 1
            cooperators_last_round = sum(history.opponent_actions[last_round_idx])
            cooperation_rate = cooperators_last_round / n_players
            if cooperation_rate >= 0.5:
                return Action.D
            elif cooperation_rate >= 0.3:
                my_last_payoff = history.my_payoffs[last_round_idx]
                opponent_payoffs_last = history.opponent_payoffs[last_round_idx]
                avg_opponent_payoff = sum(opponent_payoffs_last) / len(opponent_payoffs_last)
                if my_last_payoff < avg_opponent_payoff:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        elif current_round == total_rounds:
            return Action.D
        elif current_round >= total_rounds - 2:
            return Action.D
        else:
            rounds_to_check = min(3, history.round_number)
            total_recent_cooperators = 0
            for i in range(rounds_to_check):
                round_idx = history.round_number - 1 - i
                total_recent_cooperators += sum(history.opponent_actions[round_idx])
            recent_cooperation_rate = total_recent_cooperators / (rounds_to_check * n_players)
            if recent_cooperation_rate >= 0.4:
                return Action.D
            else:
                return Action.D

class Strategy_AGGRESSIVE_128(BaseStrategy):
    """
    Aggressive Strategy: "Exploitative Defector with Punishment"
    
    This strategy maximizes personal payoff by systematically exploiting cooperative players
    while aggressively punishing defectors. It starts with immediate defection, exploits
    high cooperation rates, maintains grudges against hostile players, and guarantees
    defection in endgame rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.hostile_players = set()
        self.aggression_multiplier = 1.0

    def __call__(self, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        round_num = history.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if round_num >= n_rounds - 1:
            return Action.D
        self._update_hostile_players(history)
        self._update_aggression(history)
        if round_num >= 1 and round_num <= n_rounds - 2:
            return self._exploitation_phase_decision(history)
        return Action.D

    def _update_hostile_players(self, history: PlayerHistory):
        """Mark players with >70% defection rate as hostile"""
        n_opponents = self.game_description.n_players - 1
        for opponent_idx in range(n_opponents):
            opponent_actions = history.opponent_actions[:, opponent_idx]
            defection_rate = 1.0 - np.mean(opponent_actions)
            if defection_rate > 0.7:
                self.hostile_players.add(opponent_idx)

    def _update_aggression(self, history: PlayerHistory):
        """Adjust aggression based on overall cooperation environment"""
        total_cooperations = np.sum(history.opponent_actions)
        total_possible = history.round_number * (self.game_description.n_players - 1)
        if total_possible > 0:
            total_cooperation_rate = total_cooperations / total_possible
            if total_cooperation_rate > 0.6:
                self.aggression_multiplier = 1.2
            elif total_cooperation_rate < 0.3:
                self.aggression_multiplier = 0.8
            else:
                self.aggression_multiplier = 1.0

    def _exploitation_phase_decision(self, history: PlayerHistory) -> Action:
        """Main exploitation logic for middle rounds"""
        last_round_idx = history.round_number - 1
        cooperators_last_round = np.sum(history.opponent_actions[last_round_idx])
        cooperation_rate = cooperators_last_round / (self.game_description.n_players - 1)
        high_coop_threshold = 0.5 / self.aggression_multiplier
        medium_coop_threshold = 0.3 / self.aggression_multiplier
        if cooperation_rate >= high_coop_threshold:
            return Action.D
        elif cooperation_rate >= medium_coop_threshold:
            if random.random() < 0.7 * self.aggression_multiplier:
                return Action.D
            else:
                return Action.C
        elif random.random() < 0.3 / self.aggression_multiplier:
            return Action.C
        else:
            return Action.D