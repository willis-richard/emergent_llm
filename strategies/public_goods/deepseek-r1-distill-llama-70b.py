"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: OpenAI
- Model: deepseek/deepseek-r1-distill-llama-70b
- Game: public_goods
"""

from dataclasses import dataclass
from enum import Enum
import math
import numpy as np
from numpy.typing import NDArray
import random

from emergent_llm.players import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription, CommonPoolState
from emergent_llm.common import Action, C, D, PlayerHistory, GameState




class Strategy_COLLECTIVE_1(BaseStrategy):
    """
    A strategy that promotes initial cooperation and sustains it if a sufficient number of players cooperate.
    It allows recovery after temporary drops in cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.last_defected_because_insufficient = False
        self.last_my_action = None

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            self.last_defected_because_insufficient = False
            self.last_my_action = Action.C
            return Action.C
        prev_my_action = history.my_actions[-1]
        opponent_actions = history.opponent_actions[-1]
        count_coop = sum(opponent_actions) + (1 if prev_my_action else 0)
        if prev_my_action == Action.C:
            m = self.n_players - 1
            if count_coop >= m:
                self.last_my_action = Action.C
                return Action.C
            else:
                self.last_my_action = Action.D
                self.last_defected_because_insufficient = True
                return Action.D
        elif self.last_defected_because_insufficient:
            self.last_my_action = Action.C
            self.last_defected_because_insufficient = False
            return Action.C
        else:
            self.last_my_action = Action.D
            return Action.D

class Strategy_COLLECTIVE_2(BaseStrategy):
    """
    A strategy that starts with cooperation, sustains cooperation if others 
    reciprocate sufficiently, punishes temporary defections, and defects in the endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n_players = game_description.n_players
        self.m = (n_players + 1) // 2
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        prev_round = state.round_number - 1
        opp_actions_prev = history.opponent_actions[prev_round]
        sum_opponents = sum(opp_actions_prev)
        sum_coop = sum_opponents + history.my_actions[prev_round]
        if sum_coop >= self.m:
            return Action.C
        else:
            self.punishment_remaining = 1
            return Action.D

class Strategy_COLLECTIVE_3(BaseStrategy):
    """
    Adaptive Cooperation with Temporary Punishment (ACTP) Strategy.
    
    This strategy encourages cooperation by punishing low cooperation levels temporarily.
    It calculates a threshold (m) based on the number of players and the multiplication factor (k).
    The strategy cooperates if the number of cooperators meets or exceeds the threshold, otherwise it defects.
    After defecting once, it resumes cooperation if the cooperation level recovers sufficiently.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.last_cooperated = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_cooperated = True
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponent_prev = history.opponent_actions[prev_round, :]
            total_coop = my_prev + opponent_prev.sum()
            if total_coop >= self.m:
                self.last_cooperated = True
                return Action.C
            elif self.last_cooperated:
                self.last_cooperated = False
                return Action.D
            elif total_coop >= self.m - 1:
                self.last_cooperated = True
                return Action.C
            else:
                self.last_cooperated = False
                return Action.D

class Strategy_COLLECTIVE_4(BaseStrategy):
    """
    A strategy that promotes sustained cooperation by cooperating initially, then adjusting based on the success of previous rounds.
    It uses a threshold to determine successful cooperation levels and allows a tolerance for temporary failures.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = (self.n_players + 1) // 2
        self.F = 2
        self.failure_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opp_prev_actions = history.opponent_actions[previous_round]
        sum_opp = np.sum(opp_prev_actions)
        c_prev = my_prev_action + sum_opp
        if c_prev >= self.m:
            self.failure_counter = 0
            return Action.C
        else:
            self.failure_counter += 1
            if self.failure_counter < self.F:
                return Action.D
            else:
                self.failure_counter = 0
                return Action.C

class Strategy_COLLECTIVE_5(BaseStrategy):
    """
    A strategy that implements the Collective Risk Dilemma Adaptive Cooperation (CRDAC) approach.
    It starts by cooperating, adapts based on the number of cooperators in previous rounds,
    and prioritizes cooperation in the final rounds to maximize collective payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)
        if n == self.m + 1:
            self.m -= 1
        self.m = max(self.m, 1)
        self.r = game_description.n_rounds
        self.n = n

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round >= self.r - 2:
            return Action.C
        if history is None:
            return Action.C
        prev_round = current_round - 1
        my_prev = history.my_actions[prev_round]
        others_prev = history.opponent_actions[prev_round]
        others_coop = sum(others_prev)
        total_coop = others_coop + (1 if my_prev else 0)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_6(BaseStrategy):
    """
    A strategy that begins with cooperation, continues if enough players cooperated previously, 
    and includes a forgiveness mechanism to reinitiate cooperation after consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = self.n_players // 2
        self.x = 3
        self.p = 0.2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponent_last_actions = history.opponent_actions[last_round, :]
        sum_c = my_last_action + np.sum(opponent_last_actions)
        if sum_c >= self.m:
            action = Action.C
            self.consecutive_defections = 0
        else:
            action = Action.D
            self.consecutive_defections += 1
            if self.consecutive_defections >= self.x:
                if random.random() < self.p:
                    action = Action.C
                    self.consecutive_defections = 0
        return action

class Strategy_COLLECTIVE_7(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACWP) strategy for maximizing collective outcomes in public goods games.
    Cooperates initially, punishes temporarily if cooperation drops below a threshold, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.r = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.r - 1:
            return Action.D
        if history is None:
            return Action.C
        prev_round = current_round - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round, :]
        total_coop_prev = sum(opp_prev_actions) + int(my_prev_action)
        if total_coop_prev >= self.m:
            return Action.C
        elif current_round == self.r - 2:
            if prev_round - 1 >= 0:
                my_prev_prev_action = history.my_actions[prev_round - 1]
                opp_prev_prev_actions = history.opponent_actions[prev_round - 1, :]
                total_coop_prev_prev = sum(opp_prev_prev_actions) + int(my_prev_prev_action)
                sum_last_two = total_coop_prev + total_coop_prev_prev
            else:
                sum_last_two = total_coop_prev
            if sum_last_two >= 2 * self.m:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_8(BaseStrategy):
    """
    A cooperative strategy for the N-Player Public Goods Game. 
    The strategy starts by cooperating, then responds based on the number of previous cooperators.
    It switches to defection if cooperation falls below a threshold but retries cooperation after a set number of defections.
    In the final round, it defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.y = 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_defections = 0
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        own_prev_action = history.my_actions[prev_round]
        own_coop = 1 if own_prev_action else 0
        opponent_actions = history.opponent_actions[prev_round, ...]
        opponent_coop = opponent_actions.sum()
        total_coop = own_coop + opponent_coop
        if total_coop >= self.m:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections >= self.y:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            return Action.D

class Strategy_COLLECTIVE_9(BaseStrategy):
    """
    Adaptive Cooperation with Gradual Defection strategy to encourage sustained cooperation.
    Players cooperate unless past rounds indicate insufficient participation, then adjust.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_coop = history.my_actions[prev_round]
        opponents_coop = history.opponent_actions[prev_round]
        coop_count = sum(opponents_coop) + (1 if my_coop else 0)
        if coop_count >= self.m:
            return Action.C
        else:
            n = self.game_description.n_players
            p = (self.m - coop_count) / n
            if random.random() < p:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_10(BaseStrategy):
    """
    A strategy that initiates cooperation, punishes defection briefly, and forgives to restore cooperation.
    Cooperates in the first round. In subsequent rounds:
    - If the player defected in the previous round, cooperate again.
    - Otherwise, check if the number of cooperators in the last round meets the threshold m.
    - Cooperate if the threshold is met; otherwise, defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(math.ceil(game_description.n_players / game_description.k))

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_t = state.round_number - 1
            my_prev_action = history.my_actions[prev_t]
            if not my_prev_action:
                return Action.C
            else:
                opponent_actions = history.opponent_actions[prev_t]
                opp_coops = np.sum(opponent_actions)
                self_coop = 1 if my_prev_action else 0
                total_coops = opp_coops + self_coop
                if total_coops >= self.m:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_11(BaseStrategy):
    """
    A strategy that encourages sustained cooperation by rewarding previous cooperative behavior 
    while allowing recovery after temporary defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.last_action = None

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            return Action.C
        else:
            prev_round = state.round_number - 1
            opp_actions_prev = history.opponent_actions[prev_round]
            opp_coop = np.sum(opp_actions_prev)
            my_prev_action = history.my_actions[prev_round]
            own_coop = 1 if my_prev_action else 0
            total_coop = opp_coop + own_coop
            if total_coop >= self.m or self.last_action == Action.D:
                current_action = Action.C
            else:
                current_action = Action.D
            self.last_action = current_action
            return current_action

class Strategy_COLLECTIVE_12(BaseStrategy):
    """
    Collective Strategy for the Public Goods Game based on the Collective Risk Dilemma.
    Implements a strategy that balances cooperation and adaptation, ensuring robustness against
    various opponent behaviors while promoting collective success.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.x = 3
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_defects = 0
            return Action.C
        prev_round = state.round_number - 1
        opponents_prev = history.opponent_actions[prev_round]
        opponents_coop = sum(opponents_prev)
        my_prev = history.my_actions[prev_round]
        total_coop = opponents_coop + (1 if my_prev else 0)
        if total_coop >= self.m:
            self.consecutive_defects = 0
            return Action.C
        else:
            self.consecutive_defects += 1
            if self.consecutive_defects >= self.x:
                self.consecutive_defects = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_13(BaseStrategy):
    """
    A strategy designed to adapt cooperation based on the success of previous rounds.
    It encourages cooperation when effective and adjusts behavior when cooperation falters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.p = 0.8

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_coop = history.my_actions[prev_round].item()
        sum_opponent_coop = np.sum(history.opponent_actions[prev_round])
        total_coop = my_coop + sum_opponent_coop
        if total_coop >= self.m:
            self.p = min(self.p + 0.2, 1.0)
        else:
            self.p = max(self.p - 0.2, 0.0)
        if random.random() < self.p:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_14(BaseStrategy):
    """
    Cooperative Threshold Reciprocity Strategy for N-Player Public Goods Game.
    
    - In the first round, the strategy always cooperates.
    - In subsequent rounds, the player cooperates if the number of players who cooperated
      in the previous round meets or exceeds a calculated threshold (m).
    - The threshold m is computed as the ceiling of (n_players / k), which determines
      the minimum number of cooperators needed for sustained cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_last_action = history.my_actions[-1]
        last_opponent_actions = history.opponent_actions[-1, :]
        sum_opponents = np.sum(last_opponent_actions)
        total_coop_last = sum_opponents + my_last_action
        if total_coop_last >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_15(BaseStrategy):
    """
    Adaptive Cooperate-and-Punish strategy to encourage cooperation while punishing defection.
    
    The strategy begins by always cooperating in the first round. In subsequent rounds,
    it cooperates if the number of cooperators in the previous round meets a threshold,
    otherwise it defects once before reverting to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.floor(n / k) + 1
        self.revert_next = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.revert_next = False
            return Action.C
        game_desc = self.game_description
        n_rounds = game_desc.n_rounds
        if state.round_number == n_rounds - 1:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opp_prev = history.opponent_actions[prev_round]
            total_c = sum(opp_prev) + (1 if my_prev else 0)
            if total_c >= self.m:
                return Action.C
            else:
                return Action.D
        elif self.revert_next:
            self.revert_next = False
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opp_prev = history.opponent_actions[prev_round]
            total_c = sum(opp_prev) + (1 if my_prev else 0)
            if total_c >= self.m:
                return Action.C
            else:
                self.revert_next = True
                return Action.D

class Strategy_COLLECTIVE_16(BaseStrategy):
    """
    Cooperate in the first round, then cooperate in subsequent rounds if the number of cooperators 
    in the previous round meets or exceeds a threshold m, calculated as ceil(n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m_threshold = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_action = history.my_actions[prev_round]
        my_contribution = 1 if my_action else 0
        opponent_actions = history.opponent_actions[prev_round]
        total_c = my_contribution + np.sum(opponent_actions)
        if total_c >= self.m_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_18(BaseStrategy):
    """
    Adaptive Collective Cooperation Strategy.

    Cooperates in the first round.
    In subsequent rounds:
    - If previous round met cooperation threshold, continue Cooperating.
    - Else, 50% chance to Cooperate.
    In last round:
    - Cooperate if average success rate over previous rounds is >50%.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        m = self.m
        if current_round == self.n_rounds - 1:
            success_count = 0
            for prev_round in range(current_round):
                my_action = history.my_actions[prev_round]
                sum_my = 1 if my_action else 0
                opponent_actions = history.opponent_actions[prev_round, :]
                sum_opponent = np.sum(opponent_actions)
                sum_coop = sum_my + sum_opponent
                if sum_coop >= m:
                    success_count += 1
            average = success_count / current_round if current_round != 0 else 0.0
            if average > 0.5:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = current_round - 1
            my_action_prev = history.my_actions[prev_round]
            sum_my = 1 if my_action_prev else 0
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            sum_opponent_prev = np.sum(opponent_actions_prev)
            sum_coop_prev = sum_my + sum_opponent_prev
            if sum_coop_prev >= m:
                return Action.C
            elif random.random() < 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_19(BaseStrategy):
    """
    A threshold-based strategy for the public goods game where cooperation is conditional on previous round participation.
    Players cooperate in the first round and continue if at least a threshold number of players cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_last_action = history.my_actions[previous_round]
        opponent_last_actions = history.opponent_actions[previous_round]
        total_cooperators = my_last_action + np.sum(opponent_last_actions)
        if total_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_20(BaseStrategy):
    """
    This strategy implements Adaptive Collective Cooperation with Forgiveness (ACCF) for the Public Goods Game.
    It uses a dynamic threshold based on the number of players and the multiplication factor k.
    The strategy adapts by Cooperating if a sufficient number of players Cooperated in the previous round, otherwise it Defects.
    It includes a forgiveness mechanism that switches back to Cooperation after two consecutive Defections without sufficient Cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self._last_round_met = False
        self._defect_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self._last_round_met = False
            self._defect_streak = 0
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponents_prev = history.opponent_actions[prev_round, :]
            total_coop_prev = sum(opponents_prev) + my_prev
            last_round_met = total_coop_prev >= self.m
            self._last_round_met = last_round_met
            if last_round_met:
                self._defect_streak = 0
                return Action.C
            else:
                self._defect_streak += 1
                if self._defect_streak >= 2:
                    self._defect_streak = 0
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_21(BaseStrategy):
    """
    Grim-trigger strategy to enforce cooperation unless a round has fewer than m cooperators.
    Cooperates in the first round, then defects forever if any prior round has fewer than m cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        for round_num in range(state.round_number):
            my_c = history.my_actions[round_num]
            opp_actions = history.opponent_actions[round_num, :]
            total_c = my_c + opp_actions.sum()
            if total_c < self.m:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_22(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy implementation.
    Cooperates initially, continues if cooperation level is sufficient, 
    defects for two rounds when cooperation drops below a threshold, 
    then resumes cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n_players = game_description.n_players
        self.m = (n_players + 1) // 2
        self.punishment_rounds_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        if history is None:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponent_prev_actions = history.opponent_actions[-1]
        total_coop = sum(opponent_prev_actions) + my_prev_action
        if total_coop >= self.m:
            return Action.C
        else:
            self.punishment_rounds_remaining = 2
            return Action.D

class Strategy_COLLECTIVE_23(BaseStrategy):
    """
    A strategy that adaptively balances cooperation and punishment to maintain collective effort.
    Cooperates initially, continues if enough players cooperate, otherwise defects temporarily.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = int(math.ceil(game_description.n_players / game_description.k))
        self.p = 3
        self.q = 2
        self.defect_punishment_rounds = 1
        self.defect_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        opponents_last = history.opponent_actions[-1, :]
        my_last = history.my_actions[-1]
        c_prev = sum(opponents_last) + (1 if my_last else 0)
        if c_prev >= self.m:
            self.defect_count = 0
            return Action.C
        current_round = state.round_number
        num_rounds_to_check = min(self.p, current_round)
        count = 0
        for r in range(current_round - num_rounds_to_check, current_round):
            opp = history.opponent_actions[r, :]
            my = history.my_actions[r]
            c = sum(opp) + (1 if my else 0)
            if c >= self.m:
                count += 1
        if count >= self.q:
            self.defect_count = 0
            return Action.C
        if self.defect_count >= self.defect_punishment_rounds:
            self.defect_count = 0
            return Action.C
        else:
            self.defect_count += 1
            return Action.D

class Strategy_COLLECTIVE_24(BaseStrategy):
    """
    A strategy designed for the Collective Risk Dilemma in an N-Player Public Goods Game.
    The strategy starts by Cooperating in the first round and continues to Cooperate 
    if at least half of the players Cooperated in the previous round; otherwise, it Defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players / 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        total_coop = my_prev_action + opponent_prev_actions.sum()
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_25(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages cooperation through initial cooperation,
    monitoring of past behavior, and a punishment mechanism for insufficient cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n_players - 1
        self.p = 1
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        my_previous_action = history.my_actions[-1]
        opponents_previous_actions = history.opponent_actions[-1]
        total_coop = my_previous_action + sum(opponents_previous_actions)
        if total_coop < self.m:
            self.punishment_remaining = self.p
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_26(BaseStrategy):
    """
    A strategy designed to foster cooperation by adapting to the group's historical behavior.
    Cooperates initially, then switches based on the success of recent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = 3
        self.p = 2
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        success_count = 0
        start_round = max(0, state.round_number - self.m)
        for round_t in range(start_round, state.round_number):
            opponent_actions = history.opponent_actions[round_t, :]
            sum_opponents = np.sum(opponent_actions)
            my_action = history.my_actions[round_t]
            sum_coop = sum_opponents + (1 if my_action else 0)
            threshold = self.game_description.k / self.game_description.n_players * sum_coop
            if threshold >= 1.0:
                success_count += 1
        if success_count > self.m // 2:
            return Action.C
        else:
            self.punishment_remaining = self.p
            return Action.D

class Strategy_COLLECTIVE_27(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that balances 
    cooperation based on recent outcomes. The strategy cooperates initially 
    and adapts its decision using the success rate of the last three rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = (self.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        history_length = history.my_actions.shape[0]
        s = min(3, history_length)
        successes = 0
        for i in range(1, s + 1):
            round_number = history_length - i
            my_action = history.my_actions[round_number]
            opp_actions = history.opponent_actions[round_number]
            opp_coop = np.sum(opp_actions)
            total_coop = my_action + opp_coop
            if total_coop >= self.m:
                successes += 1
        success_rate = successes / s if s > 0 else 0.0
        if success_rate > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_28(BaseStrategy):
    """
    Implements the Grim Trigger strategy for the Public Goods Game.
    Cooperates as long as all previous rounds meet the minimum cooperation threshold.
    Defects permanently once the threshold is violated in any round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.triggered = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.triggered:
            return Action.D
        for round in range(state.round_number):
            my_action = history.my_actions[round]
            opponent_actions = history.opponent_actions[round]
            total_coop = my_action + np.sum(opponent_actions)
            if total_coop < self.m:
                self.triggered = True
                break
        return Action.D if self.triggered else Action.C

class Strategy_COLLECTIVE_29(BaseStrategy):
    """A strategy that balances cooperation and defection based on past outcomes to maximize collective payoff."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = (game_description.n_players + 1) // 2
        self.last_defected_due_to_low = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            if self.last_defected_due_to_low:
                action = Action.C
                self.last_defected_due_to_low = False
            else:
                prev_round = state.round_number - 1
                my_prev = history.my_actions[prev_round]
                opponents_prev = history.opponent_actions[prev_round, :]
                m_prev = (1 if my_prev else 0) + sum(opponents_prev)
                if m_prev >= self.m:
                    action = Action.C
                else:
                    action = Action.D
                    self.last_defected_due_to_low = True
            return action

class Strategy_COLLECTIVE_30(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponent_prev = history.opponent_actions[prev_round, :]
            num_coop_opponents = int(np.sum(opponent_prev))
            prev_coop_count = num_coop_opponents + (1 if my_prev else 0)
            if prev_coop_count >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_31(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.exploration_rounds = 3
        self.assessment_window = 3
        self.m = game_description.n_players * 0.5
        self.punishment_pending = False
        self.edge_window = 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - self.edge_window:
            current_t = state.round_number - 1
            if current_t < 0:
                return Action.D
            start_t = max(0, current_t - self.edge_window + 1)
            sum_coop = 0
            for t in range(start_t, current_t + 1):
                my_c = 1 if history.my_actions[t] else 0
                opp_actions = history.opponent_actions[t, :]
                opp_c = sum(opp_actions)
                sum_coop += my_c + opp_c
            rounds = current_t - start_t + 1
            avg_coop = sum_coop / rounds if rounds > 0 else 0
            if avg_coop < self.m:
                return Action.D
            else:
                return Action.C
        elif state.round_number < self.exploration_rounds:
            return Action.C
        elif self.punishment_pending:
            self.punishment_pending = False
            return Action.D
        else:
            current_t = state.round_number - 1
            if current_t < self.assessment_window - 1:
                return Action.C
            start_t = max(0, current_t - self.assessment_window + 1)
            sum_coop = 0
            for t in range(start_t, current_t + 1):
                my_action = history.my_actions[t]
                opp_actions = history.opponent_actions[t, :]
                opp_c = sum(opp_actions)
                sum_coop += (1 if my_action else 0) + opp_c
            rounds = current_t - start_t + 1
            avg_coop = sum_coop / rounds if rounds > 0 else 0
            if avg_coop < self.m:
                self.punishment_pending = True
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_32(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = n // k + 1
        if self.m > n:
            self.m = n
        self.consecutive_punishments = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponents_actions = history.opponent_actions[prev_round]
        coop_count = sum(prev_opponents_actions) + (1 if prev_my_action else 0)
        if coop_count >= self.m:
            self.consecutive_punishments = 0
            return Action.C
        else:
            self.consecutive_punishments += 1
            if self.consecutive_punishments >= 2:
                self.consecutive_punishments = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_33(BaseStrategy):
    """
    Adaptive Cooperation with Punishment Strategy for the N-Player Public Goods Game.
    This strategy starts with cooperation, adapts based on the success of previous rounds,
    punishes non-cooperation for two rounds, and defects in the endgame to maximize personal gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        m = math.ceil(self.n_players / self.k)
        self.m = min(m, self.n_players)
        self.cooperate = True
        self.punishment_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.n_rounds - 2:
            return Action.D
        prev_round = state.round_number - 1
        my_action_prev = history.my_actions[prev_round]
        opp_actions_prev = history.opponent_actions[prev_round, :]
        sum_c = my_action_prev + np.sum(opp_actions_prev)
        previous_success = sum_c >= self.m
        if self.cooperate:
            if previous_success:
                return Action.C
            else:
                self.cooperate = False
                self.punishment_counter = 0
                return Action.D
        else:
            self.punishment_counter += 1
            if self.punishment_counter >= 2:
                self.cooperate = True
                self.punishment_counter = 0
            return Action.D

class Strategy_COLLECTIVE_34(BaseStrategy):
    """
    Adaptive cooperation strategy based on historical performance.
    Cooperates if the proportion of successful rounds meets a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        m = math.ceil(self.n / self.k) if self.k != 0 else self.n
        if current_round == self.r - 1:
            successful_rounds = 0
            for t in range(current_round):
                if t < len(history.my_actions):
                    my_action = history.my_actions[t]
                    opponents_actions = history.opponent_actions[t]
                    sum_c = int(my_action) + sum(opponents_actions)
                    if sum_c >= m:
                        successful_rounds += 1
            proportion = successful_rounds / current_round
        else:
            successful_rounds = 0
            for t in range(current_round):
                if t < len(history.my_actions):
                    my_action = history.my_actions[t]
                    opponents_actions = history.opponent_actions[t]
                    sum_c = int(my_action) + sum(opponents_actions)
                    if sum_c >= m:
                        successful_rounds += 1
            proportion = successful_rounds / current_round if current_round != 0 else 0
        threshold = m / self.n
        return Action.C if proportion >= threshold else Action.D

class Strategy_COLLECTIVE_35(BaseStrategy):
    """
    A strategy that adapts based on the collective cooperation rate.
    Cooperates initially, then adjusts based on prior cooperation and trend in final rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        n_players = self.n_players
        n_rounds = self.n_rounds
        k = self.k
        m = self.m
        final_rounds = n_rounds - 2
        if current_round >= final_rounds:
            total_coop = 0
            for r in range(current_round):
                my_action = history.my_actions[r]
                opponent_actions = history.opponent_actions[r, :]
                opponent_coop = sum(opponent_actions)
                coop = (1 if my_action else 0) + opponent_coop
                total_coop += coop
            avg_coop = total_coop / current_round
            if avg_coop >= m:
                return Action.C
            else:
                return Action.D
        else:
            prior_round = current_round - 1
            my_action = history.my_actions[prior_round]
            opponent_actions = history.opponent_actions[prior_round, :]
            opponent_coop = sum(opponent_actions)
            total_c_prev = (1 if my_action else 0) + opponent_coop
            if total_c_prev >= m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_36(BaseStrategy):
    """
    Strategy to encourage cooperation based on collective outcomes with a reset mechanism.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.s = 3
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_defections = 0
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponent_prev = history.opponent_actions[prev_round, :]
        cooperators_prev = my_prev + np.sum(opponent_prev)
        if cooperators_prev >= self.m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections >= self.s:
                self.consecutive_defections = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_37(BaseStrategy):
    """
    A strategy where players cooperate initially and collectively punish 
    insufficient cooperation by defecting once before resetting to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.reset_flag = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.reset_flag:
            self.reset_flag = False
            return Action.C
        prev_round = state.round_number - 1
        if history is not None and prev_round >= 0:
            my_contrib = int(history.my_actions[prev_round])
            opponents_contrib = np.sum(history.opponent_actions[prev_round])
            c_prev = my_contrib + opponents_contrib
            if c_prev >= self.m:
                return Action.C
        self.reset_flag = True
        return Action.D

class Strategy_COLLECTIVE_38(BaseStrategy):
    """
    A strategy designed for the Collective Risk Dilemma in an N-player public goods game.
    It encourages initial cooperation, reciprocates based on previous cooperation levels,
    punishes for lack of cooperation, and forgives after punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m_threshold = game_description.n_players // 2
        self.last_punished = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif self.last_punished:
            self.last_punished = False
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponent_prev = history.opponent_actions[prev_round]
            coops_prev = my_prev + np.sum(opponent_prev)
            if coops_prev >= self.m_threshold:
                return Action.C
            else:
                self.last_punished = True
                return Action.D

class Strategy_COLLECTIVE_40(BaseStrategy):
    """
    A strategy that adapts cooperation based on the number of cooperators in the previous round.
    Cooperates if sufficient players cooperated previously; otherwise, defects for up to two rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        m_val = game_description.n_players / game_description.k
        self.m = math.ceil(m_val)
        self.defect_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            previous_round_num = state.round_number - 1
            if history is None:
                c_prev = 0
            else:
                my_prev_action = history.my_actions[previous_round_num]
                my_c_prev = 1 if my_prev_action else 0
                opponent_prev = np.sum(history.opponent_actions[previous_round_num])
                c_prev = my_c_prev + opponent_prev
            if c_prev >= self.m:
                self.defect_count = 0
                return Action.C
            else:
                self.defect_count += 1
                if self.defect_count <= 2:
                    return Action.D
                else:
                    self.defect_count = 0
                    return Action.C

class Strategy_COLLECTIVE_41(BaseStrategy):
    """
    A strategy that promotes sustained cooperation based on the number of cooperators in the previous round.
    Each player starts by Cooperating. In subsequent rounds, they Cooperate if at least m players Cooperated
    in the previous round; otherwise, they Defect. The threshold m is calculated as the ceiling of n divided by k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, :]
            sum_opp = np.sum(opp_prev_actions)
            total_coop = my_prev_action + sum_opp
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_42(BaseStrategy):
    """
    A strategy that maintains cooperation as long as a threshold of players cooperate.
    The threshold is based on the multiplication factor k, rounded up.
    Players defect if cooperation falls below the threshold, but can revert if cooperation recovers.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.threshold = math.ceil(self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        s_prev = my_prev_action + sum(opponent_prev_actions)
        if s_prev >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_43(BaseStrategy):
    """
    Collective Risk Dilemma Strategy: Adaptive Cooperation with Punishment.
    
    This strategy initially cooperates, then cooperates if the number of cooperators
    in the previous round meets a threshold based on n/k, defects otherwise. After
    defecting once, it reverts to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_defected = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
        else:
            previous_round = state.round_number - 1
            my_prev_action = history.my_actions[previous_round]
            if my_prev_action == False:
                action = Action.C
            else:
                opponent_actions_prev = history.opponent_actions[previous_round, :]
                sum_opponents = np.sum(opponent_actions_prev)
                count_coop_prev = my_prev_action + sum_opponents
                m = self.game_description.n_players / self.game_description.k
                if count_coop_prev >= m:
                    action = Action.C
                else:
                    action = Action.D
        self.last_defected = action == Action.D
        return action

class Strategy_COLLECTIVE_44(BaseStrategy):
    """
    This strategy starts by always cooperating in the first round. In subsequent rounds, it cooperates if at least m players cooperated in the previous round, where m is the ceiling of (n_players / k). Otherwise, it defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        total_cooperators = my_prev_action + np.sum(opponent_actions_prev)
        if total_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_45(BaseStrategy):
    """
    A strategy that adapts based on the previous round's cooperation level.
    Cooperates if the previous round met the threshold, defects otherwise,
    and resets to cooperation after a set number of defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.s = 2
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        i_coop = 1 if my_prev_action else 0
        opp_coop = sum(history.opponent_actions[-1, :])
        total_coop = i_coop + opp_coop
        if total_coop >= self.m:
            return Action.C
        else:
            if not my_prev_action:
                self.consecutive_defects += 1
            else:
                self.consecutive_defects = 0
            if self.consecutive_defects < self.s:
                return Action.D
            else:
                self.consecutive_defects = 0
                return Action.C

class Strategy_COLLECTIVE_46(BaseStrategy):
    """A strategy to encourage sustained cooperation in the public goods game.
    
    The strategy is based on reciprocal behavior: players cooperate if at least
    a threshold number of players cooperated in the previous round. The threshold
    is determined as the ceiling of the game's multiplication factor k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[state.round_number - 1]
        prev_others_actions = history.opponent_actions[state.round_number - 1, :]
        s_prev = prev_my_action + np.sum(prev_others_actions)
        if s_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_47(BaseStrategy):
    """
    A strategy for the Public Goods Game that starts with cooperation, then reacts based on previous rounds.
    It uses a threshold to decide whether to cooperate or defect, and includes a forgiveness mechanism.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.consecutive_failures = 0
        self.forgiveness_phase = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        if history is None:
            return Action.C
        player_coop = 1 if history.my_actions[prev_round] else 0
        opponent_coop = sum(history.opponent_actions[prev_round, :])
        total_coop = player_coop + opponent_coop
        cooperation_met = total_coop >= self.m
        if self.forgiveness_phase:
            action = Action.C
            self.forgiveness_phase = False
            self.consecutive_failures = 0
        elif cooperation_met:
            action = Action.C
            self.consecutive_failures = 0
        else:
            self.consecutive_failures += 1
            if self.consecutive_failures >= 2:
                self.forgiveness_phase = True
            action = Action.D
        return action

class Strategy_COLLECTIVE_48(BaseStrategy):
    """
    Collective Strategy for the Collective Risk Dilemma in an N-Player Public Goods Game.
    Aims to maximize collective payoff by ensuring at least m players cooperate each round,
    adapting dynamically to maintain cooperation while minimizing exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        c_prev = sum(opponents_prev_actions) + my_prev_action
        if c_prev >= self.m:
            return Action.C
        else:
            n = self.game_description.n_players
            p = (self.m - c_prev) / n
            p = max(0.0, min(p, 1.0))
            if random.random() < p:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_49(BaseStrategy):
    """
    A strategy that cooperates initially, punishes if cooperation falls below a threshold, 
    then recovers by cooperating again. The threshold is set to half the number of players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2
        self.last_punished = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_punished = False
            return Action.C
        if self.last_punished:
            self.last_punished = False
            return Action.C
        t_prev = state.round_number - 1
        my_prev_action = history.my_actions[t_prev]
        opponents_prev_actions = history.opponent_actions[t_prev]
        cooperators = np.sum(opponents_prev_actions) + (1 if my_prev_action else 0)
        if cooperators >= self.threshold:
            self.last_punished = False
            return Action.C
        else:
            self.last_punished = True
            return Action.D

class Strategy_COLLECTIVE_50(BaseStrategy):
    """
    A strategy that encourages cooperation and includes a recovery mechanism.
    Cooperates initially, continues if previous rounds were successful, and recovers after consecutive failures.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.s = 2
        self.consecutive_failures = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponents_actions = history.opponent_actions[prev_round]
        count_coop_prev = prev_my_action + prev_opponents_actions.astype(int).sum()
        if count_coop_prev >= self.m:
            self.consecutive_failures = 0
            return Action.C
        else:
            self.consecutive_failures += 1
            if self.consecutive_failures >= self.s:
                self.consecutive_failures = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_51(BaseStrategy):
    """
    A strategy to maintain cooperation in repeated public goods games by allowing recovery after failures.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_prev_action = history.my_actions[last_round]
        my_contribution = 1 if my_prev_action else 0
        others_cooperation = np.sum(history.opponent_actions[last_round, :])
        total_coops = my_contribution + others_cooperation
        prev_met = total_coops >= self.m
        if prev_met:
            return Action.C
        else:
            return Action.D if my_prev_action else Action.C

class Strategy_COLLECTIVE_52(BaseStrategy):
    """
    A strategy that starts with cooperation and then responds based on the number of cooperators in the previous round.
    If the number of cooperators meets or exceeds a threshold m (calculated as ceil(n_players / k)), the strategy will cooperate again; otherwise, it defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_coops = history.opponent_actions[prev_round, :].sum()
        if prev_coops >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_53(BaseStrategy):
    """
    Implements the Collective Risk Deterrence strategy. The strategy begins with cooperation, 
    uses reciprocal altruism if enough players cooperate, gradually escalates if cooperation 
    drops below a threshold, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.max_escalation = 3
        self.reset_period = 2
        self.in_escalation = False
        self.escalation_count = 0
        self.in_reset = False
        self.reset_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if self.in_reset:
            self.reset_count -= 1
            if self.reset_count <= 0:
                self.in_reset = False
            return Action.C
        elif self.in_escalation:
            prev_coop = sum(history.opponent_actions[-1, :]) + (1 if history.my_actions[-1] else 0)
            if prev_coop >= self.m:
                self.in_escalation = False
                self.escalation_count = 0
                return Action.C
            else:
                self.escalation_count += 1
                if self.escalation_count >= self.max_escalation:
                    self.in_escalation = False
                    self.in_reset = True
                    self.reset_count = self.reset_period
                return Action.D
        else:
            prev_coop = sum(history.opponent_actions[-1, :]) + (1 if history.my_actions[-1] else 0)
            if prev_coop >= self.m:
                return Action.C
            else:
                self.in_escalation = True
                self.escalation_count = 1
                return Action.D

class Strategy_COLLECTIVE_54(BaseStrategy):
    """
    Collective Risk Strategy: Players start by cooperating, then adapt based on the proportion of past successful rounds.
    Success is defined when the number of cooperators meets a calculated threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        successes = 0
        num_previous_rounds = len(history.my_actions)
        for h in range(num_previous_rounds):
            my_action = history.my_actions[h]
            opponent_actions = history.opponent_actions[h]
            total_coop = my_action + sum(opponent_actions)
            if total_coop >= self.m:
                successes += 1
        if num_previous_rounds == 0:
            p = 0.0
        else:
            p = successes / num_previous_rounds
        if random.random() < p:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_55(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on the number of cooperators in previous rounds.
    Uses a threshold to decide whether to continue cooperating or defect, with a mechanism to revert to cooperation after defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2 + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponent_last_actions = history.opponent_actions[last_round, :]
        coop_last_round = my_last_action + np.sum(opponent_last_actions)
        if coop_last_round >= self.m:
            return Action.C
        else:
            if my_last_action == 0:
                if state.round_number >= 2:
                    two_rounds_ago = last_round - 1
                    my_two_ago = history.my_actions[two_rounds_ago]
                    opponent_two_ago = history.opponent_actions[two_rounds_ago, :]
                    coop_two_ago = my_two_ago + np.sum(opponent_two_ago)
                    if coop_two_ago < self.m:
                        return Action.C
            return Action.D

class Strategy_COLLECTIVE_56(BaseStrategy):
    """
    A strategy for sustaining cooperation in an N-player public goods game. 
    Players start by cooperating and adapt based on previous outcomes, punishing 
    lack of cooperation and allowing for recovery.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        my_prev_int = 1 if my_prev_action else 0
        opp_actions = history.opponent_actions[prev_round]
        sum_coop_prev = my_prev_int + int(np.sum(opp_actions))
        if sum_coop_prev >= self.m:
            return Action.C
        elif sum_coop_prev == 0:
            if random.random() < 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_57(BaseStrategy):
    """
    A strategy where players cooperate in the first round and continue as long as at least m players cooperated in the previous round.
    If fewer than m players cooperated, the player defects permanently.
    m is calculated as the minimal number of cooperators needed such that (k/n)*m >= 1.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.defecting = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.defecting:
            return Action.D
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponent_prev = history.opponent_actions[prev_round, :]
        t_prev = my_prev + np.sum(opponent_prev)
        if t_prev >= self.m:
            return Action.C
        else:
            self.defecting = True
            return Action.D

class Strategy_COLLECTIVE_58(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and strategic defection.
    Cooperates initially, adapts based on past cooperation levels, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prior_rounds_count = state.round_number
        m = self.game_description.n_players // 2
        count = 0
        for prior_round in range(prior_rounds_count):
            opponent_coop = sum(history.opponent_actions[prior_round, :])
            my_coop = history.my_actions[prior_round]
            total_coop = opponent_coop + (1 if my_coop else 0)
            if total_coop >= m:
                count += 1
        if count > prior_rounds_count / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_59(BaseStrategy):
    """
    A strategy that cooperates if at least m players cooperated in the previous round,
    where m is the minimum number calculated as the ceiling of (n_players / k).
    Start with cooperation in the first round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponent_prev_actions = history.opponent_actions[-1]
        coops_me = int(my_prev_action)
        coops_opponents = np.sum(opponent_prev_actions)
        total_coops = coops_me + coops_opponents
        if total_coops >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_60(BaseStrategy):
    """
    A strategy that balances responsiveness to recent outcomes with a reset mechanism 
    after periods of defection to sustain cooperation in public goods games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold_m = math.ceil(game_description.n_players / game_description.k)
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponent_last_actions = history.opponent_actions[last_round]
        my_coop = int(my_last_action)
        opponent_coop = opponent_last_actions.sum()
        num_coop = my_coop + opponent_coop
        if num_coop >= self.threshold_m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections >= 2:
                self.consecutive_defections = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_61(BaseStrategy):
    """
    A strategy that balances cooperation with strategic defection based on past outcomes.
    Cooperates initially, continues if enough others cooperate, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        elif current_round == total_rounds - 1:
            return Action.D
        else:
            prev_round = current_round - 1
            opponent_coops = sum(history.opponent_actions[prev_round])
            my_action = history.my_actions[prev_round]
            prev_total = opponent_coops + (1 if my_action else 0)
            if prev_total >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_62(BaseStrategy):
    """
    A deterministic strategy that encourages cooperation based on observing past behavior.
    It cooperates in the first round and in subsequent rounds if at least m players cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // game_description.k + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        sum_opponent_coop = np.sum(opponent_actions_prev)
        my_coop_prev = history.my_actions[prev_round]
        total_coop_prev = sum_opponent_coop + (1 if my_coop_prev else 0)
        if total_coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_63(BaseStrategy):
    """
    A deterministic strategy to maintain cooperation in public goods games.
    Players cooperate initially and adapt based on previous cooperation levels,
    attempting to recover cooperation if possible.
    Initializes with a calculated minimum number of cooperators (m) required for beneficial cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n_players = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n_players / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_last = history.my_actions[prev_round]
            opp_last = history.opponent_actions[prev_round, :]
            sum_opp_coop = np.sum(opp_last)
            prev_coop = sum_opp_coop + (1 if my_last else 0)
            if prev_coop >= self.m:
                return Action.C
            elif my_last is False:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_64(BaseStrategy):
    """
    Cooperate When Possible, Defect Strategically strategy for the N-Player Public Goods Game.
    Cooperates initially and adapts based on the number of cooperators in the previous round.
    Defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        if history is None:
            return Action.D
        my_coop_prev = history.my_actions[prev_round]
        sum_others_prev = history.opponent_actions[prev_round].sum()
        total_prev_coop = my_coop_prev + sum_others_prev
        if total_prev_coop >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_65(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy.

    This strategy encourages sustained cooperation by balancing cooperation
    with cautious defection when necessary. It co-operates in the first round,
    defects in the last round, and adapts based on the number of previous
    cooperators, allowing for limited forgiveness.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.failure_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.game_description.n_rounds - 1:
            return Action.D
        previous_round_idx = current_round - 1
        my_prev_action = history.my_actions[previous_round_idx]
        opponent_prev_actions = history.opponent_actions[previous_round_idx, :]
        n_coops_prev = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
        if n_coops_prev >= self.m:
            self.failure_counter = 0
            return Action.C
        else:
            self.failure_counter += 1
            if self.failure_counter <= 2:
                return Action.D
            else:
                self.failure_counter = 0
                return Action.C

class Strategy_COLLECTIVE_66(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages sustained cooperation by punishing insufficient cooperation 
    and providing opportunities to reset and recover. The strategy starts with cooperation, continues if a threshold of 
    cooperation is met, defects as punishment if the threshold is not met, and resets to cooperation after defecting once.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)
        self.last_defected = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif self.last_defected:
            self.last_defected = False
            return Action.C
        else:
            t_prev = state.round_number - 1
            my_prev = history.my_actions[t_prev]
            opp_prev = history.opponent_actions[t_prev, :].sum()
            m_prev = my_prev + opp_prev
            if m_prev >= self.m:
                return Action.C
            else:
                self.last_defected = True
                return Action.D

class Strategy_COLLECTIVE_67(BaseStrategy):
    """
    A strategy for the N-player Public Goods Game that encourages cooperation by rewarding past cooperation and defecting 
    when cooperation thresholds are not met. Cooperates initially, uses a threshold to decide subsequent actions, and defects 
    in the last round if past cooperation was insufficient.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defect_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.defect_remaining > 0:
            self.defect_remaining -= 1
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            past_counts = []
            for r in range(state.round_number):
                coop = int(history.my_actions[r]) + np.sum(history.opponent_actions[r, :])
                past_counts.append(coop)
            m = self.game_description.n_players // 2 + 1
            met = sum((1 for c in past_counts if c >= m))
            total_past = len(past_counts)
            if met > total_past / 2:
                return Action.C
            else:
                return Action.D
        else:
            past_counts = []
            for r in range(state.round_number):
                coop = int(history.my_actions[r]) + np.sum(history.opponent_actions[r, :])
                past_counts.append(coop)
            m = self.game_description.n_players // 2 + 1
            met = sum((1 for c in past_counts if c >= m))
            total_past = len(past_counts)
            if met > total_past / 2:
                return Action.C
            else:
                self.defect_remaining = 1
                return Action.D

class Strategy_COLLECTIVE_68(BaseStrategy):
    """
    A strategy that promotes cooperation based on the number of players who cooperated in the previous round.
    Players cooperate in the first round and then continue to cooperate if at least half of the players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions_last = history.opponent_actions[-1]
        opp_coops = np.sum(opponent_actions_last)
        my_prev_action = history.my_actions[-1]
        total_coops = opp_coops + (1 if my_prev_action else 0)
        if total_coops >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_69(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness strategy for N-Player Public Goods Game.
    Cooperates initially, defects if cooperation threshold isn't met, then waits before re-cooperating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = min(math.ceil(game_description.k), game_description.n_players)
        self.defect_until = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.defect_until is not None and state.round_number <= self.defect_until:
            return Action.D
        last_round = state.round_number - 1
        opponents_last = history.opponent_actions[last_round, :]
        my_last_action = history.my_actions[last_round]
        sum_opponents = sum(opponents_last)
        last_coop = sum_opponents + (1 if my_last_action else 0)
        if last_coop >= self.m:
            return Action.C
        else:
            w = max(1, math.ceil(self.m / self.game_description.n_players))
            self.defect_until = state.round_number + w
            return Action.D

class Strategy_COLLECTIVE_70(BaseStrategy):
    """
    A strategy that balances immediate responsiveness with forgiveness, 
    transitioning to defection after two consecutive failures.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = int(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == 1:
            return Action.C
        for r in [current_round - 1, current_round - 2]:
            if r < 0:
                continue
            my_c = history.my_actions[r]
            opponent_sum = np.sum(history.opponent_actions[r, :])
            total = my_c + opponent_sum
            if total >= self.m:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_71(BaseStrategy):
    """
    A strategy that adaptively cooperates based on the number of cooperators in the previous rounds,
    with a forgiveness mechanism to recover from defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)
        self.x = 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            self.consecutive_defections = 0
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        total_C = prev_my_action + np.sum(opp_prev_actions)
        if total_C >= self.m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections >= self.x:
                self.consecutive_defections = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_72(BaseStrategy):
    """
    A strategy designed for the N-Player Public Goods Game that balances cooperation 
    with strategic defection based on past outcomes to maximize individual and 
    group benefits effectively.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev = history.opponent_actions[prev_round]
            sum_opponents = np.sum(opponents_prev)
            total_coop = my_prev_action + sum_opponents
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_73(BaseStrategy):
    """
    Modified Tit-for-Tat (TFT) strategy for N-player public goods game.
    Cooperates if at least m players cooperated in the previous round, where m is calculated based on the game's parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        if k == 0:
            self.m = 0
        else:
            m = k / (k + 1) * n
            self.m = int(math.floor(m))

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        sum_opp_prev = sum(history.opponent_actions[prev_round, :])
        my_prev_action = history.my_actions[prev_round]
        s_prev = sum_opp_prev + (1 if my_prev_action else 0)
        if s_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_74(BaseStrategy):
    """
    Responsive Cooperation with Immediate Punishment strategy.
    Cooperates in the first round, then continues to cooperate if at least m players
    cooperated in the previous round; otherwise, defects.
    Computes m as the minimal number of cooperators required to sustain cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round]
        sum_opponent_C = np.sum(opponent_actions_prev)
        total_C_prev = my_action + sum_opponent_C
        if total_C_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_75(BaseStrategy):
    """
    Cooperative Punishment with Recovery Strategy.
    
    - Players start by Cooperating.
    - If the number of Cooperators in the previous round meets or exceeds a threshold (m), they continue to Cooperate.
    - If the threshold is not met, they Defect once (Punish) and then revert to Cooperate in the next round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.state = 'COOPERATE'

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponent_actions = history.opponent_actions[prev_round, :]
        total_prev_coop = prev_my_action + sum(prev_opponent_actions)
        if self.state == 'COOPERATE':
            if total_prev_coop >= self.m:
                return Action.C
            else:
                self.state = 'PUNISH'
                return Action.D
        else:
            self.state = 'COOPERATE'
            return Action.C

class Strategy_COLLECTIVE_76(BaseStrategy):
    """
    Cooperative Restart with Bounded Retaliation strategy.
    Cooperates initially, continues if enough players cooperate,
    and retaliates for a limited number of rounds if cooperation
    is below the threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)
        self.l = 1
        self.retaliating = False
        self.retaliating_rounds_left = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        if prev_round >= 0:
            if history is not None:
                my_prev_action = history.my_actions[prev_round]
                opponents_prev_actions = history.opponent_actions[prev_round]
                S_prev = np.sum(opponents_prev_actions) + (1 if my_prev_action else 0)
            else:
                S_prev = 0
            if S_prev >= self.m:
                self.retaliating = False
                self.retaliating_rounds_left = 0
                return Action.C
            elif self.retaliating:
                if self.retaliating_rounds_left > 0:
                    self.retaliating_rounds_left -= 1
                    return Action.D
                else:
                    self.retaliating = False
                    self.retaliating_rounds_left = 0
                    return Action.D
            else:
                self.retaliating = True
                self.retaliating_rounds_left = self.l
                return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_77(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy.
    Cooperates initially, then continues if previous round has sufficient cooperators.
    Defects once if insufficient, then forgives.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = max(1, game_description.n_players - 1)
        self.punishment_pending = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        prev_round = state.round_number - 1
        my_action_prev = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round]
        prev_coops = np.sum(opponent_actions_prev) + (1 if my_action_prev else 0)
        if prev_coops >= self.m:
            self.punishment_pending = False
            return Action.C
        elif self.punishment_pending:
            self.punishment_pending = False
            return Action.C
        else:
            self.punishment_pending = True
            return Action.D

class Strategy_COLLECTIVE_78(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.floor(self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        is_last_round = state.round_number == self.n_rounds - 1
        if is_last_round:
            total_coop = 0.0
            for t in range(len(history.my_actions)):
                my_act = history.my_actions[t]
                opponents_acts = history.opponent_actions[t, :]
                coop = my_act + np.sum(opponents_acts)
                total_coop += coop
            avg_coop = total_coop / state.round_number
            if avg_coop >= self.m:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponents_prev = history.opponent_actions[prev_round, :]
            prev_total = my_prev + np.sum(opponents_prev)
            if prev_total >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_79(BaseStrategy):
    """
    Mixed strategy for N-Player Public Goods Game where each player 
    randomizes their choice between Cooperate (C) and Defect (D) based 
    on a calculated probability p to balance expected payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.p = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if random.random() < self.p:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_80(BaseStrategy):
    """
    Adaptive Cooperation with Reset Strategy for N-Player Public Goods Game.
    Cooperates initially, then responds based on previous round's cooperation level.
    Resets cooperation after consecutive rounds below the threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.floor(self.k)
        self.reset_threshold = 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round]
        my_action_prev = history.my_actions[previous_round]
        s_prev = np.sum(opponent_actions_prev) + my_action_prev
        if s_prev >= self.m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections >= self.reset_threshold:
                self.consecutive_defections = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_81(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy.
    
    Cooperates in the first round. In subsequent rounds, cooperates if the number 
    of cooperators in the previous round meets or exceeds a threshold (m), which 
    is set to the ceiling of half the number of players. Otherwise, defects to 
    enforce compliance.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m_threshold = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        total_c = int(my_prev_action) + np.sum(opponent_prev_actions)
        if total_c >= self.m_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_82(BaseStrategy):
    """
    Cooperate-Punish-Cooperate Strategy:
    - Cooperates initially and continues if previous cooperation meets threshold.
    - Defects once if previous cooperation was insufficient, then resumes cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        if not history.my_actions[t_prev]:
            return Action.C
        opponent_actions_prev = history.opponent_actions[t_prev]
        opponents_coop = np.sum(opponent_actions_prev)
        my_coop_prev = history.my_actions[t_prev]
        m_prev = opponents_coop + (1 if my_coop_prev else 0)
        if m_prev >= self.game_description.k:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_83(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation
    with punishment. Cooperates if at least half of the players cooperated in
    the previous round, defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        sum_opponent_coop = history.opponent_actions[prev_round].sum()
        my_prev_coop = history.my_actions[prev_round]
        total_coop = sum_opponent_coop + my_prev_coop
        threshold = self.game_description.n_players // 2
        if total_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_84(BaseStrategy):
    """
    Punish Once, Then Cooperate Strategy.

    Players start by cooperating. If cooperation drops below a threshold (m),
    players defect once as punishment. After defecting, players resume
    cooperation regardless of the outcome in thepunishment round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_action = history.my_actions[prev_round]
        if not prev_action:
            return Action.C
        my_prev_c = 1 if history.my_actions[prev_round] else 0
        opponents_prev_c = sum(history.opponent_actions[prev_round, :])
        total_prev_coop = my_prev_c + opponents_prev_c
        if total_prev_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_85(BaseStrategy):
    """
    A strategy to promote sustained cooperation in a repeated N-Player Public Goods Game.
    The strategy encourages initial cooperation and adapts based on previous rounds' outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = (game_description.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            count = 0
            t = state.round_number
            for prev_round in range(t):
                my_coop = history.my_actions[prev_round]
                opponents_coop = np.sum(history.opponent_actions[prev_round, :])
                cooperators = my_coop + opponents_coop
                if cooperators >= self.m:
                    count += 1
            if 2 * count > t:
                return Action.C
            else:
                return Action.D
        else:
            t_prev = state.round_number - 1
            my_coop_prev = history.my_actions[t_prev]
            opponents_coop_prev = np.sum(history.opponent_actions[t_prev, :])
            cooperators_prev = my_coop_prev + opponents_coop_prev
            if cooperators_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_86(BaseStrategy):
    """
    Adaptive Threshold Cooperation strategy.
    Cooperates initially and continues if at least half of the recent rounds were successful.
    A round is successful if at least m players cooperated, where m = ceil(n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is None:
            return Action.C
        else:
            start_round = max(0, state.round_number - 3)
            end_round = state.round_number
            success_count = 0
            for round_num in range(start_round, end_round):
                my_action = history.my_actions[round_num]
                opponents_actions = history.opponent_actions[round_num]
                total_coops = my_action + np.sum(opponents_actions)
                if total_coops >= self.m:
                    success_count += 1
            total_rounds = end_round - start_round
            if total_rounds == 0:
                return Action.C
            else:
                success_rate = success_count / total_rounds
                if success_rate >= 0.5:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_87(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.forced_to_coop_next = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.forced_to_coop_next:
            self.forced_to_coop_next = False
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            count_coop = my_prev_action + sum(opponents_prev_actions)
            if count_coop >= self.m:
                return Action.C
            else:
                self.forced_to_coop_next = True
                return Action.D

class Strategy_COLLECTIVE_88(BaseStrategy):
    """
    A strategy that cooperates in the first round and then cooperates in subsequent rounds 
    if at least m players cooperated in the previous round, where m is determined as the floor 
    of the game's multiplication factor k. This encourages sustained cooperation while 
    protecting against widespread defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_coop = history.my_actions[-1] + sum(history.opponent_actions[-1, :])
        if prev_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_89(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.r - 1:
            return Action.C
        else:
            t = state.round_number
            s = 0
            for past_round in range(t):
                my_action = history.my_actions[past_round]
                opponents_actions = history.opponent_actions[past_round, :]
                total_C = my_action + np.sum(opponents_actions)
                if total_C >= self.m:
                    s += 1
            ratio = s / t
            return Action.C if ratio >= 0.5 else Action.D

class Strategy_COLLECTIVE_90(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) strategy for N-Player Public Goods Game.
    Starts with cooperation, adapts based on previous rounds' cooperation levels, and uses historical average in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m_threshold = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            sum_coop = 0.0
            for t in range(state.round_number):
                n_coop = history.my_actions[t] + np.sum(history.opponent_actions[t, :])
                sum_coop += n_coop
            average_coop = sum_coop / state.round_number
            return Action.C if average_coop >= self.m_threshold else Action.D
        else:
            prev_round = state.round_number - 1
            prev_coop = history.my_actions[prev_round] + np.sum(history.opponent_actions[prev_round, :])
            return Action.C if prev_coop >= self.m_threshold else Action.D

class Strategy_COLLECTIVE_92(BaseStrategy):
    """
    A strategy that starts by cooperating, then continues cooperating if at least half of the players cooperated 
    in the previous round, otherwise defects but plans to cooperate in the next round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.next_round_must_coop = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.next_round_must_coop:
            self.next_round_must_coop = False
            return Action.C
        prev_round = state.round_number - 1
        own_prev = history.my_actions[prev_round]
        others_prev = history.opponent_actions[prev_round]
        n_cooperators = sum(others_prev) + (1 if own_prev else 0)
        if n_cooperators >= self.m:
            return Action.C
        else:
            if state.round_number < self.game_description.n_rounds - 1:
                self.next_round_must_coop = True
            return Action.D

class Strategy_COLLECTIVE_93(BaseStrategy):
    """
    Adaptive Collective Cooperation Strategy.

    Cooperates initially and adapts based on the average number of cooperators in previous rounds,
    with a wait period after each strategy switch to promote stability.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.current_action = Action.C
        self.last_switched = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        if current_round - self.last_switched >= 2 or self.last_switched == -1:
            sum_coops = 0.0
            for r in range(current_round):
                my_coop = history.my_actions[r]
                opponent_coop = np.sum(history.opponent_actions[r, :])
                sum_coops += my_coop + opponent_coop
            average_coops = sum_coops / current_round
            m = self.n_players / 2.0
            desired_action = Action.C if average_coops >= m else Action.D
            if desired_action != self.current_action:
                self.current_action = desired_action
                self.last_switched = current_round
        return self.current_action

class Strategy_COLLECTIVE_94(BaseStrategy):
    """
    Cooperative Reciprocity with Punishment (CRP) Strategy.

    This strategy encourages sustained cooperation while allowing for punishment
    of non-cooperative behavior. It uses a threshold (m) to decide whether to
    cooperate based on the number of cooperators in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n_players = game_description.n_players
        k_factor = game_description.k
        m = math.ceil(n_players / k_factor)
        self.m = min(m, n_players)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        s_prev = state.round_number - 1
        my_prev = history.my_actions[s_prev]
        opp_prev = history.opponent_actions[s_prev, :]
        previous_coops = my_prev + sum(opp_prev)
        if previous_coops >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_95(BaseStrategy):
    """
    A strategy that cooperates unless the previous round failed (insufficient cooperators),
    in which case cooperating players defect once before attempting to cooperate again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_last_action = history.my_actions[-1]
        last_opponent_actions = history.opponent_actions[-1]
        c_count = sum(last_opponent_actions) + (1 if my_last_action else 0)
        if c_count >= self.m:
            return Action.C
        elif my_last_action:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_96(BaseStrategy):
    """
    A strategy to maintain cooperation in a repeated public goods game.
    Players cooperate unconditionally in the first round. In subsequent rounds,
    they continue to cooperate if a sufficient number cooperated previously,
    otherwise they cooperate with a probability proportional to the threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.n = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_actions = history.my_actions[prev_round]
        opponent_actions = history.opponent_actions[prev_round, :]
        my_coop = 1 if my_actions else 0
        opp_coop = np.sum(opponent_actions)
        total_coop = my_coop + opp_coop
        if total_coop >= self.m:
            return Action.C
        else:
            p = self.m / self.n
            if random.random() < p:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_97(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) Strategy.
    
    This strategy encourages cooperation by initially cooperating, then punishing 
    defection when a cooperation threshold is not met.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        sum_opponents = np.sum(history.opponent_actions[prev_round, :])
        total_coop = my_prev_action + sum_opponents
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_98(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy.
    Cooperates initially and continues if enough players cooperated previously.
    Introduces occasional forgiveness to recover cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions_last = history.opponent_actions[-1]
        sum_coop_opponents = np.sum(opponent_actions_last)
        my_last_action = history.my_actions[-1]
        total_coop = sum_coop_opponents + my_last_action
        if total_coop >= self.m:
            return Action.C
        elif random.random() < 0.1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_99(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        my_last_action = history.my_actions[state.round_number - 1]
        if not my_last_action:
            return Action.C
        last_round = state.round_number - 1
        opponent_actions_last = history.opponent_actions[last_round]
        count_opponents = np.sum(opponent_actions_last)
        if my_last_action:
            count_prev = 1 + count_opponents
        else:
            count_prev = count_opponents
        m = self.game_description.n_players // 2
        if count_prev >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_100(BaseStrategy):
    """
    A strategy that maintains cooperation if a sufficient number of players cooperated in the previous round.
    Uses a threshold calculated as m = ceil(n_players / k) to decide cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_opponent_actions = history.opponent_actions[-1, :]
        sum_opponents = np.sum(previous_opponent_actions)
        my_prev = history.my_actions[-1]
        total_coopr = sum_opponents + (1 if my_prev else 0)
        if total_coopr >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_101(BaseStrategy):
    """
    Adaptive Cooperation Strategy based on the number of cooperators in the previous round.
    Cooperate in the first round, then continue cooperating if the previous round had enough cooperators.
    The threshold is calculated as the ceiling of (n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = int(math.ceil(n / k))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_prev_action = history.my_actions[last_round]
        opponents_prev_actions = history.opponent_actions[last_round, :]
        m_prev = int(my_prev_action) + np.sum(opponents_prev_actions)
        if m_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_102(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages sustained cooperation.
    It starts with cooperation and adapts behavior based on the success of previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_previous_action = history.my_actions[previous_round]
        opponents_previous_actions = history.opponent_actions[previous_round]
        total_cooperation = sum(opponents_previous_actions) + (1 if my_previous_action else 0)
        if total_cooperation >= self.m:
            return Action.C
        else:
            p = self.m / self.game_description.n_players
            if random.random() < p:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_103(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on previous rounds' cooperation levels.
    Cooperates if enough players cooperated in the previous round; otherwise, defects, but only up to a patience limit.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n_players // 2
        self.patience = 2
        self.prev_coops = 0
        self.defects_in_a_row = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_coops = 0
            self.defects_in_a_row = 0
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponents_prev = history.opponent_actions[prev_round]
            self.prev_coops = my_prev + sum(opponents_prev)
            if self.prev_coops >= self.m:
                self.defects_in_a_row = 0
                return Action.C
            elif self.defects_in_a_row < self.patience:
                self.defects_in_a_row += 1
                return Action.D
            else:
                self.defects_in_a_row = 0
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_104(BaseStrategy):
    """Adaptive Cooperation Strategy based on recent success of cooperation."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.w = 3

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_action_prev = history.my_actions[t_prev]
        opponent_actions_prev = history.opponent_actions[t_prev, :]
        c_t_prev = my_action_prev + opponent_actions_prev.sum()
        if c_t_prev >= self.m:
            return Action.C
        start_round = max(0, t_prev - self.w + 1)
        s = 0
        for rt in range(start_round, t_prev + 1):
            my_action_rt = history.my_actions[rt]
            opponent_actions_rt = history.opponent_actions[rt, :]
            c_rt = my_action_rt + opponent_actions_rt.sum()
            if c_rt >= self.m:
                s += 1
        p = s / self.w
        if random.random() < p:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_105(BaseStrategy):
    """
    A strategy that cooperates if the previous round met the threshold of at least half the players cooperating.
    Defects once if the threshold was not met, then reverts to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        total_coop = int(my_prev_action) + np.sum(opponent_prev_actions)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_106(BaseStrategy):
    """
    Group-Level Tit-for-Tat (G-L TFT) Strategy.

    This strategy balances cooperation and punishment based on group performance.
    It starts by cooperating and adapts by punishing if cooperation falls below a threshold.
    The threshold is determined as half the number of players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            previous_round = state.round_number - 1
            my_prev_action = history.my_actions[previous_round]
            opponent_actions_prev = history.opponent_actions[previous_round]
            c_prev = my_prev_action + np.sum(opponent_actions_prev)
            if c_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_107(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy.

    This strategy starts by cooperating in the first round. In subsequent rounds,
    it cooperates if the number of cooperators in the previous round meets or 
    exceeds a threshold (half the number of players). If not, it mostly defects
    but has a small probability of cooperating again to encourage cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.epsilon = 0.05

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            previous_round = state.round_number - 1
            my_coop = int(history.my_actions[previous_round])
            opponent_coops = history.opponent_actions[previous_round].sum()
            total_coops = my_coop + opponent_coops
            if total_coops >= self.m:
                return Action.C
            elif random.random() < self.epsilon:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_108(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on the number of cooperators in the previous round.
    Cooperates if at least half of the players (rounded up) cooperated previously; otherwise, defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.threshold = (self.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        total_coop_prev = my_prev_action + np.sum(opponent_prev_actions)
        if total_coop_prev >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_109(BaseStrategy):
    """
    Adaptive Cooperative Punishment Strategy.
    
    This strategy starts by cooperating and continues if enough players (m) 
    cooperate in the previous round. It defects for one round as punishment 
    if cooperation drops below the threshold. For the final round, it 
    cooperates only if the penultimate round's cooperation would meet the 
    threshold when including its own action.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            opponent_last = history.opponent_actions[-1, :] if history is not None else np.array([], dtype=bool)
            projected_others = sum(opponent_last)
            if projected_others + 1 >= self.m:
                return Action.C
            else:
                return Action.D
        elif history is not None:
            prev_round = state.round_number - 1
            opponent_prev = history.opponent_actions[prev_round, :]
            sum_opp = sum(opponent_prev)
            my_prev_action = history.my_actions[prev_round]
            total_prev = sum_opp + (1 if my_prev_action else 0)
            if total_prev >= self.m:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_110(BaseStrategy):
    """
    Strategy to cooperate if at least half of the players cooperated in the previous round.
    Starts by cooperating in the first round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_last = history.my_actions[prev_round]
        opp_last = history.opponent_actions[prev_round, :]
        cooperators = my_last + opp_last.sum()
        threshold = self.game_description.n_players // 2
        if cooperators >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_111(BaseStrategy):
    """
    An adaptive strategy for the public goods game that balances cooperation based on recent collective success.
    
    The strategy tracks the success of rounds using an exponential moving average and adjusts behavior accordingly.
    It starts with cooperation, evaluates collective success, and adapts its actions while handling the final round separately.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)
        self.w = max(2, self.r // 4)
        self.alpha = 2.0 / (self.w + 1.0) if self.w != 0 else 0.0
        self.ema = 0.0
        self.threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        if current_round == self.r - 1:
            return Action.D
        prev_round = current_round - 1
        my_prev = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        n_coop = 1 if my_prev else 0
        n_coop += np.sum(opponent_actions_prev)
        s_t = 1 if n_coop >= self.m else 0
        self.ema = self.alpha * s_t + (1 - self.alpha) * self.ema
        if self.ema >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_112(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) strategy. Cooperates initially, then 
    cooperates again if at least m players cooperated in the previous round, 
    where m is derived from the game's k parameter.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)
        self.m = min(self.m, game_description.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        my_coop = 1 if my_prev_action else 0
        opp_prev_actions = history.opponent_actions[prev_round]
        opp_coop = np.sum(opp_prev_actions)
        total_coop = my_coop + opp_coop
        return Action.C if total_coop >= self.m else Action.D

class Strategy_COLLECTIVE_113(BaseStrategy):
    """
    Cooperate in the first round. In subsequent rounds, cooperate if at least m players cooperated 
    in the previous round, where m is the ceiling of n/k. Defect otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        k = self.game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        sum_opponents = np.sum(history.opponent_actions[-1])
        my_prev = history.my_actions[-1]
        total_coop = sum_opponents + (1 if my_prev else 0)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_114(BaseStrategy):
    """
    Adaptive Collective Cooperation with Punishment (ACCP) Strategy.
    
    This strategy encourages sustained cooperation by starting with cooperation,
    punishing when cooperation levels drop below a threshold, and recovery by
    re-initiating cooperation post-punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        prev_my_action = history.my_actions[t_prev]
        if not prev_my_action:
            return Action.C
        else:
            sum_opponents_prev = sum(history.opponent_actions[t_prev, :])
            sum_c_prev = sum_opponents_prev + (1 if prev_my_action else 0)
            if sum_c_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_115(BaseStrategy):
    """
    Adaptive Cooperate-and-Punish strategy for N-Player Public Goods Game.
    Cooperates initially and continues if enough players cooperate, otherwise defects once as punishment.
    Cooperates again after punishment regardless of the previous outcome.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.after_punish = False
        self.last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.last_action = action
            self.after_punish = False
            return action
        elif self.after_punish:
            action = Action.C
            self.after_punish = False
            self.last_action = action
            return action
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, :]
            coops = my_prev_action + np.sum(opp_prev_actions)
            if coops >= self.m:
                action = Action.C
            elif self.last_action == Action.C:
                action = Action.D
                self.after_punish = True
            else:
                action = Action.C
            self.last_action = action
            return action

class Strategy_COLLECTIVE_116(BaseStrategy):
    """
    A strategy to encourage sustained cooperation in the N-player Public Goods Game.
    It starts by cooperating, then continues to cooperate if a minimum threshold (m)
    of players cooperated in the previous round. After a defection, it may revert to
    cooperation if the cooperation level was sufficient two rounds prior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_C = history.my_actions[prev_round]
        opponent_prev_C = sum(history.opponent_actions[prev_round])
        count_previous = my_prev_C + opponent_prev_C
        if count_previous >= self.m:
            return Action.C
        if state.round_number > 1:
            prev_prev_round = prev_round - 1
            my_prev_prev_C = history.my_actions[prev_prev_round]
            opponent_prev_prev_C = sum(history.opponent_actions[prev_prev_round])
            count_before_last = my_prev_prev_C + opponent_prev_prev_C
            if count_before_last >= self.m:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_117(BaseStrategy):
    """
    Adaptive Cooperation Strategy for N-Player Public Goods Game.
    
    The strategy starts with cooperation and adapts based on the success of previous rounds.
    It continues cooperating if the last cooperation was beneficial compared to defecting;
    otherwise, it defects. After defecting, it reverts to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_my_action = history.my_actions[-1]
        if last_my_action:
            opponents_c = sum(history.opponent_actions[-1])
            total_c = 1 + opponents_c
            my_last_payoff = history.my_payoffs[-1]
            k = self.game_description.k
            n = self.game_description.n_players
            public_good_if_D = k / n * (total_c - 1)
            payoff_if_D = 1.0 + public_good_if_D
            if my_last_payoff > payoff_if_D:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_118(BaseStrategy):
    """
    Cooperative Restart with Limited Forgiveness strategy.
    Starts with cooperation, defects if cooperation is below a threshold, 
    and restarts cooperation after a limited number of defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponent_actions = history.opponent_actions[prev_round]
        prev_coops = int(prev_my_action) + np.sum(prev_opponent_actions)
        if prev_coops >= self.m:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections < 2:
            self.consecutive_defections += 1
            return Action.D
        else:
            self.consecutive_defections = 0
            return Action.C

class Strategy_COLLECTIVE_119(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) Strategy:
    Cooperates if the number of cooperators in the previous round meets or exceeds a threshold.
    The threshold (m) is calculated as the ceiling of (n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            s = state.round_number - 1
            my_action_prev = 1 if history.my_actions[s] else 0
            opp_actions_prev = history.opponent_actions[s]
            total_coop_prev = my_action_prev + np.sum(opp_actions_prev)
            if total_coop_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_120(BaseStrategy):
    """
    A strategy that begins by Cooperating and then Cooperates if at least m players Cooperated in the previous round.
    It Defects for rounds where enough players didn't Cooperate, but will reset back to Cooperation after one Defection.
    m is calculated as the ceiling of (n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_last = history.my_actions[prev_round]
        opp_last = history.opponent_actions[prev_round]
        my_contribution = 1 if my_last else 0
        opp_contributions = sum(opp_last)
        total_contrib = my_contribution + opp_contributions
        if total_contrib >= self.m:
            return Action.C
        elif not my_last:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_121(BaseStrategy):
    """
    Implements the Grim Trigger strategy in the N-Player Public Goods Game.
    Cooperates in all rounds unless any previous round has fewer cooperators than the total number of players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        for prev_round in range(state.round_number):
            my_coop = history.my_actions[prev_round]
            opponents_coop = history.opponent_actions[prev_round].sum()
            total_coop = my_coop + opponents_coop
            if total_coop < self.m:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_122(BaseStrategy):
    """
    Cooperate in the first round. For each subsequent round, cooperate if at 
    least half of the players (rounded down) cooperated in the previous round.
    Otherwise, defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_my_action = history.my_actions[state.round_number - 1]
            prev_opp_actions = history.opponent_actions[state.round_number - 1, :]
            total_coop = sum(prev_opp_actions) + (1 if prev_my_action else 0)
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_123(BaseStrategy):
    """
    Responsive Cooperation with Patience Strategy.
    Cooperates if the number of Cooperators in the previous round meets or exceeds a threshold.
    Uses a patience counter to reset cooperation after a brief period of low participation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.s = 2
        self.d_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponent_actions = history.opponent_actions[prev_round]
        total_coops_prev = sum(prev_opponent_actions) + (1 if prev_my_action else 0)
        if total_coops_prev >= self.m:
            self.d_counter = 0
            return Action.C
        else:
            self.d_counter += 1
            if self.d_counter >= self.s:
                self.d_counter = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_124(BaseStrategy):
    """
    Adaptive Cooperation with Punishment Strategy for Public Goods Game.

    This strategy encourages cooperation by punishing insufficient cooperation in the previous round.
    It starts with cooperation and adapts based on the number of cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opp_prev_actions = history.opponent_actions[previous_round]
        player_coop = 1 if my_prev_action else 0
        coop_opp = np.sum(opp_prev_actions)
        prev_coop = player_coop + coop_opp
        if prev_coop >= self.m:
            current_action = Action.C
        elif self.last_action == Action.C:
            current_action = Action.D
        else:
            current_action = Action.C
        self.last_action = current_action
        return current_action

class Strategy_COLLECTIVE_125(BaseStrategy):
    """
    An adaptive strategy that adjusts cooperation probability based on past cooperation levels.
    Players start with an initial probability based on a calculated threshold and adjust
    this probability each round to aim for sustained cooperation levels.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)
        self.p = self.m / n
        self.delta = 0.1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if random.random() < self.p:
                return Action.C
            else:
                return Action.D
        else:
            t = state.round_number - 1
            my_prev = history.my_actions[t]
            opponents_prev = history.opponent_actions[t, :]
            total_c = my_prev + np.sum(opponents_prev)
            if total_c < self.m:
                self.p = min(self.p + self.delta, 1.0)
            elif total_c > self.m:
                self.p = max(self.p - self.delta, 0.0)
            if random.random() < self.p:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_126(BaseStrategy):
    """
    Cooperative Threshold Strategy: Cooperate if at least m players (including self) Cooperated in the previous round,
    where m is the minimal number ensuring the public good's benefit outweighs the private loss.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        opponent_coop_prev = np.sum(opponent_prev_actions)
        total_coop = my_prev_action + opponent_coop_prev
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_127(BaseStrategy):
    """
    A strategy for N-player public goods game that encourages sustained cooperation
    by combining punishment for insufficient cooperation with opportunities to recover.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.prev_was_punish = False
        self.last_s = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        prev_round = current_round - 1
        my_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round]
        s_prev = int(my_action) + int(opponent_actions_prev.sum())
        if s_prev >= self.m:
            action = Action.C
            self.prev_was_punish = False
        elif self.prev_was_punish:
            action = Action.C
            self.prev_was_punish = False
        else:
            action = Action.D
            self.prev_was_punish = True
        self.last_s = s_prev
        return action

class Strategy_COLLECTIVE_128(BaseStrategy):
    """
    A strategy that begins with cooperation and then decides based on the success ratio of past rounds.
    Cooperates if the success ratio meets a threshold, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        successes = 0
        for t in range(state.round_number):
            sum_opponents = np.sum(history.opponent_actions[t])
            my_c = history.my_actions[t]
            n_coop = sum_opponents + my_c
            if n_coop >= self.m:
                successes += 1
        sr = successes / state.round_number
        threshold = self.m / self.n_players
        if sr >= threshold - 1e-09:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_129(BaseStrategy):
    """
    A strategy that adapts cooperation based on historical success, starting with cooperation.
    It uses a threshold to determine successful rounds and adapts its decisions accordingly.
    The strategy is designed to promote cooperation when beneficial and adapt to defection when necessary.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = (game_description.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prior_rounds = state.round_number
        successful_coops = 0
        for round_idx in range(prior_rounds):
            cooperators = sum(history.opponent_actions[round_idx, :]) + (1 if history.my_actions[round_idx] else 0)
            if cooperators >= self.m:
                successful_coops += 1
        cooperation_rate = successful_coops / prior_rounds if prior_rounds > 0 else 0.0
        if cooperation_rate >= 0.5:
            action = Action.C
        else:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if successful_coops > prior_rounds // 2:
                action = Action.C
            else:
                action = Action.D
        return action

class Strategy_COLLECTIVE_130(BaseStrategy):
    """
    A strategy that starts with cooperation, reciprocates based on previous round's cooperation level,
    and defects in the final round to maximize individual payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            num_coop_opponents = np.sum(opponent_actions_prev)
            own_prev_action = history.my_actions[prev_round]
            total_coop = num_coop_opponents + (1 if own_prev_action else 0)
            m = self.game_description.n_players // 2
            return Action.C if total_coop >= m else Action.D

class Strategy_COLLECTIVE_131(BaseStrategy):
    """
    Collective Strategy for the Collective Risk Dilemma in Public Goods Game.
    Players cooperate if the number of cooperators in the previous round meets a threshold.
    The threshold is set to half the number of players, rounded down.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_prev_action = history.my_actions[t_prev]
        opponent_prev_actions = history.opponent_actions[t_prev]
        count_coop_prev = my_prev_action + np.sum(opponent_prev_actions)
        if count_coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_132(BaseStrategy):
    """
    A strategy that balances reciprocity with forgiveness to maintain cooperation.
    Cooperates initially and continues if enough others cooperate, defects otherwise,
    but forgives after one defection to encourage recovery.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        m_float = n / k
        if m_float == int(m_float):
            self.m = int(m_float) + 1
        else:
            self.m = math.ceil(m_float)
        self.must_cooperate = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.must_cooperate:
            self.must_cooperate = False
            return Action.C
        t_prev = state.round_number - 1
        my_prev_action = history.my_actions[t_prev]
        opp_prev_actions = history.opponent_actions[t_prev]
        s_prev = int(my_prev_action) + np.sum(opp_prev_actions)
        if s_prev >= self.m:
            return Action.C
        else:
            self.must_cooperate = True
            return Action.D

class Strategy_COLLECTIVE_133(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages cooperation through initial goodwill, 
    adapts by monitoring past behavior, punishes defectors, and adjusts in endgame scenarios.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_remaining = 0
        self.m = 0.5
        self.punishment_length = 3
        self.endgame_threshold = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        if history is None:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - self.endgame_threshold:
            my_actions = history.my_actions
            my_payoffs = history.my_payoffs
            c_actions = my_actions
            c_payoffs = my_payoffs[c_actions]
            d_payoffs = my_payoffs[~c_actions]
            avg_c = np.mean(c_payoffs) if len(c_payoffs) > 0 else 0
            avg_d = np.mean(d_payoffs) if len(d_payoffs) > 0 else 0
            if avg_c >= avg_d:
                return Action.C
            else:
                return Action.D
        else:
            total_coop = 0
            count_rounds = state.round_number
            for t in range(count_rounds):
                c_me = history.my_actions[t]
                c_others = history.opponent_actions[t].sum()
                total_coop += c_me + c_others
            avg_coop = total_coop / count_rounds
            required = self.m * self.game_description.n_players
            if avg_coop >= required:
                return Action.C
            else:
                self.punishment_remaining = self.punishment_length
                return Action.D

class Strategy_COLLECTIVE_134(BaseStrategy):
    """
    An adaptive cooperation strategy that begins with cooperation and then 
    switches based on the success of recent rounds. It considers the number of 
    cooperators in the last three rounds and cooperates if more than half of 
    those rounds were successful.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        start_round = max(0, state.round_number - 3)
        recent_rounds = range(start_round, state.round_number)
        recent_successes = 0
        for r in recent_rounds:
            my_coop = history.my_actions[r]
            opponents_coop = history.opponent_actions[r]
            total_coop = int(my_coop) + np.sum(opponents_coop)
            if total_coop >= self.m:
                recent_successes += 1
        total_rounds = state.round_number - start_round
        p = recent_successes / total_rounds if total_rounds > 0 else 0.0
        if p > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_135(BaseStrategy):
    """
    Cooperative Punishment with Sustained Cooperation strategy.

    Players cooperate in the first round. In subsequent rounds, they cooperate if 
    the number of cooperators in the previous round was at least half the number 
    of players; otherwise, they defect. This encourages sustained cooperation 
    through collective punishment when participation drops below the threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_coop = history.my_actions[previous_round]
        opponents_prev_actions = history.opponent_actions[previous_round, :]
        total_coops = my_prev_coop + sum(opponents_prev_actions)
        if total_coops >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_136(BaseStrategy):
    """
    Adaptive Cooperation Based on Recent History Strategy.
    Cooperates initially, then cooperates if more than half of the last 3 rounds had enough cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2 + 1
        self.s = 3

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        history_len = state.round_number
        window_size = min(self.s, history_len)
        start_round = max(0, state.round_number - window_size)
        cooperative_rounds = 0
        for r in range(start_round, state.round_number):
            my_action = history.my_actions[r]
            opp_coop = history.opponent_actions[r].sum()
            total_coop = my_action + opp_coop
            if total_coop >= self.m:
                cooperative_rounds += 1
        if cooperative_rounds > window_size / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_137(BaseStrategy):
    """
    Reactive Cooperation with Punishment strategy.
    Cooperates in the first round. Continues cooperating if at least `m` players cooperated in the previous round; 
    otherwise defects. The threshold `m` is determined as the integer part of the game's `k` value.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(game_description.k)
        if self.m < 1:
            self.m = 1
        elif self.m >= game_description.n_players:
            self.m = game_description.n_players - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponents_prev = history.opponent_actions[prev_round, :]
        sum_my = my_prev.astype(int)
        sum_opponents = np.sum(opponents_prev)
        total_coop_prev = sum_my + sum_opponents
        if total_coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_138(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness strategy to maximize collective payoff.
    Cooperates initially and adapts based on group behavior with a forgiveness mechanism.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n_players // 2
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.consecutive_defects >= 1:
            self.consecutive_defects = 0
            return Action.C
        prev_round = state.round_number - 1
        opponents_coop = history.opponent_actions[prev_round]
        sum_opponents_coop = sum(opponents_coop)
        my_prev_action = history.my_actions[prev_round]
        total_coop = sum_opponents_coop + (1 if my_prev_action else 0)
        if total_coop >= self.m:
            return Action.C
        else:
            self.consecutive_defects += 1
            return Action.D

class Strategy_COLLECTIVE_139(BaseStrategy):
    """
    Implements a strategy that promotes sustained cooperation in a public goods game through initial cooperation, responsive punishment, and forgiveness.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n_players // 2
        self.must_cooperate_next = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            if self.must_cooperate_next:
                action = Action.C
                self.must_cooperate_next = False
            else:
                last_round = state.round_number - 1
                my_prev_action = history.my_actions[last_round]
                opponent_actions_last = history.opponent_actions[last_round, :]
                coops = sum(opponent_actions_last) + (1 if my_prev_action else 0)
                if coops < self.m:
                    action = Action.D
                    self.must_cooperate_next = True
                else:
                    action = Action.C
            return action

class Strategy_COLLECTIVE_140(BaseStrategy):
    """
    Grim Trigger Strategy: Cooperate as long as all previous rounds had all players cooperating.
    If any round had fewer cooperators, defect permanently.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        m = self.n_players
        for round in range(state.round_number):
            my_action = history.my_actions[round]
            opponents_actions = history.opponent_actions[round]
            total_coop = my_action + opponents_actions.sum()
            if total_coop < m:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_141(BaseStrategy):
    """
    A strategy that cooperates initially, then adapts based on previous cooperation levels,
    with forgiveness to prevent perpetual defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.defect_rounds = 1
        self.forgiveness_p = 0.1
        self.defect_left = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round, :]
        total_coop_prev = my_prev_action + sum(opp_prev_actions)
        if self.defect_left == 0:
            if total_coop_prev >= self.m:
                return Action.C
            else:
                self.defect_left = self.defect_rounds
                if random.random() < self.forgiveness_p:
                    return Action.C
                else:
                    return Action.D
        else:
            self.defect_left -= 1
            if random.random() < self.forgiveness_p:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_142(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy. Cooperates initially, punishes
    once if cooperation is insufficient, then forgives. In the last round,
    cooperates if cooperation was sufficient in at least half the rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.punish_window = 2

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if history is None:
                return Action.C
            prev_rounds_count = len(history.my_actions)
            if prev_rounds_count == 0:
                return Action.C
            count = 0
            for i in range(prev_rounds_count):
                own_c = history.my_actions[i]
                opp_c = sum(history.opponent_actions[i, :])
                total_c = int(own_c) + opp_c
                if total_c >= self.m:
                    count += 1
            proportion = count / prev_rounds_count
            if proportion >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            if history is None or len(history.my_actions) == 0:
                return Action.C
            prev_own_c = history.my_actions[-1]
            prev_opp_c = sum(history.opponent_actions[-1, :])
            prev_total_c = int(prev_own_c) + prev_opp_c
            if prev_total_c >= self.m:
                return Action.C
            else:
                start_idx = max(0, len(history.my_actions) - self.punish_window)
                recent_actions = history.my_actions[start_idx:]
                punished_recently = any((a is False for a in recent_actions))
                if punished_recently:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_143(BaseStrategy):
    """
    Responsive Cooperation with Reset Mechanism strategy.

    Cooperates initially and continues if enough players cooperated in the previous round.
    Defects otherwise, but resets to cooperation after one defecting round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.s = 1
        self.consec_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consec_defections = 0
            return Action.C
        prev_round = state.round_number - 1
        opponent_prev = history.opponent_actions[prev_round, :]
        my_prev = history.my_actions[prev_round]
        prev_cooperations = np.sum(opponent_prev) + (1 if my_prev else 0)
        if prev_cooperations >= self.m:
            self.consec_defections = 0
            return Action.C
        else:
            self.consec_defections += 1
            if self.consec_defections >= self.s:
                self.consec_defections = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_144(BaseStrategy):
    """
    A strategy for the N-player public goods game based on adaptive cooperation with a threshold. 
    It encourages cooperation if the number of cooperators in the previous round meets or exceeds a calculated threshold, 
    except for the last round where it always cooperates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            total_coop_prev = my_prev_action + np.sum(opponents_prev_actions)
            return Action.C if total_coop_prev >= self.m else Action.D

class Strategy_COLLECTIVE_145(BaseStrategy):
    """
    Adaptive Cooperation with Resilience (ACR) strategy promotes sustained cooperation
    while being resilient to temporary defections. Players cooperate if the previous
    round's cooperation meets a threshold; otherwise, they defect for up to two rounds,
    then attempt cooperation again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round]
        prev_c = my_prev_action + np.sum(opponent_prev_actions)
        if prev_c >= self.m:
            self.consecutive_defects = 0
            return Action.C
        elif self.consecutive_defects < 2:
            self.consecutive_defects += 1
            return Action.D
        else:
            self.consecutive_defects = 0
            return Action.C

class Strategy_COLLECTIVE_146(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that promotes cooperation while being robust against temporary failures.
    It starts with cooperation and then adapts based on previous actions and the number of cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_act = history.my_actions[-1]
        if not prev_act:
            return Action.C
        sum_opponent_C = np.sum(history.opponent_actions[-1])
        S = sum_opponent_C + (1 if prev_act else 0)
        if S >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_147(BaseStrategy):
    """
    A strategy that promotes cooperation while deterring exploitation by punishing 
    low levels of cooperation and attempting to reset cooperation afterward.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k
        self.last_action = Action.C

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            return Action.C
        if self.last_action == Action.D:
            self.last_action = Action.C
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        all_coop_prev = sum([my_prev]) + sum(history.opponent_actions[prev_round, :])
        if all_coop_prev >= self.m:
            self.last_action = Action.C
            return Action.C
        else:
            self.last_action = Action.D
            return Action.D

class Strategy_COLLECTIVE_148(BaseStrategy):
    """
    Implements an Adaptive Cooperation with Restart Mechanism strategy.
    Cooperates initially, then continues if enough players cooperated previously.
    Defects if insufficient, but restarts cooperation after two defect rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.s = 2
        self.consecutive_insufficient = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_action = history.my_actions[t_prev]
        opponent_actions = history.opponent_actions[t_prev]
        c_prev = sum(opponent_actions) + (1 if my_action else 0)
        if c_prev >= self.m:
            self.consecutive_insufficient = 0
            return Action.C
        else:
            self.consecutive_insufficient += 1
            if self.consecutive_insufficient >= self.s:
                self.consecutive_insufficient = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_149(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on the number of previous cooperators.
    It includes a forgiveness mechanism to reset cooperation after temporary defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        prev_coop = 0
        if history is not None:
            prev_coop = sum(history.opponent_actions[last_round, :])
            prev_coop += history.my_actions[last_round]
        if prev_coop >= self.m:
            return Action.C
        else:
            if history.my_actions[last_round] == 0:
                if last_round > 0:
                    prev_prev_round = last_round - 1
                    prev_prev_coop = sum(history.opponent_actions[prev_prev_round, :])
                    prev_prev_coop += history.my_actions[prev_prev_round]
                    if prev_prev_coop >= self.m:
                        return Action.C
            return Action.D

class Strategy_COLLECTIVE_150(BaseStrategy):
    """
    A strategy to promote cooperation in N-Player Public Goods Game by adapting based on previous outcomes.
    Players start by cooperating and then adjust their actions based on whether the previous round met a cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponent_last_actions = history.opponent_actions[last_round]
        S = my_last_action + np.sum(opponent_last_actions)
        n = self.game_description.n_players
        k = self.game_description.k
        threshold = n / k
        if S >= threshold:
            return Action.C
        else:
            return Action.D if my_last_action else Action.C

class Strategy_COLLECTIVE_151(BaseStrategy):
    """
    A Win-Stay, Lose-Switch inspired strategy to sustain cooperation in public goods games.
    Cooperates initially and continues if the number of cooperators meets a threshold.
    Otherwise, switches action based on the previous round's outcome.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_last_action = history.my_actions[-1]
        my_c = my_last_action.astype(int)
        opponent_c = history.opponent_actions[-1].sum()
        total_c = my_c + opponent_c
        if total_c >= self.m:
            current_action = my_last_action
        else:
            current_action = not my_last_action
        return Action.C if current_action else Action.D

class Strategy_COLLECTIVE_152(BaseStrategy):
    """Conditional Cooperation with Recovery Strategy
    
    Cooperates initially and continues if enough players cooperated in the previous round.
    Defects if too few cooperated but resumes cooperation after a set number of defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.s = 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_past_action = history.my_actions[previous_round]
        opponent_actions = history.opponent_actions[previous_round, :]
        total_c = my_past_action + sum(opponent_actions)
        if total_c >= self.m:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections >= self.s:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            return Action.D

class Strategy_COLLECTIVE_153(BaseStrategy):
    """
    A strategy that adapts cooperation based on previous rounds' cooperation levels.
    It uses the game's k parameter to determine the minimum number of required cooperators.
    Cooperates in the first round, then continues if the previous round had enough cooperators,
    and in the last round, it cooperates if the majority of previous rounds met the threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        n_rounds = self.game_description.n_rounds
        if t == 0:
            return Action.C
        if t == n_rounds - 1:
            total_met = 0
            for i in range(t):
                my_action = history.my_actions[i]
                opp_actions = history.opponent_actions[i]
                count = sum(opp_actions) + (1 if my_action else 0)
                if count >= self.m:
                    total_met += 1
            majority = t / 2
            if total_met > majority:
                return Action.C
            else:
                return Action.D
        else:
            t_prev = t - 1
            my_prev = history.my_actions[t_prev]
            opp_prev = history.opponent_actions[t_prev]
            count_prev = sum(opp_prev) + (1 if my_prev else 0)
            if count_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_155(BaseStrategy):
    """
    Adaptive Cooperating with Forgiveness Strategy.
    Cooperates initially and responds to group cooperation levels.
    Defects for up to two rounds when cooperation is below threshold.
    Resets cooperation after two defections to allow group recovery.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.defect_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        own_prev_action = history.my_actions[prev_round]
        sum_opponent_prev = np.sum(history.opponent_actions[prev_round, :])
        total_coop_prev = int(own_prev_action) + sum_opponent_prev
        if total_coop_prev >= self.m:
            self.defect_streak = 0
            return Action.C
        elif self.defect_streak < 2:
            self.defect_streak += 1
            return Action.D
        else:
            self.defect_streak = 0
            return Action.C

class Strategy_COLLECTIVE_156(BaseStrategy):
    """
    A strategy that begins with cooperation and adapts based on previous rounds' cooperation levels.
    Players cooperate if the number of cooperators in the previous round meets a threshold (half of players).
    Otherwise, they defect with a 50% probability, testing for potential future cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_actions = history.opponent_actions[state.round_number - 1]
        coop_count = np.sum(prev_actions)
        if coop_count >= self.m:
            return Action.C
        else:
            return Action.D if random.random() < 0.5 else Action.C

class Strategy_COLLECTIVE_157(BaseStrategy):
    """
    Adaptive Cooperate-Punish-Forgive Strategy.

    This strategy encourages cooperation by punishing insufficient cooperation for one round 
    but forgives after two consecutive rounds of insufficient cooperation to help re-establish 
    cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k) if self.k != 0 else 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        opp_actions_last = history.opponent_actions[last_round, :]
        opp_sum_last = np.sum(opp_actions_last)
        my_last = history.my_actions[last_round]
        last_coop = opp_sum_last + (1 if my_last else 0)
        consecutive_defections = 0
        if last_round >= 1:
            prev_last_round = last_round - 1
            opp_actions_prev_last = history.opponent_actions[prev_last_round, :]
            opp_sum_prev_last = np.sum(opp_actions_prev_last)
            my_prev_last = history.my_actions[prev_last_round]
            prev_coop = opp_sum_prev_last + (1 if my_prev_last else 0)
            if last_coop < self.m and prev_coop < self.m:
                consecutive_defections = 2
        if last_coop >= self.m or consecutive_defections >= 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_160(BaseStrategy):
    """
    A strategy that initially cooperates and then adapts based on the number of previous cooperators.
    Cooperates if at least half of the players (rounded down) cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opp_prev = history.opponent_actions[prev_round]
        total_coop = my_prev + opp_prev.sum()
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_161(BaseStrategy):
    """
    A strategy that starts by cooperating and adjusts based on recent outcomes,
    encouraging cooperation while being resilient to defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.max_consecutive_defects = 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_last = state.round_number - 1
        c_last = history.my_actions[t_last] + sum(history.opponent_actions[t_last])
        if c_last >= self.m:
            return Action.C
        else:
            defect_count = 0
            for t in range(t_last - 1, -1, -1):
                c_t = history.my_actions[t] + sum(history.opponent_actions[t])
                if c_t < self.m:
                    defect_count += 1
                else:
                    break
                if defect_count >= self.max_consecutive_defects:
                    break
            if defect_count >= self.max_consecutive_defects + 1:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_162(BaseStrategy):
    """
    This strategy balances incentives for cooperation with protection against exploitation.
    It uses an initial cooperation phase, responsive punishment for low cooperation,
    exploration with random cooperation, and adapts behavior based on recent outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.initial_phase_length = self.n_rounds // 10
        self.final_phase_start = self.n_rounds - self.n_rounds // 10
        self.m = self.n_players // 2
        self.recent_rounds = []

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.C
        if state.round_number < self.initial_phase_length:
            return Action.C
        if state.round_number >= self.final_phase_start:
            count = 0
            history_len = len(history.my_actions)
            m = self.m
            for prev_round in range(history_len):
                opp_coop = sum(history.opponent_actions[prev_round, :])
                my_action = history.my_actions[prev_round]
                total_coop = opp_coop + (1 if my_action else 0)
                if total_coop >= m:
                    count += 1
            proportion = count / history_len if history_len > 0 else 0
            return Action.C if proportion >= 0.5 else Action.D
        elif random.random() < 0.1:
            return Action.C
        else:
            prev_round = state.round_number - 1
            opp_coop = sum(history.opponent_actions[prev_round, :])
            my_prev_action = history.my_actions[prev_round]
            prev_total = opp_coop + (1 if my_prev_action else 0)
            if prev_total < self.m:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_163(BaseStrategy):
    """
    An adaptive strategy promoting collective cooperation by initiating with cooperation 
    and adjusting based on the number of previous cooperators. The strategy uses a threshold 
    calculated as the ceiling of the number of players divided by the multiplication factor.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_c = history.my_actions[prev_round]
        opponents_prev_c = history.opponent_actions[prev_round].sum()
        total_c = my_prev_c + opponents_prev_c
        if total_c >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_164(BaseStrategy):
    """
    A strategy for the N-player public goods game that starts with cooperation
    and adapts based on the proportion of successful historical rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        threshold = 0.5
        m = threshold * n_players
        s = 0
        for round_idx in range(state.round_number):
            my_coop = int(history.my_actions[round_idx])
            opp_coop = history.opponent_actions[round_idx].sum()
            total_coop = my_coop + opp_coop
            if total_coop >= m:
                s += 1
        proportion = s / state.round_number
        if proportion >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_165(BaseStrategy):
    """
    Adaptive Cooperative Restart (ACR) Strategy.

    This strategy begins by always cooperating in the first round. In subsequent rounds,
    it checks the number of cooperators from the previous round. If this number meets or
    exceeds a threshold (m), the strategy continues to cooperate. If not, it defects
    while tracking consecutive failures. After two consecutive failures, it restarts
    cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = max(1, self.game_description.n_players // 2)
        self.failure_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_coop = 0
        if prev_my_action:
            prev_coop += 1
        prev_coop_opponents = np.sum(history.opponent_actions[-1, :])
        prev_coop += prev_coop_opponents
        if prev_coop >= self.m:
            self.failure_counter = 0
            return Action.C
        else:
            self.failure_counter += 1
            if self.failure_counter >= 2:
                self.failure_counter = 0
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_166(BaseStrategy):
    """Adaptive strategy based on past cooperation levels with forgiveness."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.defected_last = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            my_action_prev = history.my_actions[prev_round]
            total_coop = sum(opponent_actions_prev) + (1 if my_action_prev else 0)
            if self.defected_last:
                if total_coop >= self.m:
                    self.defected_last = False
                    return Action.C
                else:
                    return Action.D
            elif total_coop >= self.m:
                return Action.C
            else:
                self.defected_last = True
                return Action.D

class Strategy_COLLECTIVE_167(BaseStrategy):
    """
    Adaptive Cooperation with Defection Reset (ACDR) strategy. 
    Cooperates initially and adapts based on previous cooperation rates, resetting to cooperation after three consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.cooperate = True
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_coop = history.my_actions[previous_round]
        opponents_coop = history.opponent_actions[previous_round].sum()
        sum_coops = my_coop + opponents_coop
        if sum_coops >= self.m and self.cooperate:
            self.consecutive_defects = 0
            return Action.C
        else:
            if self.cooperate:
                self.cooperate = False
                self.consecutive_defects = 1
            else:
                self.consecutive_defects += 1
                if self.consecutive_defects >= 3:
                    self.cooperate = True
                    self.consecutive_defects = 0
            return Action.D

class Strategy_COLLECTIVE_168(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that conditions cooperation 
    based on the number of cooperators in the previous round. The threshold 
    for cooperation (m) is set as half the number of players. The strategy 
    always cooperates in the first round and defects in the last round. 
    Cooperation in other rounds depends on whether the previous round met the 
    threshold of cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: 'PlayerHistory | None') -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round]
            sum_my = 1 if my_prev_action else 0
            sum_opp = np.sum(opp_prev_actions)
            sum_coop_prev = sum_my + sum_opp
            return Action.C if sum_coop_prev >= self.m else Action.D

class Strategy_COLLECTIVE_169(BaseStrategy):
    """
    Cooperate initially; continue cooperating if previous round met quota, else defect until restarting cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.threshold = math.ceil(self.k)
        self.max_defect_rounds = 2
        self.cooperating = True
        self.defect_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        op_prev = history.opponent_actions[prev_round]
        prev_c_total = sum(op_prev) + (1 if my_prev else 0)
        if prev_c_total >= self.threshold:
            self.cooperating = True
            self.defect_count = 0
            return Action.C
        else:
            self.defect_count += 1
            if self.defect_count >= self.max_defect_rounds:
                self.cooperating = True
                self.defect_count = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_171(BaseStrategy):
    """
    A strategy that begins by cooperating and adapts behavior based on the number of cooperators in the previous round.
    Cooperates if at least m players cooperated previously, where m is the minimal majority threshold (n_players +1)//2.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = (self.game_description.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_previous_action = history.my_actions[last_round]
        opponents_previous_actions = history.opponent_actions[last_round]
        sum_my_contribution = 1 if my_previous_action else 0
        sum_opponents_contribution = np.sum(opponents_previous_actions)
        total_cooperation = sum_my_contribution + sum_opponents_contribution
        if total_cooperation >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_172(BaseStrategy):
    """
    Adaptive Cooperation Strategy with recovery mechanism.
    Cooperates in the first round and adapts based on the number of cooperators in the previous round.
    Uses a threshold (m) and probability (p) to decide cooperation in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.p = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_opponent_actions = history.opponent_actions[-1, :]
        prev_coops = int(prev_my_action) + sum(prev_opponent_actions)
        if prev_coops >= self.m:
            return Action.C
        elif random.random() < self.p:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_173(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages cooperation by punishing insufficient cooperation.
    - Starts by cooperating in the first round.
    - Cooperates in subsequent rounds if enough players cooperated in the previous round.
    - Defects if insufficient cooperation is observed, then re-evaluates in future rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.prev_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_action = Action.C
            return Action.C
        if history is None:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponent_actions_prev = history.opponent_actions[-1, :]
        if my_prev_action:
            c_prev = 1 + sum(opponent_actions_prev)
        else:
            c_prev = sum(opponent_actions_prev)
        if my_prev_action:
            if c_prev >= self.m:
                self.prev_action = Action.C
                return Action.C
            else:
                self.prev_action = Action.D
                return Action.D
        else:
            c_without_me = sum(opponent_actions_prev)
            if c_without_me >= self.m:
                self.prev_action = Action.C
                return Action.C
            else:
                self.prev_action = Action.D
                return Action.D

class Strategy_COLLECTIVE_174(BaseStrategy):
    """
    An adaptive strategy to maintain cooperation in a Public Goods Game by 
    rewarding sustained cooperation and attempting to re-establish it after 
    temporary defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.s = 2
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponents_prev_actions = history.opponent_actions[previous_round, :]
        total_coop = my_prev_action + sum(opponents_prev_actions)
        if total_coop >= self.m:
            self.consecutive_defects = 0
            return Action.C
        elif self.consecutive_defects < self.s:
            self.consecutive_defects += 1
            return Action.D
        else:
            self.consecutive_defects = 0
            return Action.C

class Strategy_COLLECTIVE_175(BaseStrategy):
    """Adaptive Collective Cooperation strategy.
    
    - First round: Always cooperate.
    - Subsequent rounds: Cooperate if at least half (rounded down) of the players cooperated in the previous round; otherwise, defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.threshold = self.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        opponent_C = np.sum(opponent_actions_prev)
        my_prev_action = history.my_actions[prev_round]
        total_C = opponent_C + (1 if my_prev_action else 0)
        if total_C >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_176(BaseStrategy):
    """A threshold-based strategy for the N-Player Public Goods Game.
    
    The strategy starts with Cooperation and continues to Cooperate if at least a threshold number of players
    Cooperated in the previous round, determined by the game parameters. If insufficient players Cooperated,
    the strategy defects to prompt potential reevaluation by others.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n_players = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n_players / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_act = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round]
        sum_prev = my_prev_act + np.sum(opponent_actions_prev)
        if sum_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_177(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that combines initial cooperation 
    with temporary defection phases in response to insufficient cooperation levels.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m_threshold = game_description.n_players - 1
        self.x = 2
        self.defect_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif self.defect_counter > 0:
            if self.defect_counter < self.x:
                self.defect_counter += 1
                return Action.D
            else:
                self.defect_counter = 0
                return Action.C
        else:
            prev_round = state.round_number - 1
            my_action_prev = history.my_actions[prev_round]
            opp_actions_prev = history.opponent_actions[prev_round, :]
            sum_opp_prev = np.sum(opp_actions_prev)
            total_coop_prev = my_action_prev + sum_opp_prev
            if total_coop_prev >= self.m_threshold:
                return Action.C
            else:
                self.defect_counter = 1
                return Action.D

class Strategy_COLLECTIVE_178(BaseStrategy):
    """
    Adaptive Collective Cooperation Strategy.

    This strategy starts with cooperating in the first round.
    For subsequent rounds, it checks the number of times the cooperation threshold was met in the last three rounds.
    It cooperates if at least two of the last three rounds met the threshold, otherwise it defects.
    For rounds before three have been completed, it uses the majority of previous outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        m = self.m
        threshold_met = []
        for prev_round in range(state.round_number):
            my_action = history.my_actions[prev_round]
            opponent_actions_round = history.opponent_actions[prev_round]
            sum_coop = int(my_action) + int(np.sum(opponent_actions_round))
            met = 1 if sum_coop >= m else 0
            threshold_met.append(met)
        len_met = len(threshold_met)
        if len_met < 3:
            required = len_met // 2 + 1
            sum_met = sum(threshold_met)
            if sum_met >= required:
                return Action.C
            else:
                return Action.D
        else:
            recent = threshold_met[-3:]
            sum_recent = sum(recent)
            if sum_recent >= 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_179(BaseStrategy):
    """
    A strategy to encourage sustained cooperation in an N-player public goods game.
    The strategy involves initial cooperation, punishment for insufficient cooperation,
    and recovery by re-cooperating after a punishment phase.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)
        self.last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            return Action.C
        if self.last_action == Action.D:
            self.last_action = Action.C
            return Action.C
        prev_round = state.round_number - 1
        sum_my = 1 if history.my_actions[prev_round] else 0
        sum_opponents = np.sum(history.opponent_actions[prev_round, :])
        total_coop = sum_my + sum_opponents
        if total_coop >= self.m:
            self.last_action = Action.C
            return Action.C
        else:
            self.last_action = Action.D
            return Action.D

class Strategy_COLLECTIVE_180(BaseStrategy):
    """
    This strategy addresses the Collective Risk Dilemma by balancing cooperation with strategic punishment.
    It starts with cooperation, punishes defection, and forgives to revert cooperation.
    The threshold for cooperation is based on the multiplication factor k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        super().__init__(game_description)
        self.game_description = game_description
        self.m = math.ceil(game_description.k)
        self.next_must_cooperate = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.next_must_cooperate:
            self.next_must_cooperate = False
            return Action.C
        last_round = state.round_number - 1
        me_coop = 1 if history.my_actions[last_round] else 0
        opponent_coop = sum(history.opponent_actions[last_round, :])
        total_coop = me_coop + opponent_coop
        if total_coop >= self.m:
            return Action.C
        else:
            self.next_must_cooperate = True
            return Action.D

class Strategy_COLLECTIVE_181(BaseStrategy):
    """
    Responsive Cooperation with Forgiveness Strategy.

    This strategy starts by cooperating, then continues to cooperate as long 
    as the number of cooperators in the previous round meets a threshold. 
    If not, it defects but will forgive after a set number of defections to 
    attempt cooperation again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.x = 3
        self.defection_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponents = history.opponent_actions[prev_round]
        sum_prev_o = sum(prev_opponents)
        total_prev_c = sum_prev_o + (1 if prev_my_action else 0)
        if total_prev_c >= self.m:
            return Action.C
        else:
            self.defection_streak += 1
            if self.defection_streak >= self.x:
                self.defection_streak = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_182(BaseStrategy):
    """
    Adaptive Collective Cooperation strategy.

    This strategy aims to balance cooperation with adaptive adjustments based on past outcomes.
    It cooperates initially, punishes non-cooperation, and rejoins cooperation if beneficial.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m_threshold = math.ceil(0.6 * self.n_players)
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.game_description.n_rounds - 1:
            if history is None:
                return Action.D
            total_rounds = len(history.my_actions)
            if total_rounds == 0:
                return Action.C
            num_success = 0
            for r in range(total_rounds):
                opp_C = sum(history.opponent_actions[r, :])
                my_C = history.my_actions[r]
                total_C = opp_C + my_C
                if total_C >= self.m_threshold:
                    num_success += 1
            if num_success > total_rounds // 2:
                return Action.C
            else:
                return Action.D
        else:
            if history is None:
                return Action.D
            prev_rounds = current_round
            if prev_rounds == 0:
                return Action.C
            num_success = 0
            for r in range(prev_rounds):
                opp_C = sum(history.opponent_actions[r, :])
                my_C = history.my_actions[r]
                total_C = opp_C + my_C
                if total_C >= self.m_threshold:
                    num_success += 1
            ratio = num_success / prev_rounds
            if ratio >= 0.6:
                self.consecutive_defects = 0
                return Action.C
            else:
                self.consecutive_defects += 1
                if self.consecutive_defects >= 2:
                    success_in_last_two = 0
                    for r in [current_round - 1, current_round - 2]:
                        if r >= 0:
                            opp_C_last = sum(history.opponent_actions[r, :])
                            my_C_last = history.my_actions[r]
                            total_C_last = opp_C_last + my_C_last
                            if total_C_last >= self.m_threshold:
                                success_in_last_two += 1
                    if success_in_last_two > 0:
                        self.consecutive_defects = 0
                        return Action.C
                return Action.D

class Strategy_COLLECTIVE_183(BaseStrategy):
    """
    Cooperative Punishment with Forgiveness (CPwF) Strategy.

    This strategy starts by cooperating in the first round, defects in the last round,
    and adaptively responds to the level of cooperation in previous rounds by other players.
    It defects if the number of cooperators in the previous round is below a threshold (m),
    then reverts to cooperation unless it is the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.prev_action = None
        self.must_cooperate_next = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.prev_action = action
            self.must_cooperate_next = False
            return action
        elif state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
            self.prev_action = action
            self.must_cooperate_next = False
            return action
        else:
            if self.must_cooperate_next:
                action = Action.C
                self.must_cooperate_next = False
            else:
                prev_round = state.round_number - 1
                cooperators = 0
                if history is not None and prev_round >= 0:
                    if prev_round < len(history.my_actions) and history.my_actions[prev_round]:
                        cooperators += 1
                    if prev_round < len(history.opponent_actions) and history.opponent_actions.shape[0] > prev_round:
                        others_coop = np.sum(history.opponent_actions[prev_round, :])
                        cooperators += others_coop
                if cooperators >= self.m:
                    action = Action.C
                else:
                    action = Action.D
                    self.must_cooperate_next = True
            self.prev_action = action
            return action

class Strategy_COLLECTIVE_184(BaseStrategy):
    """
    Adaptive Cooperation with Punishment Strategy.

    The strategy starts by cooperating, then adapts based on the number of cooperators in previous rounds.
    It punishes non-cooperation by defecting for a set number of rounds and adjusts near the endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.punishment_length = 3
        self.punishment_remaining = 0
        self.endgame_rounds = 5
        start_endgame = max(0, self.n_rounds - self.endgame_rounds)
        self.start_endgame = start_endgame

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.start_endgame:
            count_prev = 0
            for r in range(0, state.round_number):
                sum_cj = int(history.my_actions[r])
                sum_cj += int(sum(history.opponent_actions[r]))
                if sum_cj >= self.m:
                    count_prev += 1
            n_prev = state.round_number
            if count_prev * 2 > n_prev:
                return Action.C
            else:
                return Action.D
        elif self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        else:
            count_prev = 0
            for r in range(0, state.round_number):
                sum_cj = int(history.my_actions[r])
                sum_cj += int(sum(history.opponent_actions[r]))
                if sum_cj >= self.m:
                    count_prev += 1
            n_prev = state.round_number
            if count_prev * 2 > n_prev:
                return Action.C
            else:
                self.punishment_remaining = self.punishment_length
                return Action.D

class Strategy_COLLECTIVE_185(BaseStrategy):
    """
    A strategy that begins with cooperation and punishes non-cooperation once before returning to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round] if history else False
        if not my_prev_action:
            return Action.C
        n = self.game_description.n_players
        k = self.game_description.k
        opponents_actions = history.opponent_actions[prev_round]
        opponent_coop = np.sum(opponents_actions)
        my_coop = history.my_actions[prev_round]
        total_coop = opponent_coop + my_coop
        bonus = k / n * total_coop
        if bonus >= 1.0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_186(BaseStrategy):
    """
    A strategy that promotes cooperation in public goods games by initially cooperating, 
    continuing cooperation if the threshold is met, defecting if not, and resetting 
    cooperation after a punishment round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m_threshold = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_action_prev = history.my_actions[prev_round]
        opp_actions_prev = history.opponent_actions[prev_round, :]
        cooperators_prev = sum(opp_actions_prev) + (1 if my_action_prev else 0)
        if cooperators_prev == 0:
            return Action.C
        if cooperators_prev >= self.m_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_187(BaseStrategy):
    """
    A strategy that maintains cooperation as much as possible while allowing recovery
    from temporary drops in cooperation levels. It uses a threshold based on the game's
    multiplication factor to decide actions in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k
        self.force_cooperate_next_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        total_c_prev = my_prev_action + np.count_nonzero(opponents_prev_actions)
        if self.force_cooperate_next_round:
            self.force_cooperate_next_round = False
            return Action.C
        elif total_c_prev >= self.m:
            return Action.C
        else:
            self.force_cooperate_next_round = True
            return Action.D

class Strategy_COLLECTIVE_188(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that starts with cooperation 
    and adapts based on the average level of cooperation in previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.D
        t = state.round_number
        my_coop = sum(history.my_actions)
        opponent_coop = history.opponent_actions.sum(axis=1).sum()
        total_coop = my_coop + opponent_coop
        average_coop = total_coop / (self.n_players * t)
        threshold = self.k / self.n_players
        if average_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_189(BaseStrategy):
    """
    A strategy that cooperates in the first round and then mirrors the group's previous cooperation level.
    Cooperates again if at least the majority of players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round, :]
        sum_opponents = np.sum(opponent_actions_prev)
        own_prev = history.my_actions[previous_round]
        total_prev = sum_opponents + own_prev
        m = (self.game_description.n_players + 1) // 2
        if total_prev >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_190(BaseStrategy):
    """
    A strategy where players cooperate unless the number of cooperators in the previous round falls below a threshold,
    in which case they defect for one round before reverting to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punished_last_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.punished_last_round = False
            return Action.C
        if self.punished_last_round:
            self.punished_last_round = False
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        num_coop_prev = sum(opponents_prev_actions) + (1 if my_prev_action else 0)
        m = self.game_description.n_players // 2
        if num_coop_prev < m:
            self.punished_last_round = True
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_191(BaseStrategy):
    """
    A strategy promoting cooperation in the N-Player Public Goods Game through persistent cooperation and adaptive responses.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self._previous_action = None
        self._consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self._previous_action = Action.C
            self._consecutive_defections = 0
            return Action.C
        else:
            prev_action = history.my_actions[-1]
            prev_payoff = history.my_payoffs[-1]
            if prev_action == Action.D and prev_payoff < self.game_description.k:
                self._consecutive_defections += 1
            else:
                self._consecutive_defections = 0
            if prev_action == Action.C:
                if prev_payoff >= self.game_description.k:
                    next_action = Action.C
                else:
                    next_action = Action.D
            elif prev_payoff >= self.game_description.k:
                next_action = Action.D
            elif self._consecutive_defections >= 1:
                next_action = Action.C
            else:
                next_action = Action.D
            self._previous_action = next_action
            return next_action

class Strategy_COLLECTIVE_192(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) strategy for N-Player Public Goods Game.
    Cooperates initially, then continues if sufficient players cooperated last round,
    with a forgiveness mechanism to recover from mutual defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            return Action.C
        prev_round = state.round_number - 1
        my_last_action = history.my_actions[prev_round]
        opp_last_actions = history.opponent_actions[prev_round]
        count_coop = my_last_action + np.sum(opp_last_actions)
        if my_last_action == Action.D:
            self.last_action = Action.C
            return Action.C
        elif count_coop >= self.m:
            self.last_action = Action.C
            return Action.C
        else:
            self.last_action = Action.D
            return Action.D

class Strategy_COLLECTIVE_194(BaseStrategy):
    """
    Adaptive cooperation strategy with punishment and re-entry.
    Cooperates initially, continues if previous round met threshold,
    defects if not, and re-enters based on average cooperation over last few rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.t = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            count_met = 0
            for r in range(state.round_number):
                my_action = history.my_actions[r]
                opp_actions = history.opponent_actions[r, :]
                cooperators = (1 if my_action else 0) + opp_actions.sum()
                if cooperators >= self.m:
                    count_met += 1
            total_prev = state.round_number
            if count_met > total_prev / 2:
                return Action.C
            else:
                return Action.D
        else:
            previous_round = state.round_number - 1
            my_prev_action = history.my_actions[previous_round]
            opp_prev_actions = history.opponent_actions[previous_round, :]
            s_prev = (1 if my_prev_action else 0) + opp_prev_actions.sum()
            if s_prev >= self.m:
                return Action.C
            elif not my_prev_action:
                start = max(0, state.round_number - self.t)
                total = 0
                for r in range(start, previous_round + 1):
                    my_r = history.my_actions[r]
                    opp_r = history.opponent_actions[r, :]
                    s_r = (1 if my_r else 0) + opp_r.sum()
                    total += s_r
                num_rounds = previous_round + 1 - start
                average = total / num_rounds if num_rounds > 0 else 0
                if average >= self.m:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_COLLECTIVE_195(BaseStrategy):
    """
    This strategy implements Collective Reciprocity. It starts by cooperating,
    then adapts based on the level of cooperation in the previous round. It uses
    a threshold m to decide whether to continue cooperating or defect. If the
    number of cooperators meets or exceeds the threshold, the player cooperates;
    otherwise, they defect. The strategy includes a forgiveness mechanism to
    avoid permanent defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.last_defected = False

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            my_last = history.my_actions[-1]
            opponents_last = history.opponent_actions[-1]
            my_contribution = int(my_last)
            opponents_contributions = np.sum(opponents_last)
            total_cooperators = my_contribution + opponents_contributions
            if total_cooperators >= self.m:
                self.last_defected = False
                return Action.C
            elif self.last_defected:
                self.last_defected = False
                return Action.C
            else:
                self.last_defected = True
                return Action.D

class Strategy_COLLECTIVE_196(BaseStrategy):
    """
    Collective Risk Strategy promotes cooperation by using an initial cooperative stance, 
    punishing lack of cooperation, and ensuring the last round is maximized.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        prev_my_action = history.my_actions[state.round_number - 1]
        opponent_coop = sum(history.opponent_actions[state.round_number - 1])
        total_coop_prev = prev_my_action + opponent_coop
        return Action.C if total_coop_prev >= self.m else Action.D

class Strategy_COLLECTIVE_197(BaseStrategy):
    """
    A reciprocity-based strategy to maintain cooperation in the N-Player Public Goods Game.
    Cooperates if enough players cooperated in the previous round, otherwise defects as punishment,
    then attempts to recover cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.should_cooperate_next_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.should_cooperate_next_round:
            self.should_cooperate_next_round = False
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions = history.opponent_actions[prev_round, :]
        sum_C = my_prev_action + np.sum(opponent_actions)
        if sum_C >= self.m:
            return Action.C
        else:
            self.should_cooperate_next_round = True
            return Action.D

class Strategy_COLLECTIVE_198(BaseStrategy):
    """
    A strategy that Cooperates initially and then Cooperates in subsequent rounds if and only if all players Cooperated in the previous round. Defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        opponent_actions = history.opponent_actions[prev_round]
        opponent_coop = np.sum(opponent_actions)
        player_previous_action = history.my_actions[prev_round]
        player_coop = 1 if player_previous_action else 0
        total_coop = opponent_coop + player_coop
        m = self.game_description.n_players
        if total_coop >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_199(BaseStrategy):
    """
    A strategy that adapts cooperation based on the historical success of rounds.
    Cooperates initially and continues if a sufficient proportion of previous rounds were successful.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        m = n // k + 1
        self.m = int(m)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        count = 0
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            opp_actions = history.opponent_actions[t]
            total_coop = my_action + np.sum(opp_actions)
            if total_coop >= self.m:
                count += 1
        success_rate = count / state.round_number
        if success_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_200(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n_players // 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0 or history is None:
            self.consecutive_defections = 0
            return Action.C
        prev_round = state.round_number - 1
        my_action_prev = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round]
        c_prev = 1 if my_action_prev else 0
        c_prev += int(np.sum(opponent_actions_prev))
        if c_prev >= self.m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections < 2:
                return Action.D
            else:
                self.consecutive_defections = 0
                return Action.C

class Strategy_COLLECTIVE_201(BaseStrategy):
    """
    Cooperate unless previous round had fewer than m cooperators; then defect once before cooperating again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.prev_defected = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_defected = False
            return Action.C
        if self.prev_defected:
            self.prev_defected = False
            return Action.C
        else:
            prev_round = state.round_number - 1
            opponents_prev = history.opponent_actions[prev_round, :]
            sum_opponents_prev = np.sum(opponents_prev)
            my_prev = history.my_actions[prev_round]
            total_prev = sum_opponents_prev + my_prev
            if total_prev >= self.m:
                return Action.C
            else:
                self.prev_defected = True
                return Action.D

class Strategy_COLLECTIVE_202(BaseStrategy):
    """
    Responsive Cooperation with Punishment (RCP) Strategy

    This strategy encourages cooperation while responding to deviations:
    - Cooperate in the first round.
    - Continue to Cooperate if the number of cooperators in the previous round meets or exceeds a threshold.
    - Defect if the number of cooperators is below the threshold, with the possibility to re-establish cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        m = self.game_description.n_players / self.game_description.k
        previous_round = state.round_number - 1
        my_previous_action = history.my_actions[previous_round]
        opponents_previous_actions = history.opponent_actions[previous_round, :]
        count_cooperators = my_previous_action + np.sum(opponents_previous_actions)
        if count_cooperators >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_203(BaseStrategy):
    """
    A strategy that promotes cooperation based on recent history.
    Cooperates initially and continues if recent rounds had sufficient cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.window_size = 3
        self.cooperation_threshold = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            start_t = max(0, state.round_number - self.window_size)
            for t in range(start_t, state.round_number):
                my_action = history.my_actions[t]
                opponent_actions = history.opponent_actions[t, :]
                total_c = int(my_action) + opponent_actions.sum()
                if total_c >= self.cooperation_threshold:
                    return Action.C
            return Action.D

class Strategy_COLLECTIVE_204(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that promotes cooperation based on reciprocal behavior.
    Players Cooperate initially and continue if at least half of the players Cooperated in the previous round.
    Otherwise, players Defect to protect their individual payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game = game_description
        self.threshold = self.game.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_prev_actions = history.opponent_actions[state.round_number - 1, :]
        num_cooperators = np.sum(opponents_prev_actions)
        if num_cooperators >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_205(BaseStrategy):
    """
    A Threshold-based Punishment Strategy for N-Player Public Goods Game.
    Cooperates if the previous round met the cooperation threshold; otherwise, defects once then reverts.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.last_punishment = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.last_punishment:
            self.last_punishment = False
            return Action.C
        t_prev = state.round_number - 1
        my_prev = history.my_actions[t_prev]
        opponents_prev = history.opponent_actions[t_prev, :]
        sum_coop = int(my_prev) + np.sum(opponents_prev)
        if sum_coop >= self.m:
            return Action.C
        else:
            self.last_punishment = True
            return Action.D

class Strategy_COLLECTIVE_206(BaseStrategy):
    """
    A strategy that encourages cooperation in public goods games through conditional cooperation and forgiveness.
    Cooperates if the previous round had enough cooperators; otherwise, defects until reset after a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.x = 3
        self.consecutive_Ds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_prev_action = history.my_actions[last_round]
        opp_prev_actions = history.opponent_actions[last_round]
        S_prev = (1 if my_prev_action else 0) + sum(opp_prev_actions)
        if S_prev >= self.m:
            self.consecutive_Ds = 0
            return Action.C
        else:
            self.consecutive_Ds += 1
            if self.consecutive_Ds < self.x:
                return Action.D
            else:
                self.consecutive_Ds = 0
                return Action.C

class Strategy_COLLECTIVE_207(BaseStrategy):
    """
    A reactive strategy for the N-player Public Goods Game. Players cooperate in the first round and in subsequent rounds 
    based on whether the number of cooperators in the previous round meets a calculated threshold. The threshold is determined 
    by the formula m = (n_players // k) + 1 to encourage cooperation when it benefits the group.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        """
        Initialize the strategy with game parameters.
        - Compute the threshold m based on the number of players and the multiplication factor.
        """
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = int(self.n_players // self.k) + 1

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        """
        Decide whether to Cooperate or Defect in the current round.
        - If it's the first round, always Cooperate.
        - For subsequent rounds, examine the number of cooperators in the previous round.
        - Cooperate if the number meets or exceeds the threshold m; otherwise, Defect.
        """
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_action = history.my_actions[prev_round]
        my_bool = 1 if my_action else 0
        opp_actions = history.opponent_actions[prev_round, :]
        opp_sum = np.sum(opp_actions)
        total_prev = my_bool + opp_sum
        if total_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_209(BaseStrategy):
    """
    An adaptive strategy that starts by cooperating and punishes insufficient cooperation.
    Cooperates if at least half of the players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_my_action = history.my_actions[state.round_number - 1]
        previous_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        total_coop = previous_my_action + sum(previous_opponent_actions)
        if total_coop >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_211(BaseStrategy):
    """
    A deterministic strategy to sustain cooperation in a public goods game. Players cooperate initially and 
    continue if at least half of previous rounds met the cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k_factor = game_description.k
        self.m = math.ceil(self.n_players / self.k_factor)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        s = 0
        for round in range(len(history.opponent_actions)):
            my_action = history.my_actions[round]
            opponents = history.opponent_actions[round]
            total_coop = sum([my_action] + opponents.tolist())
            if total_coop >= self.m:
                s += 1
        if s >= t / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_212(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that balances cooperation and defecting based on the number of cooperators in the previous round.
    Cooperates initially and continues if a threshold of cooperators is met; otherwise, mostly defects with a small chance to cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        prev_my_action = history.my_actions[t - 1]
        opp_coop = history.opponent_actions[t - 1, :].sum()
        sum_prev_coop = int(opp_coop) + (1 if prev_my_action else 0)
        if sum_prev_coop >= self.m:
            return Action.C
        elif random.random() < 0.9:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_213(BaseStrategy):
    """
    Reactive strategy where cooperation occurs if previous round had at least m cooperators.
    Initially cooperates, then continues if sufficient players cooperated in previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opp_prev = history.opponent_actions[prev_round]
        prev_coop = int(my_prev) + int(np.sum(opp_prev))
        if prev_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_218(BaseStrategy):
    """
    A strategy that starts with cooperation and then cooperates if sufficiently many others cooperated in the previous round, 
    otherwise defects to punish. It allows recovery from periods of low cooperation by reassessing after each round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_opponent_coop = sum(history.opponent_actions[-1])
        prev_own_action = 1 if history.my_actions[-1] else 0
        total_prev_coop = prev_opponent_coop + prev_own_action
        if total_prev_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_219(BaseStrategy):
    """
    Responsive Cooperation with Punishment (RCP) strategy.
    Cooperates initially and continues to cooperate if the previous round met the cooperation threshold.
    Defects if the previous round failed to meet the threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = (self.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        sum_opponents = np.sum(opponent_prev_actions)
        my_coop = 1 if my_prev_action else 0
        total_coop_prev = sum_opponents + my_coop
        if total_coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_220(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that promotes sustained cooperation 
    through conditional cooperation and temporary punishment for defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.s = 2
        self.failure_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round, :]
        last_coops = sum([my_prev_action]) + sum(opp_prev_actions)
        if last_coops >= self.m:
            self.failure_counter = 0
            return Action.C
        else:
            self.failure_counter += 1
            if self.failure_counter == self.s:
                self.failure_counter = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_221(BaseStrategy):
    """
    An adaptive strategy for the N-player Public Goods game that ensures maximum payoffs by maintaining a threshold of cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.index = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_last_action = history.my_actions[-1]
        opponent_last_actions = history.opponent_actions[-1]
        sum_coop_prev = int(my_last_action) + int(np.sum(opponent_last_actions))
        if sum_coop_prev >= self.m:
            return Action.C
        elif self.index <= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_222(BaseStrategy):
    """
    A strategy for N-Player Public Goods Game that maintains cooperation with temporary punishment.
    Cooperates initially, then responds to the number of cooperators in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.last_defected = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.last_defected:
            self.last_defected = False
            return Action.C
        t_prev = state.round_number - 1
        if t_prev < 0:
            return Action.C
        if history is None:
            s = 0
        else:
            my_prev = history.my_actions[t_prev]
            opponent_prev = history.opponent_actions[t_prev]
            s = my_prev + sum(opponent_prev)
        if s >= self.m:
            return Action.C
        else:
            self.last_defected = True
            return Action.D

class Strategy_COLLECTIVE_223(BaseStrategy):
    """
    A strategy that balances responsiveness to cooperation levels with forgiveness,
    aiming to maintain cooperation in public goods games.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_coops = history.my_actions[prev_round] + np.sum(history.opponent_actions[prev_round, :])
        if prev_coops >= self.m:
            return Action.C
        if not history.my_actions[prev_round]:
            prev_prev_round = prev_round - 1
            if prev_prev_round >= 0:
                prev_prev_coops = history.my_actions[prev_prev_round] + np.sum(history.opponent_actions[prev_prev_round, :])
                if prev_prev_coops < self.m:
                    return Action.C
            else:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_224(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game where players cooperate 
    if the public good share from the previous round is at least 1.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_prev_action = history.my_actions[t_prev]
        opponents_prev_actions = history.opponent_actions[t_prev, :]
        sum_coop_prev = my_prev_action + np.sum(opponents_prev_actions)
        share_prev = self.game_description.k / self.game_description.n_players * sum_coop_prev
        if share_prev >= 1.0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_225(BaseStrategy):
    """
    Collective Risk Tolerant Tit-for-Tat strategy to balance cooperation and self-interest.
    Cooperates initially, reciprocates based on collective past behavior with a threshold,
    and includes mechanisms for forgiveness to prevent perpetual defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponents_prev = history.opponent_actions[prev_round, :]
        my_c = int(my_prev)
        opp_c = np.sum(opponents_prev)
        total_coop = my_c + opp_c
        if total_coop >= self.m:
            return Action.C
        elif self.game_description.n_rounds < 20:
            if state.round_number % 5 == 0:
                return Action.C
            else:
                return Action.D
        elif random.random() < 0.2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_226(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.state = 'C'

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_action = history.my_actions[previous_round]
        opponent_actions = history.opponent_actions[previous_round, :]
        coop_prev = int(my_action) + int(np.sum(opponent_actions))
        if self.state == 'C':
            if coop_prev >= self.m:
                return Action.C
            else:
                self.state = 'P'
                return Action.D
        else:
            self.state = 'C'
            return Action.C

class Strategy_COLLECTIVE_227(BaseStrategy):
    """
    An adaptive strategy encouraging cooperation in a repeated public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        my_prev_action = history.my_actions[-1]
        opponent_prev_actions = history.opponent_actions[-1, :]
        total_coop_prev = my_prev_action + sum(opponent_prev_actions)
        if total_coop_prev >= self.m:
            return Action.C
        else:
            p = self.m / self.game_description.n_players
            if random.random() < p:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_228(BaseStrategy):
    """
    Adaptive Cooperative Threshold (ACT) Strategy:
    Cooperates in the first round. In subsequent rounds, cooperates if at least m players cooperated in the previous round.
    m is calculated as the ceiling of (n_players / k), ensuring adaptivity based on game parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k) if self.k != 0 else self.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            previous_round = state.round_number - 1
            my_action = history.my_actions[previous_round]
            if my_action:
                my_contribution = 1
            else:
                my_contribution = 0
            opp_actions = history.opponent_actions[previous_round]
            opp_contribution = np.sum(opp_actions)
            total_coop = my_contribution + opp_contribution
            return Action.C if total_coop >= self.m else Action.D

class Strategy_COLLECTIVE_229(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that begins by cooperating and continues to cooperate 
    if at least half of the players (rounded down) cooperated in the previous round, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponents = history.opponent_actions[prev_round, :]
        total_coop_prev = prev_my_action + np.sum(prev_opponents)
        threshold = self.game_description.n_players // 2
        if total_coop_prev >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_230(BaseStrategy):
    """
    Cooperative Punishment with Recovery Strategy.
    Encourages sustained cooperation with punishment and recovery phases.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = max(1, math.ceil(game_description.n_players / game_description.k))
        self.p = 1
        self.is_punishing = False
        self.rounds_punished = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.is_punishing:
            action = Action.D
            self.rounds_punished += 1
            previous_opponent_actions = history.opponent_actions[-1]
            num_coop_prev = np.sum(previous_opponent_actions)
            if history.my_actions.size > 0:
                previous_my_action = history.my_actions[-1]
                num_coop_prev += previous_my_action
            if num_coop_prev >= self.m:
                self.is_punishing = False
                self.rounds_punished = 0
            elif self.rounds_punished >= self.p:
                self.is_punishing = False
                self.rounds_punished = 0
            return action
        else:
            if history is None:
                return Action.D
            previous_opponent_actions = history.opponent_actions[-1]
            num_coop_prev = np.sum(previous_opponent_actions)
            if history.my_actions.size > 0:
                previous_my_action = history.my_actions[-1]
                num_coop_prev += previous_my_action
            if num_coop_prev >= self.m:
                return Action.C
            else:
                self.is_punishing = True
                self.rounds_punished = 1
                return Action.D

class Strategy_COLLECTIVE_231(BaseStrategy):
    """A strategy that promotes sustained cooperation with recovery from temporary defections."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.m = max(1, self.m)
        self.p = 2
        self.defect_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_actions_prev = history.opponent_actions[previous_round]
        prev_coops = 1 if my_prev_action else 0
        prev_coops += np.sum(opponent_actions_prev)
        if prev_coops >= self.m:
            self.defect_counter = 0
            return Action.C
        else:
            self.defect_counter += 1
            if self.defect_counter >= self.p:
                self.defect_counter = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_232(BaseStrategy):
    """
    A strategy that promotes cooperation by rewarding collective cooperation
    with continued cooperation and punishing insufficient cooperation
    with temporary defection, then reverting to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        if not history.my_actions[-1]:
            return Action.C
        sum_opponent_c = sum(history.opponent_actions[-1])
        sum_c_prev = sum_opponent_c + (1 if history.my_actions[-1] else 0)
        if sum_c_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_233(BaseStrategy):
    """
    This strategy starts with cooperation and adapts based on the number of cooperators in previous rounds.
    If the number of cooperators meets or exceeds a calculated threshold, the player continues to cooperate.
    Otherwise, the player defects but attempts to cooperate again in the following round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = max(1, math.ceil(n / k))
        self.will_cooperate_next = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round, :]
        sum_coop_prev = my_prev_action + opp_prev_actions.sum()
        if self.will_cooperate_next:
            self.will_cooperate_next = False
            return Action.C
        if sum_coop_prev >= self.m:
            return Action.C
        else:
            self.will_cooperate_next = True
            return Action.D

class Strategy_COLLECTIVE_234(BaseStrategy):
    """
    A strategy to promote sustained cooperation in the N-player public goods game.
    Players initially cooperate, then adjust their behavior based on previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)
        if self.m < 1:
            self.m = 1
        elif self.m > game_description.n_players:
            self.m = game_description.n_players
        self.m = int(self.m)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_action_bool = history.my_actions[-1]
        if not prev_action_bool:
            return Action.C
        else:
            last_opponent_actions = history.opponent_actions[-1]
            opp_coops = np.sum(last_opponent_actions)
            total_coops = 1 + opp_coops
            if total_coops >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_235(BaseStrategy):
    """
    A strategy to sustain cooperation in an N-Player Public Goods Game by balancing initial and continued cooperation with probabilistic retry after cooperation drops below a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = min(math.ceil(self.k), self.n_players)
        self.p = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opp_coops = sum(history.opponent_actions[prev_round, :])
        my_prev_action = history.my_actions[prev_round]
        prev_total = opp_coops + (1 if my_prev_action else 0)
        if prev_total >= self.m:
            return Action.C
        elif random.random() < self.p:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_236(BaseStrategy):
    """
    Cooperate if sufficient number of players cooperated in the previous round, else defect.
    The threshold is calculated as the ceiling of (n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_action = history.my_actions[t_prev]
        opponent_actions = history.opponent_actions[t_prev, :]
        total_coop = int(my_action) + np.sum(opponent_actions)
        return Action.C if total_coop >= self.m else Action.D

class Strategy_COLLECTIVE_237(BaseStrategy):
    """
    Implements a strategy that starts with cooperation, punishes temporarily after 
    unsuccessful rounds, and decides the last round based on historical success.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        is_last_round = state.round_number == self.n_rounds - 1
        if is_last_round:
            success_count = 0
            for round_idx in range(state.round_number):
                my_C = history.my_actions[round_idx]
                my_C_count = 1 if my_C else 0
                opponent_C = history.opponent_actions[round_idx, :]
                opponent_C_sum = np.sum(opponent_C)
                total_C = my_C_count + opponent_C_sum
                if total_C >= self.m:
                    success_count += 1
            if success_count * 2 >= state.round_number:
                return Action.C
            else:
                return Action.D
        elif self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_C = history.my_actions[prev_round]
            my_C_count = 1 if my_C else 0
            opponent_C = history.opponent_actions[prev_round, :]
            opponent_C_sum = np.sum(opponent_C)
            total_C = my_C_count + opponent_C_sum
            if total_C >= self.m:
                return Action.C
            else:
                self.punishment_remaining = 2
                return Action.D

class Strategy_COLLECTIVE_238(BaseStrategy):
    """
    Strategy to maintain cooperation in an N-player public goods game by balancing punishment and forgiveness.
    Cooperates if previous round's cooperators meet a threshold, otherwise defects or switches back based on previous action.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions_prev = history.opponent_actions[-1] if history is not None else None
        my_action_prev = history.my_actions[-1] if history is not None else False
        c_prev = sum(opponent_actions_prev) + (1 if my_action_prev else 0)
        if c_prev >= self.m:
            return Action.C
        if not my_action_prev:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_239(BaseStrategy):
    """
    Adaptive Collective Cooperation with Reset Strategy.
    
    Players start by cooperating. They continue to cooperate if enough players
    cooperated in the previous round (at least m). If not, they defect but reset to
    cooperation after 3 consecutive defections to allow potential reestablishment
    of cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.x = 3
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponent_actions_last_round = history.opponent_actions[last_round, :]
        cooperation_last = my_last_action + sum(opponent_actions_last_round)
        if cooperation_last >= self.m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections >= self.x:
                self.consecutive_defections = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_240(BaseStrategy):
    """
    Implements the Collective Risk Dilemma Strategy: Adaptive Cooperation with Forgiveness.
    Cooperates initially, then continues if previous round met threshold m (based on game's k).
    Defects once if threshold not met, then reverts to Cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history.my_actions[state.round_number - 1]:
            return Action.C
        prev_round = state.round_number - 1
        own_prev_action = history.my_actions[prev_round]
        prev_opponent_actions = history.opponent_actions[prev_round]
        total_prev_coop = np.sum(prev_opponent_actions) + (1 if own_prev_action else 0)
        if total_prev_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_241(BaseStrategy):
    """
    Implements the Grim Trigger strategy for group cooperation in the N-player public goods game.
    The strategy starts by cooperating and continues to do so as long as at least m players cooperated 
    in the previous round (where m = ceil(n_players / k)). If fewer than m players cooperated, 
    the strategy defects permanently in all subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.defecting = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if self.defecting:
            return Action.D
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        if history is None:
            return Action.C
        self_prev_action = history.my_actions[prev_round]
        my_c = 1 if self_prev_action else 0
        op_actions = history.opponent_actions[prev_round]
        op_c = np.sum(op_actions)
        total_c = my_c + op_c
        if total_c >= self.m:
            return Action.C
        else:
            self.defecting = True
            return Action.D

class Strategy_COLLECTIVE_242(BaseStrategy):
    """
    A strategy to promote sustained cooperation with selective retaliation and forgiveness.
    Cooperates initially and continues if sufficient players cooperate, defects otherwise,
    but retries cooperation after two consecutive failures.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(game_description.k)
        self.consecutive_failures = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.consecutive_failures = 0
            return Action.C
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        previous_round = current_round - 1
        my_prev_act = history.my_actions[previous_round]
        opp_prev_act = history.opponent_actions[previous_round]
        total_coop_prev = my_prev_act + np.sum(opp_prev_act)
        last_met = total_coop_prev >= self.m
        if last_met:
            self.consecutive_failures = 0
            return Action.C
        elif self.consecutive_failures >= 1:
            self.consecutive_failures = 0
            return Action.C
        else:
            self.consecutive_failures += 1
            return Action.D

class Strategy_COLLECTIVE_244(BaseStrategy):
    """
    Adaptive Cooperation with Reset strategy. Players initially cooperate. If enough players cooperated in the previous round, they continue cooperating. If not, they defect until reset after `s` consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = (self.n_players + 1) // 2
        self.s = 1
        self.consecutive_defect_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, :]
            cooperators = my_prev_action + sum(opp_prev_actions)
            if cooperators >= self.m:
                self.consecutive_defect_rounds = 0
                return Action.C
            else:
                self.consecutive_defect_rounds += 1
                if self.consecutive_defect_rounds >= self.s:
                    self.consecutive_defect_rounds = 0
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_245(BaseStrategy):
    """
    A strategy that encourages cooperation by punishing insufficient cooperation in the previous round.
    Cooperates initially and in subsequent rounds if the number of cooperators meets a threshold.
    Punishes once if the threshold is not met, allowing recovery in future rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        total_coop_prev = sum(opponents_prev_actions) + my_prev_action
        if total_coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_246(BaseStrategy):
    """
    Cooperative Strategy based on previous round's cooperation count.
    Cooperates if previous round met the cooperation threshold, otherwise defects once then cooperates again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.n_players / game_description.k) + 1
        self.next_cooperate = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.next_cooperate:
            action = Action.C
            self.next_cooperate = False
            return action
        t = state.round_number
        my_prev = history.my_actions[t - 1]
        opponents_prev = history.opponent_actions[t - 1, :]
        coop_count = my_prev + np.sum(opponents_prev)
        if coop_count >= self.m:
            action = Action.C
        else:
            action = Action.D
            self.next_cooperate = True
        return action

class Strategy_COLLECTIVE_247(BaseStrategy):
    """
    Adaptive Collective Cooperation with Forgiveness (ACCF) strategy.
    
    This strategy promotes cooperation by first initiating cooperation and then adjusting
    based on the collective behavior of all players. It defects temporarily when the
    cooperation threshold is not met but forgives after a set number of rounds to allow
    cooperation to recover.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)
        self.f = 3
        self.consecutive_failures = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_opponent_actions = history.opponent_actions[prev_round, :]
        prev_my_action = history.my_actions[prev_round]
        prev_opponent_c = sum(prev_opponent_actions)
        prev_my_c = 1 if prev_my_action else 0
        prev_coops = prev_opponent_c + prev_my_c
        if prev_coops >= self.m:
            self.consecutive_failures = 0
            return Action.C
        else:
            self.consecutive_failures += 1
            if self.consecutive_failures > self.f:
                self.consecutive_failures = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_248(BaseStrategy):
    """
    A strategy that cooperates on the first round and then decides based on the number of cooperators in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round]
        sum_opponent_prev = np.sum(opponent_actions_prev)
        s = int(my_prev_action) + sum_opponent_prev
        if s >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_249(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            others_prev = np.sum(history.opponent_actions[prev_round, :])
            c_prev = int(my_prev) + others_prev
            if c_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_250(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACAP) strategy to address collective risk dilemmas.
    Cooperates initially, punishes temporary defection, and adapts based on previous cooperation levels.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round]
            my_coop = int(my_prev_action)
            coop_total = my_coop + sum(opponent_prev_actions)
            if coop_total >= self.m:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round]
            my_coop = int(my_prev_action)
            coop_total = my_coop + sum(opponent_prev_actions)
            if coop_total >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_251(BaseStrategy):
    """
    A strategy that encourages initial cooperation and adapts based on the group's past behavior.
    Cooperates in the first round. In subsequent rounds, cooperates if more than half of past rounds met the cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = math.ceil(self.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        count = 0
        for t in range(state.round_number):
            my_coop = history.my_actions[t]
            opponent_coop = history.opponent_actions[t].sum()
            total_coop = my_coop + opponent_coop
            if total_coop >= self.m:
                count += 1
        proportion = count / state.round_number
        return Action.C if proportion > 0.5 else Action.D

class Strategy_COLLECTIVE_252(BaseStrategy):
    """
    Collective Tit-for-Tat Strategy: Cooperate in the first round. 
    In subsequent rounds, cooperate if at least m players cooperated in the previous round; 
    otherwise, defect. The threshold m is set to the smallest integer greater than or equal 
    to the game's multiplication factor k, but not exceeding the number of players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        k = game_description.k
        n = game_description.n_players
        self.m = math.ceil(k)
        self.m = min(self.m, n)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            total_coop = my_prev_action + np.sum(opponent_actions_prev)
            return Action.C if total_coop >= self.m else Action.D

class Strategy_COLLECTIVE_253(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy.
    Cooperates in the first round. In subsequent rounds, cooperates if at least m players cooperated in the previous round, where m is the floor of k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.floor(self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponent_actions = history.opponent_actions[prev_round]
        sum_prev_coop = sum(prev_opponent_actions) + (1 if prev_my_action else 0)
        if sum_prev_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_254(BaseStrategy):
    """
    Cooperate If Threshold Met (CITM) strategy. Cooperates if the number of cooperators in the previous round met the threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        total_coop = my_prev_action + np.sum(opponents_prev_actions)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_255(BaseStrategy):
    """
    A strategy that starts by cooperating, then switches based on the number of previous cooperators.
    Cooperates if at least k players (where k is the game's multiplication factor) cooperated in the previous round,
    otherwise defects once before cooperating again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k
        self.must_cooperate_next = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.must_cooperate_next:
            self.must_cooperate_next = False
            return Action.C
        previous_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round, :]
        sum_opponent_coop = np.sum(opponent_actions_prev)
        my_prev_action = history.my_actions[previous_round]
        total_coop = sum_opponent_coop + (1 if my_prev_action else 0)
        if total_coop >= self.m:
            return Action.C
        else:
            self.must_cooperate_next = True
            return Action.D

class Strategy_COLLECTIVE_256(BaseStrategy):
    """
    Responsive Cooperation with Forgiveness Strategy.

    This strategy starts by Cooperating, then adapts based on the number of Cooperators in the previous round.
    It continues to Cooperate if enough players Cooperated previously or alternates to Defect once before retrying.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.previous_met_m = False
        self.last_action = None

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            return Action.C
        else:
            previous_round = state.round_number - 1
            my_prev_action = history.my_actions[previous_round]
            opponents_prev = history.opponent_actions[previous_round]
            total_coop_prev = (1 if my_prev_action else 0) + sum(opponents_prev)
            previous_met_m = total_coop_prev >= self.m
            self.previous_met_m = previous_met_m
            if previous_met_m:
                action = Action.C
            elif self.last_action == Action.D:
                action = Action.C
            else:
                action = Action.D
            self.last_action = action
            return action

class Strategy_COLLECTIVE_257(BaseStrategy):
    """
    This strategy promotes sustained cooperation by initiating with cooperation and 
    adapting based on the number of cooperators in the previous round. Players cooperate 
    if at least half (rounded down) of the players cooperated previously; otherwise, they defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        sum_prev_me = 1 if my_prev else 0
        opponent_prev = history.opponent_actions[prev_round, :]
        sum_opponent = np.sum(opponent_prev)
        total_c = sum_prev_me + sum_opponent
        m = self.n_players // 2
        if total_c >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_258(BaseStrategy):
    """
    Cooperative Punishment with Recovery (CPR) Strategy.
    
    This strategy promotes cooperation by initially cooperating, punishing when cooperation drops below a certain threshold (derived from the game's multiplication factor k), and recovering cooperation after a punishment phase.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            prev_my_bool = history.my_actions[prev_round]
            prev_opponent_actions = history.opponent_actions[prev_round, :]
            prev_coop_count = sum(prev_opponent_actions) + (1 if prev_my_bool else 0)
            if prev_coop_count >= self.m or not prev_my_bool:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_259(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that balances cooperation 
    and strategic defection based on historical performance.

    The strategy starts by cooperating in the first round. In subsequent rounds, it 
    cooperates if the number of previous cooperators meets a computed threshold. If not, 
    it defects but reverts to cooperation after a single defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.floor(self.n_players / self.k) + 1

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_opponent_actions = history.opponent_actions[prev_round]
        sum_opponents = np.sum(prev_opponent_actions)
        my_prev_action = history.my_actions[prev_round]
        x_prev = sum_opponents + (1 if my_prev_action else 0)
        if x_prev >= self.m:
            return Action.C
        elif not my_prev_action:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_260(BaseStrategy):
    """
    A strategy that encourages cooperation by default but defects when participation drops below a threshold,
    then automatically recovers to cooperation in the next round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.prev_defected = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
        elif self.prev_defected:
            action = Action.C
        elif history is None:
            action = Action.D
        else:
            prev_round = state.round_number - 1
            opp_actions = history.opponent_actions[prev_round]
            opp_coop = np.sum(opp_actions)
            my_coop = history.my_actions[prev_round]
            total_coop = opp_coop + (1 if my_coop else 0)
            if total_coop >= self.m:
                action = Action.C
            else:
                action = Action.D
        self.prev_defected = action == Action.D
        return action

class Strategy_COLLECTIVE_261(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that assigns individual thresholds 
    to balance cooperation and defection, adapting based on previous rounds' outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.n_players = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_actions = history.opponent_actions[-1, :]
        cooperators = sum(previous_actions)
        threshold = self.m
        if cooperators >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_262(BaseStrategy):
    """
    A reciprocal cooperation strategy with a reset mechanism to encourage sustained cooperation.
    Cooperates if the number of cooperators in the previous round meets a threshold or after a defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)
        self.previously_defected = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previously_defected = False
            return Action.C
        prev_round = history
        opponent_coop = sum(prev_round.opponent_actions[-1])
        my_coop = prev_round.my_actions[-1]
        total_coop = opponent_coop + (1 if my_coop else 0)
        if total_coop >= self.m:
            self.previously_defected = False
            return Action.C
        elif self.previously_defected:
            self.previously_defected = False
            return Action.C
        else:
            self.previously_defected = True
            return Action.D

class Strategy_COLLECTIVE_263(BaseStrategy):
    """
    Adaptive Collective Cooperation Strategy.
    Cooperates in the first round. In subsequent rounds, cooperates if the number
    of cooperators in the previous round meets or exceeds half the number of players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_actions_prev = history.opponent_actions[prev_round, :]
        total_coop = my_prev_action + opp_actions_prev.sum()
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_264(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) Strategy.

    This strategy aims to maintain cooperation levels by cooperating initially,
    and adapting based on the number of cooperators in previous rounds.
    If cooperation drops below a threshold (m), the strategy defects once
    and then reverts back to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)
        self.revert_next = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.revert_next = False
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_opponents = history.opponent_actions[-1]
        s_prev = int(prev_my_action) + np.count_nonzero(prev_opponents)
        if self.revert_next:
            action = Action.C
            self.revert_next = False
        elif s_prev >= self.m:
            action = Action.C
        else:
            action = Action.D
            self.revert_next = True
        return action

class Strategy_COLLECTIVE_265(BaseStrategy):
    """
    Adaptive Collective Cooperation strategy.
    Starts with cooperation, adapts based on previous round outcomes, and decides last round based on majority success.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            successful_rounds = 0
            for prev_round in range(state.round_number):
                my_action = history.my_actions[prev_round]
                opponents = history.opponent_actions[prev_round, :]
                coop_count = int(my_action) + np.sum(opponents)
                if coop_count >= self.m:
                    successful_rounds += 1
            total_prev_rounds = state.round_number
            if successful_rounds > total_prev_rounds / 2:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_round = history.opponent_actions[prev_round, :]
            coop_count = int(my_prev_action) + np.sum(opponents_prev_round)
            if coop_count >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_266(BaseStrategy):
    """
    A strategy that adapts cooperation based on collective past actions with forgiveness.
    It cooperates initially, punishes when cooperation drops below a threshold,
    and forgives if cooperation resumes within a monitoring window.
    In endgame, it encourages cooperation based on the previous round's outcome.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2
        self.forgiveness_window = 3
        self.is_punishing = False
        self.punish_remain = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        t_prev = current_round - 1
        if current_round >= self.n_rounds - 5:
            sum_oppons = sum(history.opponent_actions[t_prev])
            my_coop_prev = int(history.my_actions[t_prev])
            total_coop_prev = sum_oppons + my_coop_prev
            if total_coop_prev >= self.m:
                return Action.C
            else:
                return Action.D
        sum_oppons = sum(history.opponent_actions[t_prev])
        my_coop_prev = int(history.my_actions[t_prev])
        total_coop_prev = sum_oppons + my_coop_prev
        if total_coop_prev >= self.m:
            self.is_punishing = False
            self.punish_remain = 0
            return Action.C
        elif not self.is_punishing:
            self.is_punishing = True
            self.punish_remain = self.forgiveness_window
            return Action.D
        elif self.punish_remain > 0:
            self.punish_remain -= 1
            return Action.D
        else:
            window_start = max(t_prev - self.forgiveness_window + 1, 0)
            any_met = False
            for round_to_check in range(window_start, t_prev + 1):
                sum_o = sum(history.opponent_actions[round_to_check])
                my_c = int(history.my_actions[round_to_check])
                total_c = sum_o + my_c
                if total_c >= self.m:
                    any_met = True
                    break
            if any_met:
                self.is_punishing = False
                self.punish_remain = 0
                return Action.C
            else:
                self.is_punishing = True
                self.punish_remain = self.forgiveness_window
                return Action.D

class Strategy_COLLECTIVE_267(BaseStrategy):
    """
    A strategy to address the Collective Risk Dilemma by encouraging cooperation
    based on the number of previous round cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        coop_count = int(my_prev_action) + np.sum(opponent_prev_actions)
        if coop_count >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_268(BaseStrategy):
    """
    Adaptive Threshold Cooperation (ATC) strategy for the N-Player Public Goods Game.
    This strategy encourages cooperation by setting a threshold, adapting based on collective outcomes,
    and safeguarding against persistent low cooperation by switching to defection if necessary.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.consecutive_below = 0
        self.always_defect = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if self.always_defect:
            return Action.D
        if state.round_number == 0:
            return Action.C
        my_last = history.my_actions[-1]
        opponents_last = history.opponent_actions[-1, :]
        sum_coop = my_last + np.sum(opponents_last)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if sum_coop >= self.m else Action.D
        if sum_coop < self.m:
            self.consecutive_below += 1
        else:
            self.consecutive_below = 0
        if self.consecutive_below >= 3:
            self.always_defect = True
            return Action.D
        if sum_coop >= self.m:
            return Action.C
        else:
            p = max(0.5, sum_coop / self.game_description.n_players)
            return Action.C if random.random() < p else Action.D

class Strategy_COLLECTIVE_269(BaseStrategy):
    """
    Cooperative Punisher with Forgiveness Strategy.

    This strategy cooperates initially and in subsequent rounds based on the number of cooperators.
    It defects if cooperation drops below a threshold (m) but returns to cooperation afterward.
    The threshold m is calculated as the ceiling of (n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k) if k != 0 else n
        self.next_action_forced = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.next_action_forced = False
            return Action.C
        if self.next_action_forced:
            self.next_action_forced = False
            return Action.C
        prev_round = state.round_number - 1
        if prev_round < 0:
            return Action.D
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        total = my_prev_action + np.sum(opponents_prev_actions)
        if total >= self.m:
            return Action.C
        else:
            self.next_action_forced = True
            return Action.D

class Strategy_COLLECTIVE_270(BaseStrategy):
    """
    Adaptive Cooperate-if-Met (ACM) strategy.
    Cooperates if the number of cooperators in the previous round meets or exceeds a threshold,
    which is calculated as the ceiling of (number of players / multiplication factor).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_previous_action = history.my_actions[prev_round]
        opponents_previous_actions = history.opponent_actions[prev_round]
        opponent_coop = np.sum(opponents_previous_actions)
        self_coop = 1 if my_previous_action else 0
        total_coop = opponent_coop + self_coop
        return Action.C if total_coop >= self.m else Action.D

class Strategy_COLLECTIVE_17(BaseStrategy):
    """
    Implements the Cooperative Punishment with Forgiveness strategy.
    Cooperate in the first round. In subsequent rounds, Cooperate if previous round's cooperation met the threshold.
    During punishment, players with id <= m-1 Cooperate, others Defect. Player ID handling is abstracted here.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            previous_coops = 0
        else:
            sum_opponents = sum(history.opponent_actions[-1, :])
            my_prev_action = history.my_actions[-1]
            previous_coops = sum_opponents + my_prev_action
        if previous_coops >= self.m:
            return Action.C
        else:
            threshold = self.m - 1
            return Action.D

class Strategy_COLLECTIVE_39(BaseStrategy):
    """
    Adaptive Cooperation with Punishment strategy.
    Cooperates initially, continues if enough others cooperate, otherwise defects for 2 rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        elif current_round == n_rounds - 1:
            return Action.C
        elif self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        else:
            if history is None:
                return Action.C
            prev_round = current_round - 1
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            my_prev_action = history.my_actions[prev_round]
            total_prev_coop = opponent_actions_prev.sum() + my_prev_action
            if total_prev_coop >= self.m:
                return Action.C
            else:
                self.punishment_remaining = 2
                return Action.D

class Strategy_COLLECTIVE_91(BaseStrategy):
    """
    A strategy that encourages cooperation by punishing lack of cooperation and 
    then reverting back to cooperation. It uses a threshold based on the game's 
    parameters to decide actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.n_players / game_description.k)
        self.must_cooperate = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.must_cooperate:
            self.must_cooperate = False
            return Action.C
        last_round = state.round_number - 1
        my_last = history.my_actions[last_round]
        opponents_last = history.opponent_actions[last_round, :]
        n_coop = my_last + sum(opponents_last)
        if n_coop >= self.m:
            return Action.C
        else:
            self.must_cooperate = True
            return Action.D

class Strategy_COLLECTIVE_154(BaseStrategy):
    """
    Adaptive Cooperation with Temporary Punishment Strategy.
    
    Cooperates initially, continues if sufficient players cooperated in the previous round, 
    and temporarily defects if the cooperation level falls below the threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.last_punished = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_punished = False
            return Action.C
        if self.last_punished:
            self.last_punished = False
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        my_c = 1 if my_prev_action else 0
        opp_prev_actions = history.opponent_actions[prev_round, :]
        opp_c = sum(opp_prev_actions)
        total_c_prev = my_c + opp_c
        if total_c_prev >= self.m:
            return Action.C
        else:
            self.last_punished = True
            return Action.D

class Strategy_COLLECTIVE_158(BaseStrategy):
    """
    Adaptive Threshold Cooperation (ATC) strategy.
    Cooperates initially, then uses past outcomes to decide future actions.
    Defects if cooperation is insufficient for a while, then re-initiates cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)
        self.s = 3
        self.d = 2

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        d = self.d
        consecutive_defects = 0
        my_actions = history.my_actions
        for action in reversed(my_actions):
            if action == False:
                consecutive_defects += 1
            else:
                break
        if consecutive_defects >= d:
            return Action.C
        s = self.s
        t = state.round_number - 1
        start_round = max(0, t - s + 1)
        count_met = 0
        for round_idx in range(start_round, t + 1):
            if round_idx >= len(my_actions):
                break
            sum_c = 0
            if my_actions[round_idx]:
                sum_c = 1
            else:
                sum_c = 0
            sum_c += np.sum(history.opponent_actions[round_idx, :])
            if sum_c >= self.m:
                count_met += 1
        threshold = math.ceil(s / 2)
        if count_met >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_159(BaseStrategy):
    """
    Strategy for Collective Risk Dilemma: Cooperate in the first round. In each subsequent round, cooperate if the number of cooperators in the previous round meets or exceeds m, calculated as ceil(n/k). Otherwise, defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        k = self.game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            sum_prev = int(my_prev_action) + opponents_prev_actions.sum()
            if sum_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_170(BaseStrategy):
    """
    A strategy that starts with cooperation and uses a punishment mechanism when the 
    number of cooperators falls below a threshold, then resumes cooperation after a 
    punishment phase.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        n_coop_prev = my_prev_action + np.sum(opponent_prev_actions)
        if n_coop_prev == 0:
            return Action.C
        elif n_coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_193(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) strategy for N-Player Public Goods Game.
    Cooperates initially, uses threshold-based reciprocity, and safeguards endgame with unconditional cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.defected_once = False
        self.endgame_rounds = max(1, math.ceil(0.1 * self.n_rounds))
        self.endgame_start = self.n_rounds - self.endgame_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round >= self.endgame_start:
            return Action.C
        if current_round == 0:
            return Action.C
        sum_coops = 0
        t_prev = current_round
        for round in range(t_prev):
            sum_coops += history.my_actions[round]
            sum_coops += np.sum(history.opponent_actions[round])
        denominator = self.n_players * t_prev
        average_coop = sum_coops / denominator
        threshold = self.k / self.n_players
        if average_coop >= threshold:
            return Action.C
        elif not self.defected_once:
            self.defected_once = True
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_208(BaseStrategy):
    """
    A responsive strategy for the N-Player Public Goods Game. Players cooperate 
    initially and continue to cooperate if at least half of the players (rounded down) 
    cooperated in the previous round. This encourages sustained cooperation while 
    allowing for adaptation to changes in group behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = self.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round, :]
        sum_opponent_c = np.sum(opponent_actions_prev)
        my_prev_action = history.my_actions[previous_round]
        total_c = sum_opponent_c + (1 if my_prev_action else 0)
        if total_c >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_210(BaseStrategy):
    """
    A Collective Risk Dilemma strategy that balances cooperation with adaptability.
    Cooperates initially, then adapts based on the success of previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        super().__init__(game_description)
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = self.n_players // self.k + 1

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        met_threshold = 0
        for round_idx in range(current_round):
            my_action = history.my_actions[round_idx]
            opponents_actions = history.opponent_actions[round_idx, :]
            total_coop = my_action + np.sum(opponents_actions)
            if total_coop >= self.m:
                met_threshold += 1
        proportion_met = met_threshold / current_round
        if proportion_met > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_214(BaseStrategy):
    """
    Adaptive Collective Reciprocity (ACR) Strategy.
    Cooperates initially, then adapts based on the number of cooperators in previous rounds.
    Uses a threshold to decide cooperation. Cooperates in the last round if majority of prior rounds met the threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        m = math.ceil(n / k)
        self.m = min(m, n)
        self.r = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r - 1:
            count = 0
            my_actions = history.my_actions
            opponent_actions = history.opponent_actions
            for t_prev in range(self.r - 1):
                my_c = my_actions[t_prev]
                opponent_cs = np.sum(opponent_actions[t_prev, :])
                total_c = my_c + opponent_cs
                if total_c >= self.m:
                    count += 1
            half_prev = (self.r - 1) / 2
            if count > half_prev:
                return Action.C
            else:
                return Action.D
        else:
            previous_round = state.round_number - 1
            my_c = history.my_actions[previous_round]
            opponent_actions_prev = history.opponent_actions[previous_round, :]
            opponent_cs = np.sum(opponent_actions_prev)
            total_c = my_c + opponent_cs
            if total_c >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_215(BaseStrategy):
    """
    A strategy that promotes cooperation through reciprocity and forgiveness.
    Cooperates initially, continues if enough others cooperate, defects when cooperation 
    is low, but forgives by cooperating again after defecting once.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        if not my_prev_action:
            return Action.C
        else:
            opp_coop = np.sum(history.opponent_actions[prev_round])
            my_coop = 1 if my_prev_action else 0
            coop_count = opp_coop + my_coop
            if coop_count >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_216(BaseStrategy):
    """
    A strategy that begins with cooperation and adapts based on previous round's cooperation levels.
    It uses a threshold (m) to decide whether to continue cooperating or defect with a 50% chance.
    The threshold m is calculated as the ceiling of (n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        own_prev = history.my_actions[prev_round]
        opponent_actions = history.opponent_actions[prev_round, :]
        total_C = int(own_prev) + np.sum(opponent_actions)
        if total_C >= self.m:
            return Action.C
        elif random.random() < 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_217(BaseStrategy):
    """
    A strategy that maintains cooperation by punishing defectors for a brief period, then reverting to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)
        self.defect_p = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.defect_p > 0:
            self.defect_p -= 1
            return Action.D
        if history is None:
            previous_round = -1
        else:
            previous_round = history.my_actions.size - 1
        if previous_round < 0:
            return Action.C
        my_prev_action = history.my_actions[previous_round]
        opp_prev_actions = history.opponent_actions[previous_round, :]
        count_C = int(my_prev_action) + int(sum(opp_prev_actions))
        if count_C < self.m:
            self.defect_p = 2
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_243(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that adaptively responds to past cooperation levels.
    It encourages cooperation by conditionally cooperating based on the number of previous cooperators,
    and attempts to restart cooperation after setbacks.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)
        self.should_coop_next_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.should_coop_next_round:
            self.should_coop_next_round = False
            return Action.C
        round_index = state.round_number - 1
        my_prev_c = history.my_actions[round_index]
        opponent_prev_actions = history.opponent_actions[round_index]
        c_prev = my_prev_c + sum(opponent_prev_actions)
        if c_prev >= self.m:
            return Action.C
        else:
            all_prior_under = True
            for r in range(round_index):
                my_prev = history.my_actions[r]
                opponent_prev = history.opponent_actions[r]
                c_prior = my_prev + sum(opponent_prev)
                if c_prior >= self.m:
                    all_prior_under = False
                    break
            if all_prior_under:
                return Action.D
            else:
                self.should_coop_next_round = True
                return Action.D

class Strategy_COLLECTIVE_271(BaseStrategy):
    """
    A strategy to encourage sustained cooperation by adaptively responding to the number of cooperators.
    It cooperates initially, continues if enough players cooperate, defects if not, and resets cooperation after a threshold of defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = self.n // self.k + 1
        self.consecutive_defections = 0
        self.threshold = 3

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        total_c = my_prev_action + np.sum(opponent_prev_actions)
        if total_c >= self.m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections >= self.threshold:
                self.consecutive_defections = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_272(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that promotes cooperation through adaptive monitoring and punishment.
    Cooperates initially, continues if cooperation levels are sufficient, and punishes temporarily.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishing = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        is_last_round = state.round_number == self.game_description.n_rounds - 1
        prev_round = state.round_number - 1
        if is_last_round:
            my_prev = history.my_actions[prev_round]
            opponent_prev = history.opponent_actions[prev_round, :]
            sum_coop_prev = my_prev + np.sum(opponent_prev)
            m = self.game_description.n_players // 2
            if sum_coop_prev >= m:
                return Action.C
            else:
                return Action.D
        elif self.punishing:
            self.punishing = False
            return Action.C
        else:
            my_prev = history.my_actions[prev_round]
            opponent_prev = history.opponent_actions[prev_round, :]
            sum_coop_prev = my_prev + np.sum(opponent_prev)
            m = self.game_description.n_players // 2
            if sum_coop_prev >= m:
                return Action.C
            else:
                self.punishing = True
                return Action.D

class Strategy_COLLECTIVE_273(BaseStrategy):
    """
    Forgiving Cooperation with Punishment Strategy.

    This strategy starts by cooperating. It continues to cooperate as long as the 
    number of cooperators in the previous round meets at least half the players. 
    If not, it defects for a round and then forgives, returning to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.punishing = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishing:
            self.punishing = False
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = int(history.my_actions[prev_round])
            opp_prev = history.opponent_actions[prev_round, :]
            prev_coop = my_prev + sum(opp_prev)
            if prev_coop >= self.m:
                return Action.C
            else:
                self.punishing = True
                return Action.D

class Strategy_COLLECTIVE_274(BaseStrategy):
    """
    A strategy balancing cooperation with strategic punishment to encourage collective success.
    Cooperates initially, adapts based on previous round's cooperation level,
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            action = Action.C
            self.last_action = action
            return action
        elif current_round == self.n_rounds - 1:
            action = Action.D
            self.last_action = action
            return action
        else:
            prev_round = current_round - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round]
            my_prev_coop = 1 if my_prev_action else 0
            opp_prev_coop = opp_prev_actions.sum()
            total_prev_coop = my_prev_coop + opp_prev_coop
            if total_prev_coop >= self.m:
                action = Action.C
            elif self.last_action == Action.C:
                action = Action.D
            else:
                action = Action.C
            self.last_action = action
            return action

class Strategy_COLLECTIVE_275(BaseStrategy):
    """
    Cooperate if the number of cooperators in the previous round meets the threshold (n_players), else defect.
    This promotes sustained cooperation as long as all players cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        others_prev = history.opponent_actions[prev_round, :]
        sum_coop = int(my_prev_action) + np.sum(others_prev)
        threshold = self.n_players
        if sum_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_276(BaseStrategy):
    """
    Cooperate and Forgive strategy for Public Goods Game.
    Cooperates initially, then defects if insufficient cooperation,
    but forgives after one defection to try to reestablish cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.in_punish = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[state.round_number - 1]
        prev_opp_actions = history.opponent_actions[state.round_number - 1, :]
        sum_opp = np.sum(prev_opp_actions)
        count_prev = sum_opp + (1 if prev_my_action else 0)
        if count_prev >= self.m:
            self.in_punish = False
            return Action.C
        elif self.in_punish:
            self.in_punish = False
            return Action.C
        else:
            self.in_punish = True
            return Action.D

class Strategy_COLLECTIVE_277(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that attempts to maintain cooperation
    unless the number of cooperators falls below a calculated threshold, in which case
    the strategy defects for a predetermined number of rounds before attempting cooperation again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defect_remaining = 0
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.d = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.defect_remaining > 0:
            action = Action.D
            self.defect_remaining -= 1
        else:
            action = Action.C
        if self.defect_remaining == 0 and history is not None:
            last_round = state.round_number - 1
            if last_round >= 0:
                opponent_actions_last = history.opponent_actions[last_round, :]
                my_last = history.my_actions[last_round]
                total_coop = np.sum(opponent_actions_last) + (1 if my_last else 0)
                if total_coop < self.m:
                    self.defect_remaining = self.d
        return action

class Strategy_COLLECTIVE_278(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Performance Strategy.
    Cooperates in the first round, then cooperates in subsequent rounds if the number of cooperators in the previous round meets or exceeds a threshold (k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        opponent_actions = history.opponent_actions[last_round]
        my_last_action = history.my_actions[last_round]
        num_coop_opponents = np.sum(opponent_actions)
        total_coop = num_coop_opponents + (1 if my_last_action else 0)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_280(BaseStrategy):
    """
    Collective Risk Dilemma Strategy: Adaptive Cooperation Based on Recent Success.

    This strategy starts with cooperation in the first round and then adapts based on the group's recent success.
    It checks the success of the past 't' rounds, where success is determined by whether the number of cooperators
    meets a given threshold relative to the game's parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.t = 5
        self.s = 0.6

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        n = self.game_description.n_players
        k = self.game_description.k
        threshold = n / k
        start_round = max(0, current_round - self.t)
        success_count = 0
        for r in range(start_round, current_round):
            my_c = 1 if history.my_actions[r] else 0
            opponent_c = history.opponent_actions[r].sum()
            sum_cj = my_c + opponent_c
            if sum_cj >= threshold:
                success_count += 1
        num_rounds = current_round - start_round
        if num_rounds == 0:
            return Action.C
        success_ratio = success_count / num_rounds
        if success_ratio >= self.s:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_281(BaseStrategy):
    """
    A strategy implementing Collective Reciprocity with Dynamic Thresholds.
    The strategy starts with cooperation, then uses dynamic thresholds and punishment
    to enforce cooperation in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = 1
        self.punishment_active = False
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        k = self.game_description.k
        if not self.punishment_active and current_round > 0:
            t_prev = current_round - 1
            if history.my_actions[t_prev]:
                sum_c = history.my_actions[t_prev] + np.sum(history.opponent_actions[t_prev, :])
                pi_c = k / n * sum_c
                sum_d = sum_c - 1
                pi_d = 1.0 + k / n * sum_d
                if pi_c < pi_d:
                    self.m += 1
                    if self.m > n:
                        self.m = n
        if self.punishment_active:
            if self.punishment_remaining > 0:
                self.punishment_remaining -= 1
                return Action.D
            else:
                self.punishment_active = False
                self.punishment_remaining = 0
        t_prev = current_round - 1
        if t_prev < 0:
            return Action.C
        my_prev_action = history.my_actions[t_prev]
        opponent_prev_actions = history.opponent_actions[t_prev, :]
        coop_count = my_prev_action + np.sum(opponent_prev_actions)
        if coop_count < self.m:
            T = 2 * r / self.m
            T = math.ceil(T)
            remaining_rounds = r - current_round
            if T > remaining_rounds:
                T = remaining_rounds
            self.punishment_active = True
            self.punishment_remaining = T
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_283(BaseStrategy):
    """
    Grim Trigger Strategy for N-Player Public Goods Game.

    This strategy Cooperates in the first round and continues to Cooperate as long as
    the number of cooperators in each previous round meets or exceeds the threshold.
    If the number of cooperators ever drops below the threshold, the strategy switches
    to Defect for all subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players
        self.punishing = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.punishing = False
            return Action.C
        elif self.punishing:
            return Action.D
        else:
            prev_round = state.round_number - 1
            prev_my_action = history.my_actions[prev_round]
            prev_opponent_actions = history.opponent_actions[prev_round]
            c = int(prev_my_action) + np.sum(prev_opponent_actions)
            if c < self.threshold:
                self.punishing = True
            return Action.D if self.punishing else Action.C

class Strategy_COLLECTIVE_285(BaseStrategy):
    """
    A strategy to sustain cooperation in public goods games by initially cooperating 
    and conditionally cooperating based on previous round's participation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_opp_actions = history.opponent_actions[-1, :]
        opp_coop = sum(prev_opp_actions)
        total_coop = prev_my_action + opp_coop
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_286(BaseStrategy):
    """
    Cooperative Reset with Punishment strategy.
    
    This strategy promotes sustained cooperation by reciprocating cooperation when a sufficient number
    of players cooperate in the previous round. If cooperation is below a threshold, the strategy punishes
    by defecting once, then resets to cooperation in the following round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: 'PlayerHistory | None') -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        if not history.my_actions[-1]:
            return Action.C
        prev_coop = 1 if history.my_actions[-1] else 0
        prev_coop += sum(history.opponent_actions[-1])
        if prev_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_287(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game where each player Cooperates if at least m players Cooperated in the previous round, otherwise Defects.
    m is calculated as the ceiling of (n / k) players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round, :]
        count_coop = my_prev_action + np.sum(opp_prev_actions)
        if count_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_288(BaseStrategy):
    """"""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.rng = random.Random()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.n_rounds - 3:
            count_m_poor = 0
            total_r = 0
            for t in range(1, 4):
                prev_r = state.round_number - t
                if prev_r < 0:
                    break
                my_coop = history.my_actions[prev_r]
                opp_coop = sum(history.opponent_actions[prev_r, :])
                total_coop_prev = my_coop + opp_coop
                if total_coop_prev < self.m:
                    count_m_poor += 1
                total_r += 1
            if total_r == 0:
                pass
            elif count_m_poor / total_r > 0.5:
                return Action.D
        last_round = state.round_number - 1
        my_coop = history.my_actions[last_round]
        opp_coop = sum(history.opponent_actions[last_round, :])
        total_coop_prev = my_coop + opp_coop
        if total_coop_prev >= self.m:
            return Action.C
        else:
            defect_prob = (self.m - total_coop_prev) / self.n_players
            if self.rng.random() < defect_prob:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_289(BaseStrategy):
    """
    Adaptive Collective Cooperation with Forgiveness strategy.
    Cooperates initially and continues if enough players cooperate; 
    defects once if cooperation drops below a threshold, then forgives 
    if cooperation is restored.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        prev_round = t - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        prev_coop_count = my_prev_action + np.sum(opponents_prev_actions)
        if prev_coop_count >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_291(BaseStrategy):
    """
    A strategy that starts with cooperation and continues to cooperate if enough players cooperated in the previous round.
    The threshold is calculated based on the game parameters to determine when cooperation is beneficial.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        m_prev = 0
        while True:
            required = (m_prev + 1) * k
            if required > n:
                break
            m_prev += 1
        self.m = m_prev

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        t_prev = state.round_number - 1
        my_prev_action = history.my_actions[t_prev]
        opponent_prev_actions = history.opponent_actions[t_prev, :] if t_prev < history.opponent_actions.shape[0] else np.zeros(history.opponent_actions.shape[1], dtype=bool)
        c_prev = my_prev_action + sum(opponent_prev_actions)
        if c_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_292(BaseStrategy):
    """
    A strategy that combines reciprocity with forgiveness to sustain cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)
        self.must_cooperate = False

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.must_cooperate:
            self.must_cooperate = False
            return Action.C
        previous_round = state.round_number - 1
        me_prev = history.my_actions[previous_round]
        others_prev = history.opponent_actions[previous_round, :]
        total_coop = int(me_prev) + sum(others_prev)
        if total_coop >= self.m:
            return Action.C
        else:
            self.must_cooperate = True
            return Action.D

class Strategy_COLLECTIVE_293(BaseStrategy):
    """
    A strategy that starts with cooperation, continues if sufficient players cooperate,
    defects when cooperation falters, and periodically retries cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.retry_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            my_prev_action = history.my_actions[-1]
            opponent_prev = history.opponent_actions[-1, :]
            s_prev = np.sum(opponent_prev) + (1 if my_prev_action else 0)
            if s_prev >= self.m:
                self.retry_counter = 0
                return Action.C
            elif my_prev_action:
                self.retry_counter = 1
                return Action.D
            elif self.retry_counter >= 3:
                self.retry_counter = 0
                return Action.C
            else:
                self.retry_counter += 1
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_294(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that encourages sustained cooperation.
    It starts with cooperation, continues if enough players cooperate, defects temporarily if cooperation is low,
    and resets cooperation after a threshold of defective rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.t_threshold = 2
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round, :]
        sum_prev = int(my_prev_action) + np.sum(opponent_prev_actions)
        if sum_prev >= self.m:
            self.consecutive_defects = 0
            return Action.C
        else:
            self.consecutive_defects += 1
            if self.consecutive_defects >= self.t_threshold:
                self.consecutive_defects = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_295(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that promotes cooperation by punishing insufficient participation.
    Cooperates initially, continues if enough players cooperate, and momentarily defects to enforce cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.onNextRoundCooperate = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.onNextRoundCooperate = False
            return Action.C
        if self.onNextRoundCooperate:
            self.onNextRoundCooperate = False
            return Action.C
        last_round = state.round_number - 1
        self_action = history.my_actions[last_round]
        opponent_actions = history.opponent_actions[last_round]
        c = sum(opponent_actions) + (1 if self_action else 0)
        if c < self.m:
            self.onNextRoundCooperate = True
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_296(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // self.game_description.k + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        my_prev_action = history.my_actions[prev_round]
        coop_prev = sum(opponent_actions_prev) + (1 if my_prev_action else 0)
        if coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_298(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        m = self.n_players * self.k / (self.k + 1)
        self.m = math.floor(m)
        self.m = max(1, self.m)
        self.m = min(self.m, self.n_players)
        self.last_action = None

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponent_prev = history.opponent_actions[prev_round, :]
            total_coops = my_prev + np.sum(opponent_prev)
            if total_coops >= self.m:
                self.last_action = Action.C
                return Action.C
            elif not my_prev:
                self.last_action = Action.C
                return Action.C
            else:
                self.last_action = Action.D
                return Action.D

class Strategy_COLLECTIVE_299(BaseStrategy):
    """
    A collective risk dilemma strategy that combines initial cooperation, adaptive mirroring, 
    trend-based cooperation, and forgiveness to encourage sustained collaboration.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.coop_rates = []
        self.max_window = 3
        self.forgiveness_prob = 0.2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        my_prev_action = history.my_actions[prev_round]
        total_coop_prev = sum(opponent_actions_prev) + (1 if my_prev_action else 0)
        coop_rate_prev = total_coop_prev / self.game_description.n_players
        self.coop_rates.append(coop_rate_prev)
        if len(self.coop_rates) > self.max_window:
            self.coop_rates.pop(0)
        trend_up = False
        if len(self.coop_rates) >= 2:
            trend_up = self.coop_rates[-1] > self.coop_rates[-2]
        n_players = self.game_description.n_players
        mirror_C = total_coop_prev > n_players / 2
        action = Action.D
        if mirror_C:
            action = Action.C
        elif trend_up:
            action = Action.C
        elif random.random() < self.forgiveness_prob:
            action = Action.C
        return action

class Strategy_COLLECTIVE_300(BaseStrategy):
    """
    A strategy that balances cooperation and punishment to maximize payoffs while encouraging collective success.
    Cooperates initially, then based on previous round's cooperation level, and uses majority in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = (self.game_description.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        previous_round = state.round_number - 1
        my_coop = history.my_actions[previous_round]
        opponents_coop = np.sum(history.opponent_actions[previous_round, :])
        s_prev = my_coop + opponents_coop
        if state.round_number == self.game_description.n_rounds - 1:
            if s_prev > n_players / 2:
                return Action.C
            else:
                return Action.D
        elif s_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_302(BaseStrategy):
    """
    A strategy to maintain cooperation in public goods game through punishment and recovery.
    Uses a threshold based on half the number of players to determine cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = math.ceil(self.n / 2.0)
        self.is_punishing = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_opponent_actions = history.opponent_actions[-1]
        total_coop_prev = prev_my_action + prev_opponent_actions.sum()
        if self.is_punishing:
            self.is_punishing = False
            return Action.C
        if total_coop_prev >= self.m:
            return Action.C
        else:
            self.is_punishing = True
            return Action.D

class Strategy_COLLECTIVE_303(BaseStrategy):
    """Cooperative Punishment with Reset Strategy.
    
    Cooperates initially, then continues to cooperate if a threshold of 
    previous round's cooperators is met. Defects once if the threshold 
    is not met and resets to cooperation afterwards.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // self.game_description.k + 1
        self.cooperate_next = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is None:
            return Action.C
        else:
            t = state.round_number
            prev_my_action = history.my_actions[t - 1]
            prev_opponent_actions = history.opponent_actions[t - 1]
            prev_coops = sum(prev_opponent_actions) + (1 if prev_my_action else 0)
            if not self.cooperate_next:
                action = Action.D
                self.cooperate_next = True
            elif prev_coops >= self.m:
                action = Action.C
                self.cooperate_next = True
            else:
                action = Action.D
                self.cooperate_next = False
            return action

class Strategy_COLLECTIVE_304(BaseStrategy):
    """
    Adaptive Cooperation Based on Recent History strategy for N-Player Public Goods Game.
    Cooperates initially, continues if sufficient players cooperated previously, 
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        prev_my_action = history.my_actions[-1]
        prev_opponent_actions = history.opponent_actions[-1]
        total_coop = prev_my_action + prev_opponent_actions.sum()
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_305(BaseStrategy):
    """
    A strategy that begins with cooperation and continues if sufficient players cooperate,
    defects otherwise, while always cooperating in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_action_prev = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        c_prev = my_action_prev + opponent_actions_prev.sum()
        m = self.game_description.k
        if c_prev >= m:
            return Action.C
        elif state.round_number < self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_306(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness (ACF) strategy.
    Cooperates initially, continues if threshold met, otherwise defects with increasing probability.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.current_p = 0.5
        self.failure_count = 0
        self.last_round = game_description.n_rounds - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.last_round:
            return Action.C
        previous_round = round_number - 1
        my_prev = history.my_actions[previous_round]
        opp_prev = history.opponent_actions[previous_round]
        prev_cooperators = int(my_prev) + int(opp_prev.sum())
        if prev_cooperators >= self.m:
            self.current_p = 0.5
            self.failure_count = 0
            return Action.C
        else:
            if random.random() < self.current_p:
                action = Action.D
            else:
                action = Action.C
            self.current_p += 0.1
            if self.current_p > 0.9:
                self.current_p = 0.9
            self.failure_count += 1
            return action

class Strategy_COLLECTIVE_307(BaseStrategy):
    """
    Adaptive Cooperation with Retaliation Strategy.

    This strategy starts by cooperating in the first round to encourage initial
    cooperation. In subsequent rounds, it evaluates the previous round's
    cooperation levels. If enough players cooperate, it continues to cooperate.
    If a significant number defect, it retaliates by defecting for a set number
    of rounds. In the last round, it defects if the previous round had low
    cooperation, otherwise it cooperates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.cooperation_threshold = self.n_players // 2
        self.retaliating = False
        self.retaliate_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.retaliating and self.retaliate_rounds > 0:
            self.retaliate_rounds -= 1
            if self.retaliate_rounds == 0:
                self.retaliating = False
            return Action.D
        opponent_actions_last = history.opponent_actions[-1, :]
        num_coop = sum(opponent_actions_last)
        if state.round_number == self.n_rounds - 1:
            if num_coop < self.n_players * 0.5:
                return Action.D
            else:
                return Action.C
        elif num_coop >= self.cooperation_threshold:
            return Action.C
        else:
            percent_defectors = 1.0 - num_coop / self.n_players
            if percent_defectors >= 0.5:
                self.retaliating = True
                self.retaliate_rounds = 2
            return Action.D

class Strategy_COLLECTIVE_308(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness strategy for Public Goods Game.
    Cooperates initially, then based on majority threshold in past rounds.
    Forgives in endgame round with 50% chance if threshold not met.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n // 2 + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if history is None:
            return Action.C
        if current_round == self.r - 1:
            prev_round = current_round - 1
            my_action = history.my_actions[prev_round]
            opponent_actions = history.opponent_actions[prev_round, :]
            prev_coop_count = sum([my_action] + opponent_actions.tolist())
            if prev_coop_count >= self.m:
                return Action.C
            elif random.random() < 0.5:
                return Action.C
            else:
                return Action.D
        else:
            threshold_met = 0
            for past_round in range(current_round):
                my_act = history.my_actions[past_round]
                opponent_acts = history.opponent_actions[past_round, :]
                total_coop = sum([my_act]) + sum(opponent_acts)
                if total_coop >= self.m:
                    threshold_met += 1
            total_past = current_round
            if total_past == 0:
                ratio = 0.0
            else:
                ratio = threshold_met / total_past
            if ratio > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_309(BaseStrategy):
    """
    A strategy that promotes cooperation based on the number of previous round cooperators.
    It starts with cooperation, continues as long as a threshold is met, and can recover from defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        my_prev_action = history.my_actions[prev_round]
        c_prev = sum(opponent_actions_prev) + (1 if my_prev_action else 0)
        if not my_prev_action:
            return Action.C
        if c_prev >= self.game_description.k:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_310(BaseStrategy):
    """
    Adaptive Collective Cooperation with Temporary Punishment strategy.
    Cooperates unless previous round had fewer than m cooperators.
    If so, defects once then reverts to cooperating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.punishing = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishing:
            self.punishing = False
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round, :]
            total_coop_prev = my_prev_action + opponent_prev_actions.sum()
            if total_coop_prev >= self.m:
                return Action.C
            else:
                self.punishing = True
                return Action.D

class Strategy_COLLECTIVE_311(BaseStrategy):
    """
    Adaptive Cooperation Strategy based on past performance. 
    Cooperates if the number of cooperating players in the previous round meets a calculated threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            r = state.round_number - 1
            my_action = history.my_actions[r]
            opp_actions = history.opponent_actions[r]
            count_C = int(my_action) + sum(opp_actions)
            if count_C >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_312(BaseStrategy):
    """
    Adaptive Cooperate-Punish-Forgive strategy to balance cooperation and punishment.
    Cooperates initially, punishes for up to 3 rounds if cooperation is insufficient, then resumes cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defect_count = 0
        self.m = math.ceil(game_description.k / (game_description.k + 1) * game_description.n_players)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        sum_coop = int(my_prev_action) + np.sum(opp_prev_actions)
        if sum_coop >= self.m:
            self.defect_count = 0
            return Action.C
        elif self.defect_count < 3:
            self.defect_count += 1
            return Action.D
        else:
            self.defect_count = 0
            return Action.C

class Strategy_COLLECTIVE_313(BaseStrategy):
    """
    A collective strategy for the N-player public goods game that encourages cooperation
    by dynamically adjusting based on previous round outcomes, with a punishment
    and retry mechanism.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // self.game_description.k + 1
        self.punishing = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.punishing = False
            return Action.C
        if state.round_number == 0:
            self.punishing = False
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            sum_prev = sum(history.opponent_actions[-1, :])
            if history.my_actions[-1]:
                sum_prev += 1
            if sum_prev >= self.m:
                return Action.C
            else:
                return Action.D
        elif self.punishing:
            self.punishing = False
            return Action.C
        else:
            sum_prev = sum(history.opponent_actions[-1, :])
            if history.my_actions[-1]:
                sum_prev += 1
            if sum_prev >= self.m:
                return Action.C
            else:
                self.punishing = True
                return Action.D

class Strategy_COLLECTIVE_314(BaseStrategy):
    """
    Adaptive Threshold Cooperation with Forgiveness strategy.
    Cooperates if the number of previous cooperators meets a threshold, otherwise defects for a limited number of rounds before cooperating again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.n_players // game_description.k + 1
        self.max_defections = 3
        self.defection_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_my_c = int(prev_my_action)
        prev_others_c = sum(history.opponent_actions[-1])
        prev_total_c = prev_my_c + prev_others_c
        if prev_total_c >= self.cooperation_threshold:
            self.defection_count = 0
            return Action.C
        elif self.defection_count < self.max_defections:
            self.defection_count += 1
            return Action.D
        else:
            self.defection_count = 0
            return Action.C

class Strategy_COLLECTIVE_315(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that promotes cooperation while responding to failures.
    It starts by cooperating, continues if previous cooperation was sufficient, defects otherwise, 
    and attempts to recover cooperation after a defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k) if k != 0 else n
        self.last_defection = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        if history is None or prev_round >= len(history.my_actions):
            return Action.C
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        prev_total_c = my_prev_action + np.sum(opponents_prev_actions)
        if self.last_defection:
            action = Action.C
            self.last_defection = False
        elif prev_total_c >= self.m:
            action = Action.C
        else:
            action = Action.D
            self.last_defection = True
        return action

class Strategy_COLLECTIVE_316(BaseStrategy):
    """
    A strategy for the N-player public goods game that encourages cooperation based on previous round outcomes.
    Players cooperate in the first round and subsequently based on whether the previous round's payoff met a threshold (k or 1 + k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_payoff = history.my_payoffs[-1]
        k = self.game_description.k
        epsilon = 1e-09
        if abs(last_payoff - k) < epsilon or abs(last_payoff - (1 + k)) < epsilon:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_317(BaseStrategy):
    """A strategy that maintains cooperation if the number of cooperators meets a threshold based on k."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.k
        self.n_players = self.game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponent_actions = history.opponent_actions[prev_round]
        total_cooperators = sum(prev_opponent_actions)
        if prev_my_action:
            total_cooperators += 1
        if total_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_318(BaseStrategy):
    """
    An adaptive strategy for the N-player public goods game that balances cooperation 
    and defection based on past outcomes to avoid exploitation while encouraging 
    beneficial cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.floor(n / k) + 1
        self.consecutive_defects = 0
        self.pending_cooperate = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.pending_cooperate:
            self.pending_cooperate = False
            self.consecutive_defects = 0
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        s = my_prev_action + sum(opponent_actions_prev)
        if s >= self.m:
            self.consecutive_defects = 0
            return Action.C
        else:
            self.consecutive_defects += 1
            if self.consecutive_defects == 2:
                self.pending_cooperate = True
            return Action.D

class Strategy_COLLECTIVE_319(BaseStrategy):
    """
    Adaptive Cooperation with Rebound Strategy.

    This strategy encourages cooperation by starting with cooperation and adaptively 
    responding to the number of cooperators in previous rounds. If the number of 
    cooperators meets a threshold, the player continues to cooperate. Otherwise, 
    the player defects for a set number of rounds before reverting to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.rebound_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.rebound_counter > 0:
            self.rebound_counter -= 1
            return Action.D
        my_prev_action = 1 if history.my_actions[-1] else 0
        sum_others = np.sum(history.opponent_actions[-1])
        c_prev = my_prev_action + sum_others
        if c_prev >= self.m:
            return Action.C
        else:
            self.rebound_counter = 2
            return Action.D

class Strategy_COLLECTIVE_320(BaseStrategy):
    """
    Adaptive Cooperation with Punishment and Forgiveness Strategy.
    Cooperates initially, punishes when a cooperation threshold isn't met, 
    and forgives after a few defections. Handles the last round specially.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.floor(n / k) + 1
        self.m = min(self.m, n)
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.game_description.n_rounds - 1:
            total_prev_coops = 0
            for r in range(current_round):
                own_action = int(history.my_actions[r])
                others_actions = sum(history.opponent_actions[r, :])
                total_prev_coops += own_action + others_actions
            threshold = self.m * current_round
            if total_prev_coops >= threshold:
                return Action.C
            else:
                prev_round = current_round - 1
                own_prev = int(history.my_actions[prev_round])
                others_prev = sum(history.opponent_actions[prev_round, :])
                prev_coop = own_prev + others_prev
                if self.m - prev_coop <= 0:
                    return Action.C
                else:
                    return Action.D
        elif history is None:
            return Action.C
        else:
            own_prev_action = int(history.my_actions[-1])
            prev_opp_actions = history.opponent_actions[-1, :]
            others_coop = sum(prev_opp_actions)
            cooperative_prev = own_prev_action + others_coop
            if cooperative_prev >= self.m:
                self.consecutive_defections = 0
                return Action.C
            else:
                self.consecutive_defections += 1
                if self.consecutive_defections >= 2:
                    self.consecutive_defections = 0
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_321(BaseStrategy):
    """
    A strategy to maintain cooperation in public goods games by periodically 
    attempting to restart cooperation after defections.
    Inherits from BaseStrategy and implements the described approach.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.d = 2
        self.consecutive_defections = 0
        self.last_coops = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            if history is None:
                return Action.D
            my_prev = history.my_actions[prev_round]
            opponents_prev = history.opponent_actions[prev_round, :]
            sum_prev = my_prev + sum(opponents_prev)
            if sum_prev >= self.m:
                self.consecutive_defections = 0
                self.last_coops = sum_prev
                return Action.C
            elif self.consecutive_defections < self.d:
                self.consecutive_defections += 1
                self.last_coops = sum_prev
                return Action.D
            else:
                self.consecutive_defections = 0
                self.last_coops = sum_prev
                return Action.C

class Strategy_COLLECTIVE_322(BaseStrategy):
    """
    Adaptive Historical Cooperation (AHC) strategy for N-Player Public Goods Game.
    Cooperates in the first round, then continues based on historical success rate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.floor(n / k) + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        success_count = 0
        for round in range(state.round_number):
            my_c = history.my_actions[round]
            opp_actions = history.opponent_actions[round]
            opp_c = np.sum(opp_actions)
            total_c = my_c + opp_c
            if total_c >= self.m:
                success_count += 1
        success_rate = success_count / state.round_number
        if success_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_323(BaseStrategy):
    """
    This strategy Cooperates in the first round. In subsequent rounds, it Cooperates if the number of cooperators in the previous round was below a dynamically calculated threshold (m). If the previous round's cooperators met or exceeded this threshold, it checks if its own cooperation was necessary and acts accordingly.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_my_action_int = 1 if prev_my_action else 0
        opponent_actions_prev = history.opponent_actions[-1, :].astype(int)
        total_coop_prev = prev_my_action_int + sum(opponent_actions_prev)
        if total_coop_prev < self.m:
            return Action.C
        elif total_coop_prev - prev_my_action_int < self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_324(BaseStrategy):
    """
    A strategy that starts with full cooperation and adapts based on the number of cooperators in previous rounds.
    Players cooperate if the number of cooperators meets a threshold; otherwise, they defect with a probability proportional to the shortfall.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            opponent_last_round = history.opponent_actions[-1, :]
            my_last_action = history.my_actions[-1]
            x_prev = sum(opponent_last_round) + (1 if my_last_action else 0)
            if x_prev >= self.m:
                return Action.C
            else:
                p_defect = (self.m - x_prev) / self.n_players
                p_defect = max(0, min(p_defect, 1))
                return Action.D if random.random() < p_defect else Action.C

class Strategy_COLLECTIVE_325(BaseStrategy):
    """
    An adaptive strategy for the Public Goods Game that balances cooperation based on past success.
    Cooperates in the first round, then adjusts cooperation probability according to the fraction of successful rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.p_min = 0.1
        self.p_max = 0.9

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_payoffs = history.my_payoffs
        success_count = 0
        for i in range(state.round_number):
            if my_payoffs[i] > 1:
                success_count += 1
        success_rate = success_count / state.round_number
        cooperation_prob = success_rate
        cooperation_prob = max(cooperation_prob, self.p_min)
        cooperation_prob = min(cooperation_prob, self.p_max)
        if random.random() < cooperation_prob:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_326(BaseStrategy):
    """
    Forgiving Cooperation with Temporary Punishment Strategy.
    
    This strategy encourages sustained cooperation by punishing insufficient cooperation
    with temporary defection while allowing recovery. Players cooperate initially, defect
    if not enough players cooperated in the previous round, and attempt to recover cooperation
    in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.n_players / game_description.k) + 1
        self.cooperate_next_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.cooperate_next_round:
            self.cooperate_next_round = False
            return Action.C
        previous_round = state.round_number - 1
        my_prev = history.my_actions[previous_round]
        others_prev = history.opponent_actions[previous_round, :]
        count_c = my_prev + np.sum(others_prev)
        if count_c >= self.m:
            return Action.C
        else:
            self.cooperate_next_round = True
            return Action.D

class Strategy_COLLECTIVE_327(BaseStrategy):
    """
    Strategy that begins with cooperation and adaptively responds based on previous round's cooperation level.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.floor(self.k)
        if self.m < 1:
            self.m = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round, :]
        sum_opponents = sum(opponent_actions_prev)
        my_action_prev = history.my_actions[previous_round]
        total_coop = sum_opponents + (1 if my_action_prev else 0)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_328(BaseStrategy):
    """Adaptive Cooperator with Historical Thresholding strategy.

    This strategy promotes cooperation by starting with cooperation, then adapting
    based on historical cooperation rates. It encourages sustained contribution
    to public goods by rewarding past cooperation and punishing defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        m_float = n / k
        if m_float == int(m_float):
            m = int(m_float) + 1
        else:
            m = math.ceil(m_float)
        self.m = m

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            sum_coop = 0
            for s in range(state.round_number):
                opp_actions = history.opponent_actions[s, :]
                own_act = history.my_actions[s]
                cooperators = sum(opp_actions) + (1 if own_act else 0)
                sum_coop += cooperators
            average = sum_coop / state.round_number
            if average >= self.m:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = state.round_number - 1
            opp_actions_prev = history.opponent_actions[prev_round, :]
            own_act_prev = history.my_actions[prev_round]
            cooperators_prev = sum(opp_actions_prev) + (1 if own_act_prev else 0)
            if cooperators_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_330(BaseStrategy):
    """A strategy that starts with cooperation and adapts based on past cooperation levels, defecting temporarily when a cooperation threshold is not met, then forgiving and reverting to cooperation after a few rounds."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.defect_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_last = history.my_actions[prev_round]
            opponent_last = history.opponent_actions[prev_round, :]
            total_coop_last = sum(opponent_last) + (1 if my_last else 0)
            if total_coop_last >= self.m:
                self.defect_counter = 0
                return Action.C
            elif self.defect_counter < 2:
                self.defect_counter += 1
                return Action.D
            else:
                self.defect_counter = 0
                return Action.C

class Strategy_COLLECTIVE_331(BaseStrategy):
    """
    Grim Trigger strategy: Cooperates until any previous round has fewer than m cooperators. 
    After which, all rounds defect. m is set to n_players, requiring all to cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        for prev_round in range(state.round_number):
            my_action = history.my_actions[prev_round]
            my_c = 1 if my_action else 0
            opp_actions = history.opponent_actions[prev_round, :]
            opp_c = sum(opp_actions)
            total_c = my_c + opp_c
            if total_c < self.m:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_332(BaseStrategy):
    """
    Forgiving Reciprocal Cooperation strategy for N-player public goods game.
    
    The strategy promotes initial cooperation. If the number of cooperators in the previous round meets or exceeds a threshold (n_players//2), the player cooperates. Otherwise, the player defects once as punishment but returns to cooperation in the subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.last_defected = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.last_defected:
            self.last_defected = False
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round].item()
        opponents_actions_prev = history.opponent_actions[prev_round]
        total_coop = my_prev_action + np.count_nonzero(opponents_actions_prev)
        if total_coop >= self.m:
            return Action.C
        else:
            self.last_defected = True
            return Action.D

class Strategy_COLLECTIVE_333(BaseStrategy):
    """
    A strategy that encourages cooperation by punishing rounds with insufficient cooperation.
    It starts by cooperating, then punishes if the number of cooperators falls below a threshold,
    and resumes cooperation if sufficient players cooperate again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[state.round_number - 1]
        opponent_prev_actions = history.opponent_actions[state.round_number - 1, :]
        prev_coop = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
        if prev_coop < self.m:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_334(BaseStrategy):
    """
    A strategy that promotes cooperation by rewarding collective efforts and 
    punishing defection temporarily. The strategy cooperates initially, continues 
    if enough players cooperate, and defects for 3 rounds if cooperation is low.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        m = math.ceil(game_description.n_players / game_description.k)
        if m > game_description.n_players:
            m = game_description.n_players
        self.m = m
        self.in_punishment = False
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        previous_round = round_number - 1
        my_action_prev = history.my_actions[previous_round]
        opponents_prev = history.opponent_actions[previous_round, :]
        sum_prev = my_action_prev + np.sum(opponents_prev)
        if self.in_punishment:
            action = Action.D
            self.punishment_remaining -= 1
            if self.punishment_remaining <= 0:
                self.in_punishment = False
        elif sum_prev >= self.m:
            action = Action.C
        else:
            action = Action.D
            self.in_punishment = True
            self.punishment_remaining = 3
        return action

class Strategy_COLLECTIVE_335(BaseStrategy):
    """
    Cooperative Punishment with Forgiveness strategy.
    Cooperates initially, punishes non-cooperation, then forgives.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.prev_punished = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif self.prev_punished:
            self.prev_punished = False
            return Action.C
        else:
            previous_round = state.round_number - 1
            my_prev_action = history.my_actions[previous_round]
            sum_opponent_prev = np.sum(history.opponent_actions[previous_round])
            count_prev = sum_opponent_prev + (1 if my_prev_action else 0)
            if count_prev >= self.m:
                return Action.C
            else:
                self.prev_punished = True
                return Action.D

class Strategy_COLLECTIVE_336(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness strategy for Public Goods Game.
    Cooperates initially and continues if enough players cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)
        if self.m > n:
            self.m = n

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_actions = history.opponent_actions[prev_round]
            total_coop = my_prev_action + sum(opponents_actions)
            return Action.C if total_coop >= self.m else Action.D

class Strategy_COLLECTIVE_337(BaseStrategy):
    """
    Adaptive cooperation strategy based on historical success rate of meeting a cooperator threshold.
    Cooperates in the first round and adapts based on the proportion of successful previous rounds.
    A round is successful if the total number of cooperators meets or exceeds a calculated threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.n = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        count_success = 0
        for round_t in range(state.round_number):
            my_action = history.my_actions[round_t]
            opponents_actions = history.opponent_actions[round_t]
            total_c = my_action + sum(opponents_actions)
            if total_c >= self.m:
                count_success += 1
        success_rate = count_success / state.round_number
        threshold = self.m / self.n
        if success_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_338(BaseStrategy):
    """
    An adaptive strategy promoting cooperation through punishment and forgiveness.
    Players initially cooperate, punish when cooperation falls below a threshold,
    and then forgive to reset cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponent_prev_actions = history.opponent_actions[-1]
        c_prev = (1 if my_prev_action else 0) + sum(opponent_prev_actions)
        if c_prev >= self.m:
            return Action.C
        elif not my_prev_action:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_339(BaseStrategy):
    """
    Responsive Cooperation with Recovery strategy.
    Cooperates initially, then responds to the number of cooperators in the previous round.
    Defects briefly if cooperation threshold isn't met, then attempts to recover cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.consecutive_defects = 0
        self.last_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.last_action = action
            return action
        else:
            my_prev_action = Action.C if history.my_actions[-1] else Action.D
            opponent_prev_actions = history.opponent_actions[-1]
            previous_c = np.sum(opponent_prev_actions) + (1 if my_prev_action == Action.C else 0)
            if previous_c >= self.m:
                self.consecutive_defects = 0
                action = Action.C
            elif my_prev_action == Action.D:
                self.consecutive_defects += 1
                if self.consecutive_defects > 1:
                    self.consecutive_defects = 0
                    action = Action.C
                else:
                    action = Action.D
            else:
                self.consecutive_defects = 0
                action = Action.D
            self.last_action = action
            return action

class Strategy_COLLECTIVE_341(BaseStrategy):
    """
    Cooperative Punisher with Forgiveness Strategy.

    Cooperates in the first round. For subsequent rounds, if the number of cooperators 
    in the previous round is at least half the number of players, continues to cooperate. 
    Otherwise, defects once as punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_prev_action = history.my_actions[t_prev]
        opponent_actions_prev = history.opponent_actions[t_prev]
        cooperators = sum(opponent_actions_prev) + (1 if my_prev_action else 0)
        if cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_342(BaseStrategy):
    """
    Cooperate in the first round and continue cooperating as long as at least 
    m players cooperated in the previous round, where m is the ceiling of 
    (n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        my_action = history.my_actions[-1]
        total_coop = sum(opponent_actions) + (1 if my_action else 0)
        if total_coop >= self.m:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_344(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages sustained cooperation by penalizing only when necessary.
    Players cooperate unless fewer than m players cooperated in the previous round, in which case they defect once
    and revert to cooperation in the next round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players - 1
        self.will_cooperate_next = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.will_cooperate_next:
            self.will_cooperate_next = False
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            cooperators_prev = my_prev_action + np.sum(opponents_prev_actions)
            if cooperators_prev >= self.m:
                return Action.C
            else:
                self.will_cooperate_next = True
                return Action.D

class Strategy_COLLECTIVE_345(BaseStrategy):
    """
    Collective Risk Dilemma Strategy: Adaptive Cooperation with Forgiveness.

    Players start by cooperating. They continue to cooperate if enough others
    did so in the previous round; otherwise, they defect. After three consecutive
    rounds of insufficient cooperation, they cooperate again to encourage reset.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.defect_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        my_prev = 1 if my_prev_action else 0
        opp_prev_actions = history.opponent_actions[prev_round, :]
        opp_prev = sum(opp_prev_actions)
        total_coop_prev = my_prev + opp_prev
        if total_coop_prev >= self.m:
            self.defect_streak = 0
            return Action.C
        else:
            self.defect_streak += 1
            if self.defect_streak >= 3:
                self.defect_streak = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_346(BaseStrategy):
    """
    A strategy that begins by cooperating to foster trust, then continues to cooperate if enough players 
    cooperated in the previous round or if there's an improving trend in cooperation. Defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = (self.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        coop_prev = int(my_prev_action) + sum(opponent_prev_actions)
        if coop_prev >= self.m:
            return Action.C
        if prev_round < 1:
            return Action.D
        prev_prev_round = prev_round - 1
        my_prev_prev = history.my_actions[prev_prev_round]
        opponent_prev_prev = history.opponent_actions[prev_prev_round]
        coop_prev_prev = int(my_prev_prev) + sum(opponent_prev_prev)
        trend = coop_prev > coop_prev_prev
        if trend:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_347(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy.
    Cooperates initially, defects if insufficient cooperation, forgives after two rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round]
            s_prev = (1 if my_prev_action else 0) + np.sum(opponent_prev_actions)
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.C if s_prev >= self.m else Action.D
            elif s_prev >= self.m:
                self.consecutive_defects = 0
                return Action.C
            elif self.consecutive_defects < 2:
                self.consecutive_defects += 1
                return Action.D
            else:
                self.consecutive_defects = 0
                return Action.C

class Strategy_COLLECTIVE_348(BaseStrategy):
    """
    A strategy to maintain cooperation in repeated public goods games through initial cooperation,
    responsive punishment, and informed final round decisions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // self.game_description.k + 1
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            total_coop = 0.0
            for t in range(state.round_number):
                my_action = history.my_actions[t]
                opp_actions = history.opponent_actions[t, :]
                total_coop += my_action + np.sum(opp_actions)
            average = total_coop / state.round_number
            return Action.C if average >= self.m else Action.D
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opp_prev = history.opponent_actions[prev_round, :]
        total_prev = my_prev + np.sum(opp_prev)
        return Action.C if total_prev >= self.m else Action.D

class Strategy_COLLECTIVE_349(BaseStrategy):
    """
    A strategy that initially cooperates, reciprocates cooperation based on the previous round's participation, 
    and ensures cooperation in the final round to maximize public good benefits.

    - Cooperates in the first round to establish trust.
    - Cooperates in subsequent rounds if enough players (based on k factor) cooperated in the previous round.
    - Always cooperates in the final round to maximize the chance of achieving higher payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            return Action.C
        else:
            prev_round = current_round - 1
            my_action_prev = history.my_actions[prev_round]
            opponent_actions_prev = history.opponent_actions[prev_round]
            total_cooperators = int(my_action_prev) + opponent_actions_prev.sum()
            if total_cooperators >= self.k:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_350(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy.
    
    This strategy encourages sustained cooperation by starting with cooperation,
    then adapting based on previous rounds' outcomes. It forgives occasional
    defections by attempting cooperation again after one round of defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)
        self.defect_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_opponent_actions = history.opponent_actions[-1, :]
        coop_count = 0
        if prev_my_action:
            coop_count += 1
        coop_count += np.count_nonzero(prev_opponent_actions)
        if coop_count >= self.m:
            self.defect_streak = 0
            return Action.C
        else:
            self.defect_streak += 1
            if self.defect_streak > 1:
                self.defect_streak = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_352(BaseStrategy):
    """
    A strategy that starts with cooperation and continues if the previous round's 
    cooperation meets a threshold, otherwise defects but tries to cooperate again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            last_round = state.round_number - 1
            my_last_action = history.my_actions[last_round]
            opponent_last_actions = history.opponent_actions[last_round]
            total_coop = my_last_action + sum(opponent_last_actions)
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_353(BaseStrategy):
    """
    Adaptive Cooperator with Forgiveness Strategy.
    Cooperates if at least m players cooperated in the previous round;
    defects otherwise. Resets cooperation after y consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.y = 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        others_prev_actions = history.opponent_actions[prev_round, :]
        others_coop = np.sum(others_prev_actions)
        total_coop = int(my_prev_action) + others_coop
        if total_coop >= self.m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections >= self.y:
                self.consecutive_defections = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_354(BaseStrategy):
    """
    A deterministic strategy for N-player public goods game focusing on maintaining cooperation.
    Players cooperate initially and adjust based on the previous round's cooperation level.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        t = state.round_number
        my_prev_action = history.my_actions[t - 1]
        opp_prev_actions = history.opponent_actions[t - 1, :]
        sum_opp = np.sum(opp_prev_actions)
        prev_coop = my_prev_action + sum_opp
        if prev_coop >= self.m:
            current_action = my_prev_action
        else:
            current_action = not my_prev_action
        return Action.C if current_action else Action.D

class Strategy_COLLECTIVE_355(BaseStrategy):
    """
    Adaptive Collective Cooperation Strategy.

    Encourages cooperation by rewarding group cooperation with continued cooperative 
    behavior and punishing deviations, including a forgiveness mechanism to revert 
    to cooperation once the group meets the cooperation threshold again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.state = 'coop'

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        my_c = 1 if my_prev_action else 0
        opponents_prev = history.opponent_actions[prev_round, :]
        opponents_c = np.sum(opponents_prev)
        total_coop_prev = my_c + opponents_c
        if total_coop_prev >= self.m:
            if self.state == 'defect':
                self.state = 'coop'
            return Action.C
        else:
            if self.state == 'coop':
                self.state = 'defect'
            return Action.D

class Strategy_COLLECTIVE_357(BaseStrategy):
    """
    A strategy for the Public Goods Game where players cooperate if at least m players cooperated in the previous round.
    m is calculated as the ceiling of (number of players divided by the multiplication factor k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponents_last = history.opponent_actions[last_round]
        total_coop = my_last_action + np.sum(opponents_last)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_358(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that promotes cooperation 
    through a deterministic punishment mechanism, allowing recovery from 
    breakdowns in cooperation. Players cooperate initially and continue to do 
    so unless the number of cooperators falls below a threshold, triggering a 
    round of defection as punishment. After punishment, cooperation resumes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        m = n // k + 1
        if m > n:
            m = n
        self.m = m

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my = history.my_actions[state.round_number - 1]
        prev_opp = history.opponent_actions[state.round_number - 1, :]
        cooperation_count = int(prev_my) + int(sum(prev_opp))
        if not prev_my:
            return Action.C
        elif cooperation_count >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_359(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Performance Strategy.
    
    This strategy starts with cooperation, then adapt based on the number of
    cooperators in the previous round. It uses a threshold (m) derived from the
    game's multiplication factor (k) to decide cooperation or defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        my_last_action = history.my_actions[-1]
        opponent_last_actions = history.opponent_actions[-1, :]
        prev_coop_count = sum(opponent_last_actions) + int(my_last_action)
        if prev_coop_count >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_360(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy.

    Cooperates in the first and last rounds. For other rounds, cooperates if the number of cooperators
    in the previous round meets or exceeds a majority threshold. Defects otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2 + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.C
        prev_round = state.round_number - 1
        my_action_prev = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        my_c = 1 if my_action_prev else 0
        opponent_c = np.sum(opponent_actions_prev)
        total_c = my_c + opponent_c
        if total_c >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_361(BaseStrategy):
    """
    Cooperative Reset Strategy for N-Player Public Goods Game.
    
    This strategy encourages sustained cooperation while allowing recovery from temporary failures.
    It starts with cooperation, continues if enough players cooperate, defects once if cooperation falls below a threshold,
    and then resets to cooperation regardless of the outcome after defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = self.n_players // self.k + 1
        self.force_cooperate_next = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.force_cooperate_next = False
            return Action.C
        if self.force_cooperate_next:
            self.force_cooperate_next = False
            return Action.C
        else:
            if history is None:
                return Action.C
            my_action = history.my_actions[-1]
            opp_actions = history.opponent_actions[-1, :]
            s_prev = sum(opp_actions) + (1 if my_action else 0)
            if s_prev >= self.m:
                return Action.C
            else:
                self.force_cooperate_next = True
                return Action.D

class Strategy_COLLECTIVE_362(BaseStrategy):
    """
    A strategy that encourages sustained cooperation by using a threshold 
    mechanism based on the number of cooperators in the previous round.
    Cooperates as long as the number of previous cooperators meets or exceeds a 
    calculated threshold, otherwise defects to signal dissatisfaction, but allows 
    recovery if cooperation levels improve.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_prev = history.my_actions[t_prev]
        opponents_prev = history.opponent_actions[t_prev]
        my_contrib = 1 if my_prev else 0
        opponents_contrib = sum(opponents_prev)
        tc_prev = my_contrib + opponents_contrib
        if tc_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_363(BaseStrategy):
    """
    Adaptive Cooperation Strategy that starts with cooperation and adapts based on previous rounds' outcomes.
    Cooperates if at least half of the players cooperated in the previous round; otherwise, defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponents_coop = sum(history.opponent_actions[prev_round, :])
        my_coop = int(history.my_actions[prev_round])
        total_coop = opponents_coop + my_coop
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_364(BaseStrategy):
    """
    An adaptive strategy that adjusts cooperation probability based on the group's recent success rate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = (self.n_players + 1) // 2
        self.p = 0.8

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            if random.random() < self.p:
                return Action.C
            else:
                return Action.D
        else:
            s = 0
            for t_round in range(t):
                my_c = history.my_actions[t_round]
                opponents_c = history.opponent_actions[t_round, :]
                total_c = my_c + sum(opponents_c)
                if total_c >= self.m:
                    s += 1
            success_rate = s / t
            if success_rate > 0.6:
                self.p += 0.1
            else:
                self.p -= 0.15
            self.p = max(0.3, min(self.p, 1.0))
            if random.random() < self.p:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_365(BaseStrategy):
    """
    A strategy that maintains cooperation by Cooperating if the number of cooperators 
    in the previous round meets or exceeds a threshold, and Defecting otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        own_prev_action = history.my_actions[previous_round]
        opp_prev_actions = history.opponent_actions[previous_round, :]
        c_prev = int(own_prev_action) + int(opp_prev_actions.sum())
        if c_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_366(BaseStrategy):
    """
    A strategy that promotes sustained cooperation with a recovery mechanism after failures.
    Cooperates initially, continues if enough players cooperate, otherwise defects once then tries again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m_threshold = math.ceil(game_description.n_players / game_description.k)
        self.forced_cooperate_next_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            if self.forced_cooperate_next_round:
                action = Action.C
                self.forced_cooperate_next_round = False
            else:
                prev_round = state.round_number - 1
                my_prev_action = history.my_actions[prev_round]
                opponent_actions_prev = history.opponent_actions[prev_round]
                total_coop_prev = sum(opponent_actions_prev) + my_prev_action
                if total_coop_prev >= self.m_threshold:
                    action = Action.C
                else:
                    action = Action.D
                    self.forced_cooperate_next_round = True
            return action

class Strategy_COLLECTIVE_367(BaseStrategy):
    """
    A strategy that adapts cooperation based on recent history.
    Cooperates if a majority of the last three rounds met the threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = (game_description.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        count = 0
        start_round = max(0, t - 3)
        end_round = t
        for round in range(start_round, end_round):
            my_action = 1 if history.my_actions[round] else 0
            opponent_actions = history.opponent_actions[round, :]
            sum_opp = np.sum(opponent_actions)
            s = my_action + sum_opp
            if s >= self.m:
                count += 1
        total_rounds = end_round - start_round
        if count > total_rounds / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_368(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages cooperation until a threshold is met, 
    then allows defection once the threshold is crossed. The threshold is calculated based on the game's 
    parameters to determine when individual contributions are necessary for achieving the public good.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k) if k != 0 else n

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            my_prev_action = history.my_actions[-1]
            opponents_prev_actions = history.opponent_actions[-1, :]
            c_prev = int(my_prev_action) + int(np.sum(opponents_prev_actions))
            if c_prev < self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_369(BaseStrategy):
    """
    A Strategy for the N-Player Public Goods Game that encourages cooperation
    by monitoring others' behavior and adapting based on a threshold of
    minimum cooperators required. Cooperates initially, then either continues
    cooperating or defects based on the previous round's cooperation level.
    Resets cooperation attempt after three consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = history.my_actions[-1]
        my_coop_prev = 1 if prev_round else 0
        opp_coop_prev = np.sum(history.opponent_actions[-1, :])
        total_coop_prev = my_coop_prev + opp_coop_prev
        if total_coop_prev >= self.m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections >= 3:
                self.consecutive_defections = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_370(BaseStrategy):
    """
    Implements a strategy to adaptively encourage cooperation in a public goods game.
    Players cooperate if the number of cooperators in the previous round met a threshold,
    otherwise adjust based on their player ID.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)
        self.n_players = n
        self.id = id(self)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponent_prev = history.opponent_actions[prev_round, :]
        c_prev = my_prev + opponent_prev.sum()
        if c_prev >= self.m:
            return Action.C
        else:
            s = self.n_players - c_prev + 1
            target = self.m - c_prev
            if self.id % s < target:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_371(BaseStrategy):
    """
    An adaptive strategy that encourages cooperation and restarts cooperation 
    after a series of consecutive failures based on collective outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.s = self.m
        self.consecutive_failures = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_failures = 0
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_opp_actions = history.opponent_actions[-1, :]
        prev_coop_total = prev_my_action + prev_opp_actions.sum()
        if prev_coop_total >= self.m:
            self.consecutive_failures = 0
            return Action.C
        else:
            self.consecutive_failures += 1
            if self.consecutive_failures < self.s:
                return Action.D
            else:
                self.consecutive_failures = 0
                return Action.C

class Strategy_COLLECTIVE_372(BaseStrategy):
    """
    Strategy that adapts based on recent cooperation levels using a moving window of past actions.
    Cooperates if the average cooperation in recent rounds meets a threshold; otherwise, defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m_threshold = 0.5 * game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_prev_rounds = len(history.my_actions)
        window_size = min(n_prev_rounds, 3)
        start_idx = n_prev_rounds - window_size
        cooperation_counts = []
        for r in range(start_idx, n_prev_rounds):
            my_coop = 1 if history.my_actions[r] else 0
            opponent_coops = np.sum(history.opponent_actions[r, :])
            total_coop = my_coop + opponent_coops
            cooperation_counts.append(total_coop)
        if not cooperation_counts:
            average_coop = 0.0
        else:
            average_coop = np.mean(cooperation_counts)
        threshold = self.m_threshold / self.game_description.n_players
        if average_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_373(BaseStrategy):
    """
    Implements the Adaptive Cooperative Restart (ACR) strategy. This strategy encourages sustained cooperation
    by adapting based on the number of prior cooperators, with mechanisms to reset cooperation after temporary defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        super().__init__(game_description)
        self.game_description = game_description
        self.m = math.ceil(game_description.k)
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        prev_opponent_actions = history.opponent_actions[-1]
        prev_C_count = np.sum(prev_opponent_actions) + (1 if my_prev_action else 0)
        if prev_C_count >= self.m:
            return Action.C
        if len(history.my_actions) >= 2:
            last_two = history.my_actions[-2:]
            if not np.any(last_two):
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_374(BaseStrategy):
    """
    Implementation of a strategy that starts with cooperation, 
    punishes once if cooperation drops below a threshold, 
    then resumes cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        previous_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round]
        my_prev_action = history.my_actions[previous_round]
        total_coop = np.sum(opponent_actions_prev) + my_prev_action
        if total_coop < self.m and my_prev_action:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_375(BaseStrategy):
    """
    Persistent Cooperation with Recovery Strategy.
    Cooperates in all rounds, intending to foster continuous group cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.C

class Strategy_COLLECTIVE_376(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_failures = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round, :]
        total_c = sum(opponent_prev_actions) + my_prev_action
        m = self.game_description.k
        if total_c < m:
            self.consecutive_failures += 1
        else:
            self.consecutive_failures = 0
        if self.consecutive_failures >= 2:
            action = Action.C
            self.consecutive_failures = 0
        else:
            action = Action.C if total_c >= m else Action.D
        return action

class Strategy_COLLECTIVE_377(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.cutoff_round = self.game_description.n_rounds - max(1, int(0.05 * self.game_description.n_rounds))
        self.next_round_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        if current_round >= self.cutoff_round:
            return Action.D
        if self.next_round_action is not None:
            action = self.next_round_action
            self.next_round_action = None
        else:
            prev_me = history.my_actions[-1]
            prev_others = sum(history.opponent_actions[-1, :])
            total_prev = prev_others + (1 if prev_me else 0)
            if total_prev >= self.m:
                action = Action.C
            else:
                action = Action.D
                self.next_round_action = Action.C
        return action

class Strategy_COLLECTIVE_378(BaseStrategy):
    """
    Ensures at least m cooperators each round without over-contributing.
    Cooperates in the first round. In subsequent rounds, defects if 
    the previous round had at least m cooperators, otherwise cooperates.
    m is set as the integer part of k to ensure at least m contributors.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = max(1, int(game_description.k))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        others_prev_actions = history.opponent_actions[prev_round, :]
        prev_c = my_prev_action + others_prev_actions.sum()
        if prev_c >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_379(BaseStrategy):
    """
    A strategy that cooperates initially and then adapts based on the number of cooperators in the previous round.
    It uses a threshold m, calculated as the ceiling of (n_players / k), to decide whether to cooperate or defect.
    If the number of cooperators in the previous round meets or exceeds m, the strategy cooperates; otherwise, it defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        sum_opponents = history.opponent_actions[previous_round, :].sum()
        my_coop = 1 if history.my_actions[previous_round] else 0
        total_coop_prev = sum_opponents + my_coop
        if total_coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_380(BaseStrategy):
    """
    Adaptive punishment strategy to maintain cooperation in public goods game.
    Cooperates initially and continues if cooperation threshold is met; otherwise, defects probabilistically.
    
    Parameters:
    game_description: Contains n_players, n_rounds, k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        their_prev_actions = history.opponent_actions[-1, :]
        c_prev = sum(their_prev_actions) + (1 if my_prev_action else 0)
        if c_prev >= self.m:
            return Action.C
        else:
            p_defect = (self.m - c_prev) / self.n_players
            if random.random() < p_defect:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_383(BaseStrategy):
    """
    Adaptive Forgiveness Strategy for N-Player Public Goods Game.

    The strategy starts by cooperating in the first round. In subsequent rounds, 
    it checks the number of cooperators from the previous round. If sufficient 
    (meeting a threshold), it continues to cooperate. Otherwise, it forgives 
    if it defected last round or punishes if it cooperated last round, then defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2 + 1
        self.my_previous_action = None

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.my_previous_action = action
            return action
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        opp_actions_prev = history.opponent_actions[prev_round]
        coop_prev = prev_my_action + opp_actions_prev.sum()
        if coop_prev >= self.m:
            action = Action.C
        elif prev_my_action == Action.D:
            action = Action.C
        else:
            action = Action.D
        self.my_previous_action = action
        return action

class Strategy_COLLECTIVE_384(BaseStrategy):
    """
    A strategy that starts with cooperation, reciprocates based on previous round's cooperation level,
    punishes defection, and resets cooperation after consecutive defections. Defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            pre_round = state.round_number - 1
            opp_prev_actions = history.opponent_actions[pre_round]
            my_prev_action = history.my_actions[pre_round]
            prev_coop_count = sum(opp_prev_actions) + (1 if my_prev_action else 0)
            if prev_coop_count >= self.m:
                action = Action.C
            else:
                action = Action.D
                if state.round_number >= 2:
                    pre_pre_round = state.round_number - 2
                    my_prev_prev_action = history.my_actions[pre_pre_round]
                    if not my_prev_action and (not my_prev_prev_action):
                        action = Action.C
            return action

class Strategy_COLLECTIVE_385(BaseStrategy):
    """
    Adaptive Cooperation Strategy based on Historical Performance.

    In the first round, the strategy cooperates unconditionally. In subsequent rounds,
    it cooperates if the number of cooperators in the previous round meets or exceeds
    half the number of players (n_players // 2). This encourages sustained cooperation
    while adapting to the group's previous performance.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.threshold = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponent_prev_actions = history.opponent_actions[-1]
        my_coop = 1 if my_prev_action else 0
        opponents_coop = int(opponent_prev_actions.sum())
        total_cooperators = my_coop + opponents_coop
        if total_cooperators >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_386(BaseStrategy):
    """
    Adaptive Collective Cooperation Strategy.

    Players cooperate if the majority of recent rounds met the cooperation threshold,
    otherwise defect to encourage others to adapt.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m_threshold = math.ceil(self.n / self.k)
        self.recent_rounds = 5

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        max_round = current_round - 1
        start_round = max(0, max_round - self.recent_rounds + 1)
        recent_round_indices = range(start_round, max_round + 1)
        successful_coops = 0
        total_rounds = 0
        for r in recent_round_indices:
            my_action = history.my_actions[r]
            opponent_actions = history.opponent_actions[r]
            my_coop = 1 if my_action else 0
            opp_coops = sum(opponent_actions)
            total = my_coop + opp_coops
            if total >= self.m_threshold:
                successful_coops += 1
            total_rounds += 1
        if total_rounds == 0:
            return Action.C
        proportion = successful_coops / total_rounds
        if proportion > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_387(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that maintains cooperation but defects
    when cooperation levels drop below a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)
        self.next_cooperate = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.next_cooperate:
            action = Action.C
        else:
            action = Action.D
        previous_round = state.round_number - 1
        my_last_action = history.my_actions[previous_round]
        opponent_last_actions = history.opponent_actions[previous_round]
        my_coop = int(my_last_action)
        opponent_coop = np.sum(opponent_last_actions)
        m_t = my_coop + opponent_coop
        if m_t < self.m:
            if my_last_action:
                self.next_cooperate = False
            else:
                self.next_cooperate = True
        else:
            self.next_cooperate = True
        return action

class Strategy_COLLECTIVE_388(BaseStrategy):
    """
    A strategy where each player cooperates in the first round and continues to cooperate 
    as long as the previous round had at least m cooperators. If a round fails, they 
    defect in the next round. After one round of defection, they retry cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k
        self.coopretry = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_opponents_actions = history.opponent_actions[-1]
        total_coop_prev = sum(prev_opponents_actions) + (1 if prev_my_action else 0)
        if total_coop_prev >= self.m:
            self.coopretry = False
            return Action.C
        elif self.coopretry:
            self.coopretry = False
            return Action.C
        else:
            self.coopretry = True
            return Action.D

class Strategy_COLLECTIVE_389(BaseStrategy):
    """
    A cooperative strategy with a recovery mechanism to maintain cooperation in public goods games.
    
    The strategy starts with cooperation and continues if the number of cooperators meets a threshold.
    If cooperation falters, players defect for a limited number of rounds before attempting cooperation again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.threshold = self.n_players // 2
        self.c = 1
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        total_c = int(my_prev_action) + np.sum(opp_prev_actions)
        if total_c >= self.threshold:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections <= self.c:
                return Action.D
            else:
                self.consecutive_defections = 0
                return Action.C

class Strategy_COLLECTIVE_390(BaseStrategy):
    """
    A strategy that encourages cooperation while allowing recovery from failures.
    Cooperates initially and continues if successful, otherwise occasionally defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.rng = random.Random()

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            my_last_action = history.my_actions[-1]
            opponent_last_actions = history.opponent_actions[-1, :]
            S_prev = my_last_action + sum(opponent_last_actions)
            if S_prev >= self.m:
                return Action.C
            elif self.rng.random() < 0.2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_391(BaseStrategy):
    """
    Conditional Cooperator with Recovery strategy.
    Cooperates initially, continues if previous round was successful (>=m cooperators).
    Defects once if previous round failed, then attempts to recover by cooperating again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.scheduled_defect = False
        self.force_coop_next = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            if self.force_coop_next:
                action = Action.C
                self.force_coop_next = False
            elif self.scheduled_defect:
                action = Action.D
                self.scheduled_defect = False
            else:
                prev_round = state.round_number - 1
                my_prev = history.my_actions[prev_round]
                opponent_prev = sum(history.opponent_actions[prev_round])
                total_prev_c = my_prev + opponent_prev
                if total_prev_c >= self.m:
                    action = Action.C
                else:
                    action = Action.D
                    self.force_coop_next = True
            return action

class Strategy_COLLECTIVE_392(BaseStrategy):
    """
    A strategy that combines initial cooperation with adaptive responses based on previous rounds' cooperation levels.
    It calculates a threshold (m) as the minimal number of cooperators needed for optimal payoffs.
    Players cooperate if the previous round's cooperation meets or exceeds this threshold; otherwise, they defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            my_c = 1 if my_prev_action else 0
            opponent_c = sum(history.opponent_actions[prev_round])
            total_c = my_c + opponent_c
            if total_c >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_393(BaseStrategy):
    """
    A deterministic strategy for the N-Player Public Goods Game that balances cooperation and punishment.
    Players cooperate in the first round and the last round. In subsequent rounds, they cooperate if the number of
    cooperators in the previous round meets a threshold (n_players // 2), otherwise they defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        total_cooperators = int(my_prev_action) + np.sum(opponent_prev_actions)
        if total_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_394(BaseStrategy):
    """
    A strategy that initially cooperates and adapts based on collective success.
    Cooperates if previous rounds met the cooperation threshold, otherwise defects.
    Includes post-defection monitoring and reverts to cooperation if sufficient.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.floor(self.n_players / self.k) + 1
        self.defected = False
        self.post_defection_success = 0
        self.post_defection_total = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        total_rounds = self.n_rounds
        if current_round == total_rounds - 1:
            success_count = 0
            for t in range(current_round):
                me_c = history.my_actions[t]
                opponents_c = sum(history.opponent_actions[t, :])
                S = int(me_c) + opponents_c
                if S >= self.m:
                    success_count += 1
            if success_count > current_round / 2:
                return Action.C
            else:
                return Action.D
        else:
            success_count = 0
            for t in range(current_round):
                me_c = history.my_actions[t]
                opponents_c = sum(history.opponent_actions[t, :])
                S = int(me_c) + opponents_c
                if S >= self.m:
                    success_count += 1
            prior_rounds = current_round
            if not self.defected:
                if success_count > prior_rounds / 2:
                    return Action.C
                else:
                    self.defected = True
                    self.post_defection_success = 0
                    self.post_defection_total = 0
                    return Action.D
            else:
                if history is not None and current_round > 0:
                    last_round = current_round - 1
                    me_c = history.my_actions[last_round]
                    opponents_c = sum(history.opponent_actions[last_round, :])
                    S = int(me_c) + opponents_c
                    if S >= self.m:
                        self.post_defection_success += 1
                    self.post_defection_total += 1
                if self.post_defection_success > self.post_defection_total / 2:
                    self.defected = False
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_395(BaseStrategy):
    """
    Responsive Cooperation with Punishment strategy.
    Cooperates initially and in subsequent rounds if enough players cooperated previously.
    Defects temporarily if cooperation falls below a threshold, then resumes cooperation if it recovers.
    The threshold is calculated as ceil(n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        prev_total = (1 if my_prev_action else 0) + sum(opponent_prev_actions)
        if prev_total >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_396(BaseStrategy):
    """
    A strategy that cooperates if the number of cooperators in the previous round meets or exceeds a threshold m.
    The threshold m is calculated as the ceiling of (n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        if prev_round < 0:
            return Action.C
        my_last_action = history.my_actions[prev_round]
        others_last_actions = history.opponent_actions[prev_round]
        total_coop = my_last_action + int(others_last_actions.sum())
        return Action.C if total_coop >= self.m else Action.D

class Strategy_COLLECTIVE_397(BaseStrategy):
    """
    A strategy for the N-player public goods game based on reciprocity and a cooperation threshold.
    Cooperates in the first round, then continues to Cooperate if at least m players Cooperated in the previous round.
    The threshold m is calculated as the ceiling of n_players divided by the multiplication factor k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions = history.opponent_actions[prev_round, :]
        sum_opponents = np.sum(opponent_actions)
        my_prev_action = history.my_actions[prev_round]
        sum_coop = sum_opponents + (1 if my_prev_action else 0)
        if sum_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_398(BaseStrategy):
    """
    A strategy that upholds cooperation if all players cooperated in the previous round; 
    otherwise, it defects. This encourages sustained cooperation based on mutual reciprocity.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opp_prev_actions = history.opponent_actions[-1, :]
        total_coop = (1 if my_prev_action else 0) + sum(opp_prev_actions)
        m = self.n_players
        if total_coop >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_399(BaseStrategy):
    """
    A strategy that balances responsiveness to recent cooperative behavior 
    with periodic attempts to restart cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(game_description.k)
        self.restart_threshold = 3
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.consecutive_defections >= self.restart_threshold:
            self.consecutive_defections = 0
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round]
        sum_opponent_coops = np.sum(opponent_actions_prev)
        my_prev_coop = history.my_actions[prev_round]
        sum_prev_coop = sum_opponent_coops + (1 if my_prev_coop else 0)
        if sum_prev_coop >= self.m:
            action = Action.C
        else:
            action = Action.D
        if action == Action.C:
            self.consecutive_defections = 0
        else:
            self.consecutive_defections += 1
        return action

class Strategy_COLLECTIVE_400(BaseStrategy):
    """
    A strategy that cooperates in the first round and subsequently cooperates if at least m players cooperated in the previous round.
    m is calculated as the ceiling of (n_players / k) to ensure cooperation is beneficial when enough players cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        sum_my_prev = 1 if my_prev_action else 0
        sum_opponent_prev = np.sum(history.opponent_actions[prev_round])
        sum_coop_prev = sum_my_prev + sum_opponent_prev
        if sum_coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_401(BaseStrategy):
    """
    Reciprocal cooperation strategy with punishment for failure to meet a cooperation threshold.
    Cooperates if previous rounds met the threshold; otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        any_failure = False
        m = self.m
        for s in range(t):
            if s >= len(history.my_actions) or s >= history.opponent_actions.shape[0]:
                continue
            my_c = history.my_actions[s]
            opponent_c = sum(history.opponent_actions[s, :])
            total_c = my_c + opponent_c
            if total_c < m:
                any_failure = True
                break
        if any_failure:
            return Action.D
        s_prev = t - 1
        if s_prev < len(history.my_actions) and s_prev < history.opponent_actions.shape[0]:
            my_c_prev = history.my_actions[s_prev]
            opponent_c_prev = sum(history.opponent_actions[s_prev, :])
            total_c_prev = my_c_prev + opponent_c_prev
        else:
            total_c_prev = 0
        if total_c_prev >= m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_402(BaseStrategy):
    """
    Adaptive Forgiveness with Final Cooperation strategy.
    
    This strategy starts with cooperation to build trust, adapts based on a threshold of 
    cooperators in the previous round, and ensures cooperation in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            t_prev = state.round_number - 1
            my_prev_action = history.my_actions[t_prev]
            opponent_prev_actions = history.opponent_actions[t_prev]
            sum_coop = my_prev_action + sum(opponent_prev_actions)
            if sum_coop >= self.m:
                return Action.C
            else:
                return Action.D if my_prev_action else Action.C

class Strategy_COLLECTIVE_403(BaseStrategy):
    """
    Cooperative strategy that adapts based on previous rounds' outcomes.
    Cooperates initially, continues if enough players cooperate, and retries after temporary failures.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.s = 2
        self.previous_met = False
        self.counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_t = state.round_number - 1
            my_prev = history.my_actions[prev_t]
            opp_prev = history.opponent_actions[prev_t]
            my_prev_action = int(my_prev)
            total_coop = my_prev_action + np.sum(opp_prev)
            if total_coop >= self.m:
                self.previous_met = True
                self.counter = 0
                return Action.C
            else:
                self.previous_met = False
                self.counter += 1
                if self.counter < self.s:
                    return Action.D
                else:
                    self.counter = 0
                    return Action.C

class Strategy_COLLECTIVE_404(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game where each player 
    decides to Cooperate or Defect based on the historical success of cooperation.
    Players start by Cooperating and then adapt their strategy using a threshold 
    of historical cooperation success.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        total_previous_rounds = current_round
        successful_rounds = 0
        for prev_round in range(current_round):
            my_action = history.my_actions[prev_round]
            others_actions = history.opponent_actions[prev_round]
            total_cooperators = my_action + np.sum(others_actions)
            if total_cooperators >= self.m:
                successful_rounds += 1
        if total_previous_rounds == 0:
            cooperation_proportion = 0.0
        else:
            cooperation_proportion = successful_rounds / total_previous_rounds
        if cooperation_proportion > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_406(BaseStrategy):
    """
    Adaptive Reciprocity Strategy for Collective Risk Dilemma in Public Goods Game.
    Cooperates initially, then reciprocates based on prior round's cooperation level.
    Punishes lack of cooperation with defection, and resets after a set number of failures.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_defects = 0
        self.reset_threshold = 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            my_prev = history.my_actions[-1]
            opponent_prev = history.opponent_actions[-1, :]
            sum_coop_last = (1 if my_prev else 0) + np.sum(opponent_prev)
            threshold = self.game_description.n_players / self.game_description.k
            if sum_coop_last >= threshold:
                self.consecutive_defects = 0
                return Action.C
            elif self.consecutive_defects >= self.reset_threshold:
                self.consecutive_defects = 0
                return Action.C
            else:
                self.consecutive_defects += 1
                return Action.D

class Strategy_COLLECTIVE_408(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness (ACF) Strategy.
    Starts with cooperation, adapts based on previous cooperation levels,
    and includes a forgiveness mechanism to reset cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.consecutive_insufficient = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_coop_prev = history.my_actions[prev_round]
        opponents_coop_prev = sum(history.opponent_actions[prev_round, :])
        total_cooperators_prev = my_coop_prev + opponents_coop_prev
        n_players = self.game_description.n_players
        m = self.m
        if total_cooperators_prev >= m:
            self.consecutive_insufficient = 0
            return Action.C
        else:
            self.consecutive_insufficient += 1
            if self.consecutive_insufficient >= 3:
                if random.random() < 0.2:
                    return Action.C
                else:
                    return Action.D
            else:
                defect_prob = (m - total_cooperators_prev) / n_players
                if random.random() < defect_prob:
                    return Action.D
                else:
                    return Action.C

class Strategy_COLLECTIVE_410(BaseStrategy):
    """
    A deterministic strategy based on the previous round's cooperation level.
    Cooperates if at least half (rounded down) of the players cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_coop = history.my_actions[-1]
        prev_opp_coops = sum(history.opponent_actions[-1, :])
        total_prev = prev_my_coop + prev_opp_coops
        threshold = self.game_description.n_players // 2
        if total_prev >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_411(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) Strategy.
    Cooperates initially, adapts based on previous cooperation levels, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_last_action = history.my_actions[prev_round]
            others_last_actions = history.opponent_actions[prev_round, :]
            my_c = 1 if my_last_action else 0
            others_c = sum(others_last_actions)
            total_c_prev = my_c + others_c
            if total_c_prev >= self.m:
                return Action.C
            else:
                p = max(0.0, (self.m - total_c_prev) / self.game_description.n_players)
                if random.random() < p:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_412(BaseStrategy):
    """
    A strategy that starts with cooperation, punishes for a single round if the cooperation threshold isn't met, then forgives.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)
        self.prev_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_action = Action.C
            return Action.C
        current_round = state.round_number
        if self.prev_action == Action.D:
            self.prev_action = Action.C
            return Action.C
        previous_round = current_round - 1
        my_last_action = history.my_actions[previous_round]
        opp_last_actions = history.opponent_actions[previous_round]
        s_prev = my_last_action + np.sum(opp_last_actions)
        if s_prev >= self.m:
            self.prev_action = Action.C
            return Action.C
        else:
            self.prev_action = Action.D
            return Action.D

class Strategy_COLLECTIVE_413(BaseStrategy):
    """
    Cooperative Punishment with Forgiveness strategy.
    Cooperates initially and in subsequent rounds if at least half of the players cooperated previously.
    Defects otherwise to punish free-riding, but allows for reevaluation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponents_prev = history.opponent_actions[prev_round, :]
        count_C = my_prev + np.sum(opponents_prev)
        if count_C >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_414(BaseStrategy):
    """
    This strategy follows the dominant strategy of always defecting (D) in the Public Goods Game.
    Analysis shows that defecting maximizes individual payoffs regardless of other players' actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_COLLECTIVE_416(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness strategy for the Public Goods Game.
    Cooperates initially, continues if enough players cooperated previously, 
    and resets cooperation after two rounds of insufficient cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.consecutive_insufficient = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        sum_coop = int(my_prev_action) + sum(opponent_prev_actions)
        if sum_coop >= self.m:
            self.consecutive_insufficient = 0
            return Action.C
        else:
            self.consecutive_insufficient += 1
            if self.consecutive_insufficient >= 2:
                self.consecutive_insufficient = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_417(BaseStrategy):
    """
    Responsive Cooperation with Reset Mechanism. Cooperates initially, continues if enough players cooperated previously,
    and resets cooperation attempt after 3 consecutive failures to avoid perpetual defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_failures = 0
        self.m = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_prev = history.my_actions[t_prev]
        opponent_actions_prev = history.opponent_actions[t_prev, :]
        sum_opponent_prev = np.sum(opponent_actions_prev)
        S_prev = my_prev + sum_opponent_prev
        if S_prev >= self.m:
            self.consecutive_failures = 0
            return Action.C
        else:
            self.consecutive_failures += 1
            if self.consecutive_failures >= 3:
                self.consecutive_failures = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_418(BaseStrategy):
    """
    A strategy that adaptively cooperates or defects based on the level of cooperation in previous rounds.
    It starts by cooperating, punishes by defecting if cooperation drops below a threshold, forgives if cooperation resumes,
    and ensures cooperation in the final round if the penultimate round was sufficiently cooperative.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2
        self.last_round_defected = False

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            self.last_round_defected = False
            return Action.C
        if history is not None:
            prev_my = history.my_actions[-1]
            prev_opp = history.opponent_actions[-1, :] if history.opponent_actions.size > 0 else np.zeros(0, dtype=bool)
            prev_coop_total = (1 if prev_my else 0) + sum(prev_opp)
        else:
            prev_coop_total = 0
        if state.round_number == self.n_rounds - 1:
            if len(history.my_actions) >= 2 and len(history.opponent_actions) >= 2:
                my_prev_prev = history.my_actions[-2]
                opp_prev_prev = history.opponent_actions[-2, :]
                prev_prev_coop_total = (1 if my_prev_prev else 0) + sum(opp_prev_prev)
            else:
                prev_prev_coop_total = prev_coop_total
            if prev_prev_coop_total >= self.m:
                self.last_round_defected = False
                return Action.C
            else:
                self.last_round_defected = True
                return Action.D
        elif self.last_round_defected:
            if prev_coop_total >= self.m:
                self.last_round_defected = False
                return Action.C
            else:
                self.last_round_defected = True
                return Action.D
        elif prev_coop_total >= self.m:
            self.last_round_defected = False
            return Action.C
        else:
            self.last_round_defected = True
            return Action.D

class Strategy_COLLECTIVE_419(BaseStrategy):
    """A strategy that maintains cooperation as long as enough others cooperate, 
    otherwise defects to punish and may return to cooperation if others start cooperating again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players * (self.k - 1) / self.k)
        self.is_punishing = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponents_actions_prev = history.opponent_actions[prev_round]
        opponents_coop = np.sum(opponents_actions_prev)
        my_prev_action = history.my_actions[prev_round]
        my_coop = 1 if my_prev_action else 0
        total_coop_prev = opponents_coop + my_coop
        if self.is_punishing:
            if total_coop_prev >= self.m:
                self.is_punishing = False
                return Action.C
            else:
                return Action.D
        elif total_coop_prev >= self.m:
            return Action.C
        else:
            self.is_punishing = True
            return Action.D

class Strategy_COLLECTIVE_420(BaseStrategy):
    """
    A strategy that begins with cooperation, punishes when insufficient players cooperate,
    and recovers cooperation when sufficient players cooperate again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        super().__init__(game_description)
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_prev_action = history.my_actions[last_round]
        opponent_actions = history.opponent_actions[last_round]
        total_cooperators = int(my_prev_action) + sum(opponent_actions)
        if total_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_421(BaseStrategy):
    """
    Strategy: Cooperate if Previous Round was Successful with Periodic Restart Attempts.
    - Initial cooperation in the first round.
    - Cooperate if the previous round met the threshold of cooperators.
    - Defect if the threshold was not met, but attempt cooperation after two consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.consecutive_defections = 0
        self.restart_after = 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        total_c = int(my_prev_action) + int(opponent_prev_actions.sum())
        if total_c >= self.m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections >= self.restart_after:
                self.consecutive_defections = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_422(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.k = game_description.k
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            last_payoff = history.my_payoffs[-1]
            if last_payoff == self.k or last_payoff == 1 + self.k:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_423(BaseStrategy):
    """
    A strategy for the N-player public goods game that starts with cooperation and 
    continues cooperating if at least half of the players (rounded down) cooperated 
    in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev = history.my_actions[-1]
        opponents_prev = history.opponent_actions[-1]
        coop_prev = my_prev + sum(opponents_prev)
        if coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_424(BaseStrategy):
    """
    Adaptive Cooperation with Periodic Re-engagement Strategy
    Cooperates initially, then continues if enough players cooperated in the previous round, otherwise defects. 
    Reverts to cooperation after a set number of defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.z = 3
        self.defect_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        sum_my = int(history.my_actions[-1])
        opponents = history.opponent_actions[-1]
        sum_opp = np.sum(opponents)
        sum_c = sum_my + sum_opp
        if sum_c >= self.m:
            self.defect_count = 0
            return Action.C
        else:
            self.defect_count += 1
            if self.defect_count >= self.z:
                self.defect_count = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_425(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy for the N-Player Public Goods Game.
    Aims to balance cooperation with measured punishment to maintain collective benefits while avoiding exploitation.
    Cooperates initially, punishes once after insufficient cooperation, and evaluates overall cooperation history in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(game_description.n_players // game_description.k) + 1

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds - 1:
            count = 0
            for t in range(len(history.my_actions)):
                my_coop = history.my_actions[t]
                opp_coop = np.sum(history.opponent_actions[t, :])
                sum_coop = my_coop + opp_coop
                if sum_coop >= self.m:
                    count += 1
            if count > len(history.my_actions) / 2:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = current_round - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, :]
            sum_coop = my_prev_action + np.sum(opp_prev_actions)
            if sum_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_426(BaseStrategy):
    """
    This strategy ensures that exactly m players cooperate in every round based on their indices.
    The value of m is calculated as the ceiling of (n_players / k).
    Players with an index <= m will cooperate, others will defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.D
        prev_round = history.my_actions[-1]
        if prev_round:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_427(BaseStrategy):
    """
    A deterministic strategy to promote sustained cooperation in N-player public goods games.
    It starts with cooperation, continues if successful, and uses a measured response to failures.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        t_last = state.round_number - 1
        my_last = history.my_actions[t_last]
        opponent_last = history.opponent_actions[t_last]
        last_outcome = my_last + np.sum(opponent_last)
        if last_outcome >= self.m:
            return Action.C
        else:
            consecutive_failures = 0
            for i in range(1, t_last + 2):
                round_index = t_last - i
                if round_index < 0:
                    break
                my_action = history.my_actions[round_index]
                opponent_actions = history.opponent_actions[round_index]
                outcome = my_action + np.sum(opponent_actions)
                if outcome < self.m:
                    consecutive_failures += 1
                else:
                    break
            if consecutive_failures % 2 == 0:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_428(BaseStrategy):
    """
    A strategy that combines initial cooperation with a brief punishment phase 
    followed by a return to cooperation to encourage sustained cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.state = 'Cooperating'

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        others_prev_actions = history.opponent_actions[previous_round, :]
        my_coop = 1 if my_prev_action else 0
        others_coop = sum(others_prev_actions)
        total_coop_prev = my_coop + others_coop
        if self.state == 'Cooperating':
            if total_coop_prev >= self.m:
                return Action.C
            else:
                action = Action.D
                self.state = 'Punishing'
        elif self.state == 'Punishing':
            action = Action.D
            self.state = 'Cooperating'
        return action

class Strategy_COLLECTIVE_429(BaseStrategy):
    """
    Adaptive Cooperation with Temporary Forgiveness strategy.
    
    Players cooperate if the number of cooperators in the previous round meets a threshold.
    If not, players defect but retry cooperation after a set number of consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n_players = self.game_description.n_players
        k = self.game_description.k
        self.m = math.ceil(n_players / k)
        self.consecutive_defections = 0
        self.max_consecutive_defections = 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_actions = history.opponent_actions[previous_round]
        opponent_coop = opponent_actions.sum()
        my_coop = 1 if my_prev_action else 0
        s_prev = my_coop + opponent_coop
        if s_prev >= self.m:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections < self.max_consecutive_defections:
            self.consecutive_defections += 1
            return Action.D
        else:
            self.consecutive_defections = 0
            return Action.C

class Strategy_COLLECTIVE_430(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy.
    
    This strategy begins by cooperating in the first round to establish trust.
    In subsequent rounds, it continues to cooperate if a sufficient number of players
    cooperated in the previous round. If cooperation levels drop below the threshold,
    the strategy defects but will revert to cooperation after a limited number of failures.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.consecutive_failures = 0
        self.max_failures_before_retrying = 2
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        total_coop = np.sum(opponent_prev_actions) + (1 if my_prev_action else 0)
        if total_coop >= self.m:
            self.consecutive_failures = 0
            return Action.C
        else:
            self.consecutive_failures += 1
            if self.consecutive_failures <= self.max_failures_before_retrying:
                return Action.D
            else:
                self.consecutive_failures = 0
                return Action.C

class Strategy_COLLECTIVE_434(BaseStrategy):
    """
    Cooperative Reactivism strategy for N-player public goods game.
    Players start by cooperating and continue if sufficient players cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.k)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_opponents = history.opponent_actions[-1]
        sum_opponents = np.sum(last_opponents)
        my_last_action = history.my_actions[-1]
        sum_prev = sum_opponents + my_last_action
        if sum_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_436(BaseStrategy):
    """
    A strategy to maintain cooperation in a repeated N-Player Public Goods Game.
    Players cooperate in the first round and subsequently base their decision 
    on the number of cooperators in the previous round. If the number meets or 
    exceeds a threshold (half the number of players), they cooperate; otherwise, 
    they defect to punish low cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_t = state.round_number - 1
        my_prev = history.my_actions[prev_t]
        count = 1 if my_prev else 0
        count += np.sum(history.opponent_actions[prev_t, :])
        if count >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_437(BaseStrategy):
    """
    A strategy that starts with cooperation and continues if enough players cooperated in the previous round.
    The threshold for cooperation is calculated as the ceiling of (n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.m = min(self.m, game_description.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_coop = history.my_actions[prev_round]
        opponent_prev_coops = history.opponent_actions[prev_round]
        total_coop = sum(opponent_prev_coops) + (1 if my_prev_coop else 0)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_439(BaseStrategy):
    """
    A strategy that starts by cooperating in the first round and continues to cooperate in subsequent rounds if at least half of the players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_prev = history.my_actions[t_prev]
        opponents_prev = history.opponent_actions[t_prev, :]
        c_prev = my_prev + sum(opponents_prev)
        if c_prev >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_440(BaseStrategy):
    """Threshold Cooperative Punishment Strategy
    
    Cooperates in the first round and continues if enough others cooperated previously.
    Uses a threshold based on half the number of players to determine cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions = history.opponent_actions[prev_round, :]
        total_cooperators = my_prev_action + sum(opponent_actions)
        if total_cooperators >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_441(BaseStrategy):
    """
    Cooperative strategy with punishment and reset mechanisms for public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            my_last_action = history.my_actions[-1]
            my_coop = 1 if my_last_action else 0
            opponent_coop = sum(history.opponent_actions[-1, :])
            total_coop = my_coop + opponent_coop
            if total_coop == 0:
                return Action.C
            elif total_coop >= self.threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_442(BaseStrategy):
    """
    A strategy that starts by cooperating, continues if recent rounds were successful, 
    punishes by defecting if not, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            return Action.D
        else:
            rounds_to_track = min(3, current_round)
            start_round = max(0, current_round - rounds_to_track)
            recent_successes = 0
            for r in range(start_round, current_round):
                my_action = history.my_actions[r]
                opponent_actions = history.opponent_actions[r]
                cooperators = int(my_action) + np.sum(opponent_actions)
                if cooperators >= self.m:
                    recent_successes += 1
            success_rate = recent_successes / rounds_to_track
            if success_rate > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_443(BaseStrategy):
    """
    Adaptive Cooperation Strategy based on recent collective performance.
    Cooperates if previous round's cooperation meets the threshold m.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = int(math.floor(n / k)) + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            t = state.round_number - 1
            my_prev = history.my_actions[t]
            opponent_prev = history.opponent_actions[t]
            sum_coop = my_prev + np.sum(opponent_prev)
            if sum_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_444(BaseStrategy):
    """
    An adaptive strategy based on reciprocity. Players Cooperate if at least half of the players 
    (rounded down) Cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            sum_others = np.sum(opponent_actions_prev)
            my_prev = history.my_actions[prev_round]
            sum_me = 1 if my_prev else 0
            total_coop = sum_others + sum_me
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_445(BaseStrategy):
    """
    Adaptive Collective Cooperation strategy that encourages sustained cooperation, 
    retaliates temporarily when cooperation is low, and forgives by re-cooperating if others adapt.
    Cooperates in endgame rounds to maximize final payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.is_retaliating = False
        self.retaliate_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        if current_round >= n_rounds - 2:
            return Action.C
        if self.is_retaliating:
            if self.retaliate_remaining > 0:
                self.retaliate_remaining -= 1
                return Action.D
            else:
                self.is_retaliating = False
                self.retaliate_remaining = 0
        m = n_players // 2
        start = max(0, current_round - 5)
        sum_count = 0
        for t in range(start, current_round):
            if t < len(history.my_actions):
                my_coop = history.my_actions[t]
                opponent_coop = sum(history.opponent_actions[t])
                total_coop = my_coop + opponent_coop
                if total_coop >= m:
                    sum_count += 1
        if sum_count >= 3:
            return Action.C
        else:
            self.is_retaliating = True
            self.retaliate_remaining = 2
            return Action.D

class Strategy_COLLECTIVE_446(BaseStrategy):
    """
    A strategy that combines initial cooperation with punishment for non-cooperative behavior.
    Players cooperate as long as the number of cooperators in the previous round meets a threshold.
    The threshold is half the number of players, rounded down.
    In the final round, all players defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_actions_prev = history.opponent_actions[previous_round]
        prev_coop_count = (1 if my_prev_action else 0) + np.sum(opponent_actions_prev)
        if prev_coop_count >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_447(BaseStrategy):
    """
    A strategy that promotes sustained cooperation through reciprocal behavior with a forgiveness mechanism.
    Cooperates initially, continues if enough others cooperate, defects otherwise but resets after a few defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.x = 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev = history.my_actions[-1]
        opp_prev = history.opponent_actions[-1]
        coops = my_prev + sum(opp_prev)
        if coops >= self.m:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections < self.x:
            self.consecutive_defections += 1
            return Action.D
        else:
            self.consecutive_defections = 0
            return Action.C

class Strategy_COLLECTIVE_448(BaseStrategy):
    """
    Responsive Cooperation with Resilience strategy.

    This strategy starts by cooperating and uses a moving window of recent rounds to decide actions.
    It continues to cooperate if recent rounds had sufficient cooperation. If not, it defects but resets
    cooperation after a set number of consecutive defections without cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.window_size = 3
        self.cooperator_threshold = 1
        self.reset_threshold = 3

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        s = state.round_number
        any_success = False
        window_size = self.window_size
        w = min(window_size, s)
        for t in range(s - 1, max(-1, s - 1 - w), -1):
            if t < 0:
                break
            my_c = 1 if history.my_actions[t] else 0
            opp_c = sum(history.opponent_actions[t])
            total_c = my_c + opp_c
            if total_c >= self.cooperator_threshold:
                any_success = True
                break
        if any_success:
            return Action.C
        reset_condition_met = True
        start_t = s - 1
        end_t = max(0, s - self.reset_threshold)
        for t in range(start_t, end_t - 1, -1):
            if t < 0:
                break
            if history.my_actions[t]:
                reset_condition_met = False
                break
            my_c_t = 1 if history.my_actions[t] else 0
            opp_c_t = sum(history.opponent_actions[t])
            total_c_t = my_c_t + opp_c_t
            if total_c_t != 0:
                reset_condition_met = False
                break
        if s >= self.reset_threshold and reset_condition_met:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_449(BaseStrategy):
    """
    Cooperate if the previous round had at least m cooperators; otherwise, defect.
    m is calculated as the ceiling of (n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        k = self.game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_my_action = history.my_actions[-1]
            prev_opponents_actions = history.opponent_actions[-1, :]
            sum_coops_prev = int(prev_my_action) + int(prev_opponents_actions.sum())
            if sum_coops_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_451(BaseStrategy):
    """
    A strategy that starts with cooperation, then adapts based on previous cooperation levels.
    Cooperates if at least m players (including self) cooperated last round; otherwise, defects for s consecutive rounds.
    After s defections, reverts to cooperation to attempt recovery.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m_threshold = self.n_players // 2
        self.s_threshold = 2
        self.defection_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_others_actions = history.opponent_actions[prev_round, :]
        prev_coop_count = prev_my_action + sum(prev_others_actions)
        if prev_coop_count >= self.m_threshold:
            self.defection_streak = 0
            return Action.C
        elif self.defection_streak < self.s_threshold:
            self.defection_streak += 1
            return Action.D
        else:
            self.defection_streak = 0
            return Action.C

class Strategy_COLLECTIVE_452(BaseStrategy):
    """
    A deterministic strategy to maintain cooperation levels in an N-Player Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        m = (n - 1) // k + 1
        m = max(1, min(m, n))
        self.m_threshold = m
        self.index = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if history is None:
            return Action.C
        prev_round = current_round - 1
        if prev_round >= 0:
            own_action = history.my_actions[prev_round]
            opponent_actions = history.opponent_actions[prev_round, :]
            c_prev = int(own_action) + int(opponent_actions.sum())
        else:
            c_prev = 0
        if c_prev >= self.m_threshold:
            return Action.C
        elif self.index is not None and self.index <= self.m_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_454(BaseStrategy):
    """
    An adaptive strategy balancing punishment and forgiveness in N-player public goods games.
    Cooperates initially and in rounds following sufficient cooperation, otherwise adapts based on previous actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponents_prev = history.opponent_actions[prev_round]
        my_prev = history.my_actions[prev_round]
        prev_coop = sum(opponents_prev) + my_prev
        if prev_coop >= self.m:
            return Action.C
        elif not my_prev:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_455(BaseStrategy):
    """
    Adaptive Threshold Cooperation (ATC) strategy. Cooperates initially and 
    in the last round, adapting cooperation based on the trend of past cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_trend = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        prev_round = state.round_number - 1
        my_action_prev = history.my_actions[prev_round]
        opp_actions_prev = history.opponent_actions[prev_round, :]
        coop_count = my_action_prev + opp_actions_prev.sum()
        self.cooperation_trend.append(coop_count)
        if not self.cooperation_trend:
            return Action.C
        avg_coop = sum(self.cooperation_trend) / len(self.cooperation_trend)
        if coop_count >= avg_coop:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_456(BaseStrategy):
    """
    A conditional cooperation strategy that adapts based on previous rounds' outcomes.
    Cooperates if enough players cooperated previously, with mechanisms to forgive past defections
    and adapt near the game's end.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)
        self.forgiveness_s = 2
        self.end_rounds = 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            self.consecutive_defections = 0
            return Action.C
        if state.round_number >= self.r - self.end_rounds:
            return Action.D
        previous_round = state.round_number - 1
        my_prev = int(history.my_actions[previous_round])
        opp_prev = sum(history.opponent_actions[previous_round])
        total_prev = my_prev + opp_prev
        if total_prev >= self.m:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections >= self.forgiveness_s:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            return Action.D

class Strategy_COLLECTIVE_457(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages cooperation if a sufficient number of players cooperated in the previous round.
    
    The strategy starts with cooperation and continues to cooperate if at least a threshold number of players cooperated previously. The threshold is based on the game's parameters to balance individual and collective benefits.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        sum_o = np.sum(opponent_actions)
        if history.my_actions[-1]:
            sum_o += 1
        m_prev = sum_o
        return Action.C if m_prev >= self.m else Action.D

class Strategy_COLLECTIVE_458(BaseStrategy):
    """
    A strategy to sustain cooperation in public goods games by initially cooperating, 
    monitoring cooperation levels, and briefly punishing deviations to encourage continued cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / 2)
        self.coerce_next = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.coerce_next:
            self.coerce_next = False
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions = history.opponent_actions[prev_round, :]
        sum_prev_c = sum(opponent_actions) + (1 if my_prev_action else 0)
        if sum_prev_c >= self.m:
            return Action.C
        else:
            self.coerce_next = True
            return Action.D

class Strategy_COLLECTIVE_459(BaseStrategy):
    """
    Cooperate in the first round and continue cooperating if at least half of the players 
    (rounded down) cooperated in the previous round; otherwise, defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponent_prev = history.opponent_actions[prev_round]
            sum_opp = np.sum(opponent_prev)
            total_coop_prev = my_prev + sum_opp
            m = self.game_description.n_players // 2
            if total_coop_prev >= m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_460(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy:
    Cooperates initially and continues if enough players cooperated previously.
    Defects for a period if cooperation threshold isn't met, then forgives.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.f = 2
        self.defect_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.defect_remaining > 0:
            action = Action.D
            self.defect_remaining -= 1
        else:
            previous_round = state.round_number - 1
            my_prev_action = history.my_actions[previous_round]
            opponents_prev_actions = history.opponent_actions[previous_round, :]
            my_contrib = 1 if my_prev_action else 0
            opponents_contrib = np.sum(opponents_prev_actions)
            total_coop = my_contrib + opponents_contrib
            if total_coop >= self.m:
                action = Action.C
            else:
                action = Action.D
                self.defect_remaining = self.f
        return action

class Strategy_COLLECTIVE_462(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) strategy to sustain cooperation in public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.success_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            new_rounds = range(len(self.success_history), len(history.my_payoffs))
            for s in new_rounds:
                action = history.my_actions[s]
                payoff = history.my_payoffs[s]
                if action:
                    sum_c = payoff * self.game_description.n_players / self.game_description.k
                else:
                    sum_c = (payoff - 1) * self.game_description.n_players / self.game_description.k
                sum_c_rounded = round(sum_c)
                m = self.game_description.n_players / self.game_description.k
                success = sum_c_rounded >= m
                self.success_history.append(success)
        window_size = min(len(self.success_history), 3)
        if window_size == 0:
            return Action.C
        recent_success = self.success_history[-window_size:]
        success_rate = sum(recent_success) / window_size
        if success_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_463(BaseStrategy):
    """
    Cooperative Until Failure, Then Permanent Defection strategy.
    Cooperates initially and continues if all previous rounds have at least m cooperators.
    Permanently defects if any round has fewer than m cooperators, where m is half the number of players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        for t in range(state.round_number):
            my_coop = 1 if history.my_actions[t] else 0
            opponents_coop = np.sum(history.opponent_actions[t, :])
            total_coop = my_coop + opponents_coop
            if total_coop < self.m:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_464(BaseStrategy):
    """
    A strategy promoting cooperation in the N-player public goods game.
    Cooperates if a threshold of at least half the players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.threshold = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponent_actions = history.opponent_actions[-1, :]
        my_contribution = 1 if my_prev_action else 0
        opponent_contribution = sum(opponent_actions)
        total_cooperators = my_contribution + opponent_contribution
        if total_cooperators >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_465(BaseStrategy):
    """
    A collective strategy that adapts based on observed cooperation levels.
    Cooperates initially, punishes when cooperation drops below a threshold,
    but forgives if historical cooperation averages meet the threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_act = history.my_actions[prev_round]
        opp_prev_act = history.opponent_actions[prev_round]
        prev_coop = my_prev_act + np.sum(opp_prev_act)
        if prev_coop >= self.m:
            return Action.C
        window_counts = []
        for r_offset in [0, 1, 2]:
            current_r = prev_round - r_offset
            if current_r < 0:
                break
            my_act = history.my_actions[current_r]
            opp_act = history.opponent_actions[current_r]
            coop = my_act + np.sum(opp_act)
            window_counts.append(coop)
        if not window_counts:
            return Action.D
        avg_coop = sum(window_counts) / len(window_counts)
        if avg_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_466(BaseStrategy):
    """
    A strategy that encourages sustained cooperation through adaptive responses.
    Cooperates initially, continues if previous cooperation met a threshold,
    defects once if not, then reverts to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)
        self.last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        sum_coop_prev = my_prev_action + opp_prev_actions.sum()
        if sum_coop_prev >= self.m:
            action = Action.C
        elif self.last_action == Action.D:
            action = Action.C
        else:
            action = Action.D
        self.last_action = action
        return action

class Strategy_COLLECTIVE_468(BaseStrategy):
    """
    Implementation of the "Adaptive Forgiveness" strategy for N-Player Public Goods Game.
    This strategy cooperates initially and continues to cooperate if the number of cooperators 
    meets a threshold. It defects for up to two consecutive rounds if the threshold is not met, 
    then reverts back to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_coop = int(history.my_actions[prev_round])
        opponent_coop = sum(history.opponent_actions[prev_round, :])
        total_coop = my_coop + opponent_coop
        if total_coop >= self.m:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections < 2:
            self.consecutive_defections += 1
            return Action.D
        else:
            self.consecutive_defections = 0
            return Action.C

class Strategy_COLLECTIVE_469(BaseStrategy):
    """
    A strategy where players cooperate in the first round and continue if at least half of the players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opp_prev = history.opponent_actions[prev_round, :]
            total_coop = my_prev + np.sum(opp_prev)
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_474(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = self.n - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r - 1:
            return Action.D
        t_prev = state.round_number - 1
        my_prev = history.my_actions[t_prev]
        opponent_prev = history.opponent_actions[t_prev]
        total_C = my_prev + np.sum(opponent_prev)
        if total_C >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_476(BaseStrategy):
    """
    A strategy that combines initial cooperation with temporary punishment periods 
    when cooperation levels drop below a certain threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.s = 1
        self.defect_remaining = 0
        self.in_punishment = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.in_punishment:
            action = Action.D
            self.defect_remaining -= 1
            if self.defect_remaining <= 0:
                self.in_punishment = False
                self.defect_remaining = 0
            return action
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        others_prev_actions = history.opponent_actions[prev_round]
        total_C = my_prev_action + np.sum(others_prev_actions)
        if total_C < self.m:
            self.in_punishment = True
            self.defect_remaining = self.s
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_477(BaseStrategy):
    """
    A responsive strategy that balances cooperation with self-interest.
    Cooperates initially and continues if enough players cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        m = math.floor(game_description.n_players / game_description.k) + 1
        self.m = min(m, game_description.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_others = history.opponent_actions[-1]
        num_coop = sum(prev_others) + (1 if prev_my_action else 0)
        if num_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_478(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that balances cooperation 
    with responsiveness, incorporating a forgiveness mechanism and endgame defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.just_gave_second_chance = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev = bool(history.my_actions[prev_round])
            opponent_prev = history.opponent_actions[prev_round, :]
            m_prev = int(my_prev) + int(opponent_prev.sum())
            threshold = self.game_description.n_players / self.game_description.k
            threshold_met = m_prev >= threshold
            if threshold_met:
                action = Action.C
                self.just_gave_second_chance = False
            elif self.just_gave_second_chance:
                action = Action.D
                self.just_gave_second_chance = False
            else:
                action = Action.C
                self.just_gave_second_chance = True
            return action

class Strategy_COLLECTIVE_479(BaseStrategy):
    """
    Reciprocal Cooperation Based on Past Success Strategy.

    This strategy starts with cooperation in the first round. In subsequent rounds, it cooperates if at least half of the players (rounded down) cooperated in the previous round, otherwise it defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round]
        sum_opponent_coop = np.sum(opponent_actions_prev)
        my_prev_action = history.my_actions[prev_round]
        total_prev_coop = sum_opponent_coop + (1 if my_prev_action else 0)
        if total_prev_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_480(BaseStrategy):
    """
    A strategy that adapts based on the number of previous cooperators.
    Cooperates in the first round. In subsequent rounds, cooperates if at least m players
    (m = n_players / k) cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players / game_description.k

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        my_previous_action = history.my_actions[-1]
        opponents_previous_actions = history.opponent_actions[-1, :]
        cooperator_count = sum(opponents_previous_actions) + (1 if my_previous_action else 0)
        if cooperator_count >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_481(BaseStrategy):
    """
    Conditional Cooperation Based on Historical Performance strategy.
    Cooperates in the first round, then continues if enough players cooperated previously.
    The threshold is calculated as the ceiling of n_players divided by k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m_threshold = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        m_prev = my_prev_action + sum(opp_prev_actions)
        if m_prev >= self.m_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_482(BaseStrategy):
    """
    Adaptive Cooperation Based on Success Rate Strategy.
    Cooperates initially and continues if past success rate is sufficient.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_payoffs = history.my_payoffs
        count = np.sum(my_payoffs > 1)
        total_rounds = len(my_payoffs)
        success_rate = count / total_rounds if total_rounds != 0 else 0.0
        if success_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_483(BaseStrategy):
    """
    A strategy that starts by cooperating and toggles based on the number of previous cooperators.
    Cooperates if the number of cooperators in the previous round meets or exceeds a calculated threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_my_action = history.my_actions[-1]
            prev_others_actions = history.opponent_actions[-1, :]
            prev_coop = sum(prev_others_actions) + (1 if prev_my_action else 0)
            if prev_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_484(BaseStrategy):
    """
    Collective Strategy for the Collective Risk Dilemma in the N-Player Public Goods Game.
    Cooperates if the number of cooperators in the previous round meets or exceeds a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        sum_opponents = np.sum(history.opponent_actions[prev_round, :])
        my_coop = 1 if history.my_actions[prev_round] else 0
        total_coop = sum_opponents + my_coop
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_485(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game where players Cooperate in the first round and 
    subsequently based on whether the previous round's Cooperators meet a calculated threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_idx = state.round_number - 1
        my_c = history.my_actions[prev_round_idx]
        their_cs = np.sum(history.opponent_actions[prev_round_idx])
        total_coops_prev = my_c + their_cs
        if total_coops_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_487(BaseStrategy):
    """
    Cooperate in the first round. In subsequent rounds, cooperate if all players cooperated in the previous round; otherwise defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opp_prev = history.opponent_actions[prev_round]
        sum_coop = int(my_prev) + int(opp_prev.sum())
        if sum_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_488(BaseStrategy):
    """
    A cooperative strategy inspired by Tit-for-Tat, encouraging sustained cooperation if a sufficient number of players reciprocate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_prev_action = history.my_actions[last_round]
        opponents_prev_actions = history.opponent_actions[last_round]
        total_coop = my_prev_action + opponents_prev_actions.sum()
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_489(BaseStrategy):
    """
    An adaptive strategy to encourage cooperation through responsive punishment and forgiveness.
    Players start by cooperating and adapt based on the number of cooperators in previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n // self.k
        self.cooperate_next = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            if history is not None:
                own_prev_action = history.my_actions[prev_round]
                prev_my_coop = 1 if own_prev_action else 0
                prev_others_coop = np.sum(history.opponent_actions[prev_round, :])
                prev_coop_count = prev_my_coop + prev_others_coop
            else:
                prev_coop_count = 0
            if self.cooperate_next:
                if prev_coop_count >= self.m:
                    action = Action.C
                else:
                    action = Action.D
                    self.cooperate_next = False
            else:
                action = Action.D
                if prev_coop_count >= self.m:
                    self.cooperate_next = True
            return action

class Strategy_COLLECTIVE_490(BaseStrategy):
    """
    This strategy begins with an initial phase of unconditional cooperation, 
    followed by an evaluation of recent cooperation rates to determine future actions, 
    and concludes with an endgame assessment to optimize final outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.h = max(1, self.n_rounds // 4)
        self.w = 3
        self.s_threshold = 0.8

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_players = self.n_players
        if current_round < self.h:
            return Action.C
        if history is None:
            return Action.C
        start_round = max(0, current_round - self.w)
        total_coop = 0.0
        rounds_analyzed = 0
        for rnd in range(start_round, current_round):
            my_action = history.my_actions[rnd]
            opponent_actions = history.opponent_actions[rnd]
            my_coop = 1 if my_action else 0
            opponent_coop = sum(opponent_actions)
            total_coop += my_coop + opponent_coop
            rounds_analyzed += 1
        if rounds_analyzed == 0:
            return Action.D
        avg_coop = total_coop / rounds_analyzed
        threshold = self.s_threshold * n_players
        if avg_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_491(BaseStrategy):
    """
    Adaptive Forgiveness Strategy for N-Player Public Goods Game.
    - Cooperates in the first round.
    - Subsequent rounds: Cooperates if enough players cooperated previously; otherwise, defects.
    - Forgiveness after two consecutive defections.
    - Adapts near the endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.cooperation_threshold = self.n_players // 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_defections = 0
            return Action.C
        if state.round_number == self.n_rounds - 1:
            if self.n_rounds >= 2:
                prev_prev_round = state.round_number - 2
                if prev_prev_round >= 0:
                    opponent_actions_prev_prev = history.opponent_actions[prev_prev_round, :]
                    my_action_prev_prev = history.my_actions[prev_prev_round]
                    total_coop_prev_prev = sum(opponent_actions_prev_prev) + (1 if my_action_prev_prev else 0)
                    if total_coop_prev_prev >= self.cooperation_threshold:
                        return Action.C
                    else:
                        return Action.D
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            total_coop_prev = sum(opponent_actions_prev) + (1 if my_prev_action else 0)
            if total_coop_prev >= self.cooperation_threshold:
                self.consecutive_defections = 0
                return Action.C
            elif my_prev_action == Action.C:
                self.consecutive_defections = 1
                return Action.D
            else:
                self.consecutive_defections += 1
                if self.consecutive_defections >= 2:
                    self.consecutive_defections = 0
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_492(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages cooperation while avoiding perpetual defection.
    It uses a threshold mechanism and a reset after two consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if len(history.my_actions) >= 2:
            last_two_actions = history.my_actions[-2:]
            if not any(last_two_actions):
                return Action.C
        prev_opponent_actions = history.opponent_actions[-1, :]
        prev_self_action = history.my_actions[-1]
        total_cooperators = sum(prev_opponent_actions) + (1 if prev_self_action else 0)
        if total_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_493(BaseStrategy):
    """
    Collective Risk Dilemma Strategy.

    Cooperate in the first round. In subsequent rounds, cooperate if the number 
    of cooperators in the previous round meets a threshold based on n and k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n_players = game_description.n_players
        k = game_description.k
        self.threshold_m = math.ceil(n_players / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponent_actions_last_round = history.opponent_actions[last_round, :]
        n_coop = my_last_action + np.sum(opponent_actions_last_round)
        if n_coop >= self.threshold_m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_494(BaseStrategy):
    """
    Forgiving Cooperation with Punishment Strategy.
    Cooperates unless previous round had fewer cooperators than a threshold (m=floor(k)), 
    then defects once before returning to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or len(history.my_actions) == 0:
            return Action.C
        previous_round = state.round_number - 1
        if previous_round >= len(history.my_actions):
            return Action.C
        my_last_action = history.my_actions[previous_round]
        opponent_last_actions = history.opponent_actions[previous_round, :]
        opponent_coops = np.sum(opponent_last_actions)
        total_coop = int(my_last_action) + opponent_coops
        if total_coop >= self.m:
            return Action.C
        elif not my_last_action:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_496(BaseStrategy):
    """
    A strategy that promotes sustained cooperation through a dynamic threshold of cooperation.
    Cooperates initially and continues if enough players cooperated in the previous round.
    Recovers cooperation by re-cooperating after defection when the threshold isn't met.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        sum_opponents = opponents_prev_actions.sum()
        total_coop_prev = sum_opponents + my_prev_action
        if total_coop_prev >= self.m:
            return Action.C
        elif not my_prev_action:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_497(BaseStrategy):
    """
   Strategy that starts with cooperation, punishes when cooperation drops below a threshold,
    and forgives after one round of punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.threshold = self.n_players // 2
        self.last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
        else:
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            opponent_coop = np.sum(opponent_actions_prev)
            my_prev_action = history.my_actions[prev_round]
            prev_coop = opponent_coop + (1 if my_prev_action else 0)
            if prev_coop >= self.threshold:
                action = Action.C
            elif self.last_action == Action.D:
                action = Action.C
            else:
                action = Action.D
        self.last_action = action
        return action

class Strategy_COLLECTIVE_279(BaseStrategy):
    """
    Cooperative Reset After One Defection (CRAD) strategy.
    Players cooperate initially. They continue cooperating if the number of cooperators
    in the previous round meets or exceeds a threshold m (based on k). If not,
    they defect once as punishment. After defecting once, they reset and cooperate again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)
        self.failure_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_actions = history.opponent_actions[-1, :]
        prev_my_action = history.my_actions[-1]
        prev_cooperators = sum(prev_round_actions) + prev_my_action
        if prev_cooperators >= self.m:
            return Action.C
        else:
            self.failure_counter += 1
            if self.failure_counter == 1:
                return Action.D
            else:
                self.failure_counter = 0
                return Action.C

class Strategy_COLLECTIVE_282(BaseStrategy):
    """
    Adaptive Cooperation Strategy based on Historical Performance.
    
    Description:
    This strategy encourages cooperation if a sufficient number of players 
    (determined by m) have cooperated in the previous round. It starts by 
    cooperating in the first round and adapts based on the collective past 
    behavior to ensure cooperation remains beneficial.

    Attributes:
    game_description: PublicGoodsDescription containing n_players, n_rounds, and k.
    m: The threshold number of previous cooperators required to continue cooperating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_number = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_number]
        others_actions = history.opponent_actions[prev_round_number, :]
        c_prev = 0
        if my_prev_action:
            c_prev += 1
        c_prev += np.sum(others_actions)
        if c_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_284(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on the number of previous cooperators.
    Uses a threshold (m) to decide whether to continue cooperating. If the threshold isn't met, 
    it probabilistically restarts cooperation with probability p.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.p = 0.5
        self.rng = random.Random()
        self.rng.seed(id(self))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round, :]
        num_coop_prev = my_prev_action + opp_prev_actions.sum()
        if num_coop_prev >= self.m:
            return Action.C
        elif self.rng.random() < self.p:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_290(BaseStrategy):
    """
    A strategy that balances persistence and forgiveness in the N-Player Public Goods Game.
    Starts with cooperation, then responds to others' cooperation levels, defecting temporarily if cooperation is insufficient.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.rounds_defect_remaining = 0
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.rounds_defect_remaining > 0:
            self.rounds_defect_remaining -= 1
            return Action.D
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round, :]
        sum_prev_coop = (1 if my_prev_action else 0) + opponent_prev_actions.sum()
        if sum_prev_coop >= self.m:
            return Action.C
        else:
            self.rounds_defect_remaining = 3
            return Action.D

class Strategy_COLLECTIVE_297(BaseStrategy):
    """
    Adaptive Cooperation Based on Recent Successes strategy.
    
    This strategy balances cooperation and defection based on recent group performance.
    It cooperates in the first round, defects in the last round, and adapts based on recent success in middle rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.s = 3
        self.m = math.ceil(self.k)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.r - 1:
            return Action.D
        else:
            t = state.round_number
            start_round = max(0, t - self.s)
            end_round = t - 1
            recent_rounds = list(range(start_round, end_round + 1))
            successful_rounds = 0
            for rd in recent_rounds:
                my_act = history.my_actions[rd]
                opp_sum = np.sum(history.opponent_actions[rd, :])
                total_coop = my_act + opp_sum
                if total_coop >= self.m:
                    successful_rounds += 1
            threshold = math.ceil(self.m / self.n * self.s)
            if successful_rounds >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_301(BaseStrategy):
    """
    A strategic approach to the N-Player Public Goods Game that balances cooperation with measured punishment and forgiveness.
    The strategy aims to sustain collective cooperation by reciprocating cooperation, punishing defection, and forgiving after punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        if not my_prev_action:
            return Action.C
        others_coop = history.opponent_actions[prev_round].sum()
        c_prev = others_coop + (1 if my_prev_action else 0)
        if c_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_329(BaseStrategy):
    """
    A strategy where each player Cooperates in every round to maximize their payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.C

class Strategy_COLLECTIVE_340(BaseStrategy):
    """
    A strategy that balances cooperation with responsive adaptation and a reset mechanism.
    Cooperates initially, continues if previous round met the cooperation threshold,
    and resets to cooperate after defecting.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players - 1

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        if not my_prev_action:
            return Action.C
        opp_previous = history.opponent_actions[previous_round, :]
        sum_opp_C = np.sum(opp_previous)
        total_coop = my_prev_action + sum_opp_C
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_343(BaseStrategy):
    """
    A strategy that encourages cooperation by punishing defection and periodically resetting cooperation.
    Players cooperate initially and continue if enough players cooperated previously. If cooperation drops below a threshold, players defect. After a set number of consecutive defections, cooperation resumes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.reset_threshold = 3
        self.consec_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opp_actions = history.opponent_actions[-1]
        my_prev_action = history.my_actions[-1]
        t_prev = sum(opp_actions) + my_prev_action
        if t_prev >= self.m:
            self.consec_defects = 0
            return Action.C
        else:
            self.consec_defects += 1
            if self.consec_defects >= self.reset_threshold:
                self.consec_defects = 0
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_351(BaseStrategy):
    """
    Adaptive Cooperation Based on Past Performance Strategy.

    This strategy starts with cooperation and adapts based on the number of cooperators in the previous round. 
    Players cooperate if the previous round's cooperators meet or exceed a threshold (m), which is half the number of players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        total_coop = my_prev_action + np.sum(opponents_prev_actions)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_381(BaseStrategy):
    """
    A strategy designed to ensure at least `m` cooperators in each round by adapting based on previous outcomes.
    Cooperates in the first round and continues to cooperate if the number of cooperators in the previous round meets a threshold derived from the game's multiplication factor `k`.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        cooperators_opponents = np.sum(opponent_actions_prev)
        cooperators_total = cooperators_opponents + (1 if my_prev_action else 0)
        if cooperators_total >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_382(BaseStrategy):
    """
    A strategy that balances cooperation and punishment based on previous round outcomes.
    Cooperates if the number of cooperators in the previous round meets a threshold, otherwise defects for a set number of rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.game_description.n_players // 2
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_actions = history.opponent_actions[previous_round, :]
        opponent_cooperations = np.sum(opponent_actions)
        total_cooperations = opponent_cooperations + (1 if my_prev_action else 0)
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        elif total_cooperations >= self.threshold:
            return Action.C
        else:
            self.punishment_remaining = 2
            return Action.D

class Strategy_COLLECTIVE_405(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on the previous round's cooperation level.
    Defects once if previous cooperation was below a threshold (n-1), then switches back to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = self.n - 1
        self.last_action_was_punishment = False

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        if history is None:
            return Action.C
        if self.last_action_was_punishment:
            self.last_action_was_punishment = False
            return Action.C
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        total_coop_prev = my_prev_action + int(opponent_prev_actions.sum())
        if total_coop_prev >= self.m:
            return Action.C
        else:
            self.last_action_was_punishment = True
            return Action.D

class Strategy_COLLECTIVE_409(BaseStrategy):
    """
    Adaptive cooperation based on historical success ratio.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)
        self.p = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_rounds = state.round_number
        successful_rounds = 0
        for t in range(total_rounds):
            my_action = history.my_actions[t]
            opponent_actions = history.opponent_actions[t]
            n_coop = my_action + sum(opponent_actions)
            if n_coop >= self.m:
                successful_rounds += 1
        if total_rounds == 0:
            success_ratio = 0.0
        else:
            success_ratio = successful_rounds / total_rounds
        if success_ratio > self.p:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_415(BaseStrategy):
    """
    Cooperative Punishment with Adaptive Threshold Strategy.
    Cooperates initially, punishes if the threshold of cooperators is not met,
    and adapts decision in the last round based on expected opponent cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.game_description.n_rounds - 1:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponent_prev = sum(history.opponent_actions[prev_round, :])
            total_c = my_prev + opponent_prev
            if total_c >= self.m:
                return Action.C
            else:
                return Action.D
        else:
            n_prev_rounds = state.round_number
            expected_opponents = 0.0
            for opponent in range(history.opponent_actions.shape[1]):
                cooperation = sum((history.opponent_actions[i, opponent] for i in range(n_prev_rounds)))
                avg = cooperation / n_prev_rounds
                expected_opponents += avg
            if expected_opponents + 1 >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_431(BaseStrategy):
    """
    Adaptive Collective Cooperation with Forgiveness strategy.
    Cooperates initially, then adapts based on the number of cooperators in the previous round.
    Forgiveness mechanism switches back to cooperation after two consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        my_contribution = int(my_prev_action)
        opponents_contribution = np.sum(opponents_prev_actions)
        total_coops = my_contribution + opponents_contribution
        if self.consecutive_defects >= 2:
            self.consecutive_defects = 0
            return Action.C
        if total_coops >= self.m:
            self.consecutive_defects = 0
            return Action.C
        else:
            self.consecutive_defects += 1
            return Action.D

class Strategy_COLLECTIVE_432(BaseStrategy):
    """
    Cooperate in the first round. For subsequent rounds, cooperate if at least m players 
    cooperated in the previous round, where m is the ceiling of n/k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_my = history.my_actions[-1]
            prev_opponents = history.opponent_actions[-1, :]
            total_C = prev_my + prev_opponents.sum()
            if total_C >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_433(BaseStrategy):
    """
    A strategy that promotes cooperation while adapting based on past outcomes to address the collective risk dilemma.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            past_rounds = state.round_number
            if past_rounds == 0:
                return Action.C
            success_count = 0
            for t in range(past_rounds):
                my_action = history.my_actions[t]
                opponent_actions = history.opponent_actions[t]
                coops = int(my_action) + int(np.sum(opponent_actions))
                if coops >= self.m:
                    success_count += 1
            success_rate = success_count / past_rounds
            threshold = self.m / self.game_description.n_players
            if success_rate >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_435(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that cooperates initially, continues cooperating 
    if a sufficient number of players cooperate historically, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m_threshold = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_action = history.my_actions[previous_round]
        opponent_actions = history.opponent_actions[previous_round]
        total_coop = int(my_action) + np.sum(opponent_actions)
        if total_coop >= self.m_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_450(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) strategy to promote sustained cooperation.
    Cooperates initially, then adapts based on previous round's cooperation levels.
    Punishes by defecting if cooperation drops below a threshold, then resumes cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m_threshold = game_description.n_players // 2
        self.last_defected = False

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number < 2:
            self.last_defected = False
            return Action.C
        elif self.last_defected:
            self.last_defected = False
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_last = int(history.my_actions[prev_round])
            opponents_last = history.opponent_actions[prev_round, :]
            opponent_coop = int(np.sum(opponents_last))
            total_coop = my_last + opponent_coop
            if total_coop >= self.m_threshold:
                self.last_defected = False
                return Action.C
            else:
                self.last_defected = True
                return Action.D

class Strategy_COLLECTIVE_453(BaseStrategy):
    """
    A strategy designed to encourage sustained cooperation in the N-player public goods game.
    It uses a dynamic threshold based on the number of players and the multiplication factor.
    The strategy encourages cooperation upon meeting the threshold and uses strategic defection
    to deter low cooperation, with a reset mechanism after two consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.cooperating = True
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponents_prev_actions = history.opponent_actions[previous_round]
        count_coop = my_prev_action + sum(opponents_prev_actions)
        if count_coop >= self.m:
            self.cooperating = True
        else:
            self.cooperating = False
        if self.cooperating or self.consecutive_defections >= 2:
            action = Action.C
            self.consecutive_defections = 0
        else:
            action = Action.D
            self.consecutive_defections += 1
        return action

class Strategy_COLLECTIVE_467(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on the level of cooperation in the group.
    It cooperates if at least half of the players (rounded down) cooperated in the previous round;
    otherwise, it defects once and then returns to cooperation in the following round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.next_must_coop = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.next_must_coop:
            self.next_must_coop = False
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opp_prev = history.opponent_actions[prev_round]
        total_coop = my_prev + np.sum(opp_prev)
        if total_coop >= self.m:
            return Action.C
        else:
            self.next_must_coop = True
            return Action.D

class Strategy_COLLECTIVE_470(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy for N-Player Public Goods Game.
    Cooperates initially, then continues if enough players cooperated previously, otherwise defects once.
    Reverts to cooperation after a punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)
        self.punishment_phase = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishment_phase:
            self.punishment_phase = False
            return Action.C
        prev_round_number = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_number]
        opponents_prev_actions = history.opponent_actions[prev_round_number]
        n_coop_prev = np.sum(opponents_prev_actions) + (1 if my_prev_action else 0)
        if n_coop_prev >= self.m:
            return Action.C
        else:
            self.punishment_phase = True
            return Action.D

class Strategy_COLLECTIVE_471(BaseStrategy):
    """
    Strategy for N-player public goods game based on conditional cooperation and endgame defection.
    Cooperates initially, continues if previous round meets cooperation threshold, and defects in the last two rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.m = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.n_rounds - 2:
            return Action.D
        if history is not None:
            prev_my_action = history.my_actions[-1]
            prev_opponents = history.opponent_actions[-1]
            total_c = prev_my_action + np.sum(prev_opponents)
            if total_c >= self.m:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_472(BaseStrategy):
    """
    Adaptive Cooperation Strategy based on historical success.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        historical_successes = 0
        for j in range(state.round_number):
            my_coop = history.my_actions[j]
            opponent_coop = sum(history.opponent_actions[j, :])
            total_coop = my_coop + opponent_coop
            if total_coop >= self.m:
                historical_successes += 1
        past_rounds = state.round_number
        success_ratio = historical_successes / past_rounds if past_rounds != 0 else 0
        if success_ratio >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_473(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that starts with cooperation 
    and adjusts reciprocity based on the previous round's contributions.
    Continues to cooperate if the previous round's contribution threshold was met.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev = history.opponent_actions[prev_round]
        my_prev_int = int(my_prev_action)
        opponents_prev_sum = np.sum(opponents_prev.astype(int))
        m_prev = my_prev_int + opponents_prev_sum
        threshold_met = self.k * m_prev / self.n >= 1
        return Action.C if threshold_met else Action.D

class Strategy_COLLECTIVE_475(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages cooperation 
    by defecting briefly when cooperation thresholds are not met, then 
    returning to cooperation to promote group recovery.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.pending_punishment = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            last_round = state.round_number - 1
            my_prev = history.my_actions[last_round]
            opponents_prev = history.opponent_actions[last_round]
            sum_prev = my_prev + np.sum(opponents_prev)
            if sum_prev >= self.m:
                self.pending_punishment = False
                return Action.C
            elif self.pending_punishment:
                self.pending_punishment = False
                return Action.C
            else:
                self.pending_punishment = True
                return Action.D

class Strategy_COLLECTIVE_495(BaseStrategy):
    """
    Adaptive Cooperation with Retaliation and Forgiveness Strategy.
    Starts with cooperation, retaliates against low cooperation, and forgives after retaliation.
    Cooperates in the last rounds to maximize payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.ret_rounds = 2
        self.window_size = 3
        self.ret_remaining = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.C
        if self.ret_remaining > 0:
            self.ret_remaining -= 1
            return Action.D
        sum_coop = 0
        max_rounds_available = state.round_number - 1
        start_round = max(0, max_rounds_available - self.window_size + 1)
        for t in range(start_round, max_rounds_available + 1):
            own_coop = history.my_actions[t]
            opp_coop = sum(history.opponent_actions[t, :])
            sum_coop += own_coop + opp_coop
        total_rounds = max_rounds_available + 1 - start_round
        n = self.game_description.n_players
        threshold = total_rounds * n * 0.5
        if sum_coop >= threshold:
            return Action.C
        else:
            self.ret_remaining = self.ret_rounds
            return Action.D

class Strategy_COLLECTIVE_498(BaseStrategy):
    """
    A strategy that promotes cooperation by punishing insufficient cooperation and resetting.
    Cooperates initially, then defects once if cooperation is below a threshold (n/k),
    and resets cooperation afterward.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.last_defection_flag = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_coops = history.my_actions[-1] + history.opponent_actions[-1].sum()
        m = self.game_description.n_players / self.game_description.k
        if prev_coops >= m:
            self.last_defection_flag = False
            return Action.C
        elif not self.last_defection_flag:
            self.last_defection_flag = True
            return Action.D
        else:
            self.last_defection_flag = False
            return Action.C

class Strategy_COLLECTIVE_499(BaseStrategy):
    """
    Cooperative Reset with Punishment Strategy.

    This strategy starts with cooperating and continues to cooperate as long as
    the number of cooperators is sufficient (at least m, which is the total number
    of players). If cooperation drops below m, it defects in the next round and
    then reverts back to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players
        self.force_cooperate_next = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.force_cooperate_next:
            self.force_cooperate_next = False
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        count_prev = int(my_prev_action) + np.sum(opp_prev_actions)
        if count_prev >= self.m:
            return Action.C
        else:
            self.force_cooperate_next = True
            return Action.D

class Strategy_COLLECTIVE_500(BaseStrategy):
    """
    A strategy that promotes sustained cooperation by punishing defection once and then recovering.
    
    Players cooperate initially and continue if the previous round had enough cooperators (threshold m).
    If cooperation falls below the threshold, they defect but attempt to recover in the next round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)
        self.last_action = None
        self.defected_due_to_low_S = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            self.defected_due_to_low_S = False
            return Action.C
        else:
            prev_my_C = history.my_actions[-1]
            prev_others_C = [history.opponent_actions[-1][i] for i in range(self.game_description.n_players - 1)]
            s_prev = sum(prev_others_C) + (1 if prev_my_C else 0)
            if s_prev >= self.m:
                self.defected_due_to_low_S = False
                self.last_action = Action.C
                return Action.C
            elif self.defected_due_to_low_S:
                self.defected_due_to_low_S = False
                self.last_action = Action.C
                return Action.C
            else:
                self.defected_due_to_low_S = True
                self.last_action = Action.D
                return Action.D

class Strategy_COLLECTIVE_501(BaseStrategy):
    """
    A strategy to sustain cooperation in a repeated public goods game by evaluating historical success.
    Cooperates initially and continues if more than half of previous rounds were successful.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        successful_rounds = 0
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            opponents_actions = history.opponent_actions[t]
            s_t = int(my_action) + int(opponents_actions.sum())
            if s_t >= self.m:
                successful_rounds += 1
        total_prior = state.round_number
        proportion = successful_rounds / total_prior
        if proportion > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_502(BaseStrategy):
    """
    A strategy that starts with cooperation and then conditions cooperation on 
    the number of cooperators from the previous round exceeding a threshold m.
    The threshold m is calculated as m = ceil(n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_last_action = history.my_actions[previous_round]
        opponent_actions_last = history.opponent_actions[previous_round, :]
        n_cooperators = my_last_action + np.sum(opponent_actions_last)
        if n_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_504(BaseStrategy):
    """
    A strategy designed to address the Collective Risk Dilemma by balancing cooperation 
    with strategic punishment, using a calculated threshold based on game parameters to 
    decide actions in each round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            if history is None:
                return Action.C
            total_rounds = len(history.my_actions)
            success_count = 0
            for prev_round in range(total_rounds):
                my_action = history.my_actions[prev_round]
                opp_actions = history.opponent_actions[prev_round, :]
                num_C = int(my_action) + np.sum(opp_actions)
                if num_C >= self.m:
                    success_count += 1
            if success_count / total_rounds > 0.5:
                return Action.C
            else:
                return Action.D
        else:
            if history is None:
                return Action.C
            prev_round = current_round - 1
            my_action_prev = history.my_actions[prev_round]
            opp_actions_prev = history.opponent_actions[prev_round, :]
            num_C_prev = int(my_action_prev) + np.sum(opp_actions_prev)
            if num_C_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_505(BaseStrategy):
    """
    Adaptive Reciprocity with Reinitiation strategy to address collective risk dilemmas.
    Cooperates initially, reciprocates cooperation, reinitiates after consecutive defections,
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.consecutive_defections = 0
        self.CONSECUTIVE_DEFECTS_BEFORE_REINITIATION = 3
        self.threshold = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.game_description.n_rounds - 1:
            return Action.D
        previous_round = current_round - 1
        my_prev_action = history.my_actions[previous_round]
        prev_opponent_actions = history.opponent_actions[previous_round]
        n_coop_prev = 0
        if my_prev_action:
            n_coop_prev += 1
        n_coop_prev += np.count_nonzero(prev_opponent_actions)
        met_threshold = n_coop_prev >= self.threshold
        if met_threshold or self.consecutive_defections >= self.CONSECUTIVE_DEFECTS_BEFORE_REINITIATION:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            return Action.D

class Strategy_COLLECTIVE_506(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) Strategy.
    
    This strategy starts by Cooperating in the first round to encourage initial cooperation.
    In subsequent rounds, it calculates the average number of Cooperators from all previous rounds.
    If this average meets or exceeds a threshold (computed as n_players / k), it continues to Cooperate.
    Otherwise, it defects to protect individual payoffs when collective cooperation falters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players / self.game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        sum_cooperators = 0.0
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            opponent_actions = history.opponent_actions[t]
            total = my_action + sum(opponent_actions)
            sum_cooperators += total
        avg_cooperators = sum_cooperators / state.round_number
        if avg_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_507(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy.

    Cooperates in the first round. In subsequent rounds, cooperates if the previous round's total cooperators meet a threshold (m = ceil(n/k)), otherwise defects. After defecting, continues to defect until cooperation recovers above the threshold, then returns to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.is_punishing = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        sum_opponent_prev = sum(history.opponent_actions[-1, :])
        prev_total_c = sum_opponent_prev + (1 if my_prev_action else 0)
        if not self.is_punishing:
            if prev_total_c >= self.m:
                return Action.C
            else:
                self.is_punishing = True
                return Action.D
        elif prev_total_c >= self.m:
            self.is_punishing = False
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_508(BaseStrategy):
    """
    Cooperative Punishment with Forgiveness Strategy.
    
    This strategy begins by cooperating in the first round and subsequently
    decides whether to cooperate or defect based on the number of cooperators
    in the previous round. If the number of cooperators meets a threshold (m),
    the strategy continues to cooperate. If not, it defects in the current round
    and cooperate in the next round as an act of forgiveness.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k
        self.must_cooperate_next = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.must_cooperate_next = False
            return Action.C
        elif self.must_cooperate_next:
            self.must_cooperate_next = False
            return Action.C
        else:
            if history is None:
                return Action.D
            prev_my_action = history.my_actions[-1]
            prev_opponent_actions = history.opponent_actions[-1]
            cooperators = int(prev_my_action) + sum(prev_opponent_actions)
            if cooperators >= self.m:
                return Action.C
            else:
                self.must_cooperate_next = True
                return Action.D

class Strategy_COLLECTIVE_509(BaseStrategy):
    """
    A strategy that balances cooperation and punishment to foster collective benefits while avoiding exploitation.
    It begins with cooperation, continues if cooperation was sufficient in the previous round, punishes by defecting
    if cooperation was insufficient, and limits punishment to a maximum of two consecutive rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // self.game_description.k + 1
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_defections = 0
            return Action.C
        last_round = state.round_number - 1
        my_last = history.my_actions[last_round]
        others_last = history.opponent_actions[last_round]
        total_coops = my_last + np.sum(others_last)
        if total_coops >= self.m:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections < 2:
            self.consecutive_defections += 1
            return Action.D
        else:
            self.consecutive_defections = 0
            return Action.C

class Strategy_COLLECTIVE_510(BaseStrategy):
    """
    A strategy that promotes sustained cooperation by rewarding group cooperation 
    and punishing defection. It starts by cooperating and will continue to do so 
    as long as the group meets a cooperation threshold. If the threshold is not met, 
    it defects and remains in punishment mode until the threshold is met again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.state = 'cooperate'

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        me_prev = history.my_actions[previous_round]
        opponents_prev = history.opponent_actions[previous_round]
        total_prev_C = me_prev + opponents_prev.sum()
        if self.state == 'cooperate':
            if total_prev_C >= self.m:
                return Action.C
            else:
                self.state = 'punish'
                return Action.D
        elif total_prev_C >= self.m:
            self.state = 'cooperate'
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_511(BaseStrategy):
    """
    Adaptive Cooperation with Reset Mechanism Strategy for Public Goods Game.
    Cooperates initially, then responds based on previous cooperation levels.
    Resets cooperation periodically after consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.reset_threshold = 2
        self.threshold = math.ceil(self.n / self.k)
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_defects = 0
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponent_prev_actions = history.opponent_actions[-1, :]
        c_prev = my_prev_action + sum(opponent_prev_actions)
        if not my_prev_action:
            self.consecutive_defects += 1
        else:
            self.consecutive_defects = 0
        if self.consecutive_defects >= self.reset_threshold:
            self.consecutive_defects = 0
            return Action.C
        if c_prev >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_512(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACWP) strategy for N-Player Public Goods Game.
    Cooperates in the first round, then continues cooperating if at least m players cooperated
    in the previous round, otherwise defects. The threshold m is calculated as the ceiling of half the number of players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = (self.n_players + 1) // 2

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        others = history.opponent_actions[prev_round]
        sum_others = sum(others)
        my_action = history.my_actions[prev_round]
        total_c = sum_others + (1 if my_action else 0)
        if total_c >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_1(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.recoop_remaining = 0
        self.last_total_c = None

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if self.recoop_remaining > 0:
            self.recoop_remaining -= 1
            return Action.C
        prev_round = state.round_number - 1
        if history is None or prev_round < 0:
            my_prev_action = False
            opponent_prev_actions = np.zeros(self.n_players - 1, dtype=bool)
        else:
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round]
        total_c_prev = 1 if my_prev_action else 0
        total_c_prev += sum(opponent_prev_actions)
        self.last_total_c = total_c_prev
        if self.last_total_c >= self.m:
            new_total = sum(opponent_prev_actions)
            if new_total >= self.m:
                if random.random() < 0.2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        else:
            self.recoop_remaining = 3
            return Action.C

class Strategy_EXPLOITATIVE_2(BaseStrategy):
    """
    Implements the Reactive Cooperator strategy, cooperating initially and reciprocating based on previous cooperation levels.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            sum_opponents = sum(history.opponent_actions[prev_round, :])
            sum_total = sum_opponents + (1 if my_prev_action else 0)
            if sum_total >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_3(BaseStrategy):
    """
    A strategy that adaptively cooperates based on the trend of past cooperation.
    Initially cooperates, then uses the average of the last three rounds' cooperation rates.
    Defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            if history is None:
                return Action.C
            previous_rounds = history.my_actions.shape[0]
            window = min(3, previous_rounds)
            start_round = max(0, previous_rounds - window)
            total = 0.0
            for r in range(start_round, previous_rounds):
                my_action = history.my_actions[r]
                opponent_actions = history.opponent_actions[r]
                count = int(my_action) + np.sum(opponent_actions)
                total += count
            avg = total / (previous_rounds - start_round)
            if avg >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_5(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        met_threshold_count = 0
        n_players = self.game_description.n_players
        for r in range(state.round_number):
            my_action = history.my_actions[r]
            opponents_coop = history.opponent_actions[r, :]
            sum_coop = my_action + np.sum(opponents_coop)
            threshold = 0.5 * n_players
            if sum_coop > threshold:
                met_threshold_count += 1
        frequency = met_threshold_count / state.round_number
        if frequency > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_6(BaseStrategy):
    """
    Adaptive Cooperation with Endgame Defection strategy.
    Cooperates initially, adapts based on previous cooperation levels,
    and defects in the last round to maximize payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        my_contribution = 1 if my_prev_action else 0
        opponent_contributions = history.opponent_actions[prev_round].sum()
        sum_prev = my_contribution + opponent_contributions
        k = self.game_description.k
        n = self.game_description.n_players
        threshold = k / n * sum_prev
        if threshold >= 1.0:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_7(BaseStrategy):
    """
    Adaptive Exploitation with Forgiveness strategy for the Public Goods Game.
    This strategy starts with cooperation and adapts based on historical cooperation levels,
    balancing exploitation and cooperation to maximize personal gain while maintaining collective benefits.
    """
    WINDOW_SIZE = 3

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players / game_description.k
        self.consecutive_below = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_below = 0
            return Action.C
        window_start = max(0, state.round_number - self.WINDOW_SIZE)
        sum_coop = 0
        for r in range(window_start, state.round_number):
            my_action = history.my_actions[r]
            opponent_actions = history.opponent_actions[r]
            sum_coop += (1 if my_action else 0) + sum(opponent_actions)
        n_rounds = state.round_number - window_start
        avg_coop = sum_coop / n_rounds if n_rounds > 0 else 0.0
        if state.round_number == self.game_description.n_rounds - 1:
            possible_avg = sum_coop / self.game_description.n_rounds
            if possible_avg >= self.m - 1e-09:
                return Action.D
            else:
                return Action.C
        else:
            if avg_coop < self.m - 1e-09:
                self.consecutive_below += 1
            else:
                self.consecutive_below = 0
            if self.consecutive_below >= 3:
                return Action.C
            if avg_coop >= self.m - 1e-09:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_8(BaseStrategy):
    """
    The Adaptive Cooperation with Exploration (ACE) strategy.
    Cooperates initially to set a cooperative tone, defects in the last round,
    and uses the historical average of cooperators to decide actions in subsequent rounds,
    with a 10% exploration rate to test other possibilities.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players / 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds - 1:
            return Action.D
        elif current_round == 0:
            return Action.C
        else:
            sum_coop = 0.0
            for round_num in range(current_round):
                my_c = 1 if history.my_actions[round_num] else 0
                opponent_c = history.opponent_actions[round_num].sum()
                sum_coop += my_c + opponent_c
            avg_coop = sum_coop / current_round
            if avg_coop >= self.m:
                return Action.C
            elif random.random() < 0.1:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_9(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.threshold = 0.75
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        if round_number >= n_rounds - 2:
            return Action.C
        if round_number <= 1:
            return Action.C
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        cooperation_rates = []
        for r in range(1, 4):
            target_round = round_number - r
            if target_round < 0:
                break
            my_coop = history.my_actions[target_round]
            opponents_coop = sum(history.opponent_actions[target_round])
            total_coop = my_coop + opponents_coop
            rate = total_coop / self.n_players
            cooperation_rates.append(rate)
        if cooperation_rates:
            avg_coop = sum(cooperation_rates) / len(cooperation_rates)
            if avg_coop >= self.threshold:
                return Action.C
            else:
                self.punishment_remaining = 2
                return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_10(BaseStrategy):
    """
    Adaptive Exploitation Based on Past Cooperation Success.
    Cooperates initially, then adapts based on previous cooperation rates.
    Defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = max(1, int(game_description.k))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_action_prev = history.my_actions[previous_round]
        opponents_actions_prev = history.opponent_actions[previous_round]
        coop_count_opponents = np.sum(opponents_actions_prev)
        total_coop = my_action_prev + coop_count_opponents
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_11(BaseStrategy):
    """An adaptive strategy that cooperates based on historical cooperation levels."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponents_prev = history.opponent_actions[prev_round, :]
        sum_opponents = np.sum(opponents_prev)
        my_prev = history.my_actions[prev_round]
        total_prev_coop = sum_opponents + my_prev
        if total_prev_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_12(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Public Goods Game.

    Cooperates initially to encourage others, defects in the final round, 
    and base decisions on historical cooperation averages in between.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = int(self.k)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        cooperators = 0
        for round_num in range(current_round):
            my_action = history.my_actions[round_num]
            opponents = history.opponent_actions[round_num]
            coop = sum(opponents) + (1 if my_action else 0)
            cooperators += coop
        avg_coop = cooperators / current_round
        if avg_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_13(BaseStrategy):
    """
    A strategy that balances cooperation based on opponents' past behavior.
    Cooperates initially, then decides based on the average cooperation of others.
    Aims to contribute only when necessary to meet a threshold for collective benefit.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_rounds = history.opponent_actions[:state.round_number]
        sum_coop = np.sum(prev_rounds, axis=1)
        avg_coop = np.mean(sum_coop) if len(sum_coop) > 0 else 0.0
        s_other = avg_coop
        s_total = s_other + 1
        if s_total >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_14(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and strategic defection.
    It starts by cooperating, adapts based on past outcomes, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_t = state.round_number - 1
        prev_my_action = history.my_actions[prev_t]
        prev_my_payoff = history.my_payoffs[prev_t]
        c_i_prev = 1 if prev_my_action else 0
        if prev_my_action:
            sum_prev = prev_my_payoff * (self.n_players / self.k)
        else:
            sum_prev = (prev_my_payoff - 1) * (self.n_players / self.k)
        threshold = self.n_players / self.k
        if sum_prev >= threshold:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections < 2:
            self.consecutive_defections += 1
            return Action.D
        else:
            self.consecutive_defections = 0
            return Action.C

class Strategy_EXPLOITATIVE_15(BaseStrategy):
    """
    Exploitative strategy for N-Player Public Goods Game.
    Cooperates initially, then defects if sufficient others cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(math.floor(game_description.k))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_c = history.my_actions[prev_round]
        opponents_prev_c = history.opponent_actions[prev_round]
        total_coop = (1 if my_prev_c else 0) + sum(opponents_prev_c)
        if total_coop >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_16(BaseStrategy):
    """
    Adaptive Punishment with Last-Round Exploitation strategy for the N-Player Public Goods Game.
    Cooperates initially, punishes when cooperation is below a threshold, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = current_round - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            num_coop = int(my_prev_action) + np.count_nonzero(opponents_prev_actions)
            if num_coop < self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_17(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that adaptively chooses between cooperation (C) and defection (D)
    based on the number of previous cooperators, with periodic testing of cooperation potential.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)
        self.testing_interval = 5
        self.testing_counter = 0
        self.last_action = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            action = Action.C
        elif t == self.game_description.n_rounds - 1:
            action = Action.D
            if history is not None:
                if t - 1 >= len(history.my_actions):
                    prev_coop = 0
                else:
                    prev_t = t - 1
                    my_prev_action = history.my_actions[prev_t]
                    opponent_prev_actions = history.opponent_actions[prev_t]
                    my_coop = 1 if my_prev_action else 0
                    opponent_coop = np.sum(opponent_prev_actions)
                    prev_coop = my_coop + opponent_coop
                    action = Action.C if prev_coop >= self.m else Action.D
        else:
            prev_t = t - 1
            prev_coop = 0
            if history is not None and prev_t >= 0:
                if prev_t < len(history.my_actions):
                    my_prev_action = history.my_actions[prev_t]
                    opponent_prev_actions = history.opponent_actions[prev_t]
                    my_coop = 1 if my_prev_action else 0
                    opponent_coop = np.sum(opponent_prev_actions)
                    prev_coop = my_coop + opponent_coop
            if self.last_action == Action.D and self.testing_counter >= self.testing_interval:
                action = Action.C
                self.testing_counter = 0
            else:
                action = Action.C if prev_coop >= self.m else Action.D
            if action == Action.D:
                self.testing_counter += 1
            else:
                pass
        self.last_action = action
        return action

class Strategy_EXPLOITATIVE_18(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        my_contribution = int(my_prev_action)
        opponent_acts = history.opponent_actions[prev_round, :]
        sum_opponent = np.sum(opponent_acts)
        total_cooperators = my_contribution + sum_opponent
        if total_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_19(BaseStrategy):
    """
    Exploitative strategy for the N-Player Public Goods Game. 
    Cooperates in the first round, then defects if previous round's cooperators meet a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_last = history.my_actions[prev_round]
        oppo_last = history.opponent_actions[prev_round]
        total_coop = int(my_last) + np.sum(oppo_last)
        if total_coop >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_20(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on the number of previous cooperators.
    Cooperate initially, then defect when previous cooperation was above a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_last = history.my_actions[-1]
        opp_last = history.opponent_actions[-1, :]
        sum_coop_last = 1 if my_last else 0
        sum_coop_last += sum(opp_last)
        if sum_coop_last > self.m:
            return Action.D
        elif sum_coop_last == self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_21(BaseStrategy):
    """
    A strategy designed for the N-Player Public Goods Game. It starts by Cooperating 
    in the first round, adapts based on the number of Cooperators in subsequent rounds,
    and Defects in the last round to maximize personal payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.game_description.n_players // 2
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opp_prev = sum(history.opponent_actions[prev_round, :])
        total_coop_prev = opp_prev + (1 if my_prev else 0)
        if total_coop_prev >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_22(BaseStrategy):
    """
    Adaptive strategy for N-Player Public Goods Game balancing cooperation and self-interest.
    Cooperates initially, adapts based on past cooperation, and defects in the final rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        x = self.n_players / self.k
        if x == int(x):
            self.m = int(x) + 1
        else:
            self.m = math.ceil(x)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.n_rounds - 2:
            return Action.D
        count_sufficient = 0
        total_rounds = state.round_number
        for prev_round in range(total_rounds):
            opponent_actions = history.opponent_actions[prev_round]
            own_action = history.my_actions[prev_round]
            cooperators = np.sum(opponent_actions) + (1 if own_action else 0)
            if cooperators >= self.m:
                count_sufficient += 1
        proportion = count_sufficient / total_rounds if total_rounds != 0 else 0.0
        if proportion > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_23(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Performance strategy.
    Cooperates initially, then continues if enough historical rounds met the cooperation threshold.
    The threshold is derived from the game's multiplication factor k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        sufficient = 0
        for r in range(state.round_number):
            my_action = 1 if (history.my_actions[r] if r < len(history.my_actions) else False) else 0
            opponent_actions = history.opponent_actions[r] if r < history.opponent_actions.shape[0] else np.array([], dtype=bool)
            opp_c = np.sum(opponent_actions)
            total = my_action + opp_c
            if total >= self.m:
                sufficient += 1
        total_previous_rounds = state.round_number
        if sufficient > total_previous_rounds / 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_24(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that balances cooperation and defection based on past outcomes.
    Starts with cooperation, then decides to defect if past defections were successful enough (>=50% success rate).
    Success of a defection is measured by whether the number of other cooperators met a threshold m.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = max(1, int(game_description.k))
        self.total_defects = 0
        self.defect_succeeded = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        my_actions = history.my_actions
        opp_actions = history.opponent_actions
        rounds_defected = np.where(my_actions == False)[0]
        total_defects = len(rounds_defected)
        if total_defects == 0:
            return Action.C
        successful = 0
        for rd in rounds_defected:
            if rd < opp_actions.shape[0]:
                sum_coop = np.sum(opp_actions[rd, :])
                if sum_coop >= self.m:
                    successful += 1
        success_rate = successful / total_defects
        threshold = 0.5
        if success_rate >= threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_25(BaseStrategy):
    """
    A strategy that adapts based on the cooperation of other players in the last three rounds.
    Starts by cooperating, then cooperates if others do, defects otherwise.
    Defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif history is None:
            return Action.C
        else:
            n = self.game_description.n_players
            m = n / 2
            rounds = range(max(0, state.round_number - 3), state.round_number)
            sum_c = 0
            count = 0
            for r in rounds:
                if r < len(history.my_actions):
                    opp_coop = sum(history.opponent_actions[r, :])
                    my_coop = 1 if history.my_actions[r] else 0
                    sum_c += opp_coop + my_coop
                    count += 1
            if count == 0:
                return Action.C
            average_c = sum_c / count
            if average_c >= m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_26(BaseStrategy):
    """
    Adaptive Exploitation strategy for N-Player Public Goods Game.
    Cooperates initially, retaliates if cooperation is insufficient, and monitors for improvement.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.retaliating = False
        self.retaliate_threshold = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if not self.retaliating:
            previous_round = state.round_number - 1
            sum_opponents = sum(history.opponent_actions[previous_round, :]) if history else 0
            my_prev_action = history.my_actions[previous_round] if history and history.my_actions.size > previous_round else False
            prev_coop = sum_opponents + (1 if my_prev_action else 0)
            threshold = self.game_description.n_players // 2 + 1
            if prev_coop < threshold:
                self.retaliating = True
                self.retaliate_threshold = prev_coop
                return Action.D
            else:
                return Action.C
        else:
            previous_round = state.round_number - 1
            sum_opponents = sum(history.opponent_actions[previous_round, :]) if history else 0
            my_prev_action = history.my_actions[previous_round] if history and history.my_actions.size > previous_round else False
            current_coop = sum_opponents + (1 if my_prev_action else 0)
            if current_coop > self.retaliate_threshold:
                self.retaliating = False
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_27(BaseStrategy):
    """
    A strategy that starts with cooperation, adapts based on previous rounds' cooperation levels, 
    and periodically probes by cooperating to test potential renewed cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number % 5 == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponents_prev = history.opponent_actions[prev_round, :]
        total_coop = my_prev + sum(opponents_prev)
        m = self.n_players // 2
        if total_coop >= m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_28(BaseStrategy):
    """
    Adaptive Exploitation Strategy for N-Player Public Goods Game.
    
    This strategy balances cooperation with strategic exploitation, adapting
    based on opponents' behavior. The player starts by cooperating, punishes 
    non-cooperation, and exploits sustained cooperation. It adapts to high 
    defection rates by mostly defecting.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.coop_streak = 0
        self.punished_last_round = False
        self.defect_threshold = 0.5

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        last_round = state.round_number - 1
        if not history:
            return Action.C
        sum_coop = history.my_actions[last_round] + sum(history.opponent_actions[last_round, :])
        n_past_rounds = last_round + 1
        opp_defections = 0
        if n_past_rounds > 0:
            for r in range(n_past_rounds):
                opp_defections_round = r
                coop_count = sum(history.opponent_actions[r, :])
                opp_defections += len(history.opponent_actions[r, :]) - coop_count
            defect_rate = opp_defections / (n_past_rounds * (self.n_players - 1))
        else:
            defect_rate = 0.0
        if defect_rate > self.defect_threshold:
            action = Action.D
            if random.random() < 0.2:
                action = Action.C
            self.coop_streak = 0
            return action
        if self.punished_last_round:
            self.punished_last_round = False
            self.coop_streak = 1
            return Action.C
        threshold = self.n_players / 2
        if sum_coop > threshold:
            self.coop_streak += 1
            if self.coop_streak >= 3:
                self.coop_streak = 0
                return Action.D
            else:
                return Action.C
        else:
            self.punished_last_round = True
            self.coop_streak = 0
            return Action.D

class Strategy_EXPLOITATIVE_29(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma:
    Cooperates initially, then continues if cooperation was effective (previous round sum_c > 0), 
    defects otherwise, with adaptive mechanism to revert to cooperation after a patience level.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.consecutive_defections = 0
        self.patience = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponents_prev_actions = history.opponent_actions[-1]
        total_cooperators = my_prev_action + opponents_prev_actions.sum()
        if total_cooperators > 0:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections >= self.patience:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            return Action.D

class Strategy_EXPLOITATIVE_30(BaseStrategy):
    """
    Adaptive Cooperation with Last Round Defection (ACL)
    Strategy that adapts cooperation based on the proportion of previous rounds meeting a cooperation threshold.
    Always defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            count = 0
            for t in range(state.round_number):
                opp_actions = history.opponent_actions[t]
                my_action = history.my_actions[t]
                num_coop = np.sum(opp_actions) + (1 if my_action else 0)
                if num_coop >= self.m:
                    count += 1
            proportion = count / state.round_number
            return Action.C if proportion >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_31(BaseStrategy):
    """
    A strategy that cooperates in the first round, then defects if enough players 
    cooperated previously based on a threshold derived from the game's parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players - 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[state.round_number - 1]
        prev_opp_actions = history.opponent_actions[state.round_number - 1, :]
        prev_coop_me = prev_my_action
        prev_coops_opp = np.sum(prev_opp_actions)
        total_prev_coops = prev_coops_opp + prev_coop_me
        if total_prev_coops >= self.m + 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_32(BaseStrategy):
    """
    A strategy that adapts cooperation based on past rounds' average cooperators.
    Cooperates initially, defects if average cooperation meets or exceeds k, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        total_coop = 0.0
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            my_c = 1 if my_action else 0
            opponent_actions = history.opponent_actions[t]
            opponent_c = np.sum(opponent_actions)
            total_coop += my_c + opponent_c
        average_coop = total_coop / state.round_number
        if average_coop >= self.game_description.k:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_33(BaseStrategy):
    """
    Adaptive Cooperation Threshold (ACT) strategy for the N-Player Public Goods Game.
    Cooperates initially, then adapts based on the success rate of previous rounds meeting a cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = (n + k - 1) // k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        success_count = 0
        for t in range(len(history.my_actions)):
            me_coop = history.my_actions[t]
            opponents_coop = np.count_nonzero(history.opponent_actions[t])
            total_coop = me_coop + opponents_coop
            if total_coop >= self.m:
                success_count += 1
        total_rounds = len(history.my_actions)
        if total_rounds == 0:
            success_rate = 0.0
        else:
            success_rate = success_count / total_rounds
        return Action.C if success_rate > 0.5 else Action.D

class Strategy_EXPLOITATIVE_35(BaseStrategy):
    """
    A strategy that cooperates initially, but switches to defecting if insufficient cooperation or excessive exploitation occurs.
    Uses thresholds based on the number of players and the multiplication factor.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round]
        c_prev = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
        if c_prev < self.m:
            return Action.D
        n = self.game_description.n_players
        D_prev = n - c_prev
        threshold = (n - self.m) / 2
        if D_prev > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_36(BaseStrategy):
    """
    This strategy implements a conditional cooperation approach for the public goods game.
    It starts by cooperating to encourage others, then continues to cooperate if enough players
    cooperated in the previous round. It defects in the last round to maximize immediate gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponents_prev_actions = history.opponent_actions[previous_round]
        s = int(my_prev_action) + np.sum(opponents_prev_actions)
        if s >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_37(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the N-Player Public Goods Game.
    Cooperates initially to encourage cooperation, then uses an adaptive approach
    based on recent cooperation levels to decide whether to defect or cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.e = 2
        self.s = 3
        self.m = self.game_description.n_players // 2
        self.r = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round <= self.e:
            return Action.C
        else:
            start = max(0, current_round - self.s)
            total_coops = 0.0
            for i in range(start, current_round):
                my_action = history.my_actions[i]
                opp_actions = history.opponent_actions[i]
                my_c = 1 if my_action else 0
                opp_c = opp_actions.sum()
                total_coops += my_c + opp_c
            if current_round - start == 0:
                avg_coops = 0.0
            else:
                avg_coops = total_coops / (current_round - start)
            if avg_coops >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_38(BaseStrategy):
    """
    Conditional cooperation strategy where each player cooperates only when their contribution is pivotal.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_last = int(history.my_actions[-1])
        opponent_actions = history.opponent_actions[-1, :]
        sum_others = np.sum(opponent_actions)
        x_prev = my_last + sum_others
        if x_prev >= self.m:
            if x_prev - 1 < self.m:
                return Action.C
            else:
                return Action.D
        elif x_prev + 1 >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_40(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACWP) strategy.
    Cooperates initially and adapts based on past cooperation levels.
    Punishes by defecting if insufficient cooperation is observed.
    Cooperates in the final round based on overall cooperation trend.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.k)
        self.history_state = None

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            total_coops = []
            for t in range(current_round):
                my_action = history.my_actions[t]
                opponent_actions = history.opponent_actions[t]
                total = int(my_action) + np.sum(opponent_actions)
                total_coops.append(total)
            avg_coop = sum(total_coops) / len(total_coops)
            if avg_coop >= self.m:
                return Action.C
            else:
                return Action.D
        else:
            previous_round = current_round - 1
            my_prev_action = history.my_actions[previous_round]
            opponent_prev_actions = history.opponent_actions[previous_round]
            prev_coop = int(my_prev_action) + np.sum(opponent_prev_actions)
            if prev_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_41(BaseStrategy):
    """
    A strategic approach based on tracking others' cooperation rates and defecting when expected cooperators meet a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_rounds = history.opponent_actions[:state.round_number]
            coop_sum = np.sum(prev_rounds, axis=0)
            round_count = state.round_number
            cooperation_rates = coop_sum / round_count
            e_defect = np.sum(cooperation_rates)
            return Action.D if e_defect >= self.m else Action.C

class Strategy_EXPLOITATIVE_43(BaseStrategy):
    """
    Adaptive threshold-based cooperation strategy for N-player public goods game.
    Cooperates initially and adapts based on historical cooperation rates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        met_threshold = 0
        for s in range(state.round_number):
            my_coop = history.my_actions[s]
            opp_coop = np.sum(history.opponent_actions[s])
            total_coop = my_coop + opp_coop
            if total_coop > self.k:
                met_threshold += 1
        proportion = met_threshold / state.round_number
        if proportion > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_44(BaseStrategy):
    """Adaptive strategy based on cooperation threshold in previous round."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        opponents_coop = sum(opponents_prev_actions)
        total_coop = opponents_coop + (1 if my_prev_action else 0)
        if total_coop >= self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_45(BaseStrategy):
    """
    An exploitative strategy for the N-Player Public Goods Game. 
    The strategy initially cooperates and then defects if insufficient cooperation is observed, 
    persisting in defection once triggered.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)
        self.triggered_defect = False

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.triggered_defect:
            return Action.D
        prev_round = state.round_number - 1
        my_action = history.my_actions[prev_round]
        opponents_actions = history.opponent_actions[prev_round]
        total_coop = np.sum(opponents_actions) + (1 if my_action else 0)
        if total_coop < self.m:
            self.triggered_defect = True
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_46(BaseStrategy):
    """
    Adaptive Cooperation Based on Recent Success (ACRS) Strategy.
    Cooperates in the first round and continues if the previous round met the cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponent_actions = history.opponent_actions[prev_round]
        prev_coop = sum(prev_opponent_actions) + (1 if prev_my_action else 0)
        if prev_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_47(BaseStrategy):
    """
    Responsive Cooperation strategy. Cooperates in the first round, then cooperates in subsequent rounds if the number 
    of cooperators in the previous round meets a threshold based on the game's parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n_players = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n_players / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        total_coop = my_prev_action + np.sum(opponent_prev_actions)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_48(BaseStrategy):
    """
    Implements a strategy for the N-Player Public Goods Game based on historical cooperation levels.
    The strategy uses a threshold (m) to decide whether to Cooperate or Defect in each round.
    m is calculated as the ceiling of the number of players divided by the multiplication factor k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        my_contribution = 1 if my_prev_action else 0
        opp_contributions = np.sum(opp_prev_actions)
        prev_coop = my_contribution + opp_contributions
        if prev_coop >= self.m:
            if prev_coop - 1 >= self.m:
                return Action.D
            else:
                return Action.C
        else:
            needed = self.m - prev_coop
            if needed <= 1:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_49(BaseStrategy):
    """
    Cooperative Restart with Patience Strategy.

    This strategy starts by cooperating, then continues to cooperate if a sufficient number
    of players cooperated in the previous round (at least half of the players). If not,
    it defects but will attempt to restart cooperation after 3 consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opp_prev = history.opponent_actions[prev_round, :]
        num_coop = int(my_prev) + opp_prev.sum()
        if num_coop >= self.m:
            self.consecutive_defects = 0
            return Action.C
        elif self.consecutive_defects < 3:
            self.consecutive_defects += 1
            return Action.D
        else:
            self.consecutive_defects = 0
            return Action.C

class Strategy_EXPLOITATIVE_50(BaseStrategy):
    """
    A strategy that cooperates in the first round, then uses cooperation rates of other players
    to decide whether to cooperate or defect based on a calculated threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = (self.n_players - 1) // 2 + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        opponent_actions = history.opponent_actions
        expected_cooperators = 0.0
        for j in range(self.n_players - 1):
            actions = opponent_actions[:t, j].astype(float)
            cooperation_count = np.sum(actions)
            rate = cooperation_count / t
            expected_cooperators += rate
        if expected_cooperators >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_51(BaseStrategy):
    """
    A strategy for the N-player public goods game that adapts based on previous cooperation levels.
    Cooperates initially and continues if enough others cooperated before.
    Uses a threshold based on the game's parameters to decide cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        sum_opponents_prev = np.sum(opponent_actions_prev)
        sum_prev = sum_opponents_prev + history.my_actions[prev_round]
        if sum_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_52(BaseStrategy):
    """
    A heuristic-based strategy that adapts based on the success of previous rounds
    in achieving a sufficient number of Cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        success_count = 0
        total_rounds = state.round_number
        for t in range(total_rounds):
            my_action = history.my_actions[t]
            opponents_actions = history.opponent_actions[t]
            cooperators = np.sum(opponents_actions)
            if my_action:
                cooperators += 1
            if cooperators >= self.m:
                success_count += 1
        success_rate = success_count / total_rounds
        if success_rate > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_53(BaseStrategy):
    """
    An adaptive strategy that responds to recent cooperation levels by examining the number of cooperators in previous rounds.
    Cooperates if enough recent rounds meet a minimum threshold of cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.window_size = 3
        self.h = 2
        self.m = game_description.n_players // 2 + 1

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_prior = state.round_number
        window_start = max(n_prior - self.window_size, 0)
        cooperative_rounds = 0
        for r in range(window_start, n_prior):
            own_c = history.my_actions[r]
            opp_actions = history.opponent_actions[r, :]
            total_c = own_c + opp_actions.sum()
            if total_c >= self.m:
                cooperative_rounds += 1
        return Action.C if cooperative_rounds >= self.h else Action.D

class Strategy_EXPLOITATIVE_54(BaseStrategy):
    """
    A strategy that adapts cooperation based on recent success in meeting a dynamically calculated threshold.
    It considers game parameters and recent trends, especially near the endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.k * self.n_players / (self.n_players + 1))
        self.window_size = 3

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        m = self.m
        window_size = self.window_size
        total_rounds = self.n_rounds
        if history is None:
            return Action.D
        start_round = max(0, current_round - window_size)
        recent_rounds = range(start_round, current_round)
        success_count = 0
        for r in recent_rounds:
            if r >= len(history.my_actions):
                continue
            my_action = history.my_actions[r]
            opponent_actions = history.opponent_actions[r]
            my_contribution = 1 if my_action else 0
            opponent_coop = sum(opponent_actions)
            total_coop = my_contribution + opponent_coop
            if total_coop >= m:
                success_count += 1
        success_rate = success_count / window_size
        if success_rate > 0.5:
            action = Action.C
        else:
            action = Action.D
        if current_round >= max(0, total_rounds - window_size):
            recent_coop_counts = []
            for r in recent_rounds:
                if r >= len(history.my_actions):
                    continue
                my_action = history.my_actions[r]
                opponent_actions = history.opponent_actions[r]
                my_contribution = 1 if my_action else 0
                opponent_coop = sum(opponent_actions)
                total_coop = my_contribution + opponent_coop
                recent_coop_counts.append(total_coop)
            if len(recent_coop_counts) >= 2:
                last_coop = recent_coop_counts[-1]
                prev_coop = recent_coop_counts[-2]
                if last_coop >= prev_coop:
                    action = Action.C
                else:
                    action = Action.D
        return action

class Strategy_EXPLOITATIVE_55(BaseStrategy):
    """
    A strategy that balances individual payoff maximization while maintaining sufficient cooperation.
    Cooperates in the first round, then defects if previous round's cooperators exceed a threshold m = floor(k), 
    otherwise continues cooperating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponent_prev_actions = history.opponent_actions[-1]
        sum_coop = my_prev_action + opponent_prev_actions.sum()
        if sum_coop > self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_56(BaseStrategy):
    """
    Adaptive Threshold Cooperation strategy.
    Cooperates in the first round.
    In subsequent rounds, cooperates if the number of cooperators in the previous round meets a computed threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        m = game_description.n_players * game_description.k / (game_description.k + 1)
        self.m = math.ceil(m)
        if self.m > game_description.n_players:
            self.m = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponents_prev = history.opponent_actions[prev_round]
            count = int(my_prev) + int(opponents_prev.sum())
            return Action.C if count >= self.m else Action.D

class Strategy_EXPLOITATIVE_57(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma in Public Goods Game.
    
    This strategy starts by Cooperating in the first round. In subsequent rounds,
    it Cooperates if the number of Cooperators in the previous round meets or exceeds a threshold.
    The threshold is calculated as the ceiling of (n_players / k), ensuring the strategy adapts to maximize payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m_threshold = math.ceil(self.n_players / self.k)
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponents_prev_actions = history.opponent_actions[previous_round, :]
        total_coop_prev = my_prev_action + int(opponents_prev_actions.sum())
        if total_coop_prev >= self.m_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_60(BaseStrategy):
    """
    A strategy for the Public Goods Game that starts with cooperation, 
    continues if enough players cooperated previously, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = math.floor(self.n / self.k) + 1
        self.continue_c = True

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.r - 1:
            return Action.D
        else:
            if not self.continue_c:
                return Action.D
            my_prev_action = history.my_actions[state.round_number - 1]
            prev_opp_actions = history.opponent_actions[-1]
            s = 0
            if my_prev_action:
                s += 1
            s += prev_opp_actions.sum()
            if s >= self.m:
                return Action.C
            else:
                self.continue_c = False
                return Action.D

class Strategy_EXPLOITATIVE_61(BaseStrategy):
    """
    Adaptive strategy based on expected values calculated from past outcomes. 
    Cooperates initially and adapts based on the effectiveness of cooperation versus defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.coop_threshold_met_count = 0
        self.defect_threshold_met_count = 0
        self.total_coop_actions = 0
        self.total_defect_actions = 0
        self.processed_rounds = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        n_players = self.n_players
        k = self.k
        new_processed = self.processed_rounds
        for t in range(self.processed_rounds + 1, current_round):
            if t < len(history.my_actions):
                my_action = history.my_actions[t]
                opponent_actions = history.opponent_actions[t]
                if my_action:
                    sum_c = 1 + sum(opponent_actions)
                    pi_C = k / n_players * sum_c
                    sum_c_if_D = sum_c - 1
                    pi_D = 1 + k / n_players * sum_c_if_D
                    threshold_met = pi_C > pi_D
                    if threshold_met:
                        self.coop_threshold_met_count += 1
                    self.total_coop_actions += 1
                else:
                    sum_c = sum(opponent_actions)
                    pi_D = 1 + k / n_players * sum_c
                    sum_c_if_C = sum_c + 1
                    pi_C = k / n_players * sum_c_if_C
                    threshold_met = pi_D > pi_C
                    if threshold_met:
                        self.defect_threshold_met_count += 1
                    self.total_defect_actions += 1
                new_processed = t
        self.processed_rounds = new_processed
        p_coop_met = self.coop_threshold_met_count / self.total_coop_actions if self.total_coop_actions else 0.0
        p_defect_met = self.defect_threshold_met_count / self.total_defect_actions if self.total_defect_actions else 0.0
        E_coop = p_coop_met * k
        E_defect = k * p_defect_met + 1.0
        if E_coop > E_defect:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_62(BaseStrategy):
    """
    A strategy that adapts cooperation based on the historical behavior of other players.
    Cooperates in the first round and uses the sum of others' cooperation rates to decide in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        sum_estimates = 0.0
        opponent_actions = history.opponent_actions
        num_opponents = opponent_actions.shape[1]
        for j in range(num_opponents):
            their_actions = opponent_actions[:state.round_number - 1, j]
            if len(their_actions) == 0:
                rate = 0.5
            else:
                rate = np.mean(their_actions)
            sum_estimates += rate
        m = n_players
        if sum_estimates + 1 >= m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_63(BaseStrategy):
    """
    An adaptive strategy for the N-player Public Goods game that 
    balances cooperation and cautious exploitation. The strategy 
    begins by cooperating, then adapts based on the number of 
    cooperators in previous rounds, defecting if cooperation is 
    insufficient, but resetting to cooperation after two 
    consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions = history.opponent_actions[prev_round, :]
        opponent_coop_prev = np.sum(opponent_actions)
        my_prev_action = history.my_actions[prev_round]
        self_coop_prev = int(my_prev_action)
        total_prev_coop = opponent_coop_prev + self_coop_prev
        threshold_met = total_prev_coop >= self.m
        if threshold_met:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections >= 2:
                self.consecutive_defections = 0
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_64(BaseStrategy):
    """
    A strategy that cooperates in the first round and adjusts based on the number 
    of cooperators in the previous round. It uses a threshold of half the number 
    of players to decide whether to cooperate (if below threshold) or defect 
    (if at or above threshold).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponent_last_actions = history.opponent_actions[last_round, :]
        opponent_c = sum(opponent_last_actions)
        own_c = 1 if my_last_action else 0
        total_c_last = opponent_c + own_c
        if total_c_last < self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_65(BaseStrategy):
    """
    A strategy that starts with cooperation, assesses success rate of previous rounds,
    and decides actions based on this assessment to maximize payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        successful_rounds = 0
        for t in range(state.round_number):
            if history.my_actions[t]:
                my_contribution = 1
            else:
                my_contribution = 0
            opponent_contributions = np.sum(history.opponent_actions[t])
            sum_c = my_contribution + opponent_contributions
            if sum_c > self.n / 2:
                successful_rounds += 1
        s = successful_rounds / state.round_number
        if state.round_number < self.rounds - 1:
            if s > 0.5:
                return Action.C
            else:
                return Action.D
        elif s > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_66(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            t = state.round_number
            g = self.game_description
            start_round = max(0, t - 3)
            end_round = t - 1
            n_prev_rounds = end_round - start_round + 1
            required = n_prev_rounds // 2 + 1
            count = 0
            for s in range(start_round, end_round + 1):
                my_c = history.my_actions[s]
                opps_c = sum(history.opponent_actions[s, :])
                total_c = my_c + opps_c
                if total_c >= g.k:
                    count += 1
            if count >= required:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_67(BaseStrategy):
    """
    Adaptive Exploitation Strategy: Cooperates initially and switches based on majority cooperation in past rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = (game_description.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        S = 0
        for prev_round in range(t):
            my_contribution = history.my_actions[prev_round]
            opponent_contributions = np.sum(history.opponent_actions[prev_round, :])
            total = my_contribution + opponent_contributions
            if total >= self.m:
                S += 1
        threshold = (t - 1) / 2.0
        if S > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_68(BaseStrategy):
    """
    An adaptive strategy that starts with cooperation and adjusts based on past cooperation success.
    Cooperates again if at least half of previous rounds had at least `m` players cooperating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = 1

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        m = self.m
        successful_rounds = 0
        total_rounds = state.round_number
        for r in range(total_rounds):
            my_action = history.my_actions[r]
            opponent_actions = history.opponent_actions[r]
            total_coops = sum(opponent_actions) + (1 if my_action else 0)
            if total_coops >= m:
                successful_rounds += 1
        success_rate = successful_rounds / total_rounds
        if success_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_69(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Success.

    Cooperates initially and in rounds where the historical frequency of 
    successful rounds meets or exceeds a threshold of 50%.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            s = 0
            for r in range(state.round_number):
                my_coop = 1 if history.my_actions[r] else 0
                opponents_coop = history.opponent_actions[r].sum()
                total_coop = my_coop + opponents_coop
                if total_coop >= self.m:
                    s += 1
            frequency = s / state.round_number
            if frequency > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_70(BaseStrategy):
    """
    Adaptive strategy for N-Player Public Goods Game balancing initial cooperation, 
    adaptive decision-making based on others' past behavior, and strategic last-round play.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = self.n_players / self.k
        self.initial_coop_rounds = 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number < self.initial_coop_rounds:
            return Action.C
        if history is None:
            return Action.C
        sum_coops = 0
        for round in range(state.round_number):
            sum_coops += np.sum(history.opponent_actions[round, :])
        average_s = sum_coops / state.round_number
        if average_s >= self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_71(BaseStrategy):
    """
    A strategy that balances cooperation with strategic defection, particularly in the final round,
    to maximize individual payoffs while considering the game's structure and parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round]
            opponent_coop_count = sum(opponent_actions_prev)
            my_prev_action = history.my_actions[prev_round]
            total_coop = opponent_coop_count + my_prev_action
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_72(BaseStrategy):
    """
    Adaptive Exploitation Based on Historical Performance (AEBHP) strategy.
    Cooperates initially to gather information, then uses historical data to decide actions.
    Adapts strategy near the endgame based on overall historical performance.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.initial_coop_rounds = min(game_description.n_rounds, 3)
        self.rounds_to_analyze = min(game_description.n_rounds, 5)
        self.endgame_rounds = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number < self.initial_coop_rounds:
            return Action.C
        else:
            near_end = state.round_number >= self.game_description.n_rounds - self.endgame_rounds
            if near_end:
                my_actions = history.my_actions
                opp_actions = history.opponent_actions
                total_c = my_actions.astype(int) + np.sum(opp_actions, axis=1)
                k = self.game_description.k
                n = self.game_description.n_players
                payoff_c = k / n * total_c
                avg_payoff = payoff_c.mean()
                return Action.C if avg_payoff >= 1.0 else Action.D
            else:
                my_actions_past = history.my_actions[-self.rounds_to_analyze:]
                opp_actions_past = history.opponent_actions[-self.rounds_to_analyze:]
                k = self.game_description.k
                n = self.game_description.n_players
                t = my_actions_past.astype(int)
                opp_counts = np.sum(opp_actions_past, axis=1)
                total_c = t + opp_counts
                payoff_c = k / n * total_c
                avg_payoff = payoff_c.mean()
                return Action.C if avg_payoff >= 1.0 else Action.D

class Strategy_EXPLOITATIVE_73(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that balances cooperation and strategic defection.
    It starts with cooperation, adapts based on past cooperation rates, analyzes trends, and adjusts in the endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.cooperation_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.cooperation_history = []
            return Action.C
        round_num = state.round_number - 1
        opponents_actions_t = history.opponent_actions[round_num, :]
        my_last = history.my_actions[round_num]
        total_c = sum(opponents_actions_t) + (1 if my_last else 0)
        self.cooperation_history.append(total_c)
        current_round = state.round_number
        m = self.n_players // 2
        endgame_threshold = self.n_rounds - 3
        if current_round >= endgame_threshold:
            recent = self.cooperation_history[-3:]
            decreasing = True
            for i in range(len(recent) - 1):
                if recent[i] <= recent[i + 1]:
                    decreasing = False
                    break
            if decreasing:
                return Action.D
        if total_c >= m:
            return Action.C
        else:
            recent = self.cooperation_history[-3:]
            trend_decreasing = True
            for i in range(len(recent) - 1):
                if recent[i] <= recent[i + 1]:
                    trend_decreasing = False
                    break
            if trend_decreasing:
                return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_74(BaseStrategy):
    """
    This strategy always chooses to Defect in every round.
    It ignores the actions of other players and the game state,
    following the individually optimal rational choice.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_EXPLOITATIVE_75(BaseStrategy):
    """
    An adaptive strategy based on historical cooperation rates.
    First round: Cooperate.
    Subsequent rounds: Cooperate if the sum of others' expected cooperation rates
    is below a threshold (half the number of players), otherwise Defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_opponents = self.game_description.n_players - 1
        expected_cooperators = 0.0
        for opponent in range(n_opponents):
            actions = history.opponent_actions[:state.round_number, opponent]
            coop_count = np.sum(actions)
            if state.round_number > 0:
                rate = coop_count / state.round_number
                expected_cooperators += rate
        if expected_cooperators >= self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_76(BaseStrategy):
    """
    An adaptive strategy that starts by cooperating, punishes defection for a limited number of rounds, 
    and resets cooperation periodically. Defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.max_punish_rounds = 2
        self.failure_streak = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_my_action = history.my_actions[-1]
        prev_opponent_actions = history.opponent_actions[-1, :]
        coop_count = prev_my_action + sum(prev_opponent_actions)
        if coop_count >= self.m:
            self.failure_streak = 0
            return Action.C
        else:
            self.failure_streak += 1
            if self.failure_streak >= self.max_punish_rounds:
                self.failure_streak = 0
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_77(BaseStrategy):
    """
    Exploitative Cooperation Based on Historical Performance Strategy.
    Cooperates in the first round, then defects if at least m players cooperated in the previous round; 
    otherwise continues to cooperate. Parameter m is set to half the number of players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_number = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_number]
        opponent_prev_actions = history.opponent_actions[prev_round_number]
        total_coop = int(my_prev_action) + int(opponent_prev_actions.sum())
        if total_coop >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_78(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma:
    Cooperates in the first round. In subsequent rounds, cooperates if at least half of the players
    cooperated in the previous round; otherwise, defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponent_prev = history.opponent_actions[prev_round, :]
        sum_coop_prev = my_prev + np.sum(opponent_prev)
        if sum_coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_79(BaseStrategy):
    """
    Cooperate in the first round. In subsequent rounds, base the decision on the number of cooperators in the previous round.
    Cooperate again if at least half of the players (including self) cooperated; otherwise, defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round, :]
        sum_opponent_prev = np.sum(opponent_prev_actions)
        total_coop_prev = my_prev_action + sum_opponent_prev
        m = self.game_description.n_players // 2
        if total_coop_prev >= m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_80(BaseStrategy):
    """
    Enforces cooperation by checking if the number of cooperators in the previous round meets a threshold based on k.
    Cooperates if the total number of cooperators (including self) is at least the ceiling of k, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_coops = np.sum(history.opponent_actions[prev_round])
        self_coop = history.my_actions[prev_round]
        total_coops = opponent_coops + (1 if self_coop else 0)
        threshold = math.ceil(self.game_description.k)
        if total_coops >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_81(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that adapts based on the level of cooperation in previous rounds.
    Cooperates initially and continues based on a calculated threshold of necessary cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponent_prev = history.opponent_actions[prev_round]
        sum_prev = my_prev + opponent_prev.sum()
        if sum_prev < self.m:
            return Action.C
        elif sum_prev - 1 >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_82(BaseStrategy):
    """
    Adaptive Threshold Cooperation strategy for N-player public goods game.
    Implements initial exploration, exploitation based on cooperation thresholds, and endgame defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.round_number < 5:
            if history is None:
                if random.random() < 0.5:
                    return Action.C
                else:
                    return Action.D
            elif random.random() < 0.5:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opp_prev = history.opponent_actions[prev_round, :]
            total_coop = my_prev + np.sum(opp_prev)
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_83(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // self.game_description.k + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        total_coop = sum(opp_prev_actions) + (1 if my_prev_action else 0)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_84(BaseStrategy):
    """
    Adaptive Exploitation in Collective Risk Dilemma Strategy.
    
    This strategy begins by cooperating in the first round to encourage others to contribute.
    In subsequent rounds, it adapts by defecting when others' contributions meet a threshold,
    while monitoring trends in cooperation to adjust its behavior dynamically.
    In the final round, it defects to maximize its payoff if others have sufficiently contributed.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.coop_counts = []
        self.m = math.ceil((game_description.n_players - 1) / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            prev_round = state.round_number - 1
            count_prev_c = sum(history.opponent_actions[prev_round, :])
            if count_prev_c >= self.m:
                return Action.D
            else:
                return Action.C
        prev_round = state.round_number - 1
        count_prev_c = sum(history.opponent_actions[prev_round, :])
        count_prev_total = count_prev_c + (1 if history.my_actions[prev_round] else 0)
        self.coop_counts.append(count_prev_total)
        action = Action.D if count_prev_c >= self.m else Action.C
        if len(self.coop_counts) >= 2:
            trend = self.coop_counts[-1] - self.coop_counts[-2]
            if trend > 0:
                action = Action.D
            elif trend < 0:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_85(BaseStrategy):
    """
    Adaptive Cooperation with Exploitation strategy.

    This strategy initially cooperates for the first three rounds to foster cooperation.
    In intermediate rounds, it defects if the average cooperation is sufficiently high,
    balancing exploitation with maintaining public good contributions.
    In the final round, it defects only if it's safe to do so without undermining the collective benefit.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.floor(n / k) + 1

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        t = state.round_number
        r = self.game_description.n_rounds
        if t < 3:
            return Action.C
        if history is None:
            return Action.C
        total_coop = 0.0
        for round in range(t):
            my_c = history.my_actions[round]
            others_c = sum(history.opponent_actions[round, :])
            total_coop += my_c + others_c
        avg_coop = total_coop / t
        if t >= r - 2:
            if t == r - 1:
                if avg_coop >= self.m:
                    return Action.D
                else:
                    return Action.C
            elif avg_coop >= self.m + 1:
                return Action.D
            else:
                return Action.C
        elif avg_coop >= self.m + 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_86(BaseStrategy):
    """
    Adaptive strategy balancing cooperation based on historical success of collective action.
    Starts with cooperation, then uses historical performance and randomness to decide actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.epsilon = 0.1
        self.p = 0.5
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if random.random() < self.epsilon:
            return Action.C
        successful_rounds = 0
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            opponents_actions = history.opponent_actions[t]
            total_c = int(my_action) + int(opponents_actions.sum())
            if total_c >= self.m:
                successful_rounds += 1
        ratio = successful_rounds / state.round_number
        if ratio >= self.p:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_87(BaseStrategy):
    """
    An exploitative strategy for the N-player Public Goods Game that adapts based on historical cooperation.
    Cooperates initially, defects if previous cooperation meets a threshold, and always defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            prev_my_Coop = 1 if my_prev_action else 0
            prev_opponent_actions = history.opponent_actions[prev_round]
            sum_coop_prev = prev_my_Coop + np.sum(prev_opponent_actions)
            if sum_coop_prev >= self.game_description.k:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_88(BaseStrategy):
    """
    Adaptive Punish-and-Forgive strategy to balance cooperation and exploitation.
    Cooperates initially, punishes temporarily for insufficient cooperation, 
    then forgives to encourage future cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.success_counter = 0
        self.punishment_counter = 0
        self.max_punishment_rounds = 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round_num = state.round_number - 1
        my_last_action = history.my_actions[last_round_num]
        opponent_last_actions = history.opponent_actions[last_round_num, :]
        sum_c = 1 if my_last_action else 0
        sum_c += np.sum(opponent_last_actions)
        threshold_met = self.game_description.k / self.game_description.n_players * sum_c >= 1.0
        if threshold_met:
            self.success_counter += 1
            self.punishment_counter = 0
        else:
            self.success_counter = 0
            self.punishment_counter += 1
        if self.success_counter > 0:
            return Action.C
        elif self.punishment_counter <= self.max_punishment_rounds:
            return Action.D
        else:
            self.punishment_counter = 0
            return Action.C

class Strategy_EXPLOITATIVE_89(BaseStrategy):
    """
    A strategy that starts by Cooperating in the first round. For subsequent rounds, 
    it Cooperates if more than half of the past rounds met a threshold of minimum 
    cooperators needed for beneficial outcomes, otherwise Defects.

    The threshold is determined based on the game's parameters, calculated as the 
    ceiling of the number of players divided by the multiplication factor.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        count_threshold_met = 0
        for round in range(state.round_number):
            my_action = history.my_actions[round]
            opponent_coop = sum(history.opponent_actions[round, :])
            total_coop = my_action + opponent_coop
            if total_coop >= self.m:
                count_threshold_met += 1
        total_past_rounds = state.round_number
        if count_threshold_met > total_past_rounds / 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_91(BaseStrategy):
    """
    A strategy encouraging cooperation based on reciprocity and social norms.
    Cooperates if the level of cooperation in the previous round meets a threshold
    derived from the game's parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions_last_round = history.opponent_actions[-1, :]
        sum_coop = np.sum(opponent_actions_last_round)
        n = self.game_description.n_players
        k = self.game_description.k
        threshold = k / n * (n - 1)
        if sum_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_92(BaseStrategy):
    """
    Adaptive Cooperation in Collective Risk Dilemma strategy.
    Cooperates initially and adapts based on the history of cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.m is None:
            if history is not None and history.my_actions.size > 0:
                my_coop = int(history.my_actions[0])
                opponents_coop = int(history.opponent_actions[0].sum())
                self.m = my_coop + opponents_coop
        if state.round_number == self.game_description.n_rounds - 1:
            sum_coops = []
            for r in range(len(history.my_actions)):
                my = int(history.my_actions[r])
                opponents = int(history.opponent_actions[r].sum())
                sum_coops.append(my + opponents)
            avg_coop = np.mean(sum_coops)
            if avg_coop >= self.m - 1:
                return Action.C
            else:
                return Action.D
        else:
            met = 0
            total_rounds = len(history.my_actions)
            for r in range(total_rounds):
                my = int(history.my_actions[r])
                opponents = int(history.opponent_actions[r].sum())
                total = my + opponents
                if total >= self.m:
                    met += 1
            ratio = met / total_rounds
            if ratio > 0.5:
                return Action.C
            else:
                last_action = history.my_actions[-1]
                return Action.D if last_action else Action.C

class Strategy_EXPLOITATIVE_93(BaseStrategy):
    """
    Adaptive cooperation strategy based on the number of cooperators in the previous round.
    Cooperates initially and continues if at least half (rounded down) of the players cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            my_prev_action = history.my_actions[-1]
            opponent_prev_actions = history.opponent_actions[-1]
            total_coops = my_prev_action + np.sum(opponent_prev_actions)
            if total_coops >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_95(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Success (ACBHS)
    
    This strategy begins by cooperating and then adapts based on the historical success rate of cooperation.
    Success is defined as rounds where at least a threshold number of players cooperate.
    The strategy weights recent rounds more heavily when calculating the success rate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.r = game_description.n_rounds
        self.m = self.n_players // self.k + 1
        if self.m > self.n_players:
            self.m = self.n_players
        self.alpha = 0.9
        self.threshold = 0.5

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        success_sum = 0.0
        weight_sum = 0.0
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            opp_coop = np.sum(history.opponent_actions[t, :])
            num_coop = my_action + opp_coop
            s_t = 1 if num_coop >= self.m else 0
            distance = state.round_number - 1 - t
            weight = self.alpha ** distance
            success_sum += s_t * weight
            weight_sum += weight
        if weight_sum == 0:
            success_rate = 0.0
        else:
            success_rate = success_sum / weight_sum
        if success_rate > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_96(BaseStrategy):
    """
    Implements a strategy for the Collective Risk Dilemma, balancing cooperation and defection based on previous rounds' outcomes.
    Cooperates initially, continues if a contribution threshold is met, occasionally tests cooperation, and uses majority threshold in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.p = 0.2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        if current_round == self.n_rounds - 1:
            threshold_met_count = 0
            for round in range(current_round):
                my_action = history.my_actions[round]
                opponents = history.opponent_actions[round, :]
                s = my_action + np.sum(opponents)
                if s >= self.n_players / self.k:
                    threshold_met_count += 1
            total_prior_rounds = current_round
            if threshold_met_count >= total_prior_rounds / 2:
                return Action.C
            else:
                return Action.D
        else:
            previous_round = current_round - 1
            my_action = history.my_actions[previous_round]
            opponents = history.opponent_actions[previous_round, :]
            s = my_action + np.sum(opponents)
            if s >= self.n_players / self.k:
                return Action.C
            elif random.random() < self.p:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_97(BaseStrategy):
    """
    Adaptive Exploitation Based on Historical Cooperation strategy.

    Starts with cooperation in the first round, then estimates future cooperation
    rates of other players. Cooperates if the estimated number of cooperators is
    at least k, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        n_opp_players = history.opponent_actions.shape[1]
        sum_est = 0.0
        for opp_idx in range(n_opp_players):
            actions = history.opponent_actions[:current_round, opp_idx]
            c_count = np.sum(actions)
            avg_rate = c_count / current_round if current_round != 0 else 0.0
            sum_est += avg_rate
        if sum_est >= self.game_description.k:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_98(BaseStrategy):
    """
    Adaptive Cooperate-Punish (ACP) strategy for N-Player Public Goods Game.
    Cooperates initially and uses past rounds' outcomes to decide actions, punishing
    if cooperation is too low and attempting to re-establish cooperation otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.just_defected = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        my_coop = my_prev_action
        opponents_prev_actions = history.opponent_actions[prev_round]
        coop_count = sum(opponents_prev_actions) + (1 if my_coop else 0)
        if coop_count >= self.m:
            self.just_defected = False
            return Action.C
        elif coop_count == self.m - 1:
            self.just_defected = False
            return Action.C
        else:
            if not self.just_defected:
                action = Action.D
                self.just_defected = True
            else:
                action = Action.C
                self.just_defected = False
            return action

class Strategy_EXPLOITATIVE_99(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation with probabilistic defection.
    Cooperates initially and follows a threshold-based approach with probabilistic elements.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        count_prev_C = my_prev_action + np.sum(opponent_prev_actions)
        if count_prev_C >= self.threshold:
            return Action.C
        elif random.random() < 0.8:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_100(BaseStrategy):
    """
    Adaptive Cooperative Enforcement strategy.
    Cooperates initially, then enforces cooperation by punishing low participation.
    Adapts based on recent cooperation trends.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = math.ceil(self.n_players / 2)
        self.coop_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opp_actions = history.opponent_actions[prev_round]
        opp_coop = sum(opp_actions)
        my_prev_action = history.my_actions[prev_round]
        total_coop_prev = opp_coop + (1 if my_prev_action else 0)
        self.coop_history.append(total_coop_prev)
        window_size = 3
        if len(self.coop_history) > window_size:
            self.coop_history.pop(0)
        if total_coop_prev >= self.m:
            return Action.C
        avg_coop = sum(self.coop_history) / len(self.coop_history)
        if avg_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_101(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Success Strategy.

    This strategy encourages cooperation while adapting to others' behavior.
    It cooperates initially, continues if enough players cooperate, and defects otherwise.
    In the last round, it decides based on the majority of historical cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number + 1
        game_rounds = self.game_description.n_rounds
        if current_round < game_rounds:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opp_prev = history.opponent_actions[prev_round]
            cooperators_prev = my_prev + sum(opp_prev)
            if cooperators_prev >= self.m:
                return Action.C
            else:
                return Action.D
        else:
            count = 0
            for r in range(state.round_number):
                my_act = history.my_actions[r]
                opp_act = history.opponent_actions[r]
                cooperators = my_act + sum(opp_act)
                if cooperators >= self.m:
                    count += 1
            if count > state.round_number / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_102(BaseStrategy):
    """
    Strategy to cooperate in the first round and continue cooperating if at least m players cooperated in the previous round.
    The threshold m is calculated as the ceiling of (n_players / k) to ensure the public good's return is beneficial.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round, :]
        total_coop = opp_prev_actions.sum() + (1 if my_prev_action else 0)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_103(BaseStrategy):
    """
    Adaptive Cooperator with Punishment (ACP) strategy. Starts with cooperation, then continues to cooperate as long
    as a sufficient number of players (based on k) cooperated in the previous round. Defects if cooperation is too low.
    After defecting, it will resume cooperation if the subsequent round meets the threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        if history is None or prev_round < 0:
            return Action.C
        prev_my_action = history.my_actions[prev_round]
        prev_opp_actions = history.opponent_actions[prev_round]
        prev_coops = (1 if prev_my_action else 0) + np.sum(prev_opp_actions)
        if prev_coops >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_104(BaseStrategy):
    """
    Exploitative cooperation strategy based on historical impact.
    Cooperates initially, defects if previous cooperation wasn't necessary,
    and defects in the final 5% of rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_rounds = self.game_description.n_rounds
        last_5percent = int(0.95 * total_rounds)
        if state.round_number >= last_5percent:
            return Action.D
        my_prev_action = Action.C if history.my_actions[-1] else Action.D
        c_i = 1 if my_prev_action == Action.C else 0
        opponent_coop = np.sum(history.opponent_actions[-1, :])
        n_coop_prev = c_i + opponent_coop
        m = self.game_description.k
        if n_coop_prev - c_i >= m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_105(BaseStrategy):
    """
    This strategy starts by Cooperating in the first round. In subsequent rounds,
    it calculates the expected cooperation rate from other players and Cooperate if 
    the sum of these rates plus one meets or exceeds a threshold derived from the 
    game's multiplication factor (k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        opponent_actions = history.opponent_actions[:t, :] if history else np.zeros((0, self.n_players - 1), dtype=bool)
        coop_counts = np.sum(opponent_actions, axis=0)
        rates = coop_counts / t if t != 0 else 0.0
        expected_coop = np.sum(rates)
        if expected_coop + 1 >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_106(BaseStrategy):
    """
    An adaptive strategy that Cooperates if enough players Cooperated in the previous round.
    Implements a Cooperate-and-Punish mechanism with forgiveness to re-establish cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        sum_opponents = np.sum(history.opponent_actions[last_round, :])
        sum_self = history.my_actions[last_round]
        total_cooperators = sum_opponents + sum_self
        if total_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_107(BaseStrategy):
    """
    This strategy starts by cooperating in the first round to encourage others. 
    In subsequent rounds, it calculates the cooperation rates of other players and 
    defects if their expected cooperation meets a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m_threshold = int(game_description.n_players * 0.6)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        opp_actions = history.opponent_actions
        n_opponents = opp_actions.shape[1]
        sum_expected_coop = 0.0
        for p in range(n_opponents):
            counts = sum(opp_actions[:current_round, p])
            rate = counts / current_round
            sum_expected_coop += rate
        if sum_expected_coop >= self.m_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_108(BaseStrategy):
    """
    Exploitative strategy that balances individual gain with collective success.
    Cooperates initially and defects when sufficient cooperation is observed.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_coops = 0
        count = 0
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            opponent_actions = history.opponent_actions[t]
            my_coop = 1 if my_action else 0
            others_coop = sum(opponent_actions)
            total_coops += my_coop + others_coop
            count += 1
        avg_coops = total_coops / count if count > 0 else 0.0
        if avg_coops >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_109(BaseStrategy):
    """
    An exploitative strategy for the N-Player Public Goods Game. It encourages cooperation 
    initially, continues if cooperation meets a threshold, and adapts based on trends.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(math.ceil(game_description.n_players / game_description.k))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        prev_round = t - 1
        my_coop_prev = history.my_actions[prev_round]
        opp_coops_prev = sum(history.opponent_actions[prev_round])
        c_prev = my_coop_prev + opp_coops_prev
        if c_prev >= self.m:
            return Action.C
        if t == self.game_description.n_rounds - 1:
            total_prev = t
            count = 0
            for s in range(total_prev):
                my_coop = history.my_actions[s]
                opp_coop = sum(history.opponent_actions[s])
                if my_coop + opp_coop >= self.m:
                    count += 1
            if count / total_prev >= 0.5:
                return Action.C
            else:
                return Action.D
        elif t == 1:
            return Action.D
        else:
            prev_prev_round = prev_round - 1
            my_coop_prev_prev = history.my_actions[prev_prev_round]
            opp_coops_prev_prev = sum(history.opponent_actions[prev_prev_round])
            c_prev_prev = my_coop_prev_prev + opp_coops_prev_prev
            if c_prev > c_prev_prev:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_110(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma based on observed cooperation rates.
    Cooperates initially to gather data, then defects when enough others are expected to cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.initial_coop_rounds = 3
        self.threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number < self.initial_coop_rounds:
            return Action.C
        expected_coops = 0
        n_opp = self.game_description.n_players - 1
        if history is not None:
            opp_actions = history.opponent_actions
            for opp_idx in range(n_opp):
                count = np.sum(opp_actions[:, opp_idx])
                total_rounds = state.round_number
                coop_rate = count / total_rounds if total_rounds != 0 else 0
                if coop_rate >= self.threshold:
                    expected_coops += 1
        if expected_coops >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_111(BaseStrategy):
    """
    Strategy implements an adaptive approach balancing cooperation and exploitation.
    Cooperates initially, defects if enough others cooperate, and adapts in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        if history is None:
            return Action.C
        my_prev = history.my_actions[prev_round]
        opp_prev = history.opponent_actions[prev_round]
        sum_coop_prev = my_prev + np.sum(opp_prev)
        if sum_coop_prev >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_112(BaseStrategy):
    """
    Adaptive strategy balancing cooperation and self-interest based on recent outcomes.
    Cooperates initially, then adapts based on cooperation levels and payoff trends.
    Defects in the final round to maximize individual payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        count_me = 1 if my_prev_action else 0
        count_others = np.sum(opponents_prev_actions)
        c_t_minus_1 = count_me + count_others
        m = self.n // 2
        actions = history.my_actions[:prev_round + 1]
        payoffs = history.my_payoffs[:prev_round + 1]
        is_coop = actions == 1
        avg_C = np.mean(payoffs[is_coop]) if np.any(is_coop) else 0.0
        is_defect = ~is_coop
        avg_D = np.mean(payoffs[is_defect]) if np.any(is_defect) else 0.0
        if c_t_minus_1 >= m and avg_C > avg_D:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_113(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game based on historical cooperation levels.
    The AI starts by Cooperating and then Defects if the average cooperation exceeds a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = int(game_description.k)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        total_coop = 0.0
        num_rounds = state.round_number
        for r in range(num_rounds):
            my_coop = history.my_actions[r]
            coop = 1 if my_coop else 0
            coop += sum(history.opponent_actions[r])
            total_coop += coop
        avg_coop = total_coop / num_rounds
        if avg_coop > self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_114(BaseStrategy):
    """
    Conditional Cooperation Based on Past Performance Strategy.

    Cooperates in the first round, then in subsequent rounds cooperates if the number of cooperators
    in the previous round meets or exceeds a threshold (m), which is half the number of players (rounded down).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.D
        t_minus_1 = state.round_number - 1
        my_prev = history.my_actions[t_minus_1]
        opponent_actions_prev = history.opponent_actions[t_minus_1, :]
        total_coop = int(my_prev) + opponent_actions_prev.sum()
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_115(BaseStrategy):
    """
    Exploitative Threshold Cooperative (ETC) strategy for the N-Player Public Goods Game.
    
    This strategy starts by Cooperating in the first round. In subsequent rounds, it Cooperates if the number of
    previous Cooperators meets a dynamically calculated threshold based on game parameters. It Defects in the final
    round to maximize payoff without future repercussions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            n_players = self.game_description.n_players
            k = self.game_description.k
            m = math.ceil(n_players / k)
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opp_prev = history.opponent_actions[prev_round]
            total_c = int(my_prev) + sum(opp_prev)
            if total_c >= m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_116(BaseStrategy):
    """
    Forgiving Threshold-based Cooperation strategy to address the Collective Risk Dilemma.
    Cooperates initially and adapts based on previous cooperation levels, with a mechanism
    to punish defectors by defecting for up to two consecutive rounds before cooperating again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            others_prev_actions = history.opponent_actions[prev_round, :]
            my_contribution = 1 if my_prev_action else 0
            others_contribution = np.sum(others_prev_actions)
            total_prev = my_contribution + others_contribution
            if total_prev >= self.m:
                self.consecutive_defects = 0
                return Action.C
            elif self.consecutive_defects < 2:
                self.consecutive_defects += 1
                return Action.D
            else:
                self.consecutive_defects = 0
                return Action.C

class Strategy_EXPLOITATIVE_117(BaseStrategy):
    """A strategy that cooperates if fewer than half of the players cooperated in the previous round, otherwise defects."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_action = history.my_actions[prev_round]
            opponents_actions = history.opponent_actions[prev_round, :]
            s_prev = my_action + sum(opponents_actions)
            if s_prev >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_118(BaseStrategy):
    """
    Adaptive Threshold Cooperator strategy: cooperates initially, adapts based on collective performance.
    Cooperates if past success ratio is >=50%, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        total_rounds = state.round_number
        if total_rounds == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            success_count = 0
            for prev_round in range(state.round_number):
                my_action = history.my_actions[prev_round]
                opponent_actions = history.opponent_actions[prev_round]
                num_cooperators = my_action + sum(opponent_actions)
                if num_cooperators >= self.m:
                    success_count += 1
            success_ratio = success_count / state.round_number if state.round_number > 0 else 0.0
        else:
            success_count = 0
            for prev_round in range(state.round_number):
                my_action = history.my_actions[prev_round]
                opponent_actions = history.opponent_actions[prev_round]
                num_cooperators = my_action + sum(opponent_actions)
                if num_cooperators >= self.m:
                    success_count += 1
            success_ratio = success_count / state.round_number
        if success_ratio >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_119(BaseStrategy):
    """
    Adaptive Strategy for N-Player Public Goods Game.
    
    This strategy balances cooperation and defection by:
    - Cooperating in the first round to encourage others.
    - Cooperating in subsequent rounds if previous cooperation was below a threshold (m).
    - Defecting in the last round to maximize personal gain.
    The threshold m is calculated based on the game's parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            if history is None:
                return Action.C
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round]
            prev_coop = 1 if my_prev_action else 0
            prev_coop += np.sum(opponents_prev_actions)
            if prev_coop >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_120(BaseStrategy):
    """
    An exploitative strategy for the N-Player Public Goods Game that balances cooperation and defection based on past success rates.
    Cooperates initially and adaptively adjusts based on historical cooperation success.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = max(1, min(int(game_description.k), game_description.n_players - 1))
        self.recent_window = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_rounds = state.round_number
        success_count = 0
        recent_success_count = 0
        l = min(self.recent_window, prev_rounds)
        start = max(0, prev_rounds - l)
        for t in range(prev_rounds):
            my_action = history.my_actions[t]
            opponents_actions = history.opponent_actions[t]
            sum_coop = my_action + np.sum(opponents_actions)
            if sum_coop >= self.m:
                success_count += 1
                if t >= start:
                    recent_success_count += 1
        total_rounds = prev_rounds
        success_rate = success_count / total_rounds if total_rounds > 0 else 0.0
        recent_rate = recent_success_count / l if l > 0 else 0.0
        if success_rate > 0.5 or recent_rate > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_121(BaseStrategy):
    """
    An adaptive cooperation strategy that starts by cooperating and then 
    switches to defecting based on the recent performance of the group.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.s = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        t_max = len(my_actions)
        met_list = []
        for t in range(t_max):
            my_c = my_actions[t]
            opp_c = opponent_actions[t]
            sum_c = my_c + np.count_nonzero(opp_c)
            met = sum_c >= self.m
            met_list.append(met)
        window_size = min(self.s, len(met_list))
        recent_met = sum(met_list[-window_size:]) if len(met_list) >= window_size else sum(met_list)
        threshold = 0.7 * self.s
        if recent_met >= threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_122(BaseStrategy):
    """
    A strategy that starts by Cooperating and switches to Defecting if more than 70% of past rounds met a cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        self.T = math.ceil(0.7 * n)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        count = 0
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            opponent_actions = history.opponent_actions[t]
            s = int(my_action) + np.sum(opponent_actions)
            if s >= self.T:
                count += 1
        fraction = count / state.round_number
        if fraction > 0.7:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_123(BaseStrategy):
    """
    Adaptive Cooperator with Restart Mechanism: 
    Encourages cooperation while being robust against exploitation by using 
    thresholds and restart mechanisms.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = max(1, int(round(game_description.n_players / game_description.k)))
        self.consec_defect = 0
        self.restart_threshold = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_rounds = self.game_description.n_rounds
        if state.round_number >= total_rounds - 3:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        coop_count_opponents = np.sum(opponent_prev_actions)
        my_coop = 1 if my_prev_action else 0
        total_coop = coop_count_opponents + my_coop
        if total_coop >= self.m:
            self.consec_defect = 0
            return Action.C
        else:
            self.consec_defect += 1
            if self.consec_defect >= self.restart_threshold:
                self.consec_defect = 0
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_124(BaseStrategy):
    """
    Adaptive Exploitation Based on Historical Cooperation Strategy.
    Cooperates in the first round, then defects if enough players cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        k = self.game_description.k
        m = math.ceil(n_players / k)
        prev_round = state.round_number - 1
        opponents_coop = sum(history.opponent_actions[prev_round, :])
        my_coop = history.my_actions[prev_round]
        total_coop = opponents_coop + my_coop
        if total_coop >= m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_125(BaseStrategy):
    """
    An adaptive strategy for the N-player public goods game that balances cooperation 
    with strategic defection to optimize individual payoffs while considering collective outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.m = min(self.m, self.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds - 1:
            return Action.D
        prev_round = current_round - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round, :]
        total_prev_coop = my_prev_action + opp_prev_actions.sum()
        if total_prev_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_126(BaseStrategy):
    """
    A strategy that begins by Cooperating and then uses a threshold-based approach 
    to determine subsequent actions. The threshold is derived from the game's 
    multiplication factor k. If the number of Cooperators in the previous round 
    meets or exceeds this threshold, the player Cooperates again; otherwise, 
    they Defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = min(math.floor(game_description.k), game_description.n_players - 1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        total = 0
        if my_prev_action:
            total += 1
        total += sum(opponents_prev_actions)
        if total >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_127(BaseStrategy):
    """
    Implements the Adaptive Cooperation Based on Past Success (ACPS) strategy.
    Cooperates initially, then adapts based on whether previous rounds met a cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.previous_action = None
        self.last_outcome_met = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            current_action = Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            sum_c = my_prev_action + np.sum(opponents_prev_actions)
            last_outcome_met = sum_c >= self.m
            if last_outcome_met:
                current_action = self.previous_action
            else:
                current_action = Action.D if self.previous_action == Action.C else Action.C
        self.previous_action = current_action
        return current_action

class Strategy_EXPLOITATIVE_129(BaseStrategy):
    """
    A strategy that initially cooperates and dynamically adapts to defect when it's safe,
    ensuring the public good's sustainability while maximizing individual payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = (self.n_players - 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_round = state.round_number - 1
        last_my_action = history.my_actions[last_round]
        if last_my_action:
            others_coop = sum(history.opponent_actions[last_round, :])
            if others_coop >= self.m:
                return Action.D
            else:
                return Action.C
        else:
            others_coop = sum(history.opponent_actions[last_round, :])
            if others_coop >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_130(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy.
    Cooperates initially and continues if enough players cooperated last round;
    otherwise, toggles between Cooperate and Defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2
        self.last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            total_coop_prev = int(my_prev_action) + np.sum(opponent_actions_prev)
            if total_coop_prev >= self.m:
                action = Action.C
            else:
                action = Action.C if self.last_action == Action.D else Action.D
            self.last_action = action
            return action

class Strategy_EXPLOITATIVE_131(BaseStrategy):
    """
    A strategy that cooperates initially and continues if enough players cooperated in the previous round.
    Uses a threshold based on the game's parameters to decide cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        m = game_description.n_players / game_description.k
        self.threshold_m = math.ceil(m)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponent_last_actions = history.opponent_actions[last_round]
        total_coop = sum(opponent_last_actions) + (1 if my_last_action else 0)
        if total_coop >= self.threshold_m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_132(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma in Public Goods Game.
    
    The strategy starts by Cooperating in the first round, adjusts based on the number 
    of Cooperators in the previous round for intermediate rounds, and Defects in the 
    final round to maximize immediate gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            if history is None:
                return Action.D
            previous_round = state.round_number - 1
            opponent_actions = history.opponent_actions[previous_round]
            opponents_C = sum(opponent_actions)
            my_C = 1 if history.my_actions[previous_round] else 0
            total_C = opponents_C + my_C
            if total_C >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_133(BaseStrategy):
    """
    An adaptive strategy that balances exploitation and cooperation based on historical behavior.
    Cooperates initially and then defects if sufficient others cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_opponent_actions = history.opponent_actions[-1, :]
        c_prev = np.count_nonzero(prev_opponent_actions) + (1 if prev_my_action else 0)
        if c_prev >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_134(BaseStrategy):
    """
    Strategy where players cooperate if the number of cooperators in the previous round meets a threshold.
    The threshold is half the number of players, rounded down.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            opponent_actions_last = history.opponent_actions[prev_round, :]
            opponent_coop = sum(opponent_actions_last)
            my_coop = 1 if history.my_actions[prev_round] else 0
            total_coop = opponent_coop + my_coop
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_135(BaseStrategy):
    """
    An adaptive strategy that balances exploration and exploitation in the N-Player Public Goods Game.
    Cooperates initially and in rounds where recent outcomes indicate successful cooperation, defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.success_history = []

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        t = round_number
        while len(self.success_history) < t:
            round_to_process = len(self.success_history)
            if round_to_process >= self.n_rounds:
                break
            my_action = history.my_actions[round_to_process]
            opponent_actions = history.opponent_actions[round_to_process]
            my_coop = 1 if my_action else 0
            opponent_coop = np.sum(opponent_actions)
            total_coop = my_coop + opponent_coop
            success = total_coop >= self.m
            self.success_history.append(success)
        recent_successes = self.success_history[-3:]
        sum_success = sum(recent_successes)
        num_analyzed = len(recent_successes)
        threshold = num_analyzed // 2 + 1
        if sum_success >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_136(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation 
    with responsiveness. It starts by cooperating, adapts based on the number 
    of previous cooperators, and considers the likelihood of others cooperating 
    in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        prev_round = state.round_number - 1
        if state.round_number == self.game_description.n_rounds - 1:
            others_prev = sum(history.opponent_actions[prev_round, :])
            if others_prev >= self.m:
                return Action.D
            else:
                return Action.C
        else:
            my_prev_action = history.my_actions[prev_round]
            others_prev = sum(history.opponent_actions[prev_round, :])
            total_prev = my_prev_action + others_prev
            if total_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_137(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that seeks to maximize payoff by 
    cooperating early, defecting when enough players cooperate, and defecting in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        if history is None or prev_round >= len(history.my_actions):
            return Action.C
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        count = int(my_prev_action) + sum(opponents_prev_actions)
        if count >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_138(BaseStrategy):
    """
    Cooperate in the first round, then defect if the number of cooperators in the previous round (excluding self) meets or exceeds a calculated threshold, otherwise cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        threshold = n / k
        m = math.ceil(threshold)
        self.m = min(m, n - 1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        others_c = sum(history.opponent_actions[prev_round, :])
        if others_c >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_139(BaseStrategy):
    """
    This strategy starts by Cooperating in the first round and then adapts based on the success of previous rounds.
    If Defecting in the previous round was successful (enough players Cooperated), it continues to Defect.
    Otherwise, it Cooperates to ensure a steady payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_action = history.my_actions[prev_round] if history is not None else None
        if prev_action is None:
            return Action.C
        if not prev_action:
            opponent_actions_prev = history.opponent_actions[prev_round, :] if history is not None else np.array([], dtype=bool)
            sum_opponent_C = np.sum(opponent_actions_prev)
            m = self.game_description.n_players / self.game_description.k
            if sum_opponent_C >= m:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_140(BaseStrategy):
    """
    A strategy for the N-player public goods game that balances cooperation 
    and defection to maximize personal payoff while considering collective 
    contributions. The strategy involves initial cooperation, conditional 
    cooperation in middle rounds, and defection in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        prev_round = current_round - 1
        prev_action = history.my_actions[prev_round]
        if prev_action:
            opponents_prev = history.opponent_actions[prev_round, :]
            sum_others = np.sum(opponents_prev)
            threshold = self.n_players / self.k
            if sum_others >= threshold:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_141(BaseStrategy):
    """
    Implements a reactive strategy based on the previous round's cooperation payoff.
    Cooperates initially, then defects if the previous round's payoff would have been higher by defecting.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_payoff_prev = history.my_payoffs[t_prev]
        my_action_prev = history.my_actions[t_prev]
        opponent_actions_prev = history.opponent_actions[t_prev]
        my_contribution = 1 if my_action_prev else 0
        opponent_contributions = opponent_actions_prev.sum()
        s_prev = my_contribution + opponent_contributions
        k = self.game_description.k
        n = self.game_description.n_players
        pi_defect_prev = 1.0 + k / n * s_prev
        if pi_defect_prev > my_payoff_prev:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_142(BaseStrategy):
    """
    A strategy that starts by Cooperating, then Adaptively Cooperates based on the number of cooperators in the previous round, 
    and Defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_actions_prev = history.opponent_actions[prev_round]
            num_coop = my_prev_action + sum(opponent_actions_prev)
            m = self.n_players // 2
            if num_coop >= m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_143(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages cooperation by rewarding 
    sufficient cooperation in previous rounds and defecting otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            opponent_actions_last_round = history.opponent_actions[-1]
            opponent_coop = np.sum(opponent_actions_last_round)
            my_last_action = history.my_actions[-1]
            total_coop = opponent_coop + (1 if my_last_action else 0)
            if total_coop >= self.game_description.k:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_144(BaseStrategy):
    """
    A strategy that adapts cooperation based on historical success of collective efforts.
    Cooperates if the majority of past rounds met the required number of cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        successful_rounds = 0
        for round_number in range(state.round_number):
            my_action = history.my_actions[round_number]
            opponent_actions = history.opponent_actions[round_number]
            cooperators = (1 if my_action else 0) + np.sum(opponent_actions)
            if cooperators >= self.m:
                successful_rounds += 1
        success_ratio = successful_rounds / state.round_number
        if success_ratio >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_145(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma.

    Cooperates if at least m players Cooperated in the previous round, where m is calculated as ceil(n/k).
    Starts with Cooperation in the first round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            if history is None:
                return Action.C
            prev_round = state.round_number - 1
            if prev_round >= len(history.my_actions):
                return Action.C
            prev_my_action = history.my_actions[prev_round]
            prev_opponents_actions = history.opponent_actions[prev_round]
            c_prev = int(prev_my_action) + np.sum(prev_opponents_actions)
            if c_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_146(BaseStrategy):
    """
    A strategy that always defects, following the dominant strategy from the Prisoner's Dilemma.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_EXPLOITATIVE_148(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that starts with cooperation, 
    adapts based on past outcomes, and uses reciprocity to encourage cooperation while 
    punishing defection to maintain fairness.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // self.game_description.k + 1
        self.punishment_in_next_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishment_in_next_round:
            self.punishment_in_next_round = False
            return Action.C
        last_round = state.round_number - 1
        my_last_action = int(history.my_actions[last_round])
        opponent_last_actions = history.opponent_actions[last_round]
        opponent_last_action_sum = np.sum(opponent_last_actions)
        x = my_last_action + opponent_last_action_sum
        if x >= self.m:
            if x > self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        elif x == self.m - 1:
            return Action.C
        else:
            self.punishment_in_next_round = True
            return Action.D

class Strategy_EXPLOITATIVE_149(BaseStrategy):
    """
    A strategy that starts with cooperation and continues if enough players cooperated in the previous round.
    The threshold is based on m, which is the minimal number of players needed to sustain cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round]
            sum_opponents = sum(opponents_prev_actions)
            c_prev = sum_opponents + (1 if my_prev_action else 0)
            if c_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_150(BaseStrategy):
    """
    This strategy starts by cooperating in the first round. In subsequent rounds, it decides based on the number of other players who cooperated in the previous round. If this number plus one (including itself) meets or exceeds a threshold m (calculated as the ceiling of k), it cooperates; otherwise, it defects. In the final round, it always defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k) if game_description.k else 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        x = sum(history.opponent_actions[-1, :])
        if x + 1 >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_151(BaseStrategy):
    """
    An adaptive strategy for the N-player public goods game. It starts with cooperation, then 
    adapts based on the number of cooperators in previous rounds, with a recovery mechanism.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        c_count = int(my_prev_action) + sum(opponent_prev_actions)
        m = math.ceil(self.n / self.k)
        if c_count >= m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_152(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game. Cooperate in the first round, then defect if the number of cooperators in the previous round exceeds a threshold based on n and k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m_threshold = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponents_prev = sum(history.opponent_actions[prev_round, :])
        my_prev = history.my_actions[prev_round]
        C_prev = opponents_prev + my_prev
        if C_prev > self.m_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_153(BaseStrategy):
    """
    Forgiving Tit-for-Tat strategy for N-Player Public Goods Game.

    The strategy starts by cooperating, punishes when cooperation falls below a threshold,
    and forgives after a set number of defections to re-establish cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.n_players / game_description.k) + 1
        self.consecutive_defects = 0
        self.forgiveness_threshold = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        sum_opponents = sum(history.opponent_actions[-1])
        my_last_action = history.my_actions[-1]
        total_cooperators = sum_opponents + (1 if my_last_action else 0)
        if total_cooperators >= self.m:
            self.consecutive_defects = 0
            return Action.C
        else:
            self.consecutive_defects += 1
            if self.consecutive_defects >= self.forgiveness_threshold:
                self.consecutive_defects = 0
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_155(BaseStrategy):
    """
    Adaptive Exploitation in Collective Risk Dilemma.

    Cooperates initially, tracks success rate, punishes with defection, and adapts based on recent history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.in_punishment_phase = False
        self.punishment_remaining = 0
        self.success_threshold = 0.5
        self.punishment_duration = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.in_punishment_phase:
            action = Action.D
            if self.punishment_remaining > 0:
                self.punishment_remaining -= 1
            else:
                self.in_punishment_phase = False
            return action
        n_players = self.game_description.n_players
        k = self.game_description.k
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        m = math.ceil(n_players / k)
        if m < 1:
            m = 1
        count = 0
        for t in range(current_round):
            my_action = history.my_actions[t]
            others = history.opponent_actions[t, :]
            cooperators = my_action + np.sum(others)
            if cooperators >= m:
                count += 1
        success_rate = count / current_round if current_round > 0 else 0.0
        endgame = n_rounds - current_round <= 3
        if endgame:
            recent_count = 0
            for t in range(max(0, current_round - 2), current_round):
                my_action = history.my_actions[t]
                others = history.opponent_actions[t, :]
                cooperators = my_action + np.sum(others)
                if cooperators >= m:
                    recent_count += 1
            recent_success = recent_count / (current_round - max(0, current_round - 2)) if current_round - max(0, current_round - 2) > 0 else 0.0
            if recent_success >= self.success_threshold:
                action = Action.C
            else:
                action = Action.D
        elif success_rate >= self.success_threshold:
            action = Action.C
        else:
            self.in_punishment_phase = True
            self.punishment_remaining = self.punishment_duration
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_156(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and defection based on historical data.
    Cooperates initially to encourage others and then defects when it's safe, ensuring
    the collective threshold is maintained.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.current_round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.current_round = 0
            return Action.C
        self.current_round = state.round_number
        prev_t = state.round_number - 1
        my_prev = history.my_actions[prev_t]
        opponents_prev = history.opponent_actions[prev_t]
        prev_coop = my_prev + np.sum(opponents_prev)
        if state.round_number == self.n_rounds - 1:
            if prev_coop - 1 >= self.m:
                return Action.D
            else:
                return Action.C
        elif prev_coop >= self.m + 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_157(BaseStrategy):
    """
    An adaptive strategy based on recent cooperative behavior of other players.

    This strategy starts by cooperating in the first round. For subsequent rounds,
    it uses a sliding window of recent rounds to determine the average number of
    other cooperators. The decision to cooperate or defect is based on whether
    this average meets or exceeds a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.w = 5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        history_list = [sum(round) for round in history.opponent_actions]
        recent_history = history_list[-self.w:]
        avg_others = sum(recent_history) / len(recent_history)
        if avg_others >= self.m:
            return Action.D
        elif avg_others + 1 >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_160(BaseStrategy):
    """
    A strategy that balances cooperation with strategic defection based on historical cooperation rates.
    Cooperates in the first round, defects in the last, and decides based on the average cooperation in previous rounds otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        sum_c = 0
        for r in range(state.round_number):
            my_action = history.my_actions[r]
            opponents_round = history.opponent_actions[r]
            count = 0
            if my_action:
                count += 1
            count += sum(opponents_round)
            sum_c += count
        average_c = sum_c / state.round_number
        threshold = self.game_description.n_players / 2.0
        if average_c >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_161(BaseStrategy):
    """Adaptive Cooperation Based on Past Success strategy for N-Player Public Goods Game."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k_val = game_description.k
        self.m = math.ceil(self.n_players / self.k_val)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opp_actions = history.opponent_actions[prev_round, :]
        my_prev_action = history.my_actions[prev_round]
        sum_opponents = sum(opp_actions)
        c_prev = sum_opponents + (1 if my_prev_action else 0)
        if c_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_162(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Performance.
    
    The strategy starts by Cooperating in the first round. In subsequent rounds, 
    it Cooperates if the number of Cooperators in the previous round was at least n-1, 
    otherwise it Defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        n_coop = my_prev_action + sum(opponents_prev_actions)
        threshold = self.game_description.n_players - 1
        if n_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_163(BaseStrategy):
    """
    An adaptive strategy for N-Player Public Goods Game aiming to balance cooperation and self-interest.
    It starts with cooperation, adjusts based on others' behavior, and optimizes in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.coop_prob = 0.8
        self.coop_counts = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponent_prev = history.opponent_actions[prev_round]
        coop_prev = my_prev + np.sum(opponent_prev)
        self.coop_counts.append(coop_prev)
        if state.round_number == self.n_rounds - 1:
            sum_coop = sum(self.coop_counts)
            n_coop_rounds = len(self.coop_counts)
            avg_coop = sum_coop / n_coop_rounds if n_coop_rounds > 0 else 0.0
            threshold = self.m / self.n_players
            if avg_coop >= threshold:
                return Action.C
            else:
                return Action.D
        else:
            if coop_prev >= self.m:
                self.coop_prob = min(1.0, self.coop_prob + 0.2)
            else:
                self.coop_prob = max(0.2, self.coop_prob - 0.2)
            if random.random() < self.coop_prob:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_164(BaseStrategy):
    """
    This strategy adapts based on past cooperation levels, balancing cooperation and exploitation.
    It cooperates in the first round, defects in the last, and uses a threshold-based approach otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        m = math.ceil(self.game_description.n_players / self.game_description.k)
        prev_coop_counts = []
        for r in range(state.round_number):
            my_action = history.my_actions[r].item()
            opponents = history.opponent_actions[r, :]
            coop = my_action + np.sum(opponents)
            prev_coop_counts.append(int(coop))
        s = sum((1 for cnt in prev_coop_counts if cnt >= m))
        threshold = 0.5 * len(prev_coop_counts)
        if s >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_165(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Success strategy for the Public Goods Game.
    Cooperates initially and adapts based on the success of past rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.floor(self.n_players / self.k) + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            t = state.round_number
            success_count = 0
            for i in range(t):
                my_action = history.my_actions[i]
                opponent_actions = history.opponent_actions[i]
                opp_coop = np.sum(opponent_actions)
                total_coop = my_action + opp_coop
                if total_coop >= self.m:
                    success_count += 1
            if success_count > t / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_166(BaseStrategy):
    """
    A strategy that adaptively switches between cooperation and defection based on historical success.
    It starts by cooperating and then defects if the success ratio of meeting the cooperation threshold exceeds 0.5.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.count_success = 0
        self.threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        my_contribution = 1 if my_prev_action else 0
        others_contribution = np.sum(opponent_prev_actions)
        num_coop_prev = my_contribution + others_contribution
        if num_coop_prev >= self.m:
            self.count_success += 1
        total_rounds = state.round_number
        success_ratio = self.count_success / total_rounds if total_rounds != 0 else 0.0
        if success_ratio > self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_167(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        m = game_description.k / (game_description.k + 1)
        self.m = math.ceil(m)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            previous_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[previous_round, :]
            c_minus_me = int(np.sum(opponent_actions_prev))
            if c_minus_me >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_168(BaseStrategy):
    """
    This strategy begins by cooperating in the first round. In subsequent rounds, it defects if all players cooperated in the previous round; otherwise, it cooperates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        opponent_coop = sum(opponent_prev_actions)
        my_coop = 1 if my_prev_action else 0
        total_coop = opponent_coop + my_coop
        if total_coop >= self.game_description.n_players:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_170(BaseStrategy):
    """
    This strategy encourages cooperation by rewarding sustained cooperation and 
    punishing defection, with retries after a set number of defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.max_consecutive_defections = 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opp_prev_actions = history.opponent_actions[previous_round, :]
        sum_c = sum(opp_prev_actions) + (1 if my_prev_action else 0)
        if sum_c >= self.m:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections >= self.max_consecutive_defections:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            return Action.D

class Strategy_EXPLOITATIVE_171(BaseStrategy):
    """
    A strategy that cooperates if the number of previous cooperators is at least m, where m is determined by the game parameters.
    It encourages cooperation based on the collective past actions of all players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        sum_my = 1 if my_prev_action else 0
        opponent_prev_actions = history.opponent_actions[prev_round]
        sum_opponent = np.sum(opponent_prev_actions)
        sum_coop = sum_my + sum_opponent
        if sum_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_172(BaseStrategy):
    """
    Implements the Adaptive Reciprocity strategy. Cooperate in the first round,
    and in subsequent rounds cooperate if at least m players cooperated in the previous round,
    where m is the ceiling of the multiplication factor k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)
        self.m = min(self.m, game_description.n_players)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        opponent_actions = history.opponent_actions[previous_round, :]
        sum_opponent = np.sum(opponent_actions)
        self_action_prev = history.my_actions[previous_round]
        total_coop = sum_opponent + self_action_prev
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_173(BaseStrategy):
    """
    Adaptive Threshold Exploitation strategy for N-player public goods game.
    Cooperates initially, then adapts based on historical cooperation rates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = self.n / self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        c_sum = 0.0
        c_count = 0
        d_sum = 0.0
        d_count = 0
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            opponents_actions = history.opponent_actions[t]
            sum_coop = 1 if my_action else 0
            sum_coop += np.sum(opponents_actions)
            if my_action:
                c_sum += sum_coop
                c_count += 1
            else:
                d_sum += sum_coop
                d_count += 1
        c_rate = c_sum / c_count if c_count > 0 else 0.0
        d_rate = d_sum / d_count if d_count > 0 else 0.0
        if c_rate >= self.m:
            return Action.C
        elif d_rate >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_174(BaseStrategy):
    """
    An exploitative strategy for the N-player public goods game that encourages 
    cooperation while avoiding exploitation by adapting to others' actions.
    Cooperates initially and in subsequent rounds based on previous cooperation 
    levels, alternating with defection when cooperation is insufficient. Defects 
    in the last round if cooperation dropped in the penultimate round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2
        self.last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            my_prev_action = history.my_actions[-1]
            opponent_prev_actions = history.opponent_actions[-1, :]
            coop_prev = int(my_prev_action) + sum(opponent_prev_actions)
            if coop_prev < self.m:
                self.last_action = Action.D
                return Action.D
            else:
                self.last_action = Action.C
                return Action.C
        else:
            my_prev_action = history.my_actions[-1]
            opponent_prev_actions = history.opponent_actions[-1, :]
            coop_prev = int(my_prev_action) + sum(opponent_prev_actions)
            if coop_prev >= self.m:
                self.last_action = Action.C
                return Action.C
            else:
                if self.last_action == Action.C:
                    next_action = Action.D
                else:
                    next_action = Action.C
                self.last_action = next_action
                return next_action

class Strategy_EXPLOITATIVE_175(BaseStrategy):
    """
    A strategy that starts with cooperation, adapts based on the number of previous cooperators, 
    and defects in the final round. The threshold m is derived from the multiplication factor k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            previous_round = state.round_number - 1
            my_action = history.my_actions[previous_round]
            opponent_actions = history.opponent_actions[previous_round, :]
            cooperators = 0
            if my_action:
                cooperators += 1
            cooperators += sum(opponent_actions)
            if cooperators >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_176(BaseStrategy):
    """
    A strategy that starts by cooperating and adapts based on the number of cooperators.
    It uses a failure counter to determine when to punish defectors and encourages cooperation.
    In the last round, it decides based on recent cooperation history.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.failure_counter = 0
        self.punishing = False
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            sum_met = 0
            look_back = 3
            for i in range(max(0, state.round_number - look_back), state.round_number):
                my_action = history.my_actions[i]
                opp_actions = history.opponent_actions[i]
                sum_c = my_action + np.sum(opp_actions)
                if sum_c >= self.m:
                    sum_met += 1
            if sum_met >= 2:
                return Action.C
            else:
                return Action.D
        if self.punishing:
            if self.punishment_remaining > 0:
                self.punishment_remaining -= 1
                return Action.D
            else:
                self.punishing = False
                self.punishment_remaining = 0
                prev_round = state.round_number - 1
                my_prev = history.my_actions[prev_round]
                opp_prev = history.opponent_actions[prev_round]
                sum_c = my_prev + np.sum(opp_prev)
                if sum_c >= self.m:
                    self.failure_counter = 0
                    return Action.C
                else:
                    self.failure_counter += 1
                    if self.failure_counter >= 2:
                        self.punishing = True
                        self.punishment_remaining = 2
                        return Action.D
                    else:
                        return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opp_prev = history.opponent_actions[prev_round]
            sum_c = my_prev + np.sum(opp_prev)
            if sum_c >= self.m:
                self.failure_counter = 0
                return Action.C
            else:
                self.failure_counter += 1
                if self.failure_counter >= 2:
                    self.punishing = True
                    self.punishment_remaining = 2
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_177(BaseStrategy):
    """
    An exploitative strategy for the N-player public goods game.
    Cooperates initially, then defects if enough others cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        others_coop_last = np.sum(history.opponent_actions[prev_round, :])
        if others_coop_last >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_178(BaseStrategy):
    """
    A strategy that balances cooperation and defection to maximize personal payoff while maintaining sufficient cooperation.
    It cooperates initially, defects when safe, and reverts to cooperation if defection causes cooperation to drop below a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.last_defect_caused_drop = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        C_prev = my_prev_action + np.sum(opponents_prev_actions)
        if my_prev_action == Action.D:
            if C_prev < self.m:
                return Action.C
        if C_prev >= self.m:
            if C_prev - 1 >= self.m:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_179(BaseStrategy):
    """
    A strategy for the Collective Risk Dilemma in an N-Player Public Goods Game.
    Cooperates initially, punishes if cooperation drops below a threshold, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_action_prev = history.my_actions[prev_round]
            opponents_actions_prev = history.opponent_actions[prev_round, :]
            sum_coop = my_action_prev + np.sum(opponents_actions_prev)
            if sum_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_180(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages cooperation
    while allowing recovery from instances where cooperation drops below a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n * k / (k + 1))

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        sum_opponents = np.sum(history.opponent_actions[prev_round, :])
        prev_coop = sum_opponents + (1 if my_prev_action else 0)
        if prev_coop >= self.m:
            return Action.C
        elif not my_prev_action:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_181(BaseStrategy):
    """
    A strategy that adapts based on the number of cooperators in previous rounds. Cooperates initially, then dynamically adjusts to maximize personal payoff while maintaining group success.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.last_coop_count = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponents_prev = history.opponent_actions[prev_round]
        C_prev = (1 if my_prev else 0) + sum(opponents_prev)
        self.last_coop_count = C_prev
        if C_prev >= self.m:
            if C_prev - 1 >= self.m:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_183(BaseStrategy):
    """
    Adaptive Cooperation with Exploitation (ACE) strategy for N-player public goods game.
    Balances cooperation and exploitation by responding to recent cooperation trends.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        m = game_description.k / (game_description.k + 1) * game_description.n_players
        self.m = m
        self.window_size = 5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        window_size = self.window_size
        current_round = state.round_number
        start_round = max(0, current_round - window_size)
        end_round = current_round
        sum_coop = 0.0
        for r in range(start_round, end_round):
            my_action = history.my_actions[r]
            opponents = history.opponent_actions[r, :]
            sum_others = np.sum(opponents)
            total_coop = my_action + sum_others
            sum_coop += total_coop
        n_rounds = end_round - start_round
        if n_rounds == 0:
            average = 0.0
        else:
            average = sum_coop / n_rounds
        if average >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_184(BaseStrategy):
    """
    A strategy for the Public Goods Game that adapts based on the historical success of cooperation.
    Cooperates initially and continues if past success rate is at least 50%.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        success_count = 0
        for prev_round in range(current_round):
            my_action = history.my_actions[prev_round]
            opponents_acts = history.opponent_actions[prev_round, :]
            s = 1 if my_action else 0
            s += np.sum(opponents_acts)
            if s >= self.m:
                success_count += 1
        total_rounds = current_round
        success_rate = success_count / total_rounds if total_rounds > 0 else 0.0
        if success_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_185(BaseStrategy):
    """
    Cooperates in the first round, then continues Cooperating if at least m players Cooperated in the previous round,
    where m is the ceiling of (n_players / k). This strategy encourages cooperation if the collective contribution meets the threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponent_actions = history.opponent_actions[-1]
        coop_count = sum(opponent_actions) + my_prev_action
        if coop_count >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_186(BaseStrategy):
    """
    A strategy that starts by cooperating, then dynamically adjusts based on the number of cooperators in the previous round.
    Defects if the number of cooperators meets or exceeds a threshold (n/k); otherwise, continues to cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players / game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        their_prev_actions = history.opponent_actions[-1, :]
        total_cooperators = sum(their_prev_actions) + (1 if my_prev_action else 0)
        if total_cooperators >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_187(BaseStrategy):
    """
    A balanced strategy that initially cooperates, tests the impact of occasional defection, 
    and adjusts based on the success of those tests.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.test_successes = 0
        self.test_total = 0
        self.pending_test_rounds = []
        self.mostly_defect_mode = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            current_round = state.round_number
            for r in list(self.pending_test_rounds):
                if r < current_round:
                    sum_coop = np.sum(history.opponent_actions[r, :])
                    if sum_coop >= self.m:
                        self.test_successes += 1
                    self.test_total += 1
                    self.pending_test_rounds.remove(r)
        if self.test_total > 0:
            success_ratio = self.test_successes / self.test_total
            if success_ratio >= 0.8 and (not self.mostly_defect_mode):
                self.mostly_defect_mode = True
        if state.round_number < 3:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            if self.test_total == 0:
                return Action.C
            elif self.test_successes / self.test_total >= 0.8:
                return Action.D
            else:
                return Action.C
        elif (state.round_number - 3) % 2 == 0:
            self.pending_test_rounds.append(state.round_number)
            return Action.D
        elif self.mostly_defect_mode:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_188(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and exploitation.
    Cooperates in the first round, then defects or cooperates based on the success of the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m_threshold = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        sum_opponents_prev = np.sum(opponent_prev_actions)
        cooperators_prev = my_prev_action + sum_opponents_prev
        if cooperators_prev >= self.m_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_189(BaseStrategy):
    """
    A strategy that starts by cooperating, then defects if the number of other 
    cooperators in the previous round was at least half the number of players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.threshold = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        opponent_actions = history.opponent_actions[previous_round]
        cooperators = sum(opponent_actions)
        if cooperators >= self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_190(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness strategy.
    
    This strategy starts by cooperating in the first round. For subsequent rounds, it cooperates again if enough players cooperated in the previous round. If not, it defects. After a set number of consecutive defections, it forgives by cooperating again, testing if conditions have improved.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n_players // 2
        self.s = 2
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        my_coop_prev = 1 if my_prev_action else 0
        opponent_prev_actions = history.opponent_actions[previous_round]
        opponent_coop_prev = np.count_nonzero(opponent_prev_actions)
        total_coop_prev = my_coop_prev + opponent_coop_prev
        if total_coop_prev >= self.m:
            self.consecutive_defects = 0
            return Action.C
        else:
            self.consecutive_defects += 1
            if self.consecutive_defects >= self.s:
                self.consecutive_defects = 0
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_191(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on the number of cooperators,
    with a forgiveness mechanism to retry cooperation after two consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = (self.game_description.n_players + 1) // 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions_last = history.opponent_actions[-1]
        sum_opponent = sum(opponent_actions_last)
        my_last = history.my_actions[-1]
        sum_my = 1 if my_last else 0
        total_coops = sum_opponent + sum_my
        if total_coops >= self.m:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections < 2:
            self.consecutive_defections += 1
            return Action.D
        else:
            self.consecutive_defections = 0
            return Action.C

class Strategy_EXPLOITATIVE_192(BaseStrategy):
    """
    Adaptive Cooperation with Punishment Strategy.
    Cooperates in the first round, then cooperates if at least m players 
    (including self) cooperated in the previous round. m is calculated as 
    ceil(n_players / k), ensuring that enough players contribute to make 
    cooperation beneficial.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_actions = history.opponent_actions[previous_round, :]
        c_prev = int(my_prev_action) + np.sum(opponent_actions)
        if c_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_193(BaseStrategy):
    """
    This strategy begins by cooperating in the first round. In subsequent rounds, 
    it cooperates if at least half of the players (rounded down) cooperated in 
    the previous round; otherwise, it defects. This encourages group cooperation 
    while protecting against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m_threshold = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponents_prev = history.opponent_actions[-1]
        sum_coop = my_prev_action + np.sum(opponents_prev)
        if sum_coop >= self.m_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_194(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and defection.
    Cooperates in the first round, then defects if at least half of the players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        prev_opponent_actions = history.opponent_actions[prev_round, :]
        total_cooperators_prev = my_prev_action + sum(prev_opponent_actions)
        if total_cooperators_prev >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_195(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma in Public Goods Game.
    Cooperates initially and adapts based on weighted cooperation trends in past rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        is_last_round = state.round_number == self.game_description.n_rounds - 1
        prev_rounds = state.round_number
        sum_weights = prev_rounds * (prev_rounds + 1) // 2
        sum_coop = 0.0
        for t in range(prev_rounds):
            my = history.my_actions[t]
            others = history.opponent_actions[t]
            count_coop = my.astype(float).sum() + others.sum()
            sum_coop += count_coop * (prev_rounds - t)
        average_coop = sum_coop / sum_weights if sum_weights != 0 else 0.0
        if is_last_round:
            threshold = n_players * 0.5 * 1.2
        else:
            threshold = n_players * 0.5
        if average_coop > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_196(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)
        self.m = max(1, min(self.m, n))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        if current_round == n_rounds - 1:
            return Action.D
        prev_round = current_round - 1
        my_actions = history.my_actions
        my_prev_action = my_actions[prev_round]
        my_prev = 1 if my_prev_action else 0
        opponent_actions = history.opponent_actions[prev_round, :]
        opponents_coop = opponent_actions.sum()
        total_coop = my_prev + opponents_coop
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_197(BaseStrategy):
    """
    A strategy that starts with Cooperation, then continues if the previous round had enough Cooperators,
    defects otherwise, switching back after a set number of consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.recovery_limit = 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_action_prev = history.my_actions[prev_round]
            opp_actions_prev = history.opponent_actions[prev_round, :]
            total_coop_prev = my_action_prev + np.sum(opp_actions_prev)
            m = self.n_players // 2
            threshold_met = total_coop_prev >= m
            if threshold_met:
                self.consecutive_defections = 0
                return Action.C
            else:
                self.consecutive_defections += 1
                if self.consecutive_defections >= self.recovery_limit:
                    self.consecutive_defections = 0
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_198(BaseStrategy):
    """
    A Reactive Cooperator strategy for the N-Player Public Goods Game.

    This strategy starts by always cooperating in the first round. In subsequent rounds,
    it cooperates again if the number of cooperators in the previous round was at least
    half of the total number of players (rounded down). Otherwise, it defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            total_cooperators = my_prev_action + np.sum(opponents_prev_actions)
            threshold = self.game_description.n_players // 2
            if total_cooperators >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_199(BaseStrategy):
    """
    A strategy that always chooses to defect in the Public Goods Game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_EXPLOITATIVE_200(BaseStrategy):
    """
    A strategy for the N-Player Public Goods game that adapts based on the number of cooperators in previous rounds.
    Cooperates if the number of cooperators in the previous round is at least (m-1), where m=ceil(n/k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            previous_round = state.round_number - 1
            my_c = history.my_actions[previous_round]
            my_c_count = 1 if my_c else 0
            others_c = np.sum(history.opponent_actions[previous_round])
            c_prev = my_c_count + others_c
            if c_prev >= self.m - 1:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_201(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            count = 0
            for t in range(state.round_number):
                my_action = history.my_actions[t]
                opp_actions = history.opponent_actions[t]
                sum_coop = int(my_action) + int(np.sum(opp_actions))
                if sum_coop >= self.m:
                    count += 1
            p = count / state.round_number
            if p > 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_202(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)
        self.avg_met = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0 or round_number == 1:
            return Action.C
        else:
            counts = []
            start_round = max(0, round_number - 3)
            for t in range(start_round, round_number):
                if t >= len(history.my_actions):
                    continue
                my_action = history.my_actions[t]
                opponent_actions = history.opponent_actions[t] if t < len(history.opponent_actions) else np.array([], dtype=bool)
                total_c = int(my_action) + int(opponent_actions.sum())
                counts.append(total_c)
            avg = sum(counts) / len(counts) if counts else 0.0
            if len(self.avg_met) >= 2 and (not self.avg_met[-2]) and (not self.avg_met[-1]):
                action = Action.D
            else:
                action = Action.C if avg >= self.m else Action.D
            self.avg_met.append(avg >= self.m)
            return action

class Strategy_EXPLOITATIVE_203(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        k = self.game_description.k
        s_threshold = n / k
        lookback = min(3, len(history.my_actions))
        count = 0
        for t in range(len(history.my_actions) - lookback, len(history.my_actions)):
            my_action = history.my_actions[t]
            opponent_actions = history.opponent_actions[t]
            sum_opponents = np.sum(opponent_actions)
            s = sum_opponents + my_action
            if s > s_threshold:
                count += 1
        if count / lookback >= 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_204(BaseStrategy):
    """
    Adaptive Cooperation with Exploitation (ACE) strategy for N-Player Public Goods Game.
    
    This strategy starts by cooperating and then adapts based on the number of cooperators in the previous round.
    If the number of cooperators (including self) in the previous round meets or exceeds a threshold m, the player defects.
    Otherwise, the player continues to cooperate to maintain collective benefit.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_opponents_actions = history.opponent_actions[-1]
        prev_count = int(prev_my_action) + prev_opponents_actions.sum()
        if prev_count >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_205(BaseStrategy):
    """
    A strategy that balances cooperation with self-interest by adapting to the game's outcomes.
    It cooperates in the first round, defects in the last, and adapts based on previous outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_my_payoff = history.my_payoffs[prev_round]
        if prev_my_action:
            bonus = prev_my_payoff
        else:
            bonus = prev_my_payoff - 1.0
        if bonus >= 1.0:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_206(BaseStrategy):
    """
    A strategy that starts with cooperation, adapts based on previous round's cooperators,
    and forgives after one defection, encouraging sustained cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_my_action = history.my_actions[-1]
        if not last_my_action:
            return Action.C
        my_prev = history.my_actions[-1]
        opponent_prev = history.opponent_actions[-1, :]
        my_contribution = 1 if my_prev else 0
        opponent_contributions = np.sum(opponent_prev)
        total_cooperators = my_contribution + opponent_contributions
        if total_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_207(BaseStrategy):
    """
    A strategy for the Public Goods Game that adapts based on previous cooperation levels.
    Starts by cooperating, then continues if enough others cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions = history.opponent_actions[prev_round]
        sum_others_coop = np.sum(opponent_actions)
        my_prev_action = history.my_actions[prev_round]
        total_coop = sum_others_coop + (1 if my_prev_action else 0)
        n = self.game_description.n_players
        k = self.game_description.k
        threshold = n / k
        if total_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_208(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Performance strategy.
    Cooperates initially and in subsequent rounds if historical cooperation is sufficient.
    Switches to defecting in the final 10% of rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        cutoff = self.r * 0.9
        if state.round_number >= cutoff:
            return Action.D
        m = self.n // 2
        t = state.round_number
        count = 0
        for tau in range(t):
            my_action = history.my_actions[tau]
            sum_coop = 1 if my_action else 0
            sum_coop += history.opponent_actions[tau].sum()
            if sum_coop >= m:
                count += 1
        ratio = count / t
        if ratio >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_209(BaseStrategy):
    """
    A strategy that starts by Cooperating in the first round, then checks if the public good term was >=1 in the previous round. 
    If so, Cooperate again; otherwise, Defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        pass

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            prev_payoff = history.my_payoffs[prev_round]
            prev_action = history.my_actions[prev_round]
            if prev_action:
                public = prev_payoff
            else:
                public = prev_payoff - 1
            if public >= 1.0:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_210(BaseStrategy):
    """
    Implements the Exploitative Cooperation with Punishment (ECP) strategy.
    Cooperates initially, defects if enough players cooperated previously, 
    and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_last_action = history.my_actions[prev_round]
        opponent_coops = sum(history.opponent_actions[prev_round, :])
        total_coops = my_last_action + opponent_coops
        m = self.game_description.n_players // 2
        if total_coops >= m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_211(BaseStrategy):
    """
    A strategy that adapts based on the outcomes of previous rounds to balance cooperation and defection.
    Cooperates in the first round, defects in the last round, and adapts based on whether a cooperation threshold
    was met in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        rd = state.round_number
        n_r = self.game_description.n_rounds
        if rd == 0:
            return Action.C
        if rd == n_r - 1:
            return Action.D
        prev_rd = rd - 1
        my_prev_act = history.my_actions[prev_rd]
        opponent_prev_acts = history.opponent_actions[prev_rd, :]
        sum_opponent = np.sum(opponent_prev_acts)
        total_C_prev = my_prev_act + sum_opponent
        if total_C_prev >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_212(BaseStrategy):
    """
    A strategy that begins by cooperating and adapts based on a moving average of past cooperation.
    Cooperates if the average number of past cooperators meets or exceeds the multiplication factor k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperator_counts = []
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            opponent_actions = history.opponent_actions[t, :]
            coops_t = int(my_action) + int(opponent_actions.sum())
            cooperator_counts.append(coops_t)
        window_size = min(5, len(cooperator_counts))
        relevant_counts = cooperator_counts[-window_size:]
        average = sum(relevant_counts) / window_size if relevant_counts else 0
        if average >= self.k:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_213(BaseStrategy):
    """
    Exploitative Cooperation Strategy based on past performance.
    Cooperates initially, then defects if previous cooperation met a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opp_actions = history.opponent_actions[prev_round, :]
        opp_c_prev = np.sum(opp_actions)
        my_c_prev = history.my_actions[prev_round]
        total_c_prev = opp_c_prev + my_c_prev
        if total_c_prev >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_214(BaseStrategy):
    """
    Adaptive Exploitation with Positive Feedback Strategy for Public Goods Game.
    Cooperates initially, punishes non-cooperation, and cooperates in the end.
    Inherits from BaseStrategy and implements the adaptive exploitation logic.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_remaining = 0
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.C
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        if state.round_number < 3:
            return Action.C
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        history_length = len(my_actions)
        max_considered = min(5, history_length)
        start = max(0, history_length - max_considered)
        total_coop = 0
        for r in range(start, history_length):
            my_coop = my_actions[r]
            opp_coop = sum(opponent_actions[r])
            total_coop += my_coop + opp_coop
        total_possible = max_considered * self.n_players
        cooperation_rate = total_coop / total_possible if total_possible != 0 else 1.0
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            self.punishment_remaining = 2
            return Action.D

class Strategy_EXPLOITATIVE_215(BaseStrategy):
    """
    Adaptive Exploitation Based on Historical Effectiveness.
    Cooperate initially. For subsequent rounds, defects if the majority of past defections met the cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        k = self.game_description.k
        m = math.ceil(n / k)
        total_defections = 0
        successful_defections = 0
        for t in range(state.round_number):
            if not history.my_actions[t]:
                total_defections += 1
                sum_coop_t = np.sum(history.opponent_actions[t])
                if sum_coop_t >= m:
                    successful_defections += 1
        if total_defections == 0:
            return Action.C
        else:
            success_rate = successful_defections / total_defections
            if success_rate > 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_217(BaseStrategy):
    """
    An exploitative strategy for the collective risk dilemma in public goods games.
    It encourages cooperation by punishing insufficient contributions adaptively.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_history = []
        self.punishment_remaining = 0
        self.miss_count = 0
        self.tolerance = 3

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_number = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_number]
        opponents_prev_actions = history.opponent_actions[prev_round_number]
        prev_coop_count = int(my_prev_action) + np.sum(opponents_prev_actions)
        self.cooperation_history.append(prev_coop_count)
        if len(self.cooperation_history) == 1:
            m = self.cooperation_history[0]
        else:
            m = sum(self.cooperation_history) / len(self.cooperation_history)
        if self.punishment_remaining > 0:
            action = Action.D
            self.punishment_remaining -= 1
        elif prev_coop_count < m:
            self.miss_count += 1
            excess = max(0, self.miss_count - self.tolerance)
            self.punishment_remaining = 2 + excess
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_218(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and defection.
    Cooperates initially, cooperates again if enough others cooperated previously, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            if history is None:
                return Action.C
            previous_round = state.round_number - 1
            my_prev = history.my_actions[previous_round]
            opponent_prev = history.opponent_actions[previous_round, :]
            total = my_prev + sum(opponent_prev)
            m = self.game_description.n_players // 2
            if total >= m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_220(BaseStrategy):
    """
    A reactive strategy for the N-player public goods game. Defects in the first round,
    then cooperates if at least half of the players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.threshold = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        previous_round = history.my_actions[state.round_number - 1]
        opponent_actions = history.opponent_actions[state.round_number - 1, :]
        total_coop = previous_round + np.sum(opponent_actions)
        if total_coop >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_221(BaseStrategy):
    """
    An adaptive cooperation strategy with punishment and learning.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_action = history.my_actions[last_round]
        opponent_actions = history.opponent_actions[last_round]
        cooperators_last = sum(opponent_actions) + (1 if my_action else 0)
        if cooperators_last >= self.threshold:
            return Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.C
        recent_rounds = [state.round_number - 2, last_round]
        recent_roundsvalid = [r for r in recent_rounds if r >= 0]
        recent_actions = [history.my_actions[r] for r in recent_roundsvalid]
        defect_count = sum((1 for action in recent_actions if not action))
        if defect_count <= 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_222(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that starts with an exploration phase,
    then uses historical performance to decide actions based on expected payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.count_C_success = 0
        self.total_C = 0
        self.count_D_success = 0
        self.total_D = 0
        self.last_processed_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if history is not None:
            current_history_length = len(history.my_actions)
            for round_number in range(self.last_processed_round + 1, current_history_length):
                my_action = history.my_actions[round_number]
                opponent_actions = history.opponent_actions[round_number]
                total_coop = int(my_action) + np.sum(opponent_actions)
                threshold_met = total_coop >= self.m
                if my_action:
                    self.total_C += 1
                    if threshold_met:
                        self.count_C_success += 1
                else:
                    self.total_D += 1
                    if threshold_met:
                        self.count_D_success += 1
                self.last_processed_round = round_number
        if current_round < 5:
            if current_round % 2 == 0:
                return Action.C
            else:
                return Action.D
        else:
            p_C = self.count_C_success / self.total_C if self.total_C > 0 else 0.0
            p_D = self.count_D_success / self.total_D if self.total_D > 0 else 0.0
            e_c = p_C * self.k
            e_d = p_D * (1 + self.k) + (1 - p_D) * 1.0
            if e_c > e_d:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_224(BaseStrategy):
    """
    A strategy that always defects in the N-player public goods game.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_EXPLOITATIVE_226(BaseStrategy):
    """
    A strategy that cooperates initially, adapts based on the number of cooperators, 
    and defects in the final round to maximize personal payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            m = self.game_description.n_players // 2
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            total_cooperators = (1 if my_prev_action else 0) + sum(opponents_prev_actions)
            if total_cooperators >= m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_227(BaseStrategy):
    """
    Adaptive Exploitation Strategy:
    - Cooperate in the first round to encourage initial cooperation.
    - In subsequent rounds, defect if the average cooperation of others in previous rounds meets or exceeds a threshold; otherwise, cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = (game_description.n_players - 1) / 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_coop = 0.0
        for t in range(state.round_number):
            coop_count = np.sum(history.opponent_actions[t])
            total_coop += coop_count
        avg_coop = total_coop / state.round_number
        if avg_coop >= self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_228(BaseStrategy):
    """
    An exploitative strategy for the N-Player Public Goods Game that adapts based on historical cooperation levels.
    It cooperates initially, then defects when it's safe to do so, ensuring the reward threshold is met.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.coop_counts = []

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if history is not None:
            prev_len = len(self.coop_counts)
            possible_new_rounds = len(history.my_actions)
            for i in range(prev_len, possible_new_rounds):
                my_action = history.my_actions[i]
                opponent_actions = history.opponent_actions[i]
                opponent_coop = sum(opponent_actions)
                total_coop = int(my_action) + opponent_coop
                self.coop_counts.append(total_coop)
        is_last_round = current_round == self.n_rounds - 1
        if is_last_round:
            moving_window = self.coop_counts[-3:]
            if not moving_window:
                return Action.C
            recent_coops = [x for x in moving_window if x >= self.m]
            proportion = len(recent_coops) / len(moving_window)
            if proportion > 0.5:
                return Action.D
            else:
                return Action.C
        else:
            moving_window = self.coop_counts[-3:]
            if not moving_window:
                return Action.C
            recent_coops = [x >= self.m for x in moving_window]
            recent_coops_count = sum(recent_coops)
            proportion = recent_coops_count / len(moving_window)
            if proportion > 0.5:
                last_coop = moving_window[-1]
                defect_safe = last_coop - 1 >= self.m
                if defect_safe:
                    return Action.D
            return Action.C

class Strategy_EXPLOITATIVE_229(BaseStrategy):
    """
    A strategy that starts with cooperation and then adjusts based on the number of cooperators.
    The AI cooperates initially. If the number of cooperators in the previous round is at least m,
    the AI defects; otherwise, it cooperates again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponents_prev_actions = history.opponent_actions[previous_round]
        sum_coop = int(my_prev_action) + int(np.sum(opponents_prev_actions))
        if sum_coop >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_230(BaseStrategy):
    """
    A strategy that balances cooperation and exploitation by adapting to the game's history.
    Cooperates initially, adapts based on the number of previous cooperators, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = math.ceil(self.n_players / 2)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        if history is None:
            return Action.C
        own_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round]
        total_coop = sum(opponent_prev_actions) + (1 if own_prev_action else 0)
        return Action.C if total_coop >= self.m else Action.D

class Strategy_EXPLOITATIVE_231(BaseStrategy):
    """
    A strategy that starts with cooperation, then adapts based on previous round's cooperation level.
    Cooperates if enough players cooperated previously; otherwise, defects. Periodically tests cooperation
    after a series of defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        super().__init__(game_description)
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.x = 4
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_defections = 0
            return Action.C
        if history is not None:
            my_previous = history.my_actions[-1]
            opponent_prev = history.opponent_actions[-1, :]
            c_prev = sum(opponent_prev) + (1 if my_previous else 0)
        else:
            c_prev = 0
        if c_prev >= self.m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections >= self.x:
                self.consecutive_defections = 0
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_232(BaseStrategy):
    """
    An adaptive strategy that Cooperates based on the previous round's cooperation level.
    Uses threshold m, calculated as the ceiling of (n_players / k).
    If the previous round had at least m cooperators, Cooperate; else Defect.
    Always Cooperates in round 0.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.m = int(self.m)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        if history is None:
            return Action.D
        my_prev_action = history.my_actions[previous_round]
        opponents_actions_prev = history.opponent_actions[previous_round, ...]
        opponents_coop_prev = np.sum(opponents_actions_prev)
        total_coop_prev = int(my_prev_action) + opponents_coop_prev
        if total_coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_233(BaseStrategy):
    """
    Adaptive Threshold Cooperation with Exploration strategy.
    Balances cooperation based on historical outcomes with periodic exploration.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = math.ceil(self.n_players / 2)
        self.threshold_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_length = len(self.threshold_history)
        max_round = state.round_number - 1
        if max_round >= 0:
            for r in range(current_length, max_round + 1):
                if r >= len(history.my_actions):
                    break
                my_action = history.my_actions[r]
                opp_actions = history.opponent_actions[r, :]
                total = (1 if my_action else 0) + np.sum(opp_actions)
                met = 1 if total >= self.m else 0
                self.threshold_history.append(met)
        window_size = 3
        relevant_history = self.threshold_history[-window_size:]
        met_count = sum(relevant_history)
        num_rounds = len(relevant_history)
        proportion_met = met_count / num_rounds if num_rounds > 0 else 0
        if proportion_met >= 0.5:
            action = Action.C
        else:
            action = Action.D
        if random.random() < 0.1:
            action = Action.D if action == Action.C else Action.C
        if state.round_number == self.n_rounds - 1:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_234(BaseStrategy):
    """
    Adaptive Threshold Cooperation (ATC) strategy.

    Cooperates in the first round and continues to Cooperate in subsequent rounds if the number of Cooperators 
    in the previous round meets or exceeds a threshold m, which is derived from the multiplication factor k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        sum_opponents = np.sum(history.opponent_actions[prev_round])
        total_C = sum_opponents + (1 if my_prev else 0)
        if total_C >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_235(BaseStrategy):
    """
    An adaptive strategy that decides whether to Cooperate or Defect based on historical success.
    The strategy starts by Cooperating and then adapts by evaluating the ratio of successful rounds.
    A round is considered successful if the number of cooperators meets or exceeds a computed threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.floor(game_description.n_players / game_description.k) + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        success = 0
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        total_rounds = len(my_actions)
        for t in range(total_rounds):
            my_c = 1 if my_actions[t] else 0
            opponents_c = sum(opponent_actions[t])
            total_c = my_c + opponents_c
            if total_c >= self.m:
                success += 1
        ratio = success / total_rounds if total_rounds > 0 else 0.5
        return Action.C if ratio > 0.5 else Action.D

class Strategy_EXPLOITATIVE_236(BaseStrategy):
    """
    A conditional cooperation strategy for the N-player public goods game.
    Cooperates in the first round, then continues cooperating if the number
    of cooperators in the previous round meets a threshold based on game parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)
        self.m = min(self.m, self.n)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        num_cooperators = sum(opp_prev_actions) + (1 if my_prev_action else 0)
        if num_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_237(BaseStrategy):
    """
    Adaptive Cooperation with Punishment and Reset (ACPR) Strategy.
    Cooperates initially, then adapts based on previous cooperation levels,
    with a reset mechanism after consecutive failures.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.reset_threshold = 3
        self.consecutive_failures = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round]
        coop_count = 1 if my_prev_action else 0
        coop_count += np.sum(opponent_prev_actions)
        if coop_count >= self.m:
            self.consecutive_failures = 0
            return Action.C
        else:
            self.consecutive_failures += 1
            if self.consecutive_failures >= self.reset_threshold:
                self.consecutive_failures = 0
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_238(BaseStrategy):
    """
    Adaptive Exploitative Tit-for-Tat strategy for the N-player public goods game.
    Cooperates initially, then reciprocates based on previous rounds' cooperation levels.
    In the last round, it evaluates recent history to decide the action.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            return Action.C
        elif t == self.r - 1:
            s_start = max(0, t - 5)
            recent_rounds = []
            for s in range(s_start, t):
                my_coop = history.my_actions[s]
                opp_coop = sum(history.opponent_actions[s])
                recent_rounds.append(my_coop + opp_coop >= self.m)
            successes = sum(recent_rounds)
            total = len(recent_rounds)
            if total == 0:
                return Action.D
            proportion = successes / total
            return Action.C if proportion > 0.5 else Action.D
        else:
            s_prev = t - 1
            my_prev = history.my_actions[s_prev]
            opp_prev = sum(history.opponent_actions[s_prev])
            prev_coops = my_prev + opp_prev
            return Action.C if prev_coops >= self.m else Action.D

class Strategy_EXPLOITATIVE_239(BaseStrategy):
    """
    This strategy starts by cooperating in the first round, continues to cooperate if enough others cooperated in the previous round, 
    and defects in the final round to maximize personal gain. The threshold for cooperation is half the number of players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        elif round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round]
            total_coop = int(my_prev_action) + np.sum(opponent_prev_actions)
            return Action.C if total_coop >= self.threshold else Action.D

class Strategy_EXPLOITATIVE_240(BaseStrategy):
    """Adaptive cooperation strategy with initial exploration and endgame defection."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.initial_phase_length = max(1, int(self.n_rounds * 0.1))
        self.endgame_length = max(1, int(self.n_rounds * 0.05))
        self.cooperation_threshold = self.n_players / 2.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.initial_phase_length:
            return Action.C
        if state.round_number >= self.n_rounds - self.endgame_length:
            return Action.D
        start = self.initial_phase_length
        end = state.round_number - 1
        if start > end:
            return Action.C
        considered_rounds = end - start + 1
        cooperation_rounds = 0
        for r in range(start, end + 1):
            my_action = history.my_actions[r]
            opponent_actions = history.opponent_actions[r, :]
            opp_c = np.sum(opponent_actions)
            total_c = my_action + opp_c
            if total_c >= self.cooperation_threshold:
                cooperation_rounds += 1
        if considered_rounds == 0:
            cooperation_rate = 0.0
        else:
            cooperation_rate = cooperation_rounds / considered_rounds
        if cooperation_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_241(BaseStrategy):
    """
    Strategy to maximize payoff in an N-player public goods game.
    Cooperate if at least half of the players cooperated in the previous round;
    otherwise, defect. Cooperate unconditionally in the first round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_act = history.my_actions[prev_round]
        my_c = 1 if my_prev_act else 0
        opp_acts = history.opponent_actions[prev_round]
        opp_c = sum(opp_acts)
        total_c = my_c + opp_c
        if total_c >= self.m:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_243(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma in N-Player Public Goods Game.
    
    This strategy balances cooperation for collective reward with cautious defection
    when others aren't cooperating sufficiently. It adapts based on observed behavior.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.c_prev_history = []
        self.last_round_cooperators = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_opponents = history.opponent_actions[-1]
        c_prev = int(prev_my_action) + sum(prev_opponents)
        self.c_prev_history.append(c_prev)
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        trend_increasing = False
        if len(self.c_prev_history) >= 3:
            recent_avg = sum(self.c_prev_history[-2:]) / 2
            prior_avg = sum(self.c_prev_history[-4:-2]) / 2 if len(self.c_prev_history) >= 4 else 0
            trend_increasing = recent_avg > prior_avg
        m = self.game_description.n_players // 2
        if m >= self.game_description.n_players - 1:
            if c_prev >= m:
                return Action.D
        if c_prev >= m:
            if c_prev >= self.game_description.n_players - 1:
                return Action.D
            else:
                return Action.C
        elif trend_increasing:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_244(BaseStrategy):
    """Adaptive Cooperation Based on Recent Performance strategy.

    This strategy starts by Cooperating in the first round. In subsequent rounds,
    it Cooperates if at least half of the players (rounded down) Cooperated in the previous round.
    Otherwise, it Defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round].item()
        opponent_actions_prev = history.opponent_actions[prev_round, ...]
        my_coop = 1 if my_prev_action else 0
        opponent_coop = np.sum(opponent_actions_prev)
        total_coop = my_coop + opponent_coop
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_245(BaseStrategy):
    """
    Implements the Adaptive Threshold Cooperation strategy, which includes 
    initial cooperation, adaptive decision based on historical cooperation rates,
    and endgame defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        n = self.n_players
        R = self.n_rounds
        if round_number == 0 or round_number < 5:
            return Action.C
        if round_number >= R - 5:
            return Action.D
        t = round_number
        if t == 0:
            return Action.C
        sum_me = sum(history.my_actions[:t])
        sum_others = 0
        for r in range(t):
            sum_others += sum(history.opponent_actions[r])
        total_coop = sum_me + sum_others
        average_coop = total_coop / (n * t)
        threshold = 0.5
        if average_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_246(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that decides actions based on historical performance.
    It starts with cooperation and then dynamically adjusts based on the expected values of cooperation and defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_rounds = []
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            my_c = 1 if my_action else 0
            opponents_c = history.opponent_actions[t].sum()
            total_c = my_c + opponents_c
            previous_rounds.append(total_c)
        q = state.round_number
        p = sum((1 for cr in previous_rounds if cr >= self.m))
        E_coop = p / q * self.k
        E_defect = p / q * (1 + self.k) + (q - p) / q * 1
        if E_coop > E_defect:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_248(BaseStrategy):
    """
    Adaptive Cooperation with Last-Round Exploitation strategy.
    Cooperates initially, adapts based on the number of cooperators in the previous round,
    and defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = (game_description.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            my_last = history.my_actions[-1]
            opponent_last = history.opponent_actions[-1, :]
            total_coop = my_last + np.sum(opponent_last)
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_356(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy.
    
    This strategy starts with cooperation, then responds based on the number of 
    cooperators in previous rounds, defects if cooperation is insufficient, and 
    forgives if cooperation resumes. The last round decision is based on the 
    majority of previous rounds meeting the cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m = self.n // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.r - 1:
            if history is None:
                return Action.C
            counts = 0
            for t in range(current_round):
                opponents = history.opponent_actions[t] if t < history.opponent_actions.shape[0] else np.array([], dtype=bool)
                cof = sum(opponents == True)
                cof += history.my_actions[t] if t < len(history.my_actions) else False
                if cof >= self.m:
                    counts += 1
            total_rounds = current_round
            if counts > total_rounds / 2:
                return Action.C
            else:
                return Action.D
        else:
            if history is None or len(history.my_actions) <= current_round:
                return Action.C
            has_defected = any((not action for action in history.my_actions[:current_round]))
            if not has_defected:
                prev_round = current_round - 1
                if prev_round >= len(history.opponent_actions):
                    return Action.C
                opponents = history.opponent_actions[prev_round]
                cof_prev = sum(opponents == True)
                cof_prev += history.my_actions[prev_round]
                if cof_prev >= self.m:
                    return Action.C
                else:
                    return Action.D
            else:
                last_d_round = None
                for t in range(len(history.my_actions)):
                    if not history.my_actions[t]:
                        last_d_round = t
                if last_d_round is None:
                    return Action.D
                if last_d_round + 1 < current_round:
                    found = False
                    for i in range(last_d_round + 1, current_round):
                        if i >= len(history.opponent_actions):
                            continue
                        opponents = history.opponent_actions[i]
                        cof_i = sum(opponents == True) + (history.my_actions[i] if i < len(history.my_actions) else False)
                        if cof_i >= self.m:
                            found = True
                            break
                    return Action.C if found else Action.D
                else:
                    return Action.D

class Strategy_COLLECTIVE_407(BaseStrategy):
    """
    Cooperative Punishment with Forgiveness Strategy.
    Cooperates in the first and last rounds. For other rounds, cooperates if at least m players cooperated previously.
    Punishes by defecting if fewer than m players cooperated, promoting group cooperation through coordinated punishment.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            prev_actions = history.opponent_actions[-1]
            count_coop = np.sum(prev_actions)
            if count_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_438(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on recent outcomes, 
    with mechanisms to encourage sustained cooperation and adapt to declining success.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)
        self.w = 3
        self.t = 2
        self.s = 2

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        window_size = min(self.w, len(my_actions))
        success_count = 0
        for i in range(window_size):
            round_idx = len(my_actions) - window_size + i
            is_coop = my_actions[round_idx]
            total_c = 1 if is_coop else 0
            total_c += np.sum(opponent_actions[round_idx, :])
            if total_c >= self.m:
                success_count += 1
        if success_count >= self.t:
            return Action.C
        if len(my_actions) >= self.s:
            all_def = True
            for i in range(self.s):
                round_idx = len(my_actions) - 1 - i
                if my_actions[round_idx]:
                    all_def = False
                    break
            if all_def:
                all_unsuccess = True
                for i in range(self.s):
                    round_idx = len(my_actions) - self.s + i
                    is_coop = my_actions[round_idx]
                    total_c = 1 if is_coop else 0
                    total_c += np.sum(opponent_actions[round_idx, :])
                    if total_c >= self.m:
                        all_unsuccess = False
                        break
                if all_unsuccess:
                    return Action.C
        return Action.D

class Strategy_COLLECTIVE_461(BaseStrategy):
    """
    Strategy for Collective Risk Dilemma in N-Player Public Goods Game.
    Cooperates initially, continues if enough players cooperated previously,
    defects if insufficient, with forgiveness if cooperation resumes.
    Cooperates in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        previous_round = state.round_number - 1
        my_c = history.my_actions[previous_round]
        opp_cs = sum(history.opponent_actions[previous_round, :])
        total_c = my_c + opp_cs
        m = self.game_description.n_players // 2
        if total_c >= m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_4(BaseStrategy):
    """
    Adaptive Cooperation Strategy with Fail-Safe.

    This strategy begins by cooperating in the first round. In subsequent rounds, it calculates the expected number of cooperators
    based on others' past behavior and defects if this expectation meets or exceeds a threshold. If the proportion of successful
    rounds (where cooperation meets the threshold) falls below a set level, the strategy switches to permanent defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)
        self.p = 0.5
        self.S = 0
        self.has_failed = False

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        t = state.round_number
        if t == 0:
            return Action.C
        if self.has_failed:
            return Action.D
        expected_defect = 0.0
        if history is not None and history.opponent_actions is not None and (len(history.opponent_actions) > 0):
            avg_coops = np.mean(history.opponent_actions, axis=0)
            expected_defect = np.sum(avg_coops)
        else:
            expected_defect = 0.0
        if expected_defect >= self.m:
            action = Action.D
        else:
            action = Action.C
        success_count = 0
        for r in range(t):
            if history is None or len(history.my_actions) <= r or len(history.opponent_actions) <= r:
                my_coop = 0
                others_coop = 0
            else:
                my_coop = int(bool(history.my_actions[r]))
                others_coop = np.sum(history.opponent_actions[r])
            total_coop = my_coop + others_coop
            if total_coop >= self.m:
                success_count += 1
        if t > 0:
            proportion = success_count / t
            if proportion < self.p:
                self.has_failed = True
        return action

class Strategy_EXPLOITATIVE_34(BaseStrategy):
    """
    Adaptive Exploitation strategy for N-Player Public Goods Game.
    Cooperates in the first round, defects in the last round, and adapts based on previous cooperation levels.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            prev_my_c = int(history.my_actions[prev_round])
            sum_opponents_prev = np.sum(history.opponent_actions[prev_round, :])
            total_cooperators = prev_my_c + sum_opponents_prev
            threshold = self.game_description.n_players // 2
            return Action.C if total_cooperators >= threshold else Action.D

class Strategy_EXPLOITATIVE_39(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        sum_coop_prev = 0
        for r in range(state.round_number):
            if history.my_actions[r]:
                sum_coop_prev += 1
            sum_coop_prev += np.count_nonzero(history.opponent_actions[r])
        avg_coop_prev = sum_coop_prev / state.round_number
        if avg_coop_prev >= self.m:
            return Action.D
        else:
            sum_coop_new = sum_coop_prev + 1
            new_avg = sum_coop_new / (state.round_number + 1)
            if new_avg >= self.m:
                return Action.C
            else:
                return Action.C

class Strategy_EXPLOITATIVE_42(BaseStrategy):
    """
    A strategy that adapts based on historical cooperation success, initially cooperating and later exploiting.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        successful_threshold = 0
        for prev_round in range(current_round):
            others_actions = history.opponent_actions[prev_round, :]
            my_action = history.my_actions[prev_round]
            num_cooperators = others_actions.sum() + my_action
            if num_cooperators >= self.m:
                successful_threshold += 1
        success_ratio = successful_threshold / current_round
        cooperate_prob = max(0.0, min(1.0, 2 * success_ratio - 1.0))
        exploit_factor = 1.0 - current_round / self.n_rounds
        final_probability = cooperate_prob * exploit_factor
        if random.random() < final_probability:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_58(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma in N-Player Public Goods Game.
    Cooperates initially to encourage cooperation, then adapts based on previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_coop = history.my_actions[prev_round]
            opponent_actions = history.opponent_actions[prev_round, :]
            c_prev = int(my_coop) + int(np.sum(opponent_actions))
            if c_prev >= self.m + 1:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_59(BaseStrategy):
    """
    This strategy balances cooperation and defection by adapting to the group's performance.
    It cooperates initially, defects in the last round, and uses the recent history to decide actions in between.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            return Action.C
        elif t == self.game_description.n_rounds - 1:
            return Action.D
        else:
            met_threshold = 0
            s_list = [t - 1, t - 2, t - 3]
            for s in s_list:
                if s < 0:
                    continue
                my_action = history.my_actions[s]
                opponent_actions = history.opponent_actions[s, :]
                cooperators = my_action + np.sum(opponent_actions)
                if cooperators >= self.m:
                    met_threshold += 1
            if met_threshold >= 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_128(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that adapts based on previous cooperation levels.
    Cooperates initially, defects in the last round, and adapts in intermediate rounds based on the number of previous cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        r = self.n_rounds
        if current_round == 0:
            return Action.C
        if current_round == r - 1:
            return Action.D
        previous_round = current_round - 1
        my_prev_action = history.my_actions[previous_round]
        opponents_prev_actions = history.opponent_actions[previous_round]
        num_coop = my_prev_action + np.sum(opponents_prev_actions)
        if num_coop >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_147(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Success.
    Cooperates initially, then continues based on the success ratio of previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        T = len(history.my_actions)
        if T == 0:
            return Action.C
        S = 0
        n_players = self.game_description.n_players
        k = self.game_description.k
        for t in range(T):
            my_action = history.my_actions[t]
            others_sum = np.sum(history.opponent_actions[t, :])
            sum_c = my_action + others_sum
            public_good = k / n_players * sum_c
            if public_good >= 1.0:
                S += 1
        ratio = S / T
        if ratio > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_154(BaseStrategy):
    """
    A strategy that cooperates initially and then decides to defect or cooperate based on the necessity of contributions 
    to meet a cooperation threshold. The threshold is calculated as half the number of players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_last_action = history.my_actions[-1]
        opponent_last_actions = history.opponent_actions[-1, :]
        coop_last_round = my_last_action + np.sum(opponent_last_actions)
        if my_last_action:
            adjusted_coop = coop_last_round - 1
        else:
            adjusted_coop = coop_last_round
        if adjusted_coop >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_158(BaseStrategy):
    """
    Adaptive Cooperation with Final Round Exploitation (ACFRE) Strategy.
    Cooperates initially, adapts based on past success, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n // self.k + 1
        self.success_count = 0
        self.last_processed_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.r - 1:
            return Action.D
        else:
            if history is not None:
                hist_len = history.my_actions.size
                start = self.last_processed_round + 1
                end = hist_len - 1
                if start <= end:
                    for t in range(start, end + 1):
                        my_action = history.my_actions[t]
                        opponent_actions = history.opponent_actions[t]
                        total_coop = my_action + opponent_actions.sum()
                        if total_coop >= self.m:
                            self.success_count += 1
                    self.last_processed_round = end
            past_rounds_count = current_round
            past_success_rate = self.success_count / past_rounds_count if past_rounds_count != 0 else 0.0
            if past_success_rate >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_159(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma implementation.
    Cooperates initially, adapts based on cooperation success rate, 
    defects when cooperation is insufficient, and tests cooperation occasionally.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = 0.7 * self.n_players
        self.cooperation_threshold = 0.7
        self.defect_duration = 3
        self.defect_remaining = 0
        self.must_coop_next = False

    def __call__(self, state: GameState, history: PlayerHistory):
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        if current_round == self.n_rounds - 1:
            successful_rounds = 0
            for t in range(current_round):
                my_action = history.my_actions[t]
                opp_actions = history.opponent_actions[t]
                total_c = (1 if my_action else 0) + int(opp_actions.sum())
                if total_c >= self.m:
                    successful_rounds += 1
            success_rate = successful_rounds / current_round if current_round > 0 else 0
            if success_rate >= self.cooperation_threshold:
                return Action.C
            return Action.D
        if self.defect_remaining > 0:
            self.defect_remaining -= 1
            return Action.D
        if self.must_coop_next:
            self.must_coop_next = False
            return Action.C
        successful_rounds = 0
        for t in range(current_round):
            my_action = history.my_actions[t]
            opp_actions = history.opponent_actions[t]
            total_c = (1 if my_action else 0) + int(opp_actions.sum())
            if total_c >= self.m:
                successful_rounds += 1
        total_rounds = current_round
        success_rate = successful_rounds / total_rounds if total_rounds > 0 else 0
        if success_rate >= self.cooperation_threshold:
            return Action.C
        else:
            self.defect_remaining = self.defect_duration
            return Action.D

class Strategy_EXPLOITATIVE_169(BaseStrategy):
    """
    Adaptive Exploitation Based on Expected Contributions (AEBEC) Strategy.
    Cooperates initially and then decides based on expected contributions from others.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        opponent_actions = history.opponent_actions[:t, :]
        n_opponents = opponent_actions.shape[1] if opponent_actions.size > 0 else 0
        if n_opponents == 0:
            return Action.C
        sum_coops = np.sum(opponent_actions, axis=0)
        E = np.sum(sum_coops) / t
        m = self.k
        threshold = m - 1
        if E >= threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_182(BaseStrategy):
    """
    A strategy that balances cooperation and self-interest by adapting based on previous outcomes.
    Cooperates in the first round, then adapts based on the number of previous cooperators.
    Uses a threshold (m) derived from game parameters n and k to decide actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        c_prev = my_prev_action + np.sum(opponents_prev_actions)
        if c_prev < self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_216(BaseStrategy):
    """
    Adaptive Cooperator with Punishment and Reward Strategy.

    This strategy starts by Cooperating (C) in the first round to promote cooperation.
    It then assesses the cooperation level in each subsequent round. If enough players
    cooperated (meeting a threshold), it continues to Cooperate. If not, it Defects
    for two rounds as punishment. If cooperation doesn't resume after punishment, it
    alternates between Cooperate and Defect to disrupt potential exploiters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2
        self.defect_counter = 0
        self.alternate_active = False
        self.next_alternate_action = Action.C
        self.failed_punishment = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.alternate_active:
            action = self.next_alternate_action
            self.next_alternate_action = Action.D if action == Action.C else Action.C
            return action
        if self.defect_counter > 0:
            action = Action.D
            self.defect_counter -= 1
            return action
        if history is not None and history.my_actions.size > 0:
            last_round = history.my_actions.size - 1
            sum_coops = sum(history.opponent_actions[last_round, :]) + history.my_actions[last_round]
        else:
            sum_coops = 0
        if sum_coops >= self.m:
            self.failed_punishment = False
            return Action.C
        elif not self.failed_punishment:
            self.defect_counter = 2
            self.failed_punishment = True
            return Action.D
        else:
            self.alternate_active = True
            self.next_alternate_action = Action.C
            return Action.C

class Strategy_EXPLOITATIVE_219(BaseStrategy):
    """
    Adaptive Cooperation with Punishment strategy for N-player Public Goods Game.
    Cooperates initially and adapts based on recent cooperation trends, defecting
    when cooperation is insufficient to incentivize others.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold_m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        window_start = max(0, state.round_number - 3)
        window_rounds = range(window_start, state.round_number)
        n_good = 0
        for t in window_rounds:
            my_action = history.my_actions[t]
            opp_actions = history.opponent_actions[t, :]
            n_coop = int(my_action) + opp_actions.sum()
            if n_coop >= self.threshold_m:
                n_good += 1
        window_size = state.round_number - window_start
        majority = window_size // 2 + 1
        if n_good >= majority:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_223(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.prev_round_c = 0
        self.m = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            last_round = history.opponent_actions[-1, :]
            count_c = last_round.sum()
            if count_c >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_225(BaseStrategy):
    """
    This strategy cooperates in the first round. In subsequent rounds, it cooperates 
    if the number of cooperators in the previous round is at least m, where m is 
    calculated as ceil(n/k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_actions_prev_round = history.opponent_actions[prev_round, :]
            prev_coops = my_prev_action + sum(opponent_actions_prev_round)
            if prev_coops >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_242(BaseStrategy):
    """
    Strategy for N-Player Public Goods Game based on threshold cooperation.
    Uses a threshold m to decide when to defect or cooperate, considering others' past actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)
        self.always_defect = self.n < self.m

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if self.always_defect:
            return Action.D
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        r = self.r
        if current_round < r - 1:
            sum_prev = 0
            for past_round in range(current_round):
                opponent_actions = history.opponent_actions[past_round]
                sum_prev += sum(opponent_actions)
            average_prev = sum_prev / current_round
            if average_prev >= self.m - 1:
                return Action.D
            else:
                return Action.C
        else:
            sum_prev = 0
            for past_round in range(r - 1):
                opponent_actions = history.opponent_actions[past_round]
                sum_prev += sum(opponent_actions)
            average_prev = sum_prev / (r - 1)
            if average_prev + 1 >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_247(BaseStrategy):
    """
    Exploitative Strategy for the N-Player Public Goods Game.
    
    This strategy initially cooperates to encourage others, then adapts based on 
    the number of cooperators in the previous round. It cooperates again if 
    the number of cooperators meets a calculated threshold, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_action_prev = history.my_actions[prev_round]
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            opp_coop_count = sum(opponent_actions_prev)
            total_coop_prev = int(my_action_prev) + opp_coop_count
            if total_coop_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_249(BaseStrategy):
    """
    An adaptive exploitation strategy that starts with cooperation, continues if 
    the number of cooperators meets a threshold, and defects in the last round.
    Introduces randomness to avoid predictability.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        m = self.game_description.n_players / self.game_description.k
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_actions = history.opponent_actions[prev_round]
        sum_coop_prev = my_prev_action + sum(opponents_actions)
        r = random.random()
        if sum_coop_prev >= m:
            return Action.C if r < 0.9 else Action.D
        else:
            return Action.C if r < 0.1 else Action.D

class Strategy_EXPLOITATIVE_250(BaseStrategy):
    """
    Adaptive Exploitation Based on Historical Success (AEBHS)
    Strategy. Cooperates initially, then uses historical success rates
    to decide future actions, with special handling for the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            return Action.C
        elif t == self.game_description.n_rounds - 1:
            recent_rounds_count = min(t, 3)
            recent_start = max(0, t - recent_rounds_count)
            S_recent = 0
            for round in range(recent_start, t):
                my_action = history.my_actions[round]
                opp_actions = history.opponent_actions[round, :]
                total_coop = int(my_action) + int(np.sum(opp_actions))
                if total_coop >= self.m:
                    S_recent += 1
            if recent_rounds_count == 0:
                success_rate = 0.0
            else:
                success_rate = S_recent / recent_rounds_count
            threshold = self.m / self.game_description.n_players
            return Action.C if success_rate >= threshold else Action.D
        else:
            S = 0
            for round in range(0, t):
                my_action = history.my_actions[round]
                opp_actions = history.opponent_actions[round, :]
                total_coop = int(my_action) + int(np.sum(opp_actions))
                if total_coop >= self.m:
                    S += 1
            if t == 0:
                success_rate = 0.0
            else:
                success_rate = S / t
            threshold = self.m / self.game_description.n_players
            return Action.C if success_rate >= threshold else Action.D

class Strategy_EXPLOITATIVE_251(BaseStrategy):
    """
    Adaptive Exploitation Based on Historical Cooperation Strategy.
    Cooperates initially and adapts based on the number of cooperators in the previous round.
    Defects if previous cooperation meets or exceeds the calculated threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players / game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            last_round = state.round_number - 1
            sum_others = sum(history.opponent_actions[last_round, :])
            my_last = history.my_actions[last_round]
            c_prev = sum_others + my_last
            if c_prev >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_252(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on recent outcomes.
    Cooperates if recent rounds show sufficient cooperation, otherwise defects.
    Periodically cooperates to test conditions if defecting consecutively.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.consecutive_defects = 0
        self.next_coop = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.next_coop:
            self.next_coop = False
            self.consecutive_defects = 0
            return Action.C
        recent_start = max(0, state.round_number - 5)
        recent_rounds = range(recent_start, state.round_number)
        count = 0
        threshold = math.ceil(self.n_players / self.k)
        for t in recent_rounds:
            my_action = history.my_actions[t]
            opponent_actions = history.opponent_actions[t]
            sum_c = int(my_action) + np.sum(opponent_actions)
            if sum_c >= threshold:
                count += 1
        total = len(recent_rounds)
        q = count / total if total > 0 else 0.0
        if q >= 0.5:
            action = Action.C
            self.consecutive_defects = 0
        else:
            action = Action.D
            self.consecutive_defects += 1
            if self.consecutive_defects >= 3:
                self.next_coop = True
                self.consecutive_defects = 0
        return action

class Strategy_EXPLOITATIVE_253(BaseStrategy):
    """
    Adaptive Exploitation Strategy. Cooperate initially, then defect if others'
    cooperation in the previous round meets or exceeds m, which is set to n_players - 1.
    This aims to maximize individual payoff while ensuring collective contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        sum_others = sum(history.opponent_actions[prev_round])
        if sum_others >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_254(BaseStrategy):
    """
    A strategy that starts by cooperating and then responds to the previous round's cooperation level.
    It continues to cooperate if all players cooperated last round; otherwise, it defects. 
    It retries cooperation after two consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.defect_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            my_last = history.my_actions[-1]
            c_i = 1 if my_last else 0
            opponents_last = history.opponent_actions[-1, :]
            c_others = np.sum(opponents_last)
            last_c = c_i + c_others
            m = self.game_description.n_players
            if last_c >= m:
                self.defect_counter = 0
                return Action.C
            else:
                self.defect_counter += 1
                if self.defect_counter >= 2:
                    self.defect_counter = 0
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_255(BaseStrategy):
    """
    An adaptive strategy for N-player public goods games that balances cooperation and defection.
    It tests whether contributions are necessary for achieving the public good and adapts accordingly.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            last_action = history.my_actions[-1]
            last_payoff = history.my_payoffs[-1]
            if last_action == Action.C:
                received_last = last_payoff > 0
            else:
                received_last = last_payoff - 1 > 0
            if last_action == Action.C and received_last:
                return Action.D
            elif last_action == Action.D and received_last:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_256(BaseStrategy):
    """
    An adaptive strategy that starts by defecting and continues if successful, 
    switching to cooperating if defecting becomes ineffective.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.defect_count = 0
        self.successful_defects = 0
        self.m = self.n_players // 2
        self.threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        prev_round = state.round_number - 1
        if prev_round >= 0 and (not history.my_actions[prev_round]):
            opponents_coop = np.sum(history.opponent_actions[prev_round, :])
            total_coop = int(history.my_actions[prev_round]) + opponents_coop
            if total_coop >= self.m:
                self.successful_defects += 1
            self.defect_count += 1
        if self.defect_count == 0:
            success_rate = self.threshold
        else:
            success_rate = self.successful_defects / self.defect_count
        if success_rate > self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_257(BaseStrategy):
    """
    This strategy starts with cooperation and continues to cooperate if at least m players cooperated in the previous round,
    where m is calculated as the ceiling of n divided by k. Otherwise, it defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        s_prev = int(my_prev_action) + int(opp_prev_actions.sum())
        if s_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_258(BaseStrategy):
    """
    Adaptive Cooperation Based on Past Group Performance.

    This strategy starts by Cooperating in the first round. For subsequent rounds, it Cooperates if the number of Cooperators 
    in the previous round meets or exceeds a threshold (m), calculated as the ceiling of the multiplication factor (k). 
    Otherwise, it Defects to encourage others to cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opp_prev_actions = history.opponent_actions[previous_round]
        coop_count = sum(opp_prev_actions) + (1 if my_prev_action else 0)
        if coop_count >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_259(BaseStrategy):
    """
    Adaptive cooperation strategy with punishment. Cooperate in the first round and continue if enough players cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round, :]
        num_coop_prev = my_prev_action + np.sum(opp_prev_actions)
        if num_coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_260(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances individual gain 
    with collective success by conditionally cooperating or defecting based on 
    prior rounds' outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev = history.my_actions[previous_round]
        opp_prev = history.opponent_actions[previous_round, :]
        c_count = sum(opp_prev) + (1 if my_prev else 0)
        if c_count >= self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_261(BaseStrategy):
    """
    This strategy cooperates in the first round, then defects if the number of cooperators in the previous round meets or exceeds half the number of players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            my_prev_action = history.my_actions[state.round_number - 1]
            opponent_prev_actions = history.opponent_actions[state.round_number - 1, :]
            total_coop = 1 if my_prev_action else 0
            total_coop += np.sum(opponent_prev_actions)
            if total_coop >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_262(BaseStrategy):
    """
    A strategy balancing cooperation and exploitation by adapting based on the number of cooperators in previous rounds.
    It starts by cooperating and continues if enough players cooperate, otherwise it defects, with the last round always defecting.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        gd = self.game_description
        if t == 0:
            return Action.C
        elif t == gd.n_rounds - 1:
            return Action.D
        else:
            prev_t = t - 1
            my_prev = history.my_actions[prev_t]
            opponents_prev = history.opponent_actions[prev_t, :]
            total_coop = my_prev + sum(opponents_prev)
            m = gd.n_players // 2
            if total_coop >= m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_267(BaseStrategy):
    """
    A strategy that cooperates in the first round and then defects or cooperates based on others' previous contributions relative to k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        sum_others = np.sum(history.opponent_actions[previous_round, :])
        k = self.game_description.k
        if sum_others >= k:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_268(BaseStrategy):
    """
    Adaptive Cooperation with Final Round Defection strategy.
    Cooperates initially, continues if enough players cooperated,
    and Defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        self.m = (n + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.game_description.n_rounds - 1:
            return Action.D
        previous_round = round_num - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round]
        prev_coop_count = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
        if prev_coop_count >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_269(BaseStrategy):
    """
    A strategy that adapts cooperation based on the number of cooperators in the previous round.
    Cooperates initially, continues if sufficient cooperation was observed, else defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.threshold = self.n_players / self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponent_prev_actions = history.opponent_actions[-1, :]
        c_prev = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
        if c_prev >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_270(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Performance Strategy.

    This strategy starts by Cooperating in the first round. In subsequent rounds,
    it evaluates the number of cooperators in previous rounds and decides whether
    to Cooperate or Defect based on a majority threshold of cooperation rate.
    In the last round, it assesses the average number of cooperators across all
    previous rounds to decide its action.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = math.ceil(self.n_players / 2)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        is_last_round = state.round_number == self.n_rounds - 1
        if is_last_round:
            total_coops = 0
            for t in range(state.round_number):
                my_c = history.my_actions[t]
                opp_coop = np.sum(history.opponent_actions[t, :])
                total_coops += my_c + opp_coop
            avg_coops = total_coops / state.round_number
            return Action.C if avg_coops >= self.m else Action.D
        else:
            count = 0
            for t in range(state.round_number):
                my_c = history.my_actions[t]
                opp_coop = np.sum(history.opponent_actions[t, :])
                total = my_c + opp_coop
                if total >= self.m:
                    count += 1
            if count > state.round_number / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_271(BaseStrategy):
    """
    Historical Average-Based Cooperation Strategy.

    Cooperate in the first round. For subsequent rounds, use the historical average of cooperators.
    If adding your cooperation to the historical average meets or exceeds a threshold, cooperate.
    Otherwise, defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        total_coops = 0.0
        for r in range(t):
            my_coop = history.my_actions[r]
            opponent_coops = history.opponent_actions[r].sum()
            total_coops += (1 if my_coop else 0) + opponent_coops
        avg_coops = total_coops / t
        if avg_coops + 1 >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_272(BaseStrategy):
    """
    An adaptive strategy for the N-player public goods game that balances cooperation
    and defection based on historical outcomes to address the collective risk dilemma.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        if self.k == 0:
            self.m = 0
        else:
            self.m = math.floor(self.n / (self.k - 1e-09)) + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        total_rounds = self.r
        if current_round < total_rounds - 1:
            if history is None:
                history_len = 0
            else:
                history_len = len(history.my_actions)
            h = min(3, history_len)
            start = max(0, current_round - h)
            recent_success = 0
            for s in range(start, current_round):
                if s < 0 or s >= len(history.my_actions):
                    continue
                my_c = history.my_actions[s]
                opponent_actions = history.opponent_actions[s]
                coop_count = my_c + np.sum(opponent_actions)
                if coop_count >= self.m:
                    recent_success += 1
            fraction_success = recent_success / h
            if fraction_success > 0.5:
                return Action.C
            else:
                return Action.D
        else:
            if history is None or len(history.my_actions) == 0:
                return Action.D
            total_success = 0
            for s in range(len(history.my_actions)):
                my_c = history.my_actions[s]
                opponent_actions = history.opponent_actions[s]
                coop_count = my_c + np.sum(opponent_actions)
                if coop_count >= self.m:
                    total_success += 1
            fraction_total = total_success / len(history.my_actions)
            if fraction_total > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_273(BaseStrategy):
    """
    An exploitative strategy for the N-Player Public Goods Game that adaptively punishes defection
    while encouraging cooperation through proportional responses.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k) if self.k != 0 else 0
        self.consecutive_defections = 0
        self.previous_num_coop = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        previous_round = current_round - 1
        if history is not None:
            my_prev_action = history.my_actions[previous_round]
            opponent_prev_actions = history.opponent_actions[previous_round]
            num_coop_prev = my_prev_action + sum(opponent_prev_actions)
            if num_coop_prev >= self.m:
                self.consecutive_defections = 0
                action = Action.C
            else:
                self.consecutive_defections += 1
                if self.consecutive_defections >= 2:
                    p = num_coop_prev / self.n
                    action = Action.C if random.random() < p else Action.D
                else:
                    action = Action.D
            if current_round == self.r - 1:
                action = Action.C if num_coop_prev >= self.m else Action.D
            self.previous_num_coop = num_coop_prev
        else:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_274(BaseStrategy):
    """
    An adaptive strategy that initially cooperates and then uses a sliding window of past rounds to decide actions.
    Cooperates if more than half of the recent rounds (last 3) met a cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        window_size = min(3, state.round_number)
        count = 0
        for tau in range(state.round_number - window_size, state.round_number):
            my_action = history.my_actions[tau]
            sum_opponents = np.sum(history.opponent_actions[tau, :])
            total_cooperators = int(my_action) + sum_opponents
            if total_cooperators >= self.m:
                count += 1
        proportion = count / window_size
        if proportion > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_275(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and self-interest.
    Cooperates initially, retaliate if insufficient cooperation, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            previous_round = state.round_number - 1
            my_action_prev = history.my_actions[previous_round]
            opponent_actions_prev = history.opponent_actions[previous_round, :]
            my_coop = 1 if my_action_prev else 0
            others_coop = np.sum(opponent_actions_prev)
            total_coop = my_coop + others_coop
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_277(BaseStrategy):
    """
    Adaptive Cooperation with Exploitation: Cooperates initially, then adapts based on historical cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            total_rounds = state.round_number
            count = 0
            for round in range(total_rounds):
                my_c = history.my_actions[round]
                opponent_actions = history.opponent_actions[round]
                sum_c = my_c + np.sum(opponent_actions)
                if sum_c >= self.m:
                    count += 1
            p = count / total_rounds
            if p >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_279(BaseStrategy):
    """
    Adaptive Exploitation strategy based on historical cooperation rates.
    Cooperates initially and in subsequent rounds based on the average cooperation of others.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m_threshold = self.n_players / self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_coop = 0.0
        count = 0
        for r in range(state.round_number - 1):
            if history is not None:
                opponents_in_round = history.opponent_actions[r, :]
                coop_count = np.count_nonzero(opponents_in_round)
                total_coop += coop_count
                count += 1
        if count == 0:
            return Action.C
        avg_coop = total_coop / count
        if avg_coop >= self.m_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_280(BaseStrategy):
    """
    Adaptive Exploitative Strategy (AES) balances cooperation and exploitation.
    It cooperates initially, defects in the last round, and adapts based on past outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if state.round_number == r - 1:
            return Action.D
        success_count = 0
        for round_t in range(state.round_number):
            opp_actions = history.opponent_actions[round_t]
            my_action = history.my_actions[round_t]
            total_coop = sum(opp_actions) + (1 if my_action else 0)
            if total_coop >= self.m:
                success_count += 1
        total_prev_rounds = state.round_number
        success_rate = success_count / total_prev_rounds
        return Action.C if success_rate >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_281(BaseStrategy):
    """
    A strategy that cooperates initially and continues to cooperate only if the number 
    of cooperators in the previous round meets or exceeds a calculated threshold.
    This threshold is based on the game's parameters to ensure cooperation is beneficial.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_coop = sum(history.opponent_actions[prev_round])
        my_prev_action = history.my_actions[prev_round].item()
        total_prev_coop = opponent_coop + (1 if my_prev_action else 0)
        if total_prev_coop >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_283(BaseStrategy):
    """
    Adaptive Probe and Cooperate strategy. Start with cooperation, probe periodically,
    and adapt based on past success rates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.t = 5
        self.s = 3
        self.threshold = 0.5
        self.m = int(game_description.k)
        self.history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is not None:
            for i in range(len(history.my_actions)):
                if i >= len(self.history):
                    my_action = history.my_actions[i]
                    opponents = history.opponent_actions[i]
                    n_coop = int(my_action) + np.sum(opponents)
                    self.history.append(n_coop)
        if state.round_number == 0:
            return Action.C
        elif state.round_number <= self.t:
            return Action.C
        else:
            probe_round = False
            if (state.round_number - 1) % self.s == 0:
                if len(self.history) >= self.t:
                    probe_round = True
            if probe_round:
                return Action.C
            else:
                window_size = min(self.t, len(self.history))
                window = self.history[-window_size:]
                successes = sum((1 for coops in window if coops >= self.m))
                success_rate = successes / window_size if window_size > 0 else 0.0
                if success_rate >= self.threshold:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_284(BaseStrategy):
    """
    Reciprocal Cooperation with Forgiveness Strategy:
    - Cooperates in the first round.
    - Cooperates in subsequent rounds if at least half of the players cooperated in the previous round.
    - Defects otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            my_prev_action = history.my_actions[-1]
            opponents_prev_actions = history.opponent_actions[-1]
            c_t_minus_1 = sum(opponents_prev_actions) + (1 if my_prev_action else 0)
            if c_t_minus_1 >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_285(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and defection.
    It starts with cooperation, adapts based on others' historical actions, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        n_rounds = self.n_rounds
        if t == 0:
            return Action.C
        if t == n_rounds - 1:
            return Action.D
        opponent_actions_prior = history.opponent_actions[:t, :]
        total_coop = np.sum(opponent_actions_prior)
        t_prior = t
        T = total_coop / t_prior if t_prior != 0 else 0
        if T >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_286(BaseStrategy):
    """
    Adaptive Exploitation strategy for N-Player Public Goods Game.
    Cooperates initially and adapts based on the number of Cooperators in previous rounds.
    Defects for a calculated period when cooperation falls below a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.phase = 'coop'
        self.defect_countdown = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions = history.opponent_actions[prev_round, :]
        prev_coops = np.sum(opponent_actions) + (1 if history.my_actions[prev_round] else 0)
        if self.phase == 'coop':
            if prev_coops >= self.m:
                return Action.C
            else:
                self.phase = 'defect'
                remaining_rounds = self.game_description.n_rounds - state.round_number
                self.defect_countdown = remaining_rounds // self.m
                return Action.D
        elif self.phase == 'defect':
            if self.defect_countdown > 0:
                self.defect_countdown -= 1
                return Action.D
            else:
                self.phase = 'coop'
                return Action.C

class Strategy_EXPLOITATIVE_287(BaseStrategy):
    """
    A strategy designed to encourage sustained cooperation while being resilient to exploitation.
    It starts by cooperating and adapts based on the number of cooperators in previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = self.n_players / self.k
        self.reset_threshold = 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        sum_coop = my_prev_action + np.sum(opp_prev_actions)
        if sum_coop >= self.m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections < self.reset_threshold:
                return Action.D
            else:
                self.consecutive_defections = 0
                return Action.C

class Strategy_EXPLOITATIVE_288(BaseStrategy):
    """
    Adaptive cooperation strategy based on historical success.
    Cooperates initially, defects in the last round, and adapts based on the success ratio of past rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        successful_coops = 0
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        for t in range(len(my_actions)):
            my_c = 1 if my_actions[t] else 0
            opponents_c = sum(opponent_actions[t])
            total_c = my_c + opponents_c
            if total_c >= self.m:
                successful_coops += 1
        total_past_rounds = len(my_actions)
        success_ratio = successful_coops / total_past_rounds if total_past_rounds > 0 else 0.0
        if success_ratio > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_289(BaseStrategy):
    """
    An adaptive cooperation strategy based on historical performance.
    Cooperates initially and continues if enough players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n_players = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n_players / k)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_coop_prev = history.my_actions[prev_round]
            opp_actions_prev = history.opponent_actions[prev_round]
            total_coop_prev = my_coop_prev + np.sum(opp_actions_prev)
            if total_coop_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_290(BaseStrategy):
    """
    Strategy to maximize payoffs in an N-Player Public Goods Game by balancing cooperation and defection.
    Cooperates in the first round, defects in the last round, and adapts based on previous round's cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        my_prev_action = history.my_actions[-1]
        opp_prev_actions = history.opponent_actions[-1, :]
        sum_coop_prev = my_prev_action + np.sum(opp_prev_actions)
        if sum_coop_prev >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_291(BaseStrategy):
    """
    Adaptive Exploitation Based on Historical Performance strategy.
    Cooperates initially to encourage others, then defects if historical cooperation is sufficient.
    Uses a threshold m = n_players / k to decide actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players / game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        total_coop = 0.0
        for round in range(t):
            my_c = 1 if history.my_actions[round] else 0
            opp_actions = history.opponent_actions[round, :]
            opp_c = np.sum(opp_actions)
            total_coop_round = my_c + opp_c
            total_coop += total_coop_round
        E = total_coop / t
        if E >= self.m:
            return Action.D
        elif E + 1 >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_292(BaseStrategy):
    """
    Adaptive Cooperation with Punishment strategy. Cooperates initially, defects 
    if insufficient cooperation in the recent past, and defects in the last round.
    Uses a moving window of past rounds to adapt and forgive occasional defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n_players // 2
        self.window_size = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_round = state.round_number
        start_round = max(0, current_round - self.window_size)
        successful_rounds = 0
        for r in range(start_round, current_round):
            if history is None:
                return Action.D
            opponents_coop = history.opponent_actions[r]
            self_coop = history.my_actions[r]
            count_coop = np.sum(opponents_coop) + (1 if self_coop else 0)
            if count_coop >= self.m:
                successful_rounds += 1
        if self.window_size == 0:
            threshold = 0
        else:
            threshold = (self.window_size + 1) // 2
        if successful_rounds >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_293(BaseStrategy):
    """
    A strategy that adapts based on the number of cooperators in the previous round.
    Cooperates if the number of cooperators meets a threshold (n_players // 2).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_actions = history.opponent_actions[prev_round, :]
            total_coop = int(my_prev_action) + sum(opponent_actions)
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_294(BaseStrategy):
    """
    Adaptive Cooperation with Last-Round Defection strategy.
    Cooperates initially, adapts based on the success ratio of previous rounds,
    and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n_players // 2 + 1

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        successful_rounds = 0
        for r in range(current_round):
            my_coop = history.my_actions[r]
            opponents_coop = np.sum(history.opponent_actions[r])
            total_coop = my_coop + opponents_coop
            if total_coop >= self.m:
                successful_rounds += 1
        success_ratio = successful_rounds / current_round
        if success_ratio > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_295(BaseStrategy):
    """
    Cooperation in the first round; defect if previous round had more cooperators than k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_coop = history.my_actions[prev_round]
        opponents_coop = history.opponent_actions[prev_round, :]
        total_coop = my_coop + np.sum(opponents_coop)
        if total_coop > self.k:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_296(BaseStrategy):
    """
    A strategy that cooperates initially and then decides based on the historical success of cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        s = 0
        for x in range(t):
            me_coop = history.my_actions[x]
            opp_coop = np.sum(history.opponent_actions[x, :])
            total_coop = me_coop + opp_coop
            if total_coop >= self.m:
                s += 1
        proportion = s / t
        return Action.C if proportion >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_297(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma in Public Goods Game.
    Cooperates initially, then adapts based on others' cooperation, using a threshold and trend monitoring.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = max(1, math.ceil(game_description.k))
        self.coop_history = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        sum_coop_prev = my_prev_action + sum(opponent_prev_actions)
        self.coop_history.append(sum_coop_prev)
        if len(self.coop_history) >= 2:
            trend = self.coop_history[-1] - self.coop_history[-2]
        else:
            trend = 0
        if sum_coop_prev < self.m or trend < 0:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_302(BaseStrategy):
    """
    Adaptive cooperation strategy for N-player public goods game.
    Cooperates initially;  defects when it's safe, otherwise cooperates.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        my_prev_coop = 1 if my_prev_action else 0
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        opponents_prev_coop = np.sum(opponents_prev_actions)
        c_prev = my_prev_coop + opponents_prev_coop
        if c_prev >= self.m and c_prev - 1 >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_303(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game where the player cooperates in the first round and continues cooperating if a majority of past rounds were successful.
    A round is considered successful if at least a majority of players cooperated.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        m = self.n_players // 2 + 1
        t = state.round_number
        S = 0
        for tau in range(t):
            my_action = history.my_actions[tau]
            my_c = 1 if my_action else 0
            opp_actions = history.opponent_actions[tau, :]
            opp_c = np.sum(opp_actions)
            total_c = my_c + opp_c
            if total_c >= m:
                S += 1
        threshold = 0.5 * (t - 1)
        if S > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_305(BaseStrategy):
    """
    Strategy for the Collective Risk Dilemma in an N-player public goods game.
    Cooperates initially, adapts based on the number of cooperators in previous rounds,
    and cooperate in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.n_rounds = game_description.n_rounds
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round, :]
        cooperators_prev = my_prev_action + np.sum(opponent_prev_actions)
        if cooperators_prev >= self.m:
            return Action.C if my_prev_action else Action.D
        else:
            return Action.D if my_prev_action else Action.C

class Strategy_EXPLOITATIVE_306(BaseStrategy):
    """
    An adaptive strategy that balances exploration and exploitation in an N-player public goods game.
    It starts by cooperating, periodically defects to test outcomes, and adapts based on success.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.exploration_prob = 0.2
        self.S = 0
        self.F = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number > 0:
            prev_round = state.round_number - 1
            if prev_round < len(history.my_actions):
                prev_action = history.my_actions[prev_round]
                if not prev_action:
                    sum_others_C = np.sum(history.opponent_actions[prev_round, :])
                    defect_payoff = history.my_payoffs[prev_round]
                    coop_payoff = self.k / self.n * (sum_others_C + 1)
                    if defect_payoff > coop_payoff:
                        self.S += 1
                    else:
                        self.F += 1
        if random.random() < self.exploration_prob:
            return Action.D
        elif self.S > self.F:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_307(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round]
            total_coop = sum(opponents_prev_actions) + my_prev_action
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_308(BaseStrategy):
    """
    Adaptive Cooperation with Exploitation (ACE) strategy for the N-Player Public Goods Game.
    
    This strategy begins by cooperating in the first round. In subsequent rounds, it evaluates the success of past cooperation and adapts accordingly. 
    If the proportion of successful cooperative rounds exceeds a calculated threshold, it continues to cooperate; otherwise, it defects. 
    In the final two rounds, the strategy defects to maximize personal gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        past_rounds = state.round_number
        count_success = 0
        for t in range(past_rounds):
            my_c = history.my_actions[t]
            opponents_c = history.opponent_actions[t, :].sum()
            total_c = my_c + opponents_c
            if total_c >= self.m:
                count_success += 1
        proportion = count_success / past_rounds
        threshold = self.m / self.game_description.n_players
        if proportion > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_309(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.defecting = False
        self.consecutive_defects = 0
        self.experiment_pending = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_t = state.round_number - 1
        if prev_t < 0:
            return Action.C
        my_prev = history.my_actions[prev_t]
        opponents_prev = history.opponent_actions[prev_t]
        prev_coop = sum(opponents_prev) + (1 if my_prev else 0)
        if self.experiment_pending:
            if prev_coop >= self.m:
                self.defecting = False
                self.consecutive_defects = 0
                self.experiment_pending = False
            else:
                self.defecting = True
                self.consecutive_defects = 1
                self.experiment_pending = False
            return Action.C if not self.defecting else Action.D
        elif self.defecting:
            self.consecutive_defects += 1
            if self.consecutive_defects >= 3:
                self.experiment_pending = True
                self.consecutive_defects = 0
                return Action.C
            else:
                return Action.D
        elif prev_coop >= self.m:
            return Action.C
        else:
            self.defecting = True
            self.consecutive_defects = 1
            return Action.D

@dataclass
class Strategy_EXPLOITATIVE_310(BaseStrategy):
    """
    A strategy that starts with cooperation, then adapts based on recent cooperation levels.
    Cooperates if at least two of the last three rounds had enough cooperators (>= ceil(k)).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        num_rounds_to_check = min(3, state.round_number)
        start_round = state.round_number - num_rounds_to_check
        successful_rounds = 0
        for r in range(start_round, state.round_number):
            my_action = history.my_actions[r]
            opponent_actions = history.opponent_actions[r]
            total_coop = my_action + np.sum(opponent_actions)
            if total_coop >= self.m:
                successful_rounds += 1
        if successful_rounds >= 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_311(BaseStrategy):
    """
    An adaptive strategy for the N-player public goods game that responds to previous outcomes.
    Cooperates initially, continues if the threshold of cooperators is met, defects otherwise,
    and tests cooperation again after consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        super().__init__(game_description)
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_defections = 0
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponents_prev_actions = history.opponent_actions[previous_round]
        total_c = int(my_prev_action) + np.sum(opponents_prev_actions)
        if total_c >= self.m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections >= 2:
                self.consecutive_defections = 0
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_313(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and exploitation based on past cooperation rates.
    Cooperates initially, then defects if enough players cooperated in the previous round, defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = self.n_players / self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            my_previous = history.my_actions[state.round_number - 1]
            opponents_previous = history.opponent_actions[state.round_number - 1, :]
            c_prev = int(my_previous) + np.sum(opponents_previous)
            if c_prev >= self.threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_314(BaseStrategy):
    """
    Adaptive Cooperation with Periodic Testing Strategy.

    This strategy begins by cooperating, then uses the number of cooperators in the previous round
    to decide actions while periodically testing for renewed cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            my_action = history.my_actions[-1]
            opponent_actions = history.opponent_actions[-1, :]
            total_coop = sum(opponent_actions) + my_action
            if total_coop >= self.m:
                return Action.C
            elif (state.round_number + 1) % 3 == 0:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_315(BaseStrategy):
    """
    Exploitative Strategy for the N-Player Public Goods Game.
    Cooperates in the first round and continues cooperating if the number of cooperators
    in the previous round meets or exceeds a threshold (m), otherwise defects.
    The threshold is calculated as the ceiling of the multiplication factor k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            own_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, :]
            prev_coop = sum(opp_prev_actions) + (1 if own_prev_action else 0)
            if prev_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_316(BaseStrategy):
    """Adaptive Cooperation Based on Past Success strategy implementation."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        s = 0
        t_total = state.round_number
        for prev_round in range(t_total):
            my_c = int(history.my_actions[prev_round])
            others_actions = history.opponent_actions[prev_round, :]
            others_c = int(sum(others_actions))
            total_c = my_c + others_c
            if total_c >= self.game_description.k:
                s += 1
        ratio = s / t_total
        if ratio > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_317(BaseStrategy):
    """
    This strategy adapts cooperation based on the historical success of rounds.
    It cooperates initially and continues if the ratio of successful rounds meets a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        successful_rounds = 0
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            my_c = 1 if my_action else 0
            opp_c = history.opponent_actions[t].sum()
            total_c = my_c + opp_c
            if total_c >= self.m:
                successful_rounds += 1
        success_ratio = successful_rounds / state.round_number
        threshold = self.m / self.n_players
        if success_ratio >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_318(BaseStrategy):
    """
    A strategy that begins by cooperating and then alternates based on the number of cooperators in the previous round.
    If at least half of the players cooperated in the previous round, the player will defect in the current round;
    otherwise, the player will cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_number = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_number]
        opp_prev_actions = history.opponent_actions[prev_round_number, :]
        sum_prev_coop = my_prev_action + np.sum(opp_prev_actions)
        if sum_prev_coop >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_319(BaseStrategy):
    """
    A strategy that starts by Cooperating and then determines actions based on historical cooperation rates.
    Cooperates if the average number of other Cooperators in previous rounds is below a threshold (k),
    otherwise Defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = state.round_number
        other_coops = []
        for s in range(n):
            my_action = history.my_actions[s]
            opp_actions = history.opponent_actions[s, :]
            opp_c = np.sum(opp_actions)
            if my_action:
                other_coop = opp_c
            else:
                other_coop = opp_c
            other_coops.append(other_coop)
        if not other_coops:
            return Action.C
        avg = np.mean(other_coops)
        threshold = self.game_description.k
        return Action.D if avg >= threshold else Action.C

class Strategy_EXPLOITATIVE_321(BaseStrategy):
    """
    Adaptive Cooperation Threshold (ACT) strategy.
    Cooperates initially, then adapts based on the proportion of successful rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        S = 0
        for prev_round in range(t):
            opponent_coop = np.sum(history.opponent_actions[prev_round, :])
            my_coop = history.my_actions[prev_round]
            total_coop = opponent_coop + my_coop
            if total_coop >= self.m:
                S += 1
        ratio = S / t
        if ratio >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_322(BaseStrategy):
    """Recent Threshold Cooperator (RTC) strategy implementation."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_minus_1 = state.round_number - 1
        my_prev_action = history.my_actions[t_minus_1]
        opponent_prev_actions = history.opponent_actions[t_minus_1, :]
        opponent_coop = np.sum(opponent_prev_actions)
        total_coop = opponent_coop + (1 if my_prev_action else 0)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_323(BaseStrategy):
    """
    Cooperate in the first round, then defect if enough others cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponents_actions = history.opponent_actions[prev_round, :]
        cooperators = np.sum(opponents_actions)
        if cooperators >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_324(BaseStrategy):
    """
    An adaptive strategy for the N-player public goods game. Cooperates initially, 
    then uses opponent cooperation rates to decide actions based on expected values.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        opponent_actions = history.opponent_actions
        n_opponents = opponent_actions.shape[1]
        sum_others_rates = 0.0
        for j in range(n_opponents):
            cooperation_count = np.sum(opponent_actions[:, j])
            cooperation_rate = cooperation_count / t
            sum_others_rates += cooperation_rate
        E_C = sum_others_rates + 1
        E_D = sum_others_rates
        if E_C >= self.m:
            return Action.C
        elif E_D >= self.m:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_325(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that adaptively decides to Cooperate or Defect based on the threshold of other players' cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        opponent_actions_last = history.opponent_actions[last_round, :]
        opponent_coop_last = np.sum(opponent_actions_last)
        player_action_last = history.my_actions[last_round]
        other_coop = opponent_coop_last
        if other_coop + 1 >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_326(BaseStrategy):
    """
    An adaptive and exploitative strategy that maximizes personal gain by leveraging others' cooperation.
    It balances cooperation with strategic exploitation based on previous outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        last_payoff = history.my_payoffs[-1]
        if last_payoff > 1.0:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_328(BaseStrategy):
    """Adaptive Exploitation Based on Historical Cooperation Strategy."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponents_prev_actions = history.opponent_actions[previous_round, :]
        total_cooperators = my_prev_action + sum(opponents_prev_actions)
        if total_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_329(BaseStrategy):
    """
    A strategy for the N-player public goods game that maximizes individual payoff
    by cooperating initially and then reacting to previous rounds' cooperation levels.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m_threshold = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev = history.my_actions[previous_round]
        opponent_prev = history.opponent_actions[previous_round, :]
        sum_opprev = np.count_nonzero(opponent_prev)
        my_contribution = 1 if my_prev else 0
        total_prev = sum_opprev + my_contribution
        if total_prev >= self.m_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_330(BaseStrategy):
    """
    Adaptive Threshold Punishment Strategy for N-Player Public Goods Game.
    
    This strategy encourages cooperation by initially cooperating, punishing 
    defectors by temporarily defecting, and permanently defecting if 
    opponents exploit cooperation. The strategy adapts based on the game 
    history and observed behavior of other players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / 2)
        self.exploitation_count = 0
        self.in_punishment = False
        self.in_exploitative_phase = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_rounds = self.game_description.n_rounds
        current_round = state.round_number
        if current_round < 0.1 * total_rounds:
            return Action.C
        if self.in_exploitative_phase:
            return Action.D
        if current_round >= 0.9 * total_rounds:
            return Action.D
        if self.in_punishment:
            if history is None:
                return Action.C
            prev_round = current_round - 1
            if prev_round < 0:
                return Action.C
            prev_total = sum(history.opponent_actions[prev_round])
            if history.my_actions[prev_round]:
                prev_total += 1
            if prev_total >= self.m:
                self.in_punishment = False
                return Action.C
            else:
                return Action.D
        else:
            if history is not None:
                prev_round = current_round - 1
                if prev_round >= 0 and history.my_actions is not None:
                    my_prev_action = history.my_actions[prev_round]
                    if my_prev_action:
                        prev_total = sum(history.opponent_actions[prev_round])
                        if my_prev_action:
                            prev_total += 1
                        if prev_total < self.m:
                            self.exploitation_count += 1
                            if self.exploitation_count >= 3:
                                self.in_exploitative_phase = True
                                return Action.D
            prev_round = current_round - 1
            if prev_round < 0:
                return Action.C
            my_prev_action = history.my_actions[prev_round]
            prev_total = sum(history.opponent_actions[prev_round])
            if my_prev_action:
                prev_total += 1
            if prev_total >= self.m:
                return Action.C
            else:
                self.in_punishment = True
                return Action.D

class Strategy_EXPLOITATIVE_331(BaseStrategy):
    """
    Cooperate in the first round. In subsequent rounds, defect if at least half of the players cooperated 
    in the previous round; otherwise, cooperate to encourage contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_prev_action = history.my_actions[last_round]
        opponents_prev_actions = history.opponent_actions[last_round]
        s = int(my_prev_action) + int(opponents_prev_actions.sum())
        if s >= self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_332(BaseStrategy):
    """
    An exploitative strategy that ensures cooperation only when necessary.
    The player starts by cooperating in the first round, then defects if their 
    previous cooperation wasn't pivotal.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_t = state.round_number - 1
        my_prev_action = history.my_actions[prev_t]
        others_prev = history.opponent_actions[prev_t]
        sum_others_prev = np.sum(others_prev)
        if my_prev_action:
            without_me = sum_others_prev
        else:
            without_me = sum_others_prev
        if without_me >= 0:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_333(BaseStrategy):
    """
    An adaptive strategy for the N-player Public Goods Game that starts with cooperation,
    then dynamically adjusts based on the group's cooperation rate and individual payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.recent_cooperation_threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        endgame_threshold_round = total_rounds - int(0.05 * total_rounds)
        is_endgame = current_round >= endgame_threshold_round
        if is_endgame:
            total_coop = 0.0
            for r in range(current_round):
                my_action = history.my_actions[r]
                my_coop = 1 if my_action else 0
                opp_coop = sum(history.opponent_actions[r, :])
                total_coop += (my_coop + opp_coop) / n_players
            overall_avg = total_coop / current_round if current_round != 0 else 0.0
            if overall_avg >= 0.7:
                return Action.C
            else:
                return Action.D
        else:
            total_avg = 0.0
            for r in range(current_round):
                my_action = history.my_actions[r]
                my_coop = 1 if my_action else 0
                opp_coop = sum(history.opponent_actions[r, :])
                total_avg += (my_coop + opp_coop) / n_players
            avg_coop = total_avg / current_round if current_round != 0 else 0.0
            last_round = current_round - 1
            opp_actions_last = history.opponent_actions[last_round]
            opp_coop_last = sum(opp_actions_last)
            k = self.game_description.k
            hyp_payoff = 1 + k / n_players * opp_coop_last
            actual_payoff = history.my_payoffs[last_round]
            my_last_action = history.my_actions[last_round]
            if my_last_action:
                reward_achieved = actual_payoff >= hyp_payoff
            else:
                coop_payoff = 0 + k / n_players * (opp_coop_last + 1)
                reward_achieved = actual_payoff >= hyp_payoff
            self.recent_cooperation_threshold = 0.9 * self.recent_cooperation_threshold + 0.1 * avg_coop
            if avg_coop >= self.recent_cooperation_threshold and reward_achieved:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_334(BaseStrategy):
    """
    Adaptive Exploitation strategy for an n-player public goods game.
    Cooperates initially, then uses the average cooperation rate to decide,
    defects in the last round, and can forgive and revert to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        total_coop = 0
        for round_num in range(current_round):
            my_coop = 1 if history.my_actions[round_num] else 0
            opp_coop = np.sum(history.opponent_actions[round_num])
            total_coop += my_coop + opp_coop
        avg_coop = total_coop / current_round
        threshold = self.n_players / self.k
        if avg_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_335(BaseStrategy):
    """
    Adaptive Exploitative Strategy for N-Player Public Goods Game.

    The strategy starts with cooperation to encourage collective success. 
    It adapts based on previous outcomes, switching to defection if 
    insufficient players cooperate, but periodically testing cooperation 
    again after two defections. It defects in the final round to maximize 
    personal payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2
        self.defect_consecutive = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            self.defect_consecutive = 0
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            self.defect_consecutive = 0
            return Action.D
        else:
            t_prev = state.round_number - 1
            if history is None:
                return Action.C
            my_last = history.my_actions[t_prev]
            opponents_last = history.opponent_actions[t_prev, :]
            total_c = my_last + np.sum(opponents_last)
            if total_c >= self.m:
                self.defect_consecutive = 0
                return Action.C
            else:
                self.defect_consecutive += 1
                if self.defect_consecutive <= 2:
                    return Action.D
                else:
                    self.defect_consecutive = 0
                    return Action.C

class Strategy_EXPLOITATIVE_336(BaseStrategy):
    """
    Cooperates if the majority of recent rounds (up to five) had at least half the players Cooperating.
    Starts with Cooperation, then adapts based on group performance.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        start = max(0, t - 5)
        count_success = 0
        for r in range(start, t):
            my_action = history.my_actions[r]
            opponents_actions = history.opponent_actions[r, :]
            total_coops = my_action + np.sum(opponents_actions)
            if total_coops >= self.m:
                count_success += 1
        len_recent = t - start
        if count_success * 2 > len_recent:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_337(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on previous round outcomes.
    Cooperates in the first round, defects in the last, and adapts in middle rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        elif round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = round_number - 1
            my_prev_action = history.my_actions[prev_round]
            total_coop = 1 if my_prev_action else 0
            total_coop += sum(history.opponent_actions[prev_round])
            return Action.C if total_coop >= self.m else Action.D

class Strategy_EXPLOITATIVE_338(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma in N-Player Public Goods Game.
    Cooperates initially and adapts based on the success rate of previous cooperations.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.coop_attempts = 0
        self.coop_successes = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        if previous_round >= 0 and history is not None:
            if history.my_actions[previous_round]:
                sum_c = history.my_actions[previous_round] + history.opponent_actions[previous_round].sum()
                if sum_c * self.k > self.n:
                    self.coop_successes += 1
                self.coop_attempts += 1
        is_last_round = state.round_number == self.game_description.n_rounds - 1
        if is_last_round:
            if self.coop_attempts == 0:
                return Action.D
            else:
                success_rate = self.coop_successes / self.coop_attempts
                return Action.C if success_rate >= 0.5 else Action.D
        elif self.coop_attempts == 0:
            return Action.C
        else:
            success_rate = self.coop_successes / self.coop_attempts
            return Action.C if success_rate >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_339(BaseStrategy):
    """
    This strategy starts by cooperating in the first round to encourage others. It then adaptively switches between cooperate and defect based on the history of cooperation. If a significant proportion of recent rounds have sufficient cooperation, it continues to cooperate; otherwise, it defects. In the final round, it defects to maximize immediate payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        f = min(3, state.round_number)
        successful_rounds = 0
        for t in range(max(0, state.round_number - f), state.round_number):
            my_c = history.my_actions[t]
            opp_c = history.opponent_actions[t]
            total_c = int(my_c) + np.sum(opp_c)
            if total_c >= self.m:
                successful_rounds += 1
        success_ratio = successful_rounds / f if f > 0 else 0.0
        return Action.C if success_ratio > self.threshold else Action.D

class Strategy_EXPLOITATIVE_340(BaseStrategy):
    """
    Adaptive Cooperate-Punish strategy. Starts by cooperating, then adapts based 
    on the level of cooperation in the group, includes a punishment phase and a 
    forgiveness mechanism.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2
        self.consecutive_defects = 0
        self.punish_threshold = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            if history is not None:
                count_sufficient = 0
                total_rounds = len(history.my_actions)
                for rnd in range(total_rounds):
                    my_action = history.my_actions[rnd]
                    opponent_actions = history.opponent_actions[rnd, :]
                    coop_total = my_action + opponent_actions.sum()
                    if coop_total >= self.m:
                        count_sufficient += 1
                if count_sufficient / total_rounds >= 0.5:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        else:
            last_round = state.round_number - 1
            my_last_action = history.my_actions[last_round]
            opponent_last_actions = history.opponent_actions[last_round, :]
            coop_last = my_last_action + opponent_last_actions.sum()
            if coop_last >= self.m:
                self.consecutive_defects = 0
                return Action.C
            else:
                self.consecutive_defects += 1
                if self.consecutive_defects >= self.punish_threshold:
                    self.consecutive_defects = 0
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_341(BaseStrategy):
    """
    A strategy that cooperates initially and adapts based on the number of previous cooperators.
    Cooperates if the number of cooperators in the previous round was at least n-1.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        t_prev = np.sum(opponent_actions_prev) + (1 if my_prev_action else 0)
        threshold = self.n_players - 1
        if t_prev >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_342(BaseStrategy):
    """
    A strategy for the N-player public goods game that balances cooperation and defection.
    Cooperates initially, then responds based on the number of previous cooperators,
    and defects in the last few rounds to maximize individual payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.s = 2
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number + 1
        if t > self.n_rounds - self.s:
            return Action.D
        prev_round = state.round_number - 1
        if history is not None:
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, :]
            total_coop = my_prev_action + sum(opp_prev_actions)
            return Action.C if total_coop >= self.m else Action.D
        return Action.D

class Strategy_EXPLOITATIVE_343(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and 
    exploitation by encouraging others to cooperate while seeking individual 
    benefits. It starts with cooperation, continues if a threshold is met, and 
    includes a reset mechanism after defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2
        self.last_defect_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_prev_action = history.my_actions[t_prev]
        opp_prev_actions = history.opponent_actions[t_prev, :]
        C_prev = int(my_prev_action) + int(np.sum(opp_prev_actions))
        if C_prev >= self.m:
            action = Action.C
        elif not my_prev_action:
            if self.last_defect_round == t_prev - 1:
                action = Action.C
            else:
                action = Action.D
        else:
            action = Action.D
        if action == Action.D:
            self.last_defect_round = t_prev
        elif action == Action.C and (not my_prev_action):
            self.last_defect_round = -1
        return action

class Strategy_EXPLOITATIVE_344(BaseStrategy):
    """
    An adaptive strategy that starts with cooperation, then uses historical cooperation rates 
    to decide actions, and predicts cooperation in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.total_coop = 0.0
        self.round_count = 0
        self.last_processed_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prior_rounds = state.round_number - 1
        current_rounds_in_history = history.my_actions.size
        start_round = self.last_processed_round + 1
        end_round = current_rounds_in_history
        for s in range(start_round, end_round):
            me = history.my_actions[s]
            opponents = history.opponent_actions[s, :]
            coop = int(me) + int(sum(opponents))
            self.total_coop += coop
            self.round_count += 1
        self.last_processed_round = end_round
        n_players = self.game_description.n_players
        k = self.game_description.k
        m = n_players / k
        if self.round_count == 0:
            average_coop = 0.0
        else:
            average_coop = self.total_coop / self.round_count
        if average_coop >= m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_345(BaseStrategy):
    """
    A strategy that cooperates in the first round, and in subsequent rounds 
    cooperates if at least half of the players (rounded down) cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round].item()
        opponents_prev = history.opponent_actions[prev_round]
        sum_coop_prev = my_prev + np.sum(opponents_prev)
        if sum_coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_346(BaseStrategy):
    """
    Adaptive Cooperation Threshold (ACT) strategy for the Public Goods Game.
    
    This strategy begins by cooperating in the first round to encourage others.
    In subsequent rounds, it cooperates if the number of cooperators in the previous round
    meets or exceeds a calculated threshold (m), which is derived from the game parameters.
    The threshold ensures that cooperation is individually beneficial based on the game's multiplier factor.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.floor(self.n_players / self.k) + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_action = history.my_actions[previous_round]
        opponent_actions = history.opponent_actions[previous_round]
        num_opponent_coop = np.sum(opponent_actions)
        total_coop = my_action + num_opponent_coop
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_347(BaseStrategy):
    """
    Adaptive Exploitation strategy based on historical cooperation levels.
    
    The strategy cooperates in the first round and then uses the average number
    of cooperators from all previous rounds to decide actions. If the average
    meets or exceeds a threshold (k from game parameters), the player cooperates
    in the current round; otherwise, the player defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        total_coop = 0
        for s in range(state.round_number):
            my_action = history.my_actions[s]
            my_coop = 1 if my_action else 0
            opp_actions = history.opponent_actions[s]
            opp_coop = np.sum(opp_actions)
            total_coop += my_coop + opp_coop
        avg_coop = total_coop / state.round_number
        if avg_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_348(BaseStrategy):
    """
    Implement a strategy that balances cooperation and defection based on others' past behavior to maximize individual payoff.
    Cooperates in the first round, then uses estimated cooperation probabilities of others to decide actions in subsequent rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.opponent_actions = None
        self.t = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.t = state.round_number
        opponent_actions = history.opponent_actions
        n_opponents = opponent_actions.shape[1]
        E_defect = 0.0
        for j in range(n_opponents):
            coop_count = sum(opponent_actions[:, j])
            probable_coop = coop_count / self.t if self.t != 0 else 0.0
            E_defect += probable_coop
        E_coop = E_defect + 1.0
        if E_coop >= self.m:
            if E_defect < self.m:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_349(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that starts with cooperation, 
    continues if enough others cooperate, defects otherwise, and attempts to 
    restart cooperation after a set number of defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 3
        self.s = 3
        self.consecutive_defections = 0
        self.force_next_coop = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif self.force_next_coop:
            self.force_next_coop = False
            self.consecutive_defections = 0
            return Action.C
        else:
            prev_round = state.round_number - 1
            prev_my_action = history.my_actions[prev_round]
            prev_opponent_actions = history.opponent_actions[prev_round, :]
            sum_prev = prev_my_action + np.sum(prev_opponent_actions)
            if sum_prev >= self.m:
                self.consecutive_defections = 0
                return Action.C
            else:
                self.consecutive_defections += 1
                if self.consecutive_defections >= self.s:
                    self.force_next_coop = True
                return Action.D

class Strategy_EXPLOITATIVE_350(BaseStrategy):
    """
    Exploitative strategy that balances individual gain with maintaining cooperation.
    Cooperates initially and then defects when safe, with punishment for dropping cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = int(game_description.k)
        self.buffer = 2
        self.punishment_rounds = 3
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        your_prev_action = int(history.my_actions[-1]) if history is not None else 0
        C_prev = your_prev_action + np.sum(history.opponent_actions[-1, :]) if history is not None else 0
        if your_prev_action == 0 and C_prev < self.m:
            self.punishment_remaining = self.punishment_rounds
        if self.punishment_remaining > 0:
            action = Action.C
            self.punishment_remaining -= 1
        elif C_prev >= self.m + self.buffer:
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_351(BaseStrategy):
    """
    A strategy for the N-Player Public Goods game based on exploiting others' cooperation tendencies.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.n_players // 2

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        round_number = state.round_number
        s = round_number
        n_opp = n_players - 1
        opponent_actions = history.opponent_actions
        expected_cooperators = 0
        for opponent in range(n_opp):
            opponent_actions_subset = opponent_actions[:s, opponent]
            n_coop = np.count_nonzero(opponent_actions_subset)
            rate = n_coop / s if s != 0 else 0.0
            if rate > 0.5:
                expected_cooperators += 1
        is_last_round = round_number == n_rounds - 1
        if is_last_round:
            adjustment = int(n_players / 10)
            adjusted_threshold = max(self.cooperation_threshold - adjustment, 0)
        else:
            adjusted_threshold = self.cooperation_threshold
        if expected_cooperators + 1 >= adjusted_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_352(BaseStrategy):
    """
    This strategy balances cooperation and defection based on past success of cooperation.
    It cooperates in the first round, defects in the last, and decides based on success rate otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prior_rounds_count = state.round_number
            total_success = 0
            for s in range(prior_rounds_count):
                my_action = history.my_actions[s]
                opponent_actions = history.opponent_actions[s, :]
                total_coop = my_action + np.sum(opponent_actions)
                if total_coop >= self.m:
                    total_success += 1
            if total_success > prior_rounds_count / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_353(BaseStrategy):
    """
    Exploitative Cooperation Based on Historical Rates.
    Cooperates initially and then uses others' cooperation rates to decide.
    Defects if the expected number of cooperators meets a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        k = game_description.k
        max_m = game_description.n_players - 1
        self.m = min(math.ceil(k), max_m)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            t = state.round_number
            other_players = self.game_description.n_players - 1
            sum_coops = np.zeros(other_players, dtype=np.int64)
            for j in range(other_players):
                coop = np.sum(history.opponent_actions[0:t, j])
                sum_coops[j] = coop
            sum_rates = np.sum(sum_coops) / t
            if sum_rates >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_354(BaseStrategy):
    """
    A strategy that starts with cooperation and switches to defection 
    when a threshold of previous round's cooperators is met to exploit.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_prev_action = history.my_actions[t_prev]
        opponents_prev_actions = history.opponent_actions[t_prev]
        sum_coop = my_prev_action + sum(opponents_prev_actions)
        if sum_coop >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_355(BaseStrategy):
    """
    A strategy that adapts based on the cooperation rates of other players, 
    using thresholds and probabilistic cooperation to maximize payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n = self.n_players
        r = self.n_rounds
        m = self.m
        if current_round == r - 1:
            return Action.D
        if current_round == 0:
            return Action.C
        if history is None:
            c_prev = 0
            sum_opponents = 0
        else:
            c_prev = np.sum(history.opponent_actions[-1, :])
            sum_opponents = np.sum(history.opponent_actions)
        num_previous_rounds = current_round
        if num_previous_rounds == 0:
            avg_c = 0.0
        else:
            avg_c = sum_opponents / ((n - 1) * num_previous_rounds)
        if c_prev >= m:
            return Action.C
        elif avg_c > m / n:
            p = avg_c * n / m
            p = max(0.0, min(p, 1.0))
            if random.random() < p:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_356(BaseStrategy):
    """
    An adaptive strategy that switches between Cooperate and Defect based on the effectiveness of the previous action.
    It starts with Cooperate and adjusts the next action by comparing the actual payoff from the last action with the alternative payoff if the opposite action was taken.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_my_action = history.my_actions[-1]
        last_opponents = history.opponent_actions[-1, :]
        sum_others = np.sum(last_opponents)
        if last_my_action:
            sum_total = sum_others + 1
            actual_payoff = self.game_description.k / self.game_description.n_players * sum_total
            alternative_payoff = 1 + self.game_description.k / self.game_description.n_players * sum_others
        else:
            sum_total = sum_others
            actual_payoff = 1 + self.game_description.k / self.game_description.n_players * sum_total
            alternative_payoff = self.game_description.k / self.game_description.n_players * (sum_others + 1)
        met_threshold = actual_payoff > alternative_payoff
        if last_my_action:
            return Action.C if met_threshold else Action.D
        else:
            return Action.D if met_threshold else Action.C

class Strategy_EXPLOITATIVE_357(BaseStrategy):
    """
    This strategy initially cooperates to encourage a cooperative environment. 
    In subsequent rounds, it defects only when the number of cooperators in the previous round is sufficient to maintain the reward threshold after defection.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_coop = history.my_actions[prev_round]
        opponents_coop = history.opponent_actions[prev_round, :].sum()
        x_prev = int(my_coop) + opponents_coop
        m = math.ceil(self.game_description.n_players / self.game_description.k)
        threshold = m + 1
        if x_prev >= threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_358(BaseStrategy):
    """
    An adaptive strategy for the N-player public goods game that starts with cooperation, reciprocates based on previous rounds' cooperation levels, and defects in the endgame to maximize payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2
        self.punishment_duration = 2
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_prev_action = history.my_actions[last_round]
        my_c = 1 if my_prev_action else 0
        opponent_prev_actions = history.opponent_actions[last_round]
        opponent_c = sum(opponent_prev_actions)
        total_coop = my_c + opponent_c
        rounds_remaining = self.n_rounds - state.round_number
        if rounds_remaining <= 2:
            return Action.D
        if total_coop >= self.m:
            self.punishment_remaining = 0
            return Action.C
        else:
            if self.punishment_remaining == 0:
                self.punishment_remaining = self.punishment_duration
            self.punishment_remaining -= 1
            return Action.D

class Strategy_EXPLOITATIVE_359(BaseStrategy):
    """
    Exploitative Strategy for the Collective Risk Dilemma in an N-Player Public Goods Game.
    
    This strategy begins with an initial exploration phase where it cooperates in the first few rounds.
    It then adapts based on the number of cooperators in the previous round, continuing to cooperate if a sufficient number of players cooperated. In the final round, it defects unless all other players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or state.round_number < 3:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            m_last_round = self.n_players
            prev_round = state.round_number - 1
            opp_actions_prev = history.opponent_actions[prev_round].sum()
            my_action_prev = history.my_actions[prev_round]
            total_prev = opp_actions_prev + (1 if my_action_prev else 0)
            if total_prev >= m_last_round:
                return Action.C
            else:
                return Action.D
        else:
            m = math.ceil(self.n_players / 2)
            prev_round = state.round_number - 1
            opp_actions_prev = history.opponent_actions[prev_round].sum()
            my_action_prev = history.my_actions[prev_round]
            total_prev = opp_actions_prev + (1 if my_action_prev else 0)
            if total_prev >= m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_360(BaseStrategy):
    """
    Collective Tit-for-Tat strategy for N-player public goods game.
    Cooperates in the first round. In subsequent rounds, cooperates if the number
    of previous cooperators meets a dynamically calculated threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        total_coop = my_prev_action + sum(opponents_prev_actions)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_361(BaseStrategy):
    """
    A strategy that adaptively balances cooperation and strategic defection.
    Cooperates initially, continues if enough players cooperated previously,
    otherwise defects for up to three rounds before testing cooperation again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            t_minus_1 = state.round_number - 1
            my_prev = history.my_actions[t_minus_1]
            my_contribution = 1 if my_prev else 0
            opponent_prev = history.opponent_actions[t_minus_1]
            opponent_contribution = np.sum(opponent_prev)
            sum_coop = my_contribution + opponent_contribution
            if sum_coop >= self.m:
                self.consecutive_defections = 0
                return Action.C
            elif self.consecutive_defections < 3:
                self.consecutive_defections += 1
                return Action.D
            else:
                self.consecutive_defections = 0
                return Action.C

class Strategy_EXPLOITATIVE_362(BaseStrategy):
    """
    Adaptive Cooperate-and-Punish with Periodic Forgiveness strategy.
    
    Cooperates initially, then punishes if cooperation threshold isn't met, while periodically forgiving.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number % 3 == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_c = history.my_actions[prev_round]
        their_actions_prev = history.opponent_actions[prev_round]
        sum_prev = int(my_c) + np.sum(their_actions_prev)
        return Action.C if sum_prev >= self.m else Action.D

class Strategy_EXPLOITATIVE_363(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation with strategic defection.
    It initially cooperates, adapts based on recent outcomes, punishes non-cooperation, and defects in final rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        k = self.game_description.k
        if round_number == 0:
            return Action.C
        if round_number >= n_rounds - 2:
            return Action.D
        last_round = round_number - 1
        if last_round >= 0:
            my_last_action = history.my_actions[last_round]
            if not my_last_action:
                my_contribution = 1 if history.my_actions[last_round] else 0
                opp_contributions = np.sum(history.opponent_actions[last_round, :])
                sum_cj_last = my_contribution + opp_contributions
                threshold = n_players / k
                if sum_cj_last < threshold:
                    return Action.C
        threshold = n_players / k
        count = 0
        for i in range(1, 4):
            round_num = round_number - i
            if round_num < 0:
                break
            my_action = history.my_actions[round_num]
            sum_cj = 1 if my_action else 0
            sum_cj += np.sum(history.opponent_actions[round_num, :])
            if sum_cj >= threshold:
                count += 1
        return Action.C if count >= 2 else Action.D

class Strategy_EXPLOITATIVE_364(BaseStrategy):
    """
    This strategy determines whether to cooperate or defect based on the average number of other cooperators in previous rounds.
    It uses a threshold-based approach to decide the action, aiming to maximize the individual's payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions
        prev_coops = np.sum(opponent_actions, axis=1)
        expected_st = np.mean(prev_coops)
        if expected_st >= self.m:
            return Action.D
        elif expected_st == self.m - 1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_365(BaseStrategy):
    """
    Cooperate in the first round. In subsequent rounds, defect if at least m players cooperated previously, 
    where m is the ceiling of the multiplication factor k; otherwise, cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        total_coops = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
        if total_coops >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_366(BaseStrategy):
    """
    Adaptive Exploitation Strategy for N-Player Public Goods Game.
    Balances cooperation and exploitation based on success thresholds.
    Uses punishment mechanism and endgame strategy.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.sum_threshold = math.ceil(game_description.k - 1e-09)
        self.consecutive_success = 0
        self.state = 'building'
        self.exploiting_round = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if history is None:
            return Action.C
        my_prev_act = history.my_actions[-1]
        opponent_prev_act = history.opponent_actions[-1, :]
        sum_c_prev = my_prev_act + np.sum(opponent_prev_act)
        if sum_c_prev < self.sum_threshold:
            self.consecutive_success = 0
            self.state = 'building'
            self.exploiting_round = 0
            return Action.C
        else:
            self.consecutive_success += 1
            if self.state == 'building':
                if self.consecutive_success >= 3:
                    self.state = 'exploiting'
                    self.exploiting_round = 1
            elif self.state == 'exploiting':
                self.exploiting_round += 1
            if self.state == 'building':
                action = Action.C
            else:
                prob = 0.2 + (self.exploiting_round - 1) * 0.1
                prob = min(prob, 0.8)
                action = Action.D if random.random() < prob else Action.C
            remaining_rounds = self.game_description.n_rounds - state.round_number - 1
            if remaining_rounds <= 2:
                action = Action.C
            return action

class Strategy_EXPLOITATIVE_368(BaseStrategy):
    """
    A strategy that coaches cooperation initially, continues if enough players cooperated previously, 
    and defects in the last round. The threshold m is set to 1, meaning cooperation continues 
    if at least one other player cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opp_prev = sum(history.opponent_actions[prev_round])
            total_coop = my_prev + opp_prev
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_370(BaseStrategy):
    """
    A strategy for the N-player public goods game that:
    1. Cooperates in the first round to establish trust.
    2. Punishes by defecting if cooperation falls below a threshold (half of players).
    3. Defects in the final round to maximize individual payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2
        self.is_punishing = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        prev_cooperators = history.my_actions[prev_round] + sum(history.opponent_actions[prev_round, :])
        if self.is_punishing:
            if prev_cooperators >= self.m:
                self.is_punishing = False
                return Action.C
            else:
                return Action.D
        elif prev_cooperators < self.m:
            self.is_punishing = True
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_371(BaseStrategy):
    """
    Exploitative Strategy for Public Goods Game. Cooperates initially, then defects 
    if cooperation is sufficiently high, adapting if cooperation drops.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.prev_defection = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_defection = False
            return Action.C
        t = state.round_number
        if t == self.game_description.n_rounds - 1:
            sum_coop = 0
            for r in range(t):
                my_action = history.my_actions[r]
                opponent_actions = history.opponent_actions[r, :]
                total = my_action + np.sum(opponent_actions)
                if total >= self.m:
                    sum_coop += 1
            average = sum_coop / t
            if average >= 0.8:
                return Action.D
            else:
                return Action.C
        else:
            sum_coop = 0
            for r in range(t):
                my_action = history.my_actions[r]
                opponent_actions = history.opponent_actions[r, :]
                total = my_action + np.sum(opponent_actions)
                if total >= self.m:
                    sum_coop += 1
            if self.prev_defection:
                my_last = history.my_actions[t - 1]
                opponent_last = np.sum(history.opponent_actions[t - 1, :])
                total_last = my_last + opponent_last
                if total_last >= self.m:
                    self.prev_defection = True
                    return Action.D
                else:
                    self.prev_defection = False
                    return Action.C
            else:
                average = sum_coop / t
                if average >= 0.8:
                    self.prev_defection = True
                    return Action.D
                else:
                    self.prev_defection = False
                    return Action.C

class Strategy_EXPLOITATIVE_372(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances exploitation and cooperation.
    
    The strategy cooperates in the first round, defects in rounds where sufficient cooperation was observed in the previous round,
    and always defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        s = state.round_number
        total_rounds = self.game_description.n_rounds
        if s == 0:
            return Action.C
        elif s == total_rounds - 1:
            return Action.D
        else:
            prev_round = s - 1
            my_prev_action = history.my_actions[prev_round]
            my_c = 1 if my_prev_action else 0
            opp_prev_actions = history.opponent_actions[prev_round, :]
            opp_c = sum(opp_prev_actions)
            total_c_prev = my_c + opp_c
            m = self.game_description.n_players // 2
            if total_c_prev >= m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_373(BaseStrategy):
    """
    A strategy that estimates cooperation rates from historical behavior and decides based on a threshold.
    Cooperates initially, then uses historical data to decide whether to defect or not.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players - 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        round_count = state.round_number
        opponent_actions = history.opponent_actions
        n_opponents = opponent_actions.shape[1]
        expected_coop = 0.0
        for j in range(n_opponents):
            coop_count = np.sum(opponent_actions[:, j])
            coop_rate = coop_count / round_count
            expected_coop += coop_rate
        if expected_coop >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_374(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and exploitation based on previous rounds' outcomes.
    Cooperates initially, defects if enough players cooperated previously, and always defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            previous_round = state.round_number - 1
            my_prev_action = history.my_actions[previous_round]
            others_prev_actions_sum = history.opponent_actions[previous_round].sum()
            cooperation_count = my_prev_action + others_prev_actions_sum
            if cooperation_count >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_375(BaseStrategy):
    """
    Implement a strategy that starts with cooperation and adjusts based on the number of cooperators in the previous round.
    The strategy uses a threshold calculated as ceil(n/k) to decide whether to continue cooperating.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.threshold = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        sum_opponent_prev = sum(history.opponent_actions[-1, :])
        my_last_action = history.my_actions[-1]
        prev_coop = sum_opponent_prev + (1 if my_last_action else 0)
        if prev_coop >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_376(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Collective Risk Dilemma.
    Cooperates in the first round, defects in the last, and adaptively switches
    based on the number of cooperators in previous rounds to balance exploitation
    and cooperation incentives.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold = self.n_players // 2 + 1
        self.last_punished = False
        self.last_cooperators = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif self.last_punished:
            self.last_punished = False
            return Action.C
        else:
            last_round = state.round_number - 1
            my_action = history.my_actions[last_round]
            opponents_actions = history.opponent_actions[last_round]
            my_coop = 1 if my_action else 0
            opp_coop = np.sum(opponents_actions)
            total_coop = my_coop + opp_coop
            self.last_cooperators = total_coop
            if total_coop >= self.threshold:
                return Action.C
            else:
                self.last_punished = True
                return Action.D

class Strategy_EXPLOITATIVE_377(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and defection based on recent outcomes.
    It starts with cooperation, evaluates the necessity of past cooperations, and adjusts actions dynamically.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_action_last = history.my_actions[previous_round]
        if my_action_last == Action.D:
            opponent_actions_last = history.opponent_actions[previous_round]
            s_t = int(my_action_last) + np.sum(opponent_actions_last)
            if s_t < self.m:
                return Action.C
        current_round = state.round_number
        past_rounds = current_round - 1
        start_round = max(0, past_rounds - 4)
        end_round = past_rounds + 1
        rounds_to_consider = range(start_round, end_round)
        count_necessary = 0
        for r in rounds_to_consider:
            action_r = history.my_actions[r]
            if action_r:
                opponent_actions_r = history.opponent_actions[r]
                s_r = int(action_r) + np.sum(opponent_actions_r)
                if s_r - 1 < self.m:
                    count_necessary += 1
        num_rounds = len(rounds_to_consider)
        rate = count_necessary / num_rounds if num_rounds > 0 else 0
        if rate < 0.3:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_378(BaseStrategy):
    """
    A strategy that starts by cooperating and then decides based on the success rate of previous rounds.
    It cooperates if at least half of previous rounds met the threshold of m cooperators (m = n_players // 2).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        success_count = 0
        for i in range(t):
            my_action = history.my_actions[i]
            opponent_actions = history.opponent_actions[i]
            total = my_action + opponent_actions.sum()
            if total >= self.m:
                success_count += 1
        ratio = success_count / t if t != 0 else 0.0
        if ratio >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_379(BaseStrategy):
    """
    Cooperates initially and then defects if more than half of previous rounds met the cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        count_coop = 0
        for round in range(state.round_number):
            my_action = history.my_actions[round]
            opponent_actions = history.opponent_actions[round]
            n_coop_opponents = np.sum(opponent_actions)
            total_coop = my_action + n_coop_opponents
            if total_coop >= self.m:
                count_coop += 1
        total_rounds = state.round_number
        if count_coop > total_rounds / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_380(BaseStrategy):
    """
    A strategy that initially Cooperates and then Cooperates again only if 
    a sufficient number of players Cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_opponent_actions = history.opponent_actions[-1]
        c_opponents = np.sum(last_opponent_actions)
        ai_last = history.my_actions[-1]
        c_last = c_opponents + ai_last
        m = self.game_description.n_players
        threshold = m - 1
        if c_last >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_381(BaseStrategy):
    """
    A History-Based Cooperation strategy with a threshold. Cooperates if the number of cooperators
    in the previous round meets a calculated threshold, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            previous_round = state.round_number - 1
            my_prev_action = history.my_actions[previous_round]
            opponent_actions = history.opponent_actions[previous_round, :]
            count_C = my_prev_action + np.sum(opponent_actions)
            if count_C >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_382(BaseStrategy):
    """
    Adaptive Exploitation Strategy based on cooperation history to maximize personal gain while encouraging group success.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_my_action = history.my_actions[state.round_number - 1]
            prev_opponents = history.opponent_actions[state.round_number - 1]
            total_coop = prev_my_action + np.sum(prev_opponents)
            if total_coop >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_383(BaseStrategy):
    """
    A strategy for the Public Goods Game which balances individual gain with collective benefit 
    by cooperating when the previous round's cooperation is below a threshold and defecting 
    otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.m = self.n // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponents_prev = history.opponent_actions[prev_round, :]
        sum_c = my_prev + opponents_prev.sum()
        if sum_c >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_384(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma.
    Cooperates in the first round, defects in the last.
    In other rounds, defects if the average number of cooperators in previous rounds meets or exceeds n/k.
    Otherwise, continues to cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        sum_coops = 0.0
        for t in range(state.round_number):
            my_coop = 1.0 if history.my_actions[t] else 0.0
            opp_coops = np.sum(history.opponent_actions[t, :])
            sum_coops += my_coop + opp_coops
        average_coops = sum_coops / state.round_number
        m = self.n_players / self.k
        if average_coops >= m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_385(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game. The strategy Cooperates 
    if the expected number of other Cooperators is below a threshold (m), otherwise Defects.
    The threshold m is calculated as the ceiling of (n / k), ensuring a balance between 
    cooperation and selfish incentives.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)
        self.always_coop = self.n - 1 < self.m

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.always_coop:
            return Action.C
        t = state.round_number - 1
        opponent_actions = history.opponent_actions
        n_other = opponent_actions.shape[1]
        sum_coop = 0.0
        for j in range(n_other):
            actions_j = opponent_actions[:t + 1, j]
            count = np.sum(actions_j)
            rate = count / (t + 1)
            sum_coop += rate
        if sum_coop >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_386(BaseStrategy):
    """
    Implementation of a strategy for the N-Player Public Goods Game.
    Cooperates in the first round, then defects if the sum of others' cooperation rates exceeds k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        sum_others = 0.0
        for j in range(self.n_players - 1):
            cooperation_history = history.opponent_actions[:t, j]
            count_C = np.sum(cooperation_history)
            rate_j = count_C / t
            sum_others += rate_j
        if sum_others >= self.k:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_387(BaseStrategy):
    """
    Adaptive strategy balancing cooperation and defection based on past outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.S = 0
        self.F = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == 1:
            return Action.D
        if history is not None and history.my_actions is not None and (history.my_actions[-1] == 0):
            prev_round = state.round_number - 1
            opponent_actions = history.opponent_actions[prev_round]
            sum_coop_others = np.sum(opponent_actions)
            if sum_coop_others >= 1:
                self.S += 1
            else:
                self.F += 1
        if self.S > self.F:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_388(BaseStrategy):
    """
    A strategy that always cooperates in every round, regardless of opponents' actions.
    This strategy is based on the conclusion that consistently cooperating yields higher
    overall payoffs compared to other potential strategies.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        return Action.C

class Strategy_EXPLOITATIVE_390(BaseStrategy):
    """
    A strategy that initially cooperates and then alternates based on the number of previous cooperators.
    Cooperates if enough players cooperated in the previous round; otherwise, defects and reverts to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.force_coop = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.force_coop:
            self.force_coop = False
            return Action.C
        prev_my_action = history.my_actions[-1].astype(float).sum()
        prev_others_actions = history.opponent_actions[-1, :].sum()
        total_c = prev_my_action + prev_others_actions
        m = self.game_description.k
        if total_c >= m:
            return Action.C
        else:
            self.force_coop = True
            return Action.D

class Strategy_EXPLOITATIVE_391(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            previous_payoff = history.my_payoffs[state.round_number - 1]
            previous_action = history.my_actions[state.round_number - 1]
            if previous_payoff > 1.0:
                return Action.C if previous_action else Action.D
            else:
                return Action.D if previous_action else Action.C

class Strategy_EXPLOITATIVE_392(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that cooperates in the first round, then defects if enough others cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.prev_round_coop = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        others_prev_coop = sum(history.opponent_actions[-1, :])
        if others_prev_coop >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_393(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and defection based on previous outcomes.
    It starts with cooperation, continues if a threshold is met, and periodically tests cooperation after defection.
    The last round uses historical cooperation levels to decide the action.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.consecutive_no_coop_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            count = 0
            for t in range(state.round_number):
                my_act = history.my_actions[t]
                opp_act = history.opponent_actions[t, :]
                total_c = my_act + np.sum(opp_act)
                if total_c >= self.m:
                    count += 1
            total_rounds = state.round_number
            proportion = count / total_rounds if total_rounds > 0 else 0
            if proportion >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            prev_my_act = history.my_actions[-1]
            prev_opp_act = history.opponent_actions[-1]
            total_c_prev = prev_my_act + np.sum(prev_opp_act)
            if total_c_prev >= self.m:
                self.consecutive_no_coop_rounds = 0
                return Action.C
            else:
                self.consecutive_no_coop_rounds += 1
                if self.consecutive_no_coop_rounds >= 3:
                    self.consecutive_no_coop_rounds = 0
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_394(BaseStrategy):
    """A strategy based on previous round outcomes to balance cooperation and defection, maximizing individual payoff while contributing to group success when necessary."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponents_prev = history.opponent_actions[prev_round]
        total_prev_coops = my_prev + sum(opponents_prev)
        if my_prev:
            if total_prev_coops - 1 >= self.m:
                return Action.D
            else:
                return Action.C
        elif total_prev_coops >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_395(BaseStrategy):
    """
    A threshold-based strategy for the N-Player Public Goods Game.
    Cooperates in the first round, then decides based on the number of
    cooperators in the previous round relative to a calculated threshold (m).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_num = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_num]
        opponent_prev_actions = history.opponent_actions[prev_round_num, ...]
        opponent_coop = sum(opponent_prev_actions).item()
        prev_C = (1 if my_prev_action else 0) + opponent_coop
        if my_prev_action:
            effective_prev_C = prev_C - 1
        else:
            effective_prev_C = prev_C
        if effective_prev_C >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_396(BaseStrategy):
    """
    Responsive Cooperative Punisher (RCP) strategy for N-Player Public Goods Game.
    Cooperates initially, enforces a cooperation threshold, and defects in endgame.
    Forgives after two consecutive defections to test cooperation resumption.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 3:
            return Action.D
        my_prev_action = history.my_actions[-1]
        opponent_prev_actions = history.opponent_actions[-1, :]
        prev_coop = int(my_prev_action) + int(np.sum(opponent_prev_actions))
        if prev_coop >= self.m:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections >= 2:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            return Action.D

class Strategy_EXPLOITATIVE_397(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma in N-Player Public Goods Game.
    
    The strategy initializes by Cooperating in the first round.
    Subsequent rounds before the last adapt based on the number of Cooperators in the previous round.
    The last round's decision is influenced by the average number of Cooperators across all previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)
        if self.m < 1:
            self.m = 1

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        if current_round < n_rounds - 1:
            prior_round = current_round - 1
            sum_opponent = np.sum(history.opponent_actions[prior_round])
            my_action_prev = history.my_actions[prior_round]
            total_c = sum_opponent + (1 if my_action_prev else 0)
            if total_c >= self.m:
                return Action.C
            else:
                return Action.D
        else:
            counts = []
            for t in range(current_round):
                sum_opponent = np.sum(history.opponent_actions[t])
                my_action = history.my_actions[t]
                total_c = sum_opponent + (1 if my_action else 0)
                counts.append(total_c)
            if not counts:
                return Action.C
            average_c = np.mean(counts)
            if average_c >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_398(BaseStrategy):
    """
    Dynamic strategy balancing cooperation and defection to maximize individual payoff.
    Cooperates initially, defects when beneficial based on previous cooperation levels,
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponents_prev = history.opponent_actions[prev_round]
            count = sum(opponents_prev) + (1 if my_prev else 0)
            if count >= self.game_description.k:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_399(BaseStrategy):
    """
    An adaptive strategy for N-Player Public Goods Game that starts with cooperation, 
    adapts based on recent success, and defects in endgame rounds to protect against exploitation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)
        self.initial_rounds = math.floor(self.r * 0.1)
        self.endgame_threshold = math.floor(self.r * 0.8)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.n
        r = self.r
        m = self.m
        initial_rounds = self.initial_rounds
        endgame_threshold = self.endgame_threshold
        if history is not None and len(history.my_actions) >= 1:
            last_t = len(history.my_actions) - 1
            opp_actions_last = history.opponent_actions[last_t]
            my_action_last = history.my_actions[last_t]
            total_coop_last = sum(opp_actions_last) + (1 if my_action_last else 0)
            if total_coop_last >= m:
                return Action.C
        if state.round_number < initial_rounds:
            return Action.C
        elif state.round_number >= endgame_threshold:
            return Action.D
        else:
            if history is None or len(history.my_actions) == 0:
                return Action.C
            recent_start = max(0, len(history.my_actions) - 5)
            recent_count = len(history.my_actions) - recent_start
            success_count = 0
            for t in range(recent_start, len(history.my_actions)):
                opp_actions = history.opponent_actions[t]
                my_action = history.my_actions[t]
                total_coop = sum(opp_actions) + (1 if my_action else 0)
                if total_coop >= m:
                    success_count += 1
            success_rate = success_count / recent_count if recent_count > 0 else 0.0
            if success_rate > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_400(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness strategy.

    This strategy starts by Cooperating to encourage initial cooperation.
    In subsequent rounds, it Cooperates if the previous round had a sufficient number of Cooperators.
    If not, it Defects for up to 3 rounds, then switches back to Cooperate.
    The threshold for sufficient cooperation is half the number of players.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.consecutive_defect_count = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_last_action = history.my_actions[prev_round]
        sum_me = 1 if my_last_action else 0
        opp_last_actions = history.opponent_actions[prev_round, :]
        sum_opp = np.sum(opp_last_actions)
        t_prev = sum_me + sum_opp
        if t_prev >= self.m:
            self.consecutive_defect_count = 0
            return Action.C
        elif self.consecutive_defect_count < 3:
            self.consecutive_defect_count += 1
            return Action.D
        else:
            self.consecutive_defect_count = 0
            return Action.C

class Strategy_EXPLOITATIVE_401(BaseStrategy):
    """
    Adaptive strategy for the N-Player Public Goods Game. Cooperates initially and continues if enough players cooperated in the previous round, defects otherwise. Defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opp_prev = history.opponent_actions[prev_round, :]
        total_prev_coop = my_prev + np.sum(opp_prev)
        if total_prev_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_402(BaseStrategy):
    """
    A strategy that starts with cooperation, then cooperates if enough players did so previously, 
    except in the last round where it always defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        if round_number == 0:
            return Action.C
        if round_number == n_rounds - 1:
            return Action.D
        previous_round = round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_actions_prev_round = history.opponent_actions[previous_round, :]
        opponent_coop_prev = sum(opponent_actions_prev_round)
        total_coop_prev = opponent_coop_prev + (1 if my_prev_action else 0)
        if total_coop_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_403(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game. It cooperates initially and then adapts based on past observations.
    Cooperates if less than half of the considered rounds meet the threshold without its contribution, otherwise defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        c_safe = 0
        total_rounds_considered = 0
        for t in range(state.round_number):
            if history.my_actions[t]:
                s_without_me = sum(history.opponent_actions[t])
                if s_without_me >= self.m:
                    c_safe += 1
                total_rounds_considered += 1
        if total_rounds_considered == 0:
            return Action.C
        proportion = c_safe / total_rounds_considered
        if proportion > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_404(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that encourages cooperation by mirroring past behavior
    and adjusting for endgame scenarios.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        n_rounds = self.n_rounds
        is_penultimate = current_round == n_rounds - 2
        is_last = current_round == n_rounds - 1
        if is_penultimate or is_last:
            count_cooperated_rounds = 0
            for r in range(current_round):
                opponent_actions_r = history.opponent_actions[r, :] if history is not None else np.zeros(self.n_players - 1, dtype=bool)
                sum_op = np.sum(opponent_actions_r)
                my_action_r = history.my_actions[r] if history is not None else False
                total_c = sum_op + my_action_r
                if total_c >= self.m:
                    count_cooperated_rounds += 1
            total_rounds_considered = current_round
            if count_cooperated_rounds >= total_rounds_considered * 0.5:
                return Action.C
            else:
                return Action.D
        else:
            last_round = current_round - 1
            opponent_actions_last = history.opponent_actions[last_round] if history else np.zeros(self.n_players - 1, dtype=bool)
            sum_op = np.sum(opponent_actions_last)
            my_action_last = history.my_actions[last_round] if history else False
            total_coop_last = sum_op + my_action_last
            if total_coop_last >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_405(BaseStrategy):
    """
    A strategy that cooperates initially and then defects if the number of previous cooperators meets or exceeds a threshold.
    The threshold m is calculated as (n_players * k) / (k + 1), where n_players is the number of players and k is the multiplication factor.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = n * k / (k + 1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            previous_round = state.round_number - 1
            opponent_actions = history.opponent_actions[previous_round]
            own_prev_action = history.my_actions[previous_round]
            sum_coop_prev = np.sum(opponent_actions) + own_prev_action
            if sum_coop_prev >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_406(BaseStrategy):
    """
    A strategy that begins by cooperating, adapts based on the number of previous cooperators, 
    and defects in the final round to maximize individual payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_action = history.my_actions[prev_round]
            opponent_actions = history.opponent_actions[prev_round, :]
            opponent_coop = np.sum(opponent_actions)
            my_coop = 1 if my_action else 0
            total_coop = opponent_coop + my_coop
            threshold = self.game_description.n_players // 2
            if total_coop >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_408(BaseStrategy):
    """
    Adaptive Cooperation Based on Previous Round's Outcome.
    
    This strategy starts by cooperating in the first round. In subsequent rounds, it counts the number of cooperators in the previous round. If this number meets or exceeds a threshold (half the number of players), the strategy cooperates; otherwise, it defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_coop = history.my_actions[prev_round]
            sum_opponents = sum(history.opponent_actions[prev_round, :])
            total_coop = sum_opponents + (1 if my_coop else 0)
            if total_coop >= self.threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_409(BaseStrategy):
    """
    A strategy that starts with cooperation and then responds based on the number of cooperators in the previous round.
    It uses a threshold (m) calculated as the ceiling of n/k to determine whether to continue cooperating or switch.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        opponent_actions = history.opponent_actions[previous_round, :]
        opp_coop = np.sum(opponent_actions)
        my_prev_action = history.my_actions[previous_round]
        coop_count = opp_coop + (1 if my_prev_action else 0)
        if coop_count >= self.m:
            return Action.C
        elif my_prev_action:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_410(BaseStrategy):
    """
    Adaptive Cooperation with Late-Game Defection Strategy.

    Cooperates in the initial phase (first 20% of rounds), adapts based on cooperation levels in the mid-game,
    and defects in the late phase (last 10% of rounds).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        r = self.game_description.n_rounds
        initial_cutoff = math.floor(0.2 * r)
        late_cutoff_start = max(initial_cutoff, r - math.ceil(0.1 * r))
        if current_round < initial_cutoff:
            return Action.C
        if current_round >= late_cutoff_start:
            return Action.D
        n_players = self.game_description.n_players
        threshold = 0.5 * n_players
        coops = 0
        for t in range(current_round):
            my_c = history.my_actions[t]
            opponents_c = sum(history.opponent_actions[t, :])
            total_c = my_c + opponents_c
            if total_c >= threshold:
                coops += 1
        total_rounds = current_round
        if total_rounds == 0:
            percentage = 0.0
        else:
            percentage = coops / total_rounds
        if percentage >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_411(BaseStrategy):
    """
    A strategy for the N-player public goods game that balances cooperation and defection.
    Cooperates in the first round, defects in the last round, and otherwise defects if 
    the number of cooperating opponents in the previous round meets a calculated threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        others_prev_actions = history.opponent_actions[prev_round]
        others_C_count = sum(others_prev_actions)
        if others_C_count >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_412(BaseStrategy):
    """
    A strategy that adapts based on the historical level of cooperation.
    Cooperates initially, then decides to continue cooperating or defect
    based on the fraction of past rounds meeting a cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.threshold = 0.5

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        successful_rounds = 0
        for prev_round in range(state.round_number):
            my_action = history.my_actions[prev_round]
            opponents_actions = history.opponent_actions[prev_round, :]
            total_coop = (1 if my_action else 0) + sum(opponents_actions)
            if total_coop >= self.m:
                successful_rounds += 1
        success_rate = successful_rounds / state.round_number
        if success_rate >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_413(BaseStrategy):
    """
    A strategy that starts by cooperating and then defects when it's safe, based on historical cooperation levels.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_last = history.my_actions[prev_round]
        oppo_last = history.opponent_actions[prev_round]
        c_prev = my_last + oppo_last.sum()
        if c_prev >= self.m + 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_414(BaseStrategy):
    """
    A strategy combining initial cooperation with punishment for defection below a threshold.
    Cooperates if the number of previous round cooperators meets a minimum threshold;
    otherwise, defects for a set number of rounds before reverting to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.p_defect = 2
        self.state = 'coop'
        self.defect_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        opponents_coop = sum(history.opponent_actions[prev_round, :])
        my_coop = history.my_actions[prev_round]
        total_coop = opponents_coop + (1 if my_coop else 0)
        if self.state == 'coop':
            if total_coop >= self.m:
                action = Action.C
            else:
                self.state = 'defect'
                self.defect_counter = 1
                action = Action.D
        else:
            action = Action.D
            self.defect_counter += 1
            if self.defect_counter >= self.p_defect:
                self.state = 'coop'
                self.defect_counter = 0
        return action

class Strategy_EXPLOITATIVE_415(BaseStrategy):
    """
    A strategy that adapts cooperation based on the number of cooperators in the previous round.
    Cooperates if the number of cooperators in the previous round meets or exceeds a threshold based on k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        my_contribution = 1 if my_prev_action else 0
        opponents_contribution = np.count_nonzero(opponents_prev_actions)
        total_cooperators = my_contribution + opponents_contribution
        if total_cooperators >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_416(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that begins with cooperation, 
    defects in the final round, and adapts based on the number of previous 
    cooperators. The player cooperates in a round if at least m players, where 
    m is calculated as the ceiling of (n_players / k), cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        prev_round = current_round - 1
        my_prev = history.my_actions[prev_round]
        opp_prev = history.opponent_actions[prev_round]
        prev_coop = 0
        if my_prev:
            prev_coop += 1
        prev_coop += opp_prev.sum()
        if prev_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_417(BaseStrategy):
    """Adaptive Exploitation Strategy based on previous cooperation levels."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            previous_round = state.round_number - 1
            my_prev_action = history.my_actions[previous_round]
            opponents_prev_actions = history.opponent_actions[previous_round, :]
            cooperators = sum(opponents_prev_actions) + (1 if my_prev_action else 0)
            if cooperators >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_418(BaseStrategy):
    """
    This strategy begins by cooperating to encourage others, then adapts based on the average cooperation rate.
    In the endgame (last 5 rounds), it defects to maximize personal gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.n_rounds - 5:
            return Action.D
        total_coop = 0
        current_round = state.round_number
        for t in range(current_round):
            my_coop = history.my_actions[t]
            coop = 1 if my_coop else 0
            opp_coop = history.opponent_actions[t].sum()
            total_coop += coop + opp_coop
        avg_coop_rate = total_coop / (self.n_players * current_round)
        threshold = 0.5
        if avg_coop_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_419(BaseStrategy):
    """
    Adaptive Cooperation with Periodic Testing (ACPT) strategy.
    Cooperates initially, continues if enough players cooperated previously, 
    and tests cooperation after three consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_prev_action = history.my_actions[t_prev]
        opp_prev_actions = history.opponent_actions[t_prev, :]
        sum_prev = my_prev_action + opp_prev_actions.sum()
        if sum_prev >= self.m:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections >= 3:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            return Action.D

class Strategy_EXPLOITATIVE_420(BaseStrategy):
    """
    A reactive strategy encouraging sustained cooperation based on previous rounds' cooperation levels.
    Cooperate in the first round. In subsequent rounds, cooperate if at least half of the players cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        sum_opponents = np.sum(history.opponent_actions[-1])
        sum_me = history.my_actions[-1]
        total_cooperators = sum_opponents + sum_me
        threshold = self.game_description.n_players // 2
        if total_cooperators >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_423(BaseStrategy):
    """
    An adaptive strategy that decides whether to cooperate or defect based on the estimated probability of others cooperating.
    Starts by cooperating, then calculates expected payoffs for each action using binomial probabilities.
    Chooses the action with the higher expected payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        k = self.game_description.k
        sum_other_actions = history.opponent_actions.sum()
        t = state.round_number
        p = sum_other_actions / (t * (n - 1))
        EC = 0.0
        ED = 0.0
        for m in range(n):
            prob = math.comb(n - 1, m) * p ** m * (1 - p) ** (n - 1 - m)
            payoff_c = k * (m + 1) / n
            EC += prob * payoff_c
            payoff_d = 1 + k * m / n
            ED += prob * payoff_d
        return Action.C if EC > ED else Action.D

class Strategy_EXPLOITATIVE_424(BaseStrategy):
    """
    Adaptive Exploitation with Final Round Defection (AEFRD) strategy.

    This strategy starts by cooperating to encourage others, then adapts based
    on the historical average cooperation rate, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.k / self.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        total_coops = 0
        for round_num in range(current_round):
            my_action = history.my_actions[round_num]
            opponent_actions = history.opponent_actions[round_num, :]
            my_coop = 1 if my_action else 0
            others_coop = np.sum(opponent_actions)
            total_coops += my_coop + others_coop
        t = current_round
        avg_coop = total_coops / t
        if avg_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_425(BaseStrategy):
    """
    Strategy for Collective Risk Dilemma to maximize individual payoff by 
    adapting actions based on observed cooperation trends.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.m = max(self.m, 1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        r = self.game_description.n_rounds
        if t == 0:
            return Action.C
        elif t == r - 1:
            return Action.D
        end = t - 1
        start = max(0, end - 2)
        window = range(start, end + 1)
        total_coop = 0
        for round_number in window:
            if round_number >= len(history.my_actions):
                continue
            my_action = history.my_actions[round_number]
            opponent_actions = history.opponent_actions[round_number, :]
            coop = 1 if my_action else 0
            coop += np.sum(opponent_actions)
            total_coop += coop
        avg_coop = total_coop / len(window) if window else 0
        if avg_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_426(BaseStrategy):
    """
    A strategy that balances individual payoff maximization with collective success in public goods games.
    It uses historical cooperation rates and adaptive mechanisms to decide actions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k / (game_description.k + 1) if game_description.k != 0 else 0
        self.delta = 0.5
        self.coop_phase = False
        self.coop_rounds_left = 0
        self.z = 5
        self.w = 3
        self.f = 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.coop_phase and self.coop_rounds_left > 0:
            self.coop_rounds_left -= 1
            return Action.C
        n_prev_rounds = state.round_number
        sum_c_prev = np.sum(history.opponent_actions[:n_prev_rounds, :])
        sum_c_prev /= n_prev_rounds * (self.game_description.n_players - 1)
        if sum_c_prev >= self.m - self.delta:
            action = Action.D
        else:
            action = Action.C
        recent_rounds = min(self.z, state.round_number)
        start_round = max(state.round_number - recent_rounds, 0)
        recent_actions = history.opponent_actions[start_round:state.round_number, :]
        count = 0
        for r in range(recent_actions.shape[0]):
            sum_c_r = np.sum(recent_actions[r, :]) / (self.game_description.n_players - 1)
            if sum_c_r >= self.m - self.delta:
                count += 1
        if count < self.w:
            action = Action.C
            self.coop_phase = True
            self.coop_rounds_left = self.f
        return action

class Strategy_EXPLOITATIVE_427(BaseStrategy):
    """
    An exploitative strategy for the N-Player Public Goods Game.
    Cooperates in the first round, defects in the last, and decides based on others' cooperation in previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = math.ceil((self.n_players - 1) * (self.k / self.n_players))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        sum_others_prev = sum(history.opponent_actions[prev_round, :])
        if sum_others_prev >= self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_428(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game.
    It starts with cooperation, punishes lack of cooperation with defection,
    and reevaluates cooperation based on others' contributions.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        if last_round >= len(history.my_actions):
            return Action.C
        my_last_action = history.my_actions[last_round]
        sum_opponent = np.sum(history.opponent_actions[last_round, :])
        if my_last_action:
            total_coop = sum_opponent + 1
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D
        elif sum_opponent >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_429(BaseStrategy):
    """
    This strategy uses a threshold-based approach to decide between Cooperate (C) and Defect (D) in an N-player public goods game.
    It cooperates in the first round and then checks if exactly m-1 other players cooperated in the previous round to decide action.
    The threshold m is calculated based on the game parameters to determine when mutual cooperation becomes beneficial.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.k = game_description.k
        threshold = self.n_players / self.k
        if threshold.is_integer():
            self.m = int(threshold) + 1
        else:
            self.m = math.ceil(threshold)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            last_round_opponents = history.opponent_actions[-1]
            other_coop = sum(last_round_opponents)
            if other_coop == self.m - 1:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_430(BaseStrategy):
    """
    A strategy that starts by cooperating, then adapts based on the number of cooperators in the previous round.
    Cooperates in rounds following a round with at least k cooperators, defects otherwise.
    Always defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_action_prev = history.my_actions[prev_round]
        opponents_actions_prev = history.opponent_actions[prev_round]
        sum_prev = int(my_action_prev) + np.count_nonzero(opponents_actions_prev)
        if sum_prev >= self.game_description.k:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_431(BaseStrategy):
    """
    A strategy that cooperates if in more than half of previous rounds, at least m players cooperated.
    m is calculated as (n_players // 2) + 1.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2 + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        count = 0
        total_prev = state.round_number
        for r in range(total_prev):
            my_action = history.my_actions[r]
            opp_actions = history.opponent_actions[r, :]
            num_coops = int(my_action) + opp_actions.sum()
            if num_coops >= self.m:
                count += 1
        if count > total_prev / 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_432(BaseStrategy):
    """
    Adaptive cooperation strategy for the Public Goods Game.
    Cooperates initially, learns from past successes, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.success_count = 0
        self.coop_count = 0
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.coop_count += 1
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            if history is not None:
                prev_t = state.round_number - 1
                if len(history.my_actions) > prev_t:
                    prev_action = history.my_actions[prev_t]
                    if prev_action:
                        opponent_actions_prev = history.opponent_actions[prev_t]
                        total_C = sum(opponent_actions_prev) + 1
                        if total_C >= self.m:
                            self.success_count += 1
                        self.coop_count += 1
            if self.coop_count == 0:
                success_rate = 0.0
            else:
                success_rate = self.success_count / self.coop_count
            if success_rate >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_433(BaseStrategy):
    """
    Strategy to maximize payoff by initially cooperating, defecting in the last round,
    and using average cooperation rate of others to decide in between.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        total_coop = 0
        for prev_round in range(state.round_number):
            my_action = history.my_actions[prev_round]
            opponent_actions = history.opponent_actions[prev_round]
            opponent_coop = np.sum(opponent_actions)
            total_coop += my_action + opponent_coop
        avg_coop_per_player = total_coop / (self.n_players * state.round_number)
        if (self.n_players - 1) * avg_coop_per_player >= self.k:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_434(BaseStrategy):
    """
    Implements an Adaptive Threshold Reciprocity with Forgiveness strategy.
    Cooperates initially, then reciprocates based on the number of cooperators
    in the previous round, defecting temporarily if a threshold isn't met.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)
        self.punishment_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        sum_prev_coops = sum(history.opponent_actions[-1, :]) + (1 if history.my_actions[-1] else 0)
        if sum_prev_coops >= self.m:
            return Action.C
        else:
            self.punishment_remaining = 2
            return Action.D

class Strategy_EXPLOITATIVE_435(BaseStrategy):
    """
    A strategy that adapts its cooperation based on the number of cooperators in previous rounds.
    Cooperates initially, continues if sufficient players cooperated last round, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        elif current_round == total_rounds - 1:
            return Action.D
        else:
            previous_round = current_round - 1
            opponent_actions_last = history.opponent_actions[previous_round, :]
            sum_opponent_coop = np.sum(opponent_actions_last)
            my_coop_last = history.my_actions[previous_round]
            total_coop_last = sum_opponent_coop + (1 if my_coop_last else 0)
            if total_coop_last >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_436(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that adapts based on previous rounds,
    exploiting high cooperation rates in others, and shifting towards defecting in endgame.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.opponent_coop_rates = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.opponent_coop_rates is None and history is not None:
            self.opponent_coop_rates = [0.0] * (self.n_players - 1)
        if state.round_number >= self.n_rounds - 2:
            return Action.D
        last_round = state.round_number - 1
        sum_op_prev = sum(history.opponent_actions[last_round])
        my_prev_action = history.my_actions[last_round]
        sum_C_prev = sum_op_prev + my_prev_action
        threshold = 1.0
        if self.k / self.n_players * sum_C_prev >= threshold - 1e-09:
            base_decision = Action.C
        else:
            base_decision = Action.D
        any_exploitable = False
        if history is not None:
            total_rounds = last_round + 1
            opponent_actions = history.opponent_actions[:total_rounds]
            for opponent_idx in range(self.n_players - 1):
                coop_count = sum(opponent_actions[:, opponent_idx])
                rate = coop_count / total_rounds
                if rate > 0.5:
                    any_exploitable = True
                    break
        if any_exploitable:
            if random.random() < 0.2:
                return Action.D
        return base_decision

class Strategy_EXPLOITATIVE_437(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and defection
    to maximize individual payoff while encouraging sufficient cooperation from others.
    The strategy cooperates initially, defects when others' cooperation meets a threshold,
    and defects more in endgame rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / (game_description.k + 1))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 3:
            return Action.D
        prev_round = state.round_number - 1
        if history is None or prev_round >= history.my_actions.size:
            return Action.C
        cooperators = sum(history.opponent_actions[prev_round])
        if cooperators >= self.m - 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_438(BaseStrategy):
    """
    A strategy that adapts based on the historical success of cooperative rounds.
    Cooperates if more than half of previous rounds were successful, otherwise defects.
    Always cooperates in the first round and defects in the last.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m_threshold = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.game_description.n_rounds - 1:
            return Action.D
        successful_rounds = 0
        for r in range(current_round):
            my_coop = history.my_actions[r]
            opponent_coop = sum(history.opponent_actions[r, :])
            total_coop = my_coop + opponent_coop
            if total_coop >= self.m_threshold:
                successful_rounds += 1
        ratio = successful_rounds / current_round
        if ratio > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_439(BaseStrategy):
    """
    Adaptive Cooperation with Punishment strategy for N-Player Public Goods Game.
    Cooperates initially, tracks cooperation levels and payoffs, defects as punishment
    when cooperation is insufficient, and adjusts strategy based on observed outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.punishment_remaining = 0
        self.prev_avg = 0.0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if len(history.my_payoffs) == 0:
                return Action.D
            current_avg = np.mean(history.my_payoffs)
            return Action.C if current_avg > 1 else Action.D
        last_round = state.round_number - 1
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        sum_opponent_last = np.sum(opponent_actions[last_round, :])
        my_last = 1 if my_actions[last_round] else 0
        C_prev = sum_opponent_last + my_last
        m = math.ceil(self.game_description.n_players / self.game_description.k)
        if len(history.my_payoffs) == 0:
            current_avg = 0.0
        else:
            current_avg = np.mean(history.my_payoffs)
        payoff_improved = current_avg > self.prev_avg
        self.prev_avg = current_avg
        if C_prev >= m and payoff_improved:
            return Action.C
        else:
            self.punishment_remaining = 1
            return Action.D

class Strategy_EXPLOITATIVE_440(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on historical performance. 
    players. It starts with cooperation and adjusts based on the previous round's outcomes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = 1
        self.s = 3
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        c_prev = my_prev_action + sum(opponents_prev_actions)
        if c_prev >= self.m:
            self.consecutive_defections = 0
            return Action.C
        elif self.consecutive_defections >= self.s:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            return Action.D

class Strategy_EXPLOITATIVE_441(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and 
    defection based on the number of cooperators in previous rounds to maximize 
    individual payoffs while encouraging group cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = max(1, min(self.n_players, math.ceil(self.n_players / self.k)))
        self.p = 3
        self.consec_failures = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consec_failures = 0
            return Action.C
        prev_round = state.round_number - 1
        if history is None:
            return Action.C
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        n_coop_prev = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
        if n_coop_prev >= self.m:
            self.consec_failures = 0
            return Action.C
        else:
            self.consec_failures += 1
            if self.consec_failures >= self.p:
                self.consec_failures = 0
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_442(BaseStrategy):
    """
    This strategy for the N-Player Public Goods Game balances cooperation and 
    exploitation by initially cooperating, then adapting based on past 
    cooperation levels, and Gradually defecting in the endgame rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)
        self.r = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        r = self.r
        current_round = state.round_number
        endgame_threshold = 0.8 * r
        if current_round >= endgame_threshold:
            p_defect = max(0, min(1, (current_round - endgame_threshold) / (0.2 * r)))
            if random.random() < p_defect:
                return Action.D
            else:
                return Action.C
        else:
            prev_round = current_round - 1
            opponent_actions = history.opponent_actions[prev_round]
            opponents_c = np.sum(opponent_actions)
            self_action = history.my_actions[prev_round]
            self_c = 1 if self_action else 0
            total_c = opponents_c + self_c
            if total_c >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_443(BaseStrategy):
    """
    This strategy encourages cooperation by starting with cooperation, 
    defecting if insufficient players cooperated previously, and then 
    cooperating again to reset potential mutual cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.floor(n / k) + 1
        self.force_cooperate = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif self.force_cooperate:
            action = Action.C
            self.force_cooperate = False
        else:
            prev_round = state.round_number - 1
            my_actions = history.my_actions
            opponents_actions = history.opponent_actions
            my_action = my_actions[prev_round]
            opponents_coop = np.sum(opponents_actions[prev_round, :])
            count_prev = int(my_action) + opponents_coop
            if count_prev >= self.m:
                action = Action.C
            else:
                action = Action.D
                self.force_cooperate = True
        return action

class Strategy_EXPLOITATIVE_445(BaseStrategy):
    """
    A strategy that begins with cooperation and adapts based on the number of cooperators in previous rounds.
    Cooperates if the previous number of cooperators meets a threshold, otherwise defects.
    In the last round, cooperates if the majority of previous rounds met the threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            m = self.m
            prev_rounds_count = 0
            total_prev = state.round_number
            for t_prev in range(total_prev):
                my_action = history.my_actions[t_prev]
                opponents_actions = history.opponent_actions[t_prev, :]
                sum_c = int(my_action) + np.sum(opponents_actions)
                if sum_c >= m:
                    prev_rounds_count += 1
            if prev_rounds_count > total_prev / 2:
                return Action.C
            else:
                return Action.D
        else:
            t_prev = state.round_number - 1
            my_action = history.my_actions[t_prev]
            opponents_actions = history.opponent_actions[t_prev, :]
            sum_c = int(my_action) + np.sum(opponents_actions)
            if sum_c >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_446(BaseStrategy):
    """
    Strategy: Reactive Cooperation with Last-Round Defection
    Cooperates initially, adapts based on previous cooperation, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = (game_description.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = current_round - 1
            prev_my_action = history.my_actions[prev_round]
            prev_opponent_actions = history.opponent_actions[prev_round, :]
            total_coop = prev_my_action + sum(prev_opponent_actions)
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_447(BaseStrategy):
    """
    A strategy that begins with cooperation, adapts based on previous cooperation levels,
    and resets cooperation after a threshold of consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.consecutive_defection = 0
        self.threshold_reset = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_defection = 0
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_last = history.my_actions[prev_round]
            opponents_last = history.opponent_actions[prev_round, :]
            count_c_prev = int(my_last) + opponents_last.sum()
            if count_c_prev >= self.m:
                self.consecutive_defection = 0
                return Action.C
            else:
                self.consecutive_defection += 1
                if self.consecutive_defection > self.threshold_reset:
                    self.consecutive_defection = 0
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_450(BaseStrategy):
    """
    A strategy that balances cooperation with strategic defection based on observed outcomes.
    Cooperates in the first round, adapts based on previous round outcomes, and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            t_prev = state.round_number - 1
            my_prev = history.my_actions[t_prev]
            opponent_prev = history.opponent_actions[t_prev, :]
            sum_prev = int(my_prev) + np.sum(opponent_prev)
            n = self.game_description.n_players
            k = self.game_description.k
            if k * sum_prev >= n:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_455(BaseStrategy):
    """
    A strategy to balance cooperation and defection in the Public Goods Game.
    Cooperates initially, then adapts based on previous round's cooperation level.
    Defects if cooperation threshold is not met but forgives after one defection.
    In the last round, uses past cooperation counts to decide.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2
        self.forgiveness_mode = False
        self.coop_counts = []
        self.last_action = None

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.forgiveness_mode = False
            self.coop_counts = []
            self.last_action = True
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            if self.coop_counts:
                avg_coop = sum(self.coop_counts) / len(self.coop_counts)
                if avg_coop >= self.m:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            if self.forgiveness_mode:
                action = Action.C
                self.forgiveness_mode = False
            else:
                prev_t = state.round_number - 1
                if history is None:
                    action = Action.D
                    self.forgiveness_mode = True
                else:
                    my_prev_act = history.my_actions[prev_t]
                    prev_coop_count = 1 if my_prev_act else 0
                    opp_prev_acts = history.opponent_actions[prev_t, :]
                    prev_coop_count += sum(opp_prev_acts)
                    self.coop_counts.append(prev_coop_count)
                    if prev_coop_count >= self.m:
                        action = Action.C
                    else:
                        action = Action.D
                        self.forgiveness_mode = True
            self.last_action = action == Action.C
            return action

class Strategy_EXPLOITATIVE_456(BaseStrategy):
    """
    A strategy that cooperates in the first round and then decides whether to 
    cooperate or defect based on the number of cooperators in the previous round,
    aiming to balance personal gain with meeting a cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            last_opp_actions = history.opponent_actions[-1, :]
            opp_coop = np.sum(last_opp_actions)
            my_last_action = history.my_actions[-1]
            my_coop = 1 if my_last_action else 0
            total_coop = opp_coop + my_coop
            if total_coop >= self.m + 1:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_457(BaseStrategy):
    """
    A strategy that starts with cooperation, adapts based on previous rounds' cooperation levels,
    and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)
        self.total_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.C
        elif state.round_number == self.total_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round]
            total_coop = int(my_prev_action) + sum(opp_prev_actions)
            if total_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_458(BaseStrategy):
    """
    A strategy based on historical cooperation levels, cooperating 
    initially and continuing if average cooperation meets the 
    multiplication factor, defecting otherwise.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        total_coops = 0
        n_previous_rounds = state.round_number
        for round_num in range(n_previous_rounds):
            total_coops += 1 if history.my_actions[round_num] else 0
            total_coops += np.sum(history.opponent_actions[round_num])
        average_coops = total_coops / n_previous_rounds
        threshold = self.game_description.k
        if average_coops >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_460(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Success strategy.
    Cooperates in the first round, then decides based on the ratio of
    successful cooperation rounds exceeding a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = (game_description.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        count = 0
        current_round = state.round_number
        for t in range(current_round):
            my_action = history.my_actions[t]
            my_c = 1 if my_action else 0
            opponent_actions_t = history.opponent_actions[t, :]
            opponent_coop = np.sum(opponent_actions_t)
            total_coop = my_c + opponent_coop
            if total_coop >= self.m:
                count += 1
        ratio = count / current_round
        if ratio >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_461(BaseStrategy):
    """
    A strategy that encourages cooperation by initially cooperating, then adapting based on the number of cooperators in previous rounds.
    Includes endgame adjustment and brief sanctions for low cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = max(1, int(game_description.n_players * 0.5))
        self.punish_next = False

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        r = self.game_description.n_rounds
        cutoff = int(0.9 * r)
        if state.round_number >= cutoff:
            return Action.D
        if self.punish_next:
            self.punish_next = False
            return Action.D
        if history is not None:
            prev_my_action = history.my_actions[-1]
            prev_others_actions = history.opponent_actions[-1, :]
            prev_coop = prev_others_actions.sum() + (1 if prev_my_action else 0)
        else:
            prev_coop = 0
        if self.m / self.n_players > 0.8:
            adjusted_m = max(self.m - 1, 1)
        else:
            adjusted_m = self.m
        if prev_coop >= adjusted_m:
            return Action.C
        else:
            self.punish_next = True
            return Action.D

class Strategy_EXPLOITATIVE_462(BaseStrategy):
    """
    Adaptive Exploitation Based on Past Cooperation Strategy.
    Cooperates initially, defects in the last round, and adapts based on the number of
    cooperators in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            my_prev_action = history.my_actions[-1]
            my_c = 1 if my_prev_action else 0
            opp_prev_actions = history.opponent_actions[-1]
            opp_c = np.sum(opp_prev_actions)
            total_c_prev = my_c + opp_c
            if total_c_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_463(BaseStrategy):
    """
    A strategy that adaptively cooperates based on the number of previous cooperators.
    Cooperates if at least half of the players (rounded down) cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players / 2.0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_prev_action = history.my_actions[t_prev]
        opp_prev_actions = history.opponent_actions[t_prev, :]
        total_cooperators = my_prev_action + opp_prev_actions.sum()
        if total_cooperators >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_486(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.x = 10
        self.y = 3
        self.defect_remaining = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.defect_remaining > 0:
            self.defect_remaining -= 1
            return Action.D
        if state.round_number == self.n_rounds - 1:
            total_rounds = state.round_number
            sum_success_total = 0
            for r in range(total_rounds):
                my_action = history.my_actions[r]
                opponent_actions = history.opponent_actions[r]
                sum_cj = my_action + opponent_actions.sum()
                if sum_cj >= self.m:
                    sum_success_total += 1
            if sum_success_total > total_rounds / 2:
                return Action.C
            else:
                start = max(0, total_rounds - self.x)
                recent_success = 0
                for r in range(start, total_rounds):
                    my_action = history.my_actions[r]
                    opponent_actions = history.opponent_actions[r]
                    sum_cj = my_action + opponent_actions.sum()
                    if sum_cj >= self.m:
                        recent_success += 1
                if self.x == 0:
                    success_rate = 0.0
                else:
                    success_rate = recent_success / self.x
                return Action.C if success_rate > 0.5 else Action.D
        else:
            total_rounds = state.round_number
            start = max(0, total_rounds - self.x)
            successful = 0
            for r in range(start, total_rounds):
                my_action = history.my_actions[r]
                opponent_actions = history.opponent_actions[r]
                sum_cj = my_action + opponent_actions.sum()
                if sum_cj >= self.m:
                    successful += 1
            rounds_analyzed = total_rounds - start
            if rounds_analyzed == 0:
                success_rate = 0.0
            else:
                success_rate = successful / rounds_analyzed
            if success_rate > 0.7:
                return Action.C
            elif success_rate < 0.5:
                self.defect_remaining = self.y
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_503(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that begins with cooperation and adapts based on the number of cooperators in the previous round.
    - First Round: Always Cooperate.
    - Subsequent Rounds: Cooperate if at least m players cooperated in the previous round; otherwise, cooperate with probability p = m/n.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round, :]
        coops = my_prev_action + np.sum(opp_prev_actions)
        if coops >= self.m:
            return Action.C
        else:
            self.m = int(coops)
            p = self.m / self.game_description.n_players
            if random.random() < p:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_278(BaseStrategy):
    """
    A strategy for the N-player Public Goods Game that balances cooperation and defection.
    Cooperates initially, then defects if others' contributions are sufficient, and uses majority historical cooperation in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r - 1:
            m = self.n / self.k
            count = 0
            for t in range(state.round_number):
                T_opp = sum(history.opponent_actions[t, :])
                if T_opp >= m:
                    count += 1
            total_prior = state.round_number
            if count / total_prior >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            prev_my_action = history.my_actions[-1]
            if prev_my_action:
                T_others = sum(history.opponent_actions[-1, :])
                if T_others >= self.n / self.k:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_282(BaseStrategy):
    """
    Adaptive Cooperation Based on Past Success (ACPS) strategy.
    Cooperates initially, then continues if previous round's cooperators meet threshold m.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        sum_mine = 1 if prev_my_action else 0
        sum_opponents = np.sum(history.opponent_actions[prev_round, :])
        total_coops = sum_mine + sum_opponents
        if total_coops >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_298(BaseStrategy):
    """
    An exploitative strategy for the public goods game. Cooperates initially, then
    defects if the average cooperation in previous rounds meets a threshold (k),
    and always defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k

    def compute_average_cooperators(self, history: PlayerHistory) -> float:
        total_coop = 0.0
        for r in range(history.my_actions.size):
            my_coop = 1 if history.my_actions[r] else 0
            opp_coop = np.sum(history.opponent_actions[r])
            total_coop += my_coop + opp_coop
        avg_coop = total_coop / history.my_actions.size
        return avg_coop

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            avg_coop = self.compute_average_cooperators(history)
            if avg_coop >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_299(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances individual payoff and collective good.
    Cooperates in the first round, then cooperates or defects based on previous round's cooperation level.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n * (self.k - 1) / self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        sum_prev = sum(history.opponent_actions[prev_round, :]) + prev_my_action
        if sum_prev > self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_300(BaseStrategy):
    """
    An adaptive strategy that Cooperates based on recent cooperation history.
    Switches to Defect if insufficient cooperation is observed and re-evaluates after a set period.
    Adjusts behavior near the game's end to optimize payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.m_rounds_to_consider = 3
        self.defect_duration = 2
        self.defect_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.defect_remaining = 0
            return Action.C
        else:
            cooperator_counts = []
            for round_t in range(state.round_number):
                if history is None:
                    continue
                own_action = history.my_actions[round_t]
                others = history.opponent_actions[round_t]
                count = sum(others) + (1 if own_action else 0)
                cooperator_counts.append(count)
            threshold = self.n / 2
            if len(cooperator_counts) <= self.m_rounds_to_consider:
                recent = cooperator_counts
            else:
                recent = cooperator_counts[-self.m_rounds_to_consider:]
            avg_coop = sum(recent) / len(recent) if recent else 0
            if self.defect_remaining > 0:
                action = Action.D
                self.defect_remaining -= 1
            elif avg_coop >= threshold:
                action = Action.C
            else:
                self.defect_remaining = self.defect_duration
                action = Action.D
            rounds_left = self.r - state.round_number
            if rounds_left <= self.m_rounds_to_consider:
                if len(recent) == 0:
                    action = Action.C
                else:
                    recent_avg = avg_coop
                    if recent_avg < threshold:
                        action = Action.D
                    else:
                        action = Action.C
            return action

class Strategy_EXPLOITATIVE_301(BaseStrategy):
    """
    Adaptive Exploitation strategy for the N-Player Public Goods Game.

    This strategy begins by cooperating to establish baseline cooperation. It then 
    monitors the number of cooperators in previous rounds and adaptively adjusts its 
    behavior. If the number of cooperators falls below a threshold (m), it cooperates 
    to encourage others. If the threshold is met, it tests defecting with a probability 
    that adjusts based on the success of previous defections. In the final round, it 
    defects to maximize its payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.exploit_prob = 0.2
        self.eval_next_round = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.eval_next_round:
            s_prev = sum(history.opponent_actions[-1, :]) + (1 if history.my_actions[-1] else 0)
            if s_prev >= self.m:
                self.exploit_prob = min(1.0, self.exploit_prob * 1.1)
            else:
                self.exploit_prob = max(0.0, self.exploit_prob * 0.9)
            self.eval_next_round = False
        s_prev = sum(history.opponent_actions[-1, :]) + (1 if history.my_actions[-1] else 0)
        if s_prev < self.m:
            action = Action.C
        else:
            is_last_round = state.round_number == self.game_description.n_rounds - 1
            if is_last_round:
                action = Action.D
            elif random.random() < self.exploit_prob:
                action = Action.D
                self.eval_next_round = True
            else:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_304(BaseStrategy):
    """
    A strategy that starts by Cooperating and then uses past behavior to decide future actions.
    It tracks the average number of Cooperators in past defecting rounds and defects again if this average is high enough.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.my_defect_rounds = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if not history:
            return Action.C
        my_actions = history.my_actions
        defect_rounds = [r for r in range(len(my_actions)) if not my_actions[r]]
        total_cooperators = 0
        for round in defect_rounds:
            if round < history.opponent_actions.shape[0]:
                total_cooperators += history.opponent_actions[round].sum()
        avg_coops = total_cooperators / len(defect_rounds) if defect_rounds else 0.0
        threshold = self.game_description.n_players - 1
        if avg_coops >= threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_312(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.k
        self.endgame_start = max(0, self.n_rounds - int(0.05 * self.n_rounds))
        self.n_opponents = self.n_players - 1
        self.defection_counts = [0] * self.n_opponents
        self.endgame_total_coop = 0
        self.positive_rounds = 0
        self.total_rounds_processed = 0

    def __call__(self, state: GameState, history: PlayerHistory=None) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self._update_instance_variables(history)
        if state.round_number >= self.endgame_start:
            sum_coop = self.endgame_total_coop
            if sum_coop < self.m:
                return Action.D
            else:
                return Action.C
        if self._is_punishment_necessary():
            return Action.D
        if self._should_exploit():
            return Action.C
        if history is None:
            s_prev = 0
        else:
            prev_round = history.my_actions[-1] if len(history.my_actions) > 0 else False
            prev_opponents = history.opponent_actions[-1] if len(history.opponent_actions) > 0 else []
            s_prev = sum(prev_opponents) + (1 if prev_round else 0)
        if s_prev >= self.m:
            return Action.C
        else:
            return Action.D

    def _update_instance_variables(self, history):
        for t in range(len(history.my_actions)):
            for i in range(self.n_opponents):
                if not history.opponent_actions[t][i]:
                    self.defection_counts[i] += 1
        for t in range(len(history.opponent_actions)):
            if t >= self.endgame_start:
                s_t = sum(history.opponent_actions[t, :]) + (1 if history.my_actions[t] else 0)
                self.endgame_total_coop += s_t
        for t in range(len(history.opponent_actions)):
            s_t = sum(history.opponent_actions[t, :]) + (1 if history.my_actions[t] else 0)
            if s_t >= self.m:
                self.positive_rounds += 1
        self.total_rounds_processed = len(history.my_actions)

    def _is_punishment_necessary(self):
        if self.n_opponents == 0:
            return False
        if self.total_rounds_processed == 0:
            return False
        count = 0
        for i in range(self.n_opponents):
            defect_rate = self.defection_counts[i] / self.total_rounds_processed
            if defect_rate >= 0.5:
                count += 1
        return count / self.n_opponents >= 0.5

    def _should_exploit(self):
        if self.total_rounds_processed == 0:
            return False
        return self.positive_rounds / self.total_rounds_processed >= 0.5

class Strategy_EXPLOITATIVE_320(BaseStrategy):
    """
    An adaptive strategy to sustain cooperation in public goods games.
    Starts by cooperating, continues if enough players cooperate,
    and probes cooperation periodically if not.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.consecutive_failures = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_actions_prev = history.opponent_actions[previous_round, :]
        sum_opponent_prev = np.sum(opponent_actions_prev)
        s_prev = my_prev_action + sum_opponent_prev
        if s_prev >= self.m:
            self.consecutive_failures = 0
            return Action.C
        else:
            self.consecutive_failures += 1
            if self.consecutive_failures % 3 == 0:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_367(BaseStrategy):
    """
    Cooperate If Trending Towards Threshold (CITT) Strategy.
    
    This strategy encourages cooperation if the trend of cooperation in previous rounds
    is moving towards or exceeds a calculated threshold m, which is derived from the 
    game's parameters n (number of players) and k (multiplication factor).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        if n % k == 0:
            self.m = n // k + 1
        else:
            self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            total_coop = 0
            for t in range(state.round_number):
                my_action = history.my_actions[t]
                opp_actions = history.opponent_actions[t, :]
                coop_count = my_action + sum(opp_actions)
                total_coop += coop_count
            avg_coop = total_coop / state.round_number
            if avg_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_369(BaseStrategy):
    """
    An adaptive strategy that balances cooperation with self-interest, encouraging others to contribute while maximizing personal payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.threshold = self.n_players / self.k
        self.sum_coops = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponent_actions = history.opponent_actions[prev_round, :]
        sum_opponents = np.sum(prev_opponent_actions)
        prev_coop_total = int(prev_my_action) + sum_opponents
        self.sum_coops.append(prev_coop_total)
        if state.round_number == self.n_rounds - 1:
            count = 0
            for coop in self.sum_coops:
                if coop >= self.threshold:
                    count += 1
            proportion = count / len(self.sum_coops)
            if proportion >= 0.5:
                return Action.C
            else:
                return Action.D
        elif self.sum_coops[-1] >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_389(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and exploitation based on past behavior.
    It cooperates initially and in rounds with insufficient previous cooperation, but defects when past cooperation meets a threshold.
    The last round's cooperation is determined by the average cooperation in all previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            total_c = 0
            for t in range(state.round_number):
                if history is None:
                    continue
                my_action = history.my_actions[t]
                opponent_actions = history.opponent_actions[t, :]
                sum_c = my_action + sum(opponent_actions)
                total_c += sum_c
            avg_c = total_c / state.round_number
            if avg_c >= self.m:
                return Action.D
            else:
                return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round, :]
            prev_sum_c = my_prev_action + sum(opponent_prev_actions)
            if prev_sum_c >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_407(BaseStrategy):
    """
    Adaptive Cooperation Strategy evaluates the level of cooperation in previous rounds 
    and decides to Cooperate or Defect based on a dynamic threshold and recovery mechanism.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.recovery_threshold = 3
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_others_actions = history.opponent_actions[-1]
        total_c = prev_my_action + np.sum(prev_others_actions)
        if total_c >= self.m:
            self.consecutive_defects = 0
            return Action.C
        elif self.consecutive_defects >= self.recovery_threshold:
            self.consecutive_defects = 0
            return Action.C
        else:
            self.consecutive_defects += 1
            return Action.D

class Strategy_EXPLOITATIVE_421(BaseStrategy):
    """
    Adaptive Exploitation Strategy with Threshold Maintenance.
    
    This strategy starts with cooperation in the first round, defects in the last round,
    and adapts based on the number of cooperators in the previous round. It uses a threshold
    (m) derived from the game's multiplication factor k to decide whether to cooperate or defect.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            return Action.D
        else:
            if history is None:
                return Action.D
            last_round = current_round - 1
            my_last_action = history.my_actions[last_round]
            opponent_last_actions = history.opponent_actions[last_round]
            last_C = my_last_action + sum(opponent_last_actions)
            if last_C >= self.m:
                if last_C - 1 >= self.m:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_422(BaseStrategy):
    """
    A strategy that starts with cooperation, then monitors the success rate of cooperative rounds.
    If a majority of cooperative rounds meet a threshold (sum of cooperators >= half the players),
    it continues to cooperate; otherwise, it defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        threshold = n_players / 2
        my_actions = history.my_actions[:state.round_number]
        c_rounds = np.where(my_actions)[0]
        successful = 0
        for t in c_rounds:
            if t < history.opponent_actions.shape[0]:
                opp_coop = np.sum(history.opponent_actions[t, :])
                total_coop = 1 + opp_coop
                if total_coop >= threshold:
                    successful += 1
        total_c = len(c_rounds)
        if total_c == 0:
            return Action.C
        ratio = successful / total_c
        return Action.C if ratio > 0.5 else Action.D

class Strategy_EXPLOITATIVE_444(BaseStrategy):
    """
    An exploitative strategy for the N-Player Public Goods Game that adapts based on previous cooperation levels.
    Cooperates if the proportion of previous cooperators meets a threshold; otherwise, defects. Defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            my_contribution = 1 if my_prev_action else 0
            opponent_actions_prev = history.opponent_actions[prev_round]
            opponent_cooperations = np.sum(opponent_actions_prev)
            total_cooperators = my_contribution + opponent_cooperations
            p_prev = total_cooperators / self.game_description.n_players
            threshold = self.game_description.k / self.game_description.n_players
            if p_prev >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_448(BaseStrategy):
    """
    Adaptive Cooperation with Probing (ACAP) strategy for the N-Player Public Goods Game.
    Cooperates initially and adapts based on the number of previous cooperators, with periodic probes.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.current_mode = 'cooperate'
        self.defect_counter = 0
        self.test_interval = 3

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        sum_c_prev = history.my_actions[state.round_number - 1] + sum(history.opponent_actions[state.round_number - 1, :])
        if self.current_mode == 'cooperate':
            if sum_c_prev >= self.m:
                return Action.C
            else:
                self.current_mode = 'defect'
                self.defect_counter = 0
                return Action.D
        elif self.current_mode == 'defect':
            self.defect_counter += 1
            if self.defect_counter < self.test_interval:
                return Action.D
            else:
                self.defect_counter = 0
                self.current_mode = 'probe'
                return Action.C
        elif self.current_mode == 'probe':
            if sum_c_prev >= self.m:
                self.current_mode = 'cooperate'
                return Action.C
            else:
                self.current_mode = 'defect'
                self.defect_counter = 0
                return Action.D

class Strategy_EXPLOITATIVE_449(BaseStrategy):
    """
    Reactive Exploitation with Forgiveness (REF) strategy implementation.
    Cooperates initially and adapts based on the number of previous cooperators.
    Defects when the number of previous cooperators meets a calculated threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        my_prev = int(prev_my_action)
        opponent_sum = np.sum(opponent_actions_prev)
        c_prev = my_prev + opponent_sum
        if c_prev >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_451(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Success strategy.
    Cooperates initially and continues if enough players cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponents_actions = history.opponent_actions[prev_round]
        s_prev = sum(prev_opponents_actions) + (1 if prev_my_action else 0)
        if s_prev >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_453(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and defection.
    Cooperates in the first round, defects in the last, and adapts based on previous cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        k = game_description.k
        n = game_description.n_players
        m = k / (k + 1) * n
        self.m = math.floor(m)
        if self.m < 1:
            self.m = 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        r = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        elif current_round == r - 1:
            return Action.D
        else:
            prev_round = current_round - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round, :]
            total_coops = int(my_prev_action) + opponent_prev_actions.sum()
            return Action.C if total_coops >= self.m else Action.D

class Strategy_EXPLOITATIVE_454(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that encourages cooperation 
    while adapting to opponents' actions using trend analysis and a forgiveness mechanism.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.coop_history = []
        self.punishing = False

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        n = self.game_description.n_players
        k = self.game_description.k
        rounds = self.game_description.n_rounds
        prev_round = current_round - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opp_actions = history.opponent_actions[prev_round, :]
        prev_coop = sum(prev_opp_actions) + (1 if prev_my_action else 0)
        self.coop_history.append(prev_coop)
        if current_round == rounds - 1:
            trend = self._compute_trend()
            if trend < 0:
                return Action.D
            else:
                return Action.C
        if self.punishing:
            trend = self._compute_trend()
            if trend > 0:
                self.punishing = False
                return Action.C
            else:
                return Action.D
        m = k
        if prev_coop >= m:
            trend = self._compute_trend()
            if trend >= 0:
                return Action.C
            else:
                self.punishing = True
                return Action.D
        else:
            self.punishing = True
            return Action.D

    def _compute_trend(self) -> float:
        coop_history = self.coop_history
        if len(coop_history) < 2:
            return 0
        window = min(3, len(coop_history))
        recent_avg = np.mean(coop_history[-window:]) if window > 0 else 0
        prev_window = max(0, len(coop_history) - 2 * window)
        before_avg = np.mean(coop_history[prev_window:len(coop_history) - window]) if prev_window < len(coop_history) - window else 0
        return recent_avg - before_avg

class Strategy_EXPLOITATIVE_459(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Public Goods Game.

    Cooperates initially to encourage others and gather information. For subsequent rounds, 
    defects if the average number of cooperators is above a threshold, otherwise cooperates.
    In the last round, defects if all previous rounds met the cooperation threshold, otherwise
    continues to cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        n_players = self.n_players
        m = self.m
        n_rounds = self.n_rounds
        coop_counts = []
        for t in range(current_round):
            my_action = history.my_actions[t]
            opponent_actions_t = history.opponent_actions[t]
            opp_C = np.sum(opponent_actions_t)
            total_C = my_action + opp_C
            coop_counts.append(total_C)
        if current_round == n_rounds - 1:
            all_met = all((coop >= m for coop in coop_counts))
            return Action.D if all_met else Action.C
        else:
            last_coop = coop_counts[-1] if coop_counts else 0
            if last_coop >= m:
                avg_coop = sum(coop_counts) / len(coop_counts)
                return Action.D if avg_coop > m else Action.C
            return Action.C

class Strategy_EXPLOITATIVE_464(BaseStrategy):
    """
    Adaptive Exploitation Strategy (AES) balances cooperation and exploitation.
    Cooperates initially and in rounds where the previous cooperation is below a threshold,
    defects otherwise to maximize personal gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.floor(game_description.k)
        self.m = min(self.m, game_description.n_players - 1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions = history.opponent_actions[prev_round, :]
        t_prev = sum(opponent_actions) + (1 if my_prev_action else 0)
        if t_prev > self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_465(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances individual gain with collective success.
    Cooperates initially and in subsequent rounds based on the number of previous cooperators.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponents_prev = history.opponent_actions[prev_round, :]
            C_prev = my_prev + opponents_prev.sum()
            if C_prev > self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_466(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and self-interest.
    The strategy cooperates in the first round and continues to cooperate in subsequent rounds
    only if at least half of the players (rounded down) cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.threshold = self.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        if history is None:
            return Action.C
        my_action = history.my_actions[prev_round]
        opponents_actions = history.opponent_actions[prev_round]
        total_cooperators = my_action + np.sum(opponents_actions)
        if total_cooperators >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_467(BaseStrategy):
    """
    An adaptive strategy for the N-player public goods game. It initializes by cooperating,
    then continues to cooperate if the previous round had enough cooperators,
    and resets cooperation after three consecutive rounds with insufficient cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.consecutive_failures = 0

    def __call__(self, state: GameState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions = history.opponent_actions[prev_round]
        prev_coop_count = my_prev_action + np.sum(opponent_actions)
        if prev_coop_count >= self.m:
            self.consecutive_failures = 0
            return Action.C
        else:
            self.consecutive_failures += 1
            if self.consecutive_failures >= 3:
                self.consecutive_failures = 0
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_468(BaseStrategy):
    """
    A reactive strategy for the N-Player Public Goods Game. 
    Cooperates in the first round and continues to Cooperate in subsequent rounds if at least half of the players Cooperated in the previous round; otherwise, Defects.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_last = history.my_actions[last_round]
        my_c = 1 if my_last else 0
        opponent_actions_last = history.opponent_actions[last_round]
        opponent_c = np.sum(opponent_actions_last)
        total_c = my_c + opponent_c
        m = self.n_players // 2
        if total_c >= m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_469(BaseStrategy):
    """
    An adaptive strategy that starts with cooperation and adjusts based on historical success.
    Cooperates if past cooperation rate is above 50%, with special handling for endgame rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            return Action.C
        r = self.game_description.n_rounds
        n = self.game_description.n_players
        m = n // 2 + 1
        T_met = 0
        for round in range(t):
            my_action = history.my_actions[round]
            opponent_actions = history.opponent_actions[round]
            s = int(my_action) + opponent_actions.sum()
            if s >= m:
                T_met += 1
        cooperation_rate = T_met / t
        if t >= r - 3 or t == r - 1:
            start_round = max(0, t - 5)
            recent_rounds = range(start_round, t)
            T_recent_met = 0
            for rd in recent_rounds:
                my_a = history.my_actions[rd]
                opp_a = history.opponent_actions[rd]
                s_r = int(my_a) + opp_a.sum()
                if s_r >= m:
                    T_recent_met += 1
            recent_count = len(recent_rounds)
            recent_rate = T_recent_met / recent_count if recent_count else 0.0
            if recent_rate <= 0.5:
                return Action.D
        if cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_467(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game:
    - Cooperate in the first round.
    - Cooperate again if enough players cooperated in the previous round.
    - Defect otherwise, but reset to cooperation after three consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)
        self.m = min(self.m, n)
        self.consecutive_failures = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round, :]
        sum_opponents = np.sum(opponent_prev_actions)
        coops_prev = my_prev_action + sum_opponents
        if coops_prev >= self.m:
            self.consecutive_failures = 0
            return Action.C
        elif self.consecutive_failures < 3:
            self.consecutive_failures += 1
            return Action.D
        else:
            self.consecutive_failures = 0
            return Action.C

class Strategy_COLLECTIVE_1(BaseStrategy):
    """
    A strategy to sustain cooperation in a repeated N-player public goods game.
    Players cooperate if enough others cooperated previously or attempt recovery after defecting.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k_factor = game_description.k
        self.m = math.ceil(self.n_players / self.k_factor)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = history
        opp_actions_prev = prev_round.opponent_actions[-1]
        sum_opponent_c = np.sum(opp_actions_prev)
        my_prev_action = prev_round.my_actions[-1]
        total_c_prev = sum_opponent_c + my_prev_action
        if total_c_prev >= self.m:
            return Action.C
        elif not my_prev_action:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_90(BaseStrategy):
    """
    Adaptive Exploitation strategy for the Public Goods Game.
    - Cooperates initially to encourage others.
    - Monitors cooperation rates and adapts based on moving averages.
    - Switches to defecting if personal payoff is higher, with punishment mechanics.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = 0.5
        self.coop_rates = []
        self.exploitation_mode = False
        self.punishment_rounds = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        max_rounds = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        if current_round == max_rounds - 1:
            return Action.D
        opponent_actions = history.opponent_actions
        my_actions = history.my_actions
        self.coop_rates = []
        for t in range(len(my_actions)):
            my_action = my_actions[t]
            opp_actions = opponent_actions[t]
            total_coop = sum(opp_actions) + (1 if my_action else 0)
            rate = total_coop / self.n_players
            self.coop_rates.append(rate)
        window_size = 3
        start = max(0, len(self.coop_rates) - window_size)
        recent_rates = self.coop_rates[start:]
        moving_avg = sum(recent_rates) / len(recent_rates) if recent_rates else 0.0
        if moving_avg >= self.m:
            return Action.C
        else:
            last_round = len(my_actions) - 1
            my_last_action = my_actions[last_round]
            opp_actions_last = opponent_actions[last_round]
            opp_C_last = sum(opp_actions_last)
            if my_last_action:
                pi_C = self.k * (opp_C_last + 1) / self.n_players
                pi_D = 1 + self.k * opp_C_last / self.n_players
            else:
                pi_C = self.k * (opp_C_last + 1) / self.n_players
                pi_D = history.my_payoffs[last_round]
            if pi_C > pi_D:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_94(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation
    with defection based on observed cooperation levels in previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        prev_round = current_round - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponent_actions = history.opponent_actions[prev_round, :]
        prev_coops = int(prev_my_action) + np.sum(prev_opponent_actions)
        if prev_coops >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_263(BaseStrategy):
    """Adaptive strategy to encourage cooperation while responding to group outcomes."""

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        k = self.game_description.k
        self.m = math.floor(n / k) + 1
        self.m = int(self.m)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        sum_coop = 1 if my_prev_action else 0
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        sum_opponent = np.sum(opponent_actions_prev)
        sum_coop += sum_opponent
        if sum_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_264(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Success.
    Cooperates initially, adapts based on previous cooperation levels, and uses majority success in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.m = (self.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            successful = 0
            for t in range(current_round):
                my_action = history.my_actions[t]
                opponents = history.opponent_actions[t]
                coop_total = my_action + sum(opponents)
                if coop_total >= self.m:
                    successful += 1
            if successful >= current_round / 2:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = current_round - 1
            my_action = history.my_actions[prev_round]
            opponents = history.opponent_actions[prev_round]
            coop_total = my_action + sum(opponents)
            if coop_total >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_266(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that combines initial cooperation, 
    reactive cooperation based on the previous round's outcome, and a recovery mechanism 
    after a series of defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.n_players // 2
        self.max_defections = 3
        self.consecutive_defections = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_my_action = history.my_actions[-1]
        prev_opponent_actions = history.opponent_actions[-1, :]
        my_coop_contribution = 1 if prev_my_action else 0
        opponent_coop_count = np.sum(prev_opponent_actions)
        total_cooperators = my_coop_contribution + opponent_coop_count
        if total_cooperators >= self.m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections >= self.max_defections:
                self.consecutive_defections = 0
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_276(BaseStrategy):
    """
    Adaptive Threshold Cooperator (ATC) strategy for the N-Player Public Goods Game.
    Cooperates if the number of cooperators in the previous round meets or exceeds a threshold.
    The threshold is calculated as the ceiling of (n_players / k).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_idx = state.round_number - 1
        own_prev_action = history.my_actions[prev_round_idx]
        others_prev_actions = history.opponent_actions[prev_round_idx]
        coop_count = int(own_prev_action) + np.sum(others_prev_actions)
        if coop_count >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_327(BaseStrategy):
    """
    Adaptive Cooperation Threshold (ACT) strategy for N-Player Public Goods Game.
    Cooperates initially and adapts based on the success ratio of past rounds.
    Defects if the success ratio falls below 50% or in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = int(n // k + 1)
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        successes = 0
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            opponents = history.opponent_actions[t]
            total_coop = my_action + np.sum(opponents)
            if total_coop >= self.m:
                successes += 1
        ratio = successes / state.round_number
        if ratio > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_452(BaseStrategy):
    """
    A strategy that cooperates in the first round, then defects if the number of 
    cooperators in the previous round meets a calculated threshold, otherwise continues 
    cooperating. The threshold is derived to balance individual gain with collective 
    contribution, aiming to maximize personal payoff while supporting public good.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        denominator = k + 1
        m = n * k / denominator
        self.m = math.ceil(m)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions_prev = history.opponent_actions[-1]
        sum_opponents_prev = np.sum(opponent_actions_prev)
        my_previous_action = history.my_actions[-1]
        c_prev = sum_opponents_prev + (1 if my_previous_action else 0)
        if c_prev >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_470(BaseStrategy):
    """
    A strategy for the N-player public goods game where the player cooperates in the first round. 
    In subsequent rounds, the player defects if the previous round met or exceeded the cooperation threshold; 
    otherwise, the player continues to cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_previous = history.my_actions[previous_round]
        opponent_actions_prev = history.opponent_actions[previous_round, ...]
        prev_mine_coop = 1 if my_previous else 0
        others_coop = np.sum(opponent_actions_prev)
        total_coop = prev_mine_coop + others_coop
        if total_coop >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_471(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.consec_below = 0
        self.reengagement_trigger = False

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.reengagement_trigger:
            self.reengagement_trigger = False
            self.consec_below = 0
            return Action.C
        prev_round = state.round_number - 1
        my_last_action = history.my_actions[prev_round]
        opponents_last_actions = history.opponent_actions[prev_round]
        s_prev = sum(opponents_last_actions) + (1 if my_last_action else 0)
        if s_prev >= self.m:
            self.consec_below = 0
            return Action.C
        else:
            self.consec_below += 1
            if self.consec_below == 2:
                self.reengagement_trigger = True
            return Action.D

class Strategy_EXPLOITATIVE_472(BaseStrategy):
    """
    A strategy that decides whether to Cooperate or Defect based on opponents' historical cooperation rates.
    Cooperates in the first round, then uses a threshold-based approach considering the average cooperation rates of opponents.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_opponents = self.game_description.n_players - 1
        t = state.round_number
        sum_e = 0.0
        for j in range(n_opponents):
            coop_counts = np.sum(history.opponent_actions[:t, j])
            if t == 0:
                coup_rate = 0.0
            else:
                coup_rate = coop_counts / t
            sum_e += coup_rate
        m = self.game_description.n_players
        if sum_e >= m:
            return Action.D
        elif sum_e + 1.0 >= m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_473(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that balances cooperation and self-interest.
    Cooperates in the first round, conditionally cooperates in middle rounds based on previous cooperation,
    and defects in the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k) if k != 0 else 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_prev_coop = int(history.my_actions[previous_round])
        opp_prev_coop = sum(history.opponent_actions[previous_round, :])
        total_prev_coop = my_prev_coop + opp_prev_coop
        if total_prev_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_474(BaseStrategy):
    """
    A strategy that starts with Cooperation, then adapts based on previous rounds' cooperation levels.
    It defects for a set number of rounds if a cooperation threshold is not met, then reassesses.
    Defects in the final round to maximize personal gain.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n_players / self.k)
        self.defect_rounds = 3
        self.last_coop_met_round = -1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        prev_round = current_round - 1
        my_prev_action = history.my_actions[prev_round]
        prev_my_coop = 1 if my_prev_action else 0
        opponents_prev_actions = history.opponent_actions[prev_round]
        prev_coop_count = prev_my_coop + np.sum(opponents_prev_actions)
        if prev_coop_count >= self.m:
            self.last_coop_met_round = prev_round
            return Action.C
        elif self.last_coop_met_round == -1:
            return Action.D
        else:
            rounds_since = current_round - self.last_coop_met_round
            if rounds_since <= self.defect_rounds:
                return Action.D
            elif prev_coop_count >= self.m:
                self.last_coop_met_round = prev_round
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_475(BaseStrategy):
    """
    Adaptive Exploitation Based on Historical Cooperation Rates strategy.
    Cooperates initially, then defects if the sum of other players' cooperation rates meets a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        if self.n_players - 1 == 0:
            self.m = 0.0
        else:
            self.m = self.k / self.n_players * (self.n_players - 1)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_rounds = state.round_number
        if prev_rounds == 0:
            return Action.C
        sum_p = 0.0
        n_opponents = self.n_players - 1
        for j in range(n_opponents):
            if history is not None:
                coop_count = np.sum(history.opponent_actions[:prev_rounds, j])
                rate = coop_count / prev_rounds
                sum_p += rate
        if sum_p >= self.m - 1e-09:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_476(BaseStrategy):
    """
    A strategy that Cooperates unless the previous round's cooperation surpasses a calculated threshold.
    The threshold is determined by the number of players divided by the multiplication factor.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k
        self.m = self.n_players / self.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        m_prev = sum(opponent_actions_prev) + (1 if my_prev_action else 0)
        if m_prev > self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_477(BaseStrategy):
    """
    Adapts cooperation based on the number of previous cooperators. Cooperates if at least half (rounded up) of the players cooperated previously.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = (self.game_description.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        my_coop = 1 if my_prev_action else 0
        opponents_coop = sum(opponents_prev_actions)
        total_coop = my_coop + opponents_coop
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_478(BaseStrategy):
    """
    A reactive and exploitative strategy for the N-Player Public Goods Game.
    Cooperates initially then switches to defecting if the majority of past rounds met the cooperation threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        met_m_count = 0
        for t in range(state.round_number):
            my_c = 1 if history.my_actions[t] else 0
            opponent_c = history.opponent_actions[t].sum()
            total_c = my_c + opponent_c
            if total_c >= self.m:
                met_m_count += 1
        fraction_met = met_m_count / state.round_number
        return Action.D if fraction_met > 0.5 else Action.C

class Strategy_EXPLOITATIVE_479(BaseStrategy):
    """
    A strategy that starts by Cooperating in the first round, continues to Cooperate 
    if at least half of the players Cooperated in the previous round, and Defects 
    in the last round to maximize individual payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = current_round - 1
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            opp_coop = sum(opponent_actions_prev)
            own_prev_action = history.my_actions[prev_round]
            total_coop = opp_coop + int(own_prev_action)
            m = self.n_players // 2
            if total_coop >= m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_480(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that balances cooperation based on past outcomes.
    Cooperates initially, then adapts based on the success rate of rounds where a majority cooperated.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = (game_description.n_players + 1) // 2
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        successful_rounds = 0
        for round_idx in range(state.round_number):
            my_c = history.my_actions[round_idx]
            opp_c = np.sum(history.opponent_actions[round_idx, :])
            total_c = opp_c + (1 if my_c else 0)
            if total_c >= self.m:
                successful_rounds += 1
        if state.round_number == self.n_rounds - 1:
            if successful_rounds > state.round_number / 2:
                return Action.C
            else:
                return Action.D
        else:
            success_rate = successful_rounds / state.round_number
            if success_rate > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_481(BaseStrategy):
    """
    A strategy that begins with cooperation and adapts based on the number of cooperators in previous rounds.
    Cooperates if the number of cooperators in the previous round meets a threshold (n_players // 2),
    otherwise defects. Periodically tests cooperation again after consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold = self.n_players // 2
        self.consecutive_defects = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_defects = 0
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_t = state.round_number - 1
        my_prev_action = history.my_actions[prev_t]
        opponent_prev_actions = history.opponent_actions[prev_t, :]
        s_prev = sum(opponent_prev_actions) + my_prev_action
        if s_prev >= self.threshold:
            self.consecutive_defects = 0
            return Action.C
        elif self.consecutive_defects >= 2:
            self.consecutive_defects = 0
            return Action.C
        else:
            self.consecutive_defects += 1
            return Action.D

class Strategy_EXPLOITATIVE_482(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            me_prev = history.my_actions[-1]
            opponents_prev = history.opponent_actions[-1]
            cooperators_prev = me_prev + np.sum(opponents_prev)
            if cooperators_prev >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_483(BaseStrategy):
    """Adaptive Probe Cooperation (APC) Strategy.
    
    This strategy starts by cooperating, then adapts based on previous outcomes.
    It uses a threshold 'm' to determine if enough players are cooperating.
    If cooperation falters, it defects until it decides to probe cooperation again.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)
        self.x = 3
        self.consecutive_defections = 0
        self.previous_probe_sent = False

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        if history is None:
            return Action.C
        my_prev_action = history.my_actions[previous_round]
        opponents_prev_actions = history.opponent_actions[previous_round]
        s_prev = int(my_prev_action) + int(opponents_prev_actions.sum())
        if self.previous_probe_sent:
            if s_prev >= self.m:
                self.consecutive_defections = 0
                self.previous_probe_sent = False
                return Action.C
            else:
                self.consecutive_defections = 1
                self.previous_probe_sent = False
                return Action.D
        elif s_prev >= self.m:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            if self.consecutive_defections < self.x:
                return Action.D
            else:
                self.consecutive_defections = 0
                self.previous_probe_sent = True
                return Action.C

class Strategy_EXPLOITATIVE_485(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that uses a threshold-based cooperative approach.
    Cooperates if the number of cooperators meets a threshold, otherwise defects, with special handling for the last round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = (self.n_players + 1) // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number < self.n_rounds - 1:
            if history is None:
                return Action.C
            t = state.round_number - 1
            my_action = history.my_actions[t]
            opponent_actions = history.opponent_actions[t]
            coops = my_action + np.sum(opponent_actions)
            if coops >= self.m:
                return Action.C
            else:
                return Action.D
        else:
            if history is None:
                return Action.C
            met = 0
            for round in range(state.round_number):
                if round >= len(history.my_actions):
                    break
                my_action = history.my_actions[round]
                opponent_actions = history.opponent_actions[round]
                coops = my_action + np.sum(opponent_actions)
                if coops >= self.m:
                    met += 1
            total_rounds = state.round_number
            proportion = met / total_rounds
            if proportion >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_488(BaseStrategy):
    """
    Exploitative Strategy for N-Player Public Goods Game.

    This strategy starts by cooperating to encourage others, then continues to 
    cooperate if sufficient players cooperated previously. It defects otherwise but 
    resets cooperation after three consecutive defections.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        prev_round = state.round_number - 1
        consecutive_d = 0
        for i in range(1, 4 + 1):
            round_to_check = prev_round - (i - 1)
            if round_to_check < 0:
                break
            if not history.my_actions[round_to_check]:
                consecutive_d += 1
            else:
                break
        if consecutive_d >= 3:
            return Action.C
        else:
            prev_my_action = history.my_actions[prev_round]
            my_prev_coop = 1 if prev_my_action else 0
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            opponents_prev_coop = opponents_prev_actions.sum()
            total_prev_coop = my_prev_coop + opponents_prev_coop
            if total_prev_coop >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_493(BaseStrategy):
    """
    Adaptive cooperation strategy based on recent history of cooperation.
    Cooperates in the first round, then cooperates if at least half of the players
    (rounded down) cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_actions = history.my_actions
        my_prev_action = my_actions[prev_round]
        my_c = 1 if my_prev_action else 0
        opponent_prev_actions = history.opponent_actions[prev_round]
        opp_c = sum(opponent_prev_actions)
        prev_total = my_c + opp_c
        if prev_total >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_494(BaseStrategy):
    """
    History-Based Conditional Cooperation Strategy.
    
    This strategy begins by Cooperating in the first round. In subsequent rounds, 
    it Cooperates again if at least m players Cooperated in the previous round; 
    otherwise, it Defects. The threshold m is calculated as the ceiling of the 
    number of players divided by the multiplication factor k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0 or history is None:
            return Action.C
        else:
            prev_my_action = history.my_actions[-1]
            prev_opponents_actions = history.opponent_actions[-1, :]
            num_coop = prev_my_action + sum(prev_opponents_actions)
            return Action.C if num_coop >= self.m else Action.D

class Strategy_EXPLOITATIVE_495(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on past outcomes.
    Cooperates initially, continues if enough players cooperate previously, and defects in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round]
            total_coop = my_prev_action + np.sum(opp_prev_actions)
            m = self.game_description.n_players // 2
            if total_coop >= m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_496(BaseStrategy):
    """Adaptive Cooperation with Reset Strategy.
    
    This strategy begins by cooperating and adapts based on the number of cooperators
    in the previous round. If cooperation drops below a threshold (m = ceil(n/k)),
    the strategy defects. After two consecutive defections, it resets to cooperation.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self_prev = history.my_actions[-1]
        self_coop = 1 if self_prev else 0
        other_coop = sum(history.opponent_actions[-1])
        c_prev = self_coop + other_coop
        if c_prev >= self.m:
            return Action.C
        else:
            if len(history.my_actions) >= 2:
                last_two = history.my_actions[-2:]
                if not any(last_two):
                    return Action.C
            return Action.D

class Strategy_EXPLOITATIVE_497(BaseStrategy):
    """
    Adaptive Threshold Cooperator strategy based on previous round's cooperation level.
    Cooperates if previous round's cooperation meets or exceeds a calculated threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.floor(n / k) + 1
        self.m = min(self.m, n)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponents_actions = history.opponent_actions[prev_round, :]
        C_prev = 1 if prev_my_action else 0
        C_prev += np.sum(prev_opponents_actions)
        if C_prev >= self.m:
            return Action.C
        elif C_prev + 1 >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_498(BaseStrategy):

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.k = game_description.k
        self.m = self.n_players // 2
        self.waiting_until = 0
        self.coop_payoffs = []
        self.defect_payoffs = []

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        if history:
            prev_round = current_round - 1
            if prev_round >= 0:
                my_prev_action = history.my_actions[prev_round]
                my_prev_payoff = history.my_payoffs[prev_round]
                if my_prev_action:
                    self.coop_payoffs.append(my_prev_payoff)
                else:
                    self.defect_payoffs.append(my_prev_payoff)
        if current_round == self.n_rounds - 1:
            defect_avg = sum(self.defect_payoffs) / len(self.defect_payoffs) if self.defect_payoffs else 0
            coop_avg = sum(self.coop_payoffs) / len(self.coop_payoffs) if self.coop_payoffs else 0
            return Action.D if defect_avg > coop_avg else Action.C
        if current_round < self.waiting_until:
            return Action.D
        prev_round = current_round - 1
        my_prev_act = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        total_coop = my_prev_act + sum(opponents_prev_actions)
        if total_coop >= self.m:
            return Action.C
        else:
            remaining_rounds = self.n_rounds - current_round
            max_wait = min(self.m, remaining_rounds)
            self.waiting_until = current_round + max_wait
            if self.waiting_until > self.n_rounds - 1:
                self.waiting_until = self.n_rounds - 1
            return Action.D

class Strategy_EXPLOITATIVE_499(BaseStrategy):
    """
    Exploitative Cooperation Strategy based on past performance.
    Cooperates initially and defects if enough players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // 2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        prev_opponent_actions = history.opponent_actions[previous_round]
        prev_my_action = history.my_actions[previous_round]
        prev_coops = sum(prev_opponent_actions) + prev_my_action
        if prev_coops >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_500(BaseStrategy):
    """
    A strategy that starts with cooperation and then decides to defect based on meeting a cooperation threshold.
    Uses the Public Goods Game parameters to determine the threshold dynamically.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        my_coop_last = history.my_actions[state.round_number - 1]
        opponent_coop_last = history.opponent_actions[state.round_number - 1]
        cooperators_last = my_coop_last + np.sum(opponent_coop_last)
        if cooperators_last >= self.m + 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_501(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game where each player cooperates 
    in the first round and continues cooperating if at least a threshold number 
    of players cooperated in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.k = game_description.k
        self.m = int(math.ceil(self.n / self.k))

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        sum_opponents = history.opponent_actions[prev_round, :].sum()
        my_prev = history.my_actions[prev_round]
        total_coop = sum_opponents + (1 if my_prev else 0)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_502(BaseStrategy):
    """
    Adaptive Cooperation Based on Historical Performance strategy.
    Cooperates initially and continues if the average number of cooperators meets a threshold based on k.
    Defects otherwise, but can return to cooperation as others' behavior improves.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_prev_rounds = len(history.my_actions)
        total_cooperators = 0.0
        for t in range(n_prev_rounds):
            opponents_round = history.opponent_actions[t, :]
            opponent_c = np.sum(opponents_round)
            self_c = 1 if history.my_actions[t] else 0
            total_cooperators += opponent_c + self_c
        average_cooperators = total_cooperators / n_prev_rounds
        if average_cooperators >= self.game_description.k:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_503(BaseStrategy):
    """
    Responsive Cooperation strategy to encourage cooperation when beneficial.
    Cooperates if the number of previous cooperators meets a threshold (m = ceil(n/k)).
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        sc = 1 if my_prev_action else 0
        sc += sum(opponent_prev_actions)
        if sc >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_504(BaseStrategy):
    """
    This strategy starts by cooperating in the first round. In subsequent rounds, it checks the number of cooperators from the previous round. 
    If this number is at least equal to the game's multiplication factor \\( k \\), the player defects; otherwise, they cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round] == Action.C
        s_prev = sum(history.opponent_actions[prev_round, :]) + (1 if my_prev_action else 0)
        threshold = self.game_description.k
        if s_prev >= threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_505(BaseStrategy):
    """
    A threshold-based adaptive strategy for the N-Player Public Goods Game.
    Cooperates initially and adapts based on the number of fellow cooperators in previous rounds.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(self.game_description.n_players / self.game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            s_prev_without_me = sum(opponent_actions_prev)
            if s_prev_without_me >= self.m:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_506(BaseStrategy):
    """
    This strategy cooperates in the first round, then uses the historical average of cooperators 
    to decide whether to cooperate or defect in subsequent rounds. It cooperates if adding its 
    own cooperation would meet a threshold derived from the game's parameters.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_coops = 0
        n_prev_rounds = state.round_number
        for t in range(n_prev_rounds):
            my_action = history.my_actions[t]
            opp_actions = history.opponent_actions[t]
            coops = my_action + opp_actions.sum()
            total_coops += coops
        average_S = total_coops / n_prev_rounds
        if average_S + 1 >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_507(BaseStrategy):
    """
    Cooperative strategy based on reactive cooperation with a threshold derived from game parameters.
    Cooperates if the number of cooperators in the previous round meets a calculated threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = self.game_description.n_players // self.game_description.k + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponents_prev = history.opponent_actions[prev_round]
            sum_prev = my_prev + np.sum(opponents_prev)
            if sum_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_508(BaseStrategy):
    """
    A strategy that initially cooperates and then decides based on historical success,
    cooperating if the proportion of successful rounds meets a threshold.
    Success is defined as having at least a majority of players cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.m = self.n_players // 2 + 1

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        success_count = 0
        for prev_round in range(state.round_number):
            my_action = history.my_actions[prev_round]
            opponents_actions = history.opponent_actions[prev_round, :]
            total_c = my_action + np.sum(opponents_actions)
            if total_c >= self.m:
                success_count += 1
        total_rounds = state.round_number
        success_rate = success_count / total_rounds
        threshold = self.m / self.n_players
        if success_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_509(BaseStrategy):
    """
    Adaptive Exploitative Cooperation Strategy.
    
    Cooperates in the first round and subsequent rounds based on the number of cooperators in the previous round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        n = game_description.n_players
        k = game_description.k
        self.m = math.ceil(n / k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round]
            s_prev = my_prev_action + sum(opp_prev_actions)
            if s_prev >= self.m:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_510(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that encourages cooperation
    based on the historical success of collective efforts.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.k = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        success_count = 0
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            sum_coop = int(my_action) + np.sum(history.opponent_actions[t, :])
            if sum_coop >= self.k:
                success_count += 1
        success_rate = success_count / state.round_number
        threshold = self.k / self.n_players
        if success_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_511(BaseStrategy):
    """
    A strategy for the N-Player Public Goods Game that uses a cooperation threshold to decide actions.
    Cooperates initially, then defects if the number of previous cooperators meets a threshold.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        prev_my_action = history.my_actions[previous_round]
        prev_coop_self = 1 if prev_my_action else 0
        prev_coop_others = sum(history.opponent_actions[previous_round, :])
        total_prev_coop = prev_coop_self + prev_coop_others
        if total_prev_coop >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_265(BaseStrategy):
    """
    Collective Risk Strategy: Cooperate initially, then adapt based on the number of successful past rounds.
    Defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / 2)

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        if round_number == 0:
            return Action.C
        elif round_number == n_rounds - 1:
            return Action.D
        if history is None:
            return Action.C
        successful_rounds = 0
        for r in range(round_number):
            my_action = history.my_actions[r]
            opp_actions = history.opponent_actions[r]
            total_coop = my_action + np.sum(opp_actions)
            if total_coop >= self.m:
                successful_rounds += 1
        total_past = round_number
        if total_past == 0:
            ratio = 0.0
        else:
            ratio = successful_rounds / total_past
        if ratio > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_484(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma. Starts with Cooperate and adapts based on previous cooperation levels.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m_threshold = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            my_prev_action = history.my_actions[state.round_number - 1]
            sum_my = 1 if my_prev_action else 0
            opponent_prev_actions = history.opponent_actions[state.round_number - 1]
            sum_opponent = np.sum(opponent_prev_actions)
            total_prev_coop = sum_my + sum_opponent
            return Action.C if total_prev_coop >= self.m_threshold else Action.D

class Strategy_EXPLOITATIVE_486(BaseStrategy):
    """
    An adaptive strategy for the N-player public goods game that encourages cooperation 
    while defecting strategically to maximize payoffs.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.k = game_description.k
        self.m = math.ceil(self.n / self.k)
        self.p = 1
        self.defect_counter = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.r - 1:
            if not history:
                return Action.C
            sum_prev_opponents = sum(history.opponent_actions[-1])
            payoff_c = self.k / self.n * (sum_prev_opponents + 1)
            payoff_d = 1 + self.k / self.n * sum_prev_opponents
            return Action.C if payoff_c > payoff_d else Action.D
        else:
            if not history:
                return Action.C
            prev_round = current_round - 1
            opponent_actions_prev = history.opponent_actions[prev_round]
            my_action_prev = history.my_actions[prev_round]
            coop_count_opponent = sum(opponent_actions_prev)
            my_coop = 1 if my_action_prev else 0
            coop_count_prev = coop_count_opponent + my_coop
            if coop_count_prev >= self.m:
                self.defect_counter = 0
                return Action.C
            elif self.defect_counter < self.p:
                self.defect_counter += 1
                return Action.D
            else:
                self.defect_counter = 0
                return Action.C

class Strategy_EXPLOITATIVE_487(BaseStrategy):
    """
    This strategy cooperates in the first round and then decides based on the number of cooperators in the previous round.
    It will defect if the number of cooperators exceeds the threshold m, which is set to the multiplication factor k.
    Otherwise, it continues to cooperate.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k

    def __call__(self, state: GameState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponents = history.opponent_actions[prev_round]
        total_coop = prev_my_action + np.sum(prev_opponents)
        if total_coop > self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_489(BaseStrategy):
    """
    Exploitative Strategy for Collective Risk Dilemma.
    
    This strategy begins with initial cooperation to encourage others to cooperate.
    It dynamically adjusts a threshold based on the cooperation rate observed in each round.
    If the cooperation rate falls below this threshold, the strategy switches to defecting.
    In the final round, it defects to avoid being exploited.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.threshold = 1.0
        self.alpha = 0.2

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_my_action = history.my_actions[state.round_number - 1]
        prev_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        my_c = 1 if prev_my_action else 0
        opponent_c = sum(prev_opponent_actions)
        total_c = my_c + opponent_c
        cooperation_rate = total_c / self.game_description.n_players
        if cooperation_rate < self.threshold:
            action = Action.D
        else:
            action = Action.C
        delta = cooperation_rate - self.threshold
        self.threshold += self.alpha * delta
        return action

class Strategy_EXPLOITATIVE_490(BaseStrategy):
    """
    An adaptive strategy for the N-Player Public Goods Game that encourages cooperation
    based on the number of previous cooperators, defects in the last round, and starts
    with cooperation in the first round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.n_players / game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round]
        total_coop = (1 if my_prev_action else 0) + np.sum(opponent_actions_prev)
        if total_coop >= self.m:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_491(BaseStrategy):
    """
    Exploitative Strategy for N-Player Public Goods Game.
    
    The strategy cooperates in the first round and then defects if the average number of cooperators
    in previous rounds meets a threshold based on the game's multiplication factor k.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = game_description.k

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        total_cooperators = 0
        for round_number in range(current_round):
            if history.my_actions[round_number]:
                total_cooperators += 1
            total_cooperators += np.sum(history.opponent_actions[round_number])
        average_cooperators = total_cooperators / current_round
        if average_cooperators >= self.m:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_492(BaseStrategy):
    """
    This strategy balances cooperation with strategic defection in an N-player public goods game.
    It cooperates initially to encourage others, defects when enough players have cooperated,
    and defects in the last round to maximize final payoff.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.m = math.ceil(game_description.k)

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            opponents_C = np.sum(opponent_actions_prev)
            my_action_prev = history.my_actions[prev_round]
            total_coop_prev = opponents_C + my_action_prev
            return Action.D if total_coop_prev >= self.m else Action.C

class Strategy_EXPLOITATIVE_512(BaseStrategy):
    """
    Enhanced Exploitative Adaptive Strategy (EEAS) for N-Player Public Goods Game.
    This strategy dynamically adjusts based on recent cooperation rates, defects
    when cooperation drops below a threshold, and considers overall cooperation
    trends in the final round.
    """

    def __init__(self, game_description: PublicGoodsDescription):
        self.game_description = game_description
        self.recent_cooperation = []
        self.defect_remaining = 0

    def __call__(self, state: GameState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        recent_rounds = []
        for r in range(max(0, state.round_number - 5), state.round_number):
            my_c = 1 if history.my_actions[r] else 0
            opp_cs = sum(history.opponent_actions[r, :])
            total_c = my_c + opp_cs
            rate = total_c / n_players
            recent_rounds.append(rate)
        average_recent = sum(recent_rounds) / len(recent_rounds) if recent_rounds else 0.0
        threshold = average_recent * 1.2
        threshold = min(threshold, 1.0)
        if state.round_number == self.game_description.n_rounds - 1:
            if average_recent >= threshold:
                return Action.C
            else:
                return Action.D
        if self.defect_remaining > 0:
            self.defect_remaining -= 1
            return Action.D
        shortfall = threshold - average_recent
        if shortfall <= 0:
            return Action.C
        defect_rounds = math.ceil(shortfall / 0.1)
        self.defect_remaining = defect_rounds
        return Action.D